
build-msm8953-secondary/lk:     file format elf32-littlearm


Disassembly of section .text.boot:

8f600000 <_start>:
#define ISB .byte 0x6f, 0xf0, 0x7f, 0xf5

.section ".text.boot"
.globl _start
_start:
	b	reset
8f600000:	ea000006 	b	8f600020 <reset>
	b	arm_undefined
8f600004:	ea00844a 	b	8f621134 <arm_undefined>
	b	arm_syscall
8f600008:	ea008450 	b	8f621150 <arm_syscall>
	b	arm_prefetch_abort
8f60000c:	ea008456 	b	8f62116c <arm_prefetch_abort>
	b	arm_data_abort
8f600010:	ea00845c 	b	8f621188 <arm_data_abort>
	b	arm_reserved
8f600014:	ea008462 	b	8f6211a4 <arm_reserved>
	b	arm_irq
8f600018:	ea008462 	b	8f6211a8 <arm_irq>
	b	arm_fiq
8f60001c:	ea008479 	b	8f621208 <arm_fiq>

8f600020 <reset>:

reset:
	adr r7, lk_boot_args
8f600020:	e28f7054 	add	r7, r15, #84	; 0x54
	stmia r7!, {r0-r3}
8f600024:	e8a7000f 	stmia	r7!, {r0, r1, r2, r3}
	ldr r7, =_binary_tzbsp_tzbsp_bin_start
#endif
	/* do some cpu setup */
#if ARM_WITH_CP15
        /* Read SCTLR */
	mrc		p15, 0, r0, c1, c0, 0
8f600028:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
		/* XXX this is currently for arm926, revist with armv6 cores */
		/* new thumb behavior, low exception vectors, i/d cache disable, mmu disabled */
	bic		r0, r0, #(1<<15| 1<<13 | 1<<12)
8f60002c:	e3c00a0b 	bic	r0, r0, #45056	; 0xb000
	bic		r0, r0, #(1<<2 | 1<<0)
8f600030:	e3c00005 	bic	r0, r0, #5
		/* disable alignment faults */
	bic		r0, r0, #(1<<1)
8f600034:	e3c00002 	bic	r0, r0, #2
	/* Enable CP15 barriers by default */
#ifdef ARM_CORE_V8
	orr		r0, r0, #(1<<5)
8f600038:	e3800020 	orr	r0, r0, #32
#endif
        /* Write SCTLR */
	mcr		p15, 0, r0, c1, c0, 0
8f60003c:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
	str	r0, warm_boot_tag
#endif
#endif

	/* see if we need to relocate */
	mov		r0, pc
8f600040:	e1a0000f 	mov	r0, r15
	sub		r0, r0, #(.Laddr - _start)
8f600044:	e2400048 	sub	r0, r0, #72	; 0x48
.Laddr:
	ldr		r1, =_start
8f600048:	e59f1020 	ldr	r1, [pc, #32]	; 8f600070 <reset+0x50>
	cmp		r0, r1
8f60004c:	e1500001 	cmp	r0, r1
	beq		.Lstack_setup
8f600050:	0a00000d 	beq	8f60008c <lk_boot_args+0x10>

	/* we need to relocate ourselves to the proper spot */
	ldr		r2, =__data_end	
8f600054:	e59f2018 	ldr	r2, [pc, #24]	; 8f600074 <reset+0x54>

.Lrelocate_loop:
	ldr		r3, [r0], #4
8f600058:	e4903004 	ldr	r3, [r0], #4
	str		r3, [r1], #4
8f60005c:	e4813004 	str	r3, [r1], #4
	cmp		r1, r2
8f600060:	e1510002 	cmp	r1, r2
	bne		.Lrelocate_loop
8f600064:	1afffffb 	bne	8f600058 <reset+0x38>

	/* we're relocated, jump to the right address */
	ldr		r0, =.Lstack_setup
8f600068:	e59f0008 	ldr	r0, [pc, #8]	; 8f600078 <reset+0x58>
	bx		r0
8f60006c:	e12fff10 	bx	r0
	ldr		r1, =_start
8f600070:	8f600000 	.word	0x8f600000
	ldr		r2, =__data_end	
8f600074:	8f724614 	.word	0x8f724614
	ldr		r0, =.Lstack_setup
8f600078:	8f60008c 	.word	0x8f60008c

8f60007c <lk_boot_args>:
	...
	.word 0
	.word 0

.Lstack_setup:
	/* set up the stack for irq, fiq, abort, undefined, system/user, and lastly supervisor mode */
	mrs     r0, cpsr
8f60008c:	e10f0000 	mrs	r0, CPSR
	bic     r0, r0, #0x1f
8f600090:	e3c0001f 	bic	r0, r0, #31

	ldr		r2, =abort_stack_top
8f600094:	e59f2090 	ldr	r2, [pc, #144]	; 8f60012c <lk_boot_args+0xb0>
	orr     r1, r0, #0x12 // irq
8f600098:	e3801012 	orr	r1, r0, #18
	msr     cpsr_c, r1
8f60009c:	e121f001 	msr	CPSR_c, r1
	ldr		r13, =irq_save_spot		/* save a pointer to a temporary dumping spot used during irq delivery */
8f6000a0:	e59fd088 	ldr	r13, [pc, #136]	; 8f600130 <lk_boot_args+0xb4>
	    
	orr     r1, r0, #0x11 // fiq
8f6000a4:	e3801011 	orr	r1, r0, #17
	msr     cpsr_c, r1
8f6000a8:	e121f001 	msr	CPSR_c, r1
	mov		sp, r2
8f6000ac:	e1a0d002 	mov	r13, r2
	            
	orr     r1, r0, #0x17 // abort
8f6000b0:	e3801017 	orr	r1, r0, #23
	msr     cpsr_c, r1
8f6000b4:	e121f001 	msr	CPSR_c, r1
	mov		sp, r2
8f6000b8:	e1a0d002 	mov	r13, r2
	    
	orr     r1, r0, #0x1b // undefined
8f6000bc:	e380101b 	orr	r1, r0, #27
	msr     cpsr_c, r1
8f6000c0:	e121f001 	msr	CPSR_c, r1
	mov		sp, r2
8f6000c4:	e1a0d002 	mov	r13, r2
	    
	orr     r1, r0, #0x1f // system
8f6000c8:	e380101f 	orr	r1, r0, #31
	msr     cpsr_c, r1
8f6000cc:	e121f001 	msr	CPSR_c, r1
	mov		sp, r2
8f6000d0:	e1a0d002 	mov	r13, r2

	orr		r1, r0, #0x13 // supervisor
8f6000d4:	e3801013 	orr	r1, r0, #19
	msr		cpsr_c, r1
8f6000d8:	e121f001 	msr	CPSR_c, r1
	mov		sp, r2
8f6000dc:	e1a0d002 	mov	r13, r2

	/* copy the initialized data segment out of rom if necessary */
	ldr		r0, =__data_start_rom
8f6000e0:	e59f004c 	ldr	r0, [pc, #76]	; 8f600134 <lk_boot_args+0xb8>
	ldr		r1, =__data_start
8f6000e4:	e59f104c 	ldr	r1, [pc, #76]	; 8f600138 <lk_boot_args+0xbc>
	ldr		r2, =__data_end
8f6000e8:	e59f204c 	ldr	r2, [pc, #76]	; 8f60013c <lk_boot_args+0xc0>

	cmp		r0, r1
8f6000ec:	e1500001 	cmp	r0, r1
	beq		.L__do_bss
8f6000f0:	0a000003 	beq	8f600104 <lk_boot_args+0x88>

.L__copy_loop:
	cmp		r1, r2
8f6000f4:	e1510002 	cmp	r1, r2
	ldrlt	r3, [r0], #4
8f6000f8:	b4903004 	ldrlt	r3, [r0], #4
	strlt	r3, [r1], #4
8f6000fc:	b4813004 	strlt	r3, [r1], #4
	blt		.L__copy_loop
8f600100:	bafffffb 	blt	8f6000f4 <lk_boot_args+0x78>

.L__do_bss:
	/* clear out the bss */
	ldr		r0, =__bss_start
8f600104:	e59f0034 	ldr	r0, [pc, #52]	; 8f600140 <lk_boot_args+0xc4>
	ldr		r1, =_end
8f600108:	e59f1034 	ldr	r1, [pc, #52]	; 8f600144 <lk_boot_args+0xc8>
	mov		r2, #0
8f60010c:	e3a02000 	mov	r2, #0
.L__bss_loop:
	cmp		r0, r1
8f600110:	e1500001 	cmp	r0, r1
	strlt	r2, [r0], #4
8f600114:	b4802004 	strlt	r2, [r0], #4
	blt		.L__bss_loop
8f600118:	bafffffc 	blt	8f600110 <lk_boot_args+0x94>
8f60011c:	f57ff04f 	.word	0xf57ff04f
8f600120:	f57ff06f 	.word	0xf57ff06f
#ifdef ARM_CPU_CORTEX_A8
	DSB
	ISB
#endif

	bl		kmain
8f600124:	eb008b3f 	bl	8f622e28 <kmain>
	b		.
8f600128:	eafffffe 	b	8f600128 <lk_boot_args+0xac>
	ldr		r2, =abort_stack_top
8f60012c:	8f729000 	.word	0x8f729000
	ldr		r13, =irq_save_spot		/* save a pointer to a temporary dumping spot used during irq delivery */
8f600130:	8f72d19c 	.word	0x8f72d19c
	ldr		r0, =__data_start_rom
8f600134:	8f70c0a4 	.word	0x8f70c0a4
	ldr		r1, =__data_start
8f600138:	8f70c0a4 	.word	0x8f70c0a4
	ldr		r2, =__data_end
8f60013c:	8f724614 	.word	0x8f724614
	ldr		r0, =__bss_start
8f600140:	8f724614 	.word	0x8f724614
	ldr		r1, =_end
8f600144:	8f759430 	.word	0x8f759430

Disassembly of section .text:

8f600148 <set_sdc_power_ctrl>:
	return ret;
}
#endif

static void set_sdc_power_ctrl(uint8_t slot)
{
8f600148:	e59f312c 	ldr	r3, [pc, #300]	; 8f60027c <set_sdc_power_ctrl+0x134>
	uint32_t reg = 0;
	uint8_t clk;
	uint8_t cmd;
	uint8_t dat;

	if(slot == 1)
8f60014c:	e3500001 	cmp	r0, #1
{
8f600150:	e92d4030 	push	{r4, r5, r14}
8f600154:	e24dd05c 	sub	r13, r13, #92	; 0x5c
8f600158:	e5933000 	ldr	r3, [r3]
8f60015c:	e58d3054 	str	r3, [r13, #84]	; 0x54
8f600160:	e3a03000 	mov	r3, #0
	if(slot == 1)
8f600164:	0a000040 	beq	8f60026c <set_sdc_power_ctrl+0x124>
		clk = TLMM_CUR_VAL_16MA;
		cmd = TLMM_CUR_VAL_10MA;
		dat = TLMM_CUR_VAL_10MA;
		reg = SDC1_HDRV_PULL_CTL;
	}
	else if(slot == 2)
8f600168:	e3500002 	cmp	r0, #2
	{
		clk = TLMM_CUR_VAL_16MA;
		cmd = TLMM_CUR_VAL_10MA;
		dat = TLMM_CUR_VAL_10MA;
		reg = SDC2_HDRV_PULL_CTL;
8f60016c:	03a03a09 	moveq	r3, #36864	; 0x9000
8f600170:	03403110 	movteq	r3, #272	; 0x110
	else if(slot == 2)
8f600174:	1a000031 	bne	8f600240 <set_sdc_power_ctrl+0xf8>
		dprintf(CRITICAL,"Unsupported SDC slot passed\n");
		return;
	}

	/* Drive strength configs for sdc pins */
	struct tlmm_cfgs sdc1_hdrv_cfg[] =
8f600178:	e3a02006 	mov	r2, #6
8f60017c:	e58d200c 	str	r2, [r13, #12]
8f600180:	e3002707 	movw	r2, #1799	; 0x707
8f600184:	e1cd21b0 	strh	r2, [r13, #16]
8f600188:	e3a02000 	mov	r2, #0
8f60018c:	e58d2024 	str	r2, [r13, #36]	; 0x24
		{ SDC1_CLK_PULL_CTL_OFF,  TLMM_NO_PULL, TLMM_PULL_MASK, reg},
		{ SDC1_CMD_PULL_CTL_OFF,  TLMM_PULL_UP, TLMM_PULL_MASK, reg},
		{ SDC1_DATA_PULL_CTL_OFF, TLMM_PULL_UP, TLMM_PULL_MASK, reg},
	};

	struct tlmm_cfgs sdc1_rclk_cfg[] =
8f600190:	e3002268 	movw	r2, #616	; 0x268
8f600194:	e3482f70 	movt	r2, #36720	; 0x8f70
	struct tlmm_cfgs sdc1_hdrv_cfg[] =
8f600198:	e3000704 	movw	r0, #1796	; 0x704
	struct tlmm_cfgs sdc1_pull_cfg[] =
8f60019c:	e3001303 	movw	r1, #771	; 0x303
	struct tlmm_cfgs sdc1_hdrv_cfg[] =
8f6001a0:	e1cd01bc 	strh	r0, [r13, #28]
8f6001a4:	e3a05003 	mov	r5, #3
8f6001a8:	e1cd02b8 	strh	r0, [r13, #40]	; 0x28
	struct tlmm_cfgs sdc1_rclk_cfg[] =
8f6001ac:	e1a0400d 	mov	r4, r13
	struct tlmm_cfgs sdc1_pull_cfg[] =
8f6001b0:	e1cd14b0 	strh	r1, [r13, #64]	; 0x40
8f6001b4:	e3a0c00d 	mov	r12, #13
8f6001b8:	e1cd14bc 	strh	r1, [r13, #76]	; 0x4c
	struct tlmm_cfgs sdc1_rclk_cfg[] =
8f6001bc:	e8920007 	ldm	r2, {r0, r1, r2}
	struct tlmm_cfgs sdc1_pull_cfg[] =
8f6001c0:	e58dc030 	str	r12, [r13, #48]	; 0x30
	struct tlmm_cfgs sdc1_hdrv_cfg[] =
8f6001c4:	e58d3014 	str	r3, [r13, #20]
8f6001c8:	e58d3020 	str	r3, [r13, #32]
	struct tlmm_cfgs sdc1_rclk_cfg[] =
8f6001cc:	e8840007 	stm	r4, {r0, r1, r2}
	{
		{ SDC1_RCLK_PULL_CTL_OFF, TLMM_PULL_DOWN, TLMM_PULL_MASK, 0},
	};

	/* Set the drive strength & pull control values */
	tlmm_set_hdrive_ctrl(sdc1_hdrv_cfg, ARRAY_SIZE(sdc1_hdrv_cfg));
8f6001d0:	e28d000c 	add	r0, r13, #12
8f6001d4:	e1a01005 	mov	r1, r5
	struct tlmm_cfgs sdc1_hdrv_cfg[] =
8f6001d8:	e58d302c 	str	r3, [r13, #44]	; 0x2c
	struct tlmm_cfgs sdc1_pull_cfg[] =
8f6001dc:	e58d3038 	str	r3, [r13, #56]	; 0x38
8f6001e0:	e58d3044 	str	r3, [r13, #68]	; 0x44
8f6001e4:	e58d3050 	str	r3, [r13, #80]	; 0x50
8f6001e8:	e3a03c03 	mov	r3, #768	; 0x300
	struct tlmm_cfgs sdc1_hdrv_cfg[] =
8f6001ec:	e58d5018 	str	r5, [r13, #24]
	struct tlmm_cfgs sdc1_pull_cfg[] =
8f6001f0:	e1cd33b4 	strh	r3, [r13, #52]	; 0x34
8f6001f4:	e3a0300b 	mov	r3, #11
8f6001f8:	e58d303c 	str	r3, [r13, #60]	; 0x3c
8f6001fc:	e3a03009 	mov	r3, #9
8f600200:	e58d3048 	str	r3, [r13, #72]	; 0x48
	tlmm_set_hdrive_ctrl(sdc1_hdrv_cfg, ARRAY_SIZE(sdc1_hdrv_cfg));
8f600204:	eb006689 	bl	8f619c30 <tlmm_set_hdrive_ctrl>
	tlmm_set_pull_ctrl(sdc1_pull_cfg, ARRAY_SIZE(sdc1_pull_cfg));
8f600208:	e28d0030 	add	r0, r13, #48	; 0x30
8f60020c:	e1a01005 	mov	r1, r5
8f600210:	eb0066ad 	bl	8f619ccc <tlmm_set_pull_ctrl>
	tlmm_set_pull_ctrl(sdc1_rclk_cfg, ARRAY_SIZE(sdc1_rclk_cfg));
8f600214:	e3a01001 	mov	r1, #1
8f600218:	e1a00004 	mov	r0, r4
8f60021c:	eb0066aa 	bl	8f619ccc <tlmm_set_pull_ctrl>
}
8f600220:	e59f3054 	ldr	r3, [pc, #84]	; 8f60027c <set_sdc_power_ctrl+0x134>
8f600224:	e5932000 	ldr	r2, [r3]
8f600228:	e59d3054 	ldr	r3, [r13, #84]	; 0x54
8f60022c:	e0332002 	eors	r2, r3, r2
8f600230:	e3a03000 	mov	r3, #0
8f600234:	1a00000f 	bne	8f600278 <set_sdc_power_ctrl+0x130>
8f600238:	e28dd05c 	add	r13, r13, #92	; 0x5c
8f60023c:	e8bd8030 	pop	{r4, r5, r15}
		dprintf(CRITICAL,"Unsupported SDC slot passed\n");
8f600240:	e59f3034 	ldr	r3, [pc, #52]	; 8f60027c <set_sdc_power_ctrl+0x134>
8f600244:	e5932000 	ldr	r2, [r3]
8f600248:	e59d3054 	ldr	r3, [r13, #84]	; 0x54
8f60024c:	e0332002 	eors	r2, r3, r2
8f600250:	e3a03000 	mov	r3, #0
8f600254:	1a000007 	bne	8f600278 <set_sdc_power_ctrl+0x130>
8f600258:	e3000000 	movw	r0, #0
8f60025c:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f600260:	e28dd05c 	add	r13, r13, #92	; 0x5c
8f600264:	e8bd4030 	pop	{r4, r5, r14}
		dprintf(CRITICAL,"Unsupported SDC slot passed\n");
8f600268:	ea00c9c1 	b	8f632974 <_dprintf>
		reg = SDC1_HDRV_PULL_CTL;
8f60026c:	e3a03a0a 	mov	r3, #40960	; 0xa000
8f600270:	e3403110 	movt	r3, #272	; 0x110
8f600274:	eaffffbf 	b	8f600178 <set_sdc_power_ctrl+0x30>
}
8f600278:	eb00ca50 	bl	8f632bc0 <__stack_chk_fail>
8f60027c:	8f74221c 	.word	0x8f74221c

8f600280 <target_usb_phy_reset>:
		tcsr_hs_phy_mux_configure();
	}
}

void target_usb_phy_reset()
{
8f600280:	e59f303c 	ldr	r3, [pc, #60]	; 8f6002c4 <target_usb_phy_reset+0x44>
8f600284:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f600288:	e24dd00c 	sub	r13, r13, #12
8f60028c:	e5933000 	ldr	r3, [r3]
8f600290:	e58d3004 	str	r3, [r13, #4]
8f600294:	e3a03000 	mov	r3, #0

        usb30_qmp_phy_reset();
8f600298:	eb006725 	bl	8f619f34 <usb30_qmp_phy_reset>
        qusb2_phy_reset();
8f60029c:	e59f3020 	ldr	r3, [pc, #32]	; 8f6002c4 <target_usb_phy_reset+0x44>
8f6002a0:	e5932000 	ldr	r2, [r3]
8f6002a4:	e59d3004 	ldr	r3, [r13, #4]
8f6002a8:	e0332002 	eors	r2, r3, r2
8f6002ac:	e3a03000 	mov	r3, #0
8f6002b0:	1a000002 	bne	8f6002c0 <target_usb_phy_reset+0x40>
}
8f6002b4:	e28dd00c 	add	r13, r13, #12
8f6002b8:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
        qusb2_phy_reset();
8f6002bc:	ea006847 	b	8f61a3e0 <qusb2_phy_reset>
8f6002c0:	eb00ca3e 	bl	8f632bc0 <__stack_chk_fail>
8f6002c4:	8f74221c 	.word	0x8f74221c

8f6002c8 <target_load_ssd_keystore.part.0>:
		clock_ce_enable(CE1_INSTANCE);
		target_load_ssd_keystore();
	}
}

void target_load_ssd_keystore(void)
8f6002c8:	e59f3168 	ldr	r3, [pc, #360]	; 8f600438 <target_load_ssd_keystore.part.0+0x170>
	uint32_t *buffer = NULL;

	if (!target_is_ssd_enabled())
		return;

	index = partition_get_index("ssd");
8f6002cc:	e3000020 	movw	r0, #32
void target_load_ssd_keystore(void)
8f6002d0:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	index = partition_get_index("ssd");
8f6002d4:	e3480f70 	movt	r0, #36720	; 0x8f70
void target_load_ssd_keystore(void)
8f6002d8:	e24dd00c 	sub	r13, r13, #12
8f6002dc:	e5933000 	ldr	r3, [r3]
8f6002e0:	e58d3004 	str	r3, [r13, #4]
8f6002e4:	e3a03000 	mov	r3, #0
	index = partition_get_index("ssd");
8f6002e8:	eb000e67 	bl	8f603c8c <partition_get_index>
8f6002ec:	e1a05000 	mov	r5, r0

	ptn = partition_get_offset(index);
8f6002f0:	eb001171 	bl	8f6048bc <partition_get_offset>
	if (ptn == 0){
8f6002f4:	e1903001 	orrs	r3, r0, r1
8f6002f8:	0a00002f 	beq	8f6003bc <target_load_ssd_keystore.part.0+0xf4>
		dprintf(CRITICAL, "Error: ssd partition not found\n");
		return;
	}

	size = partition_get_size(index);
8f6002fc:	e1a07000 	mov	r7, r0
8f600300:	e1a00005 	mov	r0, r5
8f600304:	e1a04001 	mov	r4, r1
8f600308:	eb00114a 	bl	8f604838 <partition_get_size>
	if (size == 0) {
8f60030c:	e1903001 	orrs	r3, r0, r1
	size = partition_get_size(index);
8f600310:	e1a05000 	mov	r5, r0
	if (size == 0) {
8f600314:	0a00001d 	beq	8f600390 <target_load_ssd_keystore.part.0+0xc8>
		dprintf(CRITICAL, "Error: invalid ssd partition size\n");
		return;
	}

	buffer = memalign(CACHE_LINE, ROUNDUP(size, CACHE_LINE));
8f600318:	e280103f 	add	r1, r0, #63	; 0x3f
8f60031c:	e3a00040 	mov	r0, #64	; 0x40
8f600320:	e3c1103f 	bic	r1, r1, #63	; 0x3f
8f600324:	eb00cf46 	bl	8f634044 <memalign>
	if (!buffer) {
8f600328:	e2506000 	subs	r6, r0, #0
8f60032c:	0a000038 	beq	8f600414 <target_load_ssd_keystore.part.0+0x14c>
		dprintf(CRITICAL, "Error: allocating memory for ssd buffer\n");
		return;
	}

	if (mmc_read(ptn, buffer, size)) {
8f600330:	e1a03005 	mov	r3, r5
8f600334:	e1a00007 	mov	r0, r7
8f600338:	e1a01004 	mov	r1, r4
8f60033c:	e1a02006 	mov	r2, r6
8f600340:	eb003250 	bl	8f60cc88 <mmc_read>
8f600344:	e3500000 	cmp	r0, #0
8f600348:	1a000024 	bne	8f6003e0 <target_load_ssd_keystore.part.0+0x118>
		dprintf(CRITICAL, "Error: cannot read data\n");
		free(buffer);
		return;
	}

	clock_ce_enable(CE1_INSTANCE);
8f60034c:	e3a00001 	mov	r0, #1
8f600350:	eb000732 	bl	8f602020 <clock_ce_enable>
	scm_protect_keystore(buffer, size);
8f600354:	e1a01005 	mov	r1, r5
8f600358:	e1a00006 	mov	r0, r6
8f60035c:	eb0050bc 	bl	8f614654 <scm_protect_keystore>
	clock_ce_disable(CE1_INSTANCE);
8f600360:	e3a00001 	mov	r0, #1
8f600364:	eb0007ae 	bl	8f602224 <clock_ce_disable>
	free(buffer);
8f600368:	e59f30c8 	ldr	r3, [pc, #200]	; 8f600438 <target_load_ssd_keystore.part.0+0x170>
8f60036c:	e5932000 	ldr	r2, [r3]
8f600370:	e59d3004 	ldr	r3, [r13, #4]
8f600374:	e0332002 	eors	r2, r3, r2
8f600378:	e3a03000 	mov	r3, #0
8f60037c:	1a000016 	bne	8f6003dc <target_load_ssd_keystore.part.0+0x114>
8f600380:	e1a00006 	mov	r0, r6
}
8f600384:	e28dd00c 	add	r13, r13, #12
8f600388:	e8bd40f0 	pop	{r4, r5, r6, r7, r14}
	free(buffer);
8f60038c:	ea00cf5e 	b	8f63410c <free>
		dprintf(CRITICAL, "Error: invalid ssd partition size\n");
8f600390:	e59f30a0 	ldr	r3, [pc, #160]	; 8f600438 <target_load_ssd_keystore.part.0+0x170>
8f600394:	e5932000 	ldr	r2, [r3]
8f600398:	e59d3004 	ldr	r3, [r13, #4]
8f60039c:	e0332002 	eors	r2, r3, r2
8f6003a0:	e3a03000 	mov	r3, #0
8f6003a4:	03000044 	movweq	r0, #68	; 0x44
8f6003a8:	03480f70 	movteq	r0, #36720	; 0x8f70
8f6003ac:	1a00000a 	bne	8f6003dc <target_load_ssd_keystore.part.0+0x114>
}
8f6003b0:	e28dd00c 	add	r13, r13, #12
8f6003b4:	e8bd40f0 	pop	{r4, r5, r6, r7, r14}
		dprintf(CRITICAL, "Error: invalid ssd partition size\n");
8f6003b8:	ea00c96d 	b	8f632974 <_dprintf>
		dprintf(CRITICAL, "Error: ssd partition not found\n");
8f6003bc:	e59f3074 	ldr	r3, [pc, #116]	; 8f600438 <target_load_ssd_keystore.part.0+0x170>
8f6003c0:	e5932000 	ldr	r2, [r3]
8f6003c4:	e59d3004 	ldr	r3, [r13, #4]
8f6003c8:	e0332002 	eors	r2, r3, r2
8f6003cc:	e3a03000 	mov	r3, #0
8f6003d0:	03000024 	movweq	r0, #36	; 0x24
8f6003d4:	03480f70 	movteq	r0, #36720	; 0x8f70
8f6003d8:	0afffff4 	beq	8f6003b0 <target_load_ssd_keystore.part.0+0xe8>
	free(buffer);
8f6003dc:	eb00c9f7 	bl	8f632bc0 <__stack_chk_fail>
		dprintf(CRITICAL, "Error: cannot read data\n");
8f6003e0:	e3000094 	movw	r0, #148	; 0x94
8f6003e4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6003e8:	eb00c961 	bl	8f632974 <_dprintf>
		free(buffer);
8f6003ec:	e59f3044 	ldr	r3, [pc, #68]	; 8f600438 <target_load_ssd_keystore.part.0+0x170>
8f6003f0:	e5932000 	ldr	r2, [r3]
8f6003f4:	e59d3004 	ldr	r3, [r13, #4]
8f6003f8:	e0332002 	eors	r2, r3, r2
8f6003fc:	e3a03000 	mov	r3, #0
8f600400:	1afffff5 	bne	8f6003dc <target_load_ssd_keystore.part.0+0x114>
	free(buffer);
8f600404:	e1a00006 	mov	r0, r6
}
8f600408:	e28dd00c 	add	r13, r13, #12
8f60040c:	e8bd40f0 	pop	{r4, r5, r6, r7, r14}
	free(buffer);
8f600410:	ea00cf3d 	b	8f63410c <free>
		dprintf(CRITICAL, "Error: allocating memory for ssd buffer\n");
8f600414:	e59f301c 	ldr	r3, [pc, #28]	; 8f600438 <target_load_ssd_keystore.part.0+0x170>
8f600418:	e5932000 	ldr	r2, [r3]
8f60041c:	e59d3004 	ldr	r3, [r13, #4]
8f600420:	e0332002 	eors	r2, r3, r2
8f600424:	e3a03000 	mov	r3, #0
8f600428:	03000068 	movweq	r0, #104	; 0x68
8f60042c:	03480f70 	movteq	r0, #36720	; 0x8f70
8f600430:	0affffde 	beq	8f6003b0 <target_load_ssd_keystore.part.0+0xe8>
8f600434:	eaffffe8 	b	8f6003dc <target_load_ssd_keystore.part.0+0x114>
8f600438:	8f74221c 	.word	0x8f74221c

8f60043c <target_early_init>:
{
8f60043c:	e59f3048 	ldr	r3, [pc, #72]	; 8f60048c <target_early_init+0x50>
8f600440:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f600444:	e24dd00c 	sub	r13, r13, #12
8f600448:	e5933000 	ldr	r3, [r3]
8f60044c:	e58d3004 	str	r3, [r13, #4]
8f600450:	e3a03000 	mov	r3, #0
	uart_dm_init(1, 0, BLSP1_UART0_BASE);
8f600454:	e59f3030 	ldr	r3, [pc, #48]	; 8f60048c <target_early_init+0x50>
8f600458:	e5932000 	ldr	r2, [r3]
8f60045c:	e59d3004 	ldr	r3, [r13, #4]
8f600460:	e0332002 	eors	r2, r3, r2
8f600464:	e3a03000 	mov	r3, #0
8f600468:	1a000006 	bne	8f600488 <target_early_init+0x4c>
8f60046c:	e3a02a0f 	mov	r2, #61440	; 0xf000
8f600470:	e3a01000 	mov	r1, #0
8f600474:	e340278a 	movt	r2, #1930	; 0x78a
8f600478:	e3a00001 	mov	r0, #1
}
8f60047c:	e28dd00c 	add	r13, r13, #12
8f600480:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	uart_dm_init(1, 0, BLSP1_UART0_BASE);
8f600484:	ea003ed0 	b	8f60ffcc <uart_dm_init>
8f600488:	eb00c9cc 	bl	8f632bc0 <__stack_chk_fail>
8f60048c:	8f74221c 	.word	0x8f74221c

8f600490 <target_sdc_init>:
{
8f600490:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	config.slot         = 1;
8f600494:	e3a06001 	mov	r6, #1
{
8f600498:	e24dd04c 	sub	r13, r13, #76	; 0x4c
8f60049c:	e59f2198 	ldr	r2, [pc, #408]	; 8f60063c <target_sdc_init+0x1ac>
	dprintf(SPEW, "initialising mmc_slot =%u\n", 1);
8f6004a0:	e1a01006 	mov	r1, r6
8f6004a4:	e30000b0 	movw	r0, #176	; 0xb0
8f6004a8:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f6004ac:	e5922000 	ldr	r2, [r2]
8f6004b0:	e58d2044 	str	r2, [r13, #68]	; 0x44
8f6004b4:	e3a02000 	mov	r2, #0
	config.bus_width    = DATA_BUS_WIDTH_8BIT;
8f6004b8:	e1a0700e 	mov	r7, r14
8f6004bc:	e3a03002 	mov	r3, #2
	config.slot         = 1;
8f6004c0:	e5cd600c 	strb	r6, [r13, #12]
	dev = mmc_init(&config);
8f6004c4:	e3024214 	movw	r4, #8724	; 0x2214
	config.bus_width    = DATA_BUS_WIDTH_8BIT;
8f6004c8:	e1cd31bc 	strh	r3, [r13, #28]
	config.max_clk_rate = MMC_CLK_192MHZ;
8f6004cc:	e3a03a0b 	mov	r3, #45056	; 0xb000
	config.hs400_support = 1;
8f6004d0:	e5cd6025 	strb	r6, [r13, #37]	; 0x25
	config.max_clk_rate = MMC_CLK_192MHZ;
8f6004d4:	e3403b71 	movt	r3, #2929	; 0xb71
8f6004d8:	e58d3020 	str	r3, [r13, #32]
	config.sdhc_base    = mmc_sdhci_base[config.slot - 1];
8f6004dc:	e3a03c49 	mov	r3, #18688	; 0x4900
8f6004e0:	e3403782 	movt	r3, #1922	; 0x782
8f6004e4:	e58d3014 	str	r3, [r13, #20]
	config.pwrctl_base  = mmc_pwrctl_base[config.slot - 1];
8f6004e8:	e3a03901 	mov	r3, #16384	; 0x4000
8f6004ec:	e3403782 	movt	r3, #1922	; 0x782
8f6004f0:	e58d3018 	str	r3, [r13, #24]
	config.pwr_irq      = mmc_sdc_pwrctl_irq[config.slot - 1];
8f6004f4:	e3a030aa 	mov	r3, #170	; 0xaa
8f6004f8:	e58d3010 	str	r3, [r13, #16]
	dprintf(SPEW, "initialising mmc_slot =%u\n", 1);
8f6004fc:	eb00c91c 	bl	8f632974 <_dprintf>
	set_sdc_power_ctrl(config.slot);
8f600500:	e5dd000c 	ldrb	r0, [r13, #12]
	dev = mmc_init(&config);
8f600504:	e3484f74 	movt	r4, #36724	; 0x8f74
	set_sdc_power_ctrl(config.slot);
8f600508:	ebffff0e 	bl	8f600148 <set_sdc_power_ctrl>
	dev = mmc_init(&config);
8f60050c:	e28d000c 	add	r0, r13, #12
8f600510:	eb0028f3 	bl	8f60a8e4 <mmc_init>
	emmc_dev = dev;
8f600514:	e3025224 	movw	r5, #8740	; 0x2224
8f600518:	e3485f74 	movt	r5, #36724	; 0x8f74
	if (!emmc_dev) {
8f60051c:	e3500000 	cmp	r0, #0
	dev = mmc_init(&config);
8f600520:	e5840000 	str	r0, [r4]
	emmc_dev = dev;
8f600524:	e5850000 	str	r0, [r5]
	if (!emmc_dev) {
8f600528:	0a00003d 	beq	8f600624 <target_sdc_init+0x194>
	dprintf(SPEW, "initialising mmc_slot =%u\n", 2);
8f60052c:	e3a01002 	mov	r1, #2
8f600530:	e30000b0 	movw	r0, #176	; 0xb0
8f600534:	e3480f70 	movt	r0, #36720	; 0x8f70
	sdcard_dev = mmc_init(&sd_config);
8f600538:	e3026218 	movw	r6, #8728	; 0x2218
	dprintf(SPEW, "initialising mmc_slot =%u\n", 2);
8f60053c:	eb00c90c 	bl	8f632974 <_dprintf>
	sd_config.slot         = 2;
8f600540:	e3a00002 	mov	r0, #2
	sd_config.bus_width    = DATA_BUS_WIDTH_4BIT;
8f600544:	e3a03001 	mov	r3, #1
	sd_config.slot         = 2;
8f600548:	e5cd0028 	strb	r0, [r13, #40]	; 0x28
	sd_config.bus_width    = DATA_BUS_WIDTH_4BIT;
8f60054c:	e1cd33b8 	strh	r3, [r13, #56]	; 0x38
	sdcard_dev = mmc_init(&sd_config);
8f600550:	e3486f74 	movt	r6, #36724	; 0x8f74
	sd_config.hs400_support = 1;
8f600554:	e5cd3041 	strb	r3, [r13, #65]	; 0x41
	sd_config.max_clk_rate = MMC_CLK_177MHZ;
8f600558:	e3083e10 	movw	r3, #36368	; 0x8e10
8f60055c:	e3403a98 	movt	r3, #2712	; 0xa98
8f600560:	e58d303c 	str	r3, [r13, #60]	; 0x3c
	sd_config.sdhc_base    = mmc_sdhci_base[sd_config.slot - 1];
8f600564:	e3a03c49 	mov	r3, #18688	; 0x4900
8f600568:	e3403786 	movt	r3, #1926	; 0x786
8f60056c:	e58d3030 	str	r3, [r13, #48]	; 0x30
	sd_config.pwrctl_base  = mmc_pwrctl_base[sd_config.slot - 1];
8f600570:	e3a03901 	mov	r3, #16384	; 0x4000
8f600574:	e3403786 	movt	r3, #1926	; 0x786
8f600578:	e58d3034 	str	r3, [r13, #52]	; 0x34
	sd_config.pwr_irq      = mmc_sdc_pwrctl_irq[sd_config.slot - 1];
8f60057c:	e3a030fd 	mov	r3, #253	; 0xfd
8f600580:	e58d302c 	str	r3, [r13, #44]	; 0x2c
	set_sdc_power_ctrl(sd_config.slot);
8f600584:	ebfffeef 	bl	8f600148 <set_sdc_power_ctrl>
	sdcard_dev = mmc_init(&sd_config);
8f600588:	e28d0028 	add	r0, r13, #40	; 0x28
8f60058c:	eb0028d4 	bl	8f60a8e4 <mmc_init>
	if (!sdcard_dev) {
8f600590:	e3500000 	cmp	r0, #0
	sdcard_dev = mmc_init(&sd_config);
8f600594:	e5860000 	str	r0, [r6]
	if (!sdcard_dev) {
8f600598:	0a00000a 	beq	8f6005c8 <target_sdc_init+0x138>
	} else if (!dev) {
8f60059c:	e5943000 	ldr	r3, [r4]
8f6005a0:	e3530000 	cmp	r3, #0
		dev = sdcard_dev;
8f6005a4:	05840000 	streq	r0, [r4]
}
8f6005a8:	e59f308c 	ldr	r3, [pc, #140]	; 8f60063c <target_sdc_init+0x1ac>
8f6005ac:	e5932000 	ldr	r2, [r3]
8f6005b0:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f6005b4:	e0332002 	eors	r2, r3, r2
8f6005b8:	e3a03000 	mov	r3, #0
8f6005bc:	1a00001d 	bne	8f600638 <target_sdc_init+0x1a8>
8f6005c0:	e28dd04c 	add	r13, r13, #76	; 0x4c
8f6005c4:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		dprintf(CRITICAL, "sdcard init failed!");
8f6005c8:	e30000f0 	movw	r0, #240	; 0xf0
8f6005cc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6005d0:	eb00c8e7 	bl	8f632974 <_dprintf>
	if (!sdcard_dev && !emmc_dev) {
8f6005d4:	e5963000 	ldr	r3, [r6]
8f6005d8:	e3530000 	cmp	r3, #0
8f6005dc:	1afffff1 	bne	8f6005a8 <target_sdc_init+0x118>
8f6005e0:	e5953000 	ldr	r3, [r5]
8f6005e4:	e3530000 	cmp	r3, #0
8f6005e8:	1affffee 	bne	8f6005a8 <target_sdc_init+0x118>
		dprintf(CRITICAL, "BOTH SLOTS FAILED!");
8f6005ec:	e3000104 	movw	r0, #260	; 0x104
8f6005f0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6005f4:	eb00c8de 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f6005f8:	e307cf64 	movw	r12, #32612	; 0x7f64
8f6005fc:	e3002118 	movw	r2, #280	; 0x118
8f600600:	e348cf70 	movt	r12, #36720	; 0x8f70
8f600604:	e3482f70 	movt	r2, #36720	; 0x8f70
8f600608:	e3001130 	movw	r1, #304	; 0x130
8f60060c:	e300314a 	movw	r3, #330	; 0x14a
8f600610:	e3481f70 	movt	r1, #36720	; 0x8f70
8f600614:	e1a00007 	mov	r0, r7
8f600618:	e58dc000 	str	r12, [r13]
8f60061c:	eb00c926 	bl	8f632abc <_panic>
}
8f600620:	eaffffe0 	b	8f6005a8 <target_sdc_init+0x118>
		dprintf(CRITICAL, "FAILED TO INIT EMMC mmc_slot = %u \n",1);
8f600624:	e30000cc 	movw	r0, #204	; 0xcc
8f600628:	e1a01006 	mov	r1, r6
8f60062c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f600630:	eb00c8cf 	bl	8f632974 <_dprintf>
8f600634:	eaffffbc 	b	8f60052c <target_sdc_init+0x9c>
}
8f600638:	eb00c960 	bl	8f632bc0 <__stack_chk_fail>
8f60063c:	8f74221c 	.word	0x8f74221c

8f600640 <target_mmc_device>:
	return (void *) dev;
8f600640:	e3023214 	movw	r3, #8724	; 0x2214
8f600644:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f600648:	e59f2038 	ldr	r2, [pc, #56]	; 8f600688 <target_mmc_device+0x48>
8f60064c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f600650:	e24dd00c 	sub	r13, r13, #12
	return (void *) dev;
8f600654:	e5930000 	ldr	r0, [r3]
{
8f600658:	e5922000 	ldr	r2, [r2]
8f60065c:	e58d2004 	str	r2, [r13, #4]
8f600660:	e3a02000 	mov	r2, #0
}
8f600664:	e59f301c 	ldr	r3, [pc, #28]	; 8f600688 <target_mmc_device+0x48>
8f600668:	e5932000 	ldr	r2, [r3]
8f60066c:	e59d3004 	ldr	r3, [r13, #4]
8f600670:	e0332002 	eors	r2, r3, r2
8f600674:	e3a03000 	mov	r3, #0
8f600678:	1a000001 	bne	8f600684 <target_mmc_device+0x44>
8f60067c:	e28dd00c 	add	r13, r13, #12
8f600680:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f600684:	eb00c94d 	bl	8f632bc0 <__stack_chk_fail>
8f600688:	8f74221c 	.word	0x8f74221c

8f60068c <target_volume_up>:
{
8f60068c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f600690:	e24dd014 	sub	r13, r13, #20
	gpio_tlmm_config(TLMM_VOL_UP_BTN_GPIO, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA, GPIO_ENABLE);
8f600694:	e3a02000 	mov	r2, #0
{
8f600698:	e59fc060 	ldr	r12, [pc, #96]	; 8f600700 <target_volume_up+0x74>
	gpio_tlmm_config(TLMM_VOL_UP_BTN_GPIO, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA, GPIO_ENABLE);
8f60069c:	e58d2004 	str	r2, [r13, #4]
8f6006a0:	e3a03003 	mov	r3, #3
8f6006a4:	e58d2000 	str	r2, [r13]
8f6006a8:	e1a01002 	mov	r1, r2
8f6006ac:	e3a00055 	mov	r0, #85	; 0x55
{
8f6006b0:	e59cc000 	ldr	r12, [r12]
8f6006b4:	e58dc00c 	str	r12, [r13, #12]
8f6006b8:	e3a0c000 	mov	r12, #0
	gpio_tlmm_config(TLMM_VOL_UP_BTN_GPIO, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA, GPIO_ENABLE);
8f6006bc:	eb0007b8 	bl	8f6025a4 <gpio_tlmm_config>
	thread_sleep(10);
8f6006c0:	e3a0000a 	mov	r0, #10
8f6006c4:	eb008eef 	bl	8f624288 <thread_sleep>
	status = gpio_status(TLMM_VOL_UP_BTN_GPIO);
8f6006c8:	e3a00055 	mov	r0, #85	; 0x55
8f6006cc:	eb0007cc 	bl	8f602604 <gpio_status>
}
8f6006d0:	e59f3028 	ldr	r3, [pc, #40]	; 8f600700 <target_volume_up+0x74>
8f6006d4:	e5932000 	ldr	r2, [r3]
8f6006d8:	e59d300c 	ldr	r3, [r13, #12]
8f6006dc:	e0332002 	eors	r2, r3, r2
8f6006e0:	e3a03000 	mov	r3, #0
8f6006e4:	1a000004 	bne	8f6006fc <target_volume_up+0x70>
8f6006e8:	e6ef0070 	uxtb	r0, r0
8f6006ec:	e16f0f10 	clz	r0, r0
8f6006f0:	e1a002a0 	lsr	r0, r0, #5
8f6006f4:	e28dd014 	add	r13, r13, #20
8f6006f8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6006fc:	eb00c92f 	bl	8f632bc0 <__stack_chk_fail>
8f600700:	8f74221c 	.word	0x8f74221c

8f600704 <target_volume_down>:
{
8f600704:	e59f3038 	ldr	r3, [pc, #56]	; 8f600744 <target_volume_down+0x40>
8f600708:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60070c:	e24dd00c 	sub	r13, r13, #12
8f600710:	e5933000 	ldr	r3, [r3]
8f600714:	e58d3004 	str	r3, [r13, #4]
8f600718:	e3a03000 	mov	r3, #0
	return pm8x41_resin_status();
8f60071c:	e59f3020 	ldr	r3, [pc, #32]	; 8f600744 <target_volume_down+0x40>
8f600720:	e5932000 	ldr	r2, [r3]
8f600724:	e59d3004 	ldr	r3, [r13, #4]
8f600728:	e0332002 	eors	r2, r3, r2
8f60072c:	e3a03000 	mov	r3, #0
8f600730:	1a000002 	bne	8f600740 <target_volume_down+0x3c>
}
8f600734:	e28dd00c 	add	r13, r13, #12
8f600738:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return pm8x41_resin_status();
8f60073c:	ea00c1c7 	b	8f630e60 <pm8x41_resin_status>
8f600740:	eb00c91e 	bl	8f632bc0 <__stack_chk_fail>
8f600744:	8f74221c 	.word	0x8f74221c

8f600748 <target_is_pwrkey_pon_reason>:
{
8f600748:	e59f30bc 	ldr	r3, [pc, #188]	; 8f60080c <target_is_pwrkey_pon_reason+0xc4>
8f60074c:	e92d4030 	push	{r4, r5, r14}
8f600750:	e24dd00c 	sub	r13, r13, #12
8f600754:	e5933000 	ldr	r3, [r3]
8f600758:	e58d3004 	str	r3, [r13, #4]
8f60075c:	e3a03000 	mov	r3, #0
	crypto_init_params(&ce_params);
}

uint32_t target_get_pmic()
{
	if (target_is_pmi_enabled()) {
8f600760:	eb00853a 	bl	8f621c50 <target_is_pmi_enabled>
8f600764:	e3500000 	cmp	r0, #0
8f600768:	1a000019 	bne	8f6007d4 <target_is_pwrkey_pon_reason+0x8c>
		pon_reason = pm8950_get_pon_reason();
8f60076c:	eb00c299 	bl	8f6311d8 <pm8950_get_pon_reason>
8f600770:	e1a05000 	mov	r5, r0
				pm8x41_reg_read(SMBCHG_USB_RT_STS));
8f600774:	e3010310 	movw	r0, #4880	; 0x1310
8f600778:	e3400002 	movt	r0, #2
8f60077c:	eb00c13d 	bl	8f630c78 <pm8x41_reg_read>
		usb_present_sts = !(USBIN_UV_RT_STS &
8f600780:	e1e04000 	mvn	r4, r0
8f600784:	e2044001 	and	r4, r4, #1
	if (pm8x41_get_is_cold_boot() && ((pon_reason == KPDPWR_N) ||
8f600788:	eb00c2f1 	bl	8f631354 <pm8x41_get_is_cold_boot>
8f60078c:	e3500000 	cmp	r0, #0
8f600790:	0a000003 	beq	8f6007a4 <target_is_pwrkey_pon_reason+0x5c>
8f600794:	e20530df 	and	r3, r5, #223	; 0xdf
8f600798:	e3530080 	cmp	r3, #128	; 0x80
		return 1;
8f60079c:	03a00001 	moveq	r0, #1
	if (pm8x41_get_is_cold_boot() && ((pon_reason == KPDPWR_N) ||
8f6007a0:	0a000003 	beq	8f6007b4 <target_is_pwrkey_pon_reason+0x6c>
	else if ((pon_reason == PON1) && (!usb_present_sts))
8f6007a4:	e2240001 	eor	r0, r4, #1
		return 1;
8f6007a8:	e3550020 	cmp	r5, #32
8f6007ac:	13a00000 	movne	r0, #0
8f6007b0:	02000001 	andeq	r0, r0, #1
}
8f6007b4:	e59f3050 	ldr	r3, [pc, #80]	; 8f60080c <target_is_pwrkey_pon_reason+0xc4>
8f6007b8:	e5932000 	ldr	r2, [r3]
8f6007bc:	e59d3004 	ldr	r3, [r13, #4]
8f6007c0:	e0332002 	eors	r2, r3, r2
8f6007c4:	e3a03000 	mov	r3, #0
8f6007c8:	1a00000e 	bne	8f600808 <target_is_pwrkey_pon_reason+0xc0>
8f6007cc:	e28dd00c 	add	r13, r13, #12
8f6007d0:	e8bd8030 	pop	{r4, r5, r15}
		uint32_t pmi_type = board_pmic_target(1) & PMIC_TYPE_MASK;
8f6007d4:	e3a00001 	mov	r0, #1
8f6007d8:	eb003eda 	bl	8f610348 <board_pmic_target>
8f6007dc:	e6ef0070 	uxtb	r0, r0
		if (pmi_type == PMIC_IS_PMI632)
8f6007e0:	e3500025 	cmp	r0, #37	; 0x25
8f6007e4:	1affffe0 	bne	8f60076c <target_is_pwrkey_pon_reason+0x24>
		pon_reason = pmi632_get_pon_reason();
8f6007e8:	eb00c2aa 	bl	8f631298 <pmi632_get_pon_reason>
8f6007ec:	e1a05000 	mov	r5, r0
				pm8x41_reg_read(SMBCHG_USB_RT_STS));
8f6007f0:	e3010310 	movw	r0, #4880	; 0x1310
8f6007f4:	e3400002 	movt	r0, #2
8f6007f8:	eb00c11e 	bl	8f630c78 <pm8x41_reg_read>
		usb_present_sts = !(USBIN_UV_RT_STS_PMI632 &
8f6007fc:	e2204004 	eor	r4, r0, #4
8f600800:	e7e04154 	ubfx	r4, r4, #2, #1
8f600804:	eaffffdf 	b	8f600788 <target_is_pwrkey_pon_reason+0x40>
}
8f600808:	eb00c8ec 	bl	8f632bc0 <__stack_chk_fail>
8f60080c:	8f74221c 	.word	0x8f74221c

8f600810 <target_init>:
{
8f600810:	e59f32b4 	ldr	r3, [pc, #692]	; 8f600acc <target_init+0x2bc>
	dprintf(INFO, "target_init()\n");
8f600814:	e3000150 	movw	r0, #336	; 0x150
{
8f600818:	e92d4010 	push	{r4, r14}
	dprintf(INFO, "target_init()\n");
8f60081c:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f600820:	e24dd030 	sub	r13, r13, #48	; 0x30
8f600824:	e1a0400e 	mov	r4, r14
8f600828:	e5933000 	ldr	r3, [r3]
8f60082c:	e58d302c 	str	r3, [r13, #44]	; 0x2c
8f600830:	e3a03000 	mov	r3, #0
	dprintf(INFO, "target_init()\n");
8f600834:	eb00c84e 	bl	8f632974 <_dprintf>
	spmi_init(PMIC_ARB_CHANNEL_NUM, PMIC_ARB_OWNER_ID);
8f600838:	e3a01000 	mov	r1, #0
8f60083c:	e1a00001 	mov	r0, r1
8f600840:	eb0040d3 	bl	8f610b94 <spmi_init>
	keys_init();
8f600844:	eb00c09c 	bl	8f630abc <keys_init>
	return pm8x41_resin_status();
8f600848:	eb00c184 	bl	8f630e60 <pm8x41_resin_status>
	if(target_volume_down())
8f60084c:	e3500000 	cmp	r0, #0
8f600850:	1a00006e 	bne	8f600a10 <target_init+0x200>
	gpio_tlmm_config(TLMM_VOL_UP_BTN_GPIO, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA, GPIO_ENABLE);
8f600854:	e3a02000 	mov	r2, #0
8f600858:	e3a03003 	mov	r3, #3
8f60085c:	e1a01002 	mov	r1, r2
8f600860:	e58d2004 	str	r2, [r13, #4]
8f600864:	e58d2000 	str	r2, [r13]
8f600868:	e3a00055 	mov	r0, #85	; 0x55
8f60086c:	eb00074c 	bl	8f6025a4 <gpio_tlmm_config>
	thread_sleep(10);
8f600870:	e3a0000a 	mov	r0, #10
8f600874:	eb008e83 	bl	8f624288 <thread_sleep>
	status = gpio_status(TLMM_VOL_UP_BTN_GPIO);
8f600878:	e3a00055 	mov	r0, #85	; 0x55
8f60087c:	eb000760 	bl	8f602604 <gpio_status>
	if(target_volume_up())
8f600880:	e6ef0070 	uxtb	r0, r0
8f600884:	e3500000 	cmp	r0, #0
8f600888:	0a00005c 	beq	8f600a00 <target_init+0x1f0>
	target_sdc_init();
8f60088c:	ebfffeff 	bl	8f600490 <target_sdc_init>
	if (partition_read_table())
8f600890:	eb000da4 	bl	8f603f28 <partition_read_table>
8f600894:	e3500000 	cmp	r0, #0
8f600898:	1a00004a 	bne	8f6009c8 <target_init+0x1b8>
	if (target_is_pmi_enabled())
8f60089c:	eb0084eb 	bl	8f621c50 <target_is_pmi_enabled>
8f6008a0:	e3500000 	cmp	r0, #0
8f6008a4:	1a000045 	bne	8f6009c0 <target_init+0x1b0>
	if (target_is_pmi_enabled())
8f6008a8:	eb0084e8 	bl	8f621c50 <target_is_pmi_enabled>
8f6008ac:	e3500000 	cmp	r0, #0
8f6008b0:	1a00003f 	bne	8f6009b4 <target_init+0x1a4>
	if (target_use_signed_kernel())
8f6008b4:	eb008482 	bl	8f621ac4 <target_use_signed_kernel>
8f6008b8:	e3500000 	cmp	r0, #0
8f6008bc:	1a000027 	bne	8f600960 <target_init+0x150>
	if (VB_M <= target_get_vb_version())
8f6008c0:	eb00857c 	bl	8f621eb8 <target_get_vb_version>
8f6008c4:	e3500001 	cmp	r0, #1
8f6008c8:	ca000008 	bgt	8f6008f0 <target_init+0xe0>
	rpm_smd_init();
8f6008cc:	e59f31f8 	ldr	r3, [pc, #504]	; 8f600acc <target_init+0x2bc>
8f6008d0:	e5932000 	ldr	r2, [r3]
8f6008d4:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
8f6008d8:	e0332002 	eors	r2, r3, r2
8f6008dc:	e3a03000 	mov	r3, #0
8f6008e0:	1a000078 	bne	8f600ac8 <target_init+0x2b8>
}
8f6008e4:	e28dd030 	add	r13, r13, #48	; 0x30
8f6008e8:	e8bd4010 	pop	{r4, r14}
	rpm_smd_init();
8f6008ec:	ea001bec 	b	8f6078a4 <rpm_smd_init>
		clock_ce_enable(CE1_INSTANCE);
8f6008f0:	e3a00001 	mov	r0, #1
8f6008f4:	eb0005c9 	bl	8f602020 <clock_ce_enable>
		if (qseecom_init() < 0)
8f6008f8:	eb0059a3 	bl	8f616f8c <qseecom_init>
8f6008fc:	e3500000 	cmp	r0, #0
8f600900:	ba000062 	blt	8f600a90 <target_init+0x280>
		if (qseecom_tz_init() < 0)
8f600904:	eb005944 	bl	8f616e1c <qseecom_tz_init>
8f600908:	e3500000 	cmp	r0, #0
8f60090c:	ba000051 	blt	8f600a58 <target_init+0x248>
		if (rpmb_init() < 0)
8f600910:	eb007ee7 	bl	8f6204b4 <rpmb_init>
8f600914:	e3500000 	cmp	r0, #0
8f600918:	ba000040 	blt	8f600a20 <target_init+0x210>
		if (load_sec_app() < 0)
8f60091c:	eb001b54 	bl	8f607674 <load_sec_app>
8f600920:	e3500000 	cmp	r0, #0
8f600924:	aaffffe8 	bge	8f6008cc <target_init+0xbc>
			dprintf(CRITICAL, "Failed to load App for verified\n");
8f600928:	e30001d8 	movw	r0, #472	; 0x1d8
8f60092c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f600930:	eb00c80f 	bl	8f632974 <_dprintf>
			ASSERT(0);
8f600934:	e307cf64 	movw	r12, #32612	; 0x7f64
8f600938:	e3002118 	movw	r2, #280	; 0x118
8f60093c:	e348cf70 	movt	r12, #36720	; 0x8f70
8f600940:	e3482f70 	movt	r2, #36720	; 0x8f70
8f600944:	e3001130 	movw	r1, #304	; 0x130
8f600948:	e30031cd 	movw	r3, #461	; 0x1cd
8f60094c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f600950:	e1a00004 	mov	r0, r4
8f600954:	e58dc000 	str	r12, [r13]
8f600958:	eb00c857 	bl	8f632abc <_panic>
8f60095c:	eaffffda 	b	8f6008cc <target_init+0xbc>
	crypto_init_params(&ce_params);
8f600960:	e28d0008 	add	r0, r13, #8
	ce_params.crypto_instance  = CE1_INSTANCE;
8f600964:	e3a01001 	mov	r1, #1
	ce_params.read_fifo_size   = CE_FIFO_SIZE;
8f600968:	e3a02040 	mov	r2, #64	; 0x40
	ce_params.crypto_instance  = CE1_INSTANCE;
8f60096c:	e58d100c 	str	r1, [r13, #12]
	ce_params.bam_ee               = CE_EE;
8f600970:	e58d1014 	str	r1, [r13, #20]
	ce_params.crypto_base      = MSM_CE1_BASE;
8f600974:	e3a03a0a 	mov	r3, #40960	; 0xa000
	ce_params.num_ce           = CE_ARRAY_SIZE;
8f600978:	e3a01014 	mov	r1, #20
	ce_params.crypto_base      = MSM_CE1_BASE;
8f60097c:	e3403073 	movt	r3, #115	; 0x73
	ce_params.num_ce           = CE_ARRAY_SIZE;
8f600980:	e58d1018 	str	r1, [r13, #24]
	ce_params.pipes.write_pipe_grp = CE_WRITE_PIPE_LOCK_GRP;
8f600984:	e3a01000 	mov	r1, #0
	ce_params.crypto_base      = MSM_CE1_BASE;
8f600988:	e58d3008 	str	r3, [r13, #8]
	ce_params.do_bam_init      = 0;
8f60098c:	e3a03c03 	mov	r3, #768	; 0x300
	ce_params.read_fifo_size   = CE_FIFO_SIZE;
8f600990:	e58d201c 	str	r2, [r13, #28]
	ce_params.do_bam_init      = 0;
8f600994:	e3403002 	movt	r3, #2
	ce_params.pipes.write_pipe_grp = CE_WRITE_PIPE_LOCK_GRP;
8f600998:	e5cd1028 	strb	r1, [r13, #40]	; 0x28
	ce_params.do_bam_init      = 0;
8f60099c:	e1cd22f0 	strd	r2, [r13, #32]
	ce_params.bam_base         = MSM_CE1_BAM_BASE;
8f6009a0:	e3a03901 	mov	r3, #16384	; 0x4000
8f6009a4:	e3403070 	movt	r3, #112	; 0x70
8f6009a8:	e58d3010 	str	r3, [r13, #16]
	crypto_init_params(&ce_params);
8f6009ac:	eb00674c 	bl	8f61a6e4 <crypto_init_params>
}
8f6009b0:	eaffffc2 	b	8f6008c0 <target_init+0xb0>
		vib_timed_turn_on(VIBRATE_TIME);
8f6009b4:	e3a000fa 	mov	r0, #250	; 0xfa
8f6009b8:	eb00c769 	bl	8f632764 <vib_timed_turn_on>
8f6009bc:	eaffffbc 	b	8f6008b4 <target_init+0xa4>
		shutdown_detect();
8f6009c0:	eb00650f 	bl	8f619e04 <shutdown_detect>
8f6009c4:	eaffffb7 	b	8f6008a8 <target_init+0x98>
		dprintf(CRITICAL, "Error reading the partition table info\n");
8f6009c8:	e3000160 	movw	r0, #352	; 0x160
8f6009cc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6009d0:	eb00c7e7 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f6009d4:	e3070f64 	movw	r0, #32612	; 0x7f64
8f6009d8:	e3002118 	movw	r2, #280	; 0x118
8f6009dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6009e0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6009e4:	e58d0000 	str	r0, [r13]
8f6009e8:	e3001130 	movw	r1, #304	; 0x130
8f6009ec:	e300319e 	movw	r3, #414	; 0x19e
8f6009f0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6009f4:	e1a00004 	mov	r0, r4
8f6009f8:	eb00c82f 	bl	8f632abc <_panic>
8f6009fc:	eaffffa6 	b	8f60089c <target_init+0x8c>
		keys_post_event(KEY_VOLUMEUP, 1);
8f600a00:	e3a01001 	mov	r1, #1
8f600a04:	e3000115 	movw	r0, #277	; 0x115
8f600a08:	eb00c040 	bl	8f630b10 <keys_post_event>
8f600a0c:	eaffff9e 	b	8f60088c <target_init+0x7c>
		keys_post_event(KEY_VOLUMEDOWN, 1);
8f600a10:	e3a01001 	mov	r1, #1
8f600a14:	e3000116 	movw	r0, #278	; 0x116
8f600a18:	eb00c03c 	bl	8f630b10 <keys_post_event>
8f600a1c:	eaffff8c 	b	8f600854 <target_init+0x44>
			dprintf(CRITICAL, "RPMB init failed\n");
8f600a20:	e30001c4 	movw	r0, #452	; 0x1c4
8f600a24:	e3480f70 	movt	r0, #36720	; 0x8f70
8f600a28:	eb00c7d1 	bl	8f632974 <_dprintf>
			ASSERT(0);
8f600a2c:	e3070f64 	movw	r0, #32612	; 0x7f64
8f600a30:	e3002118 	movw	r2, #280	; 0x118
8f600a34:	e3480f70 	movt	r0, #36720	; 0x8f70
8f600a38:	e3482f70 	movt	r2, #36720	; 0x8f70
8f600a3c:	e58d0000 	str	r0, [r13]
8f600a40:	e3001130 	movw	r1, #304	; 0x130
8f600a44:	e3a03f71 	mov	r3, #452	; 0x1c4
8f600a48:	e3481f70 	movt	r1, #36720	; 0x8f70
8f600a4c:	e1a00004 	mov	r0, r4
8f600a50:	eb00c819 	bl	8f632abc <_panic>
8f600a54:	eaffffb0 	b	8f60091c <target_init+0x10c>
			dprintf(CRITICAL, "Failed to start qseecom\n");
8f600a58:	e30001a8 	movw	r0, #424	; 0x1a8
8f600a5c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f600a60:	eb00c7c3 	bl	8f632974 <_dprintf>
			ASSERT(0);
8f600a64:	e3070f64 	movw	r0, #32612	; 0x7f64
8f600a68:	e3002118 	movw	r2, #280	; 0x118
8f600a6c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f600a70:	e3482f70 	movt	r2, #36720	; 0x8f70
8f600a74:	e58d0000 	str	r0, [r13]
8f600a78:	e3001130 	movw	r1, #304	; 0x130
8f600a7c:	e30031be 	movw	r3, #446	; 0x1be
8f600a80:	e3481f70 	movt	r1, #36720	; 0x8f70
8f600a84:	e1a00004 	mov	r0, r4
8f600a88:	eb00c80b 	bl	8f632abc <_panic>
8f600a8c:	eaffff9f 	b	8f600910 <target_init+0x100>
			dprintf(CRITICAL, "Failed to initialize qseecom\n");
8f600a90:	e3000188 	movw	r0, #392	; 0x188
8f600a94:	e3480f70 	movt	r0, #36720	; 0x8f70
8f600a98:	eb00c7b5 	bl	8f632974 <_dprintf>
			ASSERT(0);
8f600a9c:	e3070f64 	movw	r0, #32612	; 0x7f64
8f600aa0:	e3002118 	movw	r2, #280	; 0x118
8f600aa4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f600aa8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f600aac:	e58d0000 	str	r0, [r13]
8f600ab0:	e3001130 	movw	r1, #304	; 0x130
8f600ab4:	e30031b7 	movw	r3, #439	; 0x1b7
8f600ab8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f600abc:	e1a00004 	mov	r0, r4
8f600ac0:	eb00c7fd 	bl	8f632abc <_panic>
8f600ac4:	eaffff8e 	b	8f600904 <target_init+0xf4>
	rpm_smd_init();
8f600ac8:	eb00c83c 	bl	8f632bc0 <__stack_chk_fail>
8f600acc:	8f74221c 	.word	0x8f74221c

8f600ad0 <target_serialno>:
{
8f600ad0:	e59f3080 	ldr	r3, [pc, #128]	; 8f600b58 <target_serialno+0x88>
8f600ad4:	e92d4010 	push	{r4, r14}
8f600ad8:	e24dd008 	sub	r13, r13, #8
8f600adc:	e5933000 	ldr	r3, [r3]
8f600ae0:	e58d3004 	str	r3, [r13, #4]
8f600ae4:	e3a03000 	mov	r3, #0
8f600ae8:	e1a04000 	mov	r4, r0
	if (target_is_emmc_boot()) {
8f600aec:	eb0083e3 	bl	8f621a80 <target_is_emmc_boot>
8f600af0:	e3500000 	cmp	r0, #0
8f600af4:	1a000007 	bne	8f600b18 <target_serialno+0x48>
}
8f600af8:	e59f3058 	ldr	r3, [pc, #88]	; 8f600b58 <target_serialno+0x88>
8f600afc:	e5932000 	ldr	r2, [r3]
8f600b00:	e59d3004 	ldr	r3, [r13, #4]
8f600b04:	e0332002 	eors	r2, r3, r2
8f600b08:	e3a03000 	mov	r3, #0
8f600b0c:	1a000010 	bne	8f600b54 <target_serialno+0x84>
8f600b10:	e28dd008 	add	r13, r13, #8
8f600b14:	e8bd8010 	pop	{r4, r15}
		serialno = mmc_get_psn();
8f600b18:	eb0031e7 	bl	8f60d2bc <mmc_get_psn>
		snprintf((char *)buf, 13, "%x", serialno);
8f600b1c:	e59f2034 	ldr	r2, [pc, #52]	; 8f600b58 <target_serialno+0x88>
8f600b20:	e5921000 	ldr	r1, [r2]
8f600b24:	e59d2004 	ldr	r2, [r13, #4]
8f600b28:	e0321001 	eors	r1, r2, r1
8f600b2c:	e3a02000 	mov	r2, #0
		serialno = mmc_get_psn();
8f600b30:	e1a03000 	mov	r3, r0
		snprintf((char *)buf, 13, "%x", serialno);
8f600b34:	1a000006 	bne	8f600b54 <target_serialno+0x84>
8f600b38:	e30021fc 	movw	r2, #508	; 0x1fc
8f600b3c:	e3a0100d 	mov	r1, #13
8f600b40:	e3482f70 	movt	r2, #36720	; 0x8f70
8f600b44:	e1a00004 	mov	r0, r4
}
8f600b48:	e28dd008 	add	r13, r13, #8
8f600b4c:	e8bd4010 	pop	{r4, r14}
		snprintf((char *)buf, 13, "%x", serialno);
8f600b50:	ea00ccfa 	b	8f633f40 <snprintf>
}
8f600b54:	eb00c819 	bl	8f632bc0 <__stack_chk_fail>
8f600b58:	8f74221c 	.word	0x8f74221c

8f600b5c <board_machtype>:
{
8f600b5c:	e59f3038 	ldr	r3, [pc, #56]	; 8f600b9c <board_machtype+0x40>
8f600b60:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f600b64:	e24dd00c 	sub	r13, r13, #12
8f600b68:	e5933000 	ldr	r3, [r3]
8f600b6c:	e58d3004 	str	r3, [r13, #4]
8f600b70:	e3a03000 	mov	r3, #0
}
8f600b74:	e59f3020 	ldr	r3, [pc, #32]	; 8f600b9c <board_machtype+0x40>
8f600b78:	e5932000 	ldr	r2, [r3]
8f600b7c:	e59d3004 	ldr	r3, [r13, #4]
8f600b80:	e0332002 	eors	r2, r3, r2
8f600b84:	e3a03000 	mov	r3, #0
8f600b88:	1a000002 	bne	8f600b98 <board_machtype+0x3c>
8f600b8c:	e3a00000 	mov	r0, #0
8f600b90:	e28dd00c 	add	r13, r13, #12
8f600b94:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f600b98:	eb00c808 	bl	8f632bc0 <__stack_chk_fail>
8f600b9c:	8f74221c 	.word	0x8f74221c

8f600ba0 <target_detect>:
{
8f600ba0:	e59f3034 	ldr	r3, [pc, #52]	; 8f600bdc <target_detect+0x3c>
8f600ba4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f600ba8:	e24dd00c 	sub	r13, r13, #12
8f600bac:	e5933000 	ldr	r3, [r3]
8f600bb0:	e58d3004 	str	r3, [r13, #4]
8f600bb4:	e3a03000 	mov	r3, #0
}
8f600bb8:	e59f301c 	ldr	r3, [pc, #28]	; 8f600bdc <target_detect+0x3c>
8f600bbc:	e5932000 	ldr	r2, [r3]
8f600bc0:	e59d3004 	ldr	r3, [r13, #4]
8f600bc4:	e0332002 	eors	r2, r3, r2
8f600bc8:	e3a03000 	mov	r3, #0
8f600bcc:	1a000001 	bne	8f600bd8 <target_detect+0x38>
8f600bd0:	e28dd00c 	add	r13, r13, #12
8f600bd4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f600bd8:	eb00c7f8 	bl	8f632bc0 <__stack_chk_fail>
8f600bdc:	8f74221c 	.word	0x8f74221c

8f600be0 <target_baseband_detect>:
	platform = board->platform;
8f600be0:	e5901000 	ldr	r1, [r0]
	switch(platform) {
8f600be4:	e3003152 	movw	r3, #338	; 0x152
{
8f600be8:	e59f20c0 	ldr	r2, [pc, #192]	; 8f600cb0 <target_baseband_detect+0xd0>
	switch(platform) {
8f600bec:	e1510003 	cmp	r1, r3
{
8f600bf0:	e92d4010 	push	{r4, r14}
8f600bf4:	e24dd010 	sub	r13, r13, #16
8f600bf8:	e5922000 	ldr	r2, [r2]
8f600bfc:	e58d200c 	str	r2, [r13, #12]
8f600c00:	e3a02000 	mov	r2, #0
	switch(platform) {
8f600c04:	0a000025 	beq	8f600ca0 <target_baseband_detect+0xc0>
8f600c08:	e1a0400e 	mov	r4, r14
8f600c0c:	9a000010 	bls	8f600c54 <target_baseband_detect+0x74>
8f600c10:	e300315d 	movw	r3, #349	; 0x15d
8f600c14:	e1510003 	cmp	r1, r3
8f600c18:	0a000020 	beq	8f600ca0 <target_baseband_detect+0xc0>
8f600c1c:	e2413f57 	sub	r3, r1, #348	; 0x15c
8f600c20:	e2433002 	sub	r3, r3, #2
8f600c24:	e3530001 	cmp	r3, #1
8f600c28:	8a00000e 	bhi	8f600c68 <target_baseband_detect+0x88>
		board->baseband = BASEBAND_APQ;
8f600c2c:	e3a03001 	mov	r3, #1
8f600c30:	e580301c 	str	r3, [r0, #28]
}
8f600c34:	e59f3074 	ldr	r3, [pc, #116]	; 8f600cb0 <target_baseband_detect+0xd0>
8f600c38:	e5932000 	ldr	r2, [r3]
8f600c3c:	e59d300c 	ldr	r3, [r13, #12]
8f600c40:	e0332002 	eors	r2, r3, r2
8f600c44:	e3a03000 	mov	r3, #0
8f600c48:	1a000017 	bne	8f600cac <target_baseband_detect+0xcc>
8f600c4c:	e28dd010 	add	r13, r13, #16
8f600c50:	e8bd8010 	pop	{r4, r15}
	switch(platform) {
8f600c54:	e3003125 	movw	r3, #293	; 0x125
8f600c58:	e1510003 	cmp	r1, r3
8f600c5c:	0a00000f 	beq	8f600ca0 <target_baseband_detect+0xc0>
8f600c60:	e3510e13 	cmp	r1, #304	; 0x130
8f600c64:	0afffff0 	beq	8f600c2c <target_baseband_detect+0x4c>
		dprintf(CRITICAL, "Platform type: %u is not supported\n",platform);
8f600c68:	e3000200 	movw	r0, #512	; 0x200
8f600c6c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f600c70:	eb00c73f 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f600c74:	e307cf64 	movw	r12, #32612	; 0x7f64
8f600c78:	e3002118 	movw	r2, #280	; 0x118
8f600c7c:	e348cf70 	movt	r12, #36720	; 0x8f70
8f600c80:	e3482f70 	movt	r2, #36720	; 0x8f70
8f600c84:	e3001130 	movw	r1, #304	; 0x130
8f600c88:	e30031fe 	movw	r3, #510	; 0x1fe
8f600c8c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f600c90:	e1a00004 	mov	r0, r4
8f600c94:	e58dc000 	str	r12, [r13]
8f600c98:	eb00c787 	bl	8f632abc <_panic>
}
8f600c9c:	eaffffe4 	b	8f600c34 <target_baseband_detect+0x54>
		board->baseband = BASEBAND_MSM;
8f600ca0:	e3a03000 	mov	r3, #0
8f600ca4:	e580301c 	str	r3, [r0, #28]
		break;
8f600ca8:	eaffffe1 	b	8f600c34 <target_baseband_detect+0x54>
}
8f600cac:	eb00c7c3 	bl	8f632bc0 <__stack_chk_fail>
8f600cb0:	8f74221c 	.word	0x8f74221c

8f600cb4 <set_download_mode>:
{
8f600cb4:	e59f3044 	ldr	r3, [pc, #68]	; 8f600d00 <set_download_mode+0x4c>
8f600cb8:	e92d4010 	push	{r4, r14}
8f600cbc:	e24dd008 	sub	r13, r13, #8
8f600cc0:	e5933000 	ldr	r3, [r3]
8f600cc4:	e58d3004 	str	r3, [r13, #4]
8f600cc8:	e3a03000 	mov	r3, #0
	ret = scm_dload_mode(mode);
8f600ccc:	eb00520b 	bl	8f615500 <scm_dload_mode>
8f600cd0:	e1a04000 	mov	r4, r0
	pm8x41_clear_pmic_watchdog();
8f600cd4:	eb00c1db 	bl	8f631448 <pm8x41_clear_pmic_watchdog>
}
8f600cd8:	e59f3020 	ldr	r3, [pc, #32]	; 8f600d00 <set_download_mode+0x4c>
8f600cdc:	e5932000 	ldr	r2, [r3]
8f600ce0:	e59d3004 	ldr	r3, [r13, #4]
8f600ce4:	e0332002 	eors	r2, r3, r2
8f600ce8:	e3a03000 	mov	r3, #0
8f600cec:	1a000002 	bne	8f600cfc <set_download_mode+0x48>
8f600cf0:	e1a00004 	mov	r0, r4
8f600cf4:	e28dd008 	add	r13, r13, #8
8f600cf8:	e8bd8010 	pop	{r4, r15}
8f600cfc:	eb00c7af 	bl	8f632bc0 <__stack_chk_fail>
8f600d00:	8f74221c 	.word	0x8f74221c

8f600d04 <emmc_recovery_init>:
{
8f600d04:	e59f3038 	ldr	r3, [pc, #56]	; 8f600d44 <emmc_recovery_init+0x40>
8f600d08:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f600d0c:	e24dd00c 	sub	r13, r13, #12
8f600d10:	e5933000 	ldr	r3, [r3]
8f600d14:	e58d3004 	str	r3, [r13, #4]
8f600d18:	e3a03000 	mov	r3, #0
	return _emmc_recovery_init();
8f600d1c:	e59f3020 	ldr	r3, [pc, #32]	; 8f600d44 <emmc_recovery_init+0x40>
8f600d20:	e5932000 	ldr	r2, [r3]
8f600d24:	e59d3004 	ldr	r3, [r13, #4]
8f600d28:	e0332002 	eors	r2, r3, r2
8f600d2c:	e3a03000 	mov	r3, #0
8f600d30:	1a000002 	bne	8f600d40 <emmc_recovery_init+0x3c>
}
8f600d34:	e28dd00c 	add	r13, r13, #12
8f600d38:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return _emmc_recovery_init();
8f600d3c:	ea00b998 	b	8f62f3a4 <_emmc_recovery_init>
8f600d40:	eb00c79e 	bl	8f632bc0 <__stack_chk_fail>
8f600d44:	8f74221c 	.word	0x8f74221c

8f600d48 <target_uninit>:
{
8f600d48:	e59f3168 	ldr	r3, [pc, #360]	; 8f600eb8 <target_uninit+0x170>
8f600d4c:	e92d4030 	push	{r4, r5, r14}
8f600d50:	e24dd014 	sub	r13, r13, #20
8f600d54:	e5933000 	ldr	r3, [r3]
8f600d58:	e58d300c 	str	r3, [r13, #12]
8f600d5c:	e3a03000 	mov	r3, #0
	if(target_is_pmi_enabled())
8f600d60:	e1a0500e 	mov	r5, r14
8f600d64:	eb0083b9 	bl	8f621c50 <target_is_pmi_enabled>
8f600d68:	e3500000 	cmp	r0, #0
8f600d6c:	1a00002f 	bne	8f600e30 <target_uninit+0xe8>
	if (emmc_dev) {
8f600d70:	e3024224 	movw	r4, #8740	; 0x2224
8f600d74:	e3484f74 	movt	r4, #36724	; 0x8f74
8f600d78:	e5940000 	ldr	r0, [r4]
8f600d7c:	e3500000 	cmp	r0, #0
8f600d80:	0a000002 	beq	8f600d90 <target_uninit+0x48>
		mmc_put_card_to_sleep(emmc_dev);
8f600d84:	eb002d94 	bl	8f60c3dc <mmc_put_card_to_sleep>
		sdhci_mode_disable(&emmc_dev->host);
8f600d88:	e5940000 	ldr	r0, [r4]
8f600d8c:	eb0023be 	bl	8f609c8c <sdhci_mode_disable>
	if (sdcard_dev) {
8f600d90:	e3024218 	movw	r4, #8728	; 0x2218
8f600d94:	e3484f74 	movt	r4, #36724	; 0x8f74
8f600d98:	e5940000 	ldr	r0, [r4]
8f600d9c:	e3500000 	cmp	r0, #0
8f600da0:	0a000002 	beq	8f600db0 <target_uninit+0x68>
		mmc_put_card_to_sleep(sdcard_dev);
8f600da4:	eb002d8c 	bl	8f60c3dc <mmc_put_card_to_sleep>
		sdhci_mode_disable(&sdcard_dev->host);
8f600da8:	e5940000 	ldr	r0, [r4]
8f600dac:	eb0023b6 	bl	8f609c8c <sdhci_mode_disable>
	if (crypto_initialized())
8f600db0:	eb00663a 	bl	8f61a6a0 <crypto_initialized>
8f600db4:	e3500000 	cmp	r0, #0
8f600db8:	1a00001a 	bne	8f600e28 <target_uninit+0xe0>
	if (target_is_ssd_enabled())
8f600dbc:	eb008351 	bl	8f621b08 <target_is_ssd_enabled>
8f600dc0:	e3500000 	cmp	r0, #0
8f600dc4:	1a000014 	bne	8f600e1c <target_uninit+0xd4>
	if (VB_M <= target_get_vb_version())
8f600dc8:	eb00843a 	bl	8f621eb8 <target_get_vb_version>
8f600dcc:	e3500001 	cmp	r0, #1
8f600dd0:	ca000008 	bgt	8f600df8 <target_uninit+0xb0>
	rpm_smd_uninit();
8f600dd4:	e59f30dc 	ldr	r3, [pc, #220]	; 8f600eb8 <target_uninit+0x170>
8f600dd8:	e5932000 	ldr	r2, [r3]
8f600ddc:	e59d300c 	ldr	r3, [r13, #12]
8f600de0:	e0332002 	eors	r2, r3, r2
8f600de4:	e3a03000 	mov	r3, #0
8f600de8:	1a000031 	bne	8f600eb4 <target_uninit+0x16c>
}
8f600dec:	e28dd014 	add	r13, r13, #20
8f600df0:	e8bd4030 	pop	{r4, r5, r14}
	rpm_smd_uninit();
8f600df4:	ea001abe 	b	8f6078f4 <rpm_smd_uninit>
		if (is_sec_app_loaded())
8f600df8:	eb001a96 	bl	8f607858 <is_sec_app_loaded>
8f600dfc:	e3500000 	cmp	r0, #0
8f600e00:	1a00000c 	bne	8f600e38 <target_uninit+0xf0>
		if (rpmb_uninit() < 0)
8f600e04:	eb007e79 	bl	8f6207f0 <rpmb_uninit>
8f600e08:	e3500000 	cmp	r0, #0
8f600e0c:	ba00001a 	blt	8f600e7c <target_uninit+0x134>
		clock_ce_disable(CE1_INSTANCE);
8f600e10:	e3a00001 	mov	r0, #1
8f600e14:	eb000502 	bl	8f602224 <clock_ce_disable>
8f600e18:	eaffffed 	b	8f600dd4 <target_uninit+0x8c>
		clock_ce_disable(CE1_INSTANCE);
8f600e1c:	e3a00001 	mov	r0, #1
8f600e20:	eb0004ff 	bl	8f602224 <clock_ce_disable>
8f600e24:	eaffffe7 	b	8f600dc8 <target_uninit+0x80>
		crypto_eng_cleanup();
8f600e28:	eb00663d 	bl	8f61a724 <crypto_eng_cleanup>
8f600e2c:	eaffffe2 	b	8f600dbc <target_uninit+0x74>
		turn_off_vib_early();
8f600e30:	eb00c67e 	bl	8f632830 <turn_off_vib_early>
8f600e34:	eaffffcd 	b	8f600d70 <target_uninit+0x28>
			if (send_milestone_call_to_tz() < 0)
8f600e38:	eb001a47 	bl	8f60775c <send_milestone_call_to_tz>
8f600e3c:	e3500000 	cmp	r0, #0
8f600e40:	aaffffef 	bge	8f600e04 <target_uninit+0xbc>
				dprintf(CRITICAL, "Failed to unload App for rpmb\n");
8f600e44:	e3000224 	movw	r0, #548	; 0x224
8f600e48:	e3480f70 	movt	r0, #36720	; 0x8f70
8f600e4c:	eb00c6c8 	bl	8f632974 <_dprintf>
				ASSERT(0);
8f600e50:	e3070f64 	movw	r0, #32612	; 0x7f64
8f600e54:	e3002118 	movw	r2, #280	; 0x118
8f600e58:	e3480f70 	movt	r0, #36720	; 0x8f70
8f600e5c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f600e60:	e58d0000 	str	r0, [r13]
8f600e64:	e3001130 	movw	r1, #304	; 0x130
8f600e68:	e3a03f95 	mov	r3, #596	; 0x254
8f600e6c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f600e70:	e1a00005 	mov	r0, r5
8f600e74:	eb00c710 	bl	8f632abc <_panic>
8f600e78:	eaffffe1 	b	8f600e04 <target_uninit+0xbc>
			dprintf(CRITICAL, "RPMB uninit failed\n");
8f600e7c:	e3000244 	movw	r0, #580	; 0x244
8f600e80:	e3480f70 	movt	r0, #36720	; 0x8f70
8f600e84:	eb00c6ba 	bl	8f632974 <_dprintf>
			ASSERT(0);
8f600e88:	e307cf64 	movw	r12, #32612	; 0x7f64
8f600e8c:	e3002118 	movw	r2, #280	; 0x118
8f600e90:	e348cf70 	movt	r12, #36720	; 0x8f70
8f600e94:	e3482f70 	movt	r2, #36720	; 0x8f70
8f600e98:	e3001130 	movw	r1, #304	; 0x130
8f600e9c:	e300325b 	movw	r3, #603	; 0x25b
8f600ea0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f600ea4:	e1a00005 	mov	r0, r5
8f600ea8:	e58dc000 	str	r12, [r13]
8f600eac:	eb00c702 	bl	8f632abc <_panic>
8f600eb0:	eaffffd6 	b	8f600e10 <target_uninit+0xc8>
	rpm_smd_uninit();
8f600eb4:	eb00c741 	bl	8f632bc0 <__stack_chk_fail>
8f600eb8:	8f74221c 	.word	0x8f74221c

8f600ebc <target_usb30_init>:
{
8f600ebc:	e59f30b0 	ldr	r3, [pc, #176]	; 8f600f74 <target_usb30_init+0xb8>
	t_usb_iface = (target_usb_iface_t *) calloc(1, sizeof(target_usb_iface_t));
8f600ec0:	e3a01014 	mov	r1, #20
{
8f600ec4:	e92d4030 	push	{r4, r5, r14}
	t_usb_iface = (target_usb_iface_t *) calloc(1, sizeof(target_usb_iface_t));
8f600ec8:	e3a00001 	mov	r0, #1
{
8f600ecc:	e24dd014 	sub	r13, r13, #20
8f600ed0:	e1a0500e 	mov	r5, r14
8f600ed4:	e5933000 	ldr	r3, [r3]
8f600ed8:	e58d300c 	str	r3, [r13, #12]
8f600edc:	e3a03000 	mov	r3, #0
	t_usb_iface = (target_usb_iface_t *) calloc(1, sizeof(target_usb_iface_t));
8f600ee0:	eb00cc6f 	bl	8f6340a4 <calloc>
	ASSERT(t_usb_iface);
8f600ee4:	e2504000 	subs	r4, r0, #0
8f600ee8:	0a000015 	beq	8f600f44 <target_usb30_init+0x88>
	t_usb_iface->clock_init = clock_usb30_init;
8f600eec:	e301397c 	movw	r3, #6524	; 0x197c
8f600ef0:	e3483f60 	movt	r3, #36704	; 0x8f60
8f600ef4:	e584300c 	str	r3, [r4, #12]
	t_usb_iface->mux_config = NULL;
8f600ef8:	e3a00000 	mov	r0, #0
}
8f600efc:	e59f3070 	ldr	r3, [pc, #112]	; 8f600f74 <target_usb30_init+0xb8>
	t_usb_iface->phy_init   = usb30_qmp_phy_init;
8f600f00:	e3091f78 	movw	r1, #40824	; 0x9f78
	t_usb_iface->phy_reset  = target_usb_phy_reset;
8f600f04:	e3002280 	movw	r2, #640	; 0x280
	t_usb_iface->phy_init   = usb30_qmp_phy_init;
8f600f08:	e3481f61 	movt	r1, #36705	; 0x8f61
	t_usb_iface->phy_reset  = target_usb_phy_reset;
8f600f0c:	e3482f60 	movt	r2, #36704	; 0x8f60
	t_usb_iface->phy_init   = usb30_qmp_phy_init;
8f600f10:	e5841008 	str	r1, [r4, #8]
	t_usb_iface->mux_config = NULL;
8f600f14:	e5840000 	str	r0, [r4]
	t_usb_iface->vbus_override = 1;
8f600f18:	e3a01001 	mov	r1, #1
	t_usb_iface->phy_reset  = target_usb_phy_reset;
8f600f1c:	e5842004 	str	r2, [r4, #4]
	t_usb_iface->vbus_override = 1;
8f600f20:	e5c41010 	strb	r1, [r4, #16]
}
8f600f24:	e5932000 	ldr	r2, [r3]
8f600f28:	e59d300c 	ldr	r3, [r13, #12]
8f600f2c:	e0332002 	eors	r2, r3, r2
8f600f30:	e3a03000 	mov	r3, #0
8f600f34:	1a00000d 	bne	8f600f70 <target_usb30_init+0xb4>
8f600f38:	e1a00004 	mov	r0, r4
8f600f3c:	e28dd014 	add	r13, r13, #20
8f600f40:	e8bd8030 	pop	{r4, r5, r15}
	ASSERT(t_usb_iface);
8f600f44:	e300c25c 	movw	r12, #604	; 0x25c
8f600f48:	e3002118 	movw	r2, #280	; 0x118
8f600f4c:	e348cf70 	movt	r12, #36720	; 0x8f70
8f600f50:	e3482f70 	movt	r2, #36720	; 0x8f70
8f600f54:	e3001130 	movw	r1, #304	; 0x130
8f600f58:	e3003289 	movw	r3, #649	; 0x289
8f600f5c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f600f60:	e1a00005 	mov	r0, r5
8f600f64:	e58dc000 	str	r12, [r13]
8f600f68:	eb00c6d3 	bl	8f632abc <_panic>
8f600f6c:	eaffffde 	b	8f600eec <target_usb30_init+0x30>
}
8f600f70:	eb00c712 	bl	8f632bc0 <__stack_chk_fail>
8f600f74:	8f74221c 	.word	0x8f74221c

8f600f78 <target_usb_controller>:
{
8f600f78:	e59f303c 	ldr	r3, [pc, #60]	; 8f600fbc <target_usb_controller+0x44>
8f600f7c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f600f80:	e24dd00c 	sub	r13, r13, #12
8f600f84:	e5933000 	ldr	r3, [r3]
8f600f88:	e58d3004 	str	r3, [r13, #4]
8f600f8c:	e3a03000 	mov	r3, #0
}
8f600f90:	e59f3024 	ldr	r3, [pc, #36]	; 8f600fbc <target_usb_controller+0x44>
8f600f94:	e5932000 	ldr	r2, [r3]
8f600f98:	e59d3004 	ldr	r3, [r13, #4]
8f600f9c:	e0332002 	eors	r2, r3, r2
8f600fa0:	e3a03000 	mov	r3, #0
8f600fa4:	1a000003 	bne	8f600fb8 <target_usb_controller+0x40>
8f600fa8:	e3000258 	movw	r0, #600	; 0x258
8f600fac:	e3480f70 	movt	r0, #36720	; 0x8f70
8f600fb0:	e28dd00c 	add	r13, r13, #12
8f600fb4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f600fb8:	eb00c700 	bl	8f632bc0 <__stack_chk_fail>
8f600fbc:	8f74221c 	.word	0x8f74221c

8f600fc0 <target_fastboot_init>:
{
8f600fc0:	e59f3078 	ldr	r3, [pc, #120]	; 8f601040 <target_fastboot_init+0x80>
8f600fc4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f600fc8:	e24dd00c 	sub	r13, r13, #12
8f600fcc:	e5933000 	ldr	r3, [r3]
8f600fd0:	e58d3004 	str	r3, [r13, #4]
8f600fd4:	e3a03000 	mov	r3, #0
	if (target_is_ssd_enabled()) {
8f600fd8:	eb0082ca 	bl	8f621b08 <target_is_ssd_enabled>
8f600fdc:	e3500000 	cmp	r0, #0
8f600fe0:	1a000007 	bne	8f601004 <target_fastboot_init+0x44>
}
8f600fe4:	e59f3054 	ldr	r3, [pc, #84]	; 8f601040 <target_fastboot_init+0x80>
8f600fe8:	e5932000 	ldr	r2, [r3]
8f600fec:	e59d3004 	ldr	r3, [r13, #4]
8f600ff0:	e0332002 	eors	r2, r3, r2
8f600ff4:	e3a03000 	mov	r3, #0
8f600ff8:	1a00000f 	bne	8f60103c <target_fastboot_init+0x7c>
8f600ffc:	e28dd00c 	add	r13, r13, #12
8f601000:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		clock_ce_enable(CE1_INSTANCE);
8f601004:	e3a00001 	mov	r0, #1
8f601008:	eb000404 	bl	8f602020 <clock_ce_enable>
	if (!target_is_ssd_enabled())
8f60100c:	eb0082bd 	bl	8f621b08 <target_is_ssd_enabled>
8f601010:	e3500000 	cmp	r0, #0
8f601014:	0afffff2 	beq	8f600fe4 <target_fastboot_init+0x24>
8f601018:	e59f3020 	ldr	r3, [pc, #32]	; 8f601040 <target_fastboot_init+0x80>
8f60101c:	e5932000 	ldr	r2, [r3]
8f601020:	e59d3004 	ldr	r3, [r13, #4]
8f601024:	e0332002 	eors	r2, r3, r2
8f601028:	e3a03000 	mov	r3, #0
8f60102c:	1a000002 	bne	8f60103c <target_fastboot_init+0x7c>
}
8f601030:	e28dd00c 	add	r13, r13, #12
8f601034:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
8f601038:	eafffca2 	b	8f6002c8 <target_load_ssd_keystore.part.0>
8f60103c:	eb00c6df 	bl	8f632bc0 <__stack_chk_fail>
8f601040:	8f74221c 	.word	0x8f74221c

8f601044 <target_load_ssd_keystore>:
{
8f601044:	e59f3060 	ldr	r3, [pc, #96]	; 8f6010ac <target_load_ssd_keystore+0x68>
8f601048:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60104c:	e24dd00c 	sub	r13, r13, #12
8f601050:	e5933000 	ldr	r3, [r3]
8f601054:	e58d3004 	str	r3, [r13, #4]
8f601058:	e3a03000 	mov	r3, #0
	if (!target_is_ssd_enabled())
8f60105c:	eb0082a9 	bl	8f621b08 <target_is_ssd_enabled>
}
8f601060:	e59f3044 	ldr	r3, [pc, #68]	; 8f6010ac <target_load_ssd_keystore+0x68>
	if (!target_is_ssd_enabled())
8f601064:	e3500000 	cmp	r0, #0
8f601068:	1a000006 	bne	8f601088 <target_load_ssd_keystore+0x44>
}
8f60106c:	e5932000 	ldr	r2, [r3]
8f601070:	e59d3004 	ldr	r3, [r13, #4]
8f601074:	e0332002 	eors	r2, r3, r2
8f601078:	e3a03000 	mov	r3, #0
8f60107c:	1a000009 	bne	8f6010a8 <target_load_ssd_keystore+0x64>
8f601080:	e28dd00c 	add	r13, r13, #12
8f601084:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f601088:	e5932000 	ldr	r2, [r3]
8f60108c:	e59d3004 	ldr	r3, [r13, #4]
8f601090:	e0332002 	eors	r2, r3, r2
8f601094:	e3a03000 	mov	r3, #0
8f601098:	1a000002 	bne	8f6010a8 <target_load_ssd_keystore+0x64>
8f60109c:	e28dd00c 	add	r13, r13, #12
8f6010a0:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
8f6010a4:	eafffc87 	b	8f6002c8 <target_load_ssd_keystore.part.0>
8f6010a8:	eb00c6c4 	bl	8f632bc0 <__stack_chk_fail>
8f6010ac:	8f74221c 	.word	0x8f74221c

8f6010b0 <target_get_pmic>:
{
8f6010b0:	e59f3054 	ldr	r3, [pc, #84]	; 8f60110c <target_get_pmic+0x5c>
8f6010b4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6010b8:	e24dd00c 	sub	r13, r13, #12
8f6010bc:	e5933000 	ldr	r3, [r3]
8f6010c0:	e58d3004 	str	r3, [r13, #4]
8f6010c4:	e3a03000 	mov	r3, #0
	if (target_is_pmi_enabled()) {
8f6010c8:	eb0082e0 	bl	8f621c50 <target_is_pmi_enabled>
8f6010cc:	e3500000 	cmp	r0, #0
8f6010d0:	0a000004 	beq	8f6010e8 <target_get_pmic+0x38>
		uint32_t pmi_type = board_pmic_target(1) & PMIC_TYPE_MASK;
8f6010d4:	e3a00001 	mov	r0, #1
8f6010d8:	eb003c9a 	bl	8f610348 <board_pmic_target>
8f6010dc:	e6ef0070 	uxtb	r0, r0
			return PMIC_IS_PMI632;
		else
			return PMIC_IS_PMI8950;
8f6010e0:	e3500025 	cmp	r0, #37	; 0x25
8f6010e4:	13a00011 	movne	r0, #17
	}
	else {
		return PMIC_IS_UNKNOWN;
	}
}
8f6010e8:	e59f301c 	ldr	r3, [pc, #28]	; 8f60110c <target_get_pmic+0x5c>
8f6010ec:	e5932000 	ldr	r2, [r3]
8f6010f0:	e59d3004 	ldr	r3, [r13, #4]
8f6010f4:	e0332002 	eors	r2, r3, r2
8f6010f8:	e3a03000 	mov	r3, #0
8f6010fc:	1a000001 	bne	8f601108 <target_get_pmic+0x58>
8f601100:	e28dd00c 	add	r13, r13, #12
8f601104:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f601108:	eb00c6ac 	bl	8f632bc0 <__stack_chk_fail>
8f60110c:	8f74221c 	.word	0x8f74221c

8f601110 <pmic_reset_configure>:

void pmic_reset_configure(uint8_t reset_type)
{
8f601110:	e59f30a0 	ldr	r3, [pc, #160]	; 8f6011b8 <pmic_reset_configure+0xa8>
8f601114:	e92d4010 	push	{r4, r14}
8f601118:	e24dd008 	sub	r13, r13, #8
8f60111c:	e5933000 	ldr	r3, [r3]
8f601120:	e58d3004 	str	r3, [r13, #4]
8f601124:	e3a03000 	mov	r3, #0
8f601128:	e1a04000 	mov	r4, r0
	if (target_is_pmi_enabled()) {
8f60112c:	eb0082c7 	bl	8f621c50 <target_is_pmi_enabled>
8f601130:	e3500000 	cmp	r0, #0
8f601134:	1a00000f 	bne	8f601178 <pmic_reset_configure+0x68>
		pmi632_reset_configure(reset_type);
	}
	else
	{
		if (reset_type == PON_PSHOLD_HARD_RESET)
			sec_reset_type = PON_PSHOLD_SHUTDOWN;
8f601138:	e3540007 	cmp	r4, #7

		pm8996_reset_configure(PRI_PMIC_SLAVE_ID, reset_type);
8f60113c:	e1a01004 	mov	r1, r4
8f601140:	e3a00000 	mov	r0, #0
			sec_reset_type = PON_PSHOLD_SHUTDOWN;
8f601144:	03a04004 	moveq	r4, #4
		pm8996_reset_configure(PRI_PMIC_SLAVE_ID, reset_type);
8f601148:	eb00bfe9 	bl	8f6310f4 <pm8996_reset_configure>
		pm8996_reset_configure(SEC_PMIC_SLAVE_ID, sec_reset_type);
8f60114c:	e59f3064 	ldr	r3, [pc, #100]	; 8f6011b8 <pmic_reset_configure+0xa8>
8f601150:	e5932000 	ldr	r2, [r3]
8f601154:	e59d3004 	ldr	r3, [r13, #4]
8f601158:	e0332002 	eors	r2, r3, r2
8f60115c:	e3a03000 	mov	r3, #0
8f601160:	1a000013 	bne	8f6011b4 <pmic_reset_configure+0xa4>
8f601164:	e1a01004 	mov	r1, r4
8f601168:	e3a00002 	mov	r0, #2
	}
}
8f60116c:	e28dd008 	add	r13, r13, #8
8f601170:	e8bd4010 	pop	{r4, r14}
		pm8996_reset_configure(SEC_PMIC_SLAVE_ID, sec_reset_type);
8f601174:	ea00bfde 	b	8f6310f4 <pm8996_reset_configure>
		uint32_t pmi_type = board_pmic_target(1) & PMIC_TYPE_MASK;
8f601178:	e3a00001 	mov	r0, #1
8f60117c:	eb003c71 	bl	8f610348 <board_pmic_target>
8f601180:	e6ef0070 	uxtb	r0, r0
		if (pmi_type == PMIC_IS_PMI632)
8f601184:	e3500025 	cmp	r0, #37	; 0x25
8f601188:	1affffea 	bne	8f601138 <pmic_reset_configure+0x28>
		pmi632_reset_configure(reset_type);
8f60118c:	e59f3024 	ldr	r3, [pc, #36]	; 8f6011b8 <pmic_reset_configure+0xa8>
8f601190:	e5932000 	ldr	r2, [r3]
8f601194:	e59d3004 	ldr	r3, [r13, #4]
8f601198:	e0332002 	eors	r2, r3, r2
8f60119c:	e3a03000 	mov	r3, #0
8f6011a0:	1a000003 	bne	8f6011b4 <pmic_reset_configure+0xa4>
8f6011a4:	e1a00004 	mov	r0, r4
}
8f6011a8:	e28dd008 	add	r13, r13, #8
8f6011ac:	e8bd4010 	pop	{r4, r14}
		pmi632_reset_configure(reset_type);
8f6011b0:	ea00bf6c 	b	8f630f68 <pmi632_reset_configure>
		pm8996_reset_configure(SEC_PMIC_SLAVE_ID, sec_reset_type);
8f6011b4:	eb00c681 	bl	8f632bc0 <__stack_chk_fail>
8f6011b8:	8f74221c 	.word	0x8f74221c

8f6011bc <target_get_qmp_settings>:
	{0x808, 0x03}, /* PCIE_USB3_PCS_START_CONTROL */
	{0x800, 0x00}, /* PCIE_USB3_PCS_SW_RESET */
};

struct qmp_reg *target_get_qmp_settings()
{
8f6011bc:	e59f303c 	ldr	r3, [pc, #60]	; 8f601200 <target_get_qmp_settings+0x44>
8f6011c0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6011c4:	e24dd00c 	sub	r13, r13, #12
8f6011c8:	e5933000 	ldr	r3, [r3]
8f6011cc:	e58d3004 	str	r3, [r13, #4]
8f6011d0:	e3a03000 	mov	r3, #0
	return qmp_settings;
}
8f6011d4:	e59f3024 	ldr	r3, [pc, #36]	; 8f601200 <target_get_qmp_settings+0x44>
8f6011d8:	e5932000 	ldr	r2, [r3]
8f6011dc:	e59d3004 	ldr	r3, [r13, #4]
8f6011e0:	e0332002 	eors	r2, r3, r2
8f6011e4:	e3a03000 	mov	r3, #0
8f6011e8:	1a000003 	bne	8f6011fc <target_get_qmp_settings+0x40>
8f6011ec:	e30c00b0 	movw	r0, #49328	; 0xc0b0
8f6011f0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6011f4:	e28dd00c 	add	r13, r13, #12
8f6011f8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6011fc:	eb00c66f 	bl	8f632bc0 <__stack_chk_fail>
8f601200:	8f74221c 	.word	0x8f74221c

8f601204 <target_get_qmp_regsize>:

int target_get_qmp_regsize()
{
8f601204:	e59f3038 	ldr	r3, [pc, #56]	; 8f601244 <target_get_qmp_regsize+0x40>
8f601208:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60120c:	e24dd00c 	sub	r13, r13, #12
8f601210:	e5933000 	ldr	r3, [r3]
8f601214:	e58d3004 	str	r3, [r13, #4]
8f601218:	e3a03000 	mov	r3, #0
	return ARRAY_SIZE(qmp_settings);
}
8f60121c:	e59f3020 	ldr	r3, [pc, #32]	; 8f601244 <target_get_qmp_regsize+0x40>
8f601220:	e5932000 	ldr	r2, [r3]
8f601224:	e59d3004 	ldr	r3, [r13, #4]
8f601228:	e0332002 	eors	r2, r3, r2
8f60122c:	e3a03000 	mov	r3, #0
8f601230:	1a000002 	bne	8f601240 <target_get_qmp_regsize+0x3c>
8f601234:	e3a00043 	mov	r0, #67	; 0x43
8f601238:	e28dd00c 	add	r13, r13, #12
8f60123c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f601240:	eb00c65e 	bl	8f632bc0 <__stack_chk_fail>
8f601244:	8f74221c 	.word	0x8f74221c

8f601248 <target_dev_tree_mem>:
#include <libfdt.h>
#include <platform/iomap.h>
#include <dev_tree.h>

uint32_t target_dev_tree_mem(void *fdt, uint32_t memory_node_offset)
{
8f601248:	e59f3100 	ldr	r3, [pc, #256]	; 8f601350 <target_dev_tree_mem+0x108>
8f60124c:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f601250:	e24dd058 	sub	r13, r13, #88	; 0x58
8f601254:	e5933000 	ldr	r3, [r3]
8f601258:	e58d3054 	str	r3, [r13, #84]	; 0x54
8f60125c:	e3a03000 	mov	r3, #0
	unsigned int index;
	int ret = 0;
	uint32_t len = 0;

	/* Make sure RAM partition table is initialized */
	ASSERT(smem_ram_ptable_init_v1());
8f601260:	e1a0400e 	mov	r4, r14
{
8f601264:	e1a07000 	mov	r7, r0
8f601268:	e1a08001 	mov	r8, r1
	ASSERT(smem_ram_ptable_init_v1());
8f60126c:	eb0006ed 	bl	8f602e28 <smem_ram_ptable_init_v1>
8f601270:	e3500000 	cmp	r0, #0
8f601274:	0a000029 	beq	8f601320 <target_dev_tree_mem+0xd8>

	len = smem_get_ram_ptable_len();
8f601278:	eb00074c 	bl	8f602fb0 <smem_get_ram_ptable_len>

	/* Calculating the size of the mem_info_ptr */
	for (index = 0 ; index < len; index++)
8f60127c:	e2505000 	subs	r5, r0, #0
8f601280:	13a04000 	movne	r4, #0
8f601284:	1a000003 	bne	8f601298 <target_dev_tree_mem+0x50>
8f601288:	ea00001b 	b	8f6012fc <target_dev_tree_mem+0xb4>
8f60128c:	e2844001 	add	r4, r4, #1
8f601290:	e1550004 	cmp	r5, r4
8f601294:	0a000018 	beq	8f6012fc <target_dev_tree_mem+0xb4>
	{
		smem_get_ram_ptable_entry(&ptn_entry, index);
8f601298:	e28d000c 	add	r0, r13, #12
8f60129c:	e1a01004 	mov	r1, r4
8f6012a0:	eb00072c 	bl	8f602f58 <smem_get_ram_ptable_entry>

		if((ptn_entry.category == SDRAM) &&
8f6012a4:	e59d3030 	ldr	r3, [r13, #48]	; 0x30
8f6012a8:	e353000e 	cmp	r3, #14
8f6012ac:	1afffff6 	bne	8f60128c <target_dev_tree_mem+0x44>
8f6012b0:	e59d3038 	ldr	r3, [r13, #56]	; 0x38
8f6012b4:	e3530001 	cmp	r3, #1
8f6012b8:	1afffff3 	bne	8f60128c <target_dev_tree_mem+0x44>
			(ptn_entry.type == SYS_MEMORY))
		{

			/* Pass along all other usable memory regions to Linux */
			ret = dev_tree_add_mem_info(fdt,
8f6012bc:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f6012c0:	e1a01008 	mov	r1, r8
8f6012c4:	e59d201c 	ldr	r2, [r13, #28]
8f6012c8:	e1a00007 	mov	r0, r7
8f6012cc:	e58d3000 	str	r3, [r13]
8f6012d0:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f6012d4:	e58d3004 	str	r3, [r13, #4]
8f6012d8:	e59d3020 	ldr	r3, [r13, #32]
8f6012dc:	eb005f8b 	bl	8f619110 <dev_tree_add_mem_info>
							memory_node_offset,
							ptn_entry.start,
							ptn_entry.size);

			if (ret)
8f6012e0:	e2506000 	subs	r6, r0, #0
8f6012e4:	0affffe8 	beq	8f60128c <target_dev_tree_mem+0x44>
			{
				dprintf(CRITICAL, "Failed to add secondary banks memory addresses\n");
8f6012e8:	e30002ac 	movw	r0, #684	; 0x2ac
8f6012ec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6012f0:	eb00c59f 	bl	8f632974 <_dprintf>
			}
		}
	}
target_dev_tree_mem_err:

	return ret;
8f6012f4:	e1a00006 	mov	r0, r6
				goto target_dev_tree_mem_err;
8f6012f8:	ea000000 	b	8f601300 <target_dev_tree_mem+0xb8>
	for (index = 0 ; index < len; index++)
8f6012fc:	e3a00000 	mov	r0, #0
}
8f601300:	e59f3048 	ldr	r3, [pc, #72]	; 8f601350 <target_dev_tree_mem+0x108>
8f601304:	e5932000 	ldr	r2, [r3]
8f601308:	e59d3054 	ldr	r3, [r13, #84]	; 0x54
8f60130c:	e0332002 	eors	r2, r3, r2
8f601310:	e3a03000 	mov	r3, #0
8f601314:	1a00000c 	bne	8f60134c <target_dev_tree_mem+0x104>
8f601318:	e28dd058 	add	r13, r13, #88	; 0x58
8f60131c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
	ASSERT(smem_ram_ptable_init_v1());
8f601320:	e3001290 	movw	r1, #656	; 0x290
8f601324:	e3002274 	movw	r2, #628	; 0x274
8f601328:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60132c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601330:	e58d1000 	str	r1, [r13]
8f601334:	e3a0302e 	mov	r3, #46	; 0x2e
8f601338:	e1a00004 	mov	r0, r4
8f60133c:	e3001130 	movw	r1, #304	; 0x130
8f601340:	e3481f70 	movt	r1, #36720	; 0x8f70
8f601344:	eb00c5dc 	bl	8f632abc <_panic>
8f601348:	eaffffca 	b	8f601278 <target_dev_tree_mem+0x30>
}
8f60134c:	eb00c61b 	bl	8f632bc0 <__stack_chk_fail>
8f601350:	8f74221c 	.word	0x8f74221c

8f601354 <target_get_scratch_address>:

void *target_get_scratch_address(void)
{
8f601354:	e59f303c 	ldr	r3, [pc, #60]	; 8f601398 <target_get_scratch_address+0x44>
8f601358:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60135c:	e24dd00c 	sub	r13, r13, #12
8f601360:	e5933000 	ldr	r3, [r3]
8f601364:	e58d3004 	str	r3, [r13, #4]
8f601368:	e3a03000 	mov	r3, #0
	return ((void *)SCRATCH_ADDR);
}
8f60136c:	e59f3024 	ldr	r3, [pc, #36]	; 8f601398 <target_get_scratch_address+0x44>
8f601370:	e5932000 	ldr	r2, [r3]
8f601374:	e59d3004 	ldr	r3, [r13, #4]
8f601378:	e0332002 	eors	r2, r3, r2
8f60137c:	e3a03000 	mov	r3, #0
8f601380:	1a000003 	bne	8f601394 <target_get_scratch_address+0x40>
8f601384:	e3a00000 	mov	r0, #0
8f601388:	e34a0010 	movt	r0, #40976	; 0xa010
8f60138c:	e28dd00c 	add	r13, r13, #12
8f601390:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f601394:	eb00c609 	bl	8f632bc0 <__stack_chk_fail>
8f601398:	8f74221c 	.word	0x8f74221c

8f60139c <target_get_max_flash_size>:

unsigned target_get_max_flash_size(void)
{
8f60139c:	e59f303c 	ldr	r3, [pc, #60]	; 8f6013e0 <target_get_max_flash_size+0x44>
8f6013a0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6013a4:	e24dd00c 	sub	r13, r13, #12
8f6013a8:	e5933000 	ldr	r3, [r3]
8f6013ac:	e58d3004 	str	r3, [r13, #4]
8f6013b0:	e3a03000 	mov	r3, #0
	return (SCRATCH_SIZE * 1048576);
}
8f6013b4:	e59f3024 	ldr	r3, [pc, #36]	; 8f6013e0 <target_get_max_flash_size+0x44>
8f6013b8:	e5932000 	ldr	r2, [r3]
8f6013bc:	e59d3004 	ldr	r3, [r13, #4]
8f6013c0:	e0332002 	eors	r2, r3, r2
8f6013c4:	e3a03000 	mov	r3, #0
8f6013c8:	1a000003 	bne	8f6013dc <target_get_max_flash_size+0x40>
8f6013cc:	e3a00000 	mov	r0, #0
8f6013d0:	e3410fe0 	movt	r0, #8160	; 0x1fe0
8f6013d4:	e28dd00c 	add	r13, r13, #12
8f6013d8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6013dc:	eb00c5f7 	bl	8f632bc0 <__stack_chk_fail>
8f6013e0:	8f74221c 	.word	0x8f74221c

8f6013e4 <muxdiv_configure.constprop.0>:
	qgic_init();
	qtimer_init();
	scm_init();
}

static void muxdiv_configure(unsigned int base_addr, unsigned src, unsigned div)
8f6013e4:	e59f3088 	ldr	r3, [pc, #136]	; 8f601474 <muxdiv_configure.constprop.0+0x90>
8f6013e8:	e92d4030 	push	{r4, r5, r14}
8f6013ec:	e24dd00c 	sub	r13, r13, #12
8f6013f0:	e5933000 	ldr	r3, [r3]
8f6013f4:	e58d3004 	str	r3, [r13, #4]
8f6013f8:	e3a03000 	mov	r3, #0
8f6013fc:	e1a05000 	mov	r5, r0
{
	int timeout = 500;
	void *base = (void*) base_addr;

	writel(((src & 7) << 8) | (div & 0x1f), base + 4);
8f601400:	e3003401 	movw	r3, #1025	; 0x401
8f601404:	e5803004 	str	r3, [r0, #4]
	dmb();
8f601408:	eb007f3f 	bl	8f62110c <dmb>

	/* Set update bit */
	writel(readl_relaxed(base) | BIT(0), base);
8f60140c:	e5953000 	ldr	r3, [r5]
	dmb();
8f601410:	e3a04f7d 	mov	r4, #500	; 0x1f4
	writel(readl_relaxed(base) | BIT(0), base);
8f601414:	e3833001 	orr	r3, r3, #1
8f601418:	e5853000 	str	r3, [r5]
	dmb();
8f60141c:	eb007f3a 	bl	8f62110c <dmb>

	while (timeout-- && readl_relaxed(base) & BIT(0))
8f601420:	ea000003 	b	8f601434 <muxdiv_configure.constprop.0+0x50>
		udelay(1);
8f601424:	e3a00001 	mov	r0, #1
8f601428:	eb00364b 	bl	8f60ed5c <udelay>
	while (timeout-- && readl_relaxed(base) & BIT(0))
8f60142c:	e2544001 	subs	r4, r4, #1
8f601430:	0a000002 	beq	8f601440 <muxdiv_configure.constprop.0+0x5c>
8f601434:	e5953000 	ldr	r3, [r5]
8f601438:	e3130001 	tst	r3, #1
8f60143c:	1afffff8 	bne	8f601424 <muxdiv_configure.constprop.0+0x40>

	/* Enable the branch */
	writel(readl_relaxed(base + 8) | BIT(0), base + 8);
8f601440:	e5953008 	ldr	r3, [r5, #8]
8f601444:	e3833001 	orr	r3, r3, #1
8f601448:	e5853008 	str	r3, [r5, #8]
	dmb();
8f60144c:	e59f3020 	ldr	r3, [pc, #32]	; 8f601474 <muxdiv_configure.constprop.0+0x90>
8f601450:	e5932000 	ldr	r2, [r3]
8f601454:	e59d3004 	ldr	r3, [r13, #4]
8f601458:	e0332002 	eors	r2, r3, r2
8f60145c:	e3a03000 	mov	r3, #0
8f601460:	1a000002 	bne	8f601470 <muxdiv_configure.constprop.0+0x8c>
}
8f601464:	e28dd00c 	add	r13, r13, #12
8f601468:	e8bd4030 	pop	{r4, r5, r14}
	dmb();
8f60146c:	ea007f26 	b	8f62110c <dmb>
8f601470:	eb00c5d2 	bl	8f632bc0 <__stack_chk_fail>
8f601474:	8f74221c 	.word	0x8f74221c

8f601478 <platform_early_init>:
{
8f601478:	e59f3048 	ldr	r3, [pc, #72]	; 8f6014c8 <platform_early_init+0x50>
8f60147c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f601480:	e24dd00c 	sub	r13, r13, #12
8f601484:	e5933000 	ldr	r3, [r3]
8f601488:	e58d3004 	str	r3, [r13, #4]
8f60148c:	e3a03000 	mov	r3, #0
	board_init();
8f601490:	eb003d44 	bl	8f6109a8 <board_init>
	platform_clock_init();
8f601494:	eb00042e 	bl	8f602554 <platform_clock_init>
	qgic_init();
8f601498:	eb00179e 	bl	8f607318 <qgic_init>
	qtimer_init();
8f60149c:	eb00365b 	bl	8f60ee10 <qtimer_init>
	scm_init();
8f6014a0:	e59f3020 	ldr	r3, [pc, #32]	; 8f6014c8 <platform_early_init+0x50>
8f6014a4:	e5932000 	ldr	r2, [r3]
8f6014a8:	e59d3004 	ldr	r3, [r13, #4]
8f6014ac:	e0332002 	eors	r2, r3, r2
8f6014b0:	e3a03000 	mov	r3, #0
8f6014b4:	1a000002 	bne	8f6014c4 <platform_early_init+0x4c>
}
8f6014b8:	e28dd00c 	add	r13, r13, #12
8f6014bc:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	scm_init();
8f6014c0:	ea0048d0 	b	8f613808 <scm_init>
8f6014c4:	eb00c5bd 	bl	8f632bc0 <__stack_chk_fail>
8f6014c8:	8f74221c 	.word	0x8f74221c

8f6014cc <platform_init>:

void platform_init(void)
{
8f6014cc:	e59f3058 	ldr	r3, [pc, #88]	; 8f60152c <platform_init+0x60>
	dprintf(INFO, "platform_init()\n");
8f6014d0:	e30002dc 	movw	r0, #732	; 0x2dc
{
8f6014d4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	dprintf(INFO, "platform_init()\n");
8f6014d8:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f6014dc:	e24dd00c 	sub	r13, r13, #12
8f6014e0:	e5933000 	ldr	r3, [r3]
8f6014e4:	e58d3004 	str	r3, [r13, #4]
8f6014e8:	e3a03000 	mov	r3, #0
	dprintf(INFO, "platform_init()\n");
8f6014ec:	eb00c520 	bl	8f632974 <_dprintf>
	muxdiv_configure(0xb111050, 4, 1); // 800Mhz
8f6014f0:	e3010050 	movw	r0, #4176	; 0x1050
8f6014f4:	e3400b11 	movt	r0, #2833	; 0xb11
8f6014f8:	ebffffb9 	bl	8f6013e4 <muxdiv_configure.constprop.0>
	muxdiv_configure(0xb011050, 4, 1); // 800Mhz
8f6014fc:	e59f3028 	ldr	r3, [pc, #40]	; 8f60152c <platform_init+0x60>
8f601500:	e5932000 	ldr	r2, [r3]
8f601504:	e59d3004 	ldr	r3, [r13, #4]
8f601508:	e0332002 	eors	r2, r3, r2
8f60150c:	e3a03000 	mov	r3, #0
8f601510:	1a000004 	bne	8f601528 <platform_init+0x5c>
8f601514:	e3010050 	movw	r0, #4176	; 0x1050
8f601518:	e3400b01 	movt	r0, #2817	; 0xb01
}
8f60151c:	e28dd00c 	add	r13, r13, #12
8f601520:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	muxdiv_configure(0xb011050, 4, 1); // 800Mhz
8f601524:	eaffffae 	b	8f6013e4 <muxdiv_configure.constprop.0>
8f601528:	eb00c5a4 	bl	8f632bc0 <__stack_chk_fail>
8f60152c:	8f74221c 	.word	0x8f74221c

8f601530 <platform_uninit>:

void platform_uninit(void)
{
8f601530:	e59f3038 	ldr	r3, [pc, #56]	; 8f601570 <platform_uninit+0x40>
8f601534:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f601538:	e24dd00c 	sub	r13, r13, #12
8f60153c:	e5933000 	ldr	r3, [r3]
8f601540:	e58d3004 	str	r3, [r13, #4]
8f601544:	e3a03000 	mov	r3, #0
	qtimer_uninit();
8f601548:	e59f3020 	ldr	r3, [pc, #32]	; 8f601570 <platform_uninit+0x40>
8f60154c:	e5932000 	ldr	r2, [r3]
8f601550:	e59d3004 	ldr	r3, [r13, #4]
8f601554:	e0332002 	eors	r2, r3, r2
8f601558:	e3a03000 	mov	r3, #0
8f60155c:	1a000002 	bne	8f60156c <platform_uninit+0x3c>
}
8f601560:	e28dd00c 	add	r13, r13, #12
8f601564:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	qtimer_uninit();
8f601568:	ea0035d2 	b	8f60ecb8 <qtimer_uninit>
8f60156c:	eb00c593 	bl	8f632bc0 <__stack_chk_fail>
8f601570:	8f74221c 	.word	0x8f74221c

8f601574 <platform_get_sclk_count>:

uint32_t platform_get_sclk_count(void)
{
8f601574:	e59f2040 	ldr	r2, [pc, #64]	; 8f6015bc <platform_get_sclk_count+0x48>
	return readl(MPM2_MPM_SLEEP_TIMETICK_COUNT_VAL);
8f601578:	e3a03a03 	mov	r3, #12288	; 0x3000
{
8f60157c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f601580:	e24dd00c 	sub	r13, r13, #12
	return readl(MPM2_MPM_SLEEP_TIMETICK_COUNT_VAL);
8f601584:	e340304a 	movt	r3, #74	; 0x4a
{
8f601588:	e5922000 	ldr	r2, [r2]
8f60158c:	e58d2004 	str	r2, [r13, #4]
8f601590:	e3a02000 	mov	r2, #0
	return readl(MPM2_MPM_SLEEP_TIMETICK_COUNT_VAL);
8f601594:	e5930000 	ldr	r0, [r3]
}
8f601598:	e59f301c 	ldr	r3, [pc, #28]	; 8f6015bc <platform_get_sclk_count+0x48>
8f60159c:	e5932000 	ldr	r2, [r3]
8f6015a0:	e59d3004 	ldr	r3, [r13, #4]
8f6015a4:	e0332002 	eors	r2, r3, r2
8f6015a8:	e3a03000 	mov	r3, #0
8f6015ac:	1a000001 	bne	8f6015b8 <platform_get_sclk_count+0x44>
8f6015b0:	e28dd00c 	add	r13, r13, #12
8f6015b4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6015b8:	eb00c580 	bl	8f632bc0 <__stack_chk_fail>
8f6015bc:	8f74221c 	.word	0x8f74221c

8f6015c0 <get_bs_info_addr>:

addr_t get_bs_info_addr()
{
8f6015c0:	e59f303c 	ldr	r3, [pc, #60]	; 8f601604 <get_bs_info_addr+0x44>
8f6015c4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6015c8:	e24dd00c 	sub	r13, r13, #12
8f6015cc:	e5933000 	ldr	r3, [r3]
8f6015d0:	e58d3004 	str	r3, [r13, #4]
8f6015d4:	e3a03000 	mov	r3, #0
	return ((addr_t)BS_INFO_ADDR);
}
8f6015d8:	e59f3024 	ldr	r3, [pc, #36]	; 8f601604 <get_bs_info_addr+0x44>
8f6015dc:	e5932000 	ldr	r2, [r3]
8f6015e0:	e59d3004 	ldr	r3, [r13, #4]
8f6015e4:	e0332002 	eors	r2, r3, r2
8f6015e8:	e3a03000 	mov	r3, #0
8f6015ec:	1a000003 	bne	8f601600 <get_bs_info_addr+0x40>
8f6015f0:	e3a00e6b 	mov	r0, #1712	; 0x6b0
8f6015f4:	e3400860 	movt	r0, #2144	; 0x860
8f6015f8:	e28dd00c 	add	r13, r13, #12
8f6015fc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f601600:	eb00c56e 	bl	8f632bc0 <__stack_chk_fail>
8f601604:	8f74221c 	.word	0x8f74221c

8f601608 <platform_use_identity_mmu_mappings>:

int platform_use_identity_mmu_mappings(void)
{
8f601608:	e59f3038 	ldr	r3, [pc, #56]	; 8f601648 <platform_use_identity_mmu_mappings+0x40>
8f60160c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f601610:	e24dd00c 	sub	r13, r13, #12
8f601614:	e5933000 	ldr	r3, [r3]
8f601618:	e58d3004 	str	r3, [r13, #4]
8f60161c:	e3a03000 	mov	r3, #0
	/* Use only the mappings specified in this file. */
	return 0;
}
8f601620:	e59f3020 	ldr	r3, [pc, #32]	; 8f601648 <platform_use_identity_mmu_mappings+0x40>
8f601624:	e5932000 	ldr	r2, [r3]
8f601628:	e59d3004 	ldr	r3, [r13, #4]
8f60162c:	e0332002 	eors	r2, r3, r2
8f601630:	e3a03000 	mov	r3, #0
8f601634:	1a000002 	bne	8f601644 <platform_use_identity_mmu_mappings+0x3c>
8f601638:	e3a00000 	mov	r0, #0
8f60163c:	e28dd00c 	add	r13, r13, #12
8f601640:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f601644:	eb00c55d 	bl	8f632bc0 <__stack_chk_fail>
8f601648:	8f74221c 	.word	0x8f74221c

8f60164c <platform_init_mmu_mappings>:

/* Setup MMU mapping for this platform */
void platform_init_mmu_mappings(void)
{
8f60164c:	e59f30fc 	ldr	r3, [pc, #252]	; 8f601750 <platform_init_mmu_mappings+0x104>
8f601650:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f601654:	e24dd00c 	sub	r13, r13, #12
8f601658:	e5933000 	ldr	r3, [r3]
8f60165c:	e58d3004 	str	r3, [r13, #4]
8f601660:	e3a03000 	mov	r3, #0
	uint32_t i;
	uint32_t sections;
	uint32_t table_size = ARRAY_SIZE(mmu_section_table);
	uint32_t ddr_start = DDR_START;
8f601664:	eb000677 	bl	8f603048 <get_ddr_start>
 */
uint32_t platform_get_smem_base_addr()
{
	struct smem_addr_info *smem_info = NULL;

	smem_info = (struct smem_addr_info *)readl(TCSR_TZ_WONCE);
8f601668:	e3a03a0d 	mov	r3, #53248	; 0xd000
8f60166c:	e3403193 	movt	r3, #403	; 0x193
8f601670:	e5933000 	ldr	r3, [r3]
	if(smem_info && (smem_info->identifier == SMEM_TARGET_INFO_IDENTIFIER))
8f601674:	e3530000 	cmp	r3, #0
	uint32_t ddr_start = DDR_START;
8f601678:	e1a05000 	mov	r5, r0
	if(smem_info && (smem_info->identifier == SMEM_TARGET_INFO_IDENTIFIER))
8f60167c:	0a000005 	beq	8f601698 <platform_init_mmu_mappings+0x4c>
8f601680:	e5931000 	ldr	r1, [r3]
8f601684:	e3042953 	movw	r2, #18771	; 0x4953
8f601688:	e3442949 	movt	r2, #18761	; 0x4949
8f60168c:	e1510002 	cmp	r1, r2
		return smem_info->phy_addr;
8f601690:	05936008 	ldreq	r6, [r3, #8]
	if(smem_info && (smem_info->identifier == SMEM_TARGET_INFO_IDENTIFIER))
8f601694:	0a000001 	beq	8f6016a0 <platform_init_mmu_mappings+0x54>
	else
		return MSM_SHARED_BASE;
8f601698:	e3a06000 	mov	r6, #0
8f60169c:	e3486630 	movt	r6, #34352	; 0x8630
	while(sections--)
8f6016a0:	e2854659 	add	r4, r5, #93323264	; 0x5900000
		arm_mmu_map_section(ddr_start + sections * MB, ddr_start + sections* MB, COMMON_MEMORY);
8f6016a4:	e1a01004 	mov	r1, r4
8f6016a8:	e1a00004 	mov	r0, r4
8f6016ac:	e3002c18 	movw	r2, #3096	; 0xc18
8f6016b0:	eb007ffe 	bl	8f6216b0 <arm_mmu_map_section>
	while(sections--)
8f6016b4:	e1550004 	cmp	r5, r4
8f6016b8:	e2444601 	sub	r4, r4, #1048576	; 0x100000
8f6016bc:	1afffff8 	bne	8f6016a4 <platform_init_mmu_mappings+0x58>
	arm_mmu_map_section(smem_addr, smem_addr, COMMON_MEMORY);
8f6016c0:	e3002c18 	movw	r2, #3096	; 0xc18
8f6016c4:	e1a01006 	mov	r1, r6
8f6016c8:	e1a00006 	mov	r0, r6
8f6016cc:	e30082f0 	movw	r8, #752	; 0x2f0
8f6016d0:	eb007ff6 	bl	8f6216b0 <arm_mmu_map_section>
	for (i = 0; i < table_size; i++)
8f6016d4:	e3488f70 	movt	r8, #36720	; 0x8f70
8f6016d8:	e2889080 	add	r9, r8, #128	; 0x80
	arm_mmu_map_section(smem_addr, smem_addr, COMMON_MEMORY);
8f6016dc:	e3a05001 	mov	r5, #1
		while (sections--)
8f6016e0:	e3550000 	cmp	r5, #0
8f6016e4:	e2455001 	sub	r5, r5, #1
8f6016e8:	0a00000b 	beq	8f60171c <platform_init_mmu_mappings+0xd0>
								mmu_section_table[i].vaddress +
8f6016ec:	e8980048 	ldm	r8, {r3, r6}
			arm_mmu_map_section(mmu_section_table[i].paddress +
8f6016f0:	e598700c 	ldr	r7, [r8, #12]
8f6016f4:	e0834a05 	add	r4, r3, r5, lsl #20
8f6016f8:	e0466003 	sub	r6, r6, r3
8f6016fc:	e0861004 	add	r1, r6, r4
8f601700:	e1a00004 	mov	r0, r4
		while (sections--)
8f601704:	e2455001 	sub	r5, r5, #1
			arm_mmu_map_section(mmu_section_table[i].paddress +
8f601708:	e1a02007 	mov	r2, r7
8f60170c:	eb007fe7 	bl	8f6216b0 <arm_mmu_map_section>
		while (sections--)
8f601710:	e3750001 	cmn	r5, #1
8f601714:	e2444601 	sub	r4, r4, #1048576	; 0x100000
8f601718:	1afffff7 	bne	8f6016fc <platform_init_mmu_mappings+0xb0>
	for (i = 0; i < table_size; i++)
8f60171c:	e2888010 	add	r8, r8, #16
8f601720:	e1580009 	cmp	r8, r9
		sections = mmu_section_table[i].num_of_sections;
8f601724:	15985008 	ldrne	r5, [r8, #8]
8f601728:	1affffec 	bne	8f6016e0 <platform_init_mmu_mappings+0x94>
}
8f60172c:	e59f301c 	ldr	r3, [pc, #28]	; 8f601750 <platform_init_mmu_mappings+0x104>
8f601730:	e5932000 	ldr	r2, [r3]
8f601734:	e59d3004 	ldr	r3, [r13, #4]
8f601738:	e0332002 	eors	r2, r3, r2
8f60173c:	e3a03000 	mov	r3, #0
8f601740:	1a000001 	bne	8f60174c <platform_init_mmu_mappings+0x100>
8f601744:	e28dd00c 	add	r13, r13, #12
8f601748:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
8f60174c:	eb00c51b 	bl	8f632bc0 <__stack_chk_fail>
8f601750:	8f74221c 	.word	0x8f74221c

8f601754 <platform_get_virt_to_phys_mapping>:
{
8f601754:	e59f3034 	ldr	r3, [pc, #52]	; 8f601790 <platform_get_virt_to_phys_mapping+0x3c>
8f601758:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60175c:	e24dd00c 	sub	r13, r13, #12
8f601760:	e5933000 	ldr	r3, [r3]
8f601764:	e58d3004 	str	r3, [r13, #4]
8f601768:	e3a03000 	mov	r3, #0
}
8f60176c:	e59f301c 	ldr	r3, [pc, #28]	; 8f601790 <platform_get_virt_to_phys_mapping+0x3c>
8f601770:	e5932000 	ldr	r2, [r3]
8f601774:	e59d3004 	ldr	r3, [r13, #4]
8f601778:	e0332002 	eors	r2, r3, r2
8f60177c:	e3a03000 	mov	r3, #0
8f601780:	1a000001 	bne	8f60178c <platform_get_virt_to_phys_mapping+0x38>
8f601784:	e28dd00c 	add	r13, r13, #12
8f601788:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60178c:	eb00c50b 	bl	8f632bc0 <__stack_chk_fail>
8f601790:	8f74221c 	.word	0x8f74221c

8f601794 <platform_get_phys_to_virt_mapping>:
8f601794:	e59f3034 	ldr	r3, [pc, #52]	; 8f6017d0 <platform_get_phys_to_virt_mapping+0x3c>
8f601798:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60179c:	e24dd00c 	sub	r13, r13, #12
8f6017a0:	e5933000 	ldr	r3, [r3]
8f6017a4:	e58d3004 	str	r3, [r13, #4]
8f6017a8:	e3a03000 	mov	r3, #0
8f6017ac:	e59f301c 	ldr	r3, [pc, #28]	; 8f6017d0 <platform_get_phys_to_virt_mapping+0x3c>
8f6017b0:	e5932000 	ldr	r2, [r3]
8f6017b4:	e59d3004 	ldr	r3, [r13, #4]
8f6017b8:	e0332002 	eors	r2, r3, r2
8f6017bc:	e3a03000 	mov	r3, #0
8f6017c0:	1a000001 	bne	8f6017cc <platform_get_phys_to_virt_mapping+0x38>
8f6017c4:	e28dd00c 	add	r13, r13, #12
8f6017c8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6017cc:	eb00c4fb 	bl	8f632bc0 <__stack_chk_fail>
8f6017d0:	8f74221c 	.word	0x8f74221c

8f6017d4 <platform_get_max_periph>:
{
8f6017d4:	e59f3038 	ldr	r3, [pc, #56]	; 8f601814 <platform_get_max_periph+0x40>
8f6017d8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6017dc:	e24dd00c 	sub	r13, r13, #12
8f6017e0:	e5933000 	ldr	r3, [r3]
8f6017e4:	e58d3004 	str	r3, [r13, #4]
8f6017e8:	e3a03000 	mov	r3, #0
}
8f6017ec:	e59f3020 	ldr	r3, [pc, #32]	; 8f601814 <platform_get_max_periph+0x40>
8f6017f0:	e5932000 	ldr	r2, [r3]
8f6017f4:	e59d3004 	ldr	r3, [r13, #4]
8f6017f8:	e0332002 	eors	r2, r3, r2
8f6017fc:	e3a03000 	mov	r3, #0
8f601800:	1a000002 	bne	8f601810 <platform_get_max_periph+0x3c>
8f601804:	e3a00c01 	mov	r0, #256	; 0x100
8f601808:	e28dd00c 	add	r13, r13, #12
8f60180c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f601810:	eb00c4ea 	bl	8f632bc0 <__stack_chk_fail>
8f601814:	8f74221c 	.word	0x8f74221c

8f601818 <platform_get_smem_base_addr>:
{
8f601818:	e59f2068 	ldr	r2, [pc, #104]	; 8f601888 <platform_get_smem_base_addr+0x70>
	smem_info = (struct smem_addr_info *)readl(TCSR_TZ_WONCE);
8f60181c:	e3a03a0d 	mov	r3, #53248	; 0xd000
{
8f601820:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f601824:	e24dd00c 	sub	r13, r13, #12
	smem_info = (struct smem_addr_info *)readl(TCSR_TZ_WONCE);
8f601828:	e3403193 	movt	r3, #403	; 0x193
{
8f60182c:	e5922000 	ldr	r2, [r2]
8f601830:	e58d2004 	str	r2, [r13, #4]
8f601834:	e3a02000 	mov	r2, #0
	smem_info = (struct smem_addr_info *)readl(TCSR_TZ_WONCE);
8f601838:	e5933000 	ldr	r3, [r3]
	if(smem_info && (smem_info->identifier == SMEM_TARGET_INFO_IDENTIFIER))
8f60183c:	e3530000 	cmp	r3, #0
8f601840:	0a000005 	beq	8f60185c <platform_get_smem_base_addr+0x44>
8f601844:	e5931000 	ldr	r1, [r3]
8f601848:	e3042953 	movw	r2, #18771	; 0x4953
8f60184c:	e3442949 	movt	r2, #18761	; 0x4949
8f601850:	e1510002 	cmp	r1, r2
		return smem_info->phy_addr;
8f601854:	05930008 	ldreq	r0, [r3, #8]
	if(smem_info && (smem_info->identifier == SMEM_TARGET_INFO_IDENTIFIER))
8f601858:	0a000001 	beq	8f601864 <platform_get_smem_base_addr+0x4c>
		return MSM_SHARED_BASE;
8f60185c:	e3a00000 	mov	r0, #0
8f601860:	e3480630 	movt	r0, #34352	; 0x8630
}
8f601864:	e59f301c 	ldr	r3, [pc, #28]	; 8f601888 <platform_get_smem_base_addr+0x70>
8f601868:	e5932000 	ldr	r2, [r3]
8f60186c:	e59d3004 	ldr	r3, [r13, #4]
8f601870:	e0332002 	eors	r2, r3, r2
8f601874:	e3a03000 	mov	r3, #0
8f601878:	1a000001 	bne	8f601884 <platform_get_smem_base_addr+0x6c>
8f60187c:	e28dd00c 	add	r13, r13, #12
8f601880:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f601884:	eb00c4cd 	bl	8f632bc0 <__stack_chk_fail>
8f601888:	8f74221c 	.word	0x8f74221c

8f60188c <platform_is_msm8953>:

int platform_is_msm8953()
{
8f60188c:	e59f3080 	ldr	r3, [pc, #128]	; 8f601914 <platform_is_msm8953+0x88>
8f601890:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f601894:	e24dd00c 	sub	r13, r13, #12
8f601898:	e5933000 	ldr	r3, [r3]
8f60189c:	e58d3004 	str	r3, [r13, #4]
8f6018a0:	e3a03000 	mov	r3, #0
	uint32_t platform = board_platform_id();
8f6018a4:	eb003a48 	bl	8f6101cc <board_platform_id>

	switch (platform)
8f6018a8:	e3003152 	movw	r3, #338	; 0x152
8f6018ac:	e1500003 	cmp	r0, r3
8f6018b0:	0a000014 	beq	8f601908 <platform_is_msm8953+0x7c>
8f6018b4:	8a00000d 	bhi	8f6018f0 <platform_is_msm8953+0x64>
8f6018b8:	e3003125 	movw	r3, #293	; 0x125
8f6018bc:	e1500003 	cmp	r0, r3
8f6018c0:	0a000010 	beq	8f601908 <platform_is_msm8953+0x7c>
8f6018c4:	e2400e13 	sub	r0, r0, #304	; 0x130
8f6018c8:	e16f0f10 	clz	r0, r0
8f6018cc:	e1a002a0 	lsr	r0, r0, #5
			return 1;
			break;
		default:
			return 0;
	}
}
8f6018d0:	e59f303c 	ldr	r3, [pc, #60]	; 8f601914 <platform_is_msm8953+0x88>
8f6018d4:	e5932000 	ldr	r2, [r3]
8f6018d8:	e59d3004 	ldr	r3, [r13, #4]
8f6018dc:	e0332002 	eors	r2, r3, r2
8f6018e0:	e3a03000 	mov	r3, #0
8f6018e4:	1a000009 	bne	8f601910 <platform_is_msm8953+0x84>
8f6018e8:	e28dd00c 	add	r13, r13, #12
8f6018ec:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	switch (platform)
8f6018f0:	e2400f57 	sub	r0, r0, #348	; 0x15c
8f6018f4:	e2400001 	sub	r0, r0, #1
8f6018f8:	e3500002 	cmp	r0, #2
8f6018fc:	83a00000 	movhi	r0, #0
8f601900:	93a00001 	movls	r0, #1
8f601904:	eafffff1 	b	8f6018d0 <platform_is_msm8953+0x44>
			return 1;
8f601908:	e3a00001 	mov	r0, #1
8f60190c:	eaffffef 	b	8f6018d0 <platform_is_msm8953+0x44>
}
8f601910:	eb00c4aa 	bl	8f632bc0 <__stack_chk_fail>
8f601914:	8f74221c 	.word	0x8f74221c

8f601918 <platform_get_qmp_rev>:

uint32_t platform_get_qmp_rev()
{
8f601918:	e59f2058 	ldr	r2, [pc, #88]	; 8f601978 <platform_get_qmp_rev+0x60>
        return readl(USB3_PHY_REVISION_ID3) << 24 | readl(USB3_PHY_REVISION_ID2) << 16 |
8f60191c:	e3a0391e 	mov	r3, #491520	; 0x78000
{
8f601920:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f601924:	e24dd00c 	sub	r13, r13, #12
8f601928:	e5922000 	ldr	r2, [r2]
8f60192c:	e58d2004 	str	r2, [r13, #4]
8f601930:	e3a02000 	mov	r2, #0
        return readl(USB3_PHY_REVISION_ID3) << 24 | readl(USB3_PHY_REVISION_ID2) << 16 |
8f601934:	e5931994 	ldr	r1, [r3, #2452]	; 0x994
8f601938:	e5930990 	ldr	r0, [r3, #2448]	; 0x990
                   readl(USB3_PHY_REVISION_ID1) << 8 | readl(USB3_PHY_REVISION_ID0);
8f60193c:	e593298c 	ldr	r2, [r3, #2444]	; 0x98c
8f601940:	e5933988 	ldr	r3, [r3, #2440]	; 0x988
        return readl(USB3_PHY_REVISION_ID3) << 24 | readl(USB3_PHY_REVISION_ID2) << 16 |
8f601944:	e1a00800 	lsl	r0, r0, #16
8f601948:	e1800c01 	orr	r0, r0, r1, lsl #24
                   readl(USB3_PHY_REVISION_ID1) << 8 | readl(USB3_PHY_REVISION_ID0);
8f60194c:	e1800003 	orr	r0, r0, r3
}
8f601950:	e59f3020 	ldr	r3, [pc, #32]	; 8f601978 <platform_get_qmp_rev+0x60>
                   readl(USB3_PHY_REVISION_ID1) << 8 | readl(USB3_PHY_REVISION_ID0);
8f601954:	e1800402 	orr	r0, r0, r2, lsl #8
}
8f601958:	e5932000 	ldr	r2, [r3]
8f60195c:	e59d3004 	ldr	r3, [r13, #4]
8f601960:	e0332002 	eors	r2, r3, r2
8f601964:	e3a03000 	mov	r3, #0
8f601968:	1a000001 	bne	8f601974 <platform_get_qmp_rev+0x5c>
8f60196c:	e28dd00c 	add	r13, r13, #12
8f601970:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f601974:	eb00c491 	bl	8f632bc0 <__stack_chk_fail>
8f601978:	8f74221c 	.word	0x8f74221c

8f60197c <clock_usb30_init>:
	writel(reg, GCC_USB30_GDSCR);
}

/* enables usb30 clocks */
void clock_usb30_init(void)
{
8f60197c:	e59f32a4 	ldr	r3, [pc, #676]	; 8f601c28 <clock_usb30_init+0x2ac>
	int ret;

	ret = clk_get_set_enable("usb30_iface_clk", 0, 1);
8f601980:	e3a01000 	mov	r1, #0
{
8f601984:	e92d4010 	push	{r4, r14}
	ret = clk_get_set_enable("usb30_iface_clk", 0, 1);
8f601988:	e3a02001 	mov	r2, #1
{
8f60198c:	e24dd010 	sub	r13, r13, #16
	ret = clk_get_set_enable("usb30_iface_clk", 0, 1);
8f601990:	e30003bc 	movw	r0, #956	; 0x3bc
8f601994:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f601998:	e5933000 	ldr	r3, [r3]
8f60199c:	e58d300c 	str	r3, [r13, #12]
8f6019a0:	e3a03000 	mov	r3, #0
	ret = clk_get_set_enable("usb30_iface_clk", 0, 1);
8f6019a4:	e1a0400e 	mov	r4, r14
8f6019a8:	eb003724 	bl	8f60f640 <clk_get_set_enable>
	if(ret)
8f6019ac:	e2501000 	subs	r1, r0, #0
8f6019b0:	1a000039 	bne	8f601a9c <clock_usb30_init+0x120>
	uint32_t reg = readl(GCC_USB30_GDSCR);
8f6019b4:	e3a03a0f 	mov	r3, #61440	; 0xf000
8f6019b8:	e3403183 	movt	r3, #387	; 0x183
		ASSERT(0);
	}

	clock_usb30_gdsc_enable();

	ret = clk_get_set_enable("usb30_master_clk", 133330000, 1);
8f6019bc:	e3a02001 	mov	r2, #1
8f6019c0:	e3071450 	movw	r1, #29776	; 0x7450
	uint32_t reg = readl(GCC_USB30_GDSCR);
8f6019c4:	e5930078 	ldr	r0, [r3, #120]	; 0x78
	ret = clk_get_set_enable("usb30_master_clk", 133330000, 1);
8f6019c8:	e34017f2 	movt	r1, #2034	; 0x7f2
	reg &= ~(0x1);
8f6019cc:	e3c00001 	bic	r0, r0, #1
	writel(reg, GCC_USB30_GDSCR);
8f6019d0:	e5830078 	str	r0, [r3, #120]	; 0x78
	ret = clk_get_set_enable("usb30_master_clk", 133330000, 1);
8f6019d4:	e3000994 	movw	r0, #2452	; 0x994
8f6019d8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6019dc:	eb003717 	bl	8f60f640 <clk_get_set_enable>
	if(ret)
8f6019e0:	e2501000 	subs	r1, r0, #0
8f6019e4:	1a000080 	bne	8f601bec <clock_usb30_init+0x270>
	{
		dprintf(CRITICAL, "failed to set usb30_master_clk. ret = %d\n", ret);
		ASSERT(0);
	}
	ret = clk_get_set_enable("usb30_pipe_clk", 0, 1);
8f6019e8:	e3a01000 	mov	r1, #0
8f6019ec:	e3a02001 	mov	r2, #1
8f6019f0:	e3000424 	movw	r0, #1060	; 0x424
8f6019f4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6019f8:	eb003710 	bl	8f60f640 <clk_get_set_enable>
	if(ret)
8f6019fc:	e2501000 	subs	r1, r0, #0
8f601a00:	1a00006b 	bne	8f601bb4 <clock_usb30_init+0x238>
	{
		dprintf(CRITICAL, "failed to set usb30_pipe_clk. ret = %d\n", ret);
		ASSERT(0);
	}

	ret = clk_get_set_enable("usb30_aux_clk", 19200000, 1);
8f601a04:	e3a02001 	mov	r2, #1
8f601a08:	e3a01b3e 	mov	r1, #63488	; 0xf800
8f601a0c:	e300096c 	movw	r0, #2412	; 0x96c
8f601a10:	e3401124 	movt	r1, #292	; 0x124
8f601a14:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601a18:	eb003708 	bl	8f60f640 <clk_get_set_enable>
	if(ret)
8f601a1c:	e2501000 	subs	r1, r0, #0
8f601a20:	1a000055 	bne	8f601b7c <clock_usb30_init+0x200>
	{
		dprintf(CRITICAL, "failed to set usb30_aux_clk. ret = %d\n", ret);
		ASSERT(0);
	}

	ret = clk_get_set_enable("usb30_mock_utmi_clk", 60000000, 1);
8f601a24:	e3a02001 	mov	r2, #1
8f601a28:	e3a01c87 	mov	r1, #34560	; 0x8700
8f601a2c:	e3000484 	movw	r0, #1156	; 0x484
8f601a30:	e3401393 	movt	r1, #915	; 0x393
8f601a34:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601a38:	eb003700 	bl	8f60f640 <clk_get_set_enable>
	if(ret)
8f601a3c:	e2501000 	subs	r1, r0, #0
8f601a40:	1a00003f 	bne	8f601b44 <clock_usb30_init+0x1c8>
	{
		dprintf(CRITICAL, "failed to set usb30_mock_utmi_clk ret = %d\n", ret);
		ASSERT(0);
	}

	ret = clk_get_set_enable("usb30_sleep_clk", 0, 1);
8f601a44:	e3a01000 	mov	r1, #0
8f601a48:	e3a02001 	mov	r2, #1
8f601a4c:	e30004c4 	movw	r0, #1220	; 0x4c4
8f601a50:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601a54:	eb0036f9 	bl	8f60f640 <clk_get_set_enable>
	if(ret)
8f601a58:	e2501000 	subs	r1, r0, #0
8f601a5c:	1a00002a 	bne	8f601b0c <clock_usb30_init+0x190>
	{
		dprintf(CRITICAL, "failed to set usb30_sleep_clk ret = %d\n", ret);
		ASSERT(0);
	}

	ret = clk_get_set_enable("usb_phy_cfg_ahb_clk", 0, 1);
8f601a60:	e3a01000 	mov	r1, #0
8f601a64:	e3a02001 	mov	r2, #1
8f601a68:	e30009c4 	movw	r0, #2500	; 0x9c4
8f601a6c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601a70:	eb0036f2 	bl	8f60f640 <clk_get_set_enable>
	if(ret)
8f601a74:	e2501000 	subs	r1, r0, #0
8f601a78:	1a000015 	bne	8f601ad4 <clock_usb30_init+0x158>
	{
		dprintf(CRITICAL, "failed to set usb_phy_cfg_ahb_clk ret = %d\n", ret);
		ASSERT(0);
	}
}
8f601a7c:	e59f31a4 	ldr	r3, [pc, #420]	; 8f601c28 <clock_usb30_init+0x2ac>
8f601a80:	e5932000 	ldr	r2, [r3]
8f601a84:	e59d300c 	ldr	r3, [r13, #12]
8f601a88:	e0332002 	eors	r2, r3, r2
8f601a8c:	e3a03000 	mov	r3, #0
8f601a90:	1a000063 	bne	8f601c24 <clock_usb30_init+0x2a8>
8f601a94:	e28dd010 	add	r13, r13, #16
8f601a98:	e8bd8010 	pop	{r4, r15}
		dprintf(CRITICAL, "failed to set usb30_iface_clk. ret = %d\n", ret);
8f601a9c:	e30003cc 	movw	r0, #972	; 0x3cc
8f601aa0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601aa4:	eb00c3b2 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f601aa8:	e3070f64 	movw	r0, #32612	; 0x7f64
8f601aac:	e300239c 	movw	r2, #924	; 0x39c
8f601ab0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601ab4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601ab8:	e58d0000 	str	r0, [r13]
8f601abc:	e3001130 	movw	r1, #304	; 0x130
8f601ac0:	e3a0303f 	mov	r3, #63	; 0x3f
8f601ac4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f601ac8:	e1a00004 	mov	r0, r4
8f601acc:	eb00c3fa 	bl	8f632abc <_panic>
8f601ad0:	eaffffb7 	b	8f6019b4 <clock_usb30_init+0x38>
		dprintf(CRITICAL, "failed to set usb_phy_cfg_ahb_clk ret = %d\n", ret);
8f601ad4:	e30004fc 	movw	r0, #1276	; 0x4fc
8f601ad8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601adc:	eb00c3a4 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f601ae0:	e307cf64 	movw	r12, #32612	; 0x7f64
8f601ae4:	e300239c 	movw	r2, #924	; 0x39c
8f601ae8:	e348cf70 	movt	r12, #36720	; 0x8f70
8f601aec:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601af0:	e3001130 	movw	r1, #304	; 0x130
8f601af4:	e3a0306a 	mov	r3, #106	; 0x6a
8f601af8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f601afc:	e1a00004 	mov	r0, r4
8f601b00:	e58dc000 	str	r12, [r13]
8f601b04:	eb00c3ec 	bl	8f632abc <_panic>
}
8f601b08:	eaffffdb 	b	8f601a7c <clock_usb30_init+0x100>
		dprintf(CRITICAL, "failed to set usb30_sleep_clk ret = %d\n", ret);
8f601b0c:	e30004d4 	movw	r0, #1236	; 0x4d4
8f601b10:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601b14:	eb00c396 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f601b18:	e3070f64 	movw	r0, #32612	; 0x7f64
8f601b1c:	e300239c 	movw	r2, #924	; 0x39c
8f601b20:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601b24:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601b28:	e58d0000 	str	r0, [r13]
8f601b2c:	e3001130 	movw	r1, #304	; 0x130
8f601b30:	e3a03063 	mov	r3, #99	; 0x63
8f601b34:	e3481f70 	movt	r1, #36720	; 0x8f70
8f601b38:	e1a00004 	mov	r0, r4
8f601b3c:	eb00c3de 	bl	8f632abc <_panic>
8f601b40:	eaffffc6 	b	8f601a60 <clock_usb30_init+0xe4>
		dprintf(CRITICAL, "failed to set usb30_mock_utmi_clk ret = %d\n", ret);
8f601b44:	e3000498 	movw	r0, #1176	; 0x498
8f601b48:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601b4c:	eb00c388 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f601b50:	e3070f64 	movw	r0, #32612	; 0x7f64
8f601b54:	e300239c 	movw	r2, #924	; 0x39c
8f601b58:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601b5c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601b60:	e58d0000 	str	r0, [r13]
8f601b64:	e3001130 	movw	r1, #304	; 0x130
8f601b68:	e3a0305c 	mov	r3, #92	; 0x5c
8f601b6c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f601b70:	e1a00004 	mov	r0, r4
8f601b74:	eb00c3d0 	bl	8f632abc <_panic>
8f601b78:	eaffffb1 	b	8f601a44 <clock_usb30_init+0xc8>
		dprintf(CRITICAL, "failed to set usb30_aux_clk. ret = %d\n", ret);
8f601b7c:	e300045c 	movw	r0, #1116	; 0x45c
8f601b80:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601b84:	eb00c37a 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f601b88:	e3070f64 	movw	r0, #32612	; 0x7f64
8f601b8c:	e300239c 	movw	r2, #924	; 0x39c
8f601b90:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601b94:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601b98:	e58d0000 	str	r0, [r13]
8f601b9c:	e3001130 	movw	r1, #304	; 0x130
8f601ba0:	e3a03055 	mov	r3, #85	; 0x55
8f601ba4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f601ba8:	e1a00004 	mov	r0, r4
8f601bac:	eb00c3c2 	bl	8f632abc <_panic>
8f601bb0:	eaffff9b 	b	8f601a24 <clock_usb30_init+0xa8>
		dprintf(CRITICAL, "failed to set usb30_pipe_clk. ret = %d\n", ret);
8f601bb4:	e3000434 	movw	r0, #1076	; 0x434
8f601bb8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601bbc:	eb00c36c 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f601bc0:	e3070f64 	movw	r0, #32612	; 0x7f64
8f601bc4:	e300239c 	movw	r2, #924	; 0x39c
8f601bc8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601bcc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601bd0:	e58d0000 	str	r0, [r13]
8f601bd4:	e3001130 	movw	r1, #304	; 0x130
8f601bd8:	e3a0304e 	mov	r3, #78	; 0x4e
8f601bdc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f601be0:	e1a00004 	mov	r0, r4
8f601be4:	eb00c3b4 	bl	8f632abc <_panic>
8f601be8:	eaffff85 	b	8f601a04 <clock_usb30_init+0x88>
		dprintf(CRITICAL, "failed to set usb30_master_clk. ret = %d\n", ret);
8f601bec:	e30003f8 	movw	r0, #1016	; 0x3f8
8f601bf0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601bf4:	eb00c35e 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f601bf8:	e3070f64 	movw	r0, #32612	; 0x7f64
8f601bfc:	e300239c 	movw	r2, #924	; 0x39c
8f601c00:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601c04:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601c08:	e58d0000 	str	r0, [r13]
8f601c0c:	e3001130 	movw	r1, #304	; 0x130
8f601c10:	e3a03048 	mov	r3, #72	; 0x48
8f601c14:	e3481f70 	movt	r1, #36720	; 0x8f70
8f601c18:	e1a00004 	mov	r0, r4
8f601c1c:	eb00c3a6 	bl	8f632abc <_panic>
8f601c20:	eaffff70 	b	8f6019e8 <clock_usb30_init+0x6c>
}
8f601c24:	eb00c3e5 	bl	8f632bc0 <__stack_chk_fail>
8f601c28:	8f74221c 	.word	0x8f74221c

8f601c2c <clock_init_mmc>:

void clock_init_mmc(uint32_t interface)
{
8f601c2c:	e1a03000 	mov	r3, r0
8f601c30:	e59f009c 	ldr	r0, [pc, #156]	; 8f601cd4 <clock_init_mmc+0xa8>
8f601c34:	e92d4010 	push	{r4, r14}
8f601c38:	e24dd050 	sub	r13, r13, #80	; 0x50
8f601c3c:	e5900000 	ldr	r0, [r0]
8f601c40:	e58d004c 	str	r0, [r13, #76]	; 0x4c
8f601c44:	e3a00000 	mov	r0, #0
	char clk_name[64];
	int ret;

	snprintf(clk_name, sizeof(clk_name), "sdc%u_iface_clk", interface);
8f601c48:	e3a01040 	mov	r1, #64	; 0x40
8f601c4c:	e28d000c 	add	r0, r13, #12
8f601c50:	e3002528 	movw	r2, #1320	; 0x528
8f601c54:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601c58:	e1a0400e 	mov	r4, r14
8f601c5c:	eb00c8b7 	bl	8f633f40 <snprintf>

	/* enable interface clock */
	ret = clk_get_set_enable(clk_name, 0, 1);
8f601c60:	e3a01000 	mov	r1, #0
8f601c64:	e28d000c 	add	r0, r13, #12
8f601c68:	e3a02001 	mov	r2, #1
8f601c6c:	eb003673 	bl	8f60f640 <clk_get_set_enable>
	if(ret)
8f601c70:	e2501000 	subs	r1, r0, #0
8f601c74:	1a000007 	bne	8f601c98 <clock_init_mmc+0x6c>
	{
		dprintf(CRITICAL, "failed to set sdc1_iface_clk ret = %d\n", ret);
		ASSERT(0);
	}
}
8f601c78:	e59f3054 	ldr	r3, [pc, #84]	; 8f601cd4 <clock_init_mmc+0xa8>
8f601c7c:	e5932000 	ldr	r2, [r3]
8f601c80:	e59d304c 	ldr	r3, [r13, #76]	; 0x4c
8f601c84:	e0332002 	eors	r2, r3, r2
8f601c88:	e3a03000 	mov	r3, #0
8f601c8c:	1a00000f 	bne	8f601cd0 <clock_init_mmc+0xa4>
8f601c90:	e28dd050 	add	r13, r13, #80	; 0x50
8f601c94:	e8bd8010 	pop	{r4, r15}
		dprintf(CRITICAL, "failed to set sdc1_iface_clk ret = %d\n", ret);
8f601c98:	e3000538 	movw	r0, #1336	; 0x538
8f601c9c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601ca0:	eb00c333 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f601ca4:	e307cf64 	movw	r12, #32612	; 0x7f64
8f601ca8:	e300239c 	movw	r2, #924	; 0x39c
8f601cac:	e348cf70 	movt	r12, #36720	; 0x8f70
8f601cb0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601cb4:	e3001130 	movw	r1, #304	; 0x130
8f601cb8:	e3a0307a 	mov	r3, #122	; 0x7a
8f601cbc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f601cc0:	e1a00004 	mov	r0, r4
8f601cc4:	e58dc000 	str	r12, [r13]
8f601cc8:	eb00c37b 	bl	8f632abc <_panic>
}
8f601ccc:	eaffffe9 	b	8f601c78 <clock_init_mmc+0x4c>
8f601cd0:	eb00c3ba 	bl	8f632bc0 <__stack_chk_fail>
8f601cd4:	8f74221c 	.word	0x8f74221c

8f601cd8 <clock_config_mmc>:

/* Configure MMC clock */
void clock_config_mmc(uint32_t interface, uint32_t freq)
{
8f601cd8:	e92d4030 	push	{r4, r5, r14}
8f601cdc:	e1a04001 	mov	r4, r1
8f601ce0:	e59f1178 	ldr	r1, [pc, #376]	; 8f601e60 <clock_config_mmc+0x188>
8f601ce4:	e24dd054 	sub	r13, r13, #84	; 0x54
8f601ce8:	e1a03000 	mov	r3, r0
	int ret = 1;
	char clk_name[64];

	snprintf(clk_name, sizeof(clk_name), "sdc%u_core_clk", interface);
8f601cec:	e3002560 	movw	r2, #1376	; 0x560
{
8f601cf0:	e5911000 	ldr	r1, [r1]
8f601cf4:	e58d104c 	str	r1, [r13, #76]	; 0x4c
8f601cf8:	e3a01000 	mov	r1, #0
	snprintf(clk_name, sizeof(clk_name), "sdc%u_core_clk", interface);
8f601cfc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601d00:	e28d000c 	add	r0, r13, #12
8f601d04:	e3a01040 	mov	r1, #64	; 0x40
8f601d08:	e1a0500e 	mov	r5, r14
8f601d0c:	eb00c88b 	bl	8f633f40 <snprintf>

	if(freq == MMC_CLK_400KHZ)
8f601d10:	e3a03d6a 	mov	r3, #6784	; 0x1a80
8f601d14:	e3403006 	movt	r3, #6
8f601d18:	e1540003 	cmp	r4, r3
8f601d1c:	0a000036 	beq	8f601dfc <clock_config_mmc+0x124>
	{
		ret = clk_get_set_enable(clk_name, 400000, 1);
	}
	else if(freq == MMC_CLK_50MHZ)
8f601d20:	e3a03000 	mov	r3, #0
8f601d24:	e34032ee 	movt	r3, #750	; 0x2ee
8f601d28:	e1540003 	cmp	r4, r3
8f601d2c:	0a00003c 	beq	8f601e24 <clock_config_mmc+0x14c>
	{
		ret = clk_get_set_enable(clk_name, 50000000, 1);
	}
	else if(freq == MMC_CLK_177MHZ)
8f601d30:	e3083e10 	movw	r3, #36368	; 0x8e10
8f601d34:	e3403a98 	movt	r3, #2712	; 0xa98
8f601d38:	e1540003 	cmp	r4, r3
8f601d3c:	0a00002e 	beq	8f601dfc <clock_config_mmc+0x124>
	{
		ret = clk_get_set_enable(clk_name, 177770000, 1);
	}
	else if(freq == MMC_CLK_192MHZ)
8f601d40:	e3a03a0b 	mov	r3, #45056	; 0xb000
8f601d44:	e3403b71 	movt	r3, #2929	; 0xb71
8f601d48:	e1540003 	cmp	r4, r3
8f601d4c:	0a00002a 	beq	8f601dfc <clock_config_mmc+0x124>
	{
		ret = clk_get_set_enable(clk_name, 192000000, 1);
	}
	else if(freq == MMC_CLK_200MHZ)
8f601d50:	e3a03cc2 	mov	r3, #49664	; 0xc200
8f601d54:	e3403beb 	movt	r3, #3051	; 0xbeb
8f601d58:	e1540003 	cmp	r4, r3
8f601d5c:	0a000026 	beq	8f601dfc <clock_config_mmc+0x124>
	{
		ret = clk_get_set_enable(clk_name, 200000000, 1);
	}
	else if(freq == MMC_CLK_400MHZ)
8f601d60:	e3a03b21 	mov	r3, #33792	; 0x8400
8f601d64:	e34137d7 	movt	r3, #6103	; 0x17d7
8f601d68:	e1540003 	cmp	r4, r3
8f601d6c:	0a000033 	beq	8f601e40 <clock_config_mmc+0x168>
	{
		ret = clk_get_set_enable(clk_name, 384000000, 1);
	}
	else
	{
		dprintf(CRITICAL, "sdc frequency (%u) is not supported\n", freq);
8f601d70:	e1a01004 	mov	r1, r4
8f601d74:	e3000570 	movw	r0, #1392	; 0x570
8f601d78:	e3480f70 	movt	r0, #36720	; 0x8f70
		ASSERT(0);
8f601d7c:	e3074f64 	movw	r4, #32612	; 0x7f64
		dprintf(CRITICAL, "sdc frequency (%u) is not supported\n", freq);
8f601d80:	eb00c2fb 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f601d84:	e3484f70 	movt	r4, #36720	; 0x8f70
8f601d88:	e3a030a1 	mov	r3, #161	; 0xa1
8f601d8c:	e300239c 	movw	r2, #924	; 0x39c
8f601d90:	e3001130 	movw	r1, #304	; 0x130
8f601d94:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601d98:	e3481f70 	movt	r1, #36720	; 0x8f70
8f601d9c:	e1a00005 	mov	r0, r5
8f601da0:	e58d4000 	str	r4, [r13]
8f601da4:	eb00c344 	bl	8f632abc <_panic>
	int ret = 1;
8f601da8:	e3a02001 	mov	r2, #1
	}

	if(ret)
	{
		dprintf(CRITICAL, "failed to set %s ret = %d\n", clk_name, ret);
8f601dac:	e28d100c 	add	r1, r13, #12
8f601db0:	e3000598 	movw	r0, #1432	; 0x598
8f601db4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601db8:	eb00c2ed 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f601dbc:	e300239c 	movw	r2, #924	; 0x39c
8f601dc0:	e3001130 	movw	r1, #304	; 0x130
8f601dc4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601dc8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f601dcc:	e3a030a7 	mov	r3, #167	; 0xa7
8f601dd0:	e1a00005 	mov	r0, r5
8f601dd4:	e58d4000 	str	r4, [r13]
8f601dd8:	eb00c337 	bl	8f632abc <_panic>
	}
}
8f601ddc:	e59f307c 	ldr	r3, [pc, #124]	; 8f601e60 <clock_config_mmc+0x188>
8f601de0:	e5932000 	ldr	r2, [r3]
8f601de4:	e59d304c 	ldr	r3, [r13, #76]	; 0x4c
8f601de8:	e0332002 	eors	r2, r3, r2
8f601dec:	e3a03000 	mov	r3, #0
8f601df0:	1a000019 	bne	8f601e5c <clock_config_mmc+0x184>
8f601df4:	e28dd054 	add	r13, r13, #84	; 0x54
8f601df8:	e8bd8030 	pop	{r4, r5, r15}
		ret = clk_get_set_enable(clk_name, 200000000, 1);
8f601dfc:	e3a02001 	mov	r2, #1
8f601e00:	e28d000c 	add	r0, r13, #12
8f601e04:	e1a01004 	mov	r1, r4
8f601e08:	eb00360c 	bl	8f60f640 <clk_get_set_enable>
8f601e0c:	e1a02000 	mov	r2, r0
	if(ret)
8f601e10:	e3520000 	cmp	r2, #0
8f601e14:	0afffff0 	beq	8f601ddc <clock_config_mmc+0x104>
8f601e18:	e3074f64 	movw	r4, #32612	; 0x7f64
8f601e1c:	e3484f70 	movt	r4, #36720	; 0x8f70
8f601e20:	eaffffe1 	b	8f601dac <clock_config_mmc+0xd4>
		ret = clk_get_set_enable(clk_name, 50000000, 1);
8f601e24:	e3a02001 	mov	r2, #1
8f601e28:	e28d000c 	add	r0, r13, #12
8f601e2c:	e30f1080 	movw	r1, #61568	; 0xf080
8f601e30:	e34012fa 	movt	r1, #762	; 0x2fa
8f601e34:	eb003601 	bl	8f60f640 <clk_get_set_enable>
8f601e38:	e1a02000 	mov	r2, r0
8f601e3c:	eafffff3 	b	8f601e10 <clock_config_mmc+0x138>
		ret = clk_get_set_enable(clk_name, 384000000, 1);
8f601e40:	e3a02001 	mov	r2, #1
8f601e44:	e28d000c 	add	r0, r13, #12
8f601e48:	e3a01a06 	mov	r1, #24576	; 0x6000
8f601e4c:	e34116e3 	movt	r1, #5859	; 0x16e3
8f601e50:	eb0035fa 	bl	8f60f640 <clk_get_set_enable>
8f601e54:	e1a02000 	mov	r2, r0
8f601e58:	eaffffec 	b	8f601e10 <clock_config_mmc+0x138>
}
8f601e5c:	eb00c357 	bl	8f632bc0 <__stack_chk_fail>
8f601e60:	8f74221c 	.word	0x8f74221c

8f601e64 <clock_bumpup_pipe3_clk>:

void clock_bumpup_pipe3_clk()
{
8f601e64:	e59f308c 	ldr	r3, [pc, #140]	; 8f601ef8 <clock_bumpup_pipe3_clk+0x94>
	int ret =0;
	ret = clk_get_set_enable("usb30_pipe_clk", 0, true);
8f601e68:	e3a01000 	mov	r1, #0
{
8f601e6c:	e92d4010 	push	{r4, r14}
	ret = clk_get_set_enable("usb30_pipe_clk", 0, true);
8f601e70:	e3a02001 	mov	r2, #1
{
8f601e74:	e24dd010 	sub	r13, r13, #16
	ret = clk_get_set_enable("usb30_pipe_clk", 0, true);
8f601e78:	e3000424 	movw	r0, #1060	; 0x424
8f601e7c:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f601e80:	e5933000 	ldr	r3, [r3]
8f601e84:	e58d300c 	str	r3, [r13, #12]
8f601e88:	e3a03000 	mov	r3, #0
	ret = clk_get_set_enable("usb30_pipe_clk", 0, true);
8f601e8c:	e1a0400e 	mov	r4, r14
8f601e90:	eb0035ea 	bl	8f60f640 <clk_get_set_enable>

	if(ret)
8f601e94:	e2501000 	subs	r1, r0, #0
8f601e98:	1a000007 	bne	8f601ebc <clock_bumpup_pipe3_clk+0x58>
	{
		dprintf(CRITICAL, "failed to set usb30_pipe_clk. ret = %d\n", ret);
		ASSERT(0);
	}
}
8f601e9c:	e59f3054 	ldr	r3, [pc, #84]	; 8f601ef8 <clock_bumpup_pipe3_clk+0x94>
8f601ea0:	e5932000 	ldr	r2, [r3]
8f601ea4:	e59d300c 	ldr	r3, [r13, #12]
8f601ea8:	e0332002 	eors	r2, r3, r2
8f601eac:	e3a03000 	mov	r3, #0
8f601eb0:	1a00000f 	bne	8f601ef4 <clock_bumpup_pipe3_clk+0x90>
8f601eb4:	e28dd010 	add	r13, r13, #16
8f601eb8:	e8bd8010 	pop	{r4, r15}
		dprintf(CRITICAL, "failed to set usb30_pipe_clk. ret = %d\n", ret);
8f601ebc:	e3000434 	movw	r0, #1076	; 0x434
8f601ec0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601ec4:	eb00c2aa 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f601ec8:	e307cf64 	movw	r12, #32612	; 0x7f64
8f601ecc:	e300239c 	movw	r2, #924	; 0x39c
8f601ed0:	e348cf70 	movt	r12, #36720	; 0x8f70
8f601ed4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601ed8:	e3001130 	movw	r1, #304	; 0x130
8f601edc:	e3a030b3 	mov	r3, #179	; 0xb3
8f601ee0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f601ee4:	e1a00004 	mov	r0, r4
8f601ee8:	e58dc000 	str	r12, [r13]
8f601eec:	eb00c2f2 	bl	8f632abc <_panic>
}
8f601ef0:	eaffffe9 	b	8f601e9c <clock_bumpup_pipe3_clk+0x38>
8f601ef4:	eb00c331 	bl	8f632bc0 <__stack_chk_fail>
8f601ef8:	8f74221c 	.word	0x8f74221c

8f601efc <clock_config_uart_dm>:

/* Configure UART clock based on the UART block id*/
void clock_config_uart_dm(uint8_t id)
{
8f601efc:	e59f1118 	ldr	r1, [pc, #280]	; 8f60201c <clock_config_uart_dm+0x120>
	int ret;
	char iclk[64];
	char cclk[64];

	snprintf(iclk, sizeof(iclk), "uart%u_iface_clk", id);
8f601f00:	e1a03000 	mov	r3, r0
{
8f601f04:	e92d4030 	push	{r4, r5, r14}
8f601f08:	e24dd094 	sub	r13, r13, #148	; 0x94
8f601f0c:	e5911000 	ldr	r1, [r1]
8f601f10:	e58d108c 	str	r1, [r13, #140]	; 0x8c
8f601f14:	e3a01000 	mov	r1, #0
8f601f18:	e1a04000 	mov	r4, r0
	snprintf(iclk, sizeof(iclk), "uart%u_iface_clk", id);
8f601f1c:	e3a01040 	mov	r1, #64	; 0x40
8f601f20:	e28d000c 	add	r0, r13, #12
8f601f24:	e30025b4 	movw	r2, #1460	; 0x5b4
8f601f28:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601f2c:	e1a0500e 	mov	r5, r14
8f601f30:	eb00c802 	bl	8f633f40 <snprintf>
	snprintf(cclk, sizeof(cclk), "uart%u_core_clk", id);
8f601f34:	e1a03004 	mov	r3, r4
8f601f38:	e3a01040 	mov	r1, #64	; 0x40
8f601f3c:	e28d004c 	add	r0, r13, #76	; 0x4c
8f601f40:	e30025c8 	movw	r2, #1480	; 0x5c8
8f601f44:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601f48:	eb00c7fc 	bl	8f633f40 <snprintf>

	ret = clk_get_set_enable(iclk, 0, 1);
8f601f4c:	e3a02001 	mov	r2, #1
8f601f50:	e28d000c 	add	r0, r13, #12
8f601f54:	e3a01000 	mov	r1, #0
8f601f58:	eb0035b8 	bl	8f60f640 <clk_get_set_enable>
	if(ret)
8f601f5c:	e2502000 	subs	r2, r0, #0
8f601f60:	1a00000e 	bne	8f601fa0 <clock_config_uart_dm+0xa4>
	{
		dprintf(CRITICAL, "failed to set %s ret = %d\n", iclk, ret);
		ASSERT(0);
	}

	ret = clk_get_set_enable(cclk, 7372800, 1);
8f601f64:	e3a02001 	mov	r2, #1
8f601f68:	e28d004c 	add	r0, r13, #76	; 0x4c
8f601f6c:	e3a01902 	mov	r1, #32768	; 0x8000
8f601f70:	e3401070 	movt	r1, #112	; 0x70
8f601f74:	eb0035b1 	bl	8f60f640 <clk_get_set_enable>
	if(ret)
8f601f78:	e2502000 	subs	r2, r0, #0
8f601f7c:	1a000016 	bne	8f601fdc <clock_config_uart_dm+0xe0>
	{
		dprintf(CRITICAL, "failed to set %s ret = %d\n", cclk, ret);
		ASSERT(0);
	}
}
8f601f80:	e59f3094 	ldr	r3, [pc, #148]	; 8f60201c <clock_config_uart_dm+0x120>
8f601f84:	e5932000 	ldr	r2, [r3]
8f601f88:	e59d308c 	ldr	r3, [r13, #140]	; 0x8c
8f601f8c:	e0332002 	eors	r2, r3, r2
8f601f90:	e3a03000 	mov	r3, #0
8f601f94:	1a00001f 	bne	8f602018 <clock_config_uart_dm+0x11c>
8f601f98:	e28dd094 	add	r13, r13, #148	; 0x94
8f601f9c:	e8bd8030 	pop	{r4, r5, r15}
		dprintf(CRITICAL, "failed to set %s ret = %d\n", iclk, ret);
8f601fa0:	e28d100c 	add	r1, r13, #12
8f601fa4:	e3000598 	movw	r0, #1432	; 0x598
8f601fa8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601fac:	eb00c270 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f601fb0:	e3070f64 	movw	r0, #32612	; 0x7f64
8f601fb4:	e300239c 	movw	r2, #924	; 0x39c
8f601fb8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601fbc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601fc0:	e58d0000 	str	r0, [r13]
8f601fc4:	e3001130 	movw	r1, #304	; 0x130
8f601fc8:	e3a030c5 	mov	r3, #197	; 0xc5
8f601fcc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f601fd0:	e1a00005 	mov	r0, r5
8f601fd4:	eb00c2b8 	bl	8f632abc <_panic>
8f601fd8:	eaffffe1 	b	8f601f64 <clock_config_uart_dm+0x68>
		dprintf(CRITICAL, "failed to set %s ret = %d\n", cclk, ret);
8f601fdc:	e28d104c 	add	r1, r13, #76	; 0x4c
8f601fe0:	e3000598 	movw	r0, #1432	; 0x598
8f601fe4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f601fe8:	eb00c261 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f601fec:	e307cf64 	movw	r12, #32612	; 0x7f64
8f601ff0:	e300239c 	movw	r2, #924	; 0x39c
8f601ff4:	e348cf70 	movt	r12, #36720	; 0x8f70
8f601ff8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f601ffc:	e3001130 	movw	r1, #304	; 0x130
8f602000:	e3a030cc 	mov	r3, #204	; 0xcc
8f602004:	e3481f70 	movt	r1, #36720	; 0x8f70
8f602008:	e1a00005 	mov	r0, r5
8f60200c:	e58dc000 	str	r12, [r13]
8f602010:	eb00c2a9 	bl	8f632abc <_panic>
}
8f602014:	eaffffd9 	b	8f601f80 <clock_config_uart_dm+0x84>
8f602018:	eb00c2e8 	bl	8f632bc0 <__stack_chk_fail>
8f60201c:	8f74221c 	.word	0x8f74221c

8f602020 <clock_ce_enable>:

	udelay(2);
}

void clock_ce_enable(uint8_t instance)
{
8f602020:	e59f11f8 	ldr	r1, [pc, #504]	; 8f602220 <clock_ce_enable+0x200>
	int ret;
	char clk_name[64];

	snprintf(clk_name, sizeof(clk_name), "ce%u_src_clk", instance);
8f602024:	e1a03000 	mov	r3, r0
{
8f602028:	e92d4030 	push	{r4, r5, r14}
8f60202c:	e24dd054 	sub	r13, r13, #84	; 0x54
8f602030:	e5911000 	ldr	r1, [r1]
8f602034:	e58d104c 	str	r1, [r13, #76]	; 0x4c
8f602038:	e3a01000 	mov	r1, #0
8f60203c:	e1a04000 	mov	r4, r0
	snprintf(clk_name, sizeof(clk_name), "ce%u_src_clk", instance);
8f602040:	e3a01040 	mov	r1, #64	; 0x40
8f602044:	e28d000c 	add	r0, r13, #12
8f602048:	e30025d8 	movw	r2, #1496	; 0x5d8
8f60204c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f602050:	e1a0500e 	mov	r5, r14
8f602054:	eb00c7b9 	bl	8f633f40 <snprintf>
	ret = clk_get_set_enable(clk_name, 160000000, 1);
8f602058:	e3a02001 	mov	r2, #1
8f60205c:	e28d000c 	add	r0, r13, #12
8f602060:	e3a01b1a 	mov	r1, #26624	; 0x6800
8f602064:	e3401989 	movt	r1, #2441	; 0x989
8f602068:	eb003574 	bl	8f60f640 <clk_get_set_enable>
	if(ret)
8f60206c:	e2502000 	subs	r2, r0, #0
8f602070:	1a00002d 	bne	8f60212c <clock_ce_enable+0x10c>
	{
		dprintf(CRITICAL, "failed to set ce%u_src_clk ret = %d\n", instance, ret);
		ASSERT(0);
	}

	snprintf(clk_name, sizeof(clk_name), "ce%u_core_clk", instance);
8f602074:	e1a03004 	mov	r3, r4
8f602078:	e3a01040 	mov	r1, #64	; 0x40
8f60207c:	e28d000c 	add	r0, r13, #12
8f602080:	e3002610 	movw	r2, #1552	; 0x610
8f602084:	e3482f70 	movt	r2, #36720	; 0x8f70
8f602088:	eb00c7ac 	bl	8f633f40 <snprintf>
	ret = clk_get_set_enable(clk_name, 0, 1);
8f60208c:	e3a02001 	mov	r2, #1
8f602090:	e28d000c 	add	r0, r13, #12
8f602094:	e3a01000 	mov	r1, #0
8f602098:	eb003568 	bl	8f60f640 <clk_get_set_enable>
	if(ret)
8f60209c:	e2502000 	subs	r2, r0, #0
8f6020a0:	1a00004e 	bne	8f6021e0 <clock_ce_enable+0x1c0>
	{
		dprintf(CRITICAL, "failed to set ce%u_core_clk ret = %d\n", instance, ret);
		ASSERT(0);
	}

	snprintf(clk_name, sizeof(clk_name), "ce%u_ahb_clk", instance);
8f6020a4:	e1a03004 	mov	r3, r4
8f6020a8:	e3a01040 	mov	r1, #64	; 0x40
8f6020ac:	e28d000c 	add	r0, r13, #12
8f6020b0:	e3002648 	movw	r2, #1608	; 0x648
8f6020b4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6020b8:	eb00c7a0 	bl	8f633f40 <snprintf>
	ret = clk_get_set_enable(clk_name, 0, 1);
8f6020bc:	e3a02001 	mov	r2, #1
8f6020c0:	e28d000c 	add	r0, r13, #12
8f6020c4:	e3a01000 	mov	r1, #0
8f6020c8:	eb00355c 	bl	8f60f640 <clk_get_set_enable>
	if(ret)
8f6020cc:	e2502000 	subs	r2, r0, #0
8f6020d0:	1a000033 	bne	8f6021a4 <clock_ce_enable+0x184>
	{
		dprintf(CRITICAL, "failed to set ce%u_ahb_clk ret = %d\n", instance, ret);
		ASSERT(0);
	}

	snprintf(clk_name, sizeof(clk_name), "ce%u_axi_clk", instance);
8f6020d4:	e1a03004 	mov	r3, r4
8f6020d8:	e3a01040 	mov	r1, #64	; 0x40
8f6020dc:	e28d000c 	add	r0, r13, #12
8f6020e0:	e3002680 	movw	r2, #1664	; 0x680
8f6020e4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6020e8:	eb00c794 	bl	8f633f40 <snprintf>
	ret = clk_get_set_enable(clk_name, 0, 1);
8f6020ec:	e3a02001 	mov	r2, #1
8f6020f0:	e28d000c 	add	r0, r13, #12
8f6020f4:	e3a01000 	mov	r1, #0
8f6020f8:	eb003550 	bl	8f60f640 <clk_get_set_enable>
	if(ret)
8f6020fc:	e2502000 	subs	r2, r0, #0
8f602100:	1a000018 	bne	8f602168 <clock_ce_enable+0x148>
	 * This is necessary as immediately after an access control reset (boot up)
	 * or a debug re-enable, the Crypto core sequentially clears its internal
	 * pipe key storage memory. If pipe key initialization writes are attempted
	 * during this time, they may be overwritten by the internal clearing logic.
	 */
	udelay(1);
8f602104:	e3a00001 	mov	r0, #1
8f602108:	eb003313 	bl	8f60ed5c <udelay>
}
8f60210c:	e59f310c 	ldr	r3, [pc, #268]	; 8f602220 <clock_ce_enable+0x200>
8f602110:	e5932000 	ldr	r2, [r3]
8f602114:	e59d304c 	ldr	r3, [r13, #76]	; 0x4c
8f602118:	e0332002 	eors	r2, r3, r2
8f60211c:	e3a03000 	mov	r3, #0
8f602120:	1a00003d 	bne	8f60221c <clock_ce_enable+0x1fc>
8f602124:	e28dd054 	add	r13, r13, #84	; 0x54
8f602128:	e8bd8030 	pop	{r4, r5, r15}
		dprintf(CRITICAL, "failed to set ce%u_src_clk ret = %d\n", instance, ret);
8f60212c:	e1a01004 	mov	r1, r4
8f602130:	e30005e8 	movw	r0, #1512	; 0x5e8
8f602134:	e3480f70 	movt	r0, #36720	; 0x8f70
8f602138:	eb00c20d 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f60213c:	e3071f64 	movw	r1, #32612	; 0x7f64
8f602140:	e300239c 	movw	r2, #924	; 0x39c
8f602144:	e3481f70 	movt	r1, #36720	; 0x8f70
8f602148:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60214c:	e58d1000 	str	r1, [r13]
8f602150:	e3003141 	movw	r3, #321	; 0x141
8f602154:	e3001130 	movw	r1, #304	; 0x130
8f602158:	e1a00005 	mov	r0, r5
8f60215c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f602160:	eb00c255 	bl	8f632abc <_panic>
8f602164:	eaffffc2 	b	8f602074 <clock_ce_enable+0x54>
		dprintf(CRITICAL, "failed to set ce%u_axi_clk ret = %d\n", instance, ret);
8f602168:	e1a01004 	mov	r1, r4
8f60216c:	e3000690 	movw	r0, #1680	; 0x690
8f602170:	e3480f70 	movt	r0, #36720	; 0x8f70
8f602174:	eb00c1fe 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f602178:	e307cf64 	movw	r12, #32612	; 0x7f64
8f60217c:	e300239c 	movw	r2, #924	; 0x39c
8f602180:	e348cf70 	movt	r12, #36720	; 0x8f70
8f602184:	e3482f70 	movt	r2, #36720	; 0x8f70
8f602188:	e3001130 	movw	r1, #304	; 0x130
8f60218c:	e3003159 	movw	r3, #345	; 0x159
8f602190:	e3481f70 	movt	r1, #36720	; 0x8f70
8f602194:	e1a00005 	mov	r0, r5
8f602198:	e58dc000 	str	r12, [r13]
8f60219c:	eb00c246 	bl	8f632abc <_panic>
8f6021a0:	eaffffd7 	b	8f602104 <clock_ce_enable+0xe4>
		dprintf(CRITICAL, "failed to set ce%u_ahb_clk ret = %d\n", instance, ret);
8f6021a4:	e1a01004 	mov	r1, r4
8f6021a8:	e3000658 	movw	r0, #1624	; 0x658
8f6021ac:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6021b0:	eb00c1ef 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f6021b4:	e3071f64 	movw	r1, #32612	; 0x7f64
8f6021b8:	e300239c 	movw	r2, #924	; 0x39c
8f6021bc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6021c0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6021c4:	e58d1000 	str	r1, [r13]
8f6021c8:	e3003151 	movw	r3, #337	; 0x151
8f6021cc:	e3001130 	movw	r1, #304	; 0x130
8f6021d0:	e1a00005 	mov	r0, r5
8f6021d4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6021d8:	eb00c237 	bl	8f632abc <_panic>
8f6021dc:	eaffffbc 	b	8f6020d4 <clock_ce_enable+0xb4>
		dprintf(CRITICAL, "failed to set ce%u_core_clk ret = %d\n", instance, ret);
8f6021e0:	e1a01004 	mov	r1, r4
8f6021e4:	e3000620 	movw	r0, #1568	; 0x620
8f6021e8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6021ec:	eb00c1e0 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f6021f0:	e3071f64 	movw	r1, #32612	; 0x7f64
8f6021f4:	e300239c 	movw	r2, #924	; 0x39c
8f6021f8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6021fc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f602200:	e58d1000 	str	r1, [r13]
8f602204:	e3003149 	movw	r3, #329	; 0x149
8f602208:	e3001130 	movw	r1, #304	; 0x130
8f60220c:	e1a00005 	mov	r0, r5
8f602210:	e3481f70 	movt	r1, #36720	; 0x8f70
8f602214:	eb00c228 	bl	8f632abc <_panic>
8f602218:	eaffffa1 	b	8f6020a4 <clock_ce_enable+0x84>
}
8f60221c:	eb00c267 	bl	8f632bc0 <__stack_chk_fail>
8f602220:	8f74221c 	.word	0x8f74221c

8f602224 <clock_ce_disable>:

void clock_ce_disable(uint8_t instance)
{
8f602224:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	struct clk *cclk;
	struct clk *axi_clk;
	struct clk *src_clk;
	char clk_name[64];

	snprintf(clk_name, sizeof(clk_name), "ce%u_src_clk", instance);
8f602228:	e1a03000 	mov	r3, r0
{
8f60222c:	e1a04000 	mov	r4, r0
8f602230:	e59f00e4 	ldr	r0, [pc, #228]	; 8f60231c <clock_ce_disable+0xf8>
8f602234:	e24dd04c 	sub	r13, r13, #76	; 0x4c
	snprintf(clk_name, sizeof(clk_name), "ce%u_src_clk", instance);
8f602238:	e3a01040 	mov	r1, #64	; 0x40
{
8f60223c:	e5900000 	ldr	r0, [r0]
8f602240:	e58d0044 	str	r0, [r13, #68]	; 0x44
8f602244:	e3a00000 	mov	r0, #0
	snprintf(clk_name, sizeof(clk_name), "ce%u_src_clk", instance);
8f602248:	e30025d8 	movw	r2, #1496	; 0x5d8
8f60224c:	e28d0004 	add	r0, r13, #4
8f602250:	e3482f70 	movt	r2, #36720	; 0x8f70
8f602254:	eb00c739 	bl	8f633f40 <snprintf>
	src_clk = clk_get(clk_name);
8f602258:	e28d0004 	add	r0, r13, #4
8f60225c:	eb0034c9 	bl	8f60f588 <clk_get>

	snprintf(clk_name, sizeof(clk_name), "ce%u_ahb_clk", instance);
8f602260:	e1a03004 	mov	r3, r4
8f602264:	e3a01040 	mov	r1, #64	; 0x40
8f602268:	e3002648 	movw	r2, #1608	; 0x648
8f60226c:	e3482f70 	movt	r2, #36720	; 0x8f70
	src_clk = clk_get(clk_name);
8f602270:	e1a05000 	mov	r5, r0
	snprintf(clk_name, sizeof(clk_name), "ce%u_ahb_clk", instance);
8f602274:	e28d0004 	add	r0, r13, #4
8f602278:	eb00c730 	bl	8f633f40 <snprintf>
	ahb_clk = clk_get(clk_name);
8f60227c:	e28d0004 	add	r0, r13, #4
8f602280:	eb0034c0 	bl	8f60f588 <clk_get>

	snprintf(clk_name, sizeof(clk_name), "ce%u_axi_clk", instance);
8f602284:	e1a03004 	mov	r3, r4
8f602288:	e3a01040 	mov	r1, #64	; 0x40
8f60228c:	e3002680 	movw	r2, #1664	; 0x680
8f602290:	e3482f70 	movt	r2, #36720	; 0x8f70
	ahb_clk = clk_get(clk_name);
8f602294:	e1a07000 	mov	r7, r0
	snprintf(clk_name, sizeof(clk_name), "ce%u_axi_clk", instance);
8f602298:	e28d0004 	add	r0, r13, #4
8f60229c:	eb00c727 	bl	8f633f40 <snprintf>
	axi_clk = clk_get(clk_name);
8f6022a0:	e28d0004 	add	r0, r13, #4
8f6022a4:	eb0034b7 	bl	8f60f588 <clk_get>

	snprintf(clk_name, sizeof(clk_name), "ce%u_core_clk", instance);
8f6022a8:	e1a03004 	mov	r3, r4
8f6022ac:	e3a01040 	mov	r1, #64	; 0x40
8f6022b0:	e3002610 	movw	r2, #1552	; 0x610
8f6022b4:	e3482f70 	movt	r2, #36720	; 0x8f70
	axi_clk = clk_get(clk_name);
8f6022b8:	e1a06000 	mov	r6, r0
	snprintf(clk_name, sizeof(clk_name), "ce%u_core_clk", instance);
8f6022bc:	e28d0004 	add	r0, r13, #4
8f6022c0:	eb00c71e 	bl	8f633f40 <snprintf>
	cclk    = clk_get(clk_name);
8f6022c4:	e28d0004 	add	r0, r13, #4
8f6022c8:	eb0034ae 	bl	8f60f588 <clk_get>
8f6022cc:	e1a04000 	mov	r4, r0

	clk_disable(ahb_clk);
8f6022d0:	e1a00007 	mov	r0, r7
8f6022d4:	eb00341d 	bl	8f60f350 <clk_disable>
	clk_disable(axi_clk);
8f6022d8:	e1a00006 	mov	r0, r6
8f6022dc:	eb00341b 	bl	8f60f350 <clk_disable>
	clk_disable(cclk);
8f6022e0:	e1a00004 	mov	r0, r4
8f6022e4:	eb003419 	bl	8f60f350 <clk_disable>
	clk_disable(src_clk);
8f6022e8:	e1a00005 	mov	r0, r5
8f6022ec:	eb003417 	bl	8f60f350 <clk_disable>

	/* Some delay for the clocks to stabalize. */
	udelay(1);
8f6022f0:	e3a00001 	mov	r0, #1
8f6022f4:	eb003298 	bl	8f60ed5c <udelay>
}
8f6022f8:	e59f301c 	ldr	r3, [pc, #28]	; 8f60231c <clock_ce_disable+0xf8>
8f6022fc:	e5932000 	ldr	r2, [r3]
8f602300:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f602304:	e0332002 	eors	r2, r3, r2
8f602308:	e3a03000 	mov	r3, #0
8f60230c:	1a000001 	bne	8f602318 <clock_ce_disable+0xf4>
8f602310:	e28dd04c 	add	r13, r13, #76	; 0x4c
8f602314:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
8f602318:	eb00c228 	bl	8f632bc0 <__stack_chk_fail>
8f60231c:	8f74221c 	.word	0x8f74221c

8f602320 <clock_reset_usb_phy>:
	clock_ce_enable(instance);
}


void clock_reset_usb_phy()
{
8f602320:	e59f3228 	ldr	r3, [pc, #552]	; 8f602550 <clock_reset_usb_phy+0x230>

	struct clk *phy_reset_clk = NULL;
	struct clk *pipe_reset_clk = NULL;
	struct clk *master_clk = NULL;

	master_clk = clk_get("usb30_master_clk");
8f602324:	e3000994 	movw	r0, #2452	; 0x994
{
8f602328:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	master_clk = clk_get("usb30_master_clk");
8f60232c:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f602330:	e24dd014 	sub	r13, r13, #20
8f602334:	e1a0700e 	mov	r7, r14
8f602338:	e5933000 	ldr	r3, [r3]
8f60233c:	e58d300c 	str	r3, [r13, #12]
8f602340:	e3a03000 	mov	r3, #0
	master_clk = clk_get("usb30_master_clk");
8f602344:	eb00348f 	bl	8f60f588 <clk_get>
	ASSERT(master_clk);
8f602348:	e2506000 	subs	r6, r0, #0
8f60234c:	0a000062 	beq	8f6024dc <clock_reset_usb_phy+0x1bc>

	/* Look if phy com clock is present */
	phy_reset_clk = clk_get("usb30_phy_reset");
8f602350:	e30006c4 	movw	r0, #1732	; 0x6c4
8f602354:	e3480f70 	movt	r0, #36720	; 0x8f70
8f602358:	eb00348a 	bl	8f60f588 <clk_get>
	ASSERT(phy_reset_clk);
8f60235c:	e2505000 	subs	r5, r0, #0
8f602360:	0a000047 	beq	8f602484 <clock_reset_usb_phy+0x164>

	pipe_reset_clk = clk_get("usb30_pipe_clk");
8f602364:	e3000424 	movw	r0, #1060	; 0x424
8f602368:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60236c:	eb003485 	bl	8f60f588 <clk_get>
	ASSERT(pipe_reset_clk);
8f602370:	e2504000 	subs	r4, r0, #0
8f602374:	0a00004d 	beq	8f6024b0 <clock_reset_usb_phy+0x190>

	/* ASSERT */
	ret = clk_reset(master_clk, CLK_RESET_ASSERT);
8f602378:	e3a01001 	mov	r1, #1
8f60237c:	e1a00006 	mov	r0, r6
8f602380:	eb0033d2 	bl	8f60f2d0 <clk_reset>
	if (ret)
8f602384:	e3500000 	cmp	r0, #0
8f602388:	1a000026 	bne	8f602428 <clock_reset_usb_phy+0x108>
	{
		dprintf(CRITICAL, "Failed to assert usb30_master_reset clk\n");
		return;
	}
	ret = clk_reset(phy_reset_clk, CLK_RESET_ASSERT);
8f60238c:	e3a01001 	mov	r1, #1
8f602390:	e1a00005 	mov	r0, r5
8f602394:	eb0033cd 	bl	8f60f2d0 <clk_reset>

	if (ret)
8f602398:	e3500000 	cmp	r0, #0
8f60239c:	1a00001d 	bne	8f602418 <clock_reset_usb_phy+0xf8>
	{
		dprintf(CRITICAL, "Failed to assert usb30_phy_reset clk\n");
		goto deassert_master_clk;
	}

	ret = clk_reset(pipe_reset_clk, CLK_RESET_ASSERT);
8f6023a0:	e3a01001 	mov	r1, #1
8f6023a4:	e1a00004 	mov	r0, r4
8f6023a8:	eb0033c8 	bl	8f60f2d0 <clk_reset>
	if (ret)
8f6023ac:	e2507000 	subs	r7, r0, #0
8f6023b0:	1a000027 	bne	8f602454 <clock_reset_usb_phy+0x134>
	{
		dprintf(CRITICAL, "Failed to assert usb30_pipe_clk\n");
		goto deassert_phy_clk;
	}

	udelay(100);
8f6023b4:	e3a00064 	mov	r0, #100	; 0x64
8f6023b8:	eb003267 	bl	8f60ed5c <udelay>

	/* DEASSERT */
	ret = clk_reset(pipe_reset_clk, CLK_RESET_DEASSERT);
8f6023bc:	e1a01007 	mov	r1, r7
8f6023c0:	e1a00004 	mov	r0, r4
8f6023c4:	eb0033c1 	bl	8f60f2d0 <clk_reset>
	if (ret)
8f6023c8:	e3500000 	cmp	r0, #0
8f6023cc:	1a000056 	bne	8f60252c <clock_reset_usb_phy+0x20c>
		return;
	}

deassert_phy_clk:

	ret = clk_reset(phy_reset_clk, CLK_RESET_DEASSERT);
8f6023d0:	e3a01000 	mov	r1, #0
8f6023d4:	e1a00005 	mov	r0, r5
8f6023d8:	eb0033bc 	bl	8f60f2d0 <clk_reset>
	if (ret)
8f6023dc:	e3500000 	cmp	r0, #0
8f6023e0:	1a000048 	bne	8f602508 <clock_reset_usb_phy+0x1e8>
		return;
	}

deassert_master_clk:

	ret = clk_reset(master_clk, CLK_RESET_DEASSERT);
8f6023e4:	e3a01000 	mov	r1, #0
8f6023e8:	e1a00006 	mov	r0, r6
8f6023ec:	eb0033b7 	bl	8f60f2d0 <clk_reset>
	if (ret)
	{
		dprintf(CRITICAL, "Failed to deassert usb30_master clk\n");
8f6023f0:	e59f3158 	ldr	r3, [pc, #344]	; 8f602550 <clock_reset_usb_phy+0x230>
	if (ret)
8f6023f4:	e3500000 	cmp	r0, #0
8f6023f8:	1a000019 	bne	8f602464 <clock_reset_usb_phy+0x144>
		return;
	}
}
8f6023fc:	e5932000 	ldr	r2, [r3]
8f602400:	e59d300c 	ldr	r3, [r13, #12]
8f602404:	e0332002 	eors	r2, r3, r2
8f602408:	e3a03000 	mov	r3, #0
8f60240c:	1a00001b 	bne	8f602480 <clock_reset_usb_phy+0x160>
8f602410:	e28dd014 	add	r13, r13, #20
8f602414:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		dprintf(CRITICAL, "Failed to assert usb30_phy_reset clk\n");
8f602418:	e3000720 	movw	r0, #1824	; 0x720
8f60241c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f602420:	eb00c153 	bl	8f632974 <_dprintf>
		goto deassert_master_clk;
8f602424:	eaffffee 	b	8f6023e4 <clock_reset_usb_phy+0xc4>
		dprintf(CRITICAL, "Failed to assert usb30_master_reset clk\n");
8f602428:	e59f3120 	ldr	r3, [pc, #288]	; 8f602550 <clock_reset_usb_phy+0x230>
8f60242c:	e5932000 	ldr	r2, [r3]
8f602430:	e59d300c 	ldr	r3, [r13, #12]
8f602434:	e0332002 	eors	r2, r3, r2
8f602438:	e3a03000 	mov	r3, #0
8f60243c:	030006f4 	movweq	r0, #1780	; 0x6f4
8f602440:	03480f70 	movteq	r0, #36720	; 0x8f70
8f602444:	1a00000d 	bne	8f602480 <clock_reset_usb_phy+0x160>
}
8f602448:	e28dd014 	add	r13, r13, #20
8f60244c:	e8bd40f0 	pop	{r4, r5, r6, r7, r14}
		dprintf(CRITICAL, "Failed to deassert usb30_master clk\n");
8f602450:	ea00c147 	b	8f632974 <_dprintf>
		dprintf(CRITICAL, "Failed to assert usb30_pipe_clk\n");
8f602454:	e3000748 	movw	r0, #1864	; 0x748
8f602458:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60245c:	eb00c144 	bl	8f632974 <_dprintf>
		goto deassert_phy_clk;
8f602460:	eaffffda 	b	8f6023d0 <clock_reset_usb_phy+0xb0>
		dprintf(CRITICAL, "Failed to deassert usb30_master clk\n");
8f602464:	e5932000 	ldr	r2, [r3]
8f602468:	e59d300c 	ldr	r3, [r13, #12]
8f60246c:	e0332002 	eors	r2, r3, r2
8f602470:	e3a03000 	mov	r3, #0
8f602474:	030007bc 	movweq	r0, #1980	; 0x7bc
8f602478:	03480f70 	movteq	r0, #36720	; 0x8f70
8f60247c:	0afffff1 	beq	8f602448 <clock_reset_usb_phy+0x128>
}
8f602480:	eb00c1ce 	bl	8f632bc0 <__stack_chk_fail>
	ASSERT(phy_reset_clk);
8f602484:	e30016d4 	movw	r1, #1748	; 0x6d4
8f602488:	e300239c 	movw	r2, #924	; 0x39c
8f60248c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f602490:	e3482f70 	movt	r2, #36720	; 0x8f70
8f602494:	e58d1000 	str	r1, [r13]
8f602498:	e300319f 	movw	r3, #415	; 0x19f
8f60249c:	e3001130 	movw	r1, #304	; 0x130
8f6024a0:	e1a00007 	mov	r0, r7
8f6024a4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6024a8:	eb00c183 	bl	8f632abc <_panic>
8f6024ac:	eaffffac 	b	8f602364 <clock_reset_usb_phy+0x44>
	ASSERT(pipe_reset_clk);
8f6024b0:	e30036e4 	movw	r3, #1764	; 0x6e4
8f6024b4:	e1a00007 	mov	r0, r7
8f6024b8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6024bc:	e300239c 	movw	r2, #924	; 0x39c
8f6024c0:	e58d3000 	str	r3, [r13]
8f6024c4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6024c8:	e30031a2 	movw	r3, #418	; 0x1a2
8f6024cc:	e3001130 	movw	r1, #304	; 0x130
8f6024d0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6024d4:	eb00c178 	bl	8f632abc <_panic>
8f6024d8:	eaffffa6 	b	8f602378 <clock_reset_usb_phy+0x58>
	ASSERT(master_clk);
8f6024dc:	e30006b8 	movw	r0, #1720	; 0x6b8
8f6024e0:	e300239c 	movw	r2, #924	; 0x39c
8f6024e4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6024e8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6024ec:	e58d0000 	str	r0, [r13]
8f6024f0:	e3001130 	movw	r1, #304	; 0x130
8f6024f4:	e300319b 	movw	r3, #411	; 0x19b
8f6024f8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6024fc:	e1a00007 	mov	r0, r7
8f602500:	eb00c16d 	bl	8f632abc <_panic>
8f602504:	eaffff91 	b	8f602350 <clock_reset_usb_phy+0x30>
		dprintf(CRITICAL, "Failed to deassert usb30_phy_com_reset clk\n");
8f602508:	e59f3040 	ldr	r3, [pc, #64]	; 8f602550 <clock_reset_usb_phy+0x230>
8f60250c:	e5932000 	ldr	r2, [r3]
8f602510:	e59d300c 	ldr	r3, [r13, #12]
8f602514:	e0332002 	eors	r2, r3, r2
8f602518:	e3a03000 	mov	r3, #0
8f60251c:	03000790 	movweq	r0, #1936	; 0x790
8f602520:	03480f70 	movteq	r0, #36720	; 0x8f70
8f602524:	0affffc7 	beq	8f602448 <clock_reset_usb_phy+0x128>
8f602528:	eaffffd4 	b	8f602480 <clock_reset_usb_phy+0x160>
		dprintf(CRITICAL, "Failed to deassert usb_pipe_clk\n");
8f60252c:	e59f301c 	ldr	r3, [pc, #28]	; 8f602550 <clock_reset_usb_phy+0x230>
8f602530:	e5932000 	ldr	r2, [r3]
8f602534:	e59d300c 	ldr	r3, [r13, #12]
8f602538:	e0332002 	eors	r2, r3, r2
8f60253c:	e3a03000 	mov	r3, #0
8f602540:	0300076c 	movweq	r0, #1900	; 0x76c
8f602544:	03480f70 	movteq	r0, #36720	; 0x8f70
8f602548:	0affffbe 	beq	8f602448 <clock_reset_usb_phy+0x128>
8f60254c:	eaffffcb 	b	8f602480 <clock_reset_usb_phy+0x160>
8f602550:	8f74221c 	.word	0x8f74221c

8f602554 <platform_clock_init>:
	CLK_LOOKUP("ce1_core_clk", gcc_ce1_clk.c),
	CLK_LOOKUP("ce1_src_clk",  ce1_clk_src.c),
};

void platform_clock_init(void)
{
8f602554:	e59f3044 	ldr	r3, [pc, #68]	; 8f6025a0 <platform_clock_init+0x4c>
8f602558:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60255c:	e24dd00c 	sub	r13, r13, #12
8f602560:	e5933000 	ldr	r3, [r3]
8f602564:	e58d3004 	str	r3, [r13, #4]
8f602568:	e3a03000 	mov	r3, #0
	clk_init(msm_clocks_8953, ARRAY_SIZE(msm_clocks_8953));
8f60256c:	e59f302c 	ldr	r3, [pc, #44]	; 8f6025a0 <platform_clock_init+0x4c>
8f602570:	e5932000 	ldr	r2, [r3]
8f602574:	e59d3004 	ldr	r3, [r13, #4]
8f602578:	e0332002 	eors	r2, r3, r2
8f60257c:	e3a03000 	mov	r3, #0
8f602580:	1a000005 	bne	8f60259c <platform_clock_init+0x48>
8f602584:	e30c0ffc 	movw	r0, #53244	; 0xcffc
8f602588:	e3a0101b 	mov	r1, #27
8f60258c:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f602590:	e28dd00c 	add	r13, r13, #12
8f602594:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	clk_init(msm_clocks_8953, ARRAY_SIZE(msm_clocks_8953));
8f602598:	ea0033e5 	b	8f60f534 <clk_init>
8f60259c:	eb00c187 	bl	8f632bc0 <__stack_chk_fail>
8f6025a0:	8f74221c 	.word	0x8f74221c

8f6025a4 <gpio_tlmm_config>:
#include <blsp_qup.h>

void gpio_tlmm_config(uint32_t gpio, uint8_t func,
			uint8_t dir, uint8_t pull,
			uint8_t drvstr, uint32_t enable)
{
8f6025a4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6025a8:	e24dd00c 	sub	r13, r13, #12
	val |= pull;
	val |= func << 2;
	val |= drvstr << 6;
	val |= enable << 9;

	writel(val, (uint32_t *)GPIO_CONFIG_ADDR(gpio));
8f6025ac:	e2800a01 	add	r0, r0, #4096	; 0x1000
{
8f6025b0:	e5ddc010 	ldrb	r12, [r13, #16]
8f6025b4:	e59d2014 	ldr	r2, [r13, #20]
	writel(val, (uint32_t *)GPIO_CONFIG_ADDR(gpio));
8f6025b8:	e1a00600 	lsl	r0, r0, #12
	val |= enable << 9;
8f6025bc:	e183330c 	orr	r3, r3, r12, lsl #6
8f6025c0:	e1833482 	orr	r3, r3, r2, lsl #9
{
8f6025c4:	e59f2034 	ldr	r2, [pc, #52]	; 8f602600 <gpio_tlmm_config+0x5c>
	val |= enable << 9;
8f6025c8:	e1833101 	orr	r3, r3, r1, lsl #2
{
8f6025cc:	e5922000 	ldr	r2, [r2]
8f6025d0:	e58d2004 	str	r2, [r13, #4]
8f6025d4:	e3a02000 	mov	r2, #0
	writel(val, (uint32_t *)GPIO_CONFIG_ADDR(gpio));
8f6025d8:	e5803000 	str	r3, [r0]
	return;
}
8f6025dc:	e59f301c 	ldr	r3, [pc, #28]	; 8f602600 <gpio_tlmm_config+0x5c>
8f6025e0:	e5932000 	ldr	r2, [r3]
8f6025e4:	e59d3004 	ldr	r3, [r13, #4]
8f6025e8:	e0332002 	eors	r2, r3, r2
8f6025ec:	e3a03000 	mov	r3, #0
8f6025f0:	1a000001 	bne	8f6025fc <gpio_tlmm_config+0x58>
8f6025f4:	e28dd00c 	add	r13, r13, #12
8f6025f8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6025fc:	eb00c16f 	bl	8f632bc0 <__stack_chk_fail>
8f602600:	8f74221c 	.word	0x8f74221c

8f602604 <gpio_status>:

	return;
}

uint32_t gpio_status(uint32_t gpio)
{
8f602604:	e59f3044 	ldr	r3, [pc, #68]	; 8f602650 <gpio_status+0x4c>
	return readl(GPIO_IN_OUT_ADDR(gpio)) & GPIO_IN;
8f602608:	e1a00600 	lsl	r0, r0, #12
{
8f60260c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f602610:	e24dd00c 	sub	r13, r13, #12
8f602614:	e5933000 	ldr	r3, [r3]
8f602618:	e58d3004 	str	r3, [r13, #4]
8f60261c:	e3a03000 	mov	r3, #0
	return readl(GPIO_IN_OUT_ADDR(gpio)) & GPIO_IN;
8f602620:	e2800401 	add	r0, r0, #16777216	; 0x1000000
}
8f602624:	e59f3024 	ldr	r3, [pc, #36]	; 8f602650 <gpio_status+0x4c>
	return readl(GPIO_IN_OUT_ADDR(gpio)) & GPIO_IN;
8f602628:	e5900004 	ldr	r0, [r0, #4]
}
8f60262c:	e5932000 	ldr	r2, [r3]
8f602630:	e59d3004 	ldr	r3, [r13, #4]
8f602634:	e0332002 	eors	r2, r3, r2
8f602638:	e3a03000 	mov	r3, #0
8f60263c:	1a000002 	bne	8f60264c <gpio_status+0x48>
8f602640:	e2000001 	and	r0, r0, #1
8f602644:	e28dd00c 	add	r13, r13, #12
8f602648:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60264c:	eb00c15b 	bl	8f632bc0 <__stack_chk_fail>
8f602650:	8f74221c 	.word	0x8f74221c

8f602654 <gpio_config_uart_dm>:

/* Configure gpio for blsp uart 2 */
void gpio_config_uart_dm(uint8_t id)
{
8f602654:	e59f0050 	ldr	r0, [pc, #80]	; 8f6026ac <gpio_config_uart_dm+0x58>
	writel(val, (uint32_t *)GPIO_CONFIG_ADDR(gpio));
8f602658:	e3a01a05 	mov	r1, #20480	; 0x5000
8f60265c:	e3a03901 	mov	r3, #16384	; 0x4000
8f602660:	e3401100 	movt	r1, #256	; 0x100
8f602664:	e3403100 	movt	r3, #256	; 0x100
8f602668:	e3a02fb2 	mov	r2, #712	; 0x2c8
{
8f60266c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f602670:	e24dd00c 	sub	r13, r13, #12
8f602674:	e5900000 	ldr	r0, [r0]
8f602678:	e58d0004 	str	r0, [r13, #4]
8f60267c:	e3a00000 	mov	r0, #0
	writel(val, (uint32_t *)GPIO_CONFIG_ADDR(gpio));
8f602680:	e5812000 	str	r2, [r1]
8f602684:	e5832000 	str	r2, [r3]
				GPIO_8MA, GPIO_DISABLE);

	/* configure tx gpio */
	gpio_tlmm_config(4, 2, GPIO_OUTPUT, GPIO_NO_PULL,
				GPIO_8MA, GPIO_DISABLE);
}
8f602688:	e59f301c 	ldr	r3, [pc, #28]	; 8f6026ac <gpio_config_uart_dm+0x58>
8f60268c:	e5932000 	ldr	r2, [r3]
8f602690:	e59d3004 	ldr	r3, [r13, #4]
8f602694:	e0332002 	eors	r2, r3, r2
8f602698:	e3a03000 	mov	r3, #0
8f60269c:	1a000001 	bne	8f6026a8 <gpio_config_uart_dm+0x54>
8f6026a0:	e28dd00c 	add	r13, r13, #12
8f6026a4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6026a8:	eb00c144 	bl	8f632bc0 <__stack_chk_fail>
8f6026ac:	8f74221c 	.word	0x8f74221c

8f6026b0 <lk_log_getbuf>:
	log.data[log.header.idx++] = c;
	log.header.size_written++;
	if (unlikely(log.header.idx >= log.header.max_size))
		log.header.idx = 0;
}
char* lk_log_getbuf(void) {
8f6026b0:	e59f3038 	ldr	r3, [pc, #56]	; 8f6026f0 <lk_log_getbuf+0x40>
8f6026b4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6026b8:	e24dd00c 	sub	r13, r13, #12
8f6026bc:	e5933000 	ldr	r3, [r3]
8f6026c0:	e58d3004 	str	r3, [r13, #4]
8f6026c4:	e3a03000 	mov	r3, #0
    return log.data;
}
8f6026c8:	e59f3020 	ldr	r3, [pc, #32]	; 8f6026f0 <lk_log_getbuf+0x40>
8f6026cc:	e5932000 	ldr	r2, [r3]
8f6026d0:	e59d3004 	ldr	r3, [r13, #4]
8f6026d4:	e0332002 	eors	r2, r3, r2
8f6026d8:	e3a03000 	mov	r3, #0
8f6026dc:	1a000002 	bne	8f6026ec <lk_log_getbuf+0x3c>
8f6026e0:	e59f000c 	ldr	r0, [pc, #12]	; 8f6026f4 <lk_log_getbuf+0x44>
8f6026e4:	e28dd00c 	add	r13, r13, #12
8f6026e8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6026ec:	eb00c133 	bl	8f632bc0 <__stack_chk_fail>
8f6026f0:	8f74221c 	.word	0x8f74221c
8f6026f4:	8f70d234 	.word	0x8f70d234

8f6026f8 <lk_log_getsize>:
unsigned lk_log_getsize(void) {
    return log.header.size_written;
8f6026f8:	e30d3224 	movw	r3, #53796	; 0xd224
8f6026fc:	e3483f70 	movt	r3, #36720	; 0x8f70
unsigned lk_log_getsize(void) {
8f602700:	e59f2038 	ldr	r2, [pc, #56]	; 8f602740 <lk_log_getsize+0x48>
8f602704:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f602708:	e24dd00c 	sub	r13, r13, #12
    return log.header.size_written;
8f60270c:	e5930008 	ldr	r0, [r3, #8]
unsigned lk_log_getsize(void) {
8f602710:	e5922000 	ldr	r2, [r2]
8f602714:	e58d2004 	str	r2, [r13, #4]
8f602718:	e3a02000 	mov	r2, #0
}
8f60271c:	e59f301c 	ldr	r3, [pc, #28]	; 8f602740 <lk_log_getsize+0x48>
8f602720:	e5932000 	ldr	r2, [r3]
8f602724:	e59d3004 	ldr	r3, [r13, #4]
8f602728:	e0332002 	eors	r2, r3, r2
8f60272c:	e3a03000 	mov	r3, #0
8f602730:	1a000001 	bne	8f60273c <lk_log_getsize+0x44>
8f602734:	e28dd00c 	add	r13, r13, #12
8f602738:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60273c:	eb00c11f 	bl	8f632bc0 <__stack_chk_fail>
8f602740:	8f74221c 	.word	0x8f74221c

8f602744 <_dputc>:
	}
#endif
}

void _dputc(char c)
{
8f602744:	e59f307c 	ldr	r3, [pc, #124]	; 8f6027c8 <_dputc+0x84>
	if(!c) return;
8f602748:	e2501000 	subs	r1, r0, #0
{
8f60274c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f602750:	e24dd00c 	sub	r13, r13, #12
8f602754:	e5933000 	ldr	r3, [r3]
8f602758:	e58d3004 	str	r3, [r13, #4]
8f60275c:	e3a03000 	mov	r3, #0
	if(!c) return;
8f602760:	0a00000d 	beq	8f60279c <_dputc+0x58>
	log.data[log.header.idx++] = c;
8f602764:	e30d3224 	movw	r3, #53796	; 0xd224
8f602768:	e3483f70 	movt	r3, #36720	; 0x8f70
8f60276c:	e593200c 	ldr	r2, [r3, #12]
	if (unlikely(log.header.idx >= log.header.max_size))
8f602770:	e593c004 	ldr	r12, [r3, #4]
	log.data[log.header.idx++] = c;
8f602774:	e2820001 	add	r0, r2, #1
8f602778:	e0832002 	add	r2, r3, r2
	if (unlikely(log.header.idx >= log.header.max_size))
8f60277c:	e150000c 	cmp	r0, r12
	log.data[log.header.idx++] = c;
8f602780:	e583000c 	str	r0, [r3, #12]
8f602784:	e5c21010 	strb	r1, [r2, #16]
	log.header.size_written++;
8f602788:	e5932008 	ldr	r2, [r3, #8]
8f60278c:	e2822001 	add	r2, r2, #1
8f602790:	e5832008 	str	r2, [r3, #8]
		log.header.idx = 0;
8f602794:	23a02000 	movcs	r2, #0
8f602798:	2583200c 	strcs	r2, [r3, #12]
		write_dcc('\r');
	}
	write_dcc(c) ;
#endif
#if WITH_DEBUG_UART
	uart_putc(0, c);
8f60279c:	e59f3024 	ldr	r3, [pc, #36]	; 8f6027c8 <_dputc+0x84>
8f6027a0:	e5932000 	ldr	r2, [r3]
8f6027a4:	e59d3004 	ldr	r3, [r13, #4]
8f6027a8:	e0332002 	eors	r2, r3, r2
8f6027ac:	e3a03000 	mov	r3, #0
8f6027b0:	1a000003 	bne	8f6027c4 <_dputc+0x80>
8f6027b4:	e3a00000 	mov	r0, #0
	fbcon_putc(c);
#endif
#if WITH_DEBUG_JTAG
	jtag_dputc(c);
#endif
}
8f6027b8:	e28dd00c 	add	r13, r13, #12
8f6027bc:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	uart_putc(0, c);
8f6027c0:	ea003662 	b	8f610150 <uart_putc>
8f6027c4:	eb00c0fd 	bl	8f632bc0 <__stack_chk_fail>
8f6027c8:	8f74221c 	.word	0x8f74221c

8f6027cc <platform_halt>:
		return 0;
	}
}

void platform_halt(void)
{
8f6027cc:	e59f3048 	ldr	r3, [pc, #72]	; 8f60281c <platform_halt+0x50>
8f6027d0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6027d4:	e24dd00c 	sub	r13, r13, #12
8f6027d8:	e5933000 	ldr	r3, [r3]
8f6027dc:	e58d3004 	str	r3, [r13, #4]
8f6027e0:	e3a03000 	mov	r3, #0
#if PON_VIB_SUPPORT
	vib_turn_off();
8f6027e4:	eb00bfc2 	bl	8f6326f4 <vib_turn_off>
#endif
	dprintf(CRITICAL, "HALT: reboot into dload mode...\n");
8f6027e8:	e3000afc 	movw	r0, #2812	; 0xafc
8f6027ec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6027f0:	eb00c05f 	bl	8f632974 <_dprintf>
	arch_clean_cache_range(MEMBASE, MEMSIZE);
8f6027f4:	e3a0160a 	mov	r1, #10485760	; 0xa00000
8f6027f8:	e3a00000 	mov	r0, #0
8f6027fc:	e3480f60 	movt	r0, #36704	; 0x8f60
8f602800:	eb0079dd 	bl	8f620f7c <arch_clean_cache_range>
	reboot_device(NORMAL_DLOAD);
8f602804:	e3a0021f 	mov	r0, #-268435455	; 0xf0000001
8f602808:	eb0076c2 	bl	8f620318 <reboot_device>

	dprintf(CRITICAL, "HALT: spinning forever...\n");
8f60280c:	e3000b20 	movw	r0, #2848	; 0xb20
8f602810:	e3480f70 	movt	r0, #36720	; 0x8f70
8f602814:	eb00c056 	bl	8f632974 <_dprintf>
	for (;;) ;
8f602818:	eafffffe 	b	8f602818 <platform_halt+0x4c>
8f60281c:	8f74221c 	.word	0x8f74221c

8f602820 <smem_read_alloc_entry>:
}
#endif

/* buf MUST be 4byte aligned, and len MUST be a multiple of 8. */
unsigned smem_read_alloc_entry(smem_mem_type_t type, void *buf, int len)
{
8f602820:	e59f30d0 	ldr	r3, [pc, #208]	; 8f6028f8 <smem_read_alloc_entry+0xd8>
8f602824:	e92d4070 	push	{r4, r5, r6, r14}
8f602828:	e24dd008 	sub	r13, r13, #8
8f60282c:	e1a05002 	mov	r5, r2
8f602830:	e5933000 	ldr	r3, [r3]
8f602834:	e58d3004 	str	r3, [r13, #4]
8f602838:	e3a03000 	mov	r3, #0
8f60283c:	e1a04001 	mov	r4, r1
8f602840:	e1a06000 	mov	r6, r0
	uint32_t smem_addr = 0;

#if DYNAMIC_SMEM
	smem_addr = smem_get_base_addr();
#else
	smem_addr = platform_get_smem_base_addr();
8f602844:	ebfffbf3 	bl	8f601818 <platform_get_smem_base_addr>
#endif

	smem = (struct smem *)smem_addr;
8f602848:	e3092000 	movw	r2, #36864	; 0x9000
8f60284c:	e3482f72 	movt	r2, #36722	; 0x8f72
8f602850:	e5820000 	str	r0, [r2]

	if (((len & 0x3) != 0) || (((unsigned)buf & 0x3) != 0))
8f602854:	e1842005 	orr	r2, r4, r5
	smem_addr = platform_get_smem_base_addr();
8f602858:	e1a03000 	mov	r3, r0
	if (((len & 0x3) != 0) || (((unsigned)buf & 0x3) != 0))
8f60285c:	e2120003 	ands	r0, r2, #3
8f602860:	1a00001a 	bne	8f6028d0 <smem_read_alloc_entry+0xb0>
		return 1;

	if (type < SMEM_FIRST_VALID_TYPE || type > SMEM_LAST_VALID_TYPE)
8f602864:	e2462007 	sub	r2, r6, #7
8f602868:	e3520f67 	cmp	r2, #412	; 0x19c
8f60286c:	2a000017 	bcs	8f6028d0 <smem_read_alloc_entry+0xb0>
		return 1;

	/* TODO: Use smem spinlocks */
	ainfo = &smem->alloc_info[type];
	if (readl(&ainfo->allocated) == 0)
8f602870:	e0832206 	add	r2, r3, r6, lsl #4
8f602874:	e59210d0 	ldr	r1, [r2, #208]	; 0xd0
8f602878:	e3510000 	cmp	r1, #0
8f60287c:	0a000013 	beq	8f6028d0 <smem_read_alloc_entry+0xb0>
		return 1;

	size = readl(&ainfo->size);
8f602880:	e592c0d8 	ldr	r12, [r2, #216]	; 0xd8

	if (size < (unsigned)((len + 7) & ~0x00000007))
8f602884:	e2851007 	add	r1, r5, #7
8f602888:	e3c11007 	bic	r1, r1, #7
8f60288c:	e151000c 	cmp	r1, r12
8f602890:	8a00000e 	bhi	8f6028d0 <smem_read_alloc_entry+0xb0>
		return 1;

	src = smem_addr + readl(&ainfo->offset);
8f602894:	e59220d4 	ldr	r2, [r2, #212]	; 0xd4
	for (; len > 0; src += 4, len -= 4)
8f602898:	e3550000 	cmp	r5, #0
	src = smem_addr + readl(&ainfo->offset);
8f60289c:	e0823003 	add	r3, r2, r3
	for (; len > 0; src += 4, len -= 4)
8f6028a0:	da00000b 	ble	8f6028d4 <smem_read_alloc_entry+0xb4>
8f6028a4:	e2452001 	sub	r2, r5, #1
8f6028a8:	e0433004 	sub	r3, r3, r4
8f6028ac:	e3c22003 	bic	r2, r2, #3
8f6028b0:	e2822004 	add	r2, r2, #4
8f6028b4:	e0842002 	add	r2, r4, r2
		*(dest++) = readl(src);
8f6028b8:	e0841003 	add	r1, r4, r3
8f6028bc:	e5911000 	ldr	r1, [r1]
8f6028c0:	e4841004 	str	r1, [r4], #4
	for (; len > 0; src += 4, len -= 4)
8f6028c4:	e1540002 	cmp	r4, r2
8f6028c8:	1afffffa 	bne	8f6028b8 <smem_read_alloc_entry+0x98>
8f6028cc:	ea000000 	b	8f6028d4 <smem_read_alloc_entry+0xb4>
		return 1;
8f6028d0:	e3a00001 	mov	r0, #1

	return 0;
}
8f6028d4:	e59f301c 	ldr	r3, [pc, #28]	; 8f6028f8 <smem_read_alloc_entry+0xd8>
8f6028d8:	e5932000 	ldr	r2, [r3]
8f6028dc:	e59d3004 	ldr	r3, [r13, #4]
8f6028e0:	e0332002 	eors	r2, r3, r2
8f6028e4:	e3a03000 	mov	r3, #0
8f6028e8:	1a000001 	bne	8f6028f4 <smem_read_alloc_entry+0xd4>
8f6028ec:	e28dd008 	add	r13, r13, #8
8f6028f0:	e8bd8070 	pop	{r4, r5, r6, r15}
8f6028f4:	eb00c0b1 	bl	8f632bc0 <__stack_chk_fail>
8f6028f8:	8f74221c 	.word	0x8f74221c

8f6028fc <smem_get_alloc_entry>:

/* Return a pointer to smem_item with size */
void* smem_get_alloc_entry(smem_mem_type_t type, uint32_t* size)
{
8f6028fc:	e59f308c 	ldr	r3, [pc, #140]	; 8f602990 <smem_get_alloc_entry+0x94>
8f602900:	e92d4030 	push	{r4, r5, r14}
8f602904:	e24dd00c 	sub	r13, r13, #12
8f602908:	e5933000 	ldr	r3, [r3]
8f60290c:	e58d3004 	str	r3, [r13, #4]
8f602910:	e3a03000 	mov	r3, #0
8f602914:	e1a04000 	mov	r4, r0
8f602918:	e1a05001 	mov	r5, r1
	void *ret = NULL;

#if DYNAMIC_SMEM
	smem_addr = smem_get_base_addr();
#else
	smem_addr = platform_get_smem_base_addr();
8f60291c:	ebfffbbd 	bl	8f601818 <platform_get_smem_base_addr>
#endif
	smem = (struct smem *)smem_addr;

	if (type < SMEM_FIRST_VALID_TYPE || type > SMEM_LAST_VALID_TYPE)
8f602920:	e2442007 	sub	r2, r4, #7
	smem = (struct smem *)smem_addr;
8f602924:	e3093000 	movw	r3, #36864	; 0x9000
	if (type < SMEM_FIRST_VALID_TYPE || type > SMEM_LAST_VALID_TYPE)
8f602928:	e3520f67 	cmp	r2, #412	; 0x19c
	smem = (struct smem *)smem_addr;
8f60292c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f602930:	e5830000 	str	r0, [r3]
		return ret;
8f602934:	23a00000 	movcs	r0, #0
	if (type < SMEM_FIRST_VALID_TYPE || type > SMEM_LAST_VALID_TYPE)
8f602938:	2a00000b 	bcs	8f60296c <smem_get_alloc_entry+0x70>

	ainfo = &smem->alloc_info[type];
	if (readl(&ainfo->allocated) == 0)
8f60293c:	e0803204 	add	r3, r0, r4, lsl #4
8f602940:	e59320d0 	ldr	r2, [r3, #208]	; 0xd0
8f602944:	e3520000 	cmp	r2, #0
		return ret;
8f602948:	01a00002 	moveq	r0, r2
	if (readl(&ainfo->allocated) == 0)
8f60294c:	0a000006 	beq	8f60296c <smem_get_alloc_entry+0x70>
		return ret;

	*size = readl(&ainfo->size);
8f602950:	e59320d8 	ldr	r2, [r3, #216]	; 0xd8
8f602954:	e5852000 	str	r2, [r5]
	base_ext = readl(&ainfo->base_ext);
8f602958:	e59320dc 	ldr	r2, [r3, #220]	; 0xdc
	offset = readl(&ainfo->offset);
8f60295c:	e59330d4 	ldr	r3, [r3, #212]	; 0xd4

	if(base_ext)
8f602960:	e3520000 	cmp	r2, #0
	{
		ret = (void*)base_ext + offset;
8f602964:	10820003 	addne	r0, r2, r3
	}
	else
	{
		ret = (void*) smem_addr + offset;
8f602968:	00800003 	addeq	r0, r0, r3
	}

	return ret;
}
8f60296c:	e59f301c 	ldr	r3, [pc, #28]	; 8f602990 <smem_get_alloc_entry+0x94>
8f602970:	e5932000 	ldr	r2, [r3]
8f602974:	e59d3004 	ldr	r3, [r13, #4]
8f602978:	e0332002 	eors	r2, r3, r2
8f60297c:	e3a03000 	mov	r3, #0
8f602980:	1a000001 	bne	8f60298c <smem_get_alloc_entry+0x90>
8f602984:	e28dd00c 	add	r13, r13, #12
8f602988:	e8bd8030 	pop	{r4, r5, r15}
8f60298c:	eb00c08b 	bl	8f632bc0 <__stack_chk_fail>
8f602990:	8f74221c 	.word	0x8f74221c

8f602994 <smem_read_alloc_entry_offset>:

unsigned
smem_read_alloc_entry_offset(smem_mem_type_t type, void *buf, int len,
			     int offset)
{
8f602994:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f602998:	e1a06003 	mov	r6, r3
8f60299c:	e59f30b0 	ldr	r3, [pc, #176]	; 8f602a54 <smem_read_alloc_entry_offset+0xc0>
8f6029a0:	e24dd00c 	sub	r13, r13, #12
8f6029a4:	e1a04001 	mov	r4, r1
8f6029a8:	e1a05002 	mov	r5, r2
8f6029ac:	e5933000 	ldr	r3, [r3]
8f6029b0:	e58d3004 	str	r3, [r13, #4]
8f6029b4:	e3a03000 	mov	r3, #0
8f6029b8:	e1a07000 	mov	r7, r0
	uint32_t smem_addr = 0;

#if DYNAMIC_SMEM
	smem_addr = smem_get_base_addr();
#else
	smem_addr = platform_get_smem_base_addr();
8f6029bc:	ebfffb95 	bl	8f601818 <platform_get_smem_base_addr>
#endif

	smem = (struct smem *)smem_addr;

	if (((len & 0x3) != 0) || (((unsigned)buf & 0x3) != 0))
8f6029c0:	e1843005 	orr	r3, r4, r5
	smem = (struct smem *)smem_addr;
8f6029c4:	e3091000 	movw	r1, #36864	; 0x9000
8f6029c8:	e3481f72 	movt	r1, #36722	; 0x8f72
	smem_addr = platform_get_smem_base_addr();
8f6029cc:	e1a02000 	mov	r2, r0
	if (((len & 0x3) != 0) || (((unsigned)buf & 0x3) != 0))
8f6029d0:	e2130003 	ands	r0, r3, #3
	smem = (struct smem *)smem_addr;
8f6029d4:	e5812000 	str	r2, [r1]
	if (((len & 0x3) != 0) || (((unsigned)buf & 0x3) != 0))
8f6029d8:	1a000013 	bne	8f602a2c <smem_read_alloc_entry_offset+0x98>
		return 1;

	if (type < SMEM_FIRST_VALID_TYPE || type > SMEM_LAST_VALID_TYPE)
8f6029dc:	e2473007 	sub	r3, r7, #7
8f6029e0:	e3530f67 	cmp	r3, #412	; 0x19c
8f6029e4:	2a000010 	bcs	8f602a2c <smem_read_alloc_entry_offset+0x98>
		return 1;

	ainfo = &smem->alloc_info[type];
	if (readl(&ainfo->allocated) == 0)
8f6029e8:	e0827207 	add	r7, r2, r7, lsl #4
8f6029ec:	e59730d0 	ldr	r3, [r7, #208]	; 0xd0
8f6029f0:	e3530000 	cmp	r3, #0
8f6029f4:	0a00000c 	beq	8f602a2c <smem_read_alloc_entry_offset+0x98>
		return 1;

	src = smem_addr + readl(&ainfo->offset) + offset;
8f6029f8:	e0862002 	add	r2, r6, r2
	for (; size > 0; src += 4, size -= 4)
8f6029fc:	e3550000 	cmp	r5, #0
	src = smem_addr + readl(&ainfo->offset) + offset;
8f602a00:	e59760d4 	ldr	r6, [r7, #212]	; 0xd4
8f602a04:	e0822006 	add	r2, r2, r6
	for (; size > 0; src += 4, size -= 4)
8f602a08:	0a000008 	beq	8f602a30 <smem_read_alloc_entry_offset+0x9c>
8f602a0c:	e0422004 	sub	r2, r2, r4
8f602a10:	e0845005 	add	r5, r4, r5
		*(dest++) = readl(src);
8f602a14:	e0843002 	add	r3, r4, r2
8f602a18:	e5933000 	ldr	r3, [r3]
8f602a1c:	e4843004 	str	r3, [r4], #4
	for (; size > 0; src += 4, size -= 4)
8f602a20:	e1540005 	cmp	r4, r5
8f602a24:	1afffffa 	bne	8f602a14 <smem_read_alloc_entry_offset+0x80>
8f602a28:	ea000000 	b	8f602a30 <smem_read_alloc_entry_offset+0x9c>
		return 1;
8f602a2c:	e3a00001 	mov	r0, #1

	return 0;
}
8f602a30:	e59f301c 	ldr	r3, [pc, #28]	; 8f602a54 <smem_read_alloc_entry_offset+0xc0>
8f602a34:	e5932000 	ldr	r2, [r3]
8f602a38:	e59d3004 	ldr	r3, [r13, #4]
8f602a3c:	e0332002 	eors	r2, r3, r2
8f602a40:	e3a03000 	mov	r3, #0
8f602a44:	1a000001 	bne	8f602a50 <smem_read_alloc_entry_offset+0xbc>
8f602a48:	e28dd00c 	add	r13, r13, #12
8f602a4c:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
8f602a50:	eb00c05a 	bl	8f632bc0 <__stack_chk_fail>
8f602a54:	8f74221c 	.word	0x8f74221c

8f602a58 <smem_alloc_write_entry>:

/* buf MUST be 4byte aligned, and len MUST be a multiple of 8. */
unsigned smem_alloc_write_entry(smem_mem_type_t type, void *buf, unsigned size)
{
8f602a58:	e59f3120 	ldr	r3, [pc, #288]	; 8f602b80 <smem_alloc_write_entry+0x128>
8f602a5c:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f602a60:	e24dd00c 	sub	r13, r13, #12
8f602a64:	e5933000 	ldr	r3, [r3]
8f602a68:	e58d3004 	str	r3, [r13, #4]
8f602a6c:	e3a03000 	mov	r3, #0
8f602a70:	e1a04001 	mov	r4, r1
8f602a74:	e1a06002 	mov	r6, r2
8f602a78:	e1a07000 	mov	r7, r0
	uint32_t smem_addr = 0;

#if DYNAMIC_SMEM
	smem_addr = smem_get_base_addr();
#else
	smem_addr = platform_get_smem_base_addr();
8f602a7c:	ebfffb65 	bl	8f601818 <platform_get_smem_base_addr>
#endif

	smem = (struct smem *)smem_addr;

	if (((size % 8) != 0) || (((unsigned)buf & 0x3) != 0))
8f602a80:	e2065007 	and	r5, r6, #7
8f602a84:	e2043003 	and	r3, r4, #3
	smem = (struct smem *)smem_addr;
8f602a88:	e309e000 	movw	r14, #36864	; 0x9000
	if (((size % 8) != 0) || (((unsigned)buf & 0x3) != 0))
8f602a8c:	e1953003 	orrs	r3, r5, r3
	smem = (struct smem *)smem_addr;
8f602a90:	e348ef72 	movt	r14, #36722	; 0x8f72
8f602a94:	e58e0000 	str	r0, [r14]
	if (((size % 8) != 0) || (((unsigned)buf & 0x3) != 0))
8f602a98:	1a000028 	bne	8f602b40 <smem_alloc_write_entry+0xe8>
		return 22;

	if (type < SMEM_FIRST_VALID_TYPE || type > SMEM_LAST_VALID_TYPE)
8f602a9c:	e2473007 	sub	r3, r7, #7
8f602aa0:	e3530f67 	cmp	r3, #412	; 0x19c
8f602aa4:	2a000025 	bcs	8f602b40 <smem_alloc_write_entry+0xe8>
	 *     We don't communicate with it from LK so maybe we can get away
	 *     without any locking.
	 *   - YOLO.
	 */
	ainfo = &smem->alloc_info[type];
	if (readl(&ainfo->allocated)) {
8f602aa8:	e0805207 	add	r5, r0, r7, lsl #4
8f602aac:	e1a0c000 	mov	r12, r0
8f602ab0:	e59500d0 	ldr	r0, [r5, #208]	; 0xd0
8f602ab4:	e3500000 	cmp	r0, #0
8f602ab8:	1a000022 	bne	8f602b48 <smem_alloc_write_entry+0xf0>
		dprintf(CRITICAL, "SMEM entry %d is already allocated\n", type);
		return 1;
	}

	remaining = readl(&smem->heap_info.heap_remaining);
8f602abc:	e59c30c8 	ldr	r3, [r12, #200]	; 0xc8
	if (size > remaining) {
8f602ac0:	e1560003 	cmp	r6, r3
8f602ac4:	8a000025 	bhi	8f602b60 <smem_alloc_write_entry+0x108>
			type, size, remaining);
		return 12;
	}

	/* Allocate entry in SMEM */
	offset = readl(&smem->heap_info.free_offset);
8f602ac8:	e59c70c4 	ldr	r7, [r12, #196]	; 0xc4
	uint32_t *src = buf, *src_end = (uint32_t*)((uint32_t)buf + size);
8f602acc:	e0841006 	add	r1, r4, r6
	writel(offset, &ainfo->offset);
8f602ad0:	e58570d4 	str	r7, [r5, #212]	; 0xd4
	writel(size, &ainfo->size);
8f602ad4:	e58560d8 	str	r6, [r5, #216]	; 0xd8

	dsb();
8f602ad8:	f57ff04f 	dsb	sy
	writel(1, &ainfo->allocated);

	writel(offset + size, &smem->heap_info.free_offset);
8f602adc:	e59ee000 	ldr	r14, [r14]
	writel(remaining - size, &smem->heap_info.heap_remaining);
8f602ae0:	e0433006 	sub	r3, r3, r6
	writel(offset + size, &smem->heap_info.free_offset);
8f602ae4:	e0862007 	add	r2, r6, r7
	writel(1, &ainfo->allocated);
8f602ae8:	e3a06001 	mov	r6, #1
8f602aec:	e58560d0 	str	r6, [r5, #208]	; 0xd0
	writel(offset + size, &smem->heap_info.free_offset);
8f602af0:	e58e20c4 	str	r2, [r14, #196]	; 0xc4
	writel(remaining - size, &smem->heap_info.heap_remaining);
8f602af4:	e58e30c8 	str	r3, [r14, #200]	; 0xc8
	dsb();
8f602af8:	f57ff04f 	dsb	sy

	/* Write data to SMEM */
	for (dest = (uint32_t*)(smem_addr + offset); src < src_end; ++src, ++dest)
8f602afc:	e1540001 	cmp	r4, r1
8f602b00:	e08cc007 	add	r12, r12, r7
8f602b04:	2a000005 	bcs	8f602b20 <smem_alloc_write_entry+0xc8>
8f602b08:	e04cc004 	sub	r12, r12, r4
		writel(*src, dest);
8f602b0c:	e5943000 	ldr	r3, [r4]
8f602b10:	e784300c 	str	r3, [r4, r12]
	for (dest = (uint32_t*)(smem_addr + offset); src < src_end; ++src, ++dest)
8f602b14:	e2844004 	add	r4, r4, #4
8f602b18:	e1510004 	cmp	r1, r4
8f602b1c:	8afffffa 	bhi	8f602b0c <smem_alloc_write_entry+0xb4>

	return 0;
}
8f602b20:	e59f3058 	ldr	r3, [pc, #88]	; 8f602b80 <smem_alloc_write_entry+0x128>
8f602b24:	e5932000 	ldr	r2, [r3]
8f602b28:	e59d3004 	ldr	r3, [r13, #4]
8f602b2c:	e0332002 	eors	r2, r3, r2
8f602b30:	e3a03000 	mov	r3, #0
8f602b34:	1a000010 	bne	8f602b7c <smem_alloc_write_entry+0x124>
8f602b38:	e28dd00c 	add	r13, r13, #12
8f602b3c:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		return 22;
8f602b40:	e3a00016 	mov	r0, #22
8f602b44:	eafffff5 	b	8f602b20 <smem_alloc_write_entry+0xc8>
		dprintf(CRITICAL, "SMEM entry %d is already allocated\n", type);
8f602b48:	e1a01007 	mov	r1, r7
8f602b4c:	e3000b3c 	movw	r0, #2876	; 0xb3c
8f602b50:	e3480f70 	movt	r0, #36720	; 0x8f70
8f602b54:	eb00bf86 	bl	8f632974 <_dprintf>
		return 1;
8f602b58:	e3a00001 	mov	r0, #1
8f602b5c:	eaffffef 	b	8f602b20 <smem_alloc_write_entry+0xc8>
		dprintf(CRITICAL, "Not enough space in SMEM for entry %d. size: %u, remaining: %u\n",
8f602b60:	e1a02006 	mov	r2, r6
8f602b64:	e1a01007 	mov	r1, r7
8f602b68:	e3000b60 	movw	r0, #2912	; 0xb60
8f602b6c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f602b70:	eb00bf7f 	bl	8f632974 <_dprintf>
		return 12;
8f602b74:	e3a0000c 	mov	r0, #12
8f602b78:	eaffffe8 	b	8f602b20 <smem_alloc_write_entry+0xc8>
}
8f602b7c:	eb00c00f 	bl	8f632bc0 <__stack_chk_fail>
8f602b80:	8f74221c 	.word	0x8f74221c

8f602b84 <smem_get_hw_platform_name>:

size_t smem_get_hw_platform_name(void *buf, uint32_t buf_size)
{
8f602b84:	e92d4070 	push	{r4, r5, r6, r14}
	uint32 hw_id;

	if (buf == NULL) {
8f602b88:	e2505000 	subs	r5, r0, #0
{
8f602b8c:	e59f30ac 	ldr	r3, [pc, #172]	; 8f602c40 <smem_get_hw_platform_name+0xbc>
8f602b90:	e24dd008 	sub	r13, r13, #8
8f602b94:	e5933000 	ldr	r3, [r3]
8f602b98:	e58d3004 	str	r3, [r13, #4]
8f602b9c:	e3a03000 	mov	r3, #0
	if (buf == NULL) {
8f602ba0:	0a000021 	beq	8f602c2c <smem_get_hw_platform_name+0xa8>
		dprintf(CRITICAL, "ERROR: buf is NULL\n");
		return 1;
	}

	hw_id = board_hardware_id();
8f602ba4:	e1a04001 	mov	r4, r1
8f602ba8:	eb0035ad 	bl	8f610264 <board_hardware_id>
	if (hw_id >= ARRAY_SIZE(hw_platform))
		hw_id = HW_PLATFORM_UNKNOWN;

	if (buf_size < strlen(hw_platform[hw_id]) + 1)
8f602bac:	e3013234 	movw	r3, #4660	; 0x1234
8f602bb0:	e3483f71 	movt	r3, #36721	; 0x8f71
		hw_id = HW_PLATFORM_UNKNOWN;
8f602bb4:	e3500022 	cmp	r0, #34	; 0x22
8f602bb8:	23a00000 	movcs	r0, #0
	if (buf_size < strlen(hw_platform[hw_id]) + 1)
8f602bbc:	e7936100 	ldr	r6, [r3, r0, lsl #2]
8f602bc0:	e1a00006 	mov	r0, r6
8f602bc4:	eb00c70f 	bl	8f634808 <strlen>
8f602bc8:	e2801001 	add	r1, r0, #1
8f602bcc:	e1510004 	cmp	r1, r4
8f602bd0:	9a000008 	bls	8f602bf8 <smem_get_hw_platform_name+0x74>
		return 1;

	return snprintf(buf, strlen(hw_platform[hw_id]) + 1,
		"%s\n", hw_platform[hw_id]);
}
8f602bd4:	e59f3064 	ldr	r3, [pc, #100]	; 8f602c40 <smem_get_hw_platform_name+0xbc>
8f602bd8:	e5932000 	ldr	r2, [r3]
8f602bdc:	e59d3004 	ldr	r3, [r13, #4]
8f602be0:	e0332002 	eors	r2, r3, r2
8f602be4:	e3a03000 	mov	r3, #0
8f602be8:	1a000013 	bne	8f602c3c <smem_get_hw_platform_name+0xb8>
8f602bec:	e3a00001 	mov	r0, #1
8f602bf0:	e28dd008 	add	r13, r13, #8
8f602bf4:	e8bd8070 	pop	{r4, r5, r6, r15}
	return snprintf(buf, strlen(hw_platform[hw_id]) + 1,
8f602bf8:	e59f3040 	ldr	r3, [pc, #64]	; 8f602c40 <smem_get_hw_platform_name+0xbc>
8f602bfc:	e5932000 	ldr	r2, [r3]
8f602c00:	e59d3004 	ldr	r3, [r13, #4]
8f602c04:	e0332002 	eors	r2, r3, r2
8f602c08:	e3a03000 	mov	r3, #0
8f602c0c:	1a00000a 	bne	8f602c3c <smem_get_hw_platform_name+0xb8>
8f602c10:	e30326e0 	movw	r2, #14048	; 0x36e0
8f602c14:	e1a03006 	mov	r3, r6
8f602c18:	e3482f70 	movt	r2, #36720	; 0x8f70
8f602c1c:	e1a00005 	mov	r0, r5
}
8f602c20:	e28dd008 	add	r13, r13, #8
8f602c24:	e8bd4070 	pop	{r4, r5, r6, r14}
	return snprintf(buf, strlen(hw_platform[hw_id]) + 1,
8f602c28:	ea00c4c4 	b	8f633f40 <snprintf>
		dprintf(CRITICAL, "ERROR: buf is NULL\n");
8f602c2c:	e3000ba0 	movw	r0, #2976	; 0xba0
8f602c30:	e3480f70 	movt	r0, #36720	; 0x8f70
8f602c34:	eb00bf4e 	bl	8f632974 <_dprintf>
		return 1;
8f602c38:	eaffffe5 	b	8f602bd4 <smem_get_hw_platform_name+0x50>
}
8f602c3c:	eb00bfdf 	bl	8f632bc0 <__stack_chk_fail>
8f602c40:	8f74221c 	.word	0x8f74221c

8f602c44 <smem_copy_ram_ptable>:
		}
	}
}

static void smem_copy_ram_ptable(void *buf)
{
8f602c44:	e59f31d8 	ldr	r3, [pc, #472]	; 8f602e24 <smem_copy_ram_ptable+0x1e0>
8f602c48:	e1a0c000 	mov	r12, r0
8f602c4c:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f602c50:	e24dd010 	sub	r13, r13, #16
	struct smem_ram_ptable *table_v0 = NULL;
	struct smem_ram_ptable_v1 *table_v1 = NULL;
	struct smem_ram_ptable_v2 *table_v2 = NULL;
	uint32_t pentry = 0;

	ptable.hdr = *(struct smem_ram_ptable_hdr*)buf;
8f602c54:	e5900000 	ldr	r0, [r0]
{
8f602c58:	e5933000 	ldr	r3, [r3]
8f602c5c:	e58d300c 	str	r3, [r13, #12]
8f602c60:	e3a03000 	mov	r3, #0
	ptable.hdr = *(struct smem_ram_ptable_hdr*)buf;
8f602c64:	e59c2008 	ldr	r2, [r12, #8]
8f602c68:	e30b4464 	movw	r4, #46180	; 0xb464
8f602c6c:	e59c1004 	ldr	r1, [r12, #4]
8f602c70:	e3484f72 	movt	r4, #36722	; 0x8f72
8f602c74:	e59c300c 	ldr	r3, [r12, #12]

	/* Perform member to member copy from smem_ram_ptable to wrapper struct ram_ptable */
	if(ptable.hdr.version == SMEM_RAM_PTABLE_VERSION_2)
8f602c78:	e3520002 	cmp	r2, #2
	ptable.hdr = *(struct smem_ram_ptable_hdr*)buf;
8f602c7c:	e1a05004 	mov	r5, r4
8f602c80:	e8a5000f 	stmia	r5!, {r0, r1, r2, r3}
8f602c84:	e59c0010 	ldr	r0, [r12, #16]
8f602c88:	e5850000 	str	r0, [r5]
	if(ptable.hdr.version == SMEM_RAM_PTABLE_VERSION_2)
8f602c8c:	0a000048 	beq	8f602db4 <smem_copy_ram_ptable+0x170>
	{
		table_v2 = (struct smem_ram_ptable_v2*)buf;

		memcpy(&ptable, table_v2, sizeof(ram_partition_table));
	}
	else if(ptable.hdr.version == SMEM_RAM_PTABLE_VERSION_1)
8f602c90:	e3520001 	cmp	r2, #1
8f602c94:	e1a01002 	mov	r1, r2
8f602c98:	0a000027 	beq	8f602d3c <smem_copy_ram_ptable+0xf8>
			ptable.parts[pentry].domain         = table_v1->parts[pentry].domain;
			ptable.parts[pentry].type           = table_v1->parts[pentry].type;
			ptable.parts[pentry].num_partitions = table_v1->parts[pentry].num_partitions;
		}
	}
	else if(ptable.hdr.version == SMEM_RAM_PTABLE_VERSION_0)
8f602c9c:	e3520000 	cmp	r2, #0
8f602ca0:	1a00004f 	bne	8f602de4 <smem_copy_ram_ptable+0x1a0>
	{
		table_v0 = (struct smem_ram_ptable*)buf;

		for(pentry = 0; pentry < ((struct smem_ram_ptable_hdr*)buf)->len; pentry++)
8f602ca4:	e59c6010 	ldr	r6, [r12, #16]
8f602ca8:	e3560000 	cmp	r6, #0
8f602cac:	0a00001a 	beq	8f602d1c <smem_copy_ram_ptable+0xd8>
8f602cb0:	e1a02004 	mov	r2, r4
		{
			ptable.parts[pentry].start          = table_v0->parts[pentry].start;
8f602cb4:	e3a07048 	mov	r7, #72	; 0x48
8f602cb8:	e3a0e038 	mov	r14, #56	; 0x38
8f602cbc:	e1a05001 	mov	r5, r1
8f602cc0:	e023c19e 	mla	r3, r14, r1, r12
8f602cc4:	e0204197 	mla	r0, r7, r1, r4
8f602cc8:	e5938024 	ldr	r8, [r3, #36]	; 0x24
8f602ccc:	e580502c 	str	r5, [r0, #44]	; 0x2c
8f602cd0:	e5808028 	str	r8, [r0, #40]	; 0x28
			ptable.parts[pentry].size           = table_v0->parts[pentry].size;
8f602cd4:	e5938028 	ldr	r8, [r3, #40]	; 0x28
8f602cd8:	e5805034 	str	r5, [r0, #52]	; 0x34
8f602cdc:	e5808030 	str	r8, [r0, #48]	; 0x30
			ptable.parts[pentry].attr           = table_v0->parts[pentry].attr;
8f602ce0:	e593802c 	ldr	r8, [r3, #44]	; 0x2c
			ptable.parts[pentry].category       = table_v0->parts[pentry].category;
			ptable.parts[pentry].domain         = table_v0->parts[pentry].domain;
			ptable.parts[pentry].type           = table_v0->parts[pentry].type;
			ptable.parts[pentry].num_partitions = table_v0->parts[pentry].num_partitions;
8f602ce4:	e020ee91 	mla	r0, r1, r14, r14
		for(pentry = 0; pentry < ((struct smem_ram_ptable_hdr*)buf)->len; pentry++)
8f602ce8:	e2811001 	add	r1, r1, #1
			ptable.parts[pentry].attr           = table_v0->parts[pentry].attr;
8f602cec:	e5828038 	str	r8, [r2, #56]	; 0x38
		for(pentry = 0; pentry < ((struct smem_ram_ptable_hdr*)buf)->len; pentry++)
8f602cf0:	e1510006 	cmp	r1, r6
			ptable.parts[pentry].category       = table_v0->parts[pentry].category;
8f602cf4:	e5938030 	ldr	r8, [r3, #48]	; 0x30
			ptable.parts[pentry].num_partitions = table_v0->parts[pentry].num_partitions;
8f602cf8:	e08c0000 	add	r0, r12, r0
			ptable.parts[pentry].category       = table_v0->parts[pentry].category;
8f602cfc:	e582803c 	str	r8, [r2, #60]	; 0x3c
			ptable.parts[pentry].domain         = table_v0->parts[pentry].domain;
8f602d00:	e5938034 	ldr	r8, [r3, #52]	; 0x34
8f602d04:	e5828040 	str	r8, [r2, #64]	; 0x40
			ptable.parts[pentry].type           = table_v0->parts[pentry].type;
8f602d08:	e5933038 	ldr	r3, [r3, #56]	; 0x38
8f602d0c:	e5823044 	str	r3, [r2, #68]	; 0x44
			ptable.parts[pentry].num_partitions = table_v0->parts[pentry].num_partitions;
8f602d10:	e5903004 	ldr	r3, [r0, #4]
8f602d14:	e5a23048 	str	r3, [r2, #72]!	; 0x48
		for(pentry = 0; pentry < ((struct smem_ram_ptable_hdr*)buf)->len; pentry++)
8f602d18:	1affffe8 	bne	8f602cc0 <smem_copy_ram_ptable+0x7c>
	else
	{
		dprintf(CRITICAL,"ERROR: Unknown smem ram ptable version: %u", ptable.hdr.version);
		ASSERT(0);
	}
}
8f602d1c:	e59f3100 	ldr	r3, [pc, #256]	; 8f602e24 <smem_copy_ram_ptable+0x1e0>
8f602d20:	e5932000 	ldr	r2, [r3]
8f602d24:	e59d300c 	ldr	r3, [r13, #12]
8f602d28:	e0332002 	eors	r2, r3, r2
8f602d2c:	e3a03000 	mov	r3, #0
8f602d30:	1a00003a 	bne	8f602e20 <smem_copy_ram_ptable+0x1dc>
8f602d34:	e28dd010 	add	r13, r13, #16
8f602d38:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
		for(pentry = 0; pentry < ((struct smem_ram_ptable_hdr*)buf)->len; pentry++)
8f602d3c:	e59c5010 	ldr	r5, [r12, #16]
8f602d40:	e3550000 	cmp	r5, #0
8f602d44:	0afffff4 	beq	8f602d1c <smem_copy_ram_ptable+0xd8>
8f602d48:	e1a02004 	mov	r2, r4
8f602d4c:	e3a01000 	mov	r1, #0
			ptable.parts[pentry].start          = table_v1->parts[pentry].start;
8f602d50:	e3a06048 	mov	r6, #72	; 0x48
8f602d54:	e0204196 	mla	r0, r6, r1, r4
8f602d58:	e08c3301 	add	r3, r12, r1, lsl #6
		for(pentry = 0; pentry < ((struct smem_ram_ptable_hdr*)buf)->len; pentry++)
8f602d5c:	e2811001 	add	r1, r1, #1
			ptable.parts[pentry].start          = table_v1->parts[pentry].start;
8f602d60:	e5937028 	ldr	r7, [r3, #40]	; 0x28
		for(pentry = 0; pentry < ((struct smem_ram_ptable_hdr*)buf)->len; pentry++)
8f602d64:	e1510005 	cmp	r1, r5
			ptable.parts[pentry].start          = table_v1->parts[pentry].start;
8f602d68:	e593e02c 	ldr	r14, [r3, #44]	; 0x2c
8f602d6c:	e5807028 	str	r7, [r0, #40]	; 0x28
8f602d70:	e580e02c 	str	r14, [r0, #44]	; 0x2c
			ptable.parts[pentry].size           = table_v1->parts[pentry].size;
8f602d74:	e5937030 	ldr	r7, [r3, #48]	; 0x30
8f602d78:	e593e034 	ldr	r14, [r3, #52]	; 0x34
8f602d7c:	e5807030 	str	r7, [r0, #48]	; 0x30
8f602d80:	e580e034 	str	r14, [r0, #52]	; 0x34
			ptable.parts[pentry].attr           = table_v1->parts[pentry].attr;
8f602d84:	e5930038 	ldr	r0, [r3, #56]	; 0x38
8f602d88:	e5820038 	str	r0, [r2, #56]	; 0x38
			ptable.parts[pentry].category       = table_v1->parts[pentry].category;
8f602d8c:	e593003c 	ldr	r0, [r3, #60]	; 0x3c
8f602d90:	e582003c 	str	r0, [r2, #60]	; 0x3c
			ptable.parts[pentry].domain         = table_v1->parts[pentry].domain;
8f602d94:	e5930040 	ldr	r0, [r3, #64]	; 0x40
8f602d98:	e5820040 	str	r0, [r2, #64]	; 0x40
			ptable.parts[pentry].type           = table_v1->parts[pentry].type;
8f602d9c:	e5930044 	ldr	r0, [r3, #68]	; 0x44
8f602da0:	e5820044 	str	r0, [r2, #68]	; 0x44
			ptable.parts[pentry].num_partitions = table_v1->parts[pentry].num_partitions;
8f602da4:	e5933048 	ldr	r3, [r3, #72]	; 0x48
8f602da8:	e5a23048 	str	r3, [r2, #72]!	; 0x48
		for(pentry = 0; pentry < ((struct smem_ram_ptable_hdr*)buf)->len; pentry++)
8f602dac:	1affffe8 	bne	8f602d54 <smem_copy_ram_ptable+0x110>
8f602db0:	eaffffd9 	b	8f602d1c <smem_copy_ram_ptable+0xd8>
		memcpy(&ptable, table_v2, sizeof(ram_partition_table));
8f602db4:	e59f3068 	ldr	r3, [pc, #104]	; 8f602e24 <smem_copy_ram_ptable+0x1e0>
8f602db8:	e5932000 	ldr	r2, [r3]
8f602dbc:	e59d300c 	ldr	r3, [r13, #12]
8f602dc0:	e0332002 	eors	r2, r3, r2
8f602dc4:	e3a03000 	mov	r3, #0
8f602dc8:	1a000014 	bne	8f602e20 <smem_copy_ram_ptable+0x1dc>
8f602dcc:	e3002918 	movw	r2, #2328	; 0x918
8f602dd0:	e1a0100c 	mov	r1, r12
8f602dd4:	e1a00004 	mov	r0, r4
}
8f602dd8:	e28dd010 	add	r13, r13, #16
8f602ddc:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, r14}
		memcpy(&ptable, table_v2, sizeof(ram_partition_table));
8f602de0:	ea00c4f4 	b	8f6341b8 <memcpy>
8f602de4:	e1a0600e 	mov	r6, r14
		dprintf(CRITICAL,"ERROR: Unknown smem ram ptable version: %u", ptable.hdr.version);
8f602de8:	e3000c20 	movw	r0, #3104	; 0xc20
8f602dec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f602df0:	eb00bedf 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f602df4:	e307cf64 	movw	r12, #32612	; 0x7f64
8f602df8:	e3002c4c 	movw	r2, #3148	; 0xc4c
8f602dfc:	e348cf70 	movt	r12, #36720	; 0x8f70
8f602e00:	e3482f70 	movt	r2, #36720	; 0x8f70
8f602e04:	e3001130 	movw	r1, #304	; 0x130
8f602e08:	e3a030cf 	mov	r3, #207	; 0xcf
8f602e0c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f602e10:	e1a00006 	mov	r0, r6
8f602e14:	e58dc000 	str	r12, [r13]
8f602e18:	eb00bf27 	bl	8f632abc <_panic>
}
8f602e1c:	eaffffbe 	b	8f602d1c <smem_copy_ram_ptable+0xd8>
8f602e20:	eb00bf66 	bl	8f632bc0 <__stack_chk_fail>
8f602e24:	8f74221c 	.word	0x8f74221c

8f602e28 <smem_ram_ptable_init_v1>:
}

/* RAM Partition table from SMEM */
static uint32_t buffer[sizeof(struct smem_ram_ptable_v2)];
int smem_ram_ptable_init_v1()
{
8f602e28:	e92d4030 	push	{r4, r5, r14}
8f602e2c:	e24dd014 	sub	r13, r13, #20
8f602e30:	e59fc11c 	ldr	r12, [pc, #284]	; 8f602f54 <smem_ram_ptable_init_v1+0x12c>
	uint32_t version;
	uint32_t smem_ram_ptable_size = 0;
	struct smem_ram_ptable_hdr *ram_ptable_hdr;

	/* Check smem ram partition table version and decide on length of ram_ptable */
	ret = smem_read_alloc_entry_offset(SMEM_USABLE_RAM_PARTITION_TABLE,
8f602e34:	e28d1008 	add	r1, r13, #8
8f602e38:	e3a03008 	mov	r3, #8
8f602e3c:	e3a02004 	mov	r2, #4
8f602e40:	e3000192 	movw	r0, #402	; 0x192
{
8f602e44:	e59cc000 	ldr	r12, [r12]
8f602e48:	e58dc00c 	str	r12, [r13, #12]
8f602e4c:	e3a0c000 	mov	r12, #0
	ret = smem_read_alloc_entry_offset(SMEM_USABLE_RAM_PARTITION_TABLE,
8f602e50:	e1a0500e 	mov	r5, r14
8f602e54:	ebfffece 	bl	8f602994 <smem_read_alloc_entry_offset>
						&version,
						sizeof(version),
						SMEM_RAM_PTABLE_VERSION_OFFSET);

	if(ret)
8f602e58:	e2504000 	subs	r4, r0, #0
8f602e5c:	1a00001a 	bne	8f602ecc <smem_ram_ptable_init_v1+0xa4>
		return 0;

	if(version == SMEM_RAM_PTABLE_VERSION_2)
8f602e60:	e59d1008 	ldr	r1, [r13, #8]
8f602e64:	e3510002 	cmp	r1, #2
8f602e68:	03002918 	movweq	r2, #2328	; 0x918
8f602e6c:	0a000005 	beq	8f602e88 <smem_ram_ptable_init_v1+0x60>
		smem_ram_ptable_size = sizeof(struct smem_ram_ptable_v2);
	else if(version == SMEM_RAM_PTABLE_VERSION_1)
8f602e70:	e3510001 	cmp	r1, #1
8f602e74:	03002818 	movweq	r2, #2072	; 0x818
8f602e78:	0a000002 	beq	8f602e88 <smem_ram_ptable_init_v1+0x60>
		smem_ram_ptable_size = sizeof(struct smem_ram_ptable_v1);
	else if(version == SMEM_RAM_PTABLE_VERSION_0)
8f602e7c:	e3510000 	cmp	r1, #0
8f602e80:	03002718 	movweq	r2, #1816	; 0x718
8f602e84:	1a000019 	bne	8f602ef0 <smem_ram_ptable_init_v1+0xc8>
	{
		dprintf(CRITICAL,"ERROR: Wrong smem_ram_ptable version: %u", version);
		ASSERT(0);
	}

	i = smem_read_alloc_entry(SMEM_USABLE_RAM_PARTITION_TABLE,
8f602e88:	e3094004 	movw	r4, #36868	; 0x9004
8f602e8c:	e3484f72 	movt	r4, #36722	; 0x8f72
8f602e90:	e3000192 	movw	r0, #402	; 0x192
8f602e94:	e1a01004 	mov	r1, r4
8f602e98:	ebfffe60 	bl	8f602820 <smem_read_alloc_entry>
				  (void*)buffer,
				  smem_ram_ptable_size);
	if (i != 0)
8f602e9c:	e3500000 	cmp	r0, #0
8f602ea0:	1a000009 	bne	8f602ecc <smem_ram_ptable_init_v1+0xa4>
		return 0;

	ram_ptable_hdr = (struct smem_ram_ptable_hdr *)buffer;

	if (ram_ptable_hdr->magic[0] != _SMEM_RAM_PTABLE_MAGIC_1 ||
8f602ea4:	e5942000 	ldr	r2, [r4]
8f602ea8:	e30e30a8 	movw	r3, #57512	; 0xe0a8
8f602eac:	e3493da5 	movt	r3, #40357	; 0x9da5
8f602eb0:	e1520003 	cmp	r2, r3
8f602eb4:	1a000004 	bne	8f602ecc <smem_ram_ptable_init_v1+0xa4>
8f602eb8:	e5942004 	ldr	r2, [r4, #4]
8f602ebc:	e30c34e2 	movw	r3, #50402	; 0xc4e2
8f602ec0:	e34a3f9e 	movt	r3, #44958	; 0xaf9e
8f602ec4:	e1520003 	cmp	r2, r3
8f602ec8:	0a000017 	beq	8f602f2c <smem_ram_ptable_init_v1+0x104>
		return 0;
8f602ecc:	e3a00000 	mov	r0, #0

	dprintf(SPEW, "smem ram ptable found: ver: %u len: %u\n",
		ram_ptable_hdr->version, ram_ptable_hdr->len);

	return 1;
}
8f602ed0:	e59f307c 	ldr	r3, [pc, #124]	; 8f602f54 <smem_ram_ptable_init_v1+0x12c>
8f602ed4:	e5932000 	ldr	r2, [r3]
8f602ed8:	e59d300c 	ldr	r3, [r13, #12]
8f602edc:	e0332002 	eors	r2, r3, r2
8f602ee0:	e3a03000 	mov	r3, #0
8f602ee4:	1a000019 	bne	8f602f50 <smem_ram_ptable_init_v1+0x128>
8f602ee8:	e28dd014 	add	r13, r13, #20
8f602eec:	e8bd8030 	pop	{r4, r5, r15}
		dprintf(CRITICAL,"ERROR: Wrong smem_ram_ptable version: %u", version);
8f602ef0:	e3000c70 	movw	r0, #3184	; 0xc70
8f602ef4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f602ef8:	eb00be9d 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f602efc:	e3071f64 	movw	r1, #32612	; 0x7f64
8f602f00:	e3003106 	movw	r3, #262	; 0x106
8f602f04:	e3481f70 	movt	r1, #36720	; 0x8f70
8f602f08:	e3002c4c 	movw	r2, #3148	; 0xc4c
8f602f0c:	e58d1000 	str	r1, [r13]
8f602f10:	e3482f70 	movt	r2, #36720	; 0x8f70
8f602f14:	e1a00005 	mov	r0, r5
8f602f18:	e3001130 	movw	r1, #304	; 0x130
8f602f1c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f602f20:	eb00bee5 	bl	8f632abc <_panic>
8f602f24:	e1a02004 	mov	r2, r4
8f602f28:	eaffffd6 	b	8f602e88 <smem_ram_ptable_init_v1+0x60>
	smem_copy_ram_ptable((void*)buffer);
8f602f2c:	e1a00004 	mov	r0, r4
8f602f30:	ebffff43 	bl	8f602c44 <smem_copy_ram_ptable>
	dprintf(SPEW, "smem ram ptable found: ver: %u len: %u\n",
8f602f34:	e5942010 	ldr	r2, [r4, #16]
8f602f38:	e5941008 	ldr	r1, [r4, #8]
8f602f3c:	e3000c9c 	movw	r0, #3228	; 0xc9c
8f602f40:	e3480f70 	movt	r0, #36720	; 0x8f70
8f602f44:	eb00be8a 	bl	8f632974 <_dprintf>
	return 1;
8f602f48:	e3a00001 	mov	r0, #1
8f602f4c:	eaffffdf 	b	8f602ed0 <smem_ram_ptable_init_v1+0xa8>
}
8f602f50:	eb00bf1a 	bl	8f632bc0 <__stack_chk_fail>
8f602f54:	8f74221c 	.word	0x8f74221c

8f602f58 <smem_get_ram_ptable_entry>:

void smem_get_ram_ptable_entry(ram_partition *ptn, uint32_t entry)
{
8f602f58:	e59f304c 	ldr	r3, [pc, #76]	; 8f602fac <smem_get_ram_ptable_entry+0x54>
8f602f5c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f602f60:	e24dd00c 	sub	r13, r13, #12
8f602f64:	e5933000 	ldr	r3, [r3]
8f602f68:	e58d3004 	str	r3, [r13, #4]
8f602f6c:	e3a03000 	mov	r3, #0
	memcpy(ptn, &(ptable.parts[entry]), sizeof(ram_partition));
8f602f70:	e59f3034 	ldr	r3, [pc, #52]	; 8f602fac <smem_get_ram_ptable_entry+0x54>
8f602f74:	e5932000 	ldr	r2, [r3]
8f602f78:	e59d3004 	ldr	r3, [r13, #4]
8f602f7c:	e0332002 	eors	r2, r3, r2
8f602f80:	e3a03000 	mov	r3, #0
8f602f84:	1a000007 	bne	8f602fa8 <smem_get_ram_ptable_entry+0x50>
8f602f88:	e30b3464 	movw	r3, #46180	; 0xb464
8f602f8c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f602f90:	e3a02048 	mov	r2, #72	; 0x48
8f602f94:	e0213192 	mla	r1, r2, r1, r3
8f602f98:	e2811018 	add	r1, r1, #24
}
8f602f9c:	e28dd00c 	add	r13, r13, #12
8f602fa0:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	memcpy(ptn, &(ptable.parts[entry]), sizeof(ram_partition));
8f602fa4:	ea00c483 	b	8f6341b8 <memcpy>
8f602fa8:	eb00bf04 	bl	8f632bc0 <__stack_chk_fail>
8f602fac:	8f74221c 	.word	0x8f74221c

8f602fb0 <smem_get_ram_ptable_len>:

uint32_t smem_get_ram_ptable_len(void)
{
	return ptable.hdr.len;
8f602fb0:	e30b3464 	movw	r3, #46180	; 0xb464
8f602fb4:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f602fb8:	e59f2038 	ldr	r2, [pc, #56]	; 8f602ff8 <smem_get_ram_ptable_len+0x48>
8f602fbc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f602fc0:	e24dd00c 	sub	r13, r13, #12
	return ptable.hdr.len;
8f602fc4:	e5930010 	ldr	r0, [r3, #16]
{
8f602fc8:	e5922000 	ldr	r2, [r2]
8f602fcc:	e58d2004 	str	r2, [r13, #4]
8f602fd0:	e3a02000 	mov	r2, #0
}
8f602fd4:	e59f301c 	ldr	r3, [pc, #28]	; 8f602ff8 <smem_get_ram_ptable_len+0x48>
8f602fd8:	e5932000 	ldr	r2, [r3]
8f602fdc:	e59d3004 	ldr	r3, [r13, #4]
8f602fe0:	e0332002 	eors	r2, r3, r2
8f602fe4:	e3a03000 	mov	r3, #0
8f602fe8:	1a000001 	bne	8f602ff4 <smem_get_ram_ptable_len+0x44>
8f602fec:	e28dd00c 	add	r13, r13, #12
8f602ff0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f602ff4:	eb00bef1 	bl	8f632bc0 <__stack_chk_fail>
8f602ff8:	8f74221c 	.word	0x8f74221c

8f602ffc <smem_get_ram_ptable_version>:

uint32_t smem_get_ram_ptable_version(void)
{
	return ptable.hdr.version;
8f602ffc:	e30b3464 	movw	r3, #46180	; 0xb464
8f603000:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f603004:	e59f2038 	ldr	r2, [pc, #56]	; 8f603044 <smem_get_ram_ptable_version+0x48>
8f603008:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60300c:	e24dd00c 	sub	r13, r13, #12
	return ptable.hdr.version;
8f603010:	e5930008 	ldr	r0, [r3, #8]
{
8f603014:	e5922000 	ldr	r2, [r2]
8f603018:	e58d2004 	str	r2, [r13, #4]
8f60301c:	e3a02000 	mov	r2, #0
}
8f603020:	e59f301c 	ldr	r3, [pc, #28]	; 8f603044 <smem_get_ram_ptable_version+0x48>
8f603024:	e5932000 	ldr	r2, [r3]
8f603028:	e59d3004 	ldr	r3, [r13, #4]
8f60302c:	e0332002 	eors	r2, r3, r2
8f603030:	e3a03000 	mov	r3, #0
8f603034:	1a000001 	bne	8f603040 <smem_get_ram_ptable_version+0x44>
8f603038:	e28dd00c 	add	r13, r13, #12
8f60303c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f603040:	eb00bede 	bl	8f632bc0 <__stack_chk_fail>
8f603044:	8f74221c 	.word	0x8f74221c

8f603048 <get_ddr_start>:

uint32_t get_ddr_start()
{
8f603048:	e59f3110 	ldr	r3, [pc, #272]	; 8f603160 <get_ddr_start+0x118>
8f60304c:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f603050:	e24dd05c 	sub	r13, r13, #92	; 0x5c
8f603054:	e5933000 	ldr	r3, [r3]
8f603058:	e58d3054 	str	r3, [r13, #84]	; 0x54
8f60305c:	e3a03000 	mov	r3, #0
	uint32_t i;
	ram_partition ptn_entry;
	uint32_t len = 0;

	ASSERT(smem_ram_ptable_init_v1());
8f603060:	e1a0700e 	mov	r7, r14
8f603064:	ebffff6f 	bl	8f602e28 <smem_ram_ptable_init_v1>
8f603068:	e3500000 	cmp	r0, #0
8f60306c:	0a00002f 	beq	8f603130 <get_ddr_start+0xe8>
	return ptable.hdr.len;
8f603070:	e30b4464 	movw	r4, #46180	; 0xb464
8f603074:	e3484f72 	movt	r4, #36722	; 0x8f72
8f603078:	e5946010 	ldr	r6, [r4, #16]

	len = smem_get_ram_ptable_len();

	/* Determine the Start addr of the DDR RAM */
	for(i = 0; i < len; i++)
8f60307c:	e3560000 	cmp	r6, #0
8f603080:	12844018 	addne	r4, r4, #24
8f603084:	13a05000 	movne	r5, #0
8f603088:	1a000004 	bne	8f6030a0 <get_ddr_start+0x58>
8f60308c:	ea00001e 	b	8f60310c <get_ddr_start+0xc4>
8f603090:	e2855001 	add	r5, r5, #1
8f603094:	e2844048 	add	r4, r4, #72	; 0x48
8f603098:	e1560005 	cmp	r6, r5
8f60309c:	0a00001a 	beq	8f60310c <get_ddr_start+0xc4>
	memcpy(ptn, &(ptable.parts[entry]), sizeof(ram_partition));
8f6030a0:	e28d000c 	add	r0, r13, #12
8f6030a4:	e3a02048 	mov	r2, #72	; 0x48
8f6030a8:	e1a01004 	mov	r1, r4
8f6030ac:	eb00c441 	bl	8f6341b8 <memcpy>
	{
		smem_get_ram_ptable_entry(&ptn_entry, i);
		if(ptn_entry.type == SYS_MEMORY)
8f6030b0:	e59d3038 	ldr	r3, [r13, #56]	; 0x38
8f6030b4:	e3530001 	cmp	r3, #1
8f6030b8:	1afffff4 	bne	8f603090 <get_ddr_start+0x48>
		{
			if((ptn_entry.category == SDRAM) ||
8f6030bc:	e59d3030 	ldr	r3, [r13, #48]	; 0x30
8f6030c0:	e3530005 	cmp	r3, #5
8f6030c4:	1353000e 	cmpne	r3, #14
8f6030c8:	1afffff0 	bne	8f603090 <get_ddr_start+0x48>
			   (ptn_entry.category == IMEM))
			{
				/* Check to ensure that start address is 1MB aligned */
				ASSERT((ptn_entry.start & (MB-1)) == 0);
8f6030cc:	e59d001c 	ldr	r0, [r13, #28]
8f6030d0:	e7f33050 	ubfx	r3, r0, #0, #20
8f6030d4:	e3933000 	orrs	r3, r3, #0
8f6030d8:	0a00000c 	beq	8f603110 <get_ddr_start+0xc8>
8f6030dc:	e1a00007 	mov	r0, r7
8f6030e0:	e300ccc4 	movw	r12, #3268	; 0xcc4
8f6030e4:	e3a03d05 	mov	r3, #320	; 0x140
8f6030e8:	e348cf70 	movt	r12, #36720	; 0x8f70
8f6030ec:	e3002c4c 	movw	r2, #3148	; 0xc4c
8f6030f0:	e3001130 	movw	r1, #304	; 0x130
8f6030f4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6030f8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6030fc:	e58dc000 	str	r12, [r13]
8f603100:	eb00be6d 	bl	8f632abc <_panic>
				return ptn_entry.start;
8f603104:	e59d001c 	ldr	r0, [r13, #28]
8f603108:	ea000000 	b	8f603110 <get_ddr_start+0xc8>
			}
		}
	}
	ASSERT("DDR Start Mem Not found\n");
	return 0;
8f60310c:	e3a00000 	mov	r0, #0
}
8f603110:	e59f3048 	ldr	r3, [pc, #72]	; 8f603160 <get_ddr_start+0x118>
8f603114:	e5932000 	ldr	r2, [r3]
8f603118:	e59d3054 	ldr	r3, [r13, #84]	; 0x54
8f60311c:	e0332002 	eors	r2, r3, r2
8f603120:	e3a03000 	mov	r3, #0
8f603124:	1a00000c 	bne	8f60315c <get_ddr_start+0x114>
8f603128:	e28dd05c 	add	r13, r13, #92	; 0x5c
8f60312c:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
	ASSERT(smem_ram_ptable_init_v1());
8f603130:	e3000290 	movw	r0, #656	; 0x290
8f603134:	e3002c4c 	movw	r2, #3148	; 0xc4c
8f603138:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60313c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f603140:	e58d0000 	str	r0, [r13]
8f603144:	e3001130 	movw	r1, #304	; 0x130
8f603148:	e3003132 	movw	r3, #306	; 0x132
8f60314c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f603150:	e1a00007 	mov	r0, r7
8f603154:	eb00be58 	bl	8f632abc <_panic>
8f603158:	eaffffc4 	b	8f603070 <get_ddr_start+0x28>
}
8f60315c:	eb00be97 	bl	8f632bc0 <__stack_chk_fail>
8f603160:	8f74221c 	.word	0x8f74221c

8f603164 <smem_get_ddr_size>:

uint64_t smem_get_ddr_size()
{
8f603164:	e59f3104 	ldr	r3, [pc, #260]	; 8f603270 <smem_get_ddr_size+0x10c>
8f603168:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f60316c:	e24dd058 	sub	r13, r13, #88	; 0x58
8f603170:	e5933000 	ldr	r3, [r3]
8f603174:	e58d3054 	str	r3, [r13, #84]	; 0x54
8f603178:	e3a03000 	mov	r3, #0
	uint32_t i;
	ram_partition ptn_entry;
	uint32_t len = 0;
	uint64_t size = 0;

	ASSERT(smem_ram_ptable_init_v1());
8f60317c:	e1a0400e 	mov	r4, r14
8f603180:	ebffff28 	bl	8f602e28 <smem_ram_ptable_init_v1>
8f603184:	e3500000 	cmp	r0, #0
8f603188:	0a00002c 	beq	8f603240 <smem_get_ddr_size+0xdc>
	return ptable.hdr.len;
8f60318c:	e30b4464 	movw	r4, #46180	; 0xb464
8f603190:	e3484f72 	movt	r4, #36722	; 0x8f72
8f603194:	e5946010 	ldr	r6, [r4, #16]

	len = smem_get_ram_ptable_len();

	/* Determine the Start addr of the DDR RAM */
	for(i = 0; i < len; i++)
8f603198:	e3560000 	cmp	r6, #0
8f60319c:	0a000024 	beq	8f603234 <smem_get_ddr_size+0xd0>
	uint64_t size = 0;
8f6031a0:	e3a07000 	mov	r7, #0
8f6031a4:	e2844018 	add	r4, r4, #24
8f6031a8:	e1a08007 	mov	r8, r7
	for(i = 0; i < len; i++)
8f6031ac:	e1a05007 	mov	r5, r7
8f6031b0:	ea000003 	b	8f6031c4 <smem_get_ddr_size+0x60>
8f6031b4:	e2855001 	add	r5, r5, #1
8f6031b8:	e2844048 	add	r4, r4, #72	; 0x48
8f6031bc:	e1560005 	cmp	r6, r5
8f6031c0:	0a000011 	beq	8f60320c <smem_get_ddr_size+0xa8>
	memcpy(ptn, &(ptable.parts[entry]), sizeof(ram_partition));
8f6031c4:	e28d000c 	add	r0, r13, #12
8f6031c8:	e3a02048 	mov	r2, #72	; 0x48
8f6031cc:	e1a01004 	mov	r1, r4
8f6031d0:	eb00c3f8 	bl	8f6341b8 <memcpy>
	{
		smem_get_ram_ptable_entry(&ptn_entry, i);
		if(ptn_entry.type == SYS_MEMORY && ptn_entry.category == SDRAM)
8f6031d4:	e59d3038 	ldr	r3, [r13, #56]	; 0x38
8f6031d8:	e3530001 	cmp	r3, #1
8f6031dc:	1afffff4 	bne	8f6031b4 <smem_get_ddr_size+0x50>
8f6031e0:	e59d3030 	ldr	r3, [r13, #48]	; 0x30
8f6031e4:	e353000e 	cmp	r3, #14
8f6031e8:	1afffff1 	bne	8f6031b4 <smem_get_ddr_size+0x50>
			size += ptn_entry.size;
8f6031ec:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
	for(i = 0; i < len; i++)
8f6031f0:	e2855001 	add	r5, r5, #1
8f6031f4:	e2844048 	add	r4, r4, #72	; 0x48
			size += ptn_entry.size;
8f6031f8:	e0937007 	adds	r7, r3, r7
8f6031fc:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f603200:	e0a88003 	adc	r8, r8, r3
	for(i = 0; i < len; i++)
8f603204:	e1560005 	cmp	r6, r5
8f603208:	1affffed 	bne	8f6031c4 <smem_get_ddr_size+0x60>
	}

	return size;
}
8f60320c:	e59f305c 	ldr	r3, [pc, #92]	; 8f603270 <smem_get_ddr_size+0x10c>
8f603210:	e5932000 	ldr	r2, [r3]
8f603214:	e59d3054 	ldr	r3, [r13, #84]	; 0x54
8f603218:	e0332002 	eors	r2, r3, r2
8f60321c:	e3a03000 	mov	r3, #0
8f603220:	1a000011 	bne	8f60326c <smem_get_ddr_size+0x108>
8f603224:	e1a00007 	mov	r0, r7
8f603228:	e1a01008 	mov	r1, r8
8f60322c:	e28dd058 	add	r13, r13, #88	; 0x58
8f603230:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
	uint64_t size = 0;
8f603234:	e1a07006 	mov	r7, r6
8f603238:	e1a08006 	mov	r8, r6
	return size;
8f60323c:	eafffff2 	b	8f60320c <smem_get_ddr_size+0xa8>
	ASSERT(smem_ram_ptable_init_v1());
8f603240:	e300c290 	movw	r12, #656	; 0x290
8f603244:	e3002c4c 	movw	r2, #3148	; 0xc4c
8f603248:	e348cf70 	movt	r12, #36720	; 0x8f70
8f60324c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f603250:	e3001130 	movw	r1, #304	; 0x130
8f603254:	e3a03e15 	mov	r3, #336	; 0x150
8f603258:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60325c:	e1a00004 	mov	r0, r4
8f603260:	e58dc000 	str	r12, [r13]
8f603264:	eb00be14 	bl	8f632abc <_panic>
8f603268:	eaffffc7 	b	8f60318c <smem_get_ddr_size+0x28>
}
8f60326c:	eb00be53 	bl	8f632bc0 <__stack_chk_fail>
8f603270:	8f74221c 	.word	0x8f74221c

8f603274 <mbr_fill_name>:
/*
 * Fill name for android partition found.
 */
static void
mbr_fill_name(struct partition_entry *partition_ent, unsigned int type)
{
8f603274:	e59f350c 	ldr	r3, [pc, #1292]	; 8f603788 <mbr_fill_name+0x514>
	switch (type) {
8f603278:	e2411006 	sub	r1, r1, #6
{
8f60327c:	e92d4070 	push	{r4, r5, r6, r14}
8f603280:	e24dd008 	sub	r13, r13, #8
8f603284:	e5933000 	ldr	r3, [r3]
8f603288:	e58d3004 	str	r3, [r13, #4]
8f60328c:	e3a03000 	mov	r3, #0
8f603290:	e1a04000 	mov	r4, r0
	switch (type) {
8f603294:	e351007d 	cmp	r1, #125	; 0x7d
8f603298:	979ff101 	ldrls	r15, [r15, r1, lsl #2]
8f60329c:	ea00008b 	b	8f6034d0 <mbr_fill_name+0x25c>
8f6032a0:	8f6034f0 	.word	0x8f6034f0
8f6032a4:	8f6034d0 	.word	0x8f6034d0
8f6032a8:	8f6034d0 	.word	0x8f6034d0
8f6032ac:	8f6034d0 	.word	0x8f6034d0
8f6032b0:	8f6034d0 	.word	0x8f6034d0
8f6032b4:	8f6034d0 	.word	0x8f6034d0
8f6032b8:	8f6034f0 	.word	0x8f6034f0
8f6032bc:	8f6034d0 	.word	0x8f6034d0
8f6032c0:	8f6034d0 	.word	0x8f6034d0
8f6032c4:	8f6034d0 	.word	0x8f6034d0
8f6032c8:	8f6034d0 	.word	0x8f6034d0
8f6032cc:	8f6034d0 	.word	0x8f6034d0
8f6032d0:	8f6034d0 	.word	0x8f6034d0
8f6032d4:	8f6034d0 	.word	0x8f6034d0
8f6032d8:	8f6034d0 	.word	0x8f6034d0
8f6032dc:	8f6034d0 	.word	0x8f6034d0
8f6032e0:	8f6034d0 	.word	0x8f6034d0
8f6032e4:	8f6034d0 	.word	0x8f6034d0
8f6032e8:	8f6034d0 	.word	0x8f6034d0
8f6032ec:	8f6034d0 	.word	0x8f6034d0
8f6032f0:	8f6034d0 	.word	0x8f6034d0
8f6032f4:	8f6034d0 	.word	0x8f6034d0
8f6032f8:	8f6034d0 	.word	0x8f6034d0
8f6032fc:	8f6034d0 	.word	0x8f6034d0
8f603300:	8f6034d0 	.word	0x8f6034d0
8f603304:	8f6034d0 	.word	0x8f6034d0
8f603308:	8f6034d0 	.word	0x8f6034d0
8f60330c:	8f6034d0 	.word	0x8f6034d0
8f603310:	8f6034d0 	.word	0x8f6034d0
8f603314:	8f6034d0 	.word	0x8f6034d0
8f603318:	8f6034d0 	.word	0x8f6034d0
8f60331c:	8f6034d0 	.word	0x8f6034d0
8f603320:	8f6034d0 	.word	0x8f6034d0
8f603324:	8f6034d0 	.word	0x8f6034d0
8f603328:	8f6034d0 	.word	0x8f6034d0
8f60332c:	8f6034d0 	.word	0x8f6034d0
8f603330:	8f6034d0 	.word	0x8f6034d0
8f603334:	8f6034d0 	.word	0x8f6034d0
8f603338:	8f6034d0 	.word	0x8f6034d0
8f60333c:	8f6034d0 	.word	0x8f6034d0
8f603340:	8f6034d0 	.word	0x8f6034d0
8f603344:	8f6034d0 	.word	0x8f6034d0
8f603348:	8f6034d0 	.word	0x8f6034d0
8f60334c:	8f6034d0 	.word	0x8f6034d0
8f603350:	8f6034d0 	.word	0x8f6034d0
8f603354:	8f6034d0 	.word	0x8f6034d0
8f603358:	8f6034d0 	.word	0x8f6034d0
8f60335c:	8f6034d0 	.word	0x8f6034d0
8f603360:	8f6034d0 	.word	0x8f6034d0
8f603364:	8f6034d0 	.word	0x8f6034d0
8f603368:	8f6034d0 	.word	0x8f6034d0
8f60336c:	8f6034d0 	.word	0x8f6034d0
8f603370:	8f6034d0 	.word	0x8f6034d0
8f603374:	8f6034d0 	.word	0x8f6034d0
8f603378:	8f6034d0 	.word	0x8f6034d0
8f60337c:	8f6034d0 	.word	0x8f6034d0
8f603380:	8f6034d0 	.word	0x8f6034d0
8f603384:	8f6034d0 	.word	0x8f6034d0
8f603388:	8f6034d0 	.word	0x8f6034d0
8f60338c:	8f6034d0 	.word	0x8f6034d0
8f603390:	8f6034d0 	.word	0x8f6034d0
8f603394:	8f6034d0 	.word	0x8f6034d0
8f603398:	8f6034d0 	.word	0x8f6034d0
8f60339c:	8f60362c 	.word	0x8f60362c
8f6033a0:	8f6035cc 	.word	0x8f6035cc
8f6033a4:	8f6035f8 	.word	0x8f6035f8
8f6033a8:	8f603658 	.word	0x8f603658
8f6033ac:	8f6034d0 	.word	0x8f6034d0
8f6033b0:	8f603540 	.word	0x8f603540
8f6033b4:	8f603574 	.word	0x8f603574
8f6033b8:	8f6035a0 	.word	0x8f6035a0
8f6033bc:	8f603704 	.word	0x8f603704
8f6033c0:	8f603730 	.word	0x8f603730
8f6033c4:	8f6034d0 	.word	0x8f6034d0
8f6033c8:	8f6034d0 	.word	0x8f6034d0
8f6033cc:	8f60375c 	.word	0x8f60375c
8f6033d0:	8f6034d0 	.word	0x8f6034d0
8f6033d4:	8f6034d0 	.word	0x8f6034d0
8f6033d8:	8f6034d0 	.word	0x8f6034d0
8f6033dc:	8f6034d0 	.word	0x8f6034d0
8f6033e0:	8f6034d0 	.word	0x8f6034d0
8f6033e4:	8f6034d0 	.word	0x8f6034d0
8f6033e8:	8f6034d0 	.word	0x8f6034d0
8f6033ec:	8f6034d0 	.word	0x8f6034d0
8f6033f0:	8f6034d0 	.word	0x8f6034d0
8f6033f4:	8f6034d0 	.word	0x8f6034d0
8f6033f8:	8f6034d0 	.word	0x8f6034d0
8f6033fc:	8f6036b0 	.word	0x8f6036b0
8f603400:	8f6034d0 	.word	0x8f6034d0
8f603404:	8f6034d0 	.word	0x8f6034d0
8f603408:	8f6036d8 	.word	0x8f6036d8
8f60340c:	8f6034d0 	.word	0x8f6034d0
8f603410:	8f6034d0 	.word	0x8f6034d0
8f603414:	8f603684 	.word	0x8f603684
8f603418:	8f6034d0 	.word	0x8f6034d0
8f60341c:	8f6034d0 	.word	0x8f6034d0
8f603420:	8f6034d0 	.word	0x8f6034d0
8f603424:	8f6034d0 	.word	0x8f6034d0
8f603428:	8f6034d0 	.word	0x8f6034d0
8f60342c:	8f6034d0 	.word	0x8f6034d0
8f603430:	8f6034d0 	.word	0x8f6034d0
8f603434:	8f6034d0 	.word	0x8f6034d0
8f603438:	8f6034d0 	.word	0x8f6034d0
8f60343c:	8f6034d0 	.word	0x8f6034d0
8f603440:	8f6034d0 	.word	0x8f6034d0
8f603444:	8f6034d0 	.word	0x8f6034d0
8f603448:	8f6034d0 	.word	0x8f6034d0
8f60344c:	8f6034d0 	.word	0x8f6034d0
8f603450:	8f6034d0 	.word	0x8f6034d0
8f603454:	8f6034d0 	.word	0x8f6034d0
8f603458:	8f6034d0 	.word	0x8f6034d0
8f60345c:	8f6034d0 	.word	0x8f6034d0
8f603460:	8f6034d0 	.word	0x8f6034d0
8f603464:	8f6034d0 	.word	0x8f6034d0
8f603468:	8f6034d0 	.word	0x8f6034d0
8f60346c:	8f6034d0 	.word	0x8f6034d0
8f603470:	8f6034d0 	.word	0x8f6034d0
8f603474:	8f6034d0 	.word	0x8f6034d0
8f603478:	8f6034d0 	.word	0x8f6034d0
8f60347c:	8f6034d0 	.word	0x8f6034d0
8f603480:	8f6034d0 	.word	0x8f6034d0
8f603484:	8f6034d0 	.word	0x8f6034d0
8f603488:	8f6034d0 	.word	0x8f6034d0
8f60348c:	8f6034d0 	.word	0x8f6034d0
8f603490:	8f6034d0 	.word	0x8f6034d0
8f603494:	8f603498 	.word	0x8f603498
		break;
	case MBR_EFS2_TYPE:
		memcpy(partition_ent->name, "efs2", 4);
		break;
	case MBR_USERDATA_TYPE:
		if (ext3_count == sizeof(ext3_partitions) / sizeof(char *))
8f603498:	e30b5d7c 	movw	r5, #48508	; 0xbd7c
8f60349c:	e3485f72 	movt	r5, #36722	; 0x8f72
8f6034a0:	e5953000 	ldr	r3, [r5]
8f6034a4:	e3530005 	cmp	r3, #5
8f6034a8:	0a000008 	beq	8f6034d0 <mbr_fill_name+0x25c>
			return;
		strlcpy((char *)partition_ent->name,
			(const char *)ext3_partitions[ext3_count],
8f6034ac:	e30112bc 	movw	r1, #4796	; 0x12bc
8f6034b0:	e3481f71 	movt	r1, #36721	; 0x8f71
		strlcpy((char *)partition_ent->name,
8f6034b4:	e2800048 	add	r0, r0, #72	; 0x48
8f6034b8:	e3a02048 	mov	r2, #72	; 0x48
8f6034bc:	e7911103 	ldr	r1, [r1, r3, lsl #2]
8f6034c0:	eb00c49a 	bl	8f634730 <strlcpy>
			sizeof(partition_ent->name));
		ext3_count++;
8f6034c4:	e5953000 	ldr	r3, [r5]
8f6034c8:	e2833001 	add	r3, r3, #1
8f6034cc:	e5853000 	str	r3, [r5]
		break;
	case MBR_SSD_TYPE:
		memcpy(partition_ent->name, "ssd", 3);
		break;
	};
}
8f6034d0:	e59f32b0 	ldr	r3, [pc, #688]	; 8f603788 <mbr_fill_name+0x514>
8f6034d4:	e5932000 	ldr	r2, [r3]
8f6034d8:	e59d3004 	ldr	r3, [r13, #4]
8f6034dc:	e0332002 	eors	r2, r3, r2
8f6034e0:	e3a03000 	mov	r3, #0
8f6034e4:	1a00002c 	bne	8f60359c <mbr_fill_name+0x328>
8f6034e8:	e28dd008 	add	r13, r13, #8
8f6034ec:	e8bd8070 	pop	{r4, r5, r6, r15}
		if (!strcmp((const char *)vfat_partitions[vfat_count], "NONE"))
8f6034f0:	e30b5d90 	movw	r5, #48528	; 0xbd90
8f6034f4:	e3485f72 	movt	r5, #36722	; 0x8f72
8f6034f8:	e30132d0 	movw	r3, #4816	; 0x12d0
8f6034fc:	e3483f71 	movt	r3, #36721	; 0x8f71
8f603500:	e5952000 	ldr	r2, [r5]
8f603504:	e3001ce4 	movw	r1, #3300	; 0xce4
8f603508:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60350c:	e7936102 	ldr	r6, [r3, r2, lsl #2]
8f603510:	e1a00006 	mov	r0, r6
8f603514:	eb00c402 	bl	8f634524 <strcmp>
8f603518:	e3500000 	cmp	r0, #0
8f60351c:	0affffeb 	beq	8f6034d0 <mbr_fill_name+0x25c>
		strlcpy((char *)partition_ent->name,
8f603520:	e2840048 	add	r0, r4, #72	; 0x48
8f603524:	e3a02048 	mov	r2, #72	; 0x48
8f603528:	e1a01006 	mov	r1, r6
8f60352c:	eb00c47f 	bl	8f634730 <strlcpy>
		vfat_count++;
8f603530:	e5953000 	ldr	r3, [r5]
8f603534:	e2833001 	add	r3, r3, #1
8f603538:	e5853000 	str	r3, [r5]
		break;
8f60353c:	eaffffe3 	b	8f6034d0 <mbr_fill_name+0x25c>
		memcpy(partition_ent->name, "modem_st1", 9);
8f603540:	e59f3240 	ldr	r3, [pc, #576]	; 8f603788 <mbr_fill_name+0x514>
8f603544:	e5932000 	ldr	r2, [r3]
8f603548:	e59d3004 	ldr	r3, [r13, #4]
8f60354c:	e0332002 	eors	r2, r3, r2
8f603550:	e3a03000 	mov	r3, #0
8f603554:	02800048 	addeq	r0, r0, #72	; 0x48
8f603558:	03001d14 	movweq	r1, #3348	; 0xd14
8f60355c:	03a02009 	moveq	r2, #9
8f603560:	03481f70 	movteq	r1, #36720	; 0x8f70
8f603564:	1a00000c 	bne	8f60359c <mbr_fill_name+0x328>
}
8f603568:	e28dd008 	add	r13, r13, #8
8f60356c:	e8bd4070 	pop	{r4, r5, r6, r14}
		memcpy(partition_ent->name, "ssd", 3);
8f603570:	ea00c310 	b	8f6341b8 <memcpy>
		memcpy(partition_ent->name, "modem_st2", 9);
8f603574:	e59f320c 	ldr	r3, [pc, #524]	; 8f603788 <mbr_fill_name+0x514>
8f603578:	e5932000 	ldr	r2, [r3]
8f60357c:	e59d3004 	ldr	r3, [r13, #4]
8f603580:	e0332002 	eors	r2, r3, r2
8f603584:	e3a03000 	mov	r3, #0
8f603588:	02800048 	addeq	r0, r0, #72	; 0x48
8f60358c:	03001d20 	movweq	r1, #3360	; 0xd20
8f603590:	03a02009 	moveq	r2, #9
8f603594:	03481f70 	movteq	r1, #36720	; 0x8f70
8f603598:	0afffff2 	beq	8f603568 <mbr_fill_name+0x2f4>
}
8f60359c:	eb00bd87 	bl	8f632bc0 <__stack_chk_fail>
		memcpy(partition_ent->name, "aboot", 5);
8f6035a0:	e59f31e0 	ldr	r3, [pc, #480]	; 8f603788 <mbr_fill_name+0x514>
8f6035a4:	e5932000 	ldr	r2, [r3]
8f6035a8:	e59d3004 	ldr	r3, [r13, #4]
8f6035ac:	e0332002 	eors	r2, r3, r2
8f6035b0:	e3a03000 	mov	r3, #0
8f6035b4:	02800048 	addeq	r0, r0, #72	; 0x48
8f6035b8:	03001d0c 	movweq	r1, #3340	; 0xd0c
8f6035bc:	03a02005 	moveq	r2, #5
8f6035c0:	03481f70 	movteq	r1, #36720	; 0x8f70
8f6035c4:	0affffe7 	beq	8f603568 <mbr_fill_name+0x2f4>
8f6035c8:	eafffff3 	b	8f60359c <mbr_fill_name+0x328>
		memcpy(partition_ent->name, "tz", 2);
8f6035cc:	e59f31b4 	ldr	r3, [pc, #436]	; 8f603788 <mbr_fill_name+0x514>
8f6035d0:	e5932000 	ldr	r2, [r3]
8f6035d4:	e59d3004 	ldr	r3, [r13, #4]
8f6035d8:	e0332002 	eors	r2, r3, r2
8f6035dc:	e3a03000 	mov	r3, #0
8f6035e0:	02800048 	addeq	r0, r0, #72	; 0x48
8f6035e4:	03001d08 	movweq	r1, #3336	; 0xd08
8f6035e8:	03a02002 	moveq	r2, #2
8f6035ec:	03481f70 	movteq	r1, #36720	; 0x8f70
8f6035f0:	0affffdc 	beq	8f603568 <mbr_fill_name+0x2f4>
8f6035f4:	eaffffe8 	b	8f60359c <mbr_fill_name+0x328>
		memcpy(partition_ent->name, "rpm", 3);
8f6035f8:	e59f3188 	ldr	r3, [pc, #392]	; 8f603788 <mbr_fill_name+0x514>
8f6035fc:	e5932000 	ldr	r2, [r3]
8f603600:	e59d3004 	ldr	r3, [r13, #4]
8f603604:	e0332002 	eors	r2, r3, r2
8f603608:	e3a03000 	mov	r3, #0
8f60360c:	02800048 	addeq	r0, r0, #72	; 0x48
8f603610:	03001d04 	movweq	r1, #3332	; 0xd04
8f603614:	03481f70 	movteq	r1, #36720	; 0x8f70
8f603618:	1affffdf 	bne	8f60359c <mbr_fill_name+0x328>
		memcpy(partition_ent->name, "ssd", 3);
8f60361c:	e3a02003 	mov	r2, #3
}
8f603620:	e28dd008 	add	r13, r13, #8
8f603624:	e8bd4070 	pop	{r4, r5, r6, r14}
		memcpy(partition_ent->name, "ssd", 3);
8f603628:	ea00c2e2 	b	8f6341b8 <memcpy>
		memcpy(partition_ent->name, "sbl3", 4);
8f60362c:	e59f3154 	ldr	r3, [pc, #340]	; 8f603788 <mbr_fill_name+0x514>
8f603630:	e5932000 	ldr	r2, [r3]
8f603634:	e59d3004 	ldr	r3, [r13, #4]
8f603638:	e0332002 	eors	r2, r3, r2
8f60363c:	e3a03000 	mov	r3, #0
8f603640:	02800048 	addeq	r0, r0, #72	; 0x48
8f603644:	03001cfc 	movweq	r1, #3324	; 0xcfc
8f603648:	03a02004 	moveq	r2, #4
8f60364c:	03481f70 	movteq	r1, #36720	; 0x8f70
8f603650:	0affffc4 	beq	8f603568 <mbr_fill_name+0x2f4>
8f603654:	eaffffd0 	b	8f60359c <mbr_fill_name+0x328>
		memcpy(partition_ent->name, "boot", 4);
8f603658:	e59f3128 	ldr	r3, [pc, #296]	; 8f603788 <mbr_fill_name+0x514>
8f60365c:	e5932000 	ldr	r2, [r3]
8f603660:	e59d3004 	ldr	r3, [r13, #4]
8f603664:	e0332002 	eors	r2, r3, r2
8f603668:	e3a03000 	mov	r3, #0
8f60366c:	02800048 	addeq	r0, r0, #72	; 0x48
8f603670:	030a1370 	movweq	r1, #41840	; 0xa370
8f603674:	03a02004 	moveq	r2, #4
8f603678:	03481f70 	movteq	r1, #36720	; 0x8f70
8f60367c:	0affffb9 	beq	8f603568 <mbr_fill_name+0x2f4>
8f603680:	eaffffc5 	b	8f60359c <mbr_fill_name+0x328>
		memcpy(partition_ent->name, "misc", 4);
8f603684:	e59f30fc 	ldr	r3, [pc, #252]	; 8f603788 <mbr_fill_name+0x514>
8f603688:	e5932000 	ldr	r2, [r3]
8f60368c:	e59d3004 	ldr	r3, [r13, #4]
8f603690:	e0332002 	eors	r2, r3, r2
8f603694:	e3a03000 	mov	r3, #0
8f603698:	02800048 	addeq	r0, r0, #72	; 0x48
8f60369c:	03001d40 	movweq	r1, #3392	; 0xd40
8f6036a0:	03a02004 	moveq	r2, #4
8f6036a4:	03481f70 	movteq	r1, #36720	; 0x8f70
8f6036a8:	0affffae 	beq	8f603568 <mbr_fill_name+0x2f4>
8f6036ac:	eaffffba 	b	8f60359c <mbr_fill_name+0x328>
		memcpy(partition_ent->name, "ssd", 3);
8f6036b0:	e59f30d0 	ldr	r3, [pc, #208]	; 8f603788 <mbr_fill_name+0x514>
8f6036b4:	e5932000 	ldr	r2, [r3]
8f6036b8:	e59d3004 	ldr	r3, [r13, #4]
8f6036bc:	e0332002 	eors	r2, r3, r2
8f6036c0:	e3a03000 	mov	r3, #0
8f6036c4:	02800048 	addeq	r0, r0, #72	; 0x48
8f6036c8:	03001020 	movweq	r1, #32
8f6036cc:	03481f70 	movteq	r1, #36720	; 0x8f70
8f6036d0:	0affffd1 	beq	8f60361c <mbr_fill_name+0x3a8>
8f6036d4:	eaffffb0 	b	8f60359c <mbr_fill_name+0x328>
		memcpy(partition_ent->name, "recovery", 8);
8f6036d8:	e59f30a8 	ldr	r3, [pc, #168]	; 8f603788 <mbr_fill_name+0x514>
8f6036dc:	e5932000 	ldr	r2, [r3]
8f6036e0:	e59d3004 	ldr	r3, [r13, #4]
8f6036e4:	e0332002 	eors	r2, r3, r2
8f6036e8:	e3a03000 	mov	r3, #0
8f6036ec:	02800048 	addeq	r0, r0, #72	; 0x48
8f6036f0:	03001d34 	movweq	r1, #3380	; 0xd34
8f6036f4:	03a02008 	moveq	r2, #8
8f6036f8:	03481f70 	movteq	r1, #36720	; 0x8f70
8f6036fc:	0affff99 	beq	8f603568 <mbr_fill_name+0x2f4>
8f603700:	eaffffa5 	b	8f60359c <mbr_fill_name+0x328>
		memcpy(partition_ent->name, "sbl1", 4);
8f603704:	e59f307c 	ldr	r3, [pc, #124]	; 8f603788 <mbr_fill_name+0x514>
8f603708:	e5932000 	ldr	r2, [r3]
8f60370c:	e59d3004 	ldr	r3, [r13, #4]
8f603710:	e0332002 	eors	r2, r3, r2
8f603714:	e3a03000 	mov	r3, #0
8f603718:	02800048 	addeq	r0, r0, #72	; 0x48
8f60371c:	03001cec 	movweq	r1, #3308	; 0xcec
8f603720:	03a02004 	moveq	r2, #4
8f603724:	03481f70 	movteq	r1, #36720	; 0x8f70
8f603728:	0affff8e 	beq	8f603568 <mbr_fill_name+0x2f4>
8f60372c:	eaffff9a 	b	8f60359c <mbr_fill_name+0x328>
		memcpy(partition_ent->name, "efs2", 4);
8f603730:	e59f3050 	ldr	r3, [pc, #80]	; 8f603788 <mbr_fill_name+0x514>
8f603734:	e5932000 	ldr	r2, [r3]
8f603738:	e59d3004 	ldr	r3, [r13, #4]
8f60373c:	e0332002 	eors	r2, r3, r2
8f603740:	e3a03000 	mov	r3, #0
8f603744:	02800048 	addeq	r0, r0, #72	; 0x48
8f603748:	03001d2c 	movweq	r1, #3372	; 0xd2c
8f60374c:	03a02004 	moveq	r2, #4
8f603750:	03481f70 	movteq	r1, #36720	; 0x8f70
8f603754:	0affff83 	beq	8f603568 <mbr_fill_name+0x2f4>
8f603758:	eaffff8f 	b	8f60359c <mbr_fill_name+0x328>
		memcpy(partition_ent->name, "sbl2", 4);
8f60375c:	e59f3024 	ldr	r3, [pc, #36]	; 8f603788 <mbr_fill_name+0x514>
8f603760:	e5932000 	ldr	r2, [r3]
8f603764:	e59d3004 	ldr	r3, [r13, #4]
8f603768:	e0332002 	eors	r2, r3, r2
8f60376c:	e3a03000 	mov	r3, #0
8f603770:	02800048 	addeq	r0, r0, #72	; 0x48
8f603774:	03001cf4 	movweq	r1, #3316	; 0xcf4
8f603778:	03a02004 	moveq	r2, #4
8f60377c:	03481f70 	movteq	r1, #36720	; 0x8f70
8f603780:	0affff78 	beq	8f603568 <mbr_fill_name+0x2f4>
8f603784:	eaffff84 	b	8f60359c <mbr_fill_name+0x328>
8f603788:	8f74221c 	.word	0x8f74221c

8f60378c <partition_parse_gpt_header>:
partition_parse_gpt_header(unsigned char *buffer,
			   unsigned long long *first_usable_lba,
			   unsigned int *partition_entry_size,
			   unsigned int *header_size,
			   unsigned int *max_partition_count)
{
8f60378c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f603790:	e1a05003 	mov	r5, r3
8f603794:	e24dd024 	sub	r13, r13, #36	; 0x24
8f603798:	e59f33f4 	ldr	r3, [pc, #1012]	; 8f603b94 <partition_parse_gpt_header+0x408>
8f60379c:	e1a0b002 	mov	r11, r2
8f6037a0:	e1a04000 	mov	r4, r0
8f6037a4:	e5933000 	ldr	r3, [r3]
8f6037a8:	e58d301c 	str	r3, [r13, #28]
8f6037ac:	e3a03000 	mov	r3, #0
8f6037b0:	e1a07001 	mov	r7, r1
8f6037b4:	e59da048 	ldr	r10, [r13, #72]	; 0x48
	uint32_t partitions_for_block = 0;
	uint32_t blocks_to_read = 0;
	unsigned long long last_usable_lba = 0;
	unsigned long long partition_0 = 0;
	unsigned long long current_lba = 0;
	uint32_t block_size = mmc_get_device_blocksize();
8f6037b8:	eb0026ef 	bl	8f60d37c <mmc_get_device_blocksize>
8f6037bc:	e1a06000 	mov	r6, r0
	uint32_t blocks_for_entries =
			(NUM_PARTITIONS * PARTITION_ENTRY_SIZE)/ block_size;
	/* Get the density of the mmc device */
	uint64_t device_density = mmc_get_device_capacity();
8f6037c0:	eb0026d5 	bl	8f60d31c <mmc_get_device_capacity>

	/* Check GPT Signature */
	if (((uint32_t *) buffer)[0] != GPT_SIGNATURE_2 ||
8f6037c4:	e5942000 	ldr	r2, [r4]
8f6037c8:	e3043645 	movw	r3, #17989	; 0x4645
8f6037cc:	e3423049 	movt	r3, #8265	; 0x2049
8f6037d0:	e1520003 	cmp	r2, r3
8f6037d4:	1a000004 	bne	8f6037ec <partition_parse_gpt_header+0x60>
8f6037d8:	e5942004 	ldr	r2, [r4, #4]
8f6037dc:	e3043150 	movw	r3, #16720	; 0x4150
8f6037e0:	e3453452 	movt	r3, #21586	; 0x5452
8f6037e4:	e1520003 	cmp	r2, r3
8f6037e8:	0a000009 	beq	8f603814 <partition_parse_gpt_header+0x88>
	    ((uint32_t *) buffer)[1] != GPT_SIGNATURE_1)
		return 1;
8f6037ec:	e3a05001 	mov	r5, #1
fail:
	free(new_buffer);
	new_buffer = NULL;

	return ret;
}
8f6037f0:	e59f339c 	ldr	r3, [pc, #924]	; 8f603b94 <partition_parse_gpt_header+0x408>
8f6037f4:	e5932000 	ldr	r2, [r3]
8f6037f8:	e59d301c 	ldr	r3, [r13, #28]
8f6037fc:	e0332002 	eors	r2, r3, r2
8f603800:	e3a03000 	mov	r3, #0
8f603804:	1a0000dc 	bne	8f603b7c <partition_parse_gpt_header+0x3f0>
8f603808:	e1a00005 	mov	r0, r5
8f60380c:	e28dd024 	add	r13, r13, #36	; 0x24
8f603810:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	*header_size = GET_LWORD_FROM_BYTE(&buffer[HEADER_SIZE_OFFSET]);
8f603814:	e594300c 	ldr	r3, [r4, #12]
	if (*header_size < GPT_HEADER_SIZE) {
8f603818:	e353005b 	cmp	r3, #91	; 0x5b
	*header_size = GET_LWORD_FROM_BYTE(&buffer[HEADER_SIZE_OFFSET]);
8f60381c:	e5853000 	str	r3, [r5]
	if (*header_size < GPT_HEADER_SIZE) {
8f603820:	9a000070 	bls	8f6039e8 <partition_parse_gpt_header+0x25c>
	if (*header_size > block_size) {
8f603824:	e1530006 	cmp	r3, r6
8f603828:	8a000073 	bhi	8f6039fc <partition_parse_gpt_header+0x270>
	crc_val_org = GET_LWORD_FROM_BYTE(&buffer[HEADER_CRC_OFFSET]);
8f60382c:	e5943010 	ldr	r3, [r4, #16]
8f603830:	e1a09000 	mov	r9, r0
8f603834:	e1a08001 	mov	r8, r1
	crc_val  = crc32(~0L,buffer, *header_size) ^ (~0L);
8f603838:	e3e00000 	mvn	r0, #0
8f60383c:	e1a01004 	mov	r1, r4
	crc_val_org = GET_LWORD_FROM_BYTE(&buffer[HEADER_CRC_OFFSET]);
8f603840:	e58d3004 	str	r3, [r13, #4]
	PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
8f603844:	e3a03000 	mov	r3, #0
8f603848:	e5c43010 	strb	r3, [r4, #16]
8f60384c:	e5c43011 	strb	r3, [r4, #17]
8f603850:	e5c43012 	strb	r3, [r4, #18]
8f603854:	e5c43013 	strb	r3, [r4, #19]
	crc_val  = crc32(~0L,buffer, *header_size) ^ (~0L);
8f603858:	e5952000 	ldr	r2, [r5]
8f60385c:	eb000f68 	bl	8f607604 <crc32>
	if (crc_val != crc_val_org) {
8f603860:	e59d3004 	ldr	r3, [r13, #4]
	crc_val  = crc32(~0L,buffer, *header_size) ^ (~0L);
8f603864:	e1e01000 	mvn	r1, r0
	if (crc_val != crc_val_org) {
8f603868:	e1530001 	cmp	r3, r1
8f60386c:	1a00007c 	bne	8f603a64 <partition_parse_gpt_header+0x2d8>
	    GET_LLWORD_FROM_BYTE(&buffer[FIRST_USABLE_LBA_OFFSET]);
8f603870:	e5941028 	ldr	r1, [r4, #40]	; 0x28
		PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
8f603874:	e1a02423 	lsr	r2, r3, #8
	    GET_LLWORD_FROM_BYTE(&buffer[FIRST_USABLE_LBA_OFFSET]);
8f603878:	e594002c 	ldr	r0, [r4, #44]	; 0x2c
	if (!parse_secondary_gpt) {
8f60387c:	e30b5d88 	movw	r5, #48520	; 0xbd88
	current_lba =
8f603880:	e594c018 	ldr	r12, [r4, #24]
	if (!parse_secondary_gpt) {
8f603884:	e3485f72 	movt	r5, #36722	; 0x8f72
	current_lba =
8f603888:	e594e01c 	ldr	r14, [r4, #28]
		PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
8f60388c:	e5c43010 	strb	r3, [r4, #16]
8f603890:	e5c42011 	strb	r2, [r4, #17]
8f603894:	e1a02823 	lsr	r2, r3, #16
8f603898:	e1a03c23 	lsr	r3, r3, #24
8f60389c:	e5c42012 	strb	r2, [r4, #18]
8f6038a0:	e5c43013 	strb	r3, [r4, #19]
	*first_usable_lba =
8f6038a4:	e5871000 	str	r1, [r7]
8f6038a8:	e5870004 	str	r0, [r7, #4]
	    GET_LWORD_FROM_BYTE(&buffer[PARTITION_COUNT_OFFSET]);
8f6038ac:	e5942050 	ldr	r2, [r4, #80]	; 0x50
	    GET_LLWORD_FROM_BYTE(&buffer[FIRST_USABLE_LBA_OFFSET]);
8f6038b0:	e58d1004 	str	r1, [r13, #4]
8f6038b4:	e58d0008 	str	r0, [r13, #8]
	*max_partition_count =
8f6038b8:	e58a2000 	str	r2, [r10]
	if (!parse_secondary_gpt) {
8f6038bc:	e5952000 	ldr	r2, [r5]
	    GET_LWORD_FROM_BYTE(&buffer[PENTRY_SIZE_OFFSET]);
8f6038c0:	e5947054 	ldr	r7, [r4, #84]	; 0x54
	if (!parse_secondary_gpt) {
8f6038c4:	e3520000 	cmp	r2, #0
	current_lba =
8f6038c8:	e58dc00c 	str	r12, [r13, #12]
8f6038cc:	e58de010 	str	r14, [r13, #16]
	*partition_entry_size =
8f6038d0:	e58b7000 	str	r7, [r11]
	if (!parse_secondary_gpt) {
8f6038d4:	1a00004d 	bne	8f603a10 <partition_parse_gpt_header+0x284>
		if (current_lba != GPT_LBA) {
8f6038d8:	e24c3001 	sub	r3, r12, #1
8f6038dc:	e193300e 	orrs	r3, r3, r14
8f6038e0:	1a000065 	bne	8f603a7c <partition_parse_gpt_header+0x2f0>
		if (!flashing_gpt && (current_lba != ((device_density/block_size) - 1)))
8f6038e4:	e1a03002 	mov	r3, r2
8f6038e8:	e1a00009 	mov	r0, r9
8f6038ec:	e1a01008 	mov	r1, r8
8f6038f0:	e58d2014 	str	r2, [r13, #20]
8f6038f4:	e1a02006 	mov	r2, r6
8f6038f8:	fa00e629 	blx	8f63d1a4 <__aeabi_uldivmod>
8f6038fc:	e1a08000 	mov	r8, r0
8f603900:	e1a09001 	mov	r9, r1
	if (*first_usable_lba > (device_density/block_size)) {
8f603904:	e59d3004 	ldr	r3, [r13, #4]
8f603908:	e1580003 	cmp	r8, r3
8f60390c:	e59d3008 	ldr	r3, [r13, #8]
8f603910:	e0d93003 	sbcs	r3, r9, r3
8f603914:	3a000062 	bcc	8f603aa4 <partition_parse_gpt_header+0x318>
	last_usable_lba =
8f603918:	e5943030 	ldr	r3, [r4, #48]	; 0x30
	if (last_usable_lba > (device_density/block_size)) {
8f60391c:	e1580003 	cmp	r8, r3
	last_usable_lba =
8f603920:	e5943034 	ldr	r3, [r4, #52]	; 0x34
	if (last_usable_lba > (device_density/block_size)) {
8f603924:	e0d93003 	sbcs	r3, r9, r3
8f603928:	3a000062 	bcc	8f603ab8 <partition_parse_gpt_header+0x32c>
	if (*partition_entry_size != PARTITION_ENTRY_SIZE) {
8f60392c:	e3570080 	cmp	r7, #128	; 0x80
8f603930:	1a000056 	bne	8f603a90 <partition_parse_gpt_header+0x304>
	if ((*max_partition_count) > (MIN_PARTITION_ARRAY_SIZE /(*partition_entry_size))) {
8f603934:	e59a0000 	ldr	r0, [r10]
8f603938:	e3500080 	cmp	r0, #128	; 0x80
8f60393c:	8a000074 	bhi	8f603b14 <partition_parse_gpt_header+0x388>
	blocks_to_read = (*max_partition_count)/ partitions_for_block;
8f603940:	e1a013a6 	lsr	r1, r6, #7
	new_buffer = (uint8_t *)memalign(CACHE_LINE, ROUNDUP((blocks_to_read * block_size),CACHE_LINE));
8f603944:	e30b7d84 	movw	r7, #48516	; 0xbd84
8f603948:	fa00e539 	blx	8f63ce34 <__aeabi_uidivmod>
8f60394c:	e3487f72 	movt	r7, #36722	; 0x8f72
	if ((*max_partition_count) % partitions_for_block) {
8f603950:	e3510000 	cmp	r1, #0
		blocks_to_read += 1;
8f603954:	12800001 	addne	r0, r0, #1
	new_buffer = (uint8_t *)memalign(CACHE_LINE, ROUNDUP((blocks_to_read * block_size),CACHE_LINE));
8f603958:	e0030096 	mul	r3, r6, r0
8f60395c:	e3a00040 	mov	r0, #64	; 0x40
8f603960:	e283103f 	add	r1, r3, #63	; 0x3f
8f603964:	e3c1103f 	bic	r1, r1, #63	; 0x3f
8f603968:	e58d3004 	str	r3, [r13, #4]
8f60396c:	eb00c1b4 	bl	8f634044 <memalign>
	if (!new_buffer)
8f603970:	e59d3004 	ldr	r3, [r13, #4]
8f603974:	e3500000 	cmp	r0, #0
	new_buffer = (uint8_t *)memalign(CACHE_LINE, ROUNDUP((blocks_to_read * block_size),CACHE_LINE));
8f603978:	e58d0008 	str	r0, [r13, #8]
8f60397c:	e5870000 	str	r0, [r7]
	if (!new_buffer)
8f603980:	0a00007e 	beq	8f603b80 <partition_parse_gpt_header+0x3f4>
		if (!parse_secondary_gpt)
8f603984:	e5952000 	ldr	r2, [r5]
		partition_0 = GET_LLWORD_FROM_BYTE(&buffer[PARTITION_ENTRIES_OFFSET]);
8f603988:	e5945048 	ldr	r5, [r4, #72]	; 0x48
		if (!parse_secondary_gpt)
8f60398c:	e3520000 	cmp	r2, #0
		partition_0 = GET_LLWORD_FROM_BYTE(&buffer[PARTITION_ENTRIES_OFFSET]);
8f603990:	e594204c 	ldr	r2, [r4, #76]	; 0x4c
		if (!parse_secondary_gpt)
8f603994:	1a00004c 	bne	8f603acc <partition_parse_gpt_header+0x340>
			if (partition_0 != 0x2)
8f603998:	e2451002 	sub	r1, r5, #2
8f60399c:	e1911002 	orrs	r1, r1, r2
8f6039a0:	1a000070 	bne	8f603b68 <partition_parse_gpt_header+0x3dc>
		ret = mmc_read((partition_0) * (block_size), (unsigned int *)new_buffer, (blocks_to_read * block_size));
8f6039a4:	e59d1014 	ldr	r1, [r13, #20]
8f6039a8:	e0010195 	mul	r1, r5, r1
8f6039ac:	e0211296 	mla	r1, r6, r2, r1
8f6039b0:	e59d2008 	ldr	r2, [r13, #8]
8f6039b4:	e0860695 	umull	r0, r6, r5, r6
8f6039b8:	e0811006 	add	r1, r1, r6
8f6039bc:	eb0024b1 	bl	8f60cc88 <mmc_read>
		if (ret)
8f6039c0:	e2505000 	subs	r5, r0, #0
8f6039c4:	0a000057 	beq	8f603b28 <partition_parse_gpt_header+0x39c>
			dprintf(CRITICAL, "GPT: Could not read primary gpt from mmc\n");
8f6039c8:	e3000f0c 	movw	r0, #3852	; 0xf0c
8f6039cc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6039d0:	eb00bbe7 	bl	8f632974 <_dprintf>
	free(new_buffer);
8f6039d4:	e5970000 	ldr	r0, [r7]
8f6039d8:	eb00c1cb 	bl	8f63410c <free>
	new_buffer = NULL;
8f6039dc:	e3a03000 	mov	r3, #0
8f6039e0:	e5873000 	str	r3, [r7]
	return ret;
8f6039e4:	eaffff81 	b	8f6037f0 <partition_parse_gpt_header+0x64>
		dprintf(CRITICAL,"GPT Header size is too small\n");
8f6039e8:	e3000d48 	movw	r0, #3400	; 0xd48
8f6039ec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6039f0:	eb00bbdf 	bl	8f632974 <_dprintf>
		return 1;
8f6039f4:	e3a05001 	mov	r5, #1
8f6039f8:	eaffff7c 	b	8f6037f0 <partition_parse_gpt_header+0x64>
		dprintf(CRITICAL,"GPT Header size is too large\n");
8f6039fc:	e3000d68 	movw	r0, #3432	; 0xd68
8f603a00:	e3480f70 	movt	r0, #36720	; 0x8f70
8f603a04:	eb00bbda 	bl	8f632974 <_dprintf>
		return 1;
8f603a08:	e3a05001 	mov	r5, #1
8f603a0c:	eaffff77 	b	8f6037f0 <partition_parse_gpt_header+0x64>
		if (!flashing_gpt && (current_lba != ((device_density/block_size) - 1)))
8f603a10:	e1a00009 	mov	r0, r9
8f603a14:	e1a01008 	mov	r1, r8
8f603a18:	e1a02006 	mov	r2, r6
8f603a1c:	e3a03000 	mov	r3, #0
8f603a20:	fa00e5df 	blx	8f63d1a4 <__aeabi_uldivmod>
8f603a24:	e3a03000 	mov	r3, #0
8f603a28:	e58d3014 	str	r3, [r13, #20]
8f603a2c:	e2502001 	subs	r2, r0, #1
8f603a30:	e1a08000 	mov	r8, r0
8f603a34:	e2c13000 	sbc	r3, r1, #0
8f603a38:	e59d0010 	ldr	r0, [r13, #16]
8f603a3c:	e1a09001 	mov	r9, r1
8f603a40:	e59d100c 	ldr	r1, [r13, #12]
8f603a44:	e1530000 	cmp	r3, r0
8f603a48:	01520001 	cmpeq	r2, r1
8f603a4c:	0affffac 	beq	8f603904 <partition_parse_gpt_header+0x178>
			dprintf(CRITICAL,"Secondary GPT first usable LBA mismatch\n");
8f603a50:	e3000de8 	movw	r0, #3560	; 0xde8
8f603a54:	e3480f70 	movt	r0, #36720	; 0x8f70
8f603a58:	eb00bbc5 	bl	8f632974 <_dprintf>
			return 1;
8f603a5c:	e3a05001 	mov	r5, #1
8f603a60:	eaffff62 	b	8f6037f0 <partition_parse_gpt_header+0x64>
		dprintf(CRITICAL,"Header crc mismatch crc_val = %u with crc_val_org = %u\n", crc_val,crc_val_org);
8f603a64:	e1a02003 	mov	r2, r3
8f603a68:	e3000d88 	movw	r0, #3464	; 0xd88
8f603a6c:	e3480f70 	movt	r0, #36720	; 0x8f70
		return 1;
8f603a70:	e3a05001 	mov	r5, #1
		dprintf(CRITICAL,"Header crc mismatch crc_val = %u with crc_val_org = %u\n", crc_val,crc_val_org);
8f603a74:	eb00bbbe 	bl	8f632974 <_dprintf>
		return 1;
8f603a78:	eaffff5c 	b	8f6037f0 <partition_parse_gpt_header+0x64>
			dprintf(CRITICAL,"Primary GPT first usable LBA mismatch\n");
8f603a7c:	e3000dc0 	movw	r0, #3520	; 0xdc0
8f603a80:	e3480f70 	movt	r0, #36720	; 0x8f70
8f603a84:	eb00bbba 	bl	8f632974 <_dprintf>
			return 1;
8f603a88:	e3a05001 	mov	r5, #1
8f603a8c:	eaffff57 	b	8f6037f0 <partition_parse_gpt_header+0x64>
		dprintf(CRITICAL,"Invalid parition entry size\n");
8f603a90:	e3000e4c 	movw	r0, #3660	; 0xe4c
8f603a94:	e3480f70 	movt	r0, #36720	; 0x8f70
8f603a98:	eb00bbb5 	bl	8f632974 <_dprintf>
		return 1;
8f603a9c:	e3a05001 	mov	r5, #1
8f603aa0:	eaffff52 	b	8f6037f0 <partition_parse_gpt_header+0x64>
		dprintf(CRITICAL,"Invalid first_usable_lba\n");
8f603aa4:	e3000e14 	movw	r0, #3604	; 0xe14
8f603aa8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f603aac:	eb00bbb0 	bl	8f632974 <_dprintf>
		return 1;
8f603ab0:	e3a05001 	mov	r5, #1
8f603ab4:	eaffff4d 	b	8f6037f0 <partition_parse_gpt_header+0x64>
		dprintf(CRITICAL,"Invalid last_usable_lba\n");
8f603ab8:	e3000e30 	movw	r0, #3632	; 0xe30
8f603abc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f603ac0:	eb00bbab 	bl	8f632974 <_dprintf>
		return 1;
8f603ac4:	e3a05001 	mov	r5, #1
8f603ac8:	eaffff48 	b	8f6037f0 <partition_parse_gpt_header+0x64>
	uint32_t blocks_for_entries =
8f603acc:	e1a01006 	mov	r1, r6
8f603ad0:	e3a00901 	mov	r0, #16384	; 0x4000
8f603ad4:	e58d200c 	str	r2, [r13, #12]
8f603ad8:	e58d3004 	str	r3, [r13, #4]
8f603adc:	fa00e43d 	blx	8f63cbd8 <__udivsi3>
			if (partition_0 != ((device_density/block_size) -
8f603ae0:	e59d200c 	ldr	r2, [r13, #12]
8f603ae4:	e59d3004 	ldr	r3, [r13, #4]
						(blocks_for_entries + GPT_HEADER_BLOCKS)))
8f603ae8:	e2801001 	add	r1, r0, #1
			if (partition_0 != ((device_density/block_size) -
8f603aec:	e0588001 	subs	r8, r8, r1
8f603af0:	e2c99000 	sbc	r9, r9, #0
8f603af4:	e1590002 	cmp	r9, r2
8f603af8:	01580005 	cmpeq	r8, r5
8f603afc:	0affffa8 	beq	8f6039a4 <partition_parse_gpt_header+0x218>
				dprintf(CRITICAL, "BackupGPT starting LBA mismatch\n");
8f603b00:	e3000ee8 	movw	r0, #3816	; 0xee8
8f603b04:	e3480f70 	movt	r0, #36720	; 0x8f70
8f603b08:	eb00bb99 	bl	8f632974 <_dprintf>
				ret = 1;
8f603b0c:	e3a05001 	mov	r5, #1
				goto fail;
8f603b10:	eaffffaf 	b	8f6039d4 <partition_parse_gpt_header+0x248>
		dprintf(CRITICAL, "Invalid maximum partition count\n");
8f603b14:	e3000e6c 	movw	r0, #3692	; 0xe6c
8f603b18:	e3480f70 	movt	r0, #36720	; 0x8f70
8f603b1c:	eb00bb94 	bl	8f632974 <_dprintf>
		return 1;
8f603b20:	e3a05001 	mov	r5, #1
8f603b24:	eaffff31 	b	8f6037f0 <partition_parse_gpt_header+0x64>
		crc_val  = crc32(~0L,new_buffer, ((*max_partition_count) * (*partition_entry_size))) ^ (~0L);
8f603b28:	e59a3000 	ldr	r3, [r10]
8f603b2c:	e3e00000 	mvn	r0, #0
8f603b30:	e59b2000 	ldr	r2, [r11]
8f603b34:	e5971000 	ldr	r1, [r7]
		crc_val_org = GET_LWORD_FROM_BYTE(&buffer[PARTITION_CRC_OFFSET]);
8f603b38:	e5944058 	ldr	r4, [r4, #88]	; 0x58
		crc_val  = crc32(~0L,new_buffer, ((*max_partition_count) * (*partition_entry_size))) ^ (~0L);
8f603b3c:	e0020392 	mul	r2, r2, r3
8f603b40:	eb000eaf 	bl	8f607604 <crc32>
8f603b44:	e1e01000 	mvn	r1, r0
		if (crc_val != crc_val_org) {
8f603b48:	e1540001 	cmp	r4, r1
8f603b4c:	0affff27 	beq	8f6037f0 <partition_parse_gpt_header+0x64>
			dprintf(CRITICAL,"Partition entires crc mismatch crc_val= %u with crc_val_org= %u\n",crc_val,crc_val_org);
8f603b50:	e1a02004 	mov	r2, r4
8f603b54:	e3000f38 	movw	r0, #3896	; 0xf38
8f603b58:	e3480f70 	movt	r0, #36720	; 0x8f70
			ret = 1;
8f603b5c:	e3a05001 	mov	r5, #1
			dprintf(CRITICAL,"Partition entires crc mismatch crc_val= %u with crc_val_org= %u\n",crc_val,crc_val_org);
8f603b60:	eb00bb83 	bl	8f632974 <_dprintf>
			ret = 1;
8f603b64:	eaffff21 	b	8f6037f0 <partition_parse_gpt_header+0x64>
				dprintf(CRITICAL, "PrimaryGPT starting LBA mismatch\n");
8f603b68:	e3000ec4 	movw	r0, #3780	; 0xec4
8f603b6c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f603b70:	eb00bb7f 	bl	8f632974 <_dprintf>
				ret = 1;
8f603b74:	e3a05001 	mov	r5, #1
				goto fail;
8f603b78:	eaffff95 	b	8f6039d4 <partition_parse_gpt_header+0x248>
}
8f603b7c:	eb00bc0f 	bl	8f632bc0 <__stack_chk_fail>
		dprintf(CRITICAL, "Failed to Allocate memory to read partition table\n");
8f603b80:	e3000e90 	movw	r0, #3728	; 0xe90
8f603b84:	e3480f70 	movt	r0, #36720	; 0x8f70
8f603b88:	eb00bb79 	bl	8f632974 <_dprintf>
		return 1;
8f603b8c:	e3a05001 	mov	r5, #1
8f603b90:	eaffff16 	b	8f6037f0 <partition_parse_gpt_header+0x64>
8f603b94:	8f74221c 	.word	0x8f74221c

8f603b98 <partition_get_partition_count>:
	return partition_count;
8f603b98:	e30b3d8c 	movw	r3, #48524	; 0xbd8c
8f603b9c:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f603ba0:	e59f2038 	ldr	r2, [pc, #56]	; 8f603be0 <partition_get_partition_count+0x48>
8f603ba4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f603ba8:	e24dd00c 	sub	r13, r13, #12
	return partition_count;
8f603bac:	e5930000 	ldr	r0, [r3]
{
8f603bb0:	e5922000 	ldr	r2, [r2]
8f603bb4:	e58d2004 	str	r2, [r13, #4]
8f603bb8:	e3a02000 	mov	r2, #0
}
8f603bbc:	e59f301c 	ldr	r3, [pc, #28]	; 8f603be0 <partition_get_partition_count+0x48>
8f603bc0:	e5932000 	ldr	r2, [r3]
8f603bc4:	e59d3004 	ldr	r3, [r13, #4]
8f603bc8:	e0332002 	eors	r2, r3, r2
8f603bcc:	e3a03000 	mov	r3, #0
8f603bd0:	1a000001 	bne	8f603bdc <partition_get_partition_count+0x44>
8f603bd4:	e28dd00c 	add	r13, r13, #12
8f603bd8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f603bdc:	eb00bbf7 	bl	8f632bc0 <__stack_chk_fail>
8f603be0:	8f74221c 	.word	0x8f74221c

8f603be4 <partition_get_partition_entries>:
	return partition_entries;
8f603be4:	e3023230 	movw	r3, #8752	; 0x2230
8f603be8:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f603bec:	e59f2038 	ldr	r2, [pc, #56]	; 8f603c2c <partition_get_partition_entries+0x48>
8f603bf0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f603bf4:	e24dd00c 	sub	r13, r13, #12
	return partition_entries;
8f603bf8:	e5930000 	ldr	r0, [r3]
{
8f603bfc:	e5922000 	ldr	r2, [r2]
8f603c00:	e58d2004 	str	r2, [r13, #4]
8f603c04:	e3a02000 	mov	r2, #0
}
8f603c08:	e59f301c 	ldr	r3, [pc, #28]	; 8f603c2c <partition_get_partition_entries+0x48>
8f603c0c:	e5932000 	ldr	r2, [r3]
8f603c10:	e59d3004 	ldr	r3, [r13, #4]
8f603c14:	e0332002 	eors	r2, r3, r2
8f603c18:	e3a03000 	mov	r3, #0
8f603c1c:	1a000001 	bne	8f603c28 <partition_get_partition_entries+0x44>
8f603c20:	e28dd00c 	add	r13, r13, #12
8f603c24:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f603c28:	eb00bbe4 	bl	8f632bc0 <__stack_chk_fail>
8f603c2c:	8f74221c 	.word	0x8f74221c

8f603c30 <write_partition>:
	if (partition == 0) {
8f603c30:	e3510000 	cmp	r1, #0
{
8f603c34:	e59f304c 	ldr	r3, [pc, #76]	; 8f603c88 <write_partition+0x58>
8f603c38:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
		dprintf(CRITICAL, "NULL partition\n");
8f603c3c:	03000f7c 	movweq	r0, #3964	; 0xf7c
{
8f603c40:	e24dd00c 	sub	r13, r13, #12
	dprintf(CRITICAL, "Ignoring attempt to write partition table\n");
8f603c44:	13000f8c 	movwne	r0, #3980	; 0xf8c
		dprintf(CRITICAL, "NULL partition\n");
8f603c48:	03480f70 	movteq	r0, #36720	; 0x8f70
	dprintf(CRITICAL, "Ignoring attempt to write partition table\n");
8f603c4c:	13480f70 	movtne	r0, #36720	; 0x8f70
{
8f603c50:	e5933000 	ldr	r3, [r3]
8f603c54:	e58d3004 	str	r3, [r13, #4]
8f603c58:	e3a03000 	mov	r3, #0
	dprintf(CRITICAL, "Ignoring attempt to write partition table\n");
8f603c5c:	eb00bb44 	bl	8f632974 <_dprintf>
}
8f603c60:	e59f3020 	ldr	r3, [pc, #32]	; 8f603c88 <write_partition+0x58>
8f603c64:	e5932000 	ldr	r2, [r3]
8f603c68:	e59d3004 	ldr	r3, [r13, #4]
8f603c6c:	e0332002 	eors	r2, r3, r2
8f603c70:	e3a03000 	mov	r3, #0
8f603c74:	1a000002 	bne	8f603c84 <write_partition+0x54>
8f603c78:	e3a00001 	mov	r0, #1
8f603c7c:	e28dd00c 	add	r13, r13, #12
8f603c80:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f603c84:	eb00bbcd 	bl	8f632bc0 <__stack_chk_fail>
8f603c88:	8f74221c 	.word	0x8f74221c

8f603c8c <partition_get_index>:
{
8f603c8c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	if( partition_count >= NUM_PARTITIONS)
8f603c90:	e30b8d8c 	movw	r8, #48524	; 0xbd8c
{
8f603c94:	e59f3100 	ldr	r3, [pc, #256]	; 8f603d9c <partition_get_index+0x110>
	if( partition_count >= NUM_PARTITIONS)
8f603c98:	e3488f72 	movt	r8, #36722	; 0x8f72
{
8f603c9c:	e24dd014 	sub	r13, r13, #20
8f603ca0:	e1a09000 	mov	r9, r0
8f603ca4:	e5933000 	ldr	r3, [r3]
8f603ca8:	e58d300c 	str	r3, [r13, #12]
8f603cac:	e3a03000 	mov	r3, #0
	unsigned int input_string_length = strlen(name);
8f603cb0:	eb00c2d4 	bl	8f634808 <strlen>
	for (n = 0; n < partition_count; n++)
8f603cb4:	e5983000 	ldr	r3, [r8]
8f603cb8:	e2433001 	sub	r3, r3, #1
8f603cbc:	e353007e 	cmp	r3, #126	; 0x7e
8f603cc0:	8a000032 	bhi	8f603d90 <partition_get_index+0x104>
8f603cc4:	e3a06000 	mov	r6, #0
8f603cc8:	e302a230 	movw	r10, #8752	; 0x2230
					suffix_curr_actv_slot = SUFFIX_SLOT(curr_slot);
8f603ccc:	e301b2e0 	movw	r11, #4832	; 0x12e0
8f603cd0:	e348af74 	movt	r10, #36724	; 0x8f74
8f603cd4:	e348bf71 	movt	r11, #36721	; 0x8f71
8f603cd8:	e1a07000 	mov	r7, r0
	for (n = 0; n < partition_count; n++)
8f603cdc:	e1a05006 	mov	r5, r6
8f603ce0:	ea000004 	b	8f603cf8 <partition_get_index+0x6c>
8f603ce4:	e5983000 	ldr	r3, [r8]
8f603ce8:	e2855001 	add	r5, r5, #1
8f603cec:	e2866098 	add	r6, r6, #152	; 0x98
8f603cf0:	e1530005 	cmp	r3, r5
8f603cf4:	9a000025 	bls	8f603d90 <partition_get_index+0x104>
		if (!strncmp((const char*)name, (const char *)partition_entries[n].name,
8f603cf8:	e59a4000 	ldr	r4, [r10]
8f603cfc:	e1a02007 	mov	r2, r7
8f603d00:	e1a00009 	mov	r0, r9
8f603d04:	e0844006 	add	r4, r4, r6
8f603d08:	e2844048 	add	r4, r4, #72	; 0x48
8f603d0c:	e1a01004 	mov	r1, r4
8f603d10:	eb00c2d5 	bl	8f63486c <strncmp>
8f603d14:	e3500000 	cmp	r0, #0
8f603d18:	1afffff1 	bne	8f603ce4 <partition_get_index+0x58>
			if (*curr_suffix == '\0')
8f603d1c:	e7d43007 	ldrb	r3, [r4, r7]
			curr_suffix = (char *)(partition_entries[n].name+input_string_length);
8f603d20:	e0844007 	add	r4, r4, r7
			if (*curr_suffix == '\0')
8f603d24:	e3530000 	cmp	r3, #0
8f603d28:	0a00000f 	beq	8f603d6c <partition_get_index+0xe0>
			if (partition_multislot_is_supported())
8f603d2c:	eb000676 	bl	8f60570c <partition_multislot_is_supported>
8f603d30:	e3500000 	cmp	r0, #0
8f603d34:	0affffea 	beq	8f603ce4 <partition_get_index+0x58>
				curr_slot = partition_find_active_slot();
8f603d38:	eb0004a3 	bl	8f604fcc <partition_find_active_slot>
				if (curr_slot != INVALID)
8f603d3c:	e3700001 	cmn	r0, #1
8f603d40:	0a000012 	beq	8f603d90 <partition_get_index+0x104>
					suffix_curr_actv_slot = SUFFIX_SLOT(curr_slot);
8f603d44:	e79b1100 	ldr	r1, [r11, r0, lsl #2]
					if (!strncmp((const char *)curr_suffix, suffix_curr_actv_slot,
8f603d48:	e1a00001 	mov	r0, r1
8f603d4c:	e58d1004 	str	r1, [r13, #4]
8f603d50:	eb00c2ac 	bl	8f634808 <strlen>
8f603d54:	e59d1004 	ldr	r1, [r13, #4]
8f603d58:	e1a02000 	mov	r2, r0
8f603d5c:	e1a00004 	mov	r0, r4
8f603d60:	eb00c2c1 	bl	8f63486c <strncmp>
8f603d64:	e3500000 	cmp	r0, #0
8f603d68:	1affffdd 	bne	8f603ce4 <partition_get_index+0x58>
						return n;
8f603d6c:	e1a00005 	mov	r0, r5
}
8f603d70:	e59f3024 	ldr	r3, [pc, #36]	; 8f603d9c <partition_get_index+0x110>
8f603d74:	e5932000 	ldr	r2, [r3]
8f603d78:	e59d300c 	ldr	r3, [r13, #12]
8f603d7c:	e0332002 	eors	r2, r3, r2
8f603d80:	e3a03000 	mov	r3, #0
8f603d84:	1a000003 	bne	8f603d98 <partition_get_index+0x10c>
8f603d88:	e28dd014 	add	r13, r13, #20
8f603d8c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	return INVALID_PTN;
8f603d90:	e3e00000 	mvn	r0, #0
8f603d94:	eafffff5 	b	8f603d70 <partition_get_index+0xe4>
}
8f603d98:	eb00bb88 	bl	8f632bc0 <__stack_chk_fail>
8f603d9c:	8f74221c 	.word	0x8f74221c

8f603da0 <partition_split_boot>:
{
8f603da0:	e59f317c 	ldr	r3, [pc, #380]	; 8f603f24 <partition_split_boot+0x184>
8f603da4:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f603da8:	e1a05000 	mov	r5, r0
8f603dac:	e24dd00c 	sub	r13, r13, #12
	int index = partition_get_index("boot");
8f603db0:	e30a0370 	movw	r0, #41840	; 0xa370
8f603db4:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f603db8:	e5933000 	ldr	r3, [r3]
8f603dbc:	e58d3004 	str	r3, [r13, #4]
8f603dc0:	e3a03000 	mov	r3, #0
	int index = partition_get_index("boot");
8f603dc4:	ebffffb0 	bl	8f603c8c <partition_get_index>
	unsigned long long lk_size = (1 * 1024 * 1024) / block_size;
8f603dc8:	e1a01005 	mov	r1, r5
	int index = partition_get_index("boot");
8f603dcc:	e1a04000 	mov	r4, r0
	unsigned long long lk_size = (1 * 1024 * 1024) / block_size;
8f603dd0:	e3a00601 	mov	r0, #1048576	; 0x100000
8f603dd4:	fa00e37f 	blx	8f63cbd8 <__udivsi3>
	if (index == INVALID_PTN) {
8f603dd8:	e3740001 	cmn	r4, #1
8f603ddc:	0a000047 	beq	8f603f00 <partition_split_boot+0x160>
	boot = &partition_entries[index];
8f603de0:	e3023230 	movw	r3, #8752	; 0x2230
8f603de4:	e3483f74 	movt	r3, #36724	; 0x8f74
8f603de8:	e3a02098 	mov	r2, #152	; 0x98
8f603dec:	e1a06000 	mov	r6, r0
8f603df0:	e5935000 	ldr	r5, [r3]
8f603df4:	e0245492 	mla	r4, r2, r4, r5
	if (boot->size < lk_size) {
8f603df8:	e5943038 	ldr	r3, [r4, #56]	; 0x38
8f603dfc:	e1530000 	cmp	r3, r0
8f603e00:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
8f603e04:	e2d33000 	sbcs	r3, r3, #0
8f603e08:	3a000031 	bcc	8f603ed4 <partition_split_boot+0x134>
	if (partition_count < NUM_PARTITIONS) {
8f603e0c:	e30b3d8c 	movw	r3, #48524	; 0xbd8c
8f603e10:	e3483f72 	movt	r3, #36722	; 0x8f72
8f603e14:	e5931000 	ldr	r1, [r3]
8f603e18:	e351007f 	cmp	r1, #127	; 0x7f
8f603e1c:	9a000016 	bls	8f603e7c <partition_split_boot+0xdc>
		dprintf(INFO, "Too many partitions to add virtual 'lk2nd' partition\n");
8f603e20:	e301000c 	movw	r0, #4108	; 0x100c
8f603e24:	e3480f70 	movt	r0, #36720	; 0x8f70
8f603e28:	eb00bad1 	bl	8f632974 <_dprintf>
	boot->first_lba += lk_size;
8f603e2c:	e5943028 	ldr	r3, [r4, #40]	; 0x28
8f603e30:	e594202c 	ldr	r2, [r4, #44]	; 0x2c
8f603e34:	e0933006 	adds	r3, r3, r6
	boot->size -= lk_size;
8f603e38:	e5940038 	ldr	r0, [r4, #56]	; 0x38
	boot->first_lba += lk_size;
8f603e3c:	e5843028 	str	r3, [r4, #40]	; 0x28
8f603e40:	e2a23000 	adc	r3, r2, #0
8f603e44:	e584302c 	str	r3, [r4, #44]	; 0x2c
	boot->size -= lk_size;
8f603e48:	e0500006 	subs	r0, r0, r6
8f603e4c:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
8f603e50:	e5840038 	str	r0, [r4, #56]	; 0x38
8f603e54:	e2c33000 	sbc	r3, r3, #0
8f603e58:	e584303c 	str	r3, [r4, #60]	; 0x3c
}
8f603e5c:	e59f30c0 	ldr	r3, [pc, #192]	; 8f603f24 <partition_split_boot+0x184>
8f603e60:	e5932000 	ldr	r2, [r3]
8f603e64:	e59d3004 	ldr	r3, [r13, #4]
8f603e68:	e0332002 	eors	r2, r3, r2
8f603e6c:	e3a03000 	mov	r3, #0
8f603e70:	1a00002a 	bne	8f603f20 <partition_split_boot+0x180>
8f603e74:	e28dd00c 	add	r13, r13, #12
8f603e78:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		struct partition_entry *lk = &partition_entries[partition_count++];
8f603e7c:	e0255192 	mla	r5, r2, r1, r5
8f603e80:	e2811001 	add	r1, r1, #1
8f603e84:	e5831000 	str	r1, [r3]
		memcpy(lk, boot, sizeof(*lk));
8f603e88:	e1a01004 	mov	r1, r4
8f603e8c:	e3a07000 	mov	r7, #0
8f603e90:	e1a00005 	mov	r0, r5
8f603e94:	eb00c0c7 	bl	8f6341b8 <memcpy>
		strcpy(lk->name, "lk2nd");
8f603e98:	e2850048 	add	r0, r5, #72	; 0x48
8f603e9c:	e3011004 	movw	r1, #4100	; 0x1004
8f603ea0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f603ea4:	eb00c1ba 	bl	8f634594 <strcpy>
		lk->last_lba = lk->first_lba + lk_size - 1;
8f603ea8:	e5953028 	ldr	r3, [r5, #40]	; 0x28
8f603eac:	e595202c 	ldr	r2, [r5, #44]	; 0x2c
8f603eb0:	e2533001 	subs	r3, r3, #1
		lk->size = lk_size;
8f603eb4:	e585703c 	str	r7, [r5, #60]	; 0x3c
		lk->last_lba = lk->first_lba + lk_size - 1;
8f603eb8:	e2c22000 	sbc	r2, r2, #0
8f603ebc:	e0933006 	adds	r3, r3, r6
8f603ec0:	e2a22000 	adc	r2, r2, #0
		lk->size = lk_size;
8f603ec4:	e5856038 	str	r6, [r5, #56]	; 0x38
		lk->last_lba = lk->first_lba + lk_size - 1;
8f603ec8:	e5853030 	str	r3, [r5, #48]	; 0x30
8f603ecc:	e5852034 	str	r2, [r5, #52]	; 0x34
		lk->size = lk_size;
8f603ed0:	eaffffd5 	b	8f603e2c <partition_split_boot+0x8c>
		dprintf(CRITICAL, "Boot partition has not enough space for lk2nd\n");
8f603ed4:	e59f3048 	ldr	r3, [pc, #72]	; 8f603f24 <partition_split_boot+0x184>
8f603ed8:	e5932000 	ldr	r2, [r3]
8f603edc:	e59d3004 	ldr	r3, [r13, #4]
8f603ee0:	e0332002 	eors	r2, r3, r2
8f603ee4:	e3a03000 	mov	r3, #0
8f603ee8:	03000fd4 	movweq	r0, #4052	; 0xfd4
8f603eec:	03480f70 	movteq	r0, #36720	; 0x8f70
8f603ef0:	1a00000a 	bne	8f603f20 <partition_split_boot+0x180>
}
8f603ef4:	e28dd00c 	add	r13, r13, #12
8f603ef8:	e8bd40f0 	pop	{r4, r5, r6, r7, r14}
		dprintf(CRITICAL, "Boot partition has not enough space for lk2nd\n");
8f603efc:	ea00ba9c 	b	8f632974 <_dprintf>
		dprintf(CRITICAL, "Boot partition not found\n");
8f603f00:	e59f301c 	ldr	r3, [pc, #28]	; 8f603f24 <partition_split_boot+0x184>
8f603f04:	e5932000 	ldr	r2, [r3]
8f603f08:	e59d3004 	ldr	r3, [r13, #4]
8f603f0c:	e0332002 	eors	r2, r3, r2
8f603f10:	e3a03000 	mov	r3, #0
8f603f14:	03000fb8 	movweq	r0, #4024	; 0xfb8
8f603f18:	03480f70 	movteq	r0, #36720	; 0x8f70
8f603f1c:	0afffff4 	beq	8f603ef4 <partition_split_boot+0x154>
}
8f603f20:	eb00bb26 	bl	8f632bc0 <__stack_chk_fail>
8f603f24:	8f74221c 	.word	0x8f74221c

8f603f28 <partition_read_table>:
{
8f603f28:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f603f2c:	e24dd0bc 	sub	r13, r13, #188	; 0xbc
8f603f30:	e59f38fc 	ldr	r3, [pc, #2300]	; 8f604834 <partition_read_table+0x90c>
	if(!partition_entries)
8f603f34:	e302b230 	movw	r11, #8752	; 0x2230
8f603f38:	e348bf74 	movt	r11, #36724	; 0x8f74
{
8f603f3c:	e5933000 	ldr	r3, [r3]
8f603f40:	e58d30b4 	str	r3, [r13, #180]	; 0xb4
8f603f44:	e3a03000 	mov	r3, #0
	block_size = mmc_get_device_blocksize();
8f603f48:	e58de040 	str	r14, [r13, #64]	; 0x40
8f603f4c:	eb00250a 	bl	8f60d37c <mmc_get_device_blocksize>
	if(!partition_entries)
8f603f50:	e59b3000 	ldr	r3, [r11]
8f603f54:	e3530000 	cmp	r3, #0
	block_size = mmc_get_device_blocksize();
8f603f58:	e58d0010 	str	r0, [r13, #16]
	if(!partition_entries)
8f603f5c:	0a000175 	beq	8f604538 <partition_read_table+0x610>
	buffer = (uint8_t *)memalign(CACHE_LINE, ROUNDUP(block_size, CACHE_LINE));
8f603f60:	e59d3010 	ldr	r3, [r13, #16]
8f603f64:	e3a00040 	mov	r0, #64	; 0x40
8f603f68:	e283703f 	add	r7, r3, #63	; 0x3f
8f603f6c:	e3c7703f 	bic	r7, r7, #63	; 0x3f
8f603f70:	e1a01007 	mov	r1, r7
8f603f74:	eb00c032 	bl	8f634044 <memalign>
	if (!buffer)
8f603f78:	e2503000 	subs	r3, r0, #0
8f603f7c:	e58d300c 	str	r3, [r13, #12]
8f603f80:	0a000227 	beq	8f604824 <partition_read_table+0x8fc>
	ret = mmc_read(0, (unsigned int *)buffer, block_size);
8f603f84:	e1cd20dc 	ldrd	r2, [r13, #12]
8f603f88:	e3a00000 	mov	r0, #0
8f603f8c:	e3a01000 	mov	r1, #0
8f603f90:	eb00233c 	bl	8f60cc88 <mmc_read>
	if (ret) {
8f603f94:	e2503000 	subs	r3, r0, #0
8f603f98:	e58d3030 	str	r3, [r13, #48]	; 0x30
8f603f9c:	1a00001d 	bne	8f604018 <partition_read_table+0xf0>
	if ((TABLE_SIGNATURE + 1) > size) {
8f603fa0:	e59d2010 	ldr	r2, [r13, #16]
8f603fa4:	e30031fe 	movw	r3, #510	; 0x1fe
8f603fa8:	e1520003 	cmp	r2, r3
8f603fac:	9a00001c 	bls	8f604024 <partition_read_table+0xfc>
	if ((buffer[TABLE_SIGNATURE] != MMC_MBR_SIGNATURE_BYTE_0) ||
8f603fb0:	e59d200c 	ldr	r2, [r13, #12]
8f603fb4:	e5d231fe 	ldrb	r3, [r2, #510]	; 0x1fe
8f603fb8:	e3530055 	cmp	r3, #85	; 0x55
8f603fbc:	1a000002 	bne	8f603fcc <partition_read_table+0xa4>
8f603fc0:	e5d231ff 	ldrb	r3, [r2, #511]	; 0x1ff
8f603fc4:	e35300aa 	cmp	r3, #170	; 0xaa
8f603fc8:	0a000018 	beq	8f604030 <partition_read_table+0x108>
		dprintf(CRITICAL, "MBR signature does not match.\n");
8f603fcc:	e30100dc 	movw	r0, #4316	; 0x10dc
8f603fd0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f603fd4:	eb00ba66 	bl	8f632974 <_dprintf>
		free(buffer);
8f603fd8:	e59d000c 	ldr	r0, [r13, #12]
8f603fdc:	eb00c04a 	bl	8f63410c <free>
		dprintf(CRITICAL, "MMC Boot: MBR read failed!\n");
8f603fe0:	e301011c 	movw	r0, #4380	; 0x111c
8f603fe4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f603fe8:	eb00ba61 	bl	8f632974 <_dprintf>
		return 1;
8f603fec:	e3a03001 	mov	r3, #1
8f603ff0:	e58d3030 	str	r3, [r13, #48]	; 0x30
}
8f603ff4:	e59f3838 	ldr	r3, [pc, #2104]	; 8f604834 <partition_read_table+0x90c>
8f603ff8:	e5932000 	ldr	r2, [r3]
8f603ffc:	e59d30b4 	ldr	r3, [r13, #180]	; 0xb4
8f604000:	e0332002 	eors	r2, r3, r2
8f604004:	e3a03000 	mov	r3, #0
8f604008:	1a0001fa 	bne	8f6047f8 <partition_read_table+0x8d0>
8f60400c:	e59d0030 	ldr	r0, [r13, #48]	; 0x30
8f604010:	e28dd0bc 	add	r13, r13, #188	; 0xbc
8f604014:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		dprintf(CRITICAL, "Could not read partition from mmc\n");
8f604018:	e30100b8 	movw	r0, #4280	; 0x10b8
8f60401c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f604020:	eb00ba53 	bl	8f632974 <_dprintf>
		free(buffer);
8f604024:	e59d000c 	ldr	r0, [r13, #12]
8f604028:	eb00c037 	bl	8f63410c <free>
	if (ret) {
8f60402c:	eaffffeb 	b	8f603fe0 <partition_read_table+0xb8>
8f604030:	e59d900c 	ldr	r9, [r13, #12]
		partition_entries[partition_count].dtype = dtype;
8f604034:	e30b6d8c 	movw	r6, #48524	; 0xbd8c
		    buffer[idx + i * TABLE_ENTRY_SIZE + OFFSET_STATUS];
8f604038:	e59da030 	ldr	r10, [r13, #48]	; 0x30
		partition_entries[partition_count].dtype = dtype;
8f60403c:	e3486f72 	movt	r6, #36722	; 0x8f72
8f604040:	e2895040 	add	r5, r9, #64	; 0x40
		dtype = buffer[idx + i * TABLE_ENTRY_SIZE + OFFSET_TYPE];
8f604044:	e5d981c2 	ldrb	r8, [r9, #450]	; 0x1c2
		if (dtype == MBR_PROTECTED_TYPE) {
8f604048:	e35800ee 	cmp	r8, #238	; 0xee
8f60404c:	0a0001c9 	beq	8f604778 <partition_read_table+0x850>
		partition_entries[partition_count].dtype = dtype;
8f604050:	e5963000 	ldr	r3, [r6]
8f604054:	e3a02098 	mov	r2, #152	; 0x98
8f604058:	e59b0000 	ldr	r0, [r11]
		mbr_fill_name(&partition_entries[partition_count],
8f60405c:	e1a01008 	mov	r1, r8
		partition_entries[partition_count].dtype = dtype;
8f604060:	e0200392 	mla	r0, r2, r3, r0
8f604064:	e5808010 	str	r8, [r0, #16]
		    buffer[idx + i * TABLE_ENTRY_SIZE + OFFSET_STATUS];
8f604068:	e5d931be 	ldrb	r3, [r9, #446]	; 0x1be
8f60406c:	e580a044 	str	r10, [r0, #68]	; 0x44
8f604070:	e5803040 	str	r3, [r0, #64]	; 0x40
		    GET_LWORD_FROM_BYTE(&buffer[idx +
8f604074:	e5d941c8 	ldrb	r4, [r9, #456]	; 0x1c8
8f604078:	e5d931c7 	ldrb	r3, [r9, #455]	; 0x1c7
8f60407c:	e1a04804 	lsl	r4, r4, #16
8f604080:	e1844403 	orr	r4, r4, r3, lsl #8
8f604084:	e5d931c6 	ldrb	r3, [r9, #454]	; 0x1c6
8f604088:	e1844003 	orr	r4, r4, r3
8f60408c:	e5d931c9 	ldrb	r3, [r9, #457]	; 0x1c9
8f604090:	e580a02c 	str	r10, [r0, #44]	; 0x2c
8f604094:	e1844c03 	orr	r4, r4, r3, lsl #24
8f604098:	e5804028 	str	r4, [r0, #40]	; 0x28
		    GET_LWORD_FROM_BYTE(&buffer[idx +
8f60409c:	e5d931cc 	ldrb	r3, [r9, #460]	; 0x1cc
8f6040a0:	e5d921cb 	ldrb	r2, [r9, #459]	; 0x1cb
8f6040a4:	e1a03803 	lsl	r3, r3, #16
8f6040a8:	e1833402 	orr	r3, r3, r2, lsl #8
8f6040ac:	e5d921ca 	ldrb	r2, [r9, #458]	; 0x1ca
8f6040b0:	e1833002 	orr	r3, r3, r2
8f6040b4:	e5d921cd 	ldrb	r2, [r9, #461]	; 0x1cd
8f6040b8:	e580a03c 	str	r10, [r0, #60]	; 0x3c
8f6040bc:	e1833c02 	orr	r3, r3, r2, lsl #24
8f6040c0:	e5803038 	str	r3, [r0, #56]	; 0x38
		mbr_fill_name(&partition_entries[partition_count],
8f6040c4:	ebfffc6a 	bl	8f603274 <mbr_fill_name>
		partition_count++;
8f6040c8:	e5963000 	ldr	r3, [r6]
8f6040cc:	e2833001 	add	r3, r3, #1
8f6040d0:	e5863000 	str	r3, [r6]
		if (partition_count == NUM_PARTITIONS)
8f6040d4:	e3530080 	cmp	r3, #128	; 0x80
8f6040d8:	0a000004 	beq	8f6040f0 <partition_read_table+0x1c8>
	for (i = 0; i < 4; i++) {
8f6040dc:	e2899010 	add	r9, r9, #16
8f6040e0:	e1590005 	cmp	r9, r5
8f6040e4:	1affffd6 	bne	8f604044 <partition_read_table+0x11c>
	if (dtype != MBR_EBR_TYPE) {
8f6040e8:	e3580005 	cmp	r8, #5
8f6040ec:	0a000132 	beq	8f6045bc <partition_read_table+0x694>
		free(buffer);
8f6040f0:	e59d000c 	ldr	r0, [r13, #12]
8f6040f4:	e30b4d80 	movw	r4, #48512	; 0xbd80
8f6040f8:	eb00c003 	bl	8f63410c <free>
	if (ret) {
8f6040fc:	e3484f72 	movt	r4, #36722	; 0x8f72
	if (gpt_partitions_exist) {
8f604100:	e5943000 	ldr	r3, [r4]
8f604104:	e3530000 	cmp	r3, #0
8f604108:	0a0000fe 	beq	8f604508 <partition_read_table+0x5e0>
	unsigned int max_partition_count = 0;
8f60410c:	e3a04000 	mov	r4, #0
8f604110:	e58d4058 	str	r4, [r13, #88]	; 0x58
	device_density = mmc_get_device_capacity();
8f604114:	eb002480 	bl	8f60d31c <mmc_get_device_capacity>
8f604118:	e1a03001 	mov	r3, r1
8f60411c:	e58d0020 	str	r0, [r13, #32]
	data = (uint8_t *)memalign(CACHE_LINE, ROUNDUP(block_size, CACHE_LINE));
8f604120:	e1a01007 	mov	r1, r7
8f604124:	e3a00040 	mov	r0, #64	; 0x40
	device_density = mmc_get_device_capacity();
8f604128:	e58d3024 	str	r3, [r13, #36]	; 0x24
	data = (uint8_t *)memalign(CACHE_LINE, ROUNDUP(block_size, CACHE_LINE));
8f60412c:	eb00bfc4 	bl	8f634044 <memalign>
	if (!data)
8f604130:	e2503000 	subs	r3, r0, #0
8f604134:	e58d303c 	str	r3, [r13, #60]	; 0x3c
8f604138:	0a0001af 	beq	8f6047fc <partition_read_table+0x8d4>
	ret = mmc_read(block_size, (unsigned int *)data, block_size);
8f60413c:	e59d3010 	ldr	r3, [r13, #16]
8f604140:	e1a01004 	mov	r1, r4
8f604144:	e59d203c 	ldr	r2, [r13, #60]	; 0x3c
8f604148:	e1a00003 	mov	r0, r3
8f60414c:	eb0022cd 	bl	8f60cc88 <mmc_read>
	if (ret)
8f604150:	e2504000 	subs	r4, r0, #0
8f604154:	1a000108 	bne	8f60457c <partition_read_table+0x654>
	ret = partition_parse_gpt_header(data, &first_usable_lba,
8f604158:	e28d3058 	add	r3, r13, #88	; 0x58
8f60415c:	e59d003c 	ldr	r0, [r13, #60]	; 0x3c
8f604160:	e58d3000 	str	r3, [r13]
8f604164:	e28d205c 	add	r2, r13, #92	; 0x5c
8f604168:	e28d3054 	add	r3, r13, #84	; 0x54
8f60416c:	e28d1060 	add	r1, r13, #96	; 0x60
8f604170:	ebfffd85 	bl	8f60378c <partition_parse_gpt_header>
	if (ret) {
8f604174:	e3500000 	cmp	r0, #0
8f604178:	1a000152 	bne	8f6046c8 <partition_read_table+0x7a0>
	uint32_t part_entry_cnt = block_size / ENTRY_SIZE;
8f60417c:	e59d1010 	ldr	r1, [r13, #16]
	for (i = 0; i < (ROUNDUP(max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f604180:	e59d3058 	ldr	r3, [r13, #88]	; 0x58
	uint32_t part_entry_cnt = block_size / ENTRY_SIZE;
8f604184:	e1a023a1 	lsr	r2, r1, #7
	for (i = 0; i < (ROUNDUP(max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f604188:	e2433001 	sub	r3, r3, #1
8f60418c:	e2620000 	rsb	r0, r2, #0
8f604190:	e0833002 	add	r3, r3, r2
8f604194:	e0033000 	and	r3, r3, r0
	uint32_t part_entry_cnt = block_size / ENTRY_SIZE;
8f604198:	e58d2014 	str	r2, [r13, #20]
	for (i = 0; i < (ROUNDUP(max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f60419c:	e1520003 	cmp	r2, r3
8f6041a0:	e58d0038 	str	r0, [r13, #56]	; 0x38
8f6041a4:	8a000180 	bhi	8f6047ac <partition_read_table+0x884>
	uint32_t blocks_for_entries =
8f6041a8:	e3a00901 	mov	r0, #16384	; 0x4000
8f6041ac:	e30b9d8c 	movw	r9, #48524	; 0xbd8c
8f6041b0:	fa00e288 	blx	8f63cbd8 <__udivsi3>
8f6041b4:	e3489f72 	movt	r9, #36722	; 0x8f72
8f6041b8:	e1a0a00b 	mov	r10, r11
8f6041bc:	e30b3d84 	movw	r3, #48516	; 0xbd84
8f6041c0:	e3483f72 	movt	r3, #36722	; 0x8f72
8f6041c4:	e58d3034 	str	r3, [r13, #52]	; 0x34
		ASSERT(partition_count < NUM_PARTITIONS);
8f6041c8:	e30131d0 	movw	r3, #4560	; 0x11d0
8f6041cc:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6041d0:	e58d3044 	str	r3, [r13, #68]	; 0x44
8f6041d4:	e3013044 	movw	r3, #4164	; 0x1044
8f6041d8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6041dc:	e58d3048 	str	r3, [r13, #72]	; 0x48
8f6041e0:	e3003130 	movw	r3, #304	; 0x130
8f6041e4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6041e8:	e58d304c 	str	r3, [r13, #76]	; 0x4c
	uint32_t blocks_for_entries =
8f6041ec:	e3a03000 	mov	r3, #0
8f6041f0:	e58d302c 	str	r3, [r13, #44]	; 0x2c
8f6041f4:	e58d0028 	str	r0, [r13, #40]	; 0x28
		ASSERT(partition_count < NUM_PARTITIONS);
8f6041f8:	e5993000 	ldr	r3, [r9]
8f6041fc:	e353007f 	cmp	r3, #127	; 0x7f
8f604200:	8a0000c4 	bhi	8f604518 <partition_read_table+0x5f0>
		data = (new_buffer + (i * block_size));
8f604204:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
		for (j = 0; j < part_entry_cnt; j++) {
8f604208:	e3a0b000 	mov	r11, #0
		data = (new_buffer + (i * block_size));
8f60420c:	e59d2010 	ldr	r2, [r13, #16]
8f604210:	e59d102c 	ldr	r1, [r13, #44]	; 0x2c
8f604214:	e5933000 	ldr	r3, [r3]
8f604218:	e0233291 	mla	r3, r1, r2, r3
8f60421c:	e58d300c 	str	r3, [r13, #12]
				dprintf(CRITICAL, "Partition entry(%d), lba not valid\n", j);
8f604220:	e30131f4 	movw	r3, #4596	; 0x11f4
8f604224:	e3483f70 	movt	r3, #36720	; 0x8f70
8f604228:	e58d301c 	str	r3, [r13, #28]
8f60422c:	ea000009 	b	8f604258 <partition_read_table+0x330>
8f604230:	e1a0100b 	mov	r1, r11
8f604234:	e59d001c 	ldr	r0, [r13, #28]
8f604238:	eb00b9cd 	bl	8f632974 <_dprintf>
				partition_count++;
8f60423c:	e5993000 	ldr	r3, [r9]
		for (j = 0; j < part_entry_cnt; j++) {
8f604240:	e28bb001 	add	r11, r11, #1
				partition_count++;
8f604244:	e2833001 	add	r3, r3, #1
8f604248:	e5893000 	str	r3, [r9]
		for (j = 0; j < part_entry_cnt; j++) {
8f60424c:	e59d3014 	ldr	r3, [r13, #20]
8f604250:	e153000b 	cmp	r3, r11
8f604254:	0a00008f 	beq	8f604498 <partition_read_table+0x570>
			memcpy(&(partition_entries[partition_count].type_guid),
8f604258:	e59d300c 	ldr	r3, [r13, #12]
8f60425c:	e3a04098 	mov	r4, #152	; 0x98
			       &data[(j * partition_entry_size)],
8f604260:	e59d105c 	ldr	r1, [r13, #92]	; 0x5c
			memcpy(&(partition_entries[partition_count].type_guid),
8f604264:	e3a02010 	mov	r2, #16
8f604268:	e5990000 	ldr	r0, [r9]
8f60426c:	e0213b91 	mla	r1, r1, r11, r3
8f604270:	e59a3000 	ldr	r3, [r10]
8f604274:	e0203094 	mla	r0, r4, r0, r3
8f604278:	eb00bfce 	bl	8f6341b8 <memcpy>
			if (partition_entries[partition_count].type_guid[0] ==
8f60427c:	e5993000 	ldr	r3, [r9]
8f604280:	e59a2000 	ldr	r2, [r10]
8f604284:	e0030394 	mul	r3, r4, r3
8f604288:	e0820003 	add	r0, r2, r3
8f60428c:	e19230b3 	ldrh	r3, [r2, r3]
8f604290:	e3530000 	cmp	r3, #0
8f604294:	0a000085 	beq	8f6044b0 <partition_read_table+0x588>
			       &data[(j * partition_entry_size) +
8f604298:	e59d500c 	ldr	r5, [r13, #12]
			memcpy(&
8f60429c:	e3a02010 	mov	r2, #16
			       &data[(j * partition_entry_size) +
8f6042a0:	e59d105c 	ldr	r1, [r13, #92]	; 0x5c
			memcpy(&
8f6042a4:	e2800014 	add	r0, r0, #20
			       &data[(j * partition_entry_size) +
8f6042a8:	e0215b91 	mla	r1, r1, r11, r5
			memcpy(&
8f6042ac:	e2811010 	add	r1, r1, #16
8f6042b0:	eb00bfc0 	bl	8f6341b8 <memcpy>
			    GET_LLWORD_FROM_BYTE(&data
8f6042b4:	e59d405c 	ldr	r4, [r13, #92]	; 0x5c
			partition_entries[partition_count].first_lba =
8f6042b8:	e5993000 	ldr	r3, [r9]
8f6042bc:	e3a01098 	mov	r1, #152	; 0x98
8f6042c0:	e59a2000 	ldr	r2, [r10]
			    GET_LLWORD_FROM_BYTE(&data
8f6042c4:	e0245b94 	mla	r4, r4, r11, r5
			partition_entries[partition_count].first_lba =
8f6042c8:	e0202391 	mla	r0, r1, r3, r2
			if (partition_entries[partition_count].first_lba < first_usable_lba
8f6042cc:	e1cd26d0 	ldrd	r2, [r13, #96]	; 0x60
			    GET_LLWORD_FROM_BYTE(&data
8f6042d0:	e5d46022 	ldrb	r6, [r4, #34]	; 0x22
8f6042d4:	e5d41021 	ldrb	r1, [r4, #33]	; 0x21
8f6042d8:	e5d48024 	ldrb	r8, [r4, #36]	; 0x24
8f6042dc:	e1a06806 	lsl	r6, r6, #16
			partition_entries[partition_count].first_lba =
8f6042e0:	e58d0018 	str	r0, [r13, #24]
			    GET_LLWORD_FROM_BYTE(&data
8f6042e4:	e1866401 	orr	r6, r6, r1, lsl #8
8f6042e8:	e5d41025 	ldrb	r1, [r4, #37]	; 0x25
8f6042ec:	e1888401 	orr	r8, r8, r1, lsl #8
8f6042f0:	e5d41026 	ldrb	r1, [r4, #38]	; 0x26
8f6042f4:	e1888801 	orr	r8, r8, r1, lsl #16
8f6042f8:	e5d41020 	ldrb	r1, [r4, #32]
8f6042fc:	e1866001 	orr	r6, r6, r1
8f604300:	e5d41023 	ldrb	r1, [r4, #35]	; 0x23
8f604304:	e1866c01 	orr	r6, r6, r1, lsl #24
			if (partition_entries[partition_count].first_lba < first_usable_lba
8f604308:	e1560002 	cmp	r6, r2
			    GET_LLWORD_FROM_BYTE(&data
8f60430c:	e5d42027 	ldrb	r2, [r4, #39]	; 0x27
			partition_entries[partition_count].first_lba =
8f604310:	e5806028 	str	r6, [r0, #40]	; 0x28
			    GET_LLWORD_FROM_BYTE(&data
8f604314:	e1888c02 	orr	r8, r8, r2, lsl #24
			partition_entries[partition_count].first_lba =
8f604318:	e580802c 	str	r8, [r0, #44]	; 0x2c
			    GET_LLWORD_FROM_BYTE(&data
8f60431c:	e5d4502a 	ldrb	r5, [r4, #42]	; 0x2a
			if (partition_entries[partition_count].first_lba < first_usable_lba
8f604320:	e0d83003 	sbcs	r3, r8, r3
			    GET_LLWORD_FROM_BYTE(&data
8f604324:	e5d43029 	ldrb	r3, [r4, #41]	; 0x29
8f604328:	e5d4702c 	ldrb	r7, [r4, #44]	; 0x2c
8f60432c:	e1a05805 	lsl	r5, r5, #16
8f604330:	e1855403 	orr	r5, r5, r3, lsl #8
8f604334:	e5d4302d 	ldrb	r3, [r4, #45]	; 0x2d
8f604338:	e1877403 	orr	r7, r7, r3, lsl #8
8f60433c:	e5d4302e 	ldrb	r3, [r4, #46]	; 0x2e
8f604340:	e1877803 	orr	r7, r7, r3, lsl #16
8f604344:	e5d43028 	ldrb	r3, [r4, #40]	; 0x28
8f604348:	e1855003 	orr	r5, r5, r3
8f60434c:	e5d4302b 	ldrb	r3, [r4, #43]	; 0x2b
8f604350:	e1855c03 	orr	r5, r5, r3, lsl #24
8f604354:	e5d4302f 	ldrb	r3, [r4, #47]	; 0x2f
			partition_entries[partition_count].last_lba =
8f604358:	e5805030 	str	r5, [r0, #48]	; 0x30
			    GET_LLWORD_FROM_BYTE(&data
8f60435c:	e1877c03 	orr	r7, r7, r3, lsl #24
			partition_entries[partition_count].last_lba =
8f604360:	e5807034 	str	r7, [r0, #52]	; 0x34
			if (partition_entries[partition_count].first_lba < first_usable_lba
8f604364:	3affffb1 	bcc	8f604230 <partition_read_table+0x308>
						(device_density/block_size -
8f604368:	e3a03000 	mov	r3, #0
8f60436c:	e59d2010 	ldr	r2, [r13, #16]
8f604370:	e1cd02d0 	ldrd	r0, [r13, #32]
8f604374:	fa00e38a 	blx	8f63d1a4 <__aeabi_uldivmod>
						(blocks_for_entries + GPT_HEADER_BLOCKS + 1))
8f604378:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f60437c:	e2833002 	add	r3, r3, #2
						(device_density/block_size -
8f604380:	e0500003 	subs	r0, r0, r3
8f604384:	e2c11000 	sbc	r1, r1, #0
				|| partition_entries[partition_count].last_lba >
8f604388:	e1500005 	cmp	r0, r5
8f60438c:	e0d13007 	sbcs	r3, r1, r7
8f604390:	33a01001 	movcc	r1, #1
8f604394:	23a01000 	movcs	r1, #0
				|| partition_entries[partition_count].first_lba >
8f604398:	e1550006 	cmp	r5, r6
8f60439c:	e0d73008 	sbcs	r3, r7, r8
8f6043a0:	33811001 	orrcc	r1, r1, #1
8f6043a4:	e3510000 	cmp	r1, #0
8f6043a8:	1affffa0 	bne	8f604230 <partition_read_table+0x308>
			partition_entries[partition_count].size =
8f6043ac:	e59dc018 	ldr	r12, [r13, #24]
			    partition_entries[partition_count].first_lba + 1;
8f6043b0:	e2955001 	adds	r5, r5, #1
8f6043b4:	e2a77000 	adc	r7, r7, #0
8f6043b8:	e0555006 	subs	r5, r5, r6
8f6043bc:	e0c78008 	sbc	r8, r7, r8
			partition_entries[partition_count].size =
8f6043c0:	e58c5038 	str	r5, [r12, #56]	; 0x38
			partition_entries[partition_count].lun = mmc_get_lun();
8f6043c4:	e3a05098 	mov	r5, #152	; 0x98
			partition_entries[partition_count].size =
8f6043c8:	e58c803c 	str	r8, [r12, #60]	; 0x3c
			    GET_LLWORD_FROM_BYTE(&data
8f6043cc:	e5d43032 	ldrb	r3, [r4, #50]	; 0x32
8f6043d0:	e5d42031 	ldrb	r2, [r4, #49]	; 0x31
8f6043d4:	e5d40035 	ldrb	r0, [r4, #53]	; 0x35
8f6043d8:	e1a03803 	lsl	r3, r3, #16
8f6043dc:	e1833402 	orr	r3, r3, r2, lsl #8
8f6043e0:	e5d42034 	ldrb	r2, [r4, #52]	; 0x34
8f6043e4:	e1822400 	orr	r2, r2, r0, lsl #8
8f6043e8:	e5d40036 	ldrb	r0, [r4, #54]	; 0x36
8f6043ec:	e1822800 	orr	r2, r2, r0, lsl #16
8f6043f0:	e5d40030 	ldrb	r0, [r4, #48]	; 0x30
8f6043f4:	e1833000 	orr	r3, r3, r0
8f6043f8:	e5d40033 	ldrb	r0, [r4, #51]	; 0x33
8f6043fc:	e1833c00 	orr	r3, r3, r0, lsl #24
8f604400:	e5d40037 	ldrb	r0, [r4, #55]	; 0x37
			partition_entries[partition_count].attribute_flag =
8f604404:	e58c3040 	str	r3, [r12, #64]	; 0x40
			    GET_LLWORD_FROM_BYTE(&data
8f604408:	e1823c00 	orr	r3, r2, r0, lsl #24
			memset(&UTF16_name, 0x00, MAX_GPT_NAME_SIZE);
8f60440c:	e3a02048 	mov	r2, #72	; 0x48
			partition_entries[partition_count].attribute_flag =
8f604410:	e58c3044 	str	r3, [r12, #68]	; 0x44
			memset(&UTF16_name, 0x00, MAX_GPT_NAME_SIZE);
8f604414:	e28d006c 	add	r0, r13, #108	; 0x6c
8f604418:	eb00bfa9 	bl	8f6342c4 <memset>
			memcpy(UTF16_name, &data[(j * partition_entry_size) +
8f60441c:	e59d300c 	ldr	r3, [r13, #12]
8f604420:	e59d105c 	ldr	r1, [r13, #92]	; 0x5c
8f604424:	e3a02048 	mov	r2, #72	; 0x48
8f604428:	e28d006c 	add	r0, r13, #108	; 0x6c
8f60442c:	e0213b91 	mla	r1, r1, r11, r3
8f604430:	e2811038 	add	r1, r1, #56	; 0x38
8f604434:	eb00bf5f 	bl	8f6341b8 <memcpy>
			partition_entries[partition_count].lun = mmc_get_lun();
8f604438:	e5993000 	ldr	r3, [r9]
8f60443c:	e59a4000 	ldr	r4, [r10]
8f604440:	e0244395 	mla	r4, r5, r3, r4
8f604444:	eb002410 	bl	8f60d48c <mmc_get_lun>
8f604448:	e59a2000 	ldr	r2, [r10]
				partition_entries[partition_count].name[n] =
8f60444c:	e3a03001 	mov	r3, #1
			partition_entries[partition_count].lun = mmc_get_lun();
8f604450:	e5c40090 	strb	r0, [r4, #144]	; 0x90
				partition_entries[partition_count].name[n] =
8f604454:	e5990000 	ldr	r0, [r9]
8f604458:	e0010095 	mul	r1, r5, r0
8f60445c:	e2811047 	add	r1, r1, #71	; 0x47
8f604460:	e0822001 	add	r2, r2, r1
				    UTF16_name[n * 2];
8f604464:	e28d106c 	add	r1, r13, #108	; 0x6c
8f604468:	e0811083 	add	r1, r1, r3, lsl #1
			for (n = 0; n < MAX_GPT_NAME_SIZE / 2; n++) {
8f60446c:	e2833001 	add	r3, r3, #1
8f604470:	e3530025 	cmp	r3, #37	; 0x25
				    UTF16_name[n * 2];
8f604474:	e5511002 	ldrb	r1, [r1, #-2]
				partition_entries[partition_count].name[n] =
8f604478:	e5e21001 	strb	r1, [r2, #1]!
			for (n = 0; n < MAX_GPT_NAME_SIZE / 2; n++) {
8f60447c:	1afffff8 	bne	8f604464 <partition_read_table+0x53c>
		for (j = 0; j < part_entry_cnt; j++) {
8f604480:	e59d3014 	ldr	r3, [r13, #20]
8f604484:	e28bb001 	add	r11, r11, #1
			partition_count++;
8f604488:	e2800001 	add	r0, r0, #1
8f60448c:	e5890000 	str	r0, [r9]
		for (j = 0; j < part_entry_cnt; j++) {
8f604490:	e153000b 	cmp	r3, r11
8f604494:	1affff6f 	bne	8f604258 <partition_read_table+0x330>
	for (i = 0; i < (ROUNDUP(max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f604498:	e59d0058 	ldr	r0, [r13, #88]	; 0x58
8f60449c:	e2400001 	sub	r0, r0, #1
8f6044a0:	e0800003 	add	r0, r0, r3
8f6044a4:	e59d3038 	ldr	r3, [r13, #56]	; 0x38
8f6044a8:	e0000003 	and	r0, r0, r3
8f6044ac:	ea000007 	b	8f6044d0 <partition_read_table+0x5a8>
				i = ROUNDUP(max_partition_count, part_entry_cnt);
8f6044b0:	e59d3058 	ldr	r3, [r13, #88]	; 0x58
8f6044b4:	e59d2014 	ldr	r2, [r13, #20]
8f6044b8:	e2433001 	sub	r3, r3, #1
8f6044bc:	e0833002 	add	r3, r3, r2
8f6044c0:	e59d2038 	ldr	r2, [r13, #56]	; 0x38
8f6044c4:	e0033002 	and	r3, r3, r2
8f6044c8:	e58d302c 	str	r3, [r13, #44]	; 0x2c
				break;
8f6044cc:	e1a00003 	mov	r0, r3
	for (i = 0; i < (ROUNDUP(max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f6044d0:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
8f6044d4:	e59d1014 	ldr	r1, [r13, #20]
8f6044d8:	e2834001 	add	r4, r3, #1
8f6044dc:	e58d402c 	str	r4, [r13, #44]	; 0x2c
8f6044e0:	fa00e1bc 	blx	8f63cbd8 <__udivsi3>
8f6044e4:	e1540000 	cmp	r4, r0
8f6044e8:	3affff42 	bcc	8f6041f8 <partition_read_table+0x2d0>
		free(data_org_ptr);
8f6044ec:	e59d003c 	ldr	r0, [r13, #60]	; 0x3c
8f6044f0:	eb00bf05 	bl	8f63410c <free>
	if (new_buffer)
8f6044f4:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f6044f8:	e5930000 	ldr	r0, [r3]
8f6044fc:	e3500000 	cmp	r0, #0
8f604500:	0a000000 	beq	8f604508 <partition_read_table+0x5e0>
		free(new_buffer);
8f604504:	eb00bf00 	bl	8f63410c <free>
	partition_scan_for_multislot();
8f604508:	eb00023d 	bl	8f604e04 <partition_scan_for_multislot>
	partition_split_boot(block_size);
8f60450c:	e59d0010 	ldr	r0, [r13, #16]
8f604510:	ebfffe22 	bl	8f603da0 <partition_split_boot>
	return 0;
8f604514:	eafffeb6 	b	8f603ff4 <partition_read_table+0xcc>
		ASSERT(partition_count < NUM_PARTITIONS);
8f604518:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f60451c:	e59d2048 	ldr	r2, [r13, #72]	; 0x48
8f604520:	e59d104c 	ldr	r1, [r13, #76]	; 0x4c
8f604524:	e58d3000 	str	r3, [r13]
8f604528:	e3003173 	movw	r3, #371	; 0x173
8f60452c:	e59d0040 	ldr	r0, [r13, #64]	; 0x40
8f604530:	eb00b961 	bl	8f632abc <_panic>
8f604534:	eaffff32 	b	8f604204 <partition_read_table+0x2dc>
		partition_entries = (struct partition_entry *) calloc(NUM_PARTITIONS, sizeof(struct partition_entry));
8f604538:	e3a01098 	mov	r1, #152	; 0x98
8f60453c:	e3a00080 	mov	r0, #128	; 0x80
8f604540:	eb00bed7 	bl	8f6340a4 <calloc>
		ASSERT(partition_entries);
8f604544:	e3500000 	cmp	r0, #0
		partition_entries = (struct partition_entry *) calloc(NUM_PARTITIONS, sizeof(struct partition_entry));
8f604548:	e58b0000 	str	r0, [r11]
		ASSERT(partition_entries);
8f60454c:	1afffe83 	bne	8f603f60 <partition_read_table+0x38>
8f604550:	e59d0040 	ldr	r0, [r13, #64]	; 0x40
8f604554:	e301106c 	movw	r1, #4204	; 0x106c
8f604558:	e3012044 	movw	r2, #4164	; 0x1044
8f60455c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f604560:	e3482f70 	movt	r2, #36720	; 0x8f70
8f604564:	e58d1000 	str	r1, [r13]
8f604568:	e3a0308d 	mov	r3, #141	; 0x8d
8f60456c:	e3001130 	movw	r1, #304	; 0x130
8f604570:	e3481f70 	movt	r1, #36720	; 0x8f70
8f604574:	eb00b950 	bl	8f632abc <_panic>
8f604578:	eafffe78 	b	8f603f60 <partition_read_table+0x38>
		dprintf(CRITICAL, "GPT: Could not read primary gpt from mmc\n");
8f60457c:	e3000f0c 	movw	r0, #3852	; 0xf0c
8f604580:	e3480f70 	movt	r0, #36720	; 0x8f70
8f604584:	eb00b8fa 	bl	8f632974 <_dprintf>
		free(data_org_ptr);
8f604588:	e59d003c 	ldr	r0, [r13, #60]	; 0x3c
8f60458c:	eb00bede 	bl	8f63410c <free>
	if (new_buffer)
8f604590:	e30b3d84 	movw	r3, #48516	; 0xbd84
8f604594:	e3483f72 	movt	r3, #36722	; 0x8f72
8f604598:	e5930000 	ldr	r0, [r3]
8f60459c:	e3500000 	cmp	r0, #0
8f6045a0:	1a00009d 	bne	8f60481c <partition_read_table+0x8f4>
			dprintf(CRITICAL, "MMC Boot: GPT read failed!\n");
8f6045a4:	e3010218 	movw	r0, #4632	; 0x1218
8f6045a8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6045ac:	eb00b8f0 	bl	8f632974 <_dprintf>
			return 1;
8f6045b0:	e3a03001 	mov	r3, #1
8f6045b4:	e58d3030 	str	r3, [r13, #48]	; 0x30
8f6045b8:	eafffe8d 	b	8f603ff4 <partition_read_table+0xcc>
	ret = mmc_read((EBR_first_sec * block_size), (unsigned int *)buffer, block_size);
8f6045bc:	e59d3010 	ldr	r3, [r13, #16]
8f6045c0:	e3a01000 	mov	r1, #0
8f6045c4:	e59d200c 	ldr	r2, [r13, #12]
8f6045c8:	e0000394 	mul	r0, r4, r3
8f6045cc:	eb0021ad 	bl	8f60cc88 <mmc_read>
	if (ret)
8f6045d0:	e2508000 	subs	r8, r0, #0
8f6045d4:	1afffe92 	bne	8f604024 <partition_read_table+0xfc>
		    GET_LWORD_FROM_BYTE(&buffer[idx +
8f6045d8:	e1a05004 	mov	r5, r4
		partition_entries[partition_count].attribute_flag =
8f6045dc:	e58d7018 	str	r7, [r13, #24]
8f6045e0:	e58d4014 	str	r4, [r13, #20]
		dprintf(SPEW, "Reading EBR block from 0x%X\n", EBR_first_sec
8f6045e4:	e30190fc 	movw	r9, #4348	; 0x10fc
		partition_entries[partition_count].attribute_flag =
8f6045e8:	e59d7010 	ldr	r7, [r13, #16]
		dprintf(SPEW, "Reading EBR block from 0x%X\n", EBR_first_sec
8f6045ec:	e3489f70 	movt	r9, #36720	; 0x8f70
		partition_entries[partition_count].attribute_flag =
8f6045f0:	e59d400c 	ldr	r4, [r13, #12]
8f6045f4:	e3a0a098 	mov	r10, #152	; 0x98
	if ((buffer[TABLE_SIGNATURE] != MMC_MBR_SIGNATURE_BYTE_0) ||
8f6045f8:	e5d431fe 	ldrb	r3, [r4, #510]	; 0x1fe
8f6045fc:	e3530055 	cmp	r3, #85	; 0x55
8f604600:	1a000002 	bne	8f604610 <partition_read_table+0x6e8>
8f604604:	e5d431ff 	ldrb	r3, [r4, #511]	; 0x1ff
8f604608:	e35300aa 	cmp	r3, #170	; 0xaa
8f60460c:	0a000008 	beq	8f604634 <partition_read_table+0x70c>
		dprintf(CRITICAL, "MBR signature does not match.\n");
8f604610:	e30100dc 	movw	r0, #4316	; 0x10dc
8f604614:	e3480f70 	movt	r0, #36720	; 0x8f70
8f604618:	e59d7018 	ldr	r7, [r13, #24]
8f60461c:	eb00b8d4 	bl	8f632974 <_dprintf>
		free(buffer);
8f604620:	e59d000c 	ldr	r0, [r13, #12]
8f604624:	e30b4d80 	movw	r4, #48512	; 0xbd80
8f604628:	eb00beb7 	bl	8f63410c <free>
	if (ret) {
8f60462c:	e3484f72 	movt	r4, #36722	; 0x8f72
8f604630:	eafffeb2 	b	8f604100 <partition_read_table+0x1d8>
		partition_entries[partition_count].attribute_flag =
8f604634:	e5963000 	ldr	r3, [r6]
8f604638:	e59b0000 	ldr	r0, [r11]
8f60463c:	e020039a 	mla	r0, r10, r3, r0
		    buffer[TABLE_ENTRY_0 + OFFSET_STATUS];
8f604640:	e5d431be 	ldrb	r3, [r4, #446]	; 0x1be
8f604644:	e5808044 	str	r8, [r0, #68]	; 0x44
8f604648:	e5803040 	str	r3, [r0, #64]	; 0x40
		    buffer[TABLE_ENTRY_0 + OFFSET_TYPE];
8f60464c:	e5d411c2 	ldrb	r1, [r4, #450]	; 0x1c2
		partition_entries[partition_count].dtype =
8f604650:	e5801010 	str	r1, [r0, #16]
		    GET_LWORD_FROM_BYTE(&buffer[TABLE_ENTRY_0 +
8f604654:	e59431c6 	ldr	r3, [r4, #454]	; 0x1c6
						OFFSET_FIRST_SEC]) +
8f604658:	e580802c 	str	r8, [r0, #44]	; 0x2c
8f60465c:	e0835005 	add	r5, r3, r5
8f604660:	e5805028 	str	r5, [r0, #40]	; 0x28
		    GET_LWORD_FROM_BYTE(&buffer[TABLE_ENTRY_0 + OFFSET_SIZE]);
8f604664:	e59431ca 	ldr	r3, [r4, #458]	; 0x1ca
8f604668:	e580803c 	str	r8, [r0, #60]	; 0x3c
8f60466c:	e5803038 	str	r3, [r0, #56]	; 0x38
		mbr_fill_name(&(partition_entries[partition_count]),
8f604670:	ebfffaff 	bl	8f603274 <mbr_fill_name>
		partition_count++;
8f604674:	e5963000 	ldr	r3, [r6]
8f604678:	e2833001 	add	r3, r3, #1
8f60467c:	e5863000 	str	r3, [r6]
		if (partition_count == NUM_PARTITIONS)
8f604680:	e3530080 	cmp	r3, #128	; 0x80
8f604684:	0a000042 	beq	8f604794 <partition_read_table+0x86c>
		dfirstsec =
8f604688:	e59451d6 	ldr	r5, [r4, #470]	; 0x1d6
		if (dfirstsec == 0) {
8f60468c:	e3550000 	cmp	r5, #0
8f604690:	0a00003f 	beq	8f604794 <partition_read_table+0x86c>
		dprintf(SPEW, "Reading EBR block from 0x%X\n", EBR_first_sec
8f604694:	e59d3014 	ldr	r3, [r13, #20]
8f604698:	e1a00009 	mov	r0, r9
8f60469c:	e0835005 	add	r5, r3, r5
8f6046a0:	e1a01005 	mov	r1, r5
8f6046a4:	eb00b8b2 	bl	8f632974 <_dprintf>
		ret = mmc_read(((EBR_first_sec + dfirstsec) * block_size),(unsigned int *)buffer,
8f6046a8:	e0000795 	mul	r0, r5, r7
8f6046ac:	e1a03007 	mov	r3, r7
8f6046b0:	e1a02004 	mov	r2, r4
8f6046b4:	e3a01000 	mov	r1, #0
8f6046b8:	eb002172 	bl	8f60cc88 <mmc_read>
		if (ret)
8f6046bc:	e3500000 	cmp	r0, #0
8f6046c0:	0affffcc 	beq	8f6045f8 <partition_read_table+0x6d0>
8f6046c4:	eafffe56 	b	8f604024 <partition_read_table+0xfc>
		dprintf(INFO, "GPT: (WARNING) Primary signature invalid\n");
8f6046c8:	e3010138 	movw	r0, #4408	; 0x1138
8f6046cc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6046d0:	eb00b8a7 	bl	8f632974 <_dprintf>
		card_size_sec = (device_density) / block_size;
8f6046d4:	e59d5010 	ldr	r5, [r13, #16]
8f6046d8:	e1a03004 	mov	r3, r4
8f6046dc:	e59d6024 	ldr	r6, [r13, #36]	; 0x24
8f6046e0:	e59d4020 	ldr	r4, [r13, #32]
8f6046e4:	e1a02005 	mov	r2, r5
8f6046e8:	e1a01006 	mov	r1, r6
8f6046ec:	e1a00004 	mov	r0, r4
8f6046f0:	fa00e2ab 	blx	8f63d1a4 <__aeabi_uldivmod>
		ASSERT (card_size_sec > 0);
8f6046f4:	e1540005 	cmp	r4, r5
8f6046f8:	e2d63000 	sbcs	r3, r6, #0
		card_size_sec = (device_density) / block_size;
8f6046fc:	e1a05001 	mov	r5, r1
8f604700:	e1a04000 	mov	r4, r0
		ASSERT (card_size_sec > 0);
8f604704:	3a000030 	bcc	8f6047cc <partition_read_table+0x8a4>
		ret = mmc_read((backup_header_lba * block_size), (unsigned int *)data,
8f604708:	e59d2010 	ldr	r2, [r13, #16]
		backup_header_lba = card_size_sec - 1;
8f60470c:	e2544001 	subs	r4, r4, #1
8f604710:	e2c55000 	sbc	r5, r5, #0
		ret = mmc_read((backup_header_lba * block_size), (unsigned int *)data,
8f604714:	e0840294 	umull	r0, r4, r4, r2
8f604718:	e1a03002 	mov	r3, r2
8f60471c:	e0214592 	mla	r1, r2, r5, r4
8f604720:	e59d203c 	ldr	r2, [r13, #60]	; 0x3c
8f604724:	eb002157 	bl	8f60cc88 <mmc_read>
		if (ret) {
8f604728:	e3500000 	cmp	r0, #0
8f60472c:	1a00001a 	bne	8f60479c <partition_read_table+0x874>
		parse_secondary_gpt = 1;
8f604730:	e30b4d88 	movw	r4, #48520	; 0xbd88
8f604734:	e3484f72 	movt	r4, #36722	; 0x8f72
		ret = partition_parse_gpt_header(data, &first_usable_lba,
8f604738:	e28d3058 	add	r3, r13, #88	; 0x58
		parse_secondary_gpt = 1;
8f60473c:	e3a0c001 	mov	r12, #1
		ret = partition_parse_gpt_header(data, &first_usable_lba,
8f604740:	e58d3000 	str	r3, [r13]
8f604744:	e28d205c 	add	r2, r13, #92	; 0x5c
8f604748:	e59d003c 	ldr	r0, [r13, #60]	; 0x3c
8f60474c:	e28d3054 	add	r3, r13, #84	; 0x54
8f604750:	e28d1060 	add	r1, r13, #96	; 0x60
		parse_secondary_gpt = 1;
8f604754:	e584c000 	str	r12, [r4]
		ret = partition_parse_gpt_header(data, &first_usable_lba,
8f604758:	ebfffc0b 	bl	8f60378c <partition_parse_gpt_header>
		if (ret) {
8f60475c:	e3500000 	cmp	r0, #0
		parse_secondary_gpt = 0;
8f604760:	05840000 	streq	r0, [r4]
		if (ret) {
8f604764:	0afffe84 	beq	8f60417c <partition_read_table+0x254>
			dprintf(CRITICAL,
8f604768:	e30101a4 	movw	r0, #4516	; 0x11a4
8f60476c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f604770:	eb00b87f 	bl	8f632974 <_dprintf>
			goto end;
8f604774:	eaffff83 	b	8f604588 <partition_read_table+0x660>
			gpt_partitions_exist = 1;
8f604778:	e30b4d80 	movw	r4, #48512	; 0xbd80
8f60477c:	e3484f72 	movt	r4, #36722	; 0x8f72
		free(buffer);
8f604780:	e59d000c 	ldr	r0, [r13, #12]
			gpt_partitions_exist = 1;
8f604784:	e3a03001 	mov	r3, #1
8f604788:	e5843000 	str	r3, [r4]
		free(buffer);
8f60478c:	eb00be5e 	bl	8f63410c <free>
	if (ret) {
8f604790:	eafffe5a 	b	8f604100 <partition_read_table+0x1d8>
8f604794:	e59d7018 	ldr	r7, [r13, #24]
8f604798:	eafffe54 	b	8f6040f0 <partition_read_table+0x1c8>
			dprintf(CRITICAL,
8f60479c:	e3010178 	movw	r0, #4472	; 0x1178
8f6047a0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6047a4:	eb00b872 	bl	8f632974 <_dprintf>
			goto end;
8f6047a8:	eaffff76 	b	8f604588 <partition_read_table+0x660>
		free(data_org_ptr);
8f6047ac:	e59d003c 	ldr	r0, [r13, #60]	; 0x3c
8f6047b0:	eb00be55 	bl	8f63410c <free>
	if (new_buffer)
8f6047b4:	e30b3d84 	movw	r3, #48516	; 0xbd84
8f6047b8:	e3483f72 	movt	r3, #36722	; 0x8f72
8f6047bc:	e5930000 	ldr	r0, [r3]
8f6047c0:	e3500000 	cmp	r0, #0
8f6047c4:	1affff4e 	bne	8f604504 <partition_read_table+0x5dc>
8f6047c8:	eaffff4e 	b	8f604508 <partition_read_table+0x5e0>
		ASSERT (card_size_sec > 0);
8f6047cc:	e59d0040 	ldr	r0, [r13, #64]	; 0x40
8f6047d0:	e3013164 	movw	r3, #4452	; 0x1164
8f6047d4:	e3012044 	movw	r2, #4164	; 0x1044
8f6047d8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6047dc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6047e0:	e58d3000 	str	r3, [r13]
8f6047e4:	e3001130 	movw	r1, #304	; 0x130
8f6047e8:	e300315a 	movw	r3, #346	; 0x15a
8f6047ec:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6047f0:	eb00b8b1 	bl	8f632abc <_panic>
8f6047f4:	eaffffc3 	b	8f604708 <partition_read_table+0x7e0>
}
8f6047f8:	eb00b8f0 	bl	8f632bc0 <__stack_chk_fail>
		dprintf(CRITICAL, "Failed to Allocate memory to read partition table\n");
8f6047fc:	e3000e90 	movw	r0, #3728	; 0xe90
8f604800:	e3480f70 	movt	r0, #36720	; 0x8f70
8f604804:	eb00b85a 	bl	8f632974 <_dprintf>
	if (new_buffer)
8f604808:	e30b3d84 	movw	r3, #48516	; 0xbd84
8f60480c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f604810:	e5930000 	ldr	r0, [r3]
8f604814:	e1500004 	cmp	r0, r4
8f604818:	0affff61 	beq	8f6045a4 <partition_read_table+0x67c>
		free(new_buffer);
8f60481c:	eb00be3a 	bl	8f63410c <free>
		if (ret) {
8f604820:	eaffff5f 	b	8f6045a4 <partition_read_table+0x67c>
		dprintf(CRITICAL, "Error allocating memory while reading partition table\n");
8f604824:	e3010080 	movw	r0, #4224	; 0x1080
8f604828:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60482c:	eb00b850 	bl	8f632974 <_dprintf>
	if (ret) {
8f604830:	eafffdea 	b	8f603fe0 <partition_read_table+0xb8>
8f604834:	8f74221c 	.word	0x8f74221c

8f604838 <partition_get_size>:
{
8f604838:	e59f3078 	ldr	r3, [pc, #120]	; 8f6048b8 <partition_get_size+0x80>
8f60483c:	e92d4010 	push	{r4, r14}
8f604840:	e24dd008 	sub	r13, r13, #8
8f604844:	e1a04000 	mov	r4, r0
8f604848:	e5933000 	ldr	r3, [r3]
8f60484c:	e58d3004 	str	r3, [r13, #4]
8f604850:	e3a03000 	mov	r3, #0
	block_size = mmc_get_device_blocksize();
8f604854:	eb0022c8 	bl	8f60d37c <mmc_get_device_blocksize>
	if (index == INVALID_PTN)
8f604858:	e3740001 	cmn	r4, #1
8f60485c:	0a000011 	beq	8f6048a8 <partition_get_size+0x70>
		return partition_entries[index].size * block_size;
8f604860:	e3022230 	movw	r2, #8752	; 0x2230
8f604864:	e3482f74 	movt	r2, #36724	; 0x8f74
8f604868:	e1a03000 	mov	r3, r0
8f60486c:	e3a01098 	mov	r1, #152	; 0x98
8f604870:	e5920000 	ldr	r0, [r2]
8f604874:	e0240491 	mla	r4, r1, r4, r0
8f604878:	e5940038 	ldr	r0, [r4, #56]	; 0x38
8f60487c:	e594203c 	ldr	r2, [r4, #60]	; 0x3c
8f604880:	e0810390 	umull	r0, r1, r0, r3
8f604884:	e0211293 	mla	r1, r3, r2, r1
}
8f604888:	e59f3028 	ldr	r3, [pc, #40]	; 8f6048b8 <partition_get_size+0x80>
8f60488c:	e5932000 	ldr	r2, [r3]
8f604890:	e59d3004 	ldr	r3, [r13, #4]
8f604894:	e0332002 	eors	r2, r3, r2
8f604898:	e3a03000 	mov	r3, #0
8f60489c:	1a000004 	bne	8f6048b4 <partition_get_size+0x7c>
8f6048a0:	e28dd008 	add	r13, r13, #8
8f6048a4:	e8bd8010 	pop	{r4, r15}
		return 0;
8f6048a8:	e3a00000 	mov	r0, #0
8f6048ac:	e1a01000 	mov	r1, r0
8f6048b0:	eafffff4 	b	8f604888 <partition_get_size+0x50>
}
8f6048b4:	eb00b8c1 	bl	8f632bc0 <__stack_chk_fail>
8f6048b8:	8f74221c 	.word	0x8f74221c

8f6048bc <partition_get_offset>:
{
8f6048bc:	e59f3078 	ldr	r3, [pc, #120]	; 8f60493c <partition_get_offset+0x80>
8f6048c0:	e92d4010 	push	{r4, r14}
8f6048c4:	e24dd008 	sub	r13, r13, #8
8f6048c8:	e1a04000 	mov	r4, r0
8f6048cc:	e5933000 	ldr	r3, [r3]
8f6048d0:	e58d3004 	str	r3, [r13, #4]
8f6048d4:	e3a03000 	mov	r3, #0
	block_size = mmc_get_device_blocksize();
8f6048d8:	eb0022a7 	bl	8f60d37c <mmc_get_device_blocksize>
	if (index == INVALID_PTN)
8f6048dc:	e3740001 	cmn	r4, #1
8f6048e0:	0a000011 	beq	8f60492c <partition_get_offset+0x70>
		return partition_entries[index].first_lba * block_size;
8f6048e4:	e3022230 	movw	r2, #8752	; 0x2230
8f6048e8:	e3482f74 	movt	r2, #36724	; 0x8f74
8f6048ec:	e1a03000 	mov	r3, r0
8f6048f0:	e3a01098 	mov	r1, #152	; 0x98
8f6048f4:	e5920000 	ldr	r0, [r2]
8f6048f8:	e0240491 	mla	r4, r1, r4, r0
8f6048fc:	e5940028 	ldr	r0, [r4, #40]	; 0x28
8f604900:	e594202c 	ldr	r2, [r4, #44]	; 0x2c
8f604904:	e0810390 	umull	r0, r1, r0, r3
8f604908:	e0211293 	mla	r1, r3, r2, r1
}
8f60490c:	e59f3028 	ldr	r3, [pc, #40]	; 8f60493c <partition_get_offset+0x80>
8f604910:	e5932000 	ldr	r2, [r3]
8f604914:	e59d3004 	ldr	r3, [r13, #4]
8f604918:	e0332002 	eors	r2, r3, r2
8f60491c:	e3a03000 	mov	r3, #0
8f604920:	1a000004 	bne	8f604938 <partition_get_offset+0x7c>
8f604924:	e28dd008 	add	r13, r13, #8
8f604928:	e8bd8010 	pop	{r4, r15}
		return 0;
8f60492c:	e3a00000 	mov	r0, #0
8f604930:	e1a01000 	mov	r1, r0
8f604934:	eafffff4 	b	8f60490c <partition_get_offset+0x50>
}
8f604938:	eb00b8a0 	bl	8f632bc0 <__stack_chk_fail>
8f60493c:	8f74221c 	.word	0x8f74221c

8f604940 <partition_get_lun>:
	return partition_entries[index].lun;
8f604940:	e3022230 	movw	r2, #8752	; 0x2230
8f604944:	e3482f74 	movt	r2, #36724	; 0x8f74
8f604948:	e3a01098 	mov	r1, #152	; 0x98
8f60494c:	e5923000 	ldr	r3, [r2]
{
8f604950:	e59f203c 	ldr	r2, [pc, #60]	; 8f604994 <partition_get_lun+0x54>
8f604954:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f604958:	e24dd00c 	sub	r13, r13, #12
	return partition_entries[index].lun;
8f60495c:	e0233091 	mla	r3, r1, r0, r3
{
8f604960:	e5922000 	ldr	r2, [r2]
8f604964:	e58d2004 	str	r2, [r13, #4]
8f604968:	e3a02000 	mov	r2, #0
	return partition_entries[index].lun;
8f60496c:	e5d30090 	ldrb	r0, [r3, #144]	; 0x90
}
8f604970:	e59f301c 	ldr	r3, [pc, #28]	; 8f604994 <partition_get_lun+0x54>
8f604974:	e5932000 	ldr	r2, [r3]
8f604978:	e59d3004 	ldr	r3, [r13, #4]
8f60497c:	e0332002 	eors	r2, r3, r2
8f604980:	e3a03000 	mov	r3, #0
8f604984:	1a000001 	bne	8f604990 <partition_get_lun+0x50>
8f604988:	e28dd00c 	add	r13, r13, #12
8f60498c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f604990:	eb00b88a 	bl	8f632bc0 <__stack_chk_fail>
8f604994:	8f74221c 	.word	0x8f74221c

8f604998 <partition_dump>:
{
8f604998:	e92d4df0 	push	{r4, r5, r6, r7, r8, r10, r11, r14}
	for (i = 0; i < partition_count; i++) {
8f60499c:	e30b6d8c 	movw	r6, #48524	; 0xbd8c
{
8f6049a0:	e59f30a4 	ldr	r3, [pc, #164]	; 8f604a4c <partition_dump+0xb4>
	for (i = 0; i < partition_count; i++) {
8f6049a4:	e3486f72 	movt	r6, #36722	; 0x8f72
{
8f6049a8:	e24dd028 	sub	r13, r13, #40	; 0x28
8f6049ac:	e5933000 	ldr	r3, [r3]
8f6049b0:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f6049b4:	e3a03000 	mov	r3, #0
	for (i = 0; i < partition_count; i++) {
8f6049b8:	e5963000 	ldr	r3, [r6]
8f6049bc:	e3530000 	cmp	r3, #0
8f6049c0:	0a000018 	beq	8f604a28 <partition_dump+0x90>
8f6049c4:	e3a05000 	mov	r5, #0
8f6049c8:	e3028230 	movw	r8, #8752	; 0x2230
		dprintf(SPEW,
8f6049cc:	e3017234 	movw	r7, #4660	; 0x1234
8f6049d0:	e3488f74 	movt	r8, #36724	; 0x8f74
8f6049d4:	e3487f70 	movt	r7, #36720	; 0x8f70
	for (i = 0; i < partition_count; i++) {
8f6049d8:	e1a04005 	mov	r4, r5
		dprintf(SPEW,
8f6049dc:	e5983000 	ldr	r3, [r8]
8f6049e0:	e1a01004 	mov	r1, r4
8f6049e4:	e1a00007 	mov	r0, r7
	for (i = 0; i < partition_count; i++) {
8f6049e8:	e2844001 	add	r4, r4, #1
		dprintf(SPEW,
8f6049ec:	e0833005 	add	r3, r3, r5
	for (i = 0; i < partition_count; i++) {
8f6049f0:	e2855098 	add	r5, r5, #152	; 0x98
		dprintf(SPEW,
8f6049f4:	e2832048 	add	r2, r3, #72	; 0x48
8f6049f8:	e1c3a3d0 	ldrd	r10, [r3, #48]	; 0x30
8f6049fc:	e1cda1f8 	strd	r10, [r13, #24]
8f604a00:	e1c3a2d8 	ldrd	r10, [r3, #40]	; 0x28
8f604a04:	e1cda1f0 	strd	r10, [r13, #16]
8f604a08:	e593c010 	ldr	r12, [r3, #16]
8f604a0c:	e58dc008 	str	r12, [r13, #8]
8f604a10:	e1c3a3d8 	ldrd	r10, [r3, #56]	; 0x38
8f604a14:	e1cda0f0 	strd	r10, [r13]
8f604a18:	eb00b7d5 	bl	8f632974 <_dprintf>
	for (i = 0; i < partition_count; i++) {
8f604a1c:	e5963000 	ldr	r3, [r6]
8f604a20:	e1530004 	cmp	r3, r4
8f604a24:	8affffec 	bhi	8f6049dc <partition_dump+0x44>
}
8f604a28:	e59f301c 	ldr	r3, [pc, #28]	; 8f604a4c <partition_dump+0xb4>
8f604a2c:	e5932000 	ldr	r2, [r3]
8f604a30:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f604a34:	e0332002 	eors	r2, r3, r2
8f604a38:	e3a03000 	mov	r3, #0
8f604a3c:	1a000001 	bne	8f604a48 <partition_dump+0xb0>
8f604a40:	e28dd028 	add	r13, r13, #40	; 0x28
8f604a44:	e8bd8df0 	pop	{r4, r5, r6, r7, r8, r10, r11, r15}
8f604a48:	eb00b85c 	bl	8f632bc0 <__stack_chk_fail>
8f604a4c:	8f74221c 	.word	0x8f74221c

8f604a50 <mark_all_partitions_active>:
Function: To set active bit of all partitions of actve slot.
	also, unset active bits of all other slot
*/
static void
mark_all_partitions_active(signed slot)
{
8f604a50:	e59f30dc 	ldr	r3, [pc, #220]	; 8f604b34 <mark_all_partitions_active+0xe4>
8f604a54:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f604a58:	e24dd00c 	sub	r13, r13, #12
8f604a5c:	e5933000 	ldr	r3, [r3]
8f604a60:	e58d3004 	str	r3, [r13, #4]
8f604a64:	e3a03000 	mov	r3, #0
8f604a68:	e1a08000 	mov	r8, r0
	int i,j;
	char *pname = NULL;
	char *suffix_str = NULL;
	struct partition_entry *partition_entries =
				partition_get_partition_entries();
8f604a6c:	ebfffc5c 	bl	8f603be4 <partition_get_partition_entries>
8f604a70:	e1a09000 	mov	r9, r0
	int partition_count = partition_get_partition_count();
8f604a74:	ebfffc47 	bl	8f603b98 <partition_get_partition_count>

	for (i=0; i<partition_count; i++)
8f604a78:	e2504000 	subs	r4, r0, #0
8f604a7c:	da000014 	ble	8f604ad4 <mark_all_partitions_active+0x84>
8f604a80:	e3a00098 	mov	r0, #152	; 0x98
	dprintf(INFO, "Transversing partition %s\n", pname);
#endif
		/* 1. Find partition, if it is A/B enabled. */
		for ( j = 0; j<AB_SUPPORTED_SLOTS; j++)
		{
			suffix_str = strstr(pname, SUFFIX_SLOT(j));
8f604a84:	e30152e0 	movw	r5, #4832	; 0x12e0
8f604a88:	e0249490 	mla	r4, r0, r4, r9
8f604a8c:	e3485f71 	movt	r5, #36721	; 0x8f71
8f604a90:	e2899048 	add	r9, r9, #72	; 0x48
8f604a94:	e5956000 	ldr	r6, [r5]
8f604a98:	e5957004 	ldr	r7, [r5, #4]
8f604a9c:	e2844048 	add	r4, r4, #72	; 0x48
8f604aa0:	e1a01006 	mov	r1, r6
8f604aa4:	e1a00009 	mov	r0, r9
8f604aa8:	eb00bfd6 	bl	8f634a08 <strstr>
			if (suffix_str)
8f604aac:	e3500000 	cmp	r0, #0
8f604ab0:	1a000013 	bne	8f604b04 <mark_all_partitions_active+0xb4>
			suffix_str = strstr(pname, SUFFIX_SLOT(j));
8f604ab4:	e1a01007 	mov	r1, r7
8f604ab8:	e1a00009 	mov	r0, r9
8f604abc:	eb00bfd1 	bl	8f634a08 <strstr>
			if (suffix_str)
8f604ac0:	e3500000 	cmp	r0, #0
8f604ac4:	1a00000e 	bne	8f604b04 <mark_all_partitions_active+0xb4>
	for (i=0; i<partition_count; i++)
8f604ac8:	e2899098 	add	r9, r9, #152	; 0x98
8f604acc:	e1590004 	cmp	r9, r4
8f604ad0:	1afffff2 	bne	8f604aa0 <mark_all_partitions_active+0x50>
			else
				/* 2b. Unset active bit for all other partitions. */
				partition_entries[i].attribute_flag &= ~PART_ATT_ACTIVE_VAL;
		}
	}
	attributes_updated = true;
8f604ad4:	e30b3d98 	movw	r3, #48536	; 0xbd98
8f604ad8:	e3483f72 	movt	r3, #36722	; 0x8f72
8f604adc:	e3a02001 	mov	r2, #1
8f604ae0:	e5832000 	str	r2, [r3]
}
8f604ae4:	e59f3048 	ldr	r3, [pc, #72]	; 8f604b34 <mark_all_partitions_active+0xe4>
8f604ae8:	e5932000 	ldr	r2, [r3]
8f604aec:	e59d3004 	ldr	r3, [r13, #4]
8f604af0:	e0332002 	eors	r2, r3, r2
8f604af4:	e3a03000 	mov	r3, #0
8f604af8:	1a00000c 	bne	8f604b30 <mark_all_partitions_active+0xe0>
8f604afc:	e28dd00c 	add	r13, r13, #12
8f604b00:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
			if (!strcmp(suffix_str, SUFFIX_SLOT(slot)))
8f604b04:	e7951108 	ldr	r1, [r5, r8, lsl #2]
8f604b08:	eb00be85 	bl	8f634524 <strcmp>
8f604b0c:	e3500000 	cmp	r0, #0
				partition_entries[i].attribute_flag |= PART_ATT_ACTIVE_VAL;
8f604b10:	05193004 	ldreq	r3, [r9, #-4]
8f604b14:	03833701 	orreq	r3, r3, #262144	; 0x40000
8f604b18:	05093004 	streq	r3, [r9, #-4]
8f604b1c:	0affffe9 	beq	8f604ac8 <mark_all_partitions_active+0x78>
				partition_entries[i].attribute_flag &= ~PART_ATT_ACTIVE_VAL;
8f604b20:	e5193004 	ldr	r3, [r9, #-4]
8f604b24:	e3c33701 	bic	r3, r3, #262144	; 0x40000
8f604b28:	e5093004 	str	r3, [r9, #-4]
8f604b2c:	eaffffe5 	b	8f604ac8 <mark_all_partitions_active+0x78>
}
8f604b30:	eb00b822 	bl	8f632bc0 <__stack_chk_fail>
8f604b34:	8f74221c 	.word	0x8f74221c

8f604b38 <update_gpt>:
*/
static int
update_gpt(uint64_t gpt_start_addr,
		uint64_t gpt_hdr_offset,
		uint64_t gpt_entries_offset)
{
8f604b38:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f604b3c:	e24dd01c 	sub	r13, r13, #28
8f604b40:	e59f3250 	ldr	r3, [pc, #592]	; 8f604d98 <update_gpt+0x260>
8f604b44:	e1a0a002 	mov	r10, r2
8f604b48:	e1cd00f0 	strd	r0, [r13]
8f604b4c:	e59db040 	ldr	r11, [r13, #64]	; 0x40
8f604b50:	e5933000 	ldr	r3, [r3]
8f604b54:	e58d3014 	str	r3, [r13, #20]
8f604b58:	e3a03000 	mov	r3, #0
	char *buffer = NULL;
	char *gpt_entries_ptr, *gpt_hdr_ptr, *tmp = NULL;
	struct partition_entry *partition_entries = partition_get_partition_entries();
8f604b5c:	ebfffc20 	bl	8f603be4 <partition_get_partition_entries>
8f604b60:	e1a04000 	mov	r4, r0
	uint32_t partition_count = partition_get_partition_count();
8f604b64:	ebfffc0b 	bl	8f603b98 <partition_get_partition_count>
8f604b68:	e1a07000 	mov	r7, r0
	unsigned i,max_partition_count = 0;
	unsigned partition_entry_size = 0;
	uint32_t block_size = mmc_get_device_blocksize();
8f604b6c:	eb002202 	bl	8f60d37c <mmc_get_device_blocksize>
8f604b70:	e1a06000 	mov	r6, r0
	uint64_t max_gpt_size_bytes =
		(PARTITION_ENTRY_SIZE*NUM_PARTITIONS + GPT_HEADER_BLOCKS*block_size);
	int lun = -1;

	/* Get Current LUN for UFS target */
	if (!platform_boot_dev_isemmc())
8f604b74:	eb00735b 	bl	8f6218e8 <platform_boot_dev_isemmc>
		(PARTITION_ENTRY_SIZE*NUM_PARTITIONS + GPT_HEADER_BLOCKS*block_size);
8f604b78:	e2863901 	add	r3, r6, #16384	; 0x4000
8f604b7c:	e58d300c 	str	r3, [r13, #12]
	if (!platform_boot_dev_isemmc())
8f604b80:	e3500000 	cmp	r0, #0
	int lun = -1;
8f604b84:	13e05000 	mvnne	r5, #0
	if (!platform_boot_dev_isemmc())
8f604b88:	0a000069 	beq	8f604d34 <update_gpt+0x1fc>
		lun = mmc_get_lun();

	buffer = memalign(CACHE_LINE, ROUNDUP(max_gpt_size_bytes, CACHE_LINE));
8f604b8c:	e2861901 	add	r1, r6, #16384	; 0x4000
8f604b90:	e3a00040 	mov	r0, #64	; 0x40
8f604b94:	e281103f 	add	r1, r1, #63	; 0x3f
8f604b98:	e3c1103f 	bic	r1, r1, #63	; 0x3f
8f604b9c:	eb00bd28 	bl	8f634044 <memalign>
	if (!buffer)
8f604ba0:	e2508000 	subs	r8, r0, #0
8f604ba4:	0a000076 	beq	8f604d84 <update_gpt+0x24c>
	{
		dprintf(CRITICAL, "update_gpt: Failed at memory allocation\n");
		goto out;
	}

	ret = mmc_read(gpt_start_addr, (uint32_t *)buffer,
8f604ba8:	e1cd00d0 	ldrd	r0, [r13]
8f604bac:	e2863901 	add	r3, r6, #16384	; 0x4000
8f604bb0:	e1a02008 	mov	r2, r8
8f604bb4:	eb002033 	bl	8f60cc88 <mmc_read>
				max_gpt_size_bytes);
	if (ret)
8f604bb8:	e2509000 	subs	r9, r0, #0
8f604bbc:	1a000063 	bne	8f604d50 <update_gpt+0x218>
		dprintf(CRITICAL, "Failed to read GPT\n");
		goto out;
	}

	/* 0. Intialise ptrs for header and entries */
	gpt_entries_ptr = buffer + gpt_entries_offset*block_size;
8f604bc0:	e023869b 	mla	r3, r11, r6, r8
	gpt_hdr_ptr = buffer + gpt_hdr_offset*block_size;

	/* 1. Update attributes_flag of partition entry */
	tmp = gpt_entries_ptr;
	for (i=0;i<partition_count;i++)
8f604bc4:	e3570000 	cmp	r7, #0
	gpt_hdr_ptr = buffer + gpt_hdr_offset*block_size;
8f604bc8:	e026869a 	mla	r6, r10, r6, r8
	for (i=0;i<partition_count;i++)
8f604bcc:	11a0a009 	movne	r10, r9
	gpt_entries_ptr = buffer + gpt_entries_offset*block_size;
8f604bd0:	e58d3008 	str	r3, [r13, #8]
	tmp = gpt_entries_ptr;
8f604bd4:	159db008 	ldrne	r11, [r13, #8]
	for (i=0;i<partition_count;i++)
8f604bd8:	0a000021 	beq	8f604c64 <update_gpt+0x12c>
	{
		if (lun != -1)
8f604bdc:	e3750001 	cmn	r5, #1
8f604be0:	0a000003 	beq	8f604bf4 <update_gpt+0xbc>
		{
			/* Partition table is populated with entries from lun 0 to max lun.
			* break out of the loop once we see the partition lun is > current lun */
			if (partition_entries[i].lun > lun)
8f604be4:	e5d43090 	ldrb	r3, [r4, #144]	; 0x90
8f604be8:	e1530005 	cmp	r3, r5
8f604bec:	ca00001c 	bgt	8f604c64 <update_gpt+0x12c>
				break;
			/* Find the entry where the partition table for 'lun' starts
			and then update the attributes */
			if (partition_entries[i].lun != lun)
8f604bf0:	1a000017 	bne	8f604c54 <update_gpt+0x11c>
				continue;
		}

		/* Update the partition attributes */
		PUT_LONG_LONG(&tmp[ATTRIBUTE_FLAG_OFFSET],
8f604bf4:	e5943040 	ldr	r3, [r4, #64]	; 0x40
			partition_entries[i].attribute_flag);
		memscpy(tmp, PARTITION_TYPE_GUID_SIZE, partition_entries[i].type_guid,
8f604bf8:	e1a0000b 	mov	r0, r11
8f604bfc:	e1a02004 	mov	r2, r4
				PARTITION_TYPE_GUID_SIZE);

		/* point to the next partition entry */
		tmp += PARTITION_ENTRY_SIZE;
8f604c00:	e28bb080 	add	r11, r11, #128	; 0x80
		PUT_LONG_LONG(&tmp[ATTRIBUTE_FLAG_OFFSET],
8f604c04:	e54b3050 	strb	r3, [r11, #-80]	; 0xffffffb0
8f604c08:	e5943040 	ldr	r3, [r4, #64]	; 0x40
8f604c0c:	e1a03423 	lsr	r3, r3, #8
8f604c10:	e54b304f 	strb	r3, [r11, #-79]	; 0xffffffb1
8f604c14:	e1d434b2 	ldrh	r3, [r4, #66]	; 0x42
8f604c18:	e54b304e 	strb	r3, [r11, #-78]	; 0xffffffb2
8f604c1c:	e5d43043 	ldrb	r3, [r4, #67]	; 0x43
8f604c20:	e54b304d 	strb	r3, [r11, #-77]	; 0xffffffb3
8f604c24:	e5943044 	ldr	r3, [r4, #68]	; 0x44
8f604c28:	e54b304c 	strb	r3, [r11, #-76]	; 0xffffffb4
8f604c2c:	e5943044 	ldr	r3, [r4, #68]	; 0x44
8f604c30:	e1a03423 	lsr	r3, r3, #8
8f604c34:	e54b304b 	strb	r3, [r11, #-75]	; 0xffffffb5
8f604c38:	e1d434b6 	ldrh	r3, [r4, #70]	; 0x46
8f604c3c:	e54b304a 	strb	r3, [r11, #-74]	; 0xffffffb6
8f604c40:	e5d43047 	ldrb	r3, [r4, #71]	; 0x47
8f604c44:	e54b3049 	strb	r3, [r11, #-73]	; 0xffffffb7
		memscpy(tmp, PARTITION_TYPE_GUID_SIZE, partition_entries[i].type_guid,
8f604c48:	e3a03010 	mov	r3, #16
8f604c4c:	e1a01003 	mov	r1, r3
8f604c50:	eb00be01 	bl	8f63445c <memscpy>
	for (i=0;i<partition_count;i++)
8f604c54:	e28aa001 	add	r10, r10, #1
8f604c58:	e2844098 	add	r4, r4, #152	; 0x98
8f604c5c:	e157000a 	cmp	r7, r10
8f604c60:	1affffdd 	bne	8f604bdc <update_gpt+0xa4>
	}

	/* Calculate and update CRC of partition entries array */
	max_partition_count =
		    GET_LWORD_FROM_BYTE(&gpt_hdr_ptr[PARTITION_COUNT_OFFSET]);
	partition_entry_size =
8f604c64:	e5963054 	ldr	r3, [r6, #84]	; 0x54
		    GET_LWORD_FROM_BYTE(&gpt_hdr_ptr[PENTRY_SIZE_OFFSET]);

	/* Check for partition entry size */
	if (partition_entry_size != PARTITION_ENTRY_SIZE) {
8f604c68:	e3530080 	cmp	r3, #128	; 0x80
8f604c6c:	1a000033 	bne	8f604d40 <update_gpt+0x208>
	max_partition_count =
8f604c70:	e5962050 	ldr	r2, [r6, #80]	; 0x50
		dprintf(CRITICAL,"Invalid parition entry size\n");
		goto out;
	}

	/* Check for maximum partition size */
	if ((max_partition_count) > (MIN_PARTITION_ARRAY_SIZE /(partition_entry_size))) {
8f604c74:	e3520080 	cmp	r2, #128	; 0x80
8f604c78:	8a000038 	bhi	8f604d60 <update_gpt+0x228>
		dprintf(CRITICAL, "Invalid maximum partition count\n");
		goto out;
	}

	crc_val  = crc32(~0L, gpt_entries_ptr, ((max_partition_count) *
8f604c7c:	e59d1008 	ldr	r1, [r13, #8]
8f604c80:	e1a02382 	lsl	r2, r2, #7
8f604c84:	e3e00000 	mvn	r0, #0
8f604c88:	eb000a5d 	bl	8f607604 <crc32>
	PUT_LONG(&gpt_hdr_ptr[PARTITION_CRC_OFFSET], crc_val);


	/* Write CRC to 0 before we calculate the crc of the GPT header */
	crc_val = 0;
	PUT_LONG(&gpt_hdr_ptr[HEADER_CRC_OFFSET], crc_val);
8f604c8c:	e3a03000 	mov	r3, #0
	crc_val  = crc32(~0L,gpt_hdr_ptr, GPT_HEADER_SIZE) ^ (~0L);
8f604c90:	e3a0205c 	mov	r2, #92	; 0x5c
8f604c94:	e1a01006 	mov	r1, r6
	PUT_LONG(&gpt_hdr_ptr[HEADER_CRC_OFFSET], crc_val);
8f604c98:	e5c63010 	strb	r3, [r6, #16]
8f604c9c:	e5c63011 	strb	r3, [r6, #17]
8f604ca0:	e5c63012 	strb	r3, [r6, #18]
8f604ca4:	e5c63013 	strb	r3, [r6, #19]
	crc_val  = crc32(~0L, gpt_entries_ptr, ((max_partition_count) *
8f604ca8:	e1e00000 	mvn	r0, r0
	PUT_LONG(&gpt_hdr_ptr[PARTITION_CRC_OFFSET], crc_val);
8f604cac:	e5c60058 	strb	r0, [r6, #88]	; 0x58
8f604cb0:	e1a03420 	lsr	r3, r0, #8
8f604cb4:	e5c63059 	strb	r3, [r6, #89]	; 0x59
8f604cb8:	e1a03820 	lsr	r3, r0, #16
8f604cbc:	e1a00c20 	lsr	r0, r0, #24
8f604cc0:	e5c6305a 	strb	r3, [r6, #90]	; 0x5a
8f604cc4:	e5c6005b 	strb	r0, [r6, #91]	; 0x5b
	crc_val  = crc32(~0L,gpt_hdr_ptr, GPT_HEADER_SIZE) ^ (~0L);
8f604cc8:	e3e00000 	mvn	r0, #0
8f604ccc:	eb000a4c 	bl	8f607604 <crc32>
	PUT_LONG(&gpt_hdr_ptr[HEADER_CRC_OFFSET], crc_val);

	/* write to mmc */
	ret = mmc_write(gpt_start_addr, max_gpt_size_bytes, buffer);
8f604cd0:	e59d200c 	ldr	r2, [r13, #12]
	crc_val  = crc32(~0L,gpt_hdr_ptr, GPT_HEADER_SIZE) ^ (~0L);
8f604cd4:	e1e03000 	mvn	r3, r0
	ret = mmc_write(gpt_start_addr, max_gpt_size_bytes, buffer);
8f604cd8:	e1cd00d0 	ldrd	r0, [r13]
	PUT_LONG(&gpt_hdr_ptr[HEADER_CRC_OFFSET], crc_val);
8f604cdc:	e1a0c423 	lsr	r12, r3, #8
8f604ce0:	e5c63010 	strb	r3, [r6, #16]
8f604ce4:	e5c6c011 	strb	r12, [r6, #17]
8f604ce8:	e1a0c823 	lsr	r12, r3, #16
8f604cec:	e1a03c23 	lsr	r3, r3, #24
8f604cf0:	e5c6c012 	strb	r12, [r6, #18]
8f604cf4:	e5c63013 	strb	r3, [r6, #19]
	ret = mmc_write(gpt_start_addr, max_gpt_size_bytes, buffer);
8f604cf8:	e1a03008 	mov	r3, r8
8f604cfc:	eb001f47 	bl	8f60ca20 <mmc_write>
	if (ret)
8f604d00:	e2509000 	subs	r9, r0, #0
8f604d04:	1a000019 	bne	8f604d70 <update_gpt+0x238>
		dprintf(CRITICAL, "Failed to write gpt\n");
		goto out;
	}
out:
	if (buffer)
		free(buffer);
8f604d08:	e1a00008 	mov	r0, r8
8f604d0c:	eb00bcfe 	bl	8f63410c <free>
	return ret;
}
8f604d10:	e59f3080 	ldr	r3, [pc, #128]	; 8f604d98 <update_gpt+0x260>
8f604d14:	e5932000 	ldr	r2, [r3]
8f604d18:	e59d3014 	ldr	r3, [r13, #20]
8f604d1c:	e0332002 	eors	r2, r3, r2
8f604d20:	e3a03000 	mov	r3, #0
8f604d24:	1a000015 	bne	8f604d80 <update_gpt+0x248>
8f604d28:	e1a00009 	mov	r0, r9
8f604d2c:	e28dd01c 	add	r13, r13, #28
8f604d30:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		lun = mmc_get_lun();
8f604d34:	eb0021d4 	bl	8f60d48c <mmc_get_lun>
8f604d38:	e1a05000 	mov	r5, r0
8f604d3c:	eaffff92 	b	8f604b8c <update_gpt+0x54>
		dprintf(CRITICAL,"Invalid parition entry size\n");
8f604d40:	e3000e4c 	movw	r0, #3660	; 0xe4c
8f604d44:	e3480f70 	movt	r0, #36720	; 0x8f70
8f604d48:	eb00b709 	bl	8f632974 <_dprintf>
		goto out;
8f604d4c:	eaffffed 	b	8f604d08 <update_gpt+0x1d0>
		dprintf(CRITICAL, "Failed to read GPT\n");
8f604d50:	e30102dc 	movw	r0, #4828	; 0x12dc
8f604d54:	e3480f70 	movt	r0, #36720	; 0x8f70
8f604d58:	eb00b705 	bl	8f632974 <_dprintf>
		goto out;
8f604d5c:	eaffffe9 	b	8f604d08 <update_gpt+0x1d0>
		dprintf(CRITICAL, "Invalid maximum partition count\n");
8f604d60:	e3000e6c 	movw	r0, #3692	; 0xe6c
8f604d64:	e3480f70 	movt	r0, #36720	; 0x8f70
8f604d68:	eb00b701 	bl	8f632974 <_dprintf>
		goto out;
8f604d6c:	eaffffe5 	b	8f604d08 <update_gpt+0x1d0>
		dprintf(CRITICAL, "Failed to write gpt\n");
8f604d70:	e30102f0 	movw	r0, #4848	; 0x12f0
8f604d74:	e3480f70 	movt	r0, #36720	; 0x8f70
8f604d78:	eb00b6fd 	bl	8f632974 <_dprintf>
		goto out;
8f604d7c:	eaffffe1 	b	8f604d08 <update_gpt+0x1d0>
}
8f604d80:	eb00b78e 	bl	8f632bc0 <__stack_chk_fail>
		dprintf(CRITICAL, "update_gpt: Failed at memory allocation\n");
8f604d84:	e30102b0 	movw	r0, #4784	; 0x12b0
8f604d88:	e3480f70 	movt	r0, #36720	; 0x8f70
8f604d8c:	eb00b6f8 	bl	8f632974 <_dprintf>
	int ret = 0;
8f604d90:	e1a09008 	mov	r9, r8
8f604d94:	eaffffdd 	b	8f604d10 <update_gpt+0x1d8>
8f604d98:	8f74221c 	.word	0x8f74221c

8f604d9c <partition_reset_retry_count>:
{
8f604d9c:	e59f305c 	ldr	r3, [pc, #92]	; 8f604e00 <partition_reset_retry_count+0x64>
8f604da0:	e92d4010 	push	{r4, r14}
8f604da4:	e24dd008 	sub	r13, r13, #8
8f604da8:	e5933000 	ldr	r3, [r3]
8f604dac:	e58d3004 	str	r3, [r13, #4]
8f604db0:	e3a03000 	mov	r3, #0
8f604db4:	e1a04000 	mov	r4, r0
			partition_get_partition_entries();
8f604db8:	ebfffb89 	bl	8f603be4 <partition_get_partition_entries>
	int slt_index = boot_slot_index[slot];
8f604dbc:	e30b3d9c 	movw	r3, #48540	; 0xbd9c
8f604dc0:	e3483f72 	movt	r3, #36722	; 0x8f72
	partition_entries[slt_index].attribute_flag |= (PART_ATT_PRIORITY_VAL |
8f604dc4:	e3a02098 	mov	r2, #152	; 0x98
8f604dc8:	e7933104 	ldr	r3, [r3, r4, lsl #2]
8f604dcc:	e0200392 	mla	r0, r2, r3, r0
8f604dd0:	e5903044 	ldr	r3, [r0, #68]	; 0x44
8f604dd4:	e383383b 	orr	r3, r3, #3866624	; 0x3b0000
8f604dd8:	e5803044 	str	r3, [r0, #68]	; 0x44
}
8f604ddc:	e59f301c 	ldr	r3, [pc, #28]	; 8f604e00 <partition_reset_retry_count+0x64>
8f604de0:	e5932000 	ldr	r2, [r3]
8f604de4:	e59d3004 	ldr	r3, [r13, #4]
8f604de8:	e0332002 	eors	r2, r3, r2
8f604dec:	e3a03000 	mov	r3, #0
8f604df0:	1a000001 	bne	8f604dfc <partition_reset_retry_count+0x60>
8f604df4:	e28dd008 	add	r13, r13, #8
8f604df8:	e8bd8010 	pop	{r4, r15}
8f604dfc:	eb00b76f 	bl	8f632bc0 <__stack_chk_fail>
8f604e00:	8f74221c 	.word	0x8f74221c

8f604e04 <partition_scan_for_multislot>:
{
8f604e04:	e59f31bc 	ldr	r3, [pc, #444]	; 8f604fc8 <partition_scan_for_multislot+0x1c4>
	int strlen_boot = strlen("boot");
8f604e08:	e30a0370 	movw	r0, #41840	; 0xa370
{
8f604e0c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	int strlen_boot = strlen("boot");
8f604e10:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f604e14:	e24dd01c 	sub	r13, r13, #28
	multislot_support = false;
8f604e18:	e30b4da4 	movw	r4, #48548	; 0xbda4
{
8f604e1c:	e5933000 	ldr	r3, [r3]
8f604e20:	e58d3014 	str	r3, [r13, #20]
8f604e24:	e3a03000 	mov	r3, #0
	int strlen_boot = strlen("boot");
8f604e28:	eb00be76 	bl	8f634808 <strlen>
	multislot_support = false;
8f604e2c:	e3484f72 	movt	r4, #36722	; 0x8f72
8f604e30:	e3a08000 	mov	r8, #0
	int strlen_boot = strlen("boot");
8f604e34:	e1a05000 	mov	r5, r0
	int partition_count = partition_get_partition_count();
8f604e38:	ebfffb56 	bl	8f603b98 <partition_get_partition_count>
	multislot_support = false;
8f604e3c:	e58d400c 	str	r4, [r13, #12]
	int partition_count = partition_get_partition_count();
8f604e40:	e1a06000 	mov	r6, r0
				partition_get_partition_entries();
8f604e44:	ebfffb66 	bl	8f603be4 <partition_get_partition_entries>
	active_slot = INVALID;
8f604e48:	e30b3d94 	movw	r3, #48532	; 0xbd94
	attributes_updated = false;
8f604e4c:	e30b2d98 	movw	r2, #48536	; 0xbd98
	active_slot = INVALID;
8f604e50:	e3483f72 	movt	r3, #36722	; 0x8f72
	attributes_updated = false;
8f604e54:	e3482f72 	movt	r2, #36722	; 0x8f72
	if (partition_count > NUM_PARTITIONS)
8f604e58:	e3560080 	cmp	r6, #128	; 0x80
	multislot_support = false;
8f604e5c:	e5848000 	str	r8, [r4]
	attributes_updated = false;
8f604e60:	e5828000 	str	r8, [r2]
	active_slot = INVALID;
8f604e64:	e3e02000 	mvn	r2, #0
8f604e68:	e5832000 	str	r2, [r3]
	if (partition_count > NUM_PARTITIONS)
8f604e6c:	ca00004e 	bgt	8f604fac <partition_scan_for_multislot+0x1a8>
	for (i = 0; i < partition_count; i++)
8f604e70:	e1560008 	cmp	r6, r8
8f604e74:	da000036 	ble	8f604f54 <partition_scan_for_multislot+0x150>
					if (!strcmp(pname, suffix_slot[j]))
8f604e78:	e30132e0 	movw	r3, #4832	; 0x12e0
8f604e7c:	e3483f71 	movt	r3, #36721	; 0x8f71
		if (!strncmp((const char *)partition_entries[i].name, "boot", strlen_boot))
8f604e80:	e30a7370 	movw	r7, #41840	; 0xa370
8f604e84:	e2804048 	add	r4, r0, #72	; 0x48
					if (!strcmp(pname, suffix_slot[j]))
8f604e88:	e593b000 	ldr	r11, [r3]
		if (!strncmp((const char *)partition_entries[i].name, "boot", strlen_boot))
8f604e8c:	e3487f70 	movt	r7, #36720	; 0x8f70
					if (!strcmp(pname, suffix_slot[j]))
8f604e90:	e5933004 	ldr	r3, [r3, #4]
	int i, j, count = 0;
8f604e94:	e1a09008 	mov	r9, r8
	for (i = 0; i < partition_count; i++)
8f604e98:	e1a0a008 	mov	r10, r8
						count ++;
8f604e9c:	e58d8000 	str	r8, [r13]
					if (!strcmp(pname, suffix_slot[j]))
8f604ea0:	e58d3004 	str	r3, [r13, #4]
						boot_slot_index[j] = i;
8f604ea4:	e30b3d9c 	movw	r3, #48540	; 0xbd9c
8f604ea8:	e3483f72 	movt	r3, #36722	; 0x8f72
8f604eac:	e58d3008 	str	r3, [r13, #8]
8f604eb0:	ea000003 	b	8f604ec4 <partition_scan_for_multislot+0xc0>
	for (i = 0; i < partition_count; i++)
8f604eb4:	e28aa001 	add	r10, r10, #1
8f604eb8:	e2844098 	add	r4, r4, #152	; 0x98
8f604ebc:	e156000a 	cmp	r6, r10
8f604ec0:	0a000022 	beq	8f604f50 <partition_scan_for_multislot+0x14c>
		if (!strncmp((const char *)partition_entries[i].name, "boot", strlen_boot))
8f604ec4:	e1a02005 	mov	r2, r5
8f604ec8:	e1a01007 	mov	r1, r7
8f604ecc:	e1a00004 	mov	r0, r4
8f604ed0:	eb00be65 	bl	8f63486c <strncmp>
8f604ed4:	e3500000 	cmp	r0, #0
8f604ed8:	1afffff5 	bne	8f604eb4 <partition_scan_for_multislot+0xb0>
			if (*pname)
8f604edc:	e7d42005 	ldrb	r2, [r4, r5]
8f604ee0:	e0858004 	add	r8, r5, r4
8f604ee4:	e3520000 	cmp	r2, #0
8f604ee8:	0a000018 	beq	8f604f50 <partition_scan_for_multislot+0x14c>
					if (!strcmp(pname, suffix_slot[j]))
8f604eec:	e1a0100b 	mov	r1, r11
8f604ef0:	e1a00008 	mov	r0, r8
8f604ef4:	eb00bd8a 	bl	8f634524 <strcmp>
8f604ef8:	e3500000 	cmp	r0, #0
8f604efc:	1a00001d 	bne	8f604f78 <partition_scan_for_multislot+0x174>
						if (!multislot_support)
8f604f00:	e59d3000 	ldr	r3, [r13]
8f604f04:	e3530000 	cmp	r3, #0
						boot_slot_index[j] = i;
8f604f08:	e59d3008 	ldr	r3, [r13, #8]
8f604f0c:	e583a000 	str	r10, [r3]
							multislot_support =true;
8f604f10:	059d300c 	ldreq	r3, [r13, #12]
8f604f14:	03a02001 	moveq	r2, #1
8f604f18:	05832000 	streq	r2, [r3]
					if (!strcmp(pname, suffix_slot[j]))
8f604f1c:	e59d1004 	ldr	r1, [r13, #4]
8f604f20:	e1a00008 	mov	r0, r8
8f604f24:	eb00bd7e 	bl	8f634524 <strcmp>
						count ++;
8f604f28:	e2899001 	add	r9, r9, #1
					if (!strcmp(pname, suffix_slot[j]))
8f604f2c:	e3500000 	cmp	r0, #0
8f604f30:	1a000002 	bne	8f604f40 <partition_scan_for_multislot+0x13c>
						boot_slot_index[j] = i;
8f604f34:	e59d3008 	ldr	r3, [r13, #8]
8f604f38:	e583a004 	str	r10, [r3, #4]
						count ++;
8f604f3c:	e2899001 	add	r9, r9, #1
8f604f40:	e3a03001 	mov	r3, #1
8f604f44:	e58d3000 	str	r3, [r13]
				if (count == AB_SUPPORTED_SLOTS)
8f604f48:	e3590002 	cmp	r9, #2
8f604f4c:	1affffd8 	bne	8f604eb4 <partition_scan_for_multislot+0xb0>
8f604f50:	e59d8000 	ldr	r8, [r13]
}
8f604f54:	e59f306c 	ldr	r3, [pc, #108]	; 8f604fc8 <partition_scan_for_multislot+0x1c4>
8f604f58:	e5932000 	ldr	r2, [r3]
8f604f5c:	e59d3014 	ldr	r3, [r13, #20]
8f604f60:	e0332002 	eors	r2, r3, r2
8f604f64:	e3a03000 	mov	r3, #0
8f604f68:	1a000015 	bne	8f604fc4 <partition_scan_for_multislot+0x1c0>
8f604f6c:	e1a00008 	mov	r0, r8
8f604f70:	e28dd01c 	add	r13, r13, #28
8f604f74:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
					if (!strcmp(pname, suffix_slot[j]))
8f604f78:	e59d1004 	ldr	r1, [r13, #4]
8f604f7c:	e1a00008 	mov	r0, r8
8f604f80:	eb00bd67 	bl	8f634524 <strcmp>
8f604f84:	e3500000 	cmp	r0, #0
8f604f88:	1affffee 	bne	8f604f48 <partition_scan_for_multislot+0x144>
						if (!multislot_support)
8f604f8c:	e59d3000 	ldr	r3, [r13]
8f604f90:	e3530000 	cmp	r3, #0
						boot_slot_index[j] = i;
8f604f94:	e59d3008 	ldr	r3, [r13, #8]
							multislot_support =true;
8f604f98:	03a02001 	moveq	r2, #1
						boot_slot_index[j] = i;
8f604f9c:	e583a004 	str	r10, [r3, #4]
							multislot_support =true;
8f604fa0:	059d300c 	ldreq	r3, [r13, #12]
8f604fa4:	05832000 	streq	r2, [r3]
8f604fa8:	eaffffe3 	b	8f604f3c <partition_scan_for_multislot+0x138>
		dprintf(CRITICAL, "ERROR: partition_count more than supported.\n");
8f604fac:	e3010308 	movw	r0, #4872	; 0x1308
8f604fb0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f604fb4:	eb00b66e 	bl	8f632974 <_dprintf>
		return multislot_support;
8f604fb8:	e59d300c 	ldr	r3, [r13, #12]
8f604fbc:	e5938000 	ldr	r8, [r3]
8f604fc0:	eaffffe3 	b	8f604f54 <partition_scan_for_multislot+0x150>
}
8f604fc4:	eb00b6fd 	bl	8f632bc0 <__stack_chk_fail>
8f604fc8:	8f74221c 	.word	0x8f74221c

8f604fcc <partition_find_active_slot>:
{
8f604fcc:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
	if (active_slot != INVALID)
8f604fd0:	e30b4d94 	movw	r4, #48532	; 0xbd94
{
8f604fd4:	e59f3110 	ldr	r3, [pc, #272]	; 8f6050ec <partition_find_active_slot+0x120>
	if (active_slot != INVALID)
8f604fd8:	e3484f72 	movt	r4, #36722	; 0x8f72
{
8f604fdc:	e24dd008 	sub	r13, r13, #8
8f604fe0:	e5933000 	ldr	r3, [r3]
8f604fe4:	e58d3004 	str	r3, [r13, #4]
8f604fe8:	e3a03000 	mov	r3, #0
	struct partition_entry *partition_entries = partition_get_partition_entries();
8f604fec:	ebfffafc 	bl	8f603be4 <partition_get_partition_entries>
	if (active_slot != INVALID)
8f604ff0:	e5948000 	ldr	r8, [r4]
8f604ff4:	e3780001 	cmn	r8, #1
8f604ff8:	1a00001c 	bne	8f605070 <partition_find_active_slot+0xa4>
8f604ffc:	e30b6d9c 	movw	r6, #48540	; 0xbd9c
8f605000:	e3486f72 	movt	r6, #36722	; 0x8f72
8f605004:	e1a0c000 	mov	r12, r0
8f605008:	e3a0e004 	mov	r14, #4
	int i, count = 0;
8f60500c:	e3a00000 	mov	r0, #0
	return ((partition_entries[index].attribute_flag
8f605010:	e3a07098 	mov	r7, #152	; 0x98
		for (i = 0; i < AB_SUPPORTED_SLOTS; i++)
8f605014:	e30b2d9c 	movw	r2, #48540	; 0xbd9c
8f605018:	e3482f72 	movt	r2, #36722	; 0x8f72
8f60501c:	e3a01000 	mov	r1, #0
			current_priority = slot_priority(partition_entries, boot_slot_index[i]);
8f605020:	e4923004 	ldr	r3, [r2], #4
	return ((partition_entries[index].attribute_flag
8f605024:	e023c397 	mla	r3, r7, r3, r12
8f605028:	e5933044 	ldr	r3, [r3, #68]	; 0x44
	if ((partition_entries[index].attribute_flag &
8f60502c:	e3130502 	tst	r3, #8388608	; 0x800000
8f605030:	e2039502 	and	r9, r3, #8388608	; 0x800000
8f605034:	1a000007 	bne	8f605058 <partition_find_active_slot+0x8c>
		& PART_ATT_PRIORITY_VAL)>>PART_ATT_PRIORITY_BIT);
8f605038:	e7e15853 	ubfx	r5, r3, #16, #2
	if ((partition_entries[index].attribute_flag &
8f60503c:	e7e0a953 	ubfx	r10, r3, #18, #1
			if ( !current_priority &&
8f605040:	e19aa005 	orrs	r10, r10, r5
	if ((partition_entries[index].attribute_flag &
8f605044:	e2033701 	and	r3, r3, #262144	; 0x40000
				count ++;
8f605048:	02800001 	addeq	r0, r0, #1
			if ( !current_priority &&
8f60504c:	0a000001 	beq	8f605058 <partition_find_active_slot+0x8c>
			if (boot_priority == current_priority)
8f605050:	e155000e 	cmp	r5, r14
8f605054:	0a000010 	beq	8f60509c <partition_find_active_slot+0xd0>
		for (i = 0; i < AB_SUPPORTED_SLOTS; i++)
8f605058:	e3510001 	cmp	r1, #1
8f60505c:	1a00000c 	bne	8f605094 <partition_find_active_slot+0xc8>
		if (count == AB_SUPPORTED_SLOTS)
8f605060:	e3500002 	cmp	r0, #2
8f605064:	0a000011 	beq	8f6050b0 <partition_find_active_slot+0xe4>
	for (boot_priority = MAX_PRIORITY;
8f605068:	e25ee001 	subs	r14, r14, #1
8f60506c:	1affffe8 	bne	8f605014 <partition_find_active_slot+0x48>
}
8f605070:	e59f3074 	ldr	r3, [pc, #116]	; 8f6050ec <partition_find_active_slot+0x120>
8f605074:	e5932000 	ldr	r2, [r3]
8f605078:	e59d3004 	ldr	r3, [r13, #4]
8f60507c:	e0332002 	eors	r2, r3, r2
8f605080:	e3a03000 	mov	r3, #0
8f605084:	1a000017 	bne	8f6050e8 <partition_find_active_slot+0x11c>
8f605088:	e1a00008 	mov	r0, r8
8f60508c:	e28dd008 	add	r13, r13, #8
8f605090:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
8f605094:	e3a01001 	mov	r1, #1
8f605098:	eaffffe0 	b	8f605020 <partition_find_active_slot+0x54>
				if (current_active_bit &&
8f60509c:	e1993003 	orrs	r3, r9, r3
8f6050a0:	0affffec 	beq	8f605058 <partition_find_active_slot+0x8c>
					goto out;
8f6050a4:	e1a08001 	mov	r8, r1
					active_slot = i;
8f6050a8:	e5841000 	str	r1, [r4]
					goto out;
8f6050ac:	eaffffef 	b	8f605070 <partition_find_active_slot+0xa4>
			partition_get_partition_entries();
8f6050b0:	ebfffacb 	bl	8f603be4 <partition_get_partition_entries>
	CLR_BIT(partition_entries[slt_index].attribute_flag, PART_ATT_UNBOOTABLE_BIT);
8f6050b4:	e5963000 	ldr	r3, [r6]
8f6050b8:	e3a01098 	mov	r1, #152	; 0x98
			partition_get_partition_entries();
8f6050bc:	e1a02000 	mov	r2, r0
			active_slot = SLOT_A;
8f6050c0:	e3a00000 	mov	r0, #0
	CLR_BIT(partition_entries[slt_index].attribute_flag, PART_ATT_UNBOOTABLE_BIT);
8f6050c4:	e0222391 	mla	r2, r1, r3, r2
			active_slot = SLOT_A;
8f6050c8:	e5840000 	str	r0, [r4]
	CLR_BIT(partition_entries[slt_index].attribute_flag, PART_ATT_SUCCESS_BIT);
8f6050cc:	e5923044 	ldr	r3, [r2, #68]	; 0x44
8f6050d0:	e3c33503 	bic	r3, r3, #12582912	; 0xc00000
	partition_entries[slt_index].attribute_flag |= (PART_ATT_PRIORITY_VAL |
8f6050d4:	e383383f 	orr	r3, r3, #4128768	; 0x3f0000
8f6050d8:	e5823044 	str	r3, [r2, #68]	; 0x44
			mark_all_partitions_active(active_slot);
8f6050dc:	ebfffe5b 	bl	8f604a50 <mark_all_partitions_active>
	return active_slot;
8f6050e0:	e5948000 	ldr	r8, [r4]
			goto out;
8f6050e4:	eaffffe1 	b	8f605070 <partition_find_active_slot+0xa4>
}
8f6050e8:	eb00b6b4 	bl	8f632bc0 <__stack_chk_fail>
8f6050ec:	8f74221c 	.word	0x8f74221c

8f6050f0 <partition_mark_active_slot>:
{
8f6050f0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	if (active_slot == slot)
8f6050f4:	e30b6d94 	movw	r6, #48532	; 0xbd94
{
8f6050f8:	e24dd03c 	sub	r13, r13, #60	; 0x3c
8f6050fc:	e59f33b4 	ldr	r3, [pc, #948]	; 8f6054b8 <partition_mark_active_slot+0x3c8>
	if (active_slot == slot)
8f605100:	e3486f72 	movt	r6, #36722	; 0x8f72
8f605104:	e58d601c 	str	r6, [r13, #28]
{
8f605108:	e5933000 	ldr	r3, [r3]
8f60510c:	e58d3034 	str	r3, [r13, #52]	; 0x34
8f605110:	e3a03000 	mov	r3, #0
	if (active_slot == slot)
8f605114:	e5963000 	ldr	r3, [r6]
{
8f605118:	e58d0008 	str	r0, [r13, #8]
	if (active_slot == slot)
8f60511c:	e1530000 	cmp	r3, r0
8f605120:	0a000005 	beq	8f60513c <partition_mark_active_slot+0x4c>
	if(slot != INVALID)
8f605124:	e3700001 	cmn	r0, #1
8f605128:	e1a04000 	mov	r4, r0
8f60512c:	1a00000f 	bne	8f605170 <partition_mark_active_slot+0x80>
	active_slot = slot;
8f605130:	e59d301c 	ldr	r3, [r13, #28]
8f605134:	e59d2008 	ldr	r2, [r13, #8]
8f605138:	e5832000 	str	r2, [r3]
	if (attributes_updated)
8f60513c:	e30b3d98 	movw	r3, #48536	; 0xbd98
8f605140:	e3483f72 	movt	r3, #36722	; 0x8f72
8f605144:	e5933000 	ldr	r3, [r3]
8f605148:	e3530000 	cmp	r3, #0
8f60514c:	1a000089 	bne	8f605378 <partition_mark_active_slot+0x288>
}
8f605150:	e59f3360 	ldr	r3, [pc, #864]	; 8f6054b8 <partition_mark_active_slot+0x3c8>
8f605154:	e5932000 	ldr	r2, [r3]
8f605158:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f60515c:	e0332002 	eors	r2, r3, r2
8f605160:	e3a03000 	mov	r3, #0
8f605164:	1a0000d2 	bne	8f6054b4 <partition_mark_active_slot+0x3c4>
8f605168:	e28dd03c 	add	r13, r13, #60	; 0x3c
8f60516c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		dprintf(INFO, "Marking (%s) as active\n", SUFFIX_SLOT(slot));
8f605170:	e30152e0 	movw	r5, #4832	; 0x12e0
8f605174:	e3485f71 	movt	r5, #36721	; 0x8f71
8f605178:	e3010338 	movw	r0, #4920	; 0x1338
8f60517c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f605180:	e7951104 	ldr	r1, [r5, r4, lsl #2]
8f605184:	eb00b5fa 	bl	8f632974 <_dprintf>
		swap_guid(active_slot, slot);
8f605188:	e5966000 	ldr	r6, [r6]
8f60518c:	e58d600c 	str	r6, [r13, #12]
	unsigned partition_cnt = partition_get_partition_count();
8f605190:	ebfffa80 	bl	8f603b98 <partition_get_partition_count>
8f605194:	e1a0b000 	mov	r11, r0
			partition_get_partition_entries();
8f605198:	ebfffa91 	bl	8f603be4 <partition_get_partition_entries>
	if ( old_slot == new_slot)
8f60519c:	e1560004 	cmp	r6, r4
8f6051a0:	0a000071 	beq	8f60536c <partition_mark_active_slot+0x27c>
	for(i = 0; i < partition_cnt; i++)
8f6051a4:	e35b0000 	cmp	r11, #0
8f6051a8:	0a00006f 	beq	8f60536c <partition_mark_active_slot+0x27c>
		if ((ptr_suffix = strstr(ptr_pname, SUFFIX_SLOT(new_slot))))
8f6051ac:	e3a03001 	mov	r3, #1
8f6051b0:	e795a104 	ldr	r10, [r5, r4, lsl #2]
8f6051b4:	e1a07000 	mov	r7, r0
8f6051b8:	e58d3010 	str	r3, [r13, #16]
8f6051bc:	ea00000e 	b	8f6051fc <partition_mark_active_slot+0x10c>
		else if ((ptr_suffix = strstr(ptr_pname, SUFFIX_SLOT(old_slot))))
8f6051c0:	e59d300c 	ldr	r3, [r13, #12]
8f6051c4:	e1a00004 	mov	r0, r4
8f6051c8:	e7951103 	ldr	r1, [r5, r3, lsl #2]
8f6051cc:	eb00be0d 	bl	8f634a08 <strstr>
8f6051d0:	e3500000 	cmp	r0, #0
8f6051d4:	1a000039 	bne	8f6052c0 <partition_mark_active_slot+0x1d0>
	for(i = 0; i < partition_cnt; i++)
8f6051d8:	e59d3010 	ldr	r3, [r13, #16]
8f6051dc:	e15b0003 	cmp	r11, r3
8f6051e0:	9a000061 	bls	8f60536c <partition_mark_active_slot+0x27c>
8f6051e4:	e2873098 	add	r3, r7, #152	; 0x98
8f6051e8:	e58d3014 	str	r3, [r13, #20]
8f6051ec:	e59d7014 	ldr	r7, [r13, #20]
8f6051f0:	e59d3010 	ldr	r3, [r13, #16]
8f6051f4:	e2833001 	add	r3, r3, #1
8f6051f8:	e58d3010 	str	r3, [r13, #16]
		ptr_pname = (const char *)partition_entries[i].name;
8f6051fc:	e2874048 	add	r4, r7, #72	; 0x48
		if ((ptr_suffix = strstr(ptr_pname, SUFFIX_SLOT(new_slot))))
8f605200:	e1a0100a 	mov	r1, r10
8f605204:	e1a00004 	mov	r0, r4
8f605208:	eb00bdfe 	bl	8f634a08 <strstr>
8f60520c:	e3500000 	cmp	r0, #0
8f605210:	0affffea 	beq	8f6051c0 <partition_mark_active_slot+0xd0>
			for (j = i+1; j < partition_cnt; j++)
8f605214:	e59d8010 	ldr	r8, [r13, #16]
8f605218:	e15b0008 	cmp	r11, r8
8f60521c:	9a000052 	bls	8f60536c <partition_mark_active_slot+0x27c>
8f605220:	e2876098 	add	r6, r7, #152	; 0x98
8f605224:	e58d6014 	str	r6, [r13, #20]
				tmp_strlen = strlen(ptr_pname)-strlen(SUFFIX_SLOT(new_slot));
8f605228:	e1a00004 	mov	r0, r4
8f60522c:	e2869048 	add	r9, r6, #72	; 0x48
8f605230:	eb00bd74 	bl	8f634808 <strlen>
8f605234:	e59d3008 	ldr	r3, [r13, #8]
8f605238:	e1a0a000 	mov	r10, r0
8f60523c:	e7950103 	ldr	r0, [r5, r3, lsl #2]
8f605240:	eb00bd70 	bl	8f634808 <strlen>
				if (!strncmp((const char*)partition_entries[j].name, ptr_pname, tmp_strlen) &&
8f605244:	e1a01004 	mov	r1, r4
8f605248:	e04a2000 	sub	r2, r10, r0
8f60524c:	e1a00009 	mov	r0, r9
8f605250:	eb00bd85 	bl	8f63486c <strncmp>
8f605254:	e3500000 	cmp	r0, #0
8f605258:	1a000011 	bne	8f6052a4 <partition_mark_active_slot+0x1b4>
					strstr((const char*)partition_entries[j].name, SUFFIX_SLOT(old_slot)))
8f60525c:	e59d300c 	ldr	r3, [r13, #12]
8f605260:	e1a00009 	mov	r0, r9
8f605264:	e7951103 	ldr	r1, [r5, r3, lsl #2]
8f605268:	eb00bde6 	bl	8f634a08 <strstr>
				if (!strncmp((const char*)partition_entries[j].name, ptr_pname, tmp_strlen) &&
8f60526c:	e3500000 	cmp	r0, #0
8f605270:	0a00000b 	beq	8f6052a4 <partition_mark_active_slot+0x1b4>
	memcpy(tmp_guid, partition_entries[old_index].type_guid,
8f605274:	e3a02010 	mov	r2, #16
8f605278:	e1a01006 	mov	r1, r6
8f60527c:	e28d0024 	add	r0, r13, #36	; 0x24
8f605280:	eb00bbcc 	bl	8f6341b8 <memcpy>
	memcpy(partition_entries[old_index].type_guid,
8f605284:	e3a02010 	mov	r2, #16
8f605288:	e1a01007 	mov	r1, r7
8f60528c:	e1a00006 	mov	r0, r6
8f605290:	eb00bbc8 	bl	8f6341b8 <memcpy>
	memcpy(partition_entries[new_index].type_guid, tmp_guid,
8f605294:	e28d1024 	add	r1, r13, #36	; 0x24
8f605298:	e3a02010 	mov	r2, #16
8f60529c:	e1a00007 	mov	r0, r7
8f6052a0:	eb00bbc4 	bl	8f6341b8 <memcpy>
			for (j = i+1; j < partition_cnt; j++)
8f6052a4:	e2888001 	add	r8, r8, #1
8f6052a8:	e2866098 	add	r6, r6, #152	; 0x98
8f6052ac:	e15b0008 	cmp	r11, r8
8f6052b0:	1affffdc 	bne	8f605228 <partition_mark_active_slot+0x138>
		if ((ptr_suffix = strstr(ptr_pname, SUFFIX_SLOT(new_slot))))
8f6052b4:	e59d3008 	ldr	r3, [r13, #8]
8f6052b8:	e795a103 	ldr	r10, [r5, r3, lsl #2]
	for(i = 0; i < partition_cnt; i++)
8f6052bc:	eaffffca 	b	8f6051ec <partition_mark_active_slot+0xfc>
			for (j = i+1; j < partition_cnt; j++)
8f6052c0:	e59d8010 	ldr	r8, [r13, #16]
8f6052c4:	e15b0008 	cmp	r11, r8
8f6052c8:	9a000027 	bls	8f60536c <partition_mark_active_slot+0x27c>
8f6052cc:	e2876098 	add	r6, r7, #152	; 0x98
8f6052d0:	e1cd61f4 	strd	r6, [r13, #20]
				tmp_strlen = strlen(ptr_pname)-strlen(SUFFIX_SLOT(old_slot));
8f6052d4:	e1a00004 	mov	r0, r4
8f6052d8:	e2869048 	add	r9, r6, #72	; 0x48
8f6052dc:	eb00bd49 	bl	8f634808 <strlen>
8f6052e0:	e59d300c 	ldr	r3, [r13, #12]
8f6052e4:	e1a07000 	mov	r7, r0
8f6052e8:	e7950103 	ldr	r0, [r5, r3, lsl #2]
8f6052ec:	eb00bd45 	bl	8f634808 <strlen>
				if (!strncmp((const char *)partition_entries[j].name, ptr_pname, tmp_strlen) &&
8f6052f0:	e1a01004 	mov	r1, r4
8f6052f4:	e0472000 	sub	r2, r7, r0
8f6052f8:	e1a00009 	mov	r0, r9
8f6052fc:	eb00bd5a 	bl	8f63486c <strncmp>
8f605300:	e3500000 	cmp	r0, #0
8f605304:	1a000013 	bne	8f605358 <partition_mark_active_slot+0x268>
					strstr((const char *)partition_entries[j].name, SUFFIX_SLOT(new_slot)))
8f605308:	e1a00009 	mov	r0, r9
8f60530c:	e1a0100a 	mov	r1, r10
8f605310:	eb00bdbc 	bl	8f634a08 <strstr>
				if (!strncmp((const char *)partition_entries[j].name, ptr_pname, tmp_strlen) &&
8f605314:	e3500000 	cmp	r0, #0
8f605318:	0a00000e 	beq	8f605358 <partition_mark_active_slot+0x268>
	memcpy(tmp_guid, partition_entries[old_index].type_guid,
8f60531c:	e59d7018 	ldr	r7, [r13, #24]
8f605320:	e3a02010 	mov	r2, #16
8f605324:	e28d0024 	add	r0, r13, #36	; 0x24
8f605328:	e1a01007 	mov	r1, r7
8f60532c:	eb00bba1 	bl	8f6341b8 <memcpy>
	memcpy(partition_entries[old_index].type_guid,
8f605330:	e3a02010 	mov	r2, #16
8f605334:	e1a01006 	mov	r1, r6
8f605338:	e1a00007 	mov	r0, r7
8f60533c:	eb00bb9d 	bl	8f6341b8 <memcpy>
	memcpy(partition_entries[new_index].type_guid, tmp_guid,
8f605340:	e28d1024 	add	r1, r13, #36	; 0x24
8f605344:	e3a02010 	mov	r2, #16
8f605348:	e1a00006 	mov	r0, r6
8f60534c:	eb00bb99 	bl	8f6341b8 <memcpy>
		if ((ptr_suffix = strstr(ptr_pname, SUFFIX_SLOT(new_slot))))
8f605350:	e59d3008 	ldr	r3, [r13, #8]
8f605354:	e795a103 	ldr	r10, [r5, r3, lsl #2]
			for (j = i+1; j < partition_cnt; j++)
8f605358:	e2888001 	add	r8, r8, #1
8f60535c:	e2866098 	add	r6, r6, #152	; 0x98
8f605360:	e15b0008 	cmp	r11, r8
8f605364:	1affffda 	bne	8f6052d4 <partition_mark_active_slot+0x1e4>
8f605368:	eaffff9f 	b	8f6051ec <partition_mark_active_slot+0xfc>
		mark_all_partitions_active(slot);
8f60536c:	e59d0008 	ldr	r0, [r13, #8]
8f605370:	ebfffdb6 	bl	8f604a50 <mark_all_partitions_active>
8f605374:	eaffff6d 	b	8f605130 <partition_mark_active_slot+0x40>
{
	uint64_t offset;
	uint64_t gpt_entries_offset, gpt_hdr_offset;
	uint64_t gpt_start_addr;
	int ret;
	uint32_t block_size = mmc_get_device_blocksize();
8f605378:	eb001fff 	bl	8f60d37c <mmc_get_device_blocksize>
8f60537c:	e1a04000 	mov	r4, r0
	unsigned max_entries_size_bytes = PARTITION_ENTRY_SIZE*NUM_PARTITIONS;
	unsigned max_entries_blocks = max_entries_size_bytes/block_size;
8f605380:	e3a00901 	mov	r0, #16384	; 0x4000
8f605384:	e1a01004 	mov	r1, r4
8f605388:	fa00de12 	blx	8f63cbd8 <__udivsi3>
8f60538c:	e1a09000 	mov	r9, r0
	unsigned max_gpt_blocks = GPT_HEADER_BLOCKS + max_entries_blocks;
	int max_luns = 0, lun;
	int cur_lun = mmc_get_lun();
8f605390:	eb00203d 	bl	8f60d48c <mmc_get_lun>
	unsigned max_gpt_blocks = GPT_HEADER_BLOCKS + max_entries_blocks;
8f605394:	e2898001 	add	r8, r9, #1
	int cur_lun = mmc_get_lun();
8f605398:	e58d0008 	str	r0, [r13, #8]

#if defined(MMC_SDHCI_SUPPORT) || defined(UFS_SUPPORT)
	if (platform_boot_dev_isemmc())
8f60539c:	eb007151 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f6053a0:	e3500000 	cmp	r0, #0
		max_luns = 1;
8f6053a4:	13a0a001 	movne	r10, #1
	if (platform_boot_dev_isemmc())
8f6053a8:	0a00002b 	beq	8f60545c <partition_mark_active_slot+0x36c>
		/* Set current LUN */
		mmc_set_lun(lun);

		/* Update Primary GPT */
		offset = 0x01;	/*  offset is 0x1 for primary GPT */
		gpt_start_addr = offset*block_size;
8f6053ac:	e3a05000 	mov	r5, #0
8f6053b0:	ea000012 	b	8f605400 <partition_mark_active_slot+0x310>
			dprintf(CRITICAL, "Failed to update Primary GPT\n");
			return;
		}

		/* Update Secondary GPT */
		offset = ((mmc_get_device_capacity()/block_size) - max_gpt_blocks);
8f6053b4:	eb001fd8 	bl	8f60d31c <mmc_get_device_capacity>
8f6053b8:	e1a02004 	mov	r2, r4
8f6053bc:	e1a0300b 	mov	r3, r11
		gpt_start_addr = offset*block_size;
		gpt_hdr_offset = max_entries_blocks;
		gpt_entries_offset = 0; /* For secondary GPT entries offset is zero */

		ret = update_gpt(gpt_start_addr, gpt_hdr_offset, gpt_entries_offset);
8f6053c0:	e3a06000 	mov	r6, #0
		offset = ((mmc_get_device_capacity()/block_size) - max_gpt_blocks);
8f6053c4:	fa00df76 	blx	8f63d1a4 <__aeabi_uldivmod>
		ret = update_gpt(gpt_start_addr, gpt_hdr_offset, gpt_entries_offset);
8f6053c8:	e3a07000 	mov	r7, #0
8f6053cc:	e1a0300b 	mov	r3, r11
8f6053d0:	e1cd60f0 	strd	r6, [r13]
		offset = ((mmc_get_device_capacity()/block_size) - max_gpt_blocks);
8f6053d4:	e0500008 	subs	r0, r0, r8
8f6053d8:	e2c11000 	sbc	r1, r1, #0
		gpt_start_addr = offset*block_size;
8f6053dc:	e0820490 	umull	r0, r2, r0, r4
		ret = update_gpt(gpt_start_addr, gpt_hdr_offset, gpt_entries_offset);
8f6053e0:	e0212194 	mla	r1, r4, r1, r2
8f6053e4:	e1a02009 	mov	r2, r9
8f6053e8:	ebfffdd2 	bl	8f604b38 <update_gpt>
		if (ret)
8f6053ec:	e3500000 	cmp	r0, #0
8f6053f0:	1a000027 	bne	8f605494 <partition_mark_active_slot+0x3a4>
	for (lun = 0; lun < max_luns; lun++)
8f6053f4:	e2855001 	add	r5, r5, #1
8f6053f8:	e15a0005 	cmp	r10, r5
8f6053fc:	da00001a 	ble	8f60546c <partition_mark_active_slot+0x37c>
		mmc_set_lun(lun);
8f605400:	e6ef0075 	uxtb	r0, r5
8f605404:	eb00200a 	bl	8f60d434 <mmc_set_lun>
		ret = update_gpt(gpt_start_addr, gpt_hdr_offset, gpt_entries_offset);
8f605408:	e3a02001 	mov	r2, #1
8f60540c:	e3a03000 	mov	r3, #0
8f605410:	e1a00004 	mov	r0, r4
8f605414:	e1cd20f0 	strd	r2, [r13]
8f605418:	e3a01000 	mov	r1, #0
8f60541c:	e3a02000 	mov	r2, #0
8f605420:	e3a03000 	mov	r3, #0
8f605424:	ebfffdc3 	bl	8f604b38 <update_gpt>
		if (ret)
8f605428:	e250b000 	subs	r11, r0, #0
8f60542c:	0affffe0 	beq	8f6053b4 <partition_mark_active_slot+0x2c4>
			dprintf(CRITICAL, "Failed to update Primary GPT\n");
8f605430:	e59f3080 	ldr	r3, [pc, #128]	; 8f6054b8 <partition_mark_active_slot+0x3c8>
8f605434:	e5932000 	ldr	r2, [r3]
8f605438:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f60543c:	e0332002 	eors	r2, r3, r2
8f605440:	e3a03000 	mov	r3, #0
8f605444:	03010350 	movweq	r0, #4944	; 0x1350
8f605448:	03480f70 	movteq	r0, #36720	; 0x8f70
8f60544c:	1a000018 	bne	8f6054b4 <partition_mark_active_slot+0x3c4>
}
8f605450:	e28dd03c 	add	r13, r13, #60	; 0x3c
8f605454:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
		{
			dprintf(CRITICAL, "Failed to update Secondary GPT\n");
8f605458:	ea00b545 	b	8f632974 <_dprintf>
		max_luns = ufs_get_num_of_luns((struct ufs_dev*)target_mmc_device());
8f60545c:	ebffec77 	bl	8f600640 <target_mmc_device>
8f605460:	eb001d5d 	bl	8f60c9dc <ufs_get_num_of_luns>
	for (lun = 0; lun < max_luns; lun++)
8f605464:	e250a000 	subs	r10, r0, #0
8f605468:	1affffcf 	bne	8f6053ac <partition_mark_active_slot+0x2bc>
			return;
		}
	}
	mmc_set_lun(cur_lun);
8f60546c:	e59f3044 	ldr	r3, [pc, #68]	; 8f6054b8 <partition_mark_active_slot+0x3c8>
8f605470:	e5932000 	ldr	r2, [r3]
8f605474:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f605478:	e0332002 	eors	r2, r3, r2
8f60547c:	e3a03000 	mov	r3, #0
8f605480:	1a00000b 	bne	8f6054b4 <partition_mark_active_slot+0x3c4>
8f605484:	e59d0008 	ldr	r0, [r13, #8]
}
8f605488:	e28dd03c 	add	r13, r13, #60	; 0x3c
8f60548c:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	mmc_set_lun(cur_lun);
8f605490:	ea001fe7 	b	8f60d434 <mmc_set_lun>
			dprintf(CRITICAL, "Failed to update Secondary GPT\n");
8f605494:	e59f301c 	ldr	r3, [pc, #28]	; 8f6054b8 <partition_mark_active_slot+0x3c8>
8f605498:	e5932000 	ldr	r2, [r3]
8f60549c:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f6054a0:	e0332002 	eors	r2, r3, r2
8f6054a4:	e3a03000 	mov	r3, #0
8f6054a8:	03010370 	movweq	r0, #4976	; 0x1370
8f6054ac:	03480f70 	movteq	r0, #36720	; 0x8f70
8f6054b0:	0affffe6 	beq	8f605450 <partition_mark_active_slot+0x360>
}
8f6054b4:	eb00b5c1 	bl	8f632bc0 <__stack_chk_fail>
8f6054b8:	8f74221c 	.word	0x8f74221c

8f6054bc <partition_reset_attributes>:
{
8f6054bc:	e59f307c 	ldr	r3, [pc, #124]	; 8f605540 <partition_reset_attributes+0x84>
8f6054c0:	e92d4010 	push	{r4, r14}
8f6054c4:	e24dd008 	sub	r13, r13, #8
8f6054c8:	e5933000 	ldr	r3, [r3]
8f6054cc:	e58d3004 	str	r3, [r13, #4]
8f6054d0:	e3a03000 	mov	r3, #0
8f6054d4:	e1a04000 	mov	r4, r0
					partition_get_partition_entries();
8f6054d8:	ebfff9c1 	bl	8f603be4 <partition_get_partition_entries>
	partition_entries[index].attribute_flag |= (PART_ATT_PRIORITY_VAL |
8f6054dc:	e3a03098 	mov	r3, #152	; 0x98
	if (!attributes_updated)
8f6054e0:	e30b2d98 	movw	r2, #48536	; 0xbd98
8f6054e4:	e3482f72 	movt	r2, #36722	; 0x8f72
	partition_entries[index].attribute_flag |= (PART_ATT_PRIORITY_VAL |
8f6054e8:	e0200493 	mla	r0, r3, r4, r0
	if (!attributes_updated)
8f6054ec:	e5923000 	ldr	r3, [r2]
8f6054f0:	e3530000 	cmp	r3, #0
	partition_entries[index].attribute_flag &= ((~PART_ATT_SUCCESSFUL_VAL) &
8f6054f4:	e5903044 	ldr	r3, [r0, #68]	; 0x44
8f6054f8:	e3c33503 	bic	r3, r3, #12582912	; 0xc00000
8f6054fc:	e383383b 	orr	r3, r3, #3866624	; 0x3b0000
8f605500:	e5803044 	str	r3, [r0, #68]	; 0x44
		attributes_updated = true;
8f605504:	03a03001 	moveq	r3, #1
8f605508:	05823000 	streq	r3, [r2]
	partition_mark_active_slot(active_slot);
8f60550c:	e59f302c 	ldr	r3, [pc, #44]	; 8f605540 <partition_reset_attributes+0x84>
8f605510:	e5932000 	ldr	r2, [r3]
8f605514:	e59d3004 	ldr	r3, [r13, #4]
8f605518:	e0332002 	eors	r2, r3, r2
8f60551c:	e3a03000 	mov	r3, #0
8f605520:	1a000005 	bne	8f60553c <partition_reset_attributes+0x80>
8f605524:	e30b3d94 	movw	r3, #48532	; 0xbd94
8f605528:	e3483f72 	movt	r3, #36722	; 0x8f72
8f60552c:	e5930000 	ldr	r0, [r3]
}
8f605530:	e28dd008 	add	r13, r13, #8
8f605534:	e8bd4010 	pop	{r4, r14}
	partition_mark_active_slot(active_slot);
8f605538:	eafffeec 	b	8f6050f0 <partition_mark_active_slot>
8f60553c:	eb00b59f 	bl	8f632bc0 <__stack_chk_fail>
8f605540:	8f74221c 	.word	0x8f74221c

8f605544 <partition_switch_slots>:
{
8f605544:	e59f3098 	ldr	r3, [pc, #152]	; 8f6055e4 <partition_switch_slots+0xa0>
8f605548:	e92d4030 	push	{r4, r5, r14}
8f60554c:	e24dd00c 	sub	r13, r13, #12
8f605550:	e5933000 	ldr	r3, [r3]
8f605554:	e58d3004 	str	r3, [r13, #4]
8f605558:	e3a03000 	mov	r3, #0
8f60555c:	e1a05000 	mov	r5, r0
8f605560:	e1a04001 	mov	r4, r1
					partition_get_partition_entries();
8f605564:	ebfff99e 	bl	8f603be4 <partition_get_partition_entries>
	int new_slot_index = boot_slot_index[new_slot];
8f605568:	e30b3d9c 	movw	r3, #48540	; 0xbd9c
8f60556c:	e3483f72 	movt	r3, #36722	; 0x8f72
	partition_entries[old_slot_index].attribute_flag &= ~PART_ATT_ACTIVE_VAL;
8f605570:	e7932105 	ldr	r2, [r3, r5, lsl #2]
	int new_slot_index = boot_slot_index[new_slot];
8f605574:	e7931104 	ldr	r1, [r3, r4, lsl #2]
	partition_entries[old_slot_index].attribute_flag &= ~PART_ATT_ACTIVE_VAL;
8f605578:	e3a03098 	mov	r3, #152	; 0x98
8f60557c:	e0220293 	mla	r2, r3, r2, r0
	partition_entries[new_slot_index].attribute_flag |=
8f605580:	e0230193 	mla	r3, r3, r1, r0
	if (!attributes_updated)
8f605584:	e30b1d98 	movw	r1, #48536	; 0xbd98
8f605588:	e3481f72 	movt	r1, #36722	; 0x8f72
8f60558c:	e5910000 	ldr	r0, [r1]
8f605590:	e3500000 	cmp	r0, #0
	partition_entries[old_slot_index].attribute_flag &= ~PART_ATT_ACTIVE_VAL;
8f605594:	e5920044 	ldr	r0, [r2, #68]	; 0x44
8f605598:	e3c00701 	bic	r0, r0, #262144	; 0x40000
8f60559c:	e5820044 	str	r0, [r2, #68]	; 0x44
	partition_entries[new_slot_index].attribute_flag &=
8f6055a0:	e5932044 	ldr	r2, [r3, #68]	; 0x44
8f6055a4:	e3c22503 	bic	r2, r2, #12582912	; 0xc00000
8f6055a8:	e382283f 	orr	r2, r2, #4128768	; 0x3f0000
8f6055ac:	e5832044 	str	r2, [r3, #68]	; 0x44
		attributes_updated = true;
8f6055b0:	03a03001 	moveq	r3, #1
8f6055b4:	05813000 	streq	r3, [r1]
	partition_mark_active_slot(new_slot);
8f6055b8:	e59f3024 	ldr	r3, [pc, #36]	; 8f6055e4 <partition_switch_slots+0xa0>
8f6055bc:	e5932000 	ldr	r2, [r3]
8f6055c0:	e59d3004 	ldr	r3, [r13, #4]
8f6055c4:	e0332002 	eors	r2, r3, r2
8f6055c8:	e3a03000 	mov	r3, #0
8f6055cc:	1a000003 	bne	8f6055e0 <partition_switch_slots+0x9c>
8f6055d0:	e1a00004 	mov	r0, r4
}
8f6055d4:	e28dd00c 	add	r13, r13, #12
8f6055d8:	e8bd4030 	pop	{r4, r5, r14}
	partition_mark_active_slot(new_slot);
8f6055dc:	eafffec3 	b	8f6050f0 <partition_mark_active_slot>
8f6055e0:	eb00b576 	bl	8f632bc0 <__stack_chk_fail>
8f6055e4:	8f74221c 	.word	0x8f74221c

8f6055e8 <partition_find_boot_slot>:
{
8f6055e8:	e59f3118 	ldr	r3, [pc, #280]	; 8f605708 <partition_find_boot_slot+0x120>
8f6055ec:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f6055f0:	e24dd00c 	sub	r13, r13, #12
8f6055f4:	e5933000 	ldr	r3, [r3]
8f6055f8:	e58d3004 	str	r3, [r13, #4]
8f6055fc:	e3a03000 	mov	r3, #0
	struct partition_entry *partition_entries = partition_get_partition_entries();
8f605600:	ebfff977 	bl	8f603be4 <partition_get_partition_entries>
8f605604:	e1a05000 	mov	r5, r0
	boot_slot = partition_find_active_slot();
8f605608:	ebfffe6f 	bl	8f604fcc <partition_find_active_slot>
	if (boot_slot == INVALID)
8f60560c:	e3700001 	cmn	r0, #1
	boot_slot = partition_find_active_slot();
8f605610:	e1a04000 	mov	r4, r0
	if (boot_slot == INVALID)
8f605614:	0a000014 	beq	8f60566c <partition_find_boot_slot+0x84>
	slt_index = boot_slot_index[boot_slot];
8f605618:	e30b6d9c 	movw	r6, #48540	; 0xbd9c
8f60561c:	e3486f72 	movt	r6, #36722	; 0x8f72
	if (partition_entries[slt_index].attribute_flag & PART_ATT_SUCCESSFUL_VAL)
8f605620:	e3a07098 	mov	r7, #152	; 0x98
8f605624:	e7962100 	ldr	r2, [r6, r0, lsl #2]
8f605628:	e0225297 	mla	r2, r7, r2, r5
8f60562c:	e5923044 	ldr	r3, [r2, #68]	; 0x44
8f605630:	e3130501 	tst	r3, #4194304	; 0x400000
8f605634:	1a00000c 	bne	8f60566c <partition_find_boot_slot+0x84>
	if (!boot_retry_count)
8f605638:	e313070e 	tst	r3, #3670016	; 0x380000
		& PART_ATT_MAX_RETRY_COUNT_VAL) >> PART_ATT_MAX_RETRY_CNT_BIT);
8f60563c:	e7e219d3 	ubfx	r1, r3, #19, #3
	if (!boot_retry_count)
8f605640:	0a000012 	beq	8f605690 <partition_find_boot_slot+0xa8>
					| ((boot_retry_count-1) << PART_ATT_MAX_RETRY_CNT_BIT);
8f605644:	e2511001 	subs	r1, r1, #1
		if (!attributes_updated)
8f605648:	e30b0d98 	movw	r0, #48536	; 0xbd98
8f60564c:	e3480f72 	movt	r0, #36722	; 0x8f72
					& ~PART_ATT_MAX_RETRY_COUNT_VAL)
8f605650:	e3c3370e 	bic	r3, r3, #3670016	; 0x380000
					| ((boot_retry_count-1) << PART_ATT_MAX_RETRY_CNT_BIT);
8f605654:	e1833981 	orr	r3, r3, r1, lsl #19
		partition_entries[slt_index].attribute_flag =
8f605658:	e5823044 	str	r3, [r2, #68]	; 0x44
		if (!attributes_updated)
8f60565c:	e5903000 	ldr	r3, [r0]
8f605660:	e3530000 	cmp	r3, #0
			attributes_updated = true;
8f605664:	03a03001 	moveq	r3, #1
8f605668:	05803000 	streq	r3, [r0]
}
8f60566c:	e59f3094 	ldr	r3, [pc, #148]	; 8f605708 <partition_find_boot_slot+0x120>
8f605670:	e5932000 	ldr	r2, [r3]
8f605674:	e59d3004 	ldr	r3, [r13, #4]
8f605678:	e0332002 	eors	r2, r3, r2
8f60567c:	e3a03000 	mov	r3, #0
8f605680:	1a00001f 	bne	8f605704 <partition_find_boot_slot+0x11c>
8f605684:	e1a00004 	mov	r0, r4
8f605688:	e28dd00c 	add	r13, r13, #12
8f60568c:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
			partition_get_partition_entries();
8f605690:	ebfff953 	bl	8f603be4 <partition_get_partition_entries>
	SET_BIT(partition_entries[slt_index].attribute_flag, PART_ATT_UNBOOTABLE_BIT);
8f605694:	e7963104 	ldr	r3, [r6, r4, lsl #2]
	if ((partition_entries[index].attribute_flag &
8f605698:	e5962000 	ldr	r2, [r6]
8f60569c:	e0225297 	mla	r2, r7, r2, r5
	SET_BIT(partition_entries[slt_index].attribute_flag, PART_ATT_UNBOOTABLE_BIT);
8f6056a0:	e0200397 	mla	r0, r7, r3, r0
	partition_entries[slt_index].attribute_flag &= (~PART_ATT_PRIORITY_VAL &
8f6056a4:	e5903044 	ldr	r3, [r0, #68]	; 0x44
8f6056a8:	e3c3387f 	bic	r3, r3, #8323072	; 0x7f0000
8f6056ac:	e3833502 	orr	r3, r3, #8388608	; 0x800000
8f6056b0:	e5803044 	str	r3, [r0, #68]	; 0x44
	if ((partition_entries[index].attribute_flag &
8f6056b4:	e5921044 	ldr	r1, [r2, #68]	; 0x44
8f6056b8:	e3110502 	tst	r1, #8388608	; 0x800000
8f6056bc:	e2011502 	and	r1, r1, #8388608	; 0x800000
8f6056c0:	0a00000a 	beq	8f6056f0 <partition_find_boot_slot+0x108>
8f6056c4:	e5960004 	ldr	r0, [r6, #4]
8f6056c8:	e0255097 	mla	r5, r7, r0, r5
8f6056cc:	e5953044 	ldr	r3, [r5, #68]	; 0x44
8f6056d0:	e3130502 	tst	r3, #8388608	; 0x800000
8f6056d4:	0a000004 	beq	8f6056ec <partition_find_boot_slot+0x104>
	dprintf(CRITICAL, "ERROR: Unable to find any bootable slot");
8f6056d8:	e3010390 	movw	r0, #5008	; 0x1390
8f6056dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6056e0:	eb00b4a3 	bl	8f632974 <_dprintf>
			boot_slot = INVALID;
8f6056e4:	e3e04000 	mvn	r4, #0
8f6056e8:	eaffffdf 	b	8f60566c <partition_find_boot_slot+0x84>
	for (i = 0; i < AB_SUPPORTED_SLOTS; i++)
8f6056ec:	e3a01001 	mov	r1, #1
			partition_switch_slots(boot_slot, next_slot);
8f6056f0:	e1a00004 	mov	r0, r4
8f6056f4:	ebffff92 	bl	8f605544 <partition_switch_slots>
			reboot_device(0);
8f6056f8:	e3a00000 	mov	r0, #0
8f6056fc:	eb006b05 	bl	8f620318 <reboot_device>
8f605700:	eaffffd9 	b	8f60566c <partition_find_boot_slot+0x84>
}
8f605704:	eb00b52d 	bl	8f632bc0 <__stack_chk_fail>
8f605708:	8f74221c 	.word	0x8f74221c

8f60570c <partition_multislot_is_supported>:
	return multislot_support;
8f60570c:	e30b3da4 	movw	r3, #48548	; 0xbda4
8f605710:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f605714:	e59f2038 	ldr	r2, [pc, #56]	; 8f605754 <partition_multislot_is_supported+0x48>
8f605718:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60571c:	e24dd00c 	sub	r13, r13, #12
	return multislot_support;
8f605720:	e5930000 	ldr	r0, [r3]
{
8f605724:	e5922000 	ldr	r2, [r2]
8f605728:	e58d2004 	str	r2, [r13, #4]
8f60572c:	e3a02000 	mov	r2, #0
}
8f605730:	e59f301c 	ldr	r3, [pc, #28]	; 8f605754 <partition_multislot_is_supported+0x48>
8f605734:	e5932000 	ldr	r2, [r3]
8f605738:	e59d3004 	ldr	r3, [r13, #4]
8f60573c:	e0332002 	eors	r2, r3, r2
8f605740:	e3a03000 	mov	r3, #0
8f605744:	1a000001 	bne	8f605750 <partition_multislot_is_supported+0x44>
8f605748:	e28dd00c 	add	r13, r13, #12
8f60574c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f605750:	eb00b51a 	bl	8f632bc0 <__stack_chk_fail>
8f605754:	8f74221c 	.word	0x8f74221c

8f605758 <partition_fill_partition_meta>:
{
8f605758:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f60575c:	e24dd01c 	sub	r13, r13, #28
8f605760:	e59f3164 	ldr	r3, [pc, #356]	; 8f6058cc <partition_fill_partition_meta+0x174>
8f605764:	e1a09002 	mov	r9, r2
8f605768:	e1cd00f0 	strd	r0, [r13]
8f60576c:	e5933000 	ldr	r3, [r3]
8f605770:	e58d3014 	str	r3, [r13, #20]
8f605774:	e3a03000 	mov	r3, #0
				partition_get_partition_entries();
8f605778:	ebfff919 	bl	8f603be4 <partition_get_partition_entries>
8f60577c:	e1a04000 	mov	r4, r0
	int partition_count = partition_get_partition_count();
8f605780:	ebfff904 	bl	8f603b98 <partition_get_partition_count>
	for (i=0; i<partition_count; i++)
8f605784:	e2508000 	subs	r8, r0, #0
8f605788:	da00004c 	ble	8f6058c0 <partition_fill_partition_meta+0x168>
	int count = 0;
8f60578c:	e3a05000 	mov	r5, #0
8f605790:	e30172e0 	movw	r7, #4832	; 0x12e0
				strlcpy(has_slot_reply[count], " Yes", MAX_RSP_SIZE);
8f605794:	e30133b8 	movw	r3, #5048	; 0x13b8
8f605798:	e2844048 	add	r4, r4, #72	; 0x48
8f60579c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6057a0:	e3487f71 	movt	r7, #36721	; 0x8f71
8f6057a4:	e58d3008 	str	r3, [r13, #8]
	for (i=0; i<partition_count; i++)
8f6057a8:	e1a06005 	mov	r6, r5
			strlcpy(has_slot_reply[count], " No", MAX_RSP_SIZE);
8f6057ac:	e30133c0 	movw	r3, #5056	; 0x13c0
8f6057b0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6057b4:	e58d300c 	str	r3, [r13, #12]
8f6057b8:	ea000015 	b	8f605814 <partition_fill_partition_meta+0xbc>
			suffix_str = strstr(pname, SUFFIX_SLOT(j));
8f6057bc:	e5971004 	ldr	r1, [r7, #4]
8f6057c0:	e1a00004 	mov	r0, r4
8f6057c4:	eb00bc8f 	bl	8f634a08 <strstr>
			if (suffix_str)
8f6057c8:	e250a000 	subs	r10, r0, #0
8f6057cc:	1a000016 	bne	8f60582c <partition_fill_partition_meta+0xd4>
			strlcpy(has_slot_pname[count], pname, MAX_GET_VAR_NAME_SIZE);
8f6057d0:	e59d3000 	ldr	r3, [r13]
8f6057d4:	e3a02c01 	mov	r2, #256	; 0x100
8f6057d8:	e1a01004 	mov	r1, r4
8f6057dc:	e0830405 	add	r0, r3, r5, lsl #8
8f6057e0:	eb00bbd2 	bl	8f634730 <strlcpy>
			strlcpy(has_slot_reply[count], " No", MAX_RSP_SIZE);
8f6057e4:	e59d3004 	ldr	r3, [r13, #4]
8f6057e8:	e59d100c 	ldr	r1, [r13, #12]
8f6057ec:	e3a02040 	mov	r2, #64	; 0x40
8f6057f0:	e0830305 	add	r0, r3, r5, lsl #6
			count++;
8f6057f4:	e2855001 	add	r5, r5, #1
			strlcpy(has_slot_reply[count], " No", MAX_RSP_SIZE);
8f6057f8:	eb00bbcc 	bl	8f634730 <strlcpy>
		if (count >= array_size)
8f6057fc:	e1550009 	cmp	r5, r9
8f605800:	aa000022 	bge	8f605890 <partition_fill_partition_meta+0x138>
	for (i=0; i<partition_count; i++)
8f605804:	e2866001 	add	r6, r6, #1
8f605808:	e2844098 	add	r4, r4, #152	; 0x98
8f60580c:	e1580006 	cmp	r8, r6
8f605810:	0a000021 	beq	8f60589c <partition_fill_partition_meta+0x144>
			suffix_str = strstr(pname, SUFFIX_SLOT(j));
8f605814:	e597b000 	ldr	r11, [r7]
8f605818:	e1a00004 	mov	r0, r4
8f60581c:	e1a0100b 	mov	r1, r11
8f605820:	eb00bc78 	bl	8f634a08 <strstr>
			if (suffix_str)
8f605824:	e250a000 	subs	r10, r0, #0
8f605828:	0affffe3 	beq	8f6057bc <partition_fill_partition_meta+0x64>
			if (!strcmp(suffix_str, SUFFIX_SLOT(SLOT_A)))
8f60582c:	e1a0100b 	mov	r1, r11
8f605830:	e1a0000a 	mov	r0, r10
8f605834:	eb00bb3a 	bl	8f634524 <strcmp>
8f605838:	e3500000 	cmp	r0, #0
8f60583c:	1affffee 	bne	8f6057fc <partition_fill_partition_meta+0xa4>
		pname_size = strlen(pname);
8f605840:	e1a00004 	mov	r0, r4
8f605844:	eb00bbef 	bl	8f634808 <strlen>
8f605848:	e1a02000 	mov	r2, r0
				tmp = pname_size-strlen(suffix_str);
8f60584c:	e1a0000a 	mov	r0, r10
		pname_size = strlen(pname);
8f605850:	e1a0a002 	mov	r10, r2
				tmp = pname_size-strlen(suffix_str);
8f605854:	eb00bbeb 	bl	8f634808 <strlen>
				strlcpy(has_slot_pname[count], pname, tmp+1);
8f605858:	e59d3000 	ldr	r3, [r13]
8f60585c:	e1a01004 	mov	r1, r4
				tmp = pname_size-strlen(suffix_str);
8f605860:	e04a2000 	sub	r2, r10, r0
				strlcpy(has_slot_pname[count], pname, tmp+1);
8f605864:	e0830405 	add	r0, r3, r5, lsl #8
8f605868:	e2822001 	add	r2, r2, #1
8f60586c:	eb00bbaf 	bl	8f634730 <strlcpy>
				strlcpy(has_slot_reply[count], " Yes", MAX_RSP_SIZE);
8f605870:	e59d3004 	ldr	r3, [r13, #4]
8f605874:	e59d1008 	ldr	r1, [r13, #8]
8f605878:	e3a02040 	mov	r2, #64	; 0x40
8f60587c:	e0830305 	add	r0, r3, r5, lsl #6
				count++;
8f605880:	e2855001 	add	r5, r5, #1
				strlcpy(has_slot_reply[count], " Yes", MAX_RSP_SIZE);
8f605884:	eb00bba9 	bl	8f634730 <strlcpy>
		if (count >= array_size)
8f605888:	e1550009 	cmp	r5, r9
8f60588c:	baffffdc 	blt	8f605804 <partition_fill_partition_meta+0xac>
			dprintf(CRITICAL, "ERROR: Not able to parse all partitions\n");
8f605890:	e30103c4 	movw	r0, #5060	; 0x13c4
8f605894:	e3480f70 	movt	r0, #36720	; 0x8f70
8f605898:	eb00b435 	bl	8f632974 <_dprintf>
}
8f60589c:	e59f3028 	ldr	r3, [pc, #40]	; 8f6058cc <partition_fill_partition_meta+0x174>
8f6058a0:	e5932000 	ldr	r2, [r3]
8f6058a4:	e59d3014 	ldr	r3, [r13, #20]
8f6058a8:	e0332002 	eors	r2, r3, r2
8f6058ac:	e3a03000 	mov	r3, #0
8f6058b0:	1a000004 	bne	8f6058c8 <partition_fill_partition_meta+0x170>
8f6058b4:	e1a00005 	mov	r0, r5
8f6058b8:	e28dd01c 	add	r13, r13, #28
8f6058bc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	int count = 0;
8f6058c0:	e3a05000 	mov	r5, #0
8f6058c4:	eafffff4 	b	8f60589c <partition_fill_partition_meta+0x144>
}
8f6058c8:	eb00b4bc 	bl	8f632bc0 <__stack_chk_fail>
8f6058cc:	8f74221c 	.word	0x8f74221c

8f6058d0 <partition_fill_slot_meta>:
{
8f6058d0:	e59f30f4 	ldr	r3, [pc, #244]	; 8f6059cc <partition_fill_slot_meta+0xfc>
8f6058d4:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
8f6058d8:	e24dd008 	sub	r13, r13, #8
8f6058dc:	e1a06000 	mov	r6, r0
8f6058e0:	e5933000 	ldr	r3, [r3]
8f6058e4:	e58d3004 	str	r3, [r13, #4]
8f6058e8:	e3a03000 	mov	r3, #0
	struct partition_entry *ptn_entries = partition_get_partition_entries();
8f6058ec:	ebfff8bc 	bl	8f603be4 <partition_get_partition_entries>
8f6058f0:	e2864d0e 	add	r4, r6, #896	; 0x380
8f6058f4:	e30bad9c 	movw	r10, #48540	; 0xbd9c
		strlcpy(slot_info[i].slot_is_unbootable_rsp,
8f6058f8:	e30183f0 	movw	r8, #5104	; 0x13f0
8f6058fc:	e30173f4 	movw	r7, #5108	; 0x13f4
8f605900:	e348af72 	movt	r10, #36722	; 0x8f72
8f605904:	e2866d36 	add	r6, r6, #3456	; 0xd80
8f605908:	e3488f70 	movt	r8, #36720	; 0x8f70
8f60590c:	e3487f70 	movt	r7, #36720	; 0x8f70
	struct partition_entry *ptn_entries = partition_get_partition_entries();
8f605910:	e1a09000 	mov	r9, r0
		current_slot_index = boot_slot_index[i];
8f605914:	e49a5004 	ldr	r5, [r10], #4
	if ((partition_entries[index].attribute_flag &
8f605918:	e3a03098 	mov	r3, #152	; 0x98
8f60591c:	e2440d0a 	sub	r0, r4, #640	; 0x280
		strlcpy(slot_info[i].slot_is_unbootable_rsp,
8f605920:	e3a02040 	mov	r2, #64	; 0x40
	if ((partition_entries[index].attribute_flag &
8f605924:	e0259593 	mla	r5, r3, r5, r9
8f605928:	e5953044 	ldr	r3, [r5, #68]	; 0x44
8f60592c:	e3130502 	tst	r3, #8388608	; 0x800000
		strlcpy(slot_info[i].slot_is_unbootable_rsp,
8f605930:	01a01007 	moveq	r1, r7
8f605934:	11a01008 	movne	r1, r8
8f605938:	eb00bb7c 	bl	8f634730 <strlcpy>
	if ((partition_entries[index].attribute_flag &
8f60593c:	e5953044 	ldr	r3, [r5, #68]	; 0x44
8f605940:	e2440d05 	sub	r0, r4, #320	; 0x140
		strlcpy(slot_info[i].slot_is_active_rsp,
8f605944:	e3a02040 	mov	r2, #64	; 0x40
	if ((partition_entries[index].attribute_flag &
8f605948:	e3130701 	tst	r3, #262144	; 0x40000
		strlcpy(slot_info[i].slot_is_active_rsp,
8f60594c:	11a01008 	movne	r1, r8
8f605950:	01a01007 	moveq	r1, r7
8f605954:	eb00bb75 	bl	8f634730 <strlcpy>
	if ((partition_entries[index].attribute_flag &
8f605958:	e5953044 	ldr	r3, [r5, #68]	; 0x44
		strlcpy(slot_info[i].slot_is_succesful_rsp,
8f60595c:	e3a02040 	mov	r2, #64	; 0x40
8f605960:	e1a00004 	mov	r0, r4
	if ((partition_entries[index].attribute_flag &
8f605964:	e3130501 	tst	r3, #4194304	; 0x400000
		strlcpy(slot_info[i].slot_is_succesful_rsp,
8f605968:	11a01008 	movne	r1, r8
8f60596c:	01a01007 	moveq	r1, r7
8f605970:	eb00bb6e 	bl	8f634730 <strlcpy>
		& PART_ATT_MAX_RETRY_COUNT_VAL) >> PART_ATT_MAX_RETRY_CNT_BIT);
8f605974:	e5950044 	ldr	r0, [r5, #68]	; 0x44
		itoa(slot_retry_count(ptn_entries, current_slot_index),
8f605978:	e3a0300a 	mov	r3, #10
8f60597c:	e3a02002 	mov	r2, #2
8f605980:	e1a0100d 	mov	r1, r13
8f605984:	e7e209d0 	ubfx	r0, r0, #19, #3
8f605988:	eb00b719 	bl	8f6335f4 <itoa>
		strlcpy(slot_info[i].slot_retry_count_rsp, buff, MAX_RSP_SIZE);
8f60598c:	e2840d05 	add	r0, r4, #320	; 0x140
8f605990:	e3a02040 	mov	r2, #64	; 0x40
	for(i=0; i<AB_SUPPORTED_SLOTS; i++)
8f605994:	e2844c05 	add	r4, r4, #1280	; 0x500
		strlcpy(slot_info[i].slot_retry_count_rsp, buff, MAX_RSP_SIZE);
8f605998:	e1a0100d 	mov	r1, r13
8f60599c:	eb00bb63 	bl	8f634730 <strlcpy>
	for(i=0; i<AB_SUPPORTED_SLOTS; i++)
8f6059a0:	e1540006 	cmp	r4, r6
8f6059a4:	1affffda 	bne	8f605914 <partition_fill_slot_meta+0x44>
}
8f6059a8:	e59f301c 	ldr	r3, [pc, #28]	; 8f6059cc <partition_fill_slot_meta+0xfc>
8f6059ac:	e5932000 	ldr	r2, [r3]
8f6059b0:	e59d3004 	ldr	r3, [r13, #4]
8f6059b4:	e0332002 	eors	r2, r3, r2
8f6059b8:	e3a03000 	mov	r3, #0
8f6059bc:	1a000001 	bne	8f6059c8 <partition_fill_slot_meta+0xf8>
8f6059c0:	e28dd008 	add	r13, r13, #8
8f6059c4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
8f6059c8:	eb00b47c 	bl	8f632bc0 <__stack_chk_fail>
8f6059cc:	8f74221c 	.word	0x8f74221c

8f6059d0 <handle_ept_complete>:
	exit_critical_section();
	return 0;
}

static void handle_ept_complete(struct udc_endpoint *ept)
{
8f6059d0:	e59f3154 	ldr	r3, [pc, #340]	; 8f605b2c <handle_ept_complete+0x15c>
	struct usb_request *req=NULL;

	DBG("ept%d %s complete req=%p\n",
	    ept->num, ept->in ? "in" : "out", ept->req);

	arch_invalidate_cache_range((addr_t) ept,
8f6059d4:	e3a01014 	mov	r1, #20
{
8f6059d8:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f6059dc:	e1a06000 	mov	r6, r0
8f6059e0:	e24dd010 	sub	r13, r13, #16
8f6059e4:	e5933000 	ldr	r3, [r3]
8f6059e8:	e58d300c 	str	r3, [r13, #12]
8f6059ec:	e3a03000 	mov	r3, #0
	arch_invalidate_cache_range((addr_t) ept,
8f6059f0:	eb006d74 	bl	8f620fc8 <arch_invalidate_cache_range>
					  sizeof(struct udc_endpoint));

	if(ept->req)
8f6059f4:	e596000c 	ldr	r0, [r6, #12]
8f6059f8:	e3500000 	cmp	r0, #0
8f6059fc:	0a000021 	beq	8f605a88 <handle_ept_complete+0xb8>
	{
		req = (struct usb_request *)VA((addr_t)ept->req);
8f605a00:	ebffef63 	bl	8f601794 <platform_get_phys_to_virt_mapping>
		arch_invalidate_cache_range((addr_t) ept->req,
8f605a04:	e3a01014 	mov	r1, #20
		req = (struct usb_request *)VA((addr_t)ept->req);
8f605a08:	e1a07000 	mov	r7, r0
		arch_invalidate_cache_range((addr_t) ept->req,
8f605a0c:	e596000c 	ldr	r0, [r6, #12]
8f605a10:	eb006d6c 	bl	8f620fc8 <arch_invalidate_cache_range>
						sizeof(struct usb_request));
	}

	if (req) {
8f605a14:	e3570000 	cmp	r7, #0
8f605a18:	0a00001a 	beq	8f605a88 <handle_ept_complete+0xb8>
		item = (struct ept_queue_item *)VA((addr_t)req->item);
8f605a1c:	e5970010 	ldr	r0, [r7, #16]
8f605a20:	ebffef5b 	bl	8f601794 <platform_get_phys_to_virt_mapping>
		/* total transfer length for transacation */
		total_len = req->req.length;
		ept->req = 0;
8f605a24:	e3a03000 	mov	r3, #0
		actual = 0;
8f605a28:	e1a08003 	mov	r8, r3
		total_len = req->req.length;
8f605a2c:	e5975004 	ldr	r5, [r7, #4]
		ept->req = 0;
8f605a30:	e586300c 	str	r3, [r6, #12]
		item = (struct ept_queue_item *)VA((addr_t)req->item);
8f605a34:	e1a04000 	mov	r4, r0
				/*
				 * Must clean/invalidate cached item
				 * data before checking the status
				 * every time.
				 */
				arch_invalidate_cache_range((addr_t)(item),
8f605a38:	e3a01020 	mov	r1, #32
8f605a3c:	e1a00004 	mov	r0, r4
8f605a40:	eb006d60 	bl	8f620fc8 <arch_invalidate_cache_range>
							sizeof(
							struct ept_queue_item));

			} while(readl(&item->info) & INFO_ACTIVE);
8f605a44:	e5943004 	ldr	r3, [r4, #4]
8f605a48:	e3130080 	tst	r3, #128	; 0x80
8f605a4c:	1afffff9 	bne	8f605a38 <handle_ept_complete+0x68>

			if ((item->info) & 0xff) {
8f605a50:	e5943004 	ldr	r3, [r4, #4]
8f605a54:	e21320ff 	ands	r2, r3, #255	; 0xff
8f605a58:	1a000012 	bne	8f605aa8 <handle_ept_complete+0xd8>
					item->page0);
				goto out;
			}

			/* Check if we are processing last TD */
			if (item->next == TERMINATE) {
8f605a5c:	e5940000 	ldr	r0, [r4]
8f605a60:	e3500001 	cmp	r0, #1
8f605a64:	0a00002b 	beq	8f605b18 <handle_ept_complete+0x148>
				 * Since we are not in last TD
				 * the total assumed transfer ascribed to this
				 * TD woulb the max possible TD transfer size
				 * (16K)
				 */
				actual += (MAX_TD_XFER_SIZE - (item->info >> 16)) & 0x7FFF;
8f605a68:	e1a03823 	lsr	r3, r3, #16
8f605a6c:	e2633901 	rsb	r3, r3, #16384	; 0x4000
8f605a70:	e7ee3053 	ubfx	r3, r3, #0, #15
8f605a74:	e0888003 	add	r8, r8, r3
				total_len -= (MAX_TD_XFER_SIZE - (item->info >> 16)) & 0x7FFF;
8f605a78:	e0455003 	sub	r5, r5, r3
				/*Move to next item in chain*/
				item = (struct ept_queue_item *)VA(item->next);
8f605a7c:	ebffef44 	bl	8f601794 <platform_get_phys_to_virt_mapping>
8f605a80:	e1a04000 	mov	r4, r0
		while(1) {
8f605a84:	eaffffeb 	b	8f605a38 <handle_ept_complete+0x68>
		status = 0;
out:
		if (req->req.complete)
			req->req.complete(&req->req, actual, status);
	}
}
8f605a88:	e59f309c 	ldr	r3, [pc, #156]	; 8f605b2c <handle_ept_complete+0x15c>
8f605a8c:	e5932000 	ldr	r2, [r3]
8f605a90:	e59d300c 	ldr	r3, [r13, #12]
8f605a94:	e0332002 	eors	r2, r3, r2
8f605a98:	e3a03000 	mov	r3, #0
8f605a9c:	1a000021 	bne	8f605b28 <handle_ept_complete+0x158>
8f605aa0:	e28dd010 	add	r13, r13, #16
8f605aa4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
				dprintf(INFO, "EP%d/%s FAIL nfo=%x pg0=%x\n",
8f605aa8:	e5942008 	ldr	r2, [r4, #8]
8f605aac:	e3010408 	movw	r0, #5128	; 0x1408
8f605ab0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f605ab4:	e58d2000 	str	r2, [r13]
8f605ab8:	e3012404 	movw	r2, #5124	; 0x1404
8f605abc:	e5d6c011 	ldrb	r12, [r6, #17]
8f605ac0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f605ac4:	e5d61010 	ldrb	r1, [r6, #16]
8f605ac8:	e35c0000 	cmp	r12, #0
8f605acc:	01a02000 	moveq	r2, r0
8f605ad0:	e301040c 	movw	r0, #5132	; 0x140c
8f605ad4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f605ad8:	eb00b3a5 	bl	8f632974 <_dprintf>
				status = -1;
8f605adc:	e3e02000 	mvn	r2, #0
		if (req->req.complete)
8f605ae0:	e5973008 	ldr	r3, [r7, #8]
8f605ae4:	e3530000 	cmp	r3, #0
8f605ae8:	0affffe6 	beq	8f605a88 <handle_ept_complete+0xb8>
			req->req.complete(&req->req, actual, status);
8f605aec:	e59f1038 	ldr	r1, [pc, #56]	; 8f605b2c <handle_ept_complete+0x15c>
8f605af0:	e5910000 	ldr	r0, [r1]
8f605af4:	e59d100c 	ldr	r1, [r13, #12]
8f605af8:	e0310000 	eors	r0, r1, r0
8f605afc:	e3a01000 	mov	r1, #0
8f605b00:	1a000008 	bne	8f605b28 <handle_ept_complete+0x158>
8f605b04:	e1a01008 	mov	r1, r8
8f605b08:	e1a00007 	mov	r0, r7
}
8f605b0c:	e28dd010 	add	r13, r13, #16
8f605b10:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, r14}
			req->req.complete(&req->req, actual, status);
8f605b14:	e12fff13 	bx	r3
				actual += (total_len - (item->info >> 16))
8f605b18:	e0453823 	sub	r3, r5, r3, lsr #16
								& 0x7FFF;
8f605b1c:	e7ee3053 	ubfx	r3, r3, #0, #15
				actual += (total_len - (item->info >> 16))
8f605b20:	e0888003 	add	r8, r8, r3
		status = 0;
8f605b24:	eaffffed 	b	8f605ae0 <handle_ept_complete+0x110>
}
8f605b28:	eb00b424 	bl	8f632bc0 <__stack_chk_fail>
8f605b2c:	8f74221c 	.word	0x8f74221c

8f605b30 <ep0_setup_ack_complete>:
static void
ep0_setup_ack_complete()
{
	uint32_t mode;

	if (!test_mode)
8f605b30:	e30b3dc0 	movw	r3, #48576	; 0xbdc0
8f605b34:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f605b38:	e59f20a0 	ldr	r2, [pc, #160]	; 8f605be0 <ep0_setup_ack_complete+0xb0>
	if (!test_mode)
8f605b3c:	e5933000 	ldr	r3, [r3]
{
8f605b40:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	if (!test_mode)
8f605b44:	e3530000 	cmp	r3, #0
{
8f605b48:	e24dd00c 	sub	r13, r13, #12
8f605b4c:	e5922000 	ldr	r2, [r2]
8f605b50:	e58d2004 	str	r2, [r13, #4]
8f605b54:	e3a02000 	mov	r2, #0
	if (!test_mode)
8f605b58:	0a000003 	beq	8f605b6c <ep0_setup_ack_complete+0x3c>
		return;

	switch (test_mode) {
8f605b5c:	e3530c03 	cmp	r3, #768	; 0x300
8f605b60:	0a000013 	beq	8f605bb4 <ep0_setup_ack_complete+0x84>
8f605b64:	e3530b01 	cmp	r3, #1024	; 0x400
8f605b68:	0a000007 	beq	8f605b8c <ep0_setup_ack_complete+0x5c>
		mode = readl(USB_PORTSC) & (~PORTSC_PTC);
		writel(mode | PORTSC_PTC_SE0_NAK, USB_PORTSC);
		break;
	}

}
8f605b6c:	e59f306c 	ldr	r3, [pc, #108]	; 8f605be0 <ep0_setup_ack_complete+0xb0>
8f605b70:	e5932000 	ldr	r2, [r3]
8f605b74:	e59d3004 	ldr	r3, [r13, #4]
8f605b78:	e0332002 	eors	r2, r3, r2
8f605b7c:	e3a03000 	mov	r3, #0
8f605b80:	1a000015 	bne	8f605bdc <ep0_setup_ack_complete+0xac>
8f605b84:	e28dd00c 	add	r13, r13, #12
8f605b88:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		dprintf(INFO, "Entering test mode for TST_PKT\n");
8f605b8c:	e3010428 	movw	r0, #5160	; 0x1428
8f605b90:	e3480f70 	movt	r0, #36720	; 0x8f70
8f605b94:	eb00b376 	bl	8f632974 <_dprintf>
		mode = readl(USB_PORTSC) & (~PORTSC_PTC);
8f605b98:	e3a02a0b 	mov	r2, #45056	; 0xb000
8f605b9c:	e340278d 	movt	r2, #1933	; 0x78d
8f605ba0:	e5923184 	ldr	r3, [r2, #388]	; 0x184
8f605ba4:	e3c3380f 	bic	r3, r3, #983040	; 0xf0000
		writel(mode | PORTSC_PTC_TST_PKT, USB_PORTSC);
8f605ba8:	e3833701 	orr	r3, r3, #262144	; 0x40000
8f605bac:	e5823184 	str	r3, [r2, #388]	; 0x184
		break;
8f605bb0:	eaffffed 	b	8f605b6c <ep0_setup_ack_complete+0x3c>
		dprintf(INFO, "Entering test mode for SE0-NAK\n");
8f605bb4:	e3010448 	movw	r0, #5192	; 0x1448
8f605bb8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f605bbc:	eb00b36c 	bl	8f632974 <_dprintf>
		mode = readl(USB_PORTSC) & (~PORTSC_PTC);
8f605bc0:	e3a02a0b 	mov	r2, #45056	; 0xb000
8f605bc4:	e340278d 	movt	r2, #1933	; 0x78d
8f605bc8:	e5923184 	ldr	r3, [r2, #388]	; 0x184
8f605bcc:	e3c3380f 	bic	r3, r3, #983040	; 0xf0000
		writel(mode | PORTSC_PTC_SE0_NAK, USB_PORTSC);
8f605bd0:	e3833803 	orr	r3, r3, #196608	; 0x30000
8f605bd4:	e5823184 	str	r3, [r2, #388]	; 0x184
		break;
8f605bd8:	eaffffe3 	b	8f605b6c <ep0_setup_ack_complete+0x3c>
}
8f605bdc:	eb00b3f7 	bl	8f632bc0 <__stack_chk_fail>
8f605be0:	8f74221c 	.word	0x8f74221c

8f605be4 <udc_descriptor_alloc>:
	if ((len > 255) || (len < 2) || (num > 255) || (type > 255))
8f605be4:	e2423002 	sub	r3, r2, #2
8f605be8:	e35300fd 	cmp	r3, #253	; 0xfd
{
8f605bec:	e59f30f4 	ldr	r3, [pc, #244]	; 8f605ce8 <udc_descriptor_alloc+0x104>
8f605bf0:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f605bf4:	e24dd010 	sub	r13, r13, #16
8f605bf8:	e5933000 	ldr	r3, [r3]
8f605bfc:	e58d300c 	str	r3, [r13, #12]
8f605c00:	e3a03000 	mov	r3, #0
8f605c04:	e1a05002 	mov	r5, r2
8f605c08:	e1a0800e 	mov	r8, r14
8f605c0c:	e1a07000 	mov	r7, r0
8f605c10:	e1a06001 	mov	r6, r1
	if ((len > 255) || (len < 2) || (num > 255) || (type > 255))
8f605c14:	8a000016 	bhi	8f605c74 <udc_descriptor_alloc+0x90>
8f605c18:	e35000ff 	cmp	r0, #255	; 0xff
8f605c1c:	935100ff 	cmpls	r1, #255	; 0xff
8f605c20:	8a000013 	bhi	8f605c74 <udc_descriptor_alloc+0x90>
	desc = malloc(sizeof(struct udc_descriptor) + len);
8f605c24:	e2850008 	add	r0, r5, #8
8f605c28:	eb00b8f3 	bl	8f633ffc <malloc>
	ASSERT(desc);
8f605c2c:	e2504000 	subs	r4, r0, #0
8f605c30:	0a000020 	beq	8f605cb8 <udc_descriptor_alloc+0xd4>
	desc->next = 0;
8f605c34:	e3a03000 	mov	r3, #0
8f605c38:	e5843000 	str	r3, [r4]
}
8f605c3c:	e59f30a4 	ldr	r3, [pc, #164]	; 8f605ce8 <udc_descriptor_alloc+0x104>
	desc->tag = (type << 8) | num;
8f605c40:	e1866407 	orr	r6, r6, r7, lsl #8
	desc->len = len;
8f605c44:	e1c450b6 	strh	r5, [r4, #6]
	desc->tag = (type << 8) | num;
8f605c48:	e1c460b4 	strh	r6, [r4, #4]
	desc->data[0] = len;
8f605c4c:	e5c45008 	strb	r5, [r4, #8]
	desc->data[1] = type;
8f605c50:	e5c47009 	strb	r7, [r4, #9]
}
8f605c54:	e5932000 	ldr	r2, [r3]
8f605c58:	e59d300c 	ldr	r3, [r13, #12]
8f605c5c:	e0332002 	eors	r2, r3, r2
8f605c60:	e3a03000 	mov	r3, #0
8f605c64:	1a00001e 	bne	8f605ce4 <udc_descriptor_alloc+0x100>
8f605c68:	e1a00004 	mov	r0, r4
8f605c6c:	e28dd010 	add	r13, r13, #16
8f605c70:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
		dprintf(CRITICAL, "Invalid parameters for descriptor allocation\n");
8f605c74:	e3010468 	movw	r0, #5224	; 0x1468
8f605c78:	e3480f70 	movt	r0, #36720	; 0x8f70
8f605c7c:	eb00b33c 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f605c80:	e1a00008 	mov	r0, r8
8f605c84:	e3073f64 	movw	r3, #32612	; 0x7f64
8f605c88:	e3012498 	movw	r2, #5272	; 0x1498
8f605c8c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f605c90:	e3482f70 	movt	r2, #36720	; 0x8f70
8f605c94:	e58d3000 	str	r3, [r13]
8f605c98:	e3001130 	movw	r1, #304	; 0x130
8f605c9c:	e3a03043 	mov	r3, #67	; 0x43
8f605ca0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f605ca4:	eb00b384 	bl	8f632abc <_panic>
	desc = malloc(sizeof(struct udc_descriptor) + len);
8f605ca8:	e2850008 	add	r0, r5, #8
8f605cac:	eb00b8d2 	bl	8f633ffc <malloc>
	ASSERT(desc);
8f605cb0:	e2504000 	subs	r4, r0, #0
8f605cb4:	1affffde 	bne	8f605c34 <udc_descriptor_alloc+0x50>
8f605cb8:	e1a00008 	mov	r0, r8
8f605cbc:	e30134b4 	movw	r3, #5300	; 0x14b4
8f605cc0:	e3012498 	movw	r2, #5272	; 0x1498
8f605cc4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f605cc8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f605ccc:	e58d3000 	str	r3, [r13]
8f605cd0:	e3001130 	movw	r1, #304	; 0x130
8f605cd4:	e3a03047 	mov	r3, #71	; 0x47
8f605cd8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f605cdc:	eb00b376 	bl	8f632abc <_panic>
8f605ce0:	eaffffd3 	b	8f605c34 <udc_descriptor_alloc+0x50>
}
8f605ce4:	eb00b3b5 	bl	8f632bc0 <__stack_chk_fail>
8f605ce8:	8f74221c 	.word	0x8f74221c

8f605cec <udc_string_desc_alloc>:
{
8f605cec:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
	if (next_string_id > 255)
8f605cf0:	e30172ec 	movw	r7, #4844	; 0x12ec
8f605cf4:	e3487f71 	movt	r7, #36721	; 0x8f71
{
8f605cf8:	e59f30cc 	ldr	r3, [pc, #204]	; 8f605dcc <udc_string_desc_alloc+0xe0>
8f605cfc:	e24dd008 	sub	r13, r13, #8
	if (next_string_id > 255)
8f605d00:	e5978000 	ldr	r8, [r7]
{
8f605d04:	e5933000 	ldr	r3, [r3]
8f605d08:	e58d3004 	str	r3, [r13, #4]
8f605d0c:	e3a03000 	mov	r3, #0
	if (next_string_id > 255)
8f605d10:	e35800ff 	cmp	r8, #255	; 0xff
8f605d14:	93a05000 	movls	r5, #0
8f605d18:	83a05001 	movhi	r5, #1
	if (!str)
8f605d1c:	e3500000 	cmp	r0, #0
8f605d20:	03855001 	orreq	r5, r5, #1
8f605d24:	e3550000 	cmp	r5, #0
8f605d28:	0a000008 	beq	8f605d50 <udc_string_desc_alloc+0x64>
		return 0;
8f605d2c:	e3a00000 	mov	r0, #0
}
8f605d30:	e59f3094 	ldr	r3, [pc, #148]	; 8f605dcc <udc_string_desc_alloc+0xe0>
8f605d34:	e5932000 	ldr	r2, [r3]
8f605d38:	e59d3004 	ldr	r3, [r13, #4]
8f605d3c:	e0332002 	eors	r2, r3, r2
8f605d40:	e3a03000 	mov	r3, #0
8f605d44:	1a00001f 	bne	8f605dc8 <udc_string_desc_alloc+0xdc>
8f605d48:	e28dd008 	add	r13, r13, #8
8f605d4c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
	len = strlen(str);
8f605d50:	e1a04000 	mov	r4, r0
8f605d54:	eb00baab 	bl	8f634808 <strlen>
	desc = udc_descriptor_alloc(TYPE_STRING, next_string_id, len * 2 + 2);
8f605d58:	e1a01008 	mov	r1, r8
8f605d5c:	e2802001 	add	r2, r0, #1
	len = strlen(str);
8f605d60:	e1a06000 	mov	r6, r0
	desc = udc_descriptor_alloc(TYPE_STRING, next_string_id, len * 2 + 2);
8f605d64:	e3a00003 	mov	r0, #3
8f605d68:	e1a02082 	lsl	r2, r2, #1
8f605d6c:	ebffff9c 	bl	8f605be4 <udc_descriptor_alloc>
	if (!desc)
8f605d70:	e250c000 	subs	r12, r0, #0
8f605d74:	0affffec 	beq	8f605d2c <udc_string_desc_alloc+0x40>
	next_string_id++;
8f605d78:	e5973000 	ldr	r3, [r7]
	while (len-- > 0) {
8f605d7c:	e3560000 	cmp	r6, #0
	next_string_id++;
8f605d80:	e2833001 	add	r3, r3, #1
8f605d84:	e5873000 	str	r3, [r7]
	while (len-- > 0) {
8f605d88:	0a000007 	beq	8f605dac <udc_string_desc_alloc+0xc0>
8f605d8c:	e28c300c 	add	r3, r12, #12
8f605d90:	e0841006 	add	r1, r4, r6
		*data++ = *str++;
8f605d94:	e4d42001 	ldrb	r2, [r4], #1
	while (len-- > 0) {
8f605d98:	e2833002 	add	r3, r3, #2
		*data++ = 0;
8f605d9c:	e5435003 	strb	r5, [r3, #-3]
	while (len-- > 0) {
8f605da0:	e1540001 	cmp	r4, r1
		*data++ = *str++;
8f605da4:	e5432004 	strb	r2, [r3, #-4]
	while (len-- > 0) {
8f605da8:	1afffff9 	bne	8f605d94 <udc_string_desc_alloc+0xa8>
	desc->next = desc_list;
8f605dac:	e30b3da8 	movw	r3, #48552	; 0xbda8
8f605db0:	e3483f72 	movt	r3, #36722	; 0x8f72
	return desc->tag & 0xff;
8f605db4:	e5dc0004 	ldrb	r0, [r12, #4]
	desc->next = desc_list;
8f605db8:	e5932000 	ldr	r2, [r3]
	desc_list = desc;
8f605dbc:	e583c000 	str	r12, [r3]
	desc->next = desc_list;
8f605dc0:	e58c2000 	str	r2, [r12]
	return desc->tag & 0xff;
8f605dc4:	eaffffd9 	b	8f605d30 <udc_string_desc_alloc+0x44>
}
8f605dc8:	eb00b37c 	bl	8f632bc0 <__stack_chk_fail>
8f605dcc:	8f74221c 	.word	0x8f74221c

8f605dd0 <hsusb_clock_init>:
{
8f605dd0:	e59f3034 	ldr	r3, [pc, #52]	; 8f605e0c <hsusb_clock_init+0x3c>
8f605dd4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f605dd8:	e24dd00c 	sub	r13, r13, #12
8f605ddc:	e5933000 	ldr	r3, [r3]
8f605de0:	e58d3004 	str	r3, [r13, #4]
8f605de4:	e3a03000 	mov	r3, #0
}
8f605de8:	e59f301c 	ldr	r3, [pc, #28]	; 8f605e0c <hsusb_clock_init+0x3c>
8f605dec:	e5932000 	ldr	r2, [r3]
8f605df0:	e59d3004 	ldr	r3, [r13, #4]
8f605df4:	e0332002 	eors	r2, r3, r2
8f605df8:	e3a03000 	mov	r3, #0
8f605dfc:	1a000001 	bne	8f605e08 <hsusb_clock_init+0x38>
8f605e00:	e28dd00c 	add	r13, r13, #12
8f605e04:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f605e08:	eb00b36c 	bl	8f632bc0 <__stack_chk_fail>
8f605e0c:	8f74221c 	.word	0x8f74221c

8f605e10 <_udc_endpoint_alloc>:
{
8f605e10:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f605e14:	e1a07001 	mov	r7, r1
8f605e18:	e59f3128 	ldr	r3, [pc, #296]	; 8f605f48 <_udc_endpoint_alloc+0x138>
	ept = memalign(CACHE_LINE, ROUNDUP(sizeof(*ept), CACHE_LINE));
8f605e1c:	e3a01040 	mov	r1, #64	; 0x40
{
8f605e20:	e24dd010 	sub	r13, r13, #16
8f605e24:	e1a05000 	mov	r5, r0
	ept = memalign(CACHE_LINE, ROUNDUP(sizeof(*ept), CACHE_LINE));
8f605e28:	e1a00001 	mov	r0, r1
{
8f605e2c:	e5933000 	ldr	r3, [r3]
8f605e30:	e58d300c 	str	r3, [r13, #12]
8f605e34:	e3a03000 	mov	r3, #0
	ept = memalign(CACHE_LINE, ROUNDUP(sizeof(*ept), CACHE_LINE));
8f605e38:	e1a0800e 	mov	r8, r14
{
8f605e3c:	e1a06002 	mov	r6, r2
	ept = memalign(CACHE_LINE, ROUNDUP(sizeof(*ept), CACHE_LINE));
8f605e40:	eb00b87f 	bl	8f634044 <memalign>
	ASSERT(ept);
8f605e44:	e2504000 	subs	r4, r0, #0
8f605e48:	0a000032 	beq	8f605f18 <_udc_endpoint_alloc+0x108>
	ept->in = !!in;
8f605e4c:	e3570000 	cmp	r7, #0
	ept->req = 0;
8f605e50:	e3a02000 	mov	r2, #0
	cfg = CONFIG_MAX_PKT(max_pkt) | CONFIG_ZLT;
8f605e54:	e1a03806 	lsl	r3, r6, #16
	ept->req = 0;
8f605e58:	e584200c 	str	r2, [r4, #12]
	ept->in = !!in;
8f605e5c:	13a00001 	movne	r0, #1
8f605e60:	01a00002 	moveq	r0, r2
	cfg = CONFIG_MAX_PKT(max_pkt) | CONFIG_ZLT;
8f605e64:	e3831202 	orr	r1, r3, #536870912	; 0x20000000
	ept->maxpkt = max_pkt;
8f605e68:	e1c461b2 	strh	r6, [r4, #18]
	ept->num = num;
8f605e6c:	e5c45010 	strb	r5, [r4, #16]
	ept->in = !!in;
8f605e70:	e5c40011 	strb	r0, [r4, #17]
	if (ept->in) {
8f605e74:	0a00001f 	beq	8f605ef8 <_udc_endpoint_alloc+0xe8>
		ept->bit = EPT_TX(ept->num);
8f605e78:	e6ef3075 	uxtb	r3, r5
8f605e7c:	e2832010 	add	r2, r3, #16
8f605e80:	e3a03001 	mov	r3, #1
8f605e84:	e1a03213 	lsl	r3, r3, r2
8f605e88:	e5843004 	str	r3, [r4, #4]
	ept->head = epts + (num * 2) + (ept->in);
8f605e8c:	e30b3dbc 	movw	r3, #48572	; 0xbdbc
8f605e90:	e3483f72 	movt	r3, #36722	; 0x8f72
8f605e94:	e0805085 	add	r5, r0, r5, lsl #1
	arch_clean_invalidate_cache_range((addr_t) ept,
8f605e98:	e1a00004 	mov	r0, r4
	ept->head = epts + (num * 2) + (ept->in);
8f605e9c:	e5932000 	ldr	r2, [r3]
8f605ea0:	e0823305 	add	r3, r2, r5, lsl #6
8f605ea4:	e5843008 	str	r3, [r4, #8]
	ept->next = ept_list;
8f605ea8:	e30b3db8 	movw	r3, #48568	; 0xbdb8
8f605eac:	e3483f72 	movt	r3, #36722	; 0x8f72
	ept->head->config = cfg;
8f605eb0:	e7821305 	str	r1, [r2, r5, lsl #6]
	arch_clean_invalidate_cache_range((addr_t) ept,
8f605eb4:	e3a01014 	mov	r1, #20
	ept->next = ept_list;
8f605eb8:	e5932000 	ldr	r2, [r3]
	ept_list = ept;
8f605ebc:	e5834000 	str	r4, [r3]
	ept->next = ept_list;
8f605ec0:	e5842000 	str	r2, [r4]
	arch_clean_invalidate_cache_range((addr_t) ept,
8f605ec4:	eb006c35 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	arch_clean_invalidate_cache_range((addr_t) ept->head,
8f605ec8:	e5940008 	ldr	r0, [r4, #8]
8f605ecc:	e3a01040 	mov	r1, #64	; 0x40
8f605ed0:	eb006c32 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
}
8f605ed4:	e59f306c 	ldr	r3, [pc, #108]	; 8f605f48 <_udc_endpoint_alloc+0x138>
8f605ed8:	e5932000 	ldr	r2, [r3]
8f605edc:	e59d300c 	ldr	r3, [r13, #12]
8f605ee0:	e0332002 	eors	r2, r3, r2
8f605ee4:	e3a03000 	mov	r3, #0
8f605ee8:	1a000015 	bne	8f605f44 <_udc_endpoint_alloc+0x134>
8f605eec:	e1a00004 	mov	r0, r4
8f605ef0:	e28dd010 	add	r13, r13, #16
8f605ef4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
		if (num == 0)
8f605ef8:	e3550000 	cmp	r5, #0
		ept->bit = EPT_RX(ept->num);
8f605efc:	e6efc075 	uxtb	r12, r5
			cfg |= CONFIG_IOS;
8f605f00:	03831202 	orreq	r1, r3, #536870912	; 0x20000000
		ept->bit = EPT_RX(ept->num);
8f605f04:	e3a02001 	mov	r2, #1
8f605f08:	e1a02c12 	lsl	r2, r2, r12
			cfg |= CONFIG_IOS;
8f605f0c:	03811902 	orreq	r1, r1, #32768	; 0x8000
		ept->bit = EPT_RX(ept->num);
8f605f10:	e5842004 	str	r2, [r4, #4]
			cfg |= CONFIG_IOS;
8f605f14:	eaffffdc 	b	8f605e8c <_udc_endpoint_alloc+0x7c>
	ASSERT(ept);
8f605f18:	e1a00008 	mov	r0, r8
8f605f1c:	e30134bc 	movw	r3, #5308	; 0x14bc
8f605f20:	e3012498 	movw	r2, #5272	; 0x1498
8f605f24:	e3483f70 	movt	r3, #36720	; 0x8f70
8f605f28:	e3482f70 	movt	r2, #36720	; 0x8f70
8f605f2c:	e58d3000 	str	r3, [r13]
8f605f30:	e3001130 	movw	r1, #304	; 0x130
8f605f34:	e3a030a7 	mov	r3, #167	; 0xa7
8f605f38:	e3481f70 	movt	r1, #36720	; 0x8f70
8f605f3c:	eb00b2de 	bl	8f632abc <_panic>
8f605f40:	eaffffc1 	b	8f605e4c <_udc_endpoint_alloc+0x3c>
}
8f605f44:	eb00b31d 	bl	8f632bc0 <__stack_chk_fail>
8f605f48:	8f74221c 	.word	0x8f74221c

8f605f4c <udc_endpoint_alloc>:
{
8f605f4c:	e1a02001 	mov	r2, r1
	if (type == UDC_TYPE_BULK_IN) {
8f605f50:	e3500001 	cmp	r0, #1
{
8f605f54:	e59f10a0 	ldr	r1, [pc, #160]	; 8f605ffc <udc_endpoint_alloc+0xb0>
8f605f58:	e1a03000 	mov	r3, r0
8f605f5c:	e92d4030 	push	{r4, r5, r14}
8f605f60:	e24dd00c 	sub	r13, r13, #12
8f605f64:	e5911000 	ldr	r1, [r1]
8f605f68:	e58d1004 	str	r1, [r13, #4]
8f605f6c:	e3a01000 	mov	r1, #0
	if (type == UDC_TYPE_BULK_IN) {
8f605f70:	0a000002 	beq	8f605f80 <udc_endpoint_alloc+0x34>
	} else if (type == UDC_TYPE_BULK_OUT) {
8f605f74:	e3500002 	cmp	r0, #2
8f605f78:	1a00000e 	bne	8f605fb8 <udc_endpoint_alloc+0x6c>
		in = 0;
8f605f7c:	e3a03000 	mov	r3, #0
		if (ept_alloc_table & bit)
8f605f80:	e30152e8 	movw	r5, #4840	; 0x12e8
8f605f84:	e3485f71 	movt	r5, #36721	; 0x8f71
	for (n = 1; n < 16; n++) {
8f605f88:	e3a00001 	mov	r0, #1
		if (ept_alloc_table & bit)
8f605f8c:	e5951000 	ldr	r1, [r5]
		unsigned bit = in ? EPT_TX(n) : EPT_RX(n);
8f605f90:	e1a0c000 	mov	r12, r0
8f605f94:	e3530000 	cmp	r3, #0
8f605f98:	12804010 	addne	r4, r0, #16
8f605f9c:	01a0401c 	lsleq	r4, r12, r0
8f605fa0:	11a0441c 	lslne	r4, r12, r4
		if (ept_alloc_table & bit)
8f605fa4:	e1110004 	tst	r1, r4
8f605fa8:	0a00000b 	beq	8f605fdc <udc_endpoint_alloc+0x90>
	for (n = 1; n < 16; n++) {
8f605fac:	e2800001 	add	r0, r0, #1
8f605fb0:	e3500010 	cmp	r0, #16
8f605fb4:	1afffff6 	bne	8f605f94 <udc_endpoint_alloc+0x48>
		return 0;
8f605fb8:	e3a00000 	mov	r0, #0
}
8f605fbc:	e59f3038 	ldr	r3, [pc, #56]	; 8f605ffc <udc_endpoint_alloc+0xb0>
8f605fc0:	e5932000 	ldr	r2, [r3]
8f605fc4:	e59d3004 	ldr	r3, [r13, #4]
8f605fc8:	e0332002 	eors	r2, r3, r2
8f605fcc:	e3a03000 	mov	r3, #0
8f605fd0:	1a000008 	bne	8f605ff8 <udc_endpoint_alloc+0xac>
8f605fd4:	e28dd00c 	add	r13, r13, #12
8f605fd8:	e8bd8030 	pop	{r4, r5, r15}
		ept = _udc_endpoint_alloc(n, in, maxpkt);
8f605fdc:	e1a01003 	mov	r1, r3
8f605fe0:	ebffff8a 	bl	8f605e10 <_udc_endpoint_alloc>
		if (ept)
8f605fe4:	e3500000 	cmp	r0, #0
			ept_alloc_table |= bit;
8f605fe8:	15953000 	ldrne	r3, [r5]
8f605fec:	11834004 	orrne	r4, r3, r4
8f605ff0:	15854000 	strne	r4, [r5]
8f605ff4:	eafffff0 	b	8f605fbc <udc_endpoint_alloc+0x70>
}
8f605ff8:	eb00b2f0 	bl	8f632bc0 <__stack_chk_fail>
8f605ffc:	8f74221c 	.word	0x8f74221c

8f606000 <udc_request_alloc>:
{
8f606000:	e59f3098 	ldr	r3, [pc, #152]	; 8f6060a0 <udc_request_alloc+0xa0>
	req = memalign(CACHE_LINE, ROUNDUP(sizeof(*req), CACHE_LINE));
8f606004:	e3a01040 	mov	r1, #64	; 0x40
{
8f606008:	e92d4030 	push	{r4, r5, r14}
	req = memalign(CACHE_LINE, ROUNDUP(sizeof(*req), CACHE_LINE));
8f60600c:	e1a00001 	mov	r0, r1
{
8f606010:	e24dd014 	sub	r13, r13, #20
8f606014:	e1a0500e 	mov	r5, r14
8f606018:	e5933000 	ldr	r3, [r3]
8f60601c:	e58d300c 	str	r3, [r13, #12]
8f606020:	e3a03000 	mov	r3, #0
	req = memalign(CACHE_LINE, ROUNDUP(sizeof(*req), CACHE_LINE));
8f606024:	eb00b806 	bl	8f634044 <memalign>
	ASSERT(req);
8f606028:	e2504000 	subs	r4, r0, #0
8f60602c:	0a00000f 	beq	8f606070 <udc_request_alloc+0x70>
	req->item = memalign(CACHE_LINE, ROUNDUP(sizeof(struct ept_queue_item),
8f606030:	e3a01040 	mov	r1, #64	; 0x40
	req->req.buf = 0;
8f606034:	e3a03000 	mov	r3, #0
	req->item = memalign(CACHE_LINE, ROUNDUP(sizeof(struct ept_queue_item),
8f606038:	e1a00001 	mov	r0, r1
	req->req.buf = 0;
8f60603c:	e5843000 	str	r3, [r4]
	req->req.length = 0;
8f606040:	e5843004 	str	r3, [r4, #4]
	req->item = memalign(CACHE_LINE, ROUNDUP(sizeof(struct ept_queue_item),
8f606044:	eb00b7fe 	bl	8f634044 <memalign>
}
8f606048:	e59f3050 	ldr	r3, [pc, #80]	; 8f6060a0 <udc_request_alloc+0xa0>
	req->item = memalign(CACHE_LINE, ROUNDUP(sizeof(struct ept_queue_item),
8f60604c:	e5840010 	str	r0, [r4, #16]
}
8f606050:	e5932000 	ldr	r2, [r3]
8f606054:	e59d300c 	ldr	r3, [r13, #12]
8f606058:	e0332002 	eors	r2, r3, r2
8f60605c:	e3a03000 	mov	r3, #0
8f606060:	1a00000d 	bne	8f60609c <udc_request_alloc+0x9c>
8f606064:	e1a00004 	mov	r0, r4
8f606068:	e28dd014 	add	r13, r13, #20
8f60606c:	e8bd8030 	pop	{r4, r5, r15}
	ASSERT(req);
8f606070:	e301c4c0 	movw	r12, #5312	; 0x14c0
8f606074:	e3012498 	movw	r2, #5272	; 0x1498
8f606078:	e348cf70 	movt	r12, #36720	; 0x8f70
8f60607c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f606080:	e3001130 	movw	r1, #304	; 0x130
8f606084:	e3003107 	movw	r3, #263	; 0x107
8f606088:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60608c:	e1a00005 	mov	r0, r5
8f606090:	e58dc000 	str	r12, [r13]
8f606094:	eb00b288 	bl	8f632abc <_panic>
8f606098:	eaffffe4 	b	8f606030 <udc_request_alloc+0x30>
}
8f60609c:	eb00b2c7 	bl	8f632bc0 <__stack_chk_fail>
8f6060a0:	8f74221c 	.word	0x8f74221c

8f6060a4 <udc_request_free>:
{
8f6060a4:	e59f3038 	ldr	r3, [pc, #56]	; 8f6060e4 <udc_request_free+0x40>
8f6060a8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6060ac:	e24dd00c 	sub	r13, r13, #12
8f6060b0:	e5933000 	ldr	r3, [r3]
8f6060b4:	e58d3004 	str	r3, [r13, #4]
8f6060b8:	e3a03000 	mov	r3, #0
	free(req);
8f6060bc:	e59f3020 	ldr	r3, [pc, #32]	; 8f6060e4 <udc_request_free+0x40>
8f6060c0:	e5932000 	ldr	r2, [r3]
8f6060c4:	e59d3004 	ldr	r3, [r13, #4]
8f6060c8:	e0332002 	eors	r2, r3, r2
8f6060cc:	e3a03000 	mov	r3, #0
8f6060d0:	1a000002 	bne	8f6060e0 <udc_request_free+0x3c>
}
8f6060d4:	e28dd00c 	add	r13, r13, #12
8f6060d8:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	free(req);
8f6060dc:	ea00b80a 	b	8f63410c <free>
8f6060e0:	eb00b2b6 	bl	8f632bc0 <__stack_chk_fail>
8f6060e4:	8f74221c 	.word	0x8f74221c

8f6060e8 <udc_request_queue>:
{
8f6060e8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	curr_item->page1 = (phys & 0xfffff000) + 0x1000;
8f6060ec:	e3a06a0f 	mov	r6, #61440	; 0xf000
	unsigned phys = (unsigned)req->req.buf;
8f6060f0:	e8910028 	ldm	r1, {r3, r5}
{
8f6060f4:	e24dd014 	sub	r13, r13, #20
	curr_item = req->item;
8f6060f8:	e5914010 	ldr	r4, [r1, #16]
	curr_item->page1 = (phys & 0xfffff000) + 0x1000;
8f6060fc:	e34f6fff 	movt	r6, #65535	; 0xffff
	xfer = (len > MAX_TD_XFER_SIZE) ? MAX_TD_XFER_SIZE : len;
8f606100:	e3550901 	cmp	r5, #16384	; 0x4000
{
8f606104:	e59f21f8 	ldr	r2, [pc, #504]	; 8f606304 <udc_request_queue+0x21c>
8f606108:	e1a07001 	mov	r7, r1
8f60610c:	e1a08000 	mov	r8, r0
	xfer = (len > MAX_TD_XFER_SIZE) ? MAX_TD_XFER_SIZE : len;
8f606110:	31a0b005 	movcc	r11, r5
8f606114:	23a0b901 	movcs	r11, #16384	; 0x4000
	while (len > 0) {
8f606118:	e055500b 	subs	r5, r5, r11
{
8f60611c:	e5922000 	ldr	r2, [r2]
8f606120:	e58d200c 	str	r2, [r13, #12]
8f606124:	e3a02000 	mov	r2, #0
	curr_item->info = INFO_BYTES(xfer) | INFO_ACTIVE;
8f606128:	e1a0280b 	lsl	r2, r11, #16
	curr_item->page0 = phys;
8f60612c:	e5843008 	str	r3, [r4, #8]
	phys += xfer;
8f606130:	e083b00b 	add	r11, r3, r11
	curr_item->page1 = (phys & 0xfffff000) + 0x1000;
8f606134:	e0033006 	and	r3, r3, r6
8f606138:	e2831a01 	add	r1, r3, #4096	; 0x1000
	curr_item->info = INFO_BYTES(xfer) | INFO_ACTIVE;
8f60613c:	e3822080 	orr	r2, r2, #128	; 0x80
	curr_item->page1 = (phys & 0xfffff000) + 0x1000;
8f606140:	e584100c 	str	r1, [r4, #12]
	curr_item->page2 = (phys & 0xfffff000) + 0x2000;
8f606144:	e2831a02 	add	r1, r3, #8192	; 0x2000
	curr_item->info = INFO_BYTES(xfer) | INFO_ACTIVE;
8f606148:	e5842004 	str	r2, [r4, #4]
	curr_item->page2 = (phys & 0xfffff000) + 0x2000;
8f60614c:	e5841010 	str	r1, [r4, #16]
	curr_item->page3 = (phys & 0xfffff000) + 0x3000;
8f606150:	e2831a03 	add	r1, r3, #12288	; 0x3000
	curr_item->page4 = (phys & 0xfffff000) + 0x4000;
8f606154:	e2833901 	add	r3, r3, #16384	; 0x4000
	curr_item->page3 = (phys & 0xfffff000) + 0x3000;
8f606158:	e5841014 	str	r1, [r4, #20]
	curr_item->page4 = (phys & 0xfffff000) + 0x4000;
8f60615c:	e5843018 	str	r3, [r4, #24]
	while (len > 0) {
8f606160:	0a000023 	beq	8f6061f4 <udc_request_queue+0x10c>
				curr_item->next = PA((addr_t)transfer_desc_item);
8f606164:	e30b3e00 	movw	r3, #48640	; 0xbe00
8f606168:	e3483f72 	movt	r3, #36722	; 0x8f72
8f60616c:	e58d3004 	str	r3, [r13, #4]
8f606170:	ea000010 	b	8f6061b8 <udc_request_queue+0xd0>
			item = (struct ept_queue_item *)VA(curr_item->next);
8f606174:	e1a00009 	mov	r0, r9
8f606178:	ebffed85 	bl	8f601794 <platform_get_phys_to_virt_mapping>
8f60617c:	e1a04000 	mov	r4, r0
	while (len > 0) {
8f606180:	e055500a 	subs	r5, r5, r10
		item->page1 = (phys & 0xfffff000) + 0x1000;
8f606184:	e00b3006 	and	r3, r11, r6
		item->info = INFO_BYTES(xfer) | INFO_ACTIVE;
8f606188:	e1a0280a 	lsl	r2, r10, #16
		item->page1 = (phys & 0xfffff000) + 0x1000;
8f60618c:	e283ca01 	add	r12, r3, #4096	; 0x1000
		item->page2 = (phys & 0xfffff000) + 0x2000;
8f606190:	e2830a02 	add	r0, r3, #8192	; 0x2000
		item->page3 = (phys & 0xfffff000) + 0x3000;
8f606194:	e2831a03 	add	r1, r3, #12288	; 0x3000
		item->info = INFO_BYTES(xfer) | INFO_ACTIVE;
8f606198:	e3822080 	orr	r2, r2, #128	; 0x80
		item->page4 = (phys & 0xfffff000) + 0x4000;
8f60619c:	e2833901 	add	r3, r3, #16384	; 0x4000
		item->info = INFO_BYTES(xfer) | INFO_ACTIVE;
8f6061a0:	e9840804 	stmib	r4, {r2, r11}
		phys += xfer;
8f6061a4:	e08bb00a 	add	r11, r11, r10
		item->page1 = (phys & 0xfffff000) + 0x1000;
8f6061a8:	e584c00c 	str	r12, [r4, #12]
		item->page3 = (phys & 0xfffff000) + 0x3000;
8f6061ac:	e1c401f0 	strd	r0, [r4, #16]
		item->page4 = (phys & 0xfffff000) + 0x4000;
8f6061b0:	e5843018 	str	r3, [r4, #24]
	while (len > 0) {
8f6061b4:	0a00000e 	beq	8f6061f4 <udc_request_queue+0x10c>
		xfer = (len > MAX_TD_XFER_SIZE) ? MAX_TD_XFER_SIZE : len;
8f6061b8:	e3550901 	cmp	r5, #16384	; 0x4000
		if (curr_item->next == TERMINATE) {
8f6061bc:	e5949000 	ldr	r9, [r4]
		xfer = (len > MAX_TD_XFER_SIZE) ? MAX_TD_XFER_SIZE : len;
8f6061c0:	31a0a005 	movcc	r10, r5
8f6061c4:	23a0a901 	movcs	r10, #16384	; 0x4000
		if (curr_item->next == TERMINATE) {
8f6061c8:	e3590001 	cmp	r9, #1
8f6061cc:	1affffe8 	bne	8f606174 <udc_request_queue+0x8c>
				curr_item->next = PA((addr_t)transfer_desc_item);
8f6061d0:	e30b0e00 	movw	r0, #48640	; 0xbe00
8f6061d4:	e3480f72 	movt	r0, #36722	; 0x8f72
8f6061d8:	ebffed5d 	bl	8f601754 <platform_get_virt_to_phys_mapping>
				item->next = TERMINATE;
8f6061dc:	e59d3004 	ldr	r3, [r13, #4]
				curr_item->next = PA((addr_t)transfer_desc_item);
8f6061e0:	e5840000 	str	r0, [r4]
				item = (struct ept_queue_item *)transfer_desc_item;
8f6061e4:	e30b4e00 	movw	r4, #48640	; 0xbe00
				item->next = TERMINATE;
8f6061e8:	e5839000 	str	r9, [r3]
				item = (struct ept_queue_item *)transfer_desc_item;
8f6061ec:	e3484f72 	movt	r4, #36722	; 0x8f72
8f6061f0:	eaffffe2 	b	8f606180 <udc_request_queue+0x98>
/* critical sections */
extern int critical_section_count;

static inline __ALWAYS_INLINE void enter_critical_section(void)
{
	critical_section_count++;
8f6061f4:	e3015acc 	movw	r5, #6860	; 0x1acc
8f6061f8:	e3485f71 	movt	r5, #36721	; 0x8f71
	curr_item->next = TERMINATE;
8f6061fc:	e3a03001 	mov	r3, #1
8f606200:	e5843000 	str	r3, [r4]
8f606204:	e5953000 	ldr	r3, [r5]
	curr_item->info |= INFO_IOC;
8f606208:	e3822902 	orr	r2, r2, #32768	; 0x8000
8f60620c:	e5842004 	str	r2, [r4, #4]
8f606210:	e2833001 	add	r3, r3, #1
8f606214:	e5853000 	str	r3, [r5]
	if (critical_section_count == 1)
8f606218:	e3530001 	cmp	r3, #1
8f60621c:	0a000035 	beq	8f6062f8 <udc_request_queue+0x210>
	ept->head->next = PA((addr_t)req->item);
8f606220:	e5970010 	ldr	r0, [r7, #16]
8f606224:	e5984008 	ldr	r4, [r8, #8]
8f606228:	ebffed49 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	ept->head->info = 0;
8f60622c:	e5983008 	ldr	r3, [r8, #8]
8f606230:	e3a02000 	mov	r2, #0
	arch_clean_invalidate_cache_range((addr_t) ept,
8f606234:	e3a01014 	mov	r1, #20
	ept->head->next = PA((addr_t)req->item);
8f606238:	e5840008 	str	r0, [r4, #8]
	arch_clean_invalidate_cache_range((addr_t) ept,
8f60623c:	e1a00008 	mov	r0, r8
	ept->head->info = 0;
8f606240:	e583200c 	str	r2, [r3, #12]
	ept->req = req;
8f606244:	e588700c 	str	r7, [r8, #12]
	arch_clean_invalidate_cache_range((addr_t) ept,
8f606248:	eb006b54 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	arch_clean_invalidate_cache_range((addr_t) ept->head,
8f60624c:	e5980008 	ldr	r0, [r8, #8]
8f606250:	e3a01040 	mov	r1, #64	; 0x40
8f606254:	eb006b51 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	arch_clean_invalidate_cache_range((addr_t) ept->req,
8f606258:	e3a01014 	mov	r1, #20
8f60625c:	e598000c 	ldr	r0, [r8, #12]
8f606260:	eb006b4e 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	arch_clean_invalidate_cache_range((addr_t) VA((addr_t)req->req.buf),
8f606264:	e5970000 	ldr	r0, [r7]
8f606268:	ebffed49 	bl	8f601794 <platform_get_phys_to_virt_mapping>
8f60626c:	e5971004 	ldr	r1, [r7, #4]
8f606270:	eb006b4a 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	item = req->item;
8f606274:	e5970010 	ldr	r0, [r7, #16]
	while (item != NULL) {
8f606278:	e3500000 	cmp	r0, #0
8f60627c:	1a000004 	bne	8f606294 <udc_request_queue+0x1ac>
8f606280:	ea000008 	b	8f6062a8 <udc_request_queue+0x1c0>
		arch_clean_invalidate_cache_range((addr_t) curr_item,
8f606284:	eb006b45 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	while (item != NULL) {
8f606288:	e3540000 	cmp	r4, #0
8f60628c:	0a000005 	beq	8f6062a8 <udc_request_queue+0x1c0>
8f606290:	e1a00004 	mov	r0, r4
		if (curr_item->next == TERMINATE)
8f606294:	e5904000 	ldr	r4, [r0]
		arch_clean_invalidate_cache_range((addr_t) curr_item,
8f606298:	e3a01020 	mov	r1, #32
		if (curr_item->next == TERMINATE)
8f60629c:	e3540001 	cmp	r4, #1
8f6062a0:	1afffff7 	bne	8f606284 <udc_request_queue+0x19c>
		arch_clean_invalidate_cache_range((addr_t) curr_item,
8f6062a4:	eb006b3d 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	writel(ept->bit, USB_ENDPTPRIME);
8f6062a8:	e5982004 	ldr	r2, [r8, #4]
8f6062ac:	e3a03a0b 	mov	r3, #45056	; 0xb000
8f6062b0:	e340378d 	movt	r3, #1933	; 0x78d
8f6062b4:	e58321b0 	str	r2, [r3, #432]	; 0x1b0
		arch_disable_ints();
}

static inline __ALWAYS_INLINE void exit_critical_section(void)
{
	critical_section_count--;
8f6062b8:	e5953000 	ldr	r3, [r5]
8f6062bc:	e2433001 	sub	r3, r3, #1
8f6062c0:	e5853000 	str	r3, [r5]
	if (critical_section_count == 0)
8f6062c4:	e3530000 	cmp	r3, #0
8f6062c8:	0a000008 	beq	8f6062f0 <udc_request_queue+0x208>
}
8f6062cc:	e59f3030 	ldr	r3, [pc, #48]	; 8f606304 <udc_request_queue+0x21c>
8f6062d0:	e5932000 	ldr	r2, [r3]
8f6062d4:	e59d300c 	ldr	r3, [r13, #12]
8f6062d8:	e0332002 	eors	r2, r3, r2
8f6062dc:	e3a03000 	mov	r3, #0
8f6062e0:	1a000006 	bne	8f606300 <udc_request_queue+0x218>
8f6062e4:	e3a00000 	mov	r0, #0
8f6062e8:	e28dd014 	add	r13, r13, #20
8f6062ec:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		arch_enable_ints();
8f6062f0:	eb006b44 	bl	8f621008 <arch_enable_ints>
8f6062f4:	eafffff4 	b	8f6062cc <udc_request_queue+0x1e4>
		arch_disable_ints();
8f6062f8:	eb006b46 	bl	8f621018 <arch_disable_ints>
8f6062fc:	eaffffc7 	b	8f606220 <udc_request_queue+0x138>
8f606300:	eb00b22e 	bl	8f632bc0 <__stack_chk_fail>
8f606304:	8f74221c 	.word	0x8f74221c

8f606308 <setup_tx>:
		udc_request_queue(ep0out, req);
	}
}

static void setup_tx(void *buf, unsigned len)
{
8f606308:	e92d4030 	push	{r4, r5, r14}
	DBG("setup_tx %p %d\n", buf, len);
	memcpy(ep0req->buf, buf, len);
8f60630c:	e30b4db4 	movw	r4, #48564	; 0xbdb4
8f606310:	e3484f72 	movt	r4, #36722	; 0x8f72
{
8f606314:	e1a05001 	mov	r5, r1
8f606318:	e1a01000 	mov	r1, r0
8f60631c:	e59f0080 	ldr	r0, [pc, #128]	; 8f6063a4 <setup_tx+0x9c>
	memcpy(ep0req->buf, buf, len);
8f606320:	e5943000 	ldr	r3, [r4]
{
8f606324:	e24dd00c 	sub	r13, r13, #12
	memcpy(ep0req->buf, buf, len);
8f606328:	e1a02005 	mov	r2, r5
{
8f60632c:	e5900000 	ldr	r0, [r0]
8f606330:	e58d0004 	str	r0, [r13, #4]
8f606334:	e3a00000 	mov	r0, #0
	memcpy(ep0req->buf, buf, len);
8f606338:	e5930000 	ldr	r0, [r3]
8f60633c:	eb00b79d 	bl	8f6341b8 <memcpy>
	ep0req->buf = (void *)PA((addr_t)ep0req->buf);
8f606340:	e5943000 	ldr	r3, [r4]
8f606344:	e5930000 	ldr	r0, [r3]
8f606348:	ebffed01 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f60634c:	e5943000 	ldr	r3, [r4]
	arch_clean_invalidate_cache_range((addr_t)ep0req->buf, len);
8f606350:	e1a01005 	mov	r1, r5
	ep0req->buf = (void *)PA((addr_t)ep0req->buf);
8f606354:	e5830000 	str	r0, [r3]
	arch_clean_invalidate_cache_range((addr_t)ep0req->buf, len);
8f606358:	eb006b10 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	ep0req->complete = ep0in_complete;
8f60635c:	e5941000 	ldr	r1, [r4]
8f606360:	e30633a8 	movw	r3, #25512	; 0x63a8
8f606364:	e3483f60 	movt	r3, #36704	; 0x8f60
8f606368:	e5813008 	str	r3, [r1, #8]
	ep0req->length = len;
	udc_request_queue(ep0in, ep0req);
8f60636c:	e59f3030 	ldr	r3, [pc, #48]	; 8f6063a4 <setup_tx+0x9c>
	ep0req->length = len;
8f606370:	e5815004 	str	r5, [r1, #4]
	udc_request_queue(ep0in, ep0req);
8f606374:	e5932000 	ldr	r2, [r3]
8f606378:	e59d3004 	ldr	r3, [r13, #4]
8f60637c:	e0332002 	eors	r2, r3, r2
8f606380:	e3a03000 	mov	r3, #0
8f606384:	1a000005 	bne	8f6063a0 <setup_tx+0x98>
8f606388:	e30b3dac 	movw	r3, #48556	; 0xbdac
8f60638c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f606390:	e5930000 	ldr	r0, [r3]
}
8f606394:	e28dd00c 	add	r13, r13, #12
8f606398:	e8bd4030 	pop	{r4, r5, r14}
	udc_request_queue(ep0in, ep0req);
8f60639c:	eaffff51 	b	8f6060e8 <udc_request_queue>
8f6063a0:	eb00b206 	bl	8f632bc0 <__stack_chk_fail>
8f6063a4:	8f74221c 	.word	0x8f74221c

8f6063a8 <ep0in_complete>:
{
8f6063a8:	e59f3078 	ldr	r3, [pc, #120]	; 8f606428 <ep0in_complete+0x80>
	if (status == 0) {
8f6063ac:	e3520000 	cmp	r2, #0
{
8f6063b0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6063b4:	e24dd00c 	sub	r13, r13, #12
8f6063b8:	e5933000 	ldr	r3, [r3]
8f6063bc:	e58d3004 	str	r3, [r13, #4]
8f6063c0:	e3a03000 	mov	r3, #0
	if (status == 0) {
8f6063c4:	0a000007 	beq	8f6063e8 <ep0in_complete+0x40>
}
8f6063c8:	e59f3058 	ldr	r3, [pc, #88]	; 8f606428 <ep0in_complete+0x80>
8f6063cc:	e5932000 	ldr	r2, [r3]
8f6063d0:	e59d3004 	ldr	r3, [r13, #4]
8f6063d4:	e0332002 	eors	r2, r3, r2
8f6063d8:	e3a03000 	mov	r3, #0
8f6063dc:	1a000010 	bne	8f606424 <ep0in_complete+0x7c>
8f6063e0:	e28dd00c 	add	r13, r13, #12
8f6063e4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		udc_request_queue(ep0out, req);
8f6063e8:	e59f3038 	ldr	r3, [pc, #56]	; 8f606428 <ep0in_complete+0x80>
		req->length = 0;
8f6063ec:	e5802004 	str	r2, [r0, #4]
		req->complete = 0;
8f6063f0:	e5802008 	str	r2, [r0, #8]
		udc_request_queue(ep0out, req);
8f6063f4:	e5932000 	ldr	r2, [r3]
8f6063f8:	e59d3004 	ldr	r3, [r13, #4]
8f6063fc:	e0332002 	eors	r2, r3, r2
8f606400:	e3a03000 	mov	r3, #0
8f606404:	1a000006 	bne	8f606424 <ep0in_complete+0x7c>
8f606408:	e30b3db0 	movw	r3, #48560	; 0xbdb0
8f60640c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f606410:	e1a01000 	mov	r1, r0
8f606414:	e5930000 	ldr	r0, [r3]
}
8f606418:	e28dd00c 	add	r13, r13, #12
8f60641c:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		udc_request_queue(ep0out, req);
8f606420:	eaffff30 	b	8f6060e8 <udc_request_queue>
}
8f606424:	eb00b1e5 	bl	8f632bc0 <__stack_chk_fail>
8f606428:	8f74221c 	.word	0x8f74221c

8f60642c <udc_interrupt>:
	the_device = dev;
	return 0;
}

enum handler_return udc_interrupt(void *arg)
{
8f60642c:	e59f26a0 	ldr	r2, [pc, #1696]	; 8f606ad4 <udc_interrupt+0x6a8>
	struct udc_endpoint *ept;
	unsigned ret = INT_NO_RESCHEDULE;
	unsigned n = readl(USB_USBSTS);
8f606430:	e3a03a0b 	mov	r3, #45056	; 0xb000
{
8f606434:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f606438:	e24dd020 	sub	r13, r13, #32
	unsigned n = readl(USB_USBSTS);
8f60643c:	e340378d 	movt	r3, #1933	; 0x78d
{
8f606440:	e5922000 	ldr	r2, [r2]
8f606444:	e58d201c 	str	r2, [r13, #28]
8f606448:	e3a02000 	mov	r2, #0
	writel(n, USB_USBSTS);

	DBG("\nudc_interrupt(): status = 0x%x\n", n);

	n &= (STS_SLI | STS_URI | STS_PCI | STS_UI | STS_UEI);
8f60644c:	e3000147 	movw	r0, #327	; 0x147
	unsigned n = readl(USB_USBSTS);
8f606450:	e5935144 	ldr	r5, [r3, #324]	; 0x144

	if (n == 0) {
8f606454:	e0150000 	ands	r0, r5, r0
	writel(n, USB_USBSTS);
8f606458:	e5835144 	str	r5, [r3, #324]	; 0x144
	if (n == 0) {
8f60645c:	0a000020 	beq	8f6064e4 <udc_interrupt+0xb8>
		DBG("n = 0\n");
		return ret;
	}

	if (n & STS_URI) {
8f606460:	e3150040 	tst	r5, #64	; 0x40
8f606464:	1a00003f 	bne	8f606568 <udc_interrupt+0x13c>
		usb_status(0, usb_highspeed);
	}
	if (n & STS_SLI) {
		DBG("-- suspend --\n");
	}
	if (n & STS_PCI) {
8f606468:	e3150004 	tst	r5, #4
8f60646c:	1a00002d 	bne	8f606528 <udc_interrupt+0xfc>
			usb_highspeed = 1;
		} else {
			usb_highspeed = 0;
		}
	}
	if (n & STS_UEI) {
8f606470:	e3150002 	tst	r5, #2
8f606474:	1a000022 	bne	8f606504 <udc_interrupt+0xd8>
		DBG("STS_UEI\n");
		dprintf(INFO, "<UEI %x>\n", readl(USB_ENDPTCOMPLETE));
	}
	if ((n & STS_UI) || (n & STS_UEI)) {
8f606478:	e2150003 	ands	r0, r5, #3
8f60647c:	0a000018 	beq	8f6064e4 <udc_interrupt+0xb8>
		if (n & STS_UEI)
			DBG("ERROR ");
		if (n & STS_UI)
			DBG("USB ");

		n = readl(USB_ENDPTSETUPSTAT);
8f606480:	e3a04a0b 	mov	r4, #45056	; 0xb000
8f606484:	e340478d 	movt	r4, #1933	; 0x78d
8f606488:	e59401ac 	ldr	r0, [r4, #428]	; 0x1ac
		if (n & EPT_RX(0)) {
8f60648c:	e2105001 	ands	r5, r0, #1
8f606490:	1a00005b 	bne	8f606604 <udc_interrupt+0x1d8>
8f606494:	e30b4db8 	movw	r4, #48568	; 0xbdb8
8f606498:	e3484f72 	movt	r4, #36722	; 0x8f72
			handle_setup(ep0out);
			ret = INT_RESCHEDULE;
		}

		n = readl(USB_ENDPTCOMPLETE);
8f60649c:	e3a03a0b 	mov	r3, #45056	; 0xb000
8f6064a0:	e340378d 	movt	r3, #1933	; 0x78d
8f6064a4:	e59361bc 	ldr	r6, [r3, #444]	; 0x1bc
		if (n != 0) {
8f6064a8:	e3560000 	cmp	r6, #0
			writel(n, USB_ENDPTCOMPLETE);
8f6064ac:	158361bc 	strne	r6, [r3, #444]	; 0x1bc
		}

		for (ept = ept_list; ept; ept = ept->next) {
8f6064b0:	e5944000 	ldr	r4, [r4]
8f6064b4:	e3540000 	cmp	r4, #0
8f6064b8:	0a000008 	beq	8f6064e0 <udc_interrupt+0xb4>
			if (n & ept->bit) {
8f6064bc:	e5943004 	ldr	r3, [r4, #4]
8f6064c0:	e1160003 	tst	r6, r3
8f6064c4:	0afffff9 	beq	8f6064b0 <udc_interrupt+0x84>
				handle_ept_complete(ept);
8f6064c8:	e1a00004 	mov	r0, r4
				ret = INT_RESCHEDULE;
8f6064cc:	e3a05001 	mov	r5, #1
				handle_ept_complete(ept);
8f6064d0:	ebfffd3e 	bl	8f6059d0 <handle_ept_complete>
		for (ept = ept_list; ept; ept = ept->next) {
8f6064d4:	e5944000 	ldr	r4, [r4]
8f6064d8:	e3540000 	cmp	r4, #0
8f6064dc:	1afffff6 	bne	8f6064bc <udc_interrupt+0x90>
			}
		}
	}
	return ret;
8f6064e0:	e6ef0075 	uxtb	r0, r5
}
8f6064e4:	e59f35e8 	ldr	r3, [pc, #1512]	; 8f606ad4 <udc_interrupt+0x6a8>
8f6064e8:	e5932000 	ldr	r2, [r3]
8f6064ec:	e59d301c 	ldr	r3, [r13, #28]
8f6064f0:	e0332002 	eors	r2, r3, r2
8f6064f4:	e3a03000 	mov	r3, #0
8f6064f8:	1a000174 	bne	8f606ad0 <udc_interrupt+0x6a4>
8f6064fc:	e28dd020 	add	r13, r13, #32
8f606500:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
		dprintf(INFO, "<UEI %x>\n", readl(USB_ENDPTCOMPLETE));
8f606504:	e3a03a0b 	mov	r3, #45056	; 0xb000
8f606508:	e340378d 	movt	r3, #1933	; 0x78d
8f60650c:	e30104f4 	movw	r0, #5364	; 0x14f4
8f606510:	e3480f70 	movt	r0, #36720	; 0x8f70
8f606514:	e59311bc 	ldr	r1, [r3, #444]	; 0x1bc
8f606518:	eb00b115 	bl	8f632974 <_dprintf>
	if ((n & STS_UI) || (n & STS_UEI)) {
8f60651c:	e2150003 	ands	r0, r5, #3
8f606520:	0affffef 	beq	8f6064e4 <udc_interrupt+0xb8>
8f606524:	eaffffd5 	b	8f606480 <udc_interrupt+0x54>
		dprintf(INFO, "-- portchange --\n");
8f606528:	e30104e0 	movw	r0, #5344	; 0x14e0
8f60652c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f606530:	eb00b10f 	bl	8f632974 <_dprintf>
		unsigned spd = (readl(USB_PORTSC) >> 26) & 3;
8f606534:	e3a03a0b 	mov	r3, #45056	; 0xb000
8f606538:	e340378d 	movt	r3, #1933	; 0x78d
8f60653c:	e5933184 	ldr	r3, [r3, #388]	; 0x184
8f606540:	e7e13d53 	ubfx	r3, r3, #26, #2
		if (spd == 2) {
8f606544:	e3530002 	cmp	r3, #2
			usb_highspeed = 1;
8f606548:	e30b3e44 	movw	r3, #48708	; 0xbe44
8f60654c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f606550:	03a02001 	moveq	r2, #1
			usb_highspeed = 0;
8f606554:	13a02000 	movne	r2, #0
	if (n & STS_UEI) {
8f606558:	e3150002 	tst	r5, #2
			usb_highspeed = 0;
8f60655c:	e5832000 	str	r2, [r3]
	if (n & STS_UEI) {
8f606560:	0affffc4 	beq	8f606478 <udc_interrupt+0x4c>
8f606564:	eaffffe6 	b	8f606504 <udc_interrupt+0xd8>
		writel(readl(USB_ENDPTCOMPLETE), USB_ENDPTCOMPLETE);
8f606568:	e59311bc 	ldr	r1, [r3, #444]	; 0x1bc
		writel(0, USB_ENDPTCTRL(1));
8f60656c:	e3a04000 	mov	r4, #0
		writel(0xffffffff, USB_ENDPTFLUSH);
8f606570:	e3e02000 	mvn	r2, #0
		dprintf(INFO, "-- reset --\n");
8f606574:	e30104d0 	movw	r0, #5328	; 0x14d0
8f606578:	e3480f70 	movt	r0, #36720	; 0x8f70
		writel(readl(USB_ENDPTCOMPLETE), USB_ENDPTCOMPLETE);
8f60657c:	e58311bc 	str	r1, [r3, #444]	; 0x1bc
		writel(readl(USB_ENDPTSETUPSTAT), USB_ENDPTSETUPSTAT);
8f606580:	e59311ac 	ldr	r1, [r3, #428]	; 0x1ac
8f606584:	e58311ac 	str	r1, [r3, #428]	; 0x1ac
		writel(0xffffffff, USB_ENDPTFLUSH);
8f606588:	e58321b4 	str	r2, [r3, #436]	; 0x1b4
		writel(0, USB_ENDPTCTRL(1));
8f60658c:	e58341c4 	str	r4, [r3, #452]	; 0x1c4
		dprintf(INFO, "-- reset --\n");
8f606590:	eb00b0f7 	bl	8f632974 <_dprintf>
		the_gadget->notify(the_gadget, UDC_EVENT_OFFLINE);
8f606594:	e30b2dc8 	movw	r2, #48584	; 0xbdc8
8f606598:	e3482f72 	movt	r2, #36722	; 0x8f72
		usb_config_value = 0;
8f60659c:	e30b3e40 	movw	r3, #48704	; 0xbe40
8f6065a0:	e3483f72 	movt	r3, #36722	; 0x8f72
		the_gadget->notify(the_gadget, UDC_EVENT_OFFLINE);
8f6065a4:	e3a01002 	mov	r1, #2
8f6065a8:	e5920000 	ldr	r0, [r2]
		usb_config_value = 0;
8f6065ac:	e5c34000 	strb	r4, [r3]
		for (ept = ept_list; ept; ept = ept->next) {
8f6065b0:	e30b4db8 	movw	r4, #48568	; 0xbdb8
8f6065b4:	e3484f72 	movt	r4, #36722	; 0x8f72
		the_gadget->notify(the_gadget, UDC_EVENT_OFFLINE);
8f6065b8:	e5903000 	ldr	r3, [r0]
8f6065bc:	e12fff33 	blx	r3
		for (ept = ept_list; ept; ept = ept->next) {
8f6065c0:	e5944000 	ldr	r4, [r4]
8f6065c4:	e3540000 	cmp	r4, #0
8f6065c8:	0affffa6 	beq	8f606468 <udc_interrupt+0x3c>
				ept->req->item->info = INFO_HALTED;
8f6065cc:	e3a06040 	mov	r6, #64	; 0x40
			if (ept->req) {
8f6065d0:	e594300c 	ldr	r3, [r4, #12]
8f6065d4:	e3530000 	cmp	r3, #0
8f6065d8:	0a000003 	beq	8f6065ec <udc_interrupt+0x1c0>
				ept->req->item->info = INFO_HALTED;
8f6065dc:	e5933010 	ldr	r3, [r3, #16]
				handle_ept_complete(ept);
8f6065e0:	e1a00004 	mov	r0, r4
				ept->req->item->info = INFO_HALTED;
8f6065e4:	e5836004 	str	r6, [r3, #4]
				handle_ept_complete(ept);
8f6065e8:	ebfffcf8 	bl	8f6059d0 <handle_ept_complete>
		for (ept = ept_list; ept; ept = ept->next) {
8f6065ec:	e5944000 	ldr	r4, [r4]
8f6065f0:	e3540000 	cmp	r4, #0
8f6065f4:	1afffff5 	bne	8f6065d0 <udc_interrupt+0x1a4>
	if (n & STS_PCI) {
8f6065f8:	e3150004 	tst	r5, #4
8f6065fc:	0affff9b 	beq	8f606470 <udc_interrupt+0x44>
8f606600:	eaffffc8 	b	8f606528 <udc_interrupt+0xfc>
			handle_setup(ep0out);
8f606604:	e30b3db0 	movw	r3, #48560	; 0xbdb0
8f606608:	e3483f72 	movt	r3, #36722	; 0x8f72
	arch_clean_invalidate_cache_range((addr_t) ept->head->setup_data,
8f60660c:	e3a01040 	mov	r1, #64	; 0x40
			handle_setup(ep0out);
8f606610:	e5936000 	ldr	r6, [r3]
	arch_clean_invalidate_cache_range((addr_t) ept->head->setup_data,
8f606614:	e5960008 	ldr	r0, [r6, #8]
8f606618:	e2800028 	add	r0, r0, #40	; 0x28
8f60661c:	eb006a5f 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	memcpy(&s, ept->head->setup_data, sizeof(s));
8f606620:	e5961008 	ldr	r1, [r6, #8]
8f606624:	e3a02008 	mov	r2, #8
8f606628:	e28d0014 	add	r0, r13, #20
8f60662c:	e2811028 	add	r1, r1, #40	; 0x28
8f606630:	eb00b6e0 	bl	8f6341b8 <memcpy>
	arch_clean_invalidate_cache_range((addr_t)&s, sizeof(s));
8f606634:	e3a01008 	mov	r1, #8
8f606638:	e28d0014 	add	r0, r13, #20
8f60663c:	eb006a57 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	writel(ept->bit, USB_ENDPTSETUPSTAT);
8f606640:	e5963004 	ldr	r3, [r6, #4]
8f606644:	e58431ac 	str	r3, [r4, #428]	; 0x1ac
	switch (SETUP(s.type, s.request)) {
8f606648:	e3003201 	movw	r3, #513	; 0x201
8f60664c:	e1dd11b4 	ldrh	r1, [r13, #20]
8f606650:	e5dd2014 	ldrb	r2, [r13, #20]
8f606654:	e6bf1fb1 	rev16	r1, r1
8f606658:	e6ff1071 	uxth	r1, r1
8f60665c:	e1510003 	cmp	r1, r3
8f606660:	e5dd3015 	ldrb	r3, [r13, #21]
8f606664:	0a0000b8 	beq	8f60694c <udc_interrupt+0x520>
8f606668:	ca000019 	bgt	8f6066d4 <udc_interrupt+0x2a8>
8f60666c:	e3510009 	cmp	r1, #9
8f606670:	0a000098 	beq	8f6068d8 <udc_interrupt+0x4ac>
8f606674:	ca00002e 	bgt	8f606734 <udc_interrupt+0x308>
8f606678:	e3510003 	cmp	r1, #3
8f60667c:	0a000085 	beq	8f606898 <udc_interrupt+0x46c>
8f606680:	e3510005 	cmp	r1, #5
8f606684:	1a00007d 	bne	8f606880 <udc_interrupt+0x454>
	ep0req->complete = ep0_setup_ack_complete;
8f606688:	e30b2db4 	movw	r2, #48564	; 0xbdb4
8f60668c:	e3482f72 	movt	r2, #36722	; 0x8f72
		writel((s.value << 25) | (1 << 24), USB_DEVICEADDR);
8f606690:	e1dd31b6 	ldrh	r3, [r13, #22]
	udc_request_queue(ep0in, ep0req);
8f606694:	e30b0dac 	movw	r0, #48556	; 0xbdac
	ep0req->complete = ep0_setup_ack_complete;
8f606698:	e5921000 	ldr	r1, [r2]
	udc_request_queue(ep0in, ep0req);
8f60669c:	e3480f72 	movt	r0, #36722	; 0x8f72
	ep0req->complete = ep0_setup_ack_complete;
8f6066a0:	e3052b30 	movw	r2, #23344	; 0x5b30
8f6066a4:	e3482f60 	movt	r2, #36704	; 0x8f60
		writel((s.value << 25) | (1 << 24), USB_DEVICEADDR);
8f6066a8:	e1a03c83 	lsl	r3, r3, #25
	udc_request_queue(ep0in, ep0req);
8f6066ac:	e5900000 	ldr	r0, [r0]
		writel((s.value << 25) | (1 << 24), USB_DEVICEADDR);
8f6066b0:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
8f6066b4:	e5843154 	str	r3, [r4, #340]	; 0x154
	ep0req->length = 0;
8f6066b8:	e3a03000 	mov	r3, #0
	ep0req->complete = ep0_setup_ack_complete;
8f6066bc:	e5812008 	str	r2, [r1, #8]
	ep0req->length = 0;
8f6066c0:	e5813004 	str	r3, [r1, #4]
	udc_request_queue(ep0in, ep0req);
8f6066c4:	e30b4db8 	movw	r4, #48568	; 0xbdb8
8f6066c8:	ebfffe86 	bl	8f6060e8 <udc_request_queue>
8f6066cc:	e3484f72 	movt	r4, #36722	; 0x8f72
}
8f6066d0:	eaffff71 	b	8f60649c <udc_interrupt+0x70>
	switch (SETUP(s.type, s.request)) {
8f6066d4:	e3080006 	movw	r0, #32774	; 0x8006
8f6066d8:	e1510000 	cmp	r1, r0
8f6066dc:	0a000043 	beq	8f6067f0 <udc_interrupt+0x3c4>
8f6066e0:	e3080008 	movw	r0, #32776	; 0x8008
8f6066e4:	e1510000 	cmp	r1, r0
8f6066e8:	1a00001f 	bne	8f60676c <udc_interrupt+0x340>
		if ((s.value == 0) && (s.index == 0) && (s.length == 1)) {
8f6066ec:	e1dde1b6 	ldrh	r14, [r13, #22]
8f6066f0:	e1dd01b8 	ldrh	r0, [r13, #24]
8f6066f4:	e19e1000 	orrs	r1, r14, r0
8f6066f8:	1a000032 	bne	8f6067c8 <udc_interrupt+0x39c>
8f6066fc:	e1ddc1ba 	ldrh	r12, [r13, #26]
8f606700:	e35c0001 	cmp	r12, #1
8f606704:	11a00001 	movne	r0, r1
8f606708:	130b4db8 	movwne	r4, #48568	; 0xbdb8
8f60670c:	11a0e000 	movne	r14, r0
8f606710:	13484f72 	movtne	r4, #36722	; 0x8f72
8f606714:	1a00001f 	bne	8f606798 <udc_interrupt+0x36c>
			setup_tx(&usb_config_value, 1);
8f606718:	e1a0100c 	mov	r1, r12
8f60671c:	e30b0e40 	movw	r0, #48704	; 0xbe40
8f606720:	e3480f72 	movt	r0, #36722	; 0x8f72
8f606724:	e30b4db8 	movw	r4, #48568	; 0xbdb8
8f606728:	ebfffef6 	bl	8f606308 <setup_tx>
			return;
8f60672c:	e3484f72 	movt	r4, #36722	; 0x8f72
8f606730:	eaffff59 	b	8f60649c <udc_interrupt+0x70>
	switch (SETUP(s.type, s.request)) {
8f606734:	e300010b 	movw	r0, #267	; 0x10b
8f606738:	e1510000 	cmp	r1, r0
8f60673c:	1a00004f 	bne	8f606880 <udc_interrupt+0x454>
8f606740:	e30b4db8 	movw	r4, #48568	; 0xbdb8
8f606744:	e3484f72 	movt	r4, #36722	; 0x8f72
	writel((1 << 16) | (1 << 0), USB_ENDPTCTRL(ept->num));
8f606748:	e5d61010 	ldrb	r1, [r6, #16]
8f60674c:	e3063c70 	movw	r3, #27760	; 0x6c70
8f606750:	e34031e3 	movt	r3, #483	; 0x1e3
8f606754:	e3a02001 	mov	r2, #1
8f606758:	e0813003 	add	r3, r1, r3
8f60675c:	e3402001 	movt	r2, #1
8f606760:	e1a03103 	lsl	r3, r3, #2
8f606764:	e5832000 	str	r2, [r3]
8f606768:	eaffff4b 	b	8f60649c <udc_interrupt+0x70>
	switch (SETUP(s.type, s.request)) {
8f60676c:	e3510902 	cmp	r1, #32768	; 0x8000
8f606770:	1a000042 	bne	8f606880 <udc_interrupt+0x454>
			if (s.length == 2) {
8f606774:	e1ddc1ba 	ldrh	r12, [r13, #26]
			unsigned zero = 0;
8f606778:	e3a01000 	mov	r1, #0
8f60677c:	e58d1010 	str	r1, [r13, #16]
			if (s.length == 2) {
8f606780:	e35c0002 	cmp	r12, #2
8f606784:	0a000013 	beq	8f6067d8 <udc_interrupt+0x3ac>
				if (desc->tag == s.value) {
8f606788:	e1dde1b6 	ldrh	r14, [r13, #22]
8f60678c:	e30b4db8 	movw	r4, #48568	; 0xbdb8
		if ((s.value == 0) && (s.index == 0) && (s.length == 1)) {
8f606790:	e1dd01b8 	ldrh	r0, [r13, #24]
8f606794:	e3484f72 	movt	r4, #36722	; 0x8f72
	switch (r) {
8f606798:	e353000b 	cmp	r3, #11
	dprintf(INFO, "STALL %s %d %d %d %d %d\n",
8f60679c:	e98d1001 	stmib	r13, {r0, r12}
8f6067a0:	e58de000 	str	r14, [r13]
8f6067a4:	e3010500 	movw	r0, #5376	; 0x1500
8f6067a8:	93011668 	movwls	r1, #5736	; 0x1668
8f6067ac:	93481f70 	movtls	r1, #36720	; 0x8f70
8f6067b0:	830114c4 	movwhi	r1, #5316	; 0x14c4
8f6067b4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6067b8:	97911103 	ldrls	r1, [r1, r3, lsl #2]
8f6067bc:	83481f70 	movthi	r1, #36720	; 0x8f70
8f6067c0:	eb00b06b 	bl	8f632974 <_dprintf>
8f6067c4:	eaffffdf 	b	8f606748 <udc_interrupt+0x31c>
8f6067c8:	e30b4db8 	movw	r4, #48568	; 0xbdb8
			if (s.length == 2) {
8f6067cc:	e1ddc1ba 	ldrh	r12, [r13, #26]
8f6067d0:	e3484f72 	movt	r4, #36722	; 0x8f72
8f6067d4:	eaffffef 	b	8f606798 <udc_interrupt+0x36c>
				setup_tx(&zero, 2);
8f6067d8:	e28d0010 	add	r0, r13, #16
8f6067dc:	e1a0100c 	mov	r1, r12
8f6067e0:	e30b4db8 	movw	r4, #48568	; 0xbdb8
8f6067e4:	ebfffec7 	bl	8f606308 <setup_tx>
				return;
8f6067e8:	e3484f72 	movt	r4, #36722	; 0x8f72
8f6067ec:	eaffff2a 	b	8f60649c <udc_interrupt+0x70>
			for (desc = desc_list; desc; desc = desc->next) {
8f6067f0:	e30b1da8 	movw	r1, #48552	; 0xbda8
8f6067f4:	e3481f72 	movt	r1, #36722	; 0x8f72
				if (desc->tag == s.value) {
8f6067f8:	e1dde1b6 	ldrh	r14, [r13, #22]
			for (desc = desc_list; desc; desc = desc->next) {
8f6067fc:	e5910000 	ldr	r0, [r1]
8f606800:	e3500000 	cmp	r0, #0
8f606804:	1a000003 	bne	8f606818 <udc_interrupt+0x3ec>
8f606808:	ea00001d 	b	8f606884 <udc_interrupt+0x458>
8f60680c:	e5900000 	ldr	r0, [r0]
8f606810:	e3500000 	cmp	r0, #0
8f606814:	0a00001a 	beq	8f606884 <udc_interrupt+0x458>
				if (desc->tag == s.value) {
8f606818:	e1d010b4 	ldrh	r1, [r0, #4]
8f60681c:	e151000e 	cmp	r1, r14
8f606820:	1afffff9 	bne	8f60680c <udc_interrupt+0x3e0>
					if (desc->tag == (TYPE_CONFIGURATION << 8)) {
8f606824:	e35e0c02 	cmp	r14, #512	; 0x200
8f606828:	1a00000b 	bne	8f60685c <udc_interrupt+0x430>
							data[4] = usb_highspeed ? 512:64;
8f60682c:	e30b3e44 	movw	r3, #48708	; 0xbe44
8f606830:	e3483f72 	movt	r3, #36722	; 0x8f72
8f606834:	e5933000 	ldr	r3, [r3]
8f606838:	e3530000 	cmp	r3, #0
8f60683c:	03a02040 	moveq	r2, #64	; 0x40
8f606840:	13a02000 	movne	r2, #0
8f606844:	03a03000 	moveq	r3, #0
8f606848:	13a03002 	movne	r3, #2
8f60684c:	e5c0201e 	strb	r2, [r0, #30]
							data[5] = (usb_highspeed ? 512:64)>>8;
8f606850:	e5c0301f 	strb	r3, [r0, #31]
							data[4] = usb_highspeed ? 512:64;
8f606854:	e5c02025 	strb	r2, [r0, #37]	; 0x25
							data[5] = (usb_highspeed ? 512:64)>>8;
8f606858:	e5c03026 	strb	r3, [r0, #38]	; 0x26
					setup_tx(desc->data, len);
8f60685c:	e1d010b6 	ldrh	r1, [r0, #6]
8f606860:	e2800008 	add	r0, r0, #8
8f606864:	e1dd31ba 	ldrh	r3, [r13, #26]
8f606868:	e30b4db8 	movw	r4, #48568	; 0xbdb8
8f60686c:	e3484f72 	movt	r4, #36722	; 0x8f72
8f606870:	e1510003 	cmp	r1, r3
8f606874:	21a01003 	movcs	r1, r3
8f606878:	ebfffea2 	bl	8f606308 <setup_tx>
					return;
8f60687c:	eaffff06 	b	8f60649c <udc_interrupt+0x70>
				if (desc->tag == s.value) {
8f606880:	e1dde1b6 	ldrh	r14, [r13, #22]
8f606884:	e30b4db8 	movw	r4, #48568	; 0xbdb8
		if ((s.value == 0) && (s.index == 0) && (s.length == 1)) {
8f606888:	e1dd01b8 	ldrh	r0, [r13, #24]
			if (s.length == 2) {
8f60688c:	e1ddc1ba 	ldrh	r12, [r13, #26]
8f606890:	e3484f72 	movt	r4, #36722	; 0x8f72
8f606894:	eaffffbf 	b	8f606798 <udc_interrupt+0x36c>
	ep0req->complete = ep0_setup_ack_complete;
8f606898:	e30b3db4 	movw	r3, #48564	; 0xbdb4
8f60689c:	e3483f72 	movt	r3, #36722	; 0x8f72
		test_mode = s.index;
8f6068a0:	e1ddc1b8 	ldrh	r12, [r13, #24]
	udc_request_queue(ep0in, ep0req);
8f6068a4:	e30b2dac 	movw	r2, #48556	; 0xbdac
	ep0req->complete = ep0_setup_ack_complete;
8f6068a8:	e5931000 	ldr	r1, [r3]
	udc_request_queue(ep0in, ep0req);
8f6068ac:	e3482f72 	movt	r2, #36722	; 0x8f72
		test_mode = s.index;
8f6068b0:	e30b3dc0 	movw	r3, #48576	; 0xbdc0
8f6068b4:	e3483f72 	movt	r3, #36722	; 0x8f72
	udc_request_queue(ep0in, ep0req);
8f6068b8:	e5920000 	ldr	r0, [r2]
	ep0req->length = 0;
8f6068bc:	e3a02000 	mov	r2, #0
		test_mode = s.index;
8f6068c0:	e583c000 	str	r12, [r3]
	ep0req->complete = ep0_setup_ack_complete;
8f6068c4:	e3053b30 	movw	r3, #23344	; 0x5b30
8f6068c8:	e3483f60 	movt	r3, #36704	; 0x8f60
8f6068cc:	e1c120f4 	strd	r2, [r1, #4]
	udc_request_queue(ep0in, ep0req);
8f6068d0:	ebfffe04 	bl	8f6060e8 <udc_request_queue>
8f6068d4:	eafffeee 	b	8f606494 <udc_interrupt+0x68>
		if (s.value == 1) {
8f6068d8:	e1dd31b6 	ldrh	r3, [r13, #22]
8f6068dc:	e3530001 	cmp	r3, #1
8f6068e0:	0a00004f 	beq	8f606a24 <udc_interrupt+0x5f8>
			the_gadget->notify(the_gadget, UDC_EVENT_OFFLINE);
8f6068e4:	e30b2dc8 	movw	r2, #48584	; 0xbdc8
8f6068e8:	e3482f72 	movt	r2, #36722	; 0x8f72
			usb_config_value = 0;
8f6068ec:	e30b3e40 	movw	r3, #48704	; 0xbe40
8f6068f0:	e3483f72 	movt	r3, #36722	; 0x8f72
			the_gadget->notify(the_gadget, UDC_EVENT_OFFLINE);
8f6068f4:	e5920000 	ldr	r0, [r2]
8f6068f8:	e3a01002 	mov	r1, #2
			writel(0, USB_ENDPTCTRL(1));
8f6068fc:	e3a02000 	mov	r2, #0
8f606900:	e58421c4 	str	r2, [r4, #452]	; 0x1c4
			usb_config_value = 0;
8f606904:	e5c32000 	strb	r2, [r3]
			the_gadget->notify(the_gadget, UDC_EVENT_OFFLINE);
8f606908:	e30b4db8 	movw	r4, #48568	; 0xbdb8
8f60690c:	e5903000 	ldr	r3, [r0]
8f606910:	e3484f72 	movt	r4, #36722	; 0x8f72
8f606914:	e12fff33 	blx	r3
	ep0req->complete = ep0_setup_ack_complete;
8f606918:	e30b2db4 	movw	r2, #48564	; 0xbdb4
8f60691c:	e3482f72 	movt	r2, #36722	; 0x8f72
	udc_request_queue(ep0in, ep0req);
8f606920:	e30b3dac 	movw	r3, #48556	; 0xbdac
8f606924:	e3483f72 	movt	r3, #36722	; 0x8f72
	ep0req->complete = ep0_setup_ack_complete;
8f606928:	e5921000 	ldr	r1, [r2]
	ep0req->length = 0;
8f60692c:	e3a02000 	mov	r2, #0
	udc_request_queue(ep0in, ep0req);
8f606930:	e5930000 	ldr	r0, [r3]
	ep0req->complete = ep0_setup_ack_complete;
8f606934:	e3053b30 	movw	r3, #23344	; 0x5b30
8f606938:	e3483f60 	movt	r3, #36704	; 0x8f60
	ep0req->length = 0;
8f60693c:	e5812004 	str	r2, [r1, #4]
	ep0req->complete = ep0_setup_ack_complete;
8f606940:	e5813008 	str	r3, [r1, #8]
	udc_request_queue(ep0in, ep0req);
8f606944:	ebfffde7 	bl	8f6060e8 <udc_request_queue>
		return;
8f606948:	eafffed3 	b	8f60649c <udc_interrupt+0x70>
			if ((s.value == 0) && (s.length == 0)) {
8f60694c:	e1dde1b6 	ldrh	r14, [r13, #22]
				for (ept = ept_list; ept; ept = ept->next) {
8f606950:	e30b4db8 	movw	r4, #48568	; 0xbdb8
			if ((s.value == 0) && (s.length == 0)) {
8f606954:	e1ddc1ba 	ldrh	r12, [r13, #26]
				for (ept = ept_list; ept; ept = ept->next) {
8f606958:	e3484f72 	movt	r4, #36722	; 0x8f72
			unsigned num = s.index & 15;
8f60695c:	e1dd01b8 	ldrh	r0, [r13, #24]
			if ((s.value == 0) && (s.length == 0)) {
8f606960:	e19e100c 	orrs	r1, r14, r12
8f606964:	1affff8b 	bne	8f606798 <udc_interrupt+0x36c>
				for (ept = ept_list; ept; ept = ept->next) {
8f606968:	e5941000 	ldr	r1, [r4]
8f60696c:	e3510000 	cmp	r1, #0
8f606970:	0a000053 	beq	8f606ac4 <udc_interrupt+0x698>
8f606974:	e200e00f 	and	r14, r0, #15
			unsigned in = !!(s.index & 0x80);
8f606978:	e7e083d0 	ubfx	r8, r0, #7, #1
8f60697c:	ea000002 	b	8f60698c <udc_interrupt+0x560>
				for (ept = ept_list; ept; ept = ept->next) {
8f606980:	e5911000 	ldr	r1, [r1]
8f606984:	e3510000 	cmp	r1, #0
8f606988:	0a00004d 	beq	8f606ac4 <udc_interrupt+0x698>
					if ((ept->num == num)
8f60698c:	e5d1c010 	ldrb	r12, [r1, #16]
8f606990:	e15e000c 	cmp	r14, r12
8f606994:	1afffff9 	bne	8f606980 <udc_interrupt+0x554>
					    && (ept->in == in)) {
8f606998:	e5d17011 	ldrb	r7, [r1, #17]
8f60699c:	e1570008 	cmp	r7, r8
8f6069a0:	1afffff6 	bne	8f606980 <udc_interrupt+0x554>
	unsigned n = readl(USB_ENDPTCTRL(ept->num));
8f6069a4:	e3063c70 	movw	r3, #27760	; 0x6c70
8f6069a8:	e34031e3 	movt	r3, #483	; 0x1e3
8f6069ac:	e08c3003 	add	r3, r12, r3
		if (ept->in) {
8f6069b0:	e3580000 	cmp	r8, #0
	unsigned n = readl(USB_ENDPTCTRL(ept->num));
8f6069b4:	e1a03103 	lsl	r3, r3, #2
8f6069b8:	e5932000 	ldr	r2, [r3]
			n |= (CTRL_TXE | CTRL_TXR | CTRL_TXT_BULK);
8f6069bc:	13822732 	orrne	r2, r2, #13107200	; 0xc80000
			n |= (CTRL_RXE | CTRL_RXR | CTRL_RXT_BULK);
8f6069c0:	038220c8 	orreq	r2, r2, #200	; 0xc8
		if (ept->num != 0) {
8f6069c4:	e35c0000 	cmp	r12, #0
8f6069c8:	0a000007 	beq	8f6069ec <udc_interrupt+0x5c0>
			if (usb_highspeed) {
8f6069cc:	e30b0e44 	movw	r0, #48708	; 0xbe44
8f6069d0:	e3480f72 	movt	r0, #36722	; 0x8f72
				ept->head->config =
8f6069d4:	e5911008 	ldr	r1, [r1, #8]
			if (usb_highspeed) {
8f6069d8:	e5900000 	ldr	r0, [r0]
8f6069dc:	e3500000 	cmp	r0, #0
				ept->head->config =
8f6069e0:	13a00422 	movne	r0, #570425344	; 0x22000000
				ept->head->config =
8f6069e4:	03a00581 	moveq	r0, #541065216	; 0x20400000
8f6069e8:	e5810000 	str	r0, [r1]
	ep0req->complete = ep0_setup_ack_complete;
8f6069ec:	e30b1db4 	movw	r1, #48564	; 0xbdb4
8f6069f0:	e3481f72 	movt	r1, #36722	; 0x8f72
	writel(n, USB_ENDPTCTRL(ept->num));
8f6069f4:	e5832000 	str	r2, [r3]
	udc_request_queue(ep0in, ep0req);
8f6069f8:	e30b3dac 	movw	r3, #48556	; 0xbdac
	ep0req->complete = ep0_setup_ack_complete;
8f6069fc:	e5911000 	ldr	r1, [r1]
	udc_request_queue(ep0in, ep0req);
8f606a00:	e3483f72 	movt	r3, #36722	; 0x8f72
	ep0req->length = 0;
8f606a04:	e3a00000 	mov	r0, #0
	ep0req->complete = ep0_setup_ack_complete;
8f606a08:	e3052b30 	movw	r2, #23344	; 0x5b30
8f606a0c:	e3482f60 	movt	r2, #36704	; 0x8f60
	ep0req->length = 0;
8f606a10:	e5810004 	str	r0, [r1, #4]
	ep0req->complete = ep0_setup_ack_complete;
8f606a14:	e5812008 	str	r2, [r1, #8]
	udc_request_queue(ep0in, ep0req);
8f606a18:	e5930000 	ldr	r0, [r3]
8f606a1c:	ebfffdb1 	bl	8f6060e8 <udc_request_queue>
}
8f606a20:	eafffe9d 	b	8f60649c <udc_interrupt+0x70>
			for (ept = ept_list; ept; ept = ept->next) {
8f606a24:	e30b4db8 	movw	r4, #48568	; 0xbdb8
8f606a28:	e3484f72 	movt	r4, #36722	; 0x8f72
8f606a2c:	e5943000 	ldr	r3, [r4]
8f606a30:	e3530000 	cmp	r3, #0
8f606a34:	0a000018 	beq	8f606a9c <udc_interrupt+0x670>
			if (usb_highspeed) {
8f606a38:	e30b2e44 	movw	r2, #48708	; 0xbe44
8f606a3c:	e3482f72 	movt	r2, #36722	; 0x8f72
	unsigned n = readl(USB_ENDPTCTRL(ept->num));
8f606a40:	e3060c70 	movw	r0, #27760	; 0x6c70
8f606a44:	e34001e3 	movt	r0, #483	; 0x1e3
			if (usb_highspeed) {
8f606a48:	e592c000 	ldr	r12, [r2]
				ept->head->config =
8f606a4c:	e3a06581 	mov	r6, #541065216	; 0x20400000
				ept->head->config =
8f606a50:	e3a0e422 	mov	r14, #570425344	; 0x22000000
				if (ept->num == 0)
8f606a54:	e5d32010 	ldrb	r2, [r3, #16]
8f606a58:	e3520000 	cmp	r2, #0
8f606a5c:	0a00000b 	beq	8f606a90 <udc_interrupt+0x664>
	unsigned n = readl(USB_ENDPTCTRL(ept->num));
8f606a60:	e0822000 	add	r2, r2, r0
		if (ept->in) {
8f606a64:	e5d31011 	ldrb	r1, [r3, #17]
				ept->head->config =
8f606a68:	e5937008 	ldr	r7, [r3, #8]
	unsigned n = readl(USB_ENDPTCTRL(ept->num));
8f606a6c:	e1a02102 	lsl	r2, r2, #2
		if (ept->in) {
8f606a70:	e3510000 	cmp	r1, #0
	unsigned n = readl(USB_ENDPTCTRL(ept->num));
8f606a74:	e5921000 	ldr	r1, [r2]
			n |= (CTRL_TXE | CTRL_TXR | CTRL_TXT_BULK);
8f606a78:	13811732 	orrne	r1, r1, #13107200	; 0xc80000
			n |= (CTRL_RXE | CTRL_RXR | CTRL_RXT_BULK);
8f606a7c:	038110c8 	orreq	r1, r1, #200	; 0xc8
			if (usb_highspeed) {
8f606a80:	e35c0000 	cmp	r12, #0
				ept->head->config =
8f606a84:	1587e000 	strne	r14, [r7]
				ept->head->config =
8f606a88:	05876000 	streq	r6, [r7]
	writel(n, USB_ENDPTCTRL(ept->num));
8f606a8c:	e5821000 	str	r1, [r2]
			for (ept = ept_list; ept; ept = ept->next) {
8f606a90:	e5933000 	ldr	r3, [r3]
8f606a94:	e3530000 	cmp	r3, #0
8f606a98:	1affffed 	bne	8f606a54 <udc_interrupt+0x628>
			the_gadget->notify(the_gadget, UDC_EVENT_ONLINE);
8f606a9c:	e30b2dc8 	movw	r2, #48584	; 0xbdc8
8f606aa0:	e3482f72 	movt	r2, #36722	; 0x8f72
			usb_config_value = 1;
8f606aa4:	e30b3e40 	movw	r3, #48704	; 0xbe40
8f606aa8:	e3483f72 	movt	r3, #36722	; 0x8f72
			the_gadget->notify(the_gadget, UDC_EVENT_ONLINE);
8f606aac:	e5920000 	ldr	r0, [r2]
			usb_config_value = 1;
8f606ab0:	e3a01001 	mov	r1, #1
8f606ab4:	e5c31000 	strb	r1, [r3]
			the_gadget->notify(the_gadget, UDC_EVENT_ONLINE);
8f606ab8:	e5903000 	ldr	r3, [r0]
8f606abc:	e12fff33 	blx	r3
8f606ac0:	eaffff94 	b	8f606918 <udc_interrupt+0x4ec>
				for (ept = ept_list; ept; ept = ept->next) {
8f606ac4:	e1a0c001 	mov	r12, r1
8f606ac8:	e1a0e001 	mov	r14, r1
8f606acc:	eaffff31 	b	8f606798 <udc_interrupt+0x36c>
}
8f606ad0:	eb00b03a 	bl	8f632bc0 <__stack_chk_fail>
8f606ad4:	8f74221c 	.word	0x8f74221c

8f606ad8 <udc_init>:
{
8f606ad8:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	writel(0x00080002, USB_USBCMD);
8f606adc:	e3a05a0b 	mov	r5, #45056	; 0xb000
{
8f606ae0:	e59f31c4 	ldr	r3, [pc, #452]	; 8f606cac <udc_init+0x1d4>
	writel(0x00080002, USB_USBCMD);
8f606ae4:	e340578d 	movt	r5, #1933	; 0x78d
{
8f606ae8:	e24dd014 	sub	r13, r13, #20
8f606aec:	e1a06000 	mov	r6, r0
8f606af0:	e5933000 	ldr	r3, [r3]
8f606af4:	e58d300c 	str	r3, [r13, #12]
8f606af8:	e3a03000 	mov	r3, #0
	hsusb_clock_init();
8f606afc:	e1a0700e 	mov	r7, r14
8f606b00:	ebfffcb2 	bl	8f605dd0 <hsusb_clock_init>
	writel(0x00080002, USB_USBCMD);
8f606b04:	e3a03002 	mov	r3, #2
	thread_sleep(20);
8f606b08:	e3a00014 	mov	r0, #20
	writel(0x00080002, USB_USBCMD);
8f606b0c:	e3403008 	movt	r3, #8
8f606b10:	e5853140 	str	r3, [r5, #320]	; 0x140
	thread_sleep(20);
8f606b14:	eb0075db 	bl	8f624288 <thread_sleep>
	while((readl(USB_USBCMD)&2));
8f606b18:	e5953140 	ldr	r3, [r5, #320]	; 0x140
8f606b1c:	e2134002 	ands	r4, r3, #2
8f606b20:	1afffffc 	bne	8f606b18 <udc_init+0x40>
	writel(0x80000000, USB_PORTSC);
8f606b24:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
8f606b28:	e5853184 	str	r3, [r5, #388]	; 0x184
	target_usb_init();
8f606b2c:	eb006c06 	bl	8f621b4c <target_usb_init>
	writel(0x08, USB_AHB_MODE);
8f606b30:	e3a03008 	mov	r3, #8
	writel(0x0, USB_SBUSCFG);
8f606b34:	e5854090 	str	r4, [r5, #144]	; 0x90
	epts = memalign(lcm(4096, CACHE_LINE), ROUNDUP(4096, CACHE_LINE));
8f606b38:	e3a01040 	mov	r1, #64	; 0x40
	writel(0x08, USB_AHB_MODE);
8f606b3c:	e5853098 	str	r3, [r5, #152]	; 0x98
	epts = memalign(lcm(4096, CACHE_LINE), ROUNDUP(4096, CACHE_LINE));
8f606b40:	e3a00a01 	mov	r0, #4096	; 0x1000
8f606b44:	eb00b288 	bl	8f63356c <lcm>
8f606b48:	e3a01a01 	mov	r1, #4096	; 0x1000
8f606b4c:	eb00b53c 	bl	8f634044 <memalign>
8f606b50:	e30b4dbc 	movw	r4, #48572	; 0xbdbc
8f606b54:	e3484f72 	movt	r4, #36722	; 0x8f72
	ASSERT(epts);
8f606b58:	e3500000 	cmp	r0, #0
	epts = memalign(lcm(4096, CACHE_LINE), ROUNDUP(4096, CACHE_LINE));
8f606b5c:	e1a01000 	mov	r1, r0
8f606b60:	e5840000 	str	r0, [r4]
	ASSERT(epts);
8f606b64:	0a000043 	beq	8f606c78 <udc_init+0x1a0>
	dprintf(INFO, "USB init ept @ %p\n", epts);
8f606b68:	e3010524 	movw	r0, #5412	; 0x1524
8f606b6c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f606b70:	eb00af7f 	bl	8f632974 <_dprintf>
	memset(epts, 0, 32 * sizeof(struct ept_queue_head));
8f606b74:	e3a02b02 	mov	r2, #2048	; 0x800
8f606b78:	e5940000 	ldr	r0, [r4]
8f606b7c:	e3a01000 	mov	r1, #0
8f606b80:	eb00b5cf 	bl	8f6342c4 <memset>
	arch_clean_invalidate_cache_range((addr_t) epts,
8f606b84:	e5940000 	ldr	r0, [r4]
8f606b88:	e3a01b02 	mov	r1, #2048	; 0x800
8f606b8c:	eb006903 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	writel((unsigned)PA((addr_t)epts), USB_ENDPOINTLISTADDR);
8f606b90:	e5940000 	ldr	r0, [r4]
8f606b94:	ebffeaee 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f606b98:	e3a03a0b 	mov	r3, #45056	; 0xb000
8f606b9c:	e340378d 	movt	r3, #1933	; 0x78d
	writel(0x02, USB_USBMODE);
8f606ba0:	e3a01002 	mov	r1, #2
	writel((unsigned)PA((addr_t)epts), USB_ENDPOINTLISTADDR);
8f606ba4:	e1a02000 	mov	r2, r0
	thread_sleep(20);
8f606ba8:	e3a00014 	mov	r0, #20
	writel((unsigned)PA((addr_t)epts), USB_ENDPOINTLISTADDR);
8f606bac:	e5832158 	str	r2, [r3, #344]	; 0x158
	writel(0xffffffff, USB_ENDPTFLUSH);
8f606bb0:	e3e02000 	mvn	r2, #0
	writel(0x02, USB_USBMODE);
8f606bb4:	e58311a8 	str	r1, [r3, #424]	; 0x1a8
	writel(0xffffffff, USB_ENDPTFLUSH);
8f606bb8:	e58321b4 	str	r2, [r3, #436]	; 0x1b4
	thread_sleep(20);
8f606bbc:	eb0075b1 	bl	8f624288 <thread_sleep>
	ep0out = _udc_endpoint_alloc(0, 0, 64);
8f606bc0:	e3a01000 	mov	r1, #0
8f606bc4:	e3a02040 	mov	r2, #64	; 0x40
8f606bc8:	e1a00001 	mov	r0, r1
8f606bcc:	ebfffc8f 	bl	8f605e10 <_udc_endpoint_alloc>
8f606bd0:	e30b3db0 	movw	r3, #48560	; 0xbdb0
8f606bd4:	e3483f72 	movt	r3, #36722	; 0x8f72
	ep0in = _udc_endpoint_alloc(0, 1, 64);
8f606bd8:	e3a02040 	mov	r2, #64	; 0x40
8f606bdc:	e3a01001 	mov	r1, #1
	ep0out = _udc_endpoint_alloc(0, 0, 64);
8f606be0:	e5830000 	str	r0, [r3]
	ep0in = _udc_endpoint_alloc(0, 1, 64);
8f606be4:	e3a00000 	mov	r0, #0
8f606be8:	ebfffc88 	bl	8f605e10 <_udc_endpoint_alloc>
8f606bec:	e30b3dac 	movw	r3, #48556	; 0xbdac
8f606bf0:	e3483f72 	movt	r3, #36722	; 0x8f72
8f606bf4:	e5830000 	str	r0, [r3]
	ep0req = udc_request_alloc();
8f606bf8:	ebfffd00 	bl	8f606000 <udc_request_alloc>
8f606bfc:	e30b3db4 	movw	r3, #48564	; 0xbdb4
8f606c00:	e3483f72 	movt	r3, #36722	; 0x8f72
	ep0req->buf = memalign(CACHE_LINE, ROUNDUP(4096, CACHE_LINE));
8f606c04:	e3a01a01 	mov	r1, #4096	; 0x1000
	ep0req = udc_request_alloc();
8f606c08:	e1a04000 	mov	r4, r0
	ep0req->buf = memalign(CACHE_LINE, ROUNDUP(4096, CACHE_LINE));
8f606c0c:	e3a00040 	mov	r0, #64	; 0x40
	ep0req = udc_request_alloc();
8f606c10:	e5834000 	str	r4, [r3]
	ep0req->buf = memalign(CACHE_LINE, ROUNDUP(4096, CACHE_LINE));
8f606c14:	eb00b50a 	bl	8f634044 <memalign>
		    udc_descriptor_alloc(TYPE_STRING, 0, 4);
8f606c18:	e3a02004 	mov	r2, #4
8f606c1c:	e3a01000 	mov	r1, #0
	ep0req->buf = memalign(CACHE_LINE, ROUNDUP(4096, CACHE_LINE));
8f606c20:	e5840000 	str	r0, [r4]
		    udc_descriptor_alloc(TYPE_STRING, 0, 4);
8f606c24:	e3a00003 	mov	r0, #3
8f606c28:	ebfffbed 	bl	8f605be4 <udc_descriptor_alloc>
	desc->next = desc_list;
8f606c2c:	e30b3da8 	movw	r3, #48552	; 0xbda8
8f606c30:	e3483f72 	movt	r3, #36722	; 0x8f72
	the_device = dev;
8f606c34:	e30b2dc4 	movw	r2, #48580	; 0xbdc4
8f606c38:	e3482f72 	movt	r2, #36722	; 0x8f72
		desc->data[2] = 0x09;
8f606c3c:	e300c409 	movw	r12, #1033	; 0x409
	desc->next = desc_list;
8f606c40:	e5931000 	ldr	r1, [r3]
	the_device = dev;
8f606c44:	e5826000 	str	r6, [r2]
	desc_list = desc;
8f606c48:	e5830000 	str	r0, [r3]
}
8f606c4c:	e59f3058 	ldr	r3, [pc, #88]	; 8f606cac <udc_init+0x1d4>
		desc->data[2] = 0x09;
8f606c50:	e1c0c0ba 	strh	r12, [r0, #10]
	desc->next = desc_list;
8f606c54:	e5801000 	str	r1, [r0]
}
8f606c58:	e5932000 	ldr	r2, [r3]
8f606c5c:	e59d300c 	ldr	r3, [r13, #12]
8f606c60:	e0332002 	eors	r2, r3, r2
8f606c64:	e3a03000 	mov	r3, #0
8f606c68:	1a00000e 	bne	8f606ca8 <udc_init+0x1d0>
8f606c6c:	e3a00000 	mov	r0, #0
8f606c70:	e28dd014 	add	r13, r13, #20
8f606c74:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
	ASSERT(epts);
8f606c78:	e301251c 	movw	r2, #5404	; 0x151c
8f606c7c:	e3a03d0b 	mov	r3, #704	; 0x2c0
8f606c80:	e3482f70 	movt	r2, #36720	; 0x8f70
8f606c84:	e1a00007 	mov	r0, r7
8f606c88:	e58d2000 	str	r2, [r13]
8f606c8c:	e3001130 	movw	r1, #304	; 0x130
8f606c90:	e3012498 	movw	r2, #5272	; 0x1498
8f606c94:	e3481f70 	movt	r1, #36720	; 0x8f70
8f606c98:	e3482f70 	movt	r2, #36720	; 0x8f70
8f606c9c:	eb00af86 	bl	8f632abc <_panic>
	dprintf(INFO, "USB init ept @ %p\n", epts);
8f606ca0:	e5941000 	ldr	r1, [r4]
8f606ca4:	eaffffaf 	b	8f606b68 <udc_init+0x90>
}
8f606ca8:	eb00afc4 	bl	8f632bc0 <__stack_chk_fail>
8f606cac:	8f74221c 	.word	0x8f74221c

8f606cb0 <udc_register_gadget>:

int udc_register_gadget(struct udc_gadget *gadget)
{
8f606cb0:	e59f2068 	ldr	r2, [pc, #104]	; 8f606d20 <udc_register_gadget+0x70>
	if (the_gadget) {
8f606cb4:	e30b3dc8 	movw	r3, #48584	; 0xbdc8
8f606cb8:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f606cbc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f606cc0:	e24dd00c 	sub	r13, r13, #12
8f606cc4:	e5922000 	ldr	r2, [r2]
8f606cc8:	e58d2004 	str	r2, [r13, #4]
8f606ccc:	e3a02000 	mov	r2, #0
	if (the_gadget) {
8f606cd0:	e5932000 	ldr	r2, [r3]
8f606cd4:	e3520000 	cmp	r2, #0
8f606cd8:	01a01000 	moveq	r1, r0
		dprintf(CRITICAL, "only one gadget supported\n");
		return -1;
	}
	the_gadget = gadget;
	return 0;
8f606cdc:	01a00002 	moveq	r0, r2
	the_gadget = gadget;
8f606ce0:	05831000 	streq	r1, [r3]
	if (the_gadget) {
8f606ce4:	1a000007 	bne	8f606d08 <udc_register_gadget+0x58>
}
8f606ce8:	e59f3030 	ldr	r3, [pc, #48]	; 8f606d20 <udc_register_gadget+0x70>
8f606cec:	e5932000 	ldr	r2, [r3]
8f606cf0:	e59d3004 	ldr	r3, [r13, #4]
8f606cf4:	e0332002 	eors	r2, r3, r2
8f606cf8:	e3a03000 	mov	r3, #0
8f606cfc:	1a000006 	bne	8f606d1c <udc_register_gadget+0x6c>
8f606d00:	e28dd00c 	add	r13, r13, #12
8f606d04:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		dprintf(CRITICAL, "only one gadget supported\n");
8f606d08:	e3010538 	movw	r0, #5432	; 0x1538
8f606d0c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f606d10:	eb00af17 	bl	8f632974 <_dprintf>
		return -1;
8f606d14:	e3e00000 	mvn	r0, #0
8f606d18:	eafffff2 	b	8f606ce8 <udc_register_gadget+0x38>
}
8f606d1c:	eb00afa7 	bl	8f632bc0 <__stack_chk_fail>
8f606d20:	8f74221c 	.word	0x8f74221c

8f606d24 <udc_start>:
		data += 7;
	}
}

int udc_start(void)
{
8f606d24:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
	unsigned size;
	uint32_t val;

	dprintf(ALWAYS, "udc_start()\n");

	if (!the_device) {
8f606d28:	e30b5dc4 	movw	r5, #48580	; 0xbdc4
{
8f606d2c:	e59f332c 	ldr	r3, [pc, #812]	; 8f607060 <udc_start+0x33c>
	if (!the_device) {
8f606d30:	e3485f72 	movt	r5, #36722	; 0x8f72
{
8f606d34:	e24dd014 	sub	r13, r13, #20
	dprintf(ALWAYS, "udc_start()\n");
8f606d38:	e3010554 	movw	r0, #5460	; 0x1554
8f606d3c:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f606d40:	e5933000 	ldr	r3, [r3]
8f606d44:	e58d300c 	str	r3, [r13, #12]
8f606d48:	e3a03000 	mov	r3, #0
	dprintf(ALWAYS, "udc_start()\n");
8f606d4c:	e1a0800e 	mov	r8, r14
8f606d50:	eb00af07 	bl	8f632974 <_dprintf>
	if (!the_device) {
8f606d54:	e5953000 	ldr	r3, [r5]
8f606d58:	e3530000 	cmp	r3, #0
8f606d5c:	0a0000b9 	beq	8f607048 <udc_start+0x324>
		dprintf(CRITICAL, "udc cannot start before init\n");
		return -1;
	}
	if (!the_gadget) {
8f606d60:	e30b6dc8 	movw	r6, #48584	; 0xbdc8
8f606d64:	e3486f72 	movt	r6, #36722	; 0x8f72
8f606d68:	e5963000 	ldr	r3, [r6]
8f606d6c:	e3530000 	cmp	r3, #0
8f606d70:	0a0000af 	beq	8f607034 <udc_start+0x310>
		dprintf(CRITICAL, "udc has no gadget registered\n");
		return -1;
	}

	/* create our device descriptor */
	if(!(desc = udc_descriptor_alloc(TYPE_DEVICE, 0, 18)))
8f606d74:	e3a02012 	mov	r2, #18
8f606d78:	e3a01000 	mov	r1, #0
8f606d7c:	e3a00001 	mov	r0, #1
8f606d80:	ebfffb97 	bl	8f605be4 <udc_descriptor_alloc>
8f606d84:	e2504000 	subs	r4, r0, #0
8f606d88:	0a00008d 	beq	8f606fc4 <udc_start+0x2a0>
		dprintf(CRITICAL, "Failed to allocate device descriptor\n");
		ASSERT(0);
	}
	data = desc->data;
	data[2] = 0x00;		/* usb spec minor rev */
	data[3] = 0x02;		/* usb spec major rev */
8f606d8c:	e3a07002 	mov	r7, #2
	data[2] = 0x00;		/* usb spec minor rev */
8f606d90:	e3a09000 	mov	r9, #0
	data[4] = 0x00;		/* class */
	data[5] = 0x00;		/* subclass */
	data[6] = 0x00;		/* protocol */
	data[7] = 0x40;		/* max packet size on ept 0 */
8f606d94:	e3a03040 	mov	r3, #64	; 0x40
	memcpy(data + 8, &the_device->vendor_id, sizeof(short));
8f606d98:	e5951000 	ldr	r1, [r5]
	data[7] = 0x40;		/* max packet size on ept 0 */
8f606d9c:	e5c4300f 	strb	r3, [r4, #15]
	memcpy(data + 8, &the_device->vendor_id, sizeof(short));
8f606da0:	e1a02007 	mov	r2, r7
	data[3] = 0x02;		/* usb spec major rev */
8f606da4:	e5c4700b 	strb	r7, [r4, #11]
	memcpy(data + 8, &the_device->vendor_id, sizeof(short));
8f606da8:	e2840010 	add	r0, r4, #16
	data[2] = 0x00;		/* usb spec minor rev */
8f606dac:	e5c4900a 	strb	r9, [r4, #10]
	data[4] = 0x00;		/* class */
8f606db0:	e5c4900c 	strb	r9, [r4, #12]
	data[5] = 0x00;		/* subclass */
8f606db4:	e5c4900d 	strb	r9, [r4, #13]
	data[6] = 0x00;		/* protocol */
8f606db8:	e5c4900e 	strb	r9, [r4, #14]
	memcpy(data + 8, &the_device->vendor_id, sizeof(short));
8f606dbc:	eb00b4fd 	bl	8f6341b8 <memcpy>
	memcpy(data + 10, &the_device->product_id, sizeof(short));
8f606dc0:	e5951000 	ldr	r1, [r5]
8f606dc4:	e1a02007 	mov	r2, r7
8f606dc8:	e2840012 	add	r0, r4, #18
8f606dcc:	e0811007 	add	r1, r1, r7
8f606dd0:	eb00b4f8 	bl	8f6341b8 <memcpy>
	memcpy(data + 12, &the_device->version_id, sizeof(short));
8f606dd4:	e5951000 	ldr	r1, [r5]
8f606dd8:	e1a02007 	mov	r2, r7
8f606ddc:	e2840014 	add	r0, r4, #20
8f606de0:	e2811004 	add	r1, r1, #4
8f606de4:	eb00b4f3 	bl	8f6341b8 <memcpy>
	data[14] = udc_string_desc_alloc(the_device->manufacturer);
8f606de8:	e5953000 	ldr	r3, [r5]
8f606dec:	e5930008 	ldr	r0, [r3, #8]
8f606df0:	ebfffbbd 	bl	8f605cec <udc_string_desc_alloc>
	data[15] = udc_string_desc_alloc(the_device->product);
8f606df4:	e5953000 	ldr	r3, [r5]
	data[14] = udc_string_desc_alloc(the_device->manufacturer);
8f606df8:	e5c40016 	strb	r0, [r4, #22]
	data[15] = udc_string_desc_alloc(the_device->product);
8f606dfc:	e593000c 	ldr	r0, [r3, #12]
8f606e00:	ebfffbb9 	bl	8f605cec <udc_string_desc_alloc>
	data[16] = udc_string_desc_alloc(the_device->serialno);
8f606e04:	e5953000 	ldr	r3, [r5]
	desc->next = desc_list;
8f606e08:	e30b5da8 	movw	r5, #48552	; 0xbda8
8f606e0c:	e3485f72 	movt	r5, #36722	; 0x8f72
	data[15] = udc_string_desc_alloc(the_device->product);
8f606e10:	e5c40017 	strb	r0, [r4, #23]
	data[16] = udc_string_desc_alloc(the_device->serialno);
8f606e14:	e5930010 	ldr	r0, [r3, #16]
8f606e18:	ebfffbb3 	bl	8f605cec <udc_string_desc_alloc>
	return 9 + g->ifc_endpoints * 7;
8f606e1c:	e5963000 	ldr	r3, [r6]
	data[17] = 1;		/* number of configurations */
8f606e20:	e3a02001 	mov	r2, #1
8f606e24:	e5c42019 	strb	r2, [r4, #25]
	desc->next = desc_list;
8f606e28:	e5952000 	ldr	r2, [r5]
	udc_descriptor_register(desc);

	/* create our configuration descriptor */
	size = 9 + udc_ifc_desc_size(the_gadget);
	desc = udc_descriptor_alloc(TYPE_CONFIGURATION, 0, size);
8f606e2c:	e1a01009 	mov	r1, r9
	desc_list = desc;
8f606e30:	e5854000 	str	r4, [r5]
	desc->next = desc_list;
8f606e34:	e5842000 	str	r2, [r4]
	data[16] = udc_string_desc_alloc(the_device->serialno);
8f606e38:	e5c40018 	strb	r0, [r4, #24]
	desc = udc_descriptor_alloc(TYPE_CONFIGURATION, 0, size);
8f606e3c:	e1a00007 	mov	r0, r7
	size = 9 + udc_ifc_desc_size(the_gadget);
8f606e40:	e5d3200b 	ldrb	r2, [r3, #11]
8f606e44:	e3a07007 	mov	r7, #7
8f606e48:	e3a03012 	mov	r3, #18
8f606e4c:	e1073287 	smlabb	r7, r7, r2, r3
	desc = udc_descriptor_alloc(TYPE_CONFIGURATION, 0, size);
8f606e50:	e1a02007 	mov	r2, r7
8f606e54:	ebfffb62 	bl	8f605be4 <udc_descriptor_alloc>
	if(!desc)
8f606e58:	e2504000 	subs	r4, r0, #0
8f606e5c:	0a000066 	beq	8f606ffc <udc_start+0x2d8>
	data[4] = 0x01;		/* number of interfaces */
	data[5] = 0x01;		/* configuration value */
	data[6] = 0x00;		/* configuration string */
	data[7] = 0x80;		/* attributes */
	data[8] = 0x80;		/* max power (250ma) -- todo fix this */
	udc_ifc_desc_fill(the_gadget, data + 9);
8f606e60:	e5966000 	ldr	r6, [r6]
	data[0] = 0x09;
8f606e64:	e3a03009 	mov	r3, #9
	data[2] = size;
8f606e68:	e5c4700a 	strb	r7, [r4, #10]
	data[3] = size >> 8;
8f606e6c:	e1a07427 	lsr	r7, r7, #8
	data[0] = 0x09;
8f606e70:	e5c43008 	strb	r3, [r4, #8]
	data[3] = size >> 8;
8f606e74:	e5c4700b 	strb	r7, [r4, #11]
	data[6] = 0x00;		/* configuration string */
8f606e78:	e3a07000 	mov	r7, #0
	data[0] = 0x09;
8f606e7c:	e5c43011 	strb	r3, [r4, #17]
	data[4] = 0x01;		/* number of interfaces */
8f606e80:	e3a03001 	mov	r3, #1
	data[6] = 0x00;		/* configuration string */
8f606e84:	e5c4700e 	strb	r7, [r4, #14]
	data[4] = 0x01;		/* number of interfaces */
8f606e88:	e5c4300c 	strb	r3, [r4, #12]
	data[5] = 0x01;		/* configuration value */
8f606e8c:	e5c4300d 	strb	r3, [r4, #13]
	data[7] = 0x80;		/* attributes */
8f606e90:	e3e0307f 	mvn	r3, #127	; 0x7f
	data[2] = 0x00;		/* ifc number */
8f606e94:	e5c47013 	strb	r7, [r4, #19]
	data[7] = 0x80;		/* attributes */
8f606e98:	e5c4300f 	strb	r3, [r4, #15]
	data[8] = 0x80;		/* max power (250ma) -- todo fix this */
8f606e9c:	e5c43010 	strb	r3, [r4, #16]
	data[1] = TYPE_INTERFACE;
8f606ea0:	e3a03004 	mov	r3, #4
	data[3] = 0x00;		/* alt number */
8f606ea4:	e5c47014 	strb	r7, [r4, #20]
	data[1] = TYPE_INTERFACE;
8f606ea8:	e5c43012 	strb	r3, [r4, #18]
	data[4] = g->ifc_endpoints;
8f606eac:	e5d6300b 	ldrb	r3, [r6, #11]
8f606eb0:	e5c43015 	strb	r3, [r4, #21]
	data[5] = g->ifc_class;
8f606eb4:	e5d63008 	ldrb	r3, [r6, #8]
8f606eb8:	e5c43016 	strb	r3, [r4, #22]
	data[6] = g->ifc_subclass;
8f606ebc:	e5d63009 	ldrb	r3, [r6, #9]
8f606ec0:	e5c43017 	strb	r3, [r4, #23]
	data[7] = g->ifc_protocol;
8f606ec4:	e5d6300a 	ldrb	r3, [r6, #10]
8f606ec8:	e5c43018 	strb	r3, [r4, #24]
	data[8] = udc_string_desc_alloc(g->ifc_string);
8f606ecc:	e596000c 	ldr	r0, [r6, #12]
8f606ed0:	ebfffb85 	bl	8f605cec <udc_string_desc_alloc>
8f606ed4:	e5c40019 	strb	r0, [r4, #25]
	for (n = 0; n < g->ifc_endpoints; n++) {
8f606ed8:	e5d6300b 	ldrb	r3, [r6, #11]
8f606edc:	e1530007 	cmp	r3, r7
8f606ee0:	0a00001c 	beq	8f606f58 <udc_start+0x234>
8f606ee4:	e2843021 	add	r3, r4, #33	; 0x21
8f606ee8:	e1a01007 	mov	r1, r7
	data[0] = 7;
8f606eec:	e3a08007 	mov	r8, #7
	data[1] = TYPE_ENDPOINT;
8f606ef0:	e3a07005 	mov	r7, #5
	data[3] = 0x02;		/* bulk -- the only kind we support */
8f606ef4:	e3a0e002 	mov	r14, #2
		udc_ept_desc_fill(g->ept[n], data);
8f606ef8:	e5962014 	ldr	r2, [r6, #20]
	for (n = 0; n < g->ifc_endpoints; n++) {
8f606efc:	e2833007 	add	r3, r3, #7
		udc_ept_desc_fill(g->ept[n], data);
8f606f00:	e7922101 	ldr	r2, [r2, r1, lsl #2]
	for (n = 0; n < g->ifc_endpoints; n++) {
8f606f04:	e2811001 	add	r1, r1, #1
	data[0] = 7;
8f606f08:	e543800e 	strb	r8, [r3, #-14]
	data[1] = TYPE_ENDPOINT;
8f606f0c:	e543700d 	strb	r7, [r3, #-13]
	data[2] = ept->num | (ept->in ? 0x80 : 0x00);
8f606f10:	e5d2c011 	ldrb	r12, [r2, #17]
8f606f14:	e5d20010 	ldrb	r0, [r2, #16]
8f606f18:	e35c0000 	cmp	r12, #0
	data[3] = 0x02;		/* bulk -- the only kind we support */
8f606f1c:	e543e00b 	strb	r14, [r3, #-11]
	data[2] = ept->num | (ept->in ? 0x80 : 0x00);
8f606f20:	13800080 	orrne	r0, r0, #128	; 0x80
8f606f24:	e543000c 	strb	r0, [r3, #-12]
	data[4] = ept->maxpkt;
8f606f28:	e1d201b2 	ldrh	r0, [r2, #18]
8f606f2c:	e543000a 	strb	r0, [r3, #-10]
	data[5] = ept->maxpkt >> 8;
8f606f30:	e1d2c1b2 	ldrh	r12, [r2, #18]
8f606f34:	e1a0c42c 	lsr	r12, r12, #8
8f606f38:	e543c009 	strb	r12, [r3, #-9]
	data[6] = ept->in ? 0x00 : 0x01;
8f606f3c:	e5d22011 	ldrb	r2, [r2, #17]
8f606f40:	e16f2f12 	clz	r2, r2
8f606f44:	e1a022a2 	lsr	r2, r2, #5
8f606f48:	e5432008 	strb	r2, [r3, #-8]
	for (n = 0; n < g->ifc_endpoints; n++) {
8f606f4c:	e5d6200b 	ldrb	r2, [r6, #11]
8f606f50:	e1510002 	cmp	r1, r2
8f606f54:	3affffe7 	bcc	8f606ef8 <udc_start+0x1d4>
	desc->next = desc_list;
8f606f58:	e5953000 	ldr	r3, [r5]
	udc_descriptor_register(desc);

	register_int_handler(INT_USB_HS, udc_interrupt, (void *)0);
8f606f5c:	e3a02000 	mov	r2, #0
	desc_list = desc;
8f606f60:	e5854000 	str	r4, [r5]
	register_int_handler(INT_USB_HS, udc_interrupt, (void *)0);
8f606f64:	e3a000ac 	mov	r0, #172	; 0xac
8f606f68:	e306142c 	movw	r1, #25644	; 0x642c
8f606f6c:	e3481f60 	movt	r1, #36704	; 0x8f60
	desc->next = desc_list;
8f606f70:	e5843000 	str	r3, [r4]
	writel(STS_URI | STS_SLI | STS_UI | STS_PCI, USB_USBINTR);
8f606f74:	e3a04a0b 	mov	r4, #45056	; 0xb000
8f606f78:	e340478d 	movt	r4, #1933	; 0x78d
	register_int_handler(INT_USB_HS, udc_interrupt, (void *)0);
8f606f7c:	eb0020c2 	bl	8f60f28c <register_int_handler>
	writel(STS_URI | STS_SLI | STS_UI | STS_PCI, USB_USBINTR);
8f606f80:	e3003145 	movw	r3, #325	; 0x145
	unmask_interrupt(INT_USB_HS);
8f606f84:	e3a000ac 	mov	r0, #172	; 0xac
	writel(STS_URI | STS_SLI | STS_UI | STS_PCI, USB_USBINTR);
8f606f88:	e5843148 	str	r3, [r4, #328]	; 0x148
	unmask_interrupt(INT_USB_HS);
8f606f8c:	eb0020ad 	bl	8f60f248 <unmask_interrupt>

	/* go to RUN mode (D+ pullup enable) */
	val = readl(USB_USBCMD);
8f606f90:	e5943140 	ldr	r3, [r4, #320]	; 0x140

	writel(val | 0x00080001, USB_USBCMD);

	return 0;
8f606f94:	e3a00000 	mov	r0, #0
	writel(val | 0x00080001, USB_USBCMD);
8f606f98:	e3833702 	orr	r3, r3, #524288	; 0x80000
8f606f9c:	e3833001 	orr	r3, r3, #1
8f606fa0:	e5843140 	str	r3, [r4, #320]	; 0x140
}
8f606fa4:	e59f30b4 	ldr	r3, [pc, #180]	; 8f607060 <udc_start+0x33c>
8f606fa8:	e5932000 	ldr	r2, [r3]
8f606fac:	e59d300c 	ldr	r3, [r13, #12]
8f606fb0:	e0332002 	eors	r2, r3, r2
8f606fb4:	e3a03000 	mov	r3, #0
8f606fb8:	1a000027 	bne	8f60705c <udc_start+0x338>
8f606fbc:	e28dd014 	add	r13, r13, #20
8f606fc0:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
		dprintf(CRITICAL, "Failed to allocate device descriptor\n");
8f606fc4:	e30105a4 	movw	r0, #5540	; 0x15a4
8f606fc8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f606fcc:	eb00ae68 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f606fd0:	e3073f64 	movw	r3, #32612	; 0x7f64
8f606fd4:	e3012498 	movw	r2, #5272	; 0x1498
8f606fd8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f606fdc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f606fe0:	e58d3000 	str	r3, [r13]
8f606fe4:	e3001130 	movw	r1, #304	; 0x130
8f606fe8:	e300337b 	movw	r3, #891	; 0x37b
8f606fec:	e3481f70 	movt	r1, #36720	; 0x8f70
8f606ff0:	e1a00008 	mov	r0, r8
8f606ff4:	eb00aeb0 	bl	8f632abc <_panic>
8f606ff8:	eaffff63 	b	8f606d8c <udc_start+0x68>
		dprintf(CRITICAL, "Failed to allocate device descriptor\n");
8f606ffc:	e30105a4 	movw	r0, #5540	; 0x15a4
8f607000:	e3480f70 	movt	r0, #36720	; 0x8f70
8f607004:	eb00ae5a 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f607008:	e1a00008 	mov	r0, r8
8f60700c:	e3073f64 	movw	r3, #32612	; 0x7f64
8f607010:	e3012498 	movw	r2, #5272	; 0x1498
8f607014:	e3483f70 	movt	r3, #36720	; 0x8f70
8f607018:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60701c:	e58d3000 	str	r3, [r13]
8f607020:	e3001130 	movw	r1, #304	; 0x130
8f607024:	e3003393 	movw	r3, #915	; 0x393
8f607028:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60702c:	eb00aea2 	bl	8f632abc <_panic>
8f607030:	eaffff8a 	b	8f606e60 <udc_start+0x13c>
		dprintf(CRITICAL, "udc has no gadget registered\n");
8f607034:	e3010584 	movw	r0, #5508	; 0x1584
8f607038:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60703c:	eb00ae4c 	bl	8f632974 <_dprintf>
		return -1;
8f607040:	e3e00000 	mvn	r0, #0
8f607044:	eaffffd6 	b	8f606fa4 <udc_start+0x280>
		dprintf(CRITICAL, "udc cannot start before init\n");
8f607048:	e3010564 	movw	r0, #5476	; 0x1564
8f60704c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f607050:	eb00ae47 	bl	8f632974 <_dprintf>
		return -1;
8f607054:	e3e00000 	mvn	r0, #0
8f607058:	eaffffd1 	b	8f606fa4 <udc_start+0x280>
}
8f60705c:	eb00aed7 	bl	8f632bc0 <__stack_chk_fail>
8f607060:	8f74221c 	.word	0x8f74221c

8f607064 <udc_stop>:

int udc_stop(void)
{
8f607064:	e59f3078 	ldr	r3, [pc, #120]	; 8f6070e4 <udc_stop+0x80>
	/* Stop controller. */
	val = readl(USB_USBCMD);
	writel(val & ~USBCMD_ATTACH, USB_USBCMD);

	/* Mask the interrupts. */
	writel(0, USB_USBINTR);
8f607068:	e3a02000 	mov	r2, #0
{
8f60706c:	e92d4010 	push	{r4, r14}
8f607070:	e24dd008 	sub	r13, r13, #8
8f607074:	e5933000 	ldr	r3, [r3]
8f607078:	e58d3004 	str	r3, [r13, #4]
8f60707c:	e3a03000 	mov	r3, #0
	writel(0xffffffff, USB_ENDPTFLUSH);
8f607080:	e3a04a0b 	mov	r4, #45056	; 0xb000
8f607084:	e340478d 	movt	r4, #1933	; 0x78d
8f607088:	e3e03000 	mvn	r3, #0
	mask_interrupt(INT_USB_HS);
8f60708c:	e3a000ac 	mov	r0, #172	; 0xac
	writel(0xffffffff, USB_ENDPTFLUSH);
8f607090:	e58431b4 	str	r3, [r4, #436]	; 0x1b4
	val = readl(USB_USBCMD);
8f607094:	e5943140 	ldr	r3, [r4, #320]	; 0x140
	writel(val & ~USBCMD_ATTACH, USB_USBCMD);
8f607098:	e3c33001 	bic	r3, r3, #1
8f60709c:	e5843140 	str	r3, [r4, #320]	; 0x140
	writel(0, USB_USBINTR);
8f6070a0:	e5842148 	str	r2, [r4, #328]	; 0x148
	mask_interrupt(INT_USB_HS);
8f6070a4:	eb002056 	bl	8f60f204 <mask_interrupt>

	/* Perform any target specific clean up. */
	target_usb_stop();
8f6070a8:	eb006ab7 	bl	8f621b8c <target_usb_stop>

	/* Reset the controller. */
	writel(USBCMD_RESET, USB_USBCMD);
8f6070ac:	e3a03002 	mov	r3, #2
8f6070b0:	e5843140 	str	r3, [r4, #320]	; 0x140
	/* Wait until reset completes. */
	while(readl(USB_USBCMD) & USBCMD_RESET);
8f6070b4:	e5940140 	ldr	r0, [r4, #320]	; 0x140
8f6070b8:	e2100002 	ands	r0, r0, #2
8f6070bc:	1afffffc 	bne	8f6070b4 <udc_stop+0x50>

	return 0;
}
8f6070c0:	e59f301c 	ldr	r3, [pc, #28]	; 8f6070e4 <udc_stop+0x80>
8f6070c4:	e5932000 	ldr	r2, [r3]
8f6070c8:	e59d3004 	ldr	r3, [r13, #4]
8f6070cc:	e0332002 	eors	r2, r3, r2
8f6070d0:	e3a03000 	mov	r3, #0
8f6070d4:	1a000001 	bne	8f6070e0 <udc_stop+0x7c>
8f6070d8:	e28dd008 	add	r13, r13, #8
8f6070dc:	e8bd8010 	pop	{r4, r15}
8f6070e0:	eb00aeb6 	bl	8f632bc0 <__stack_chk_fail>
8f6070e4:	8f74221c 	.word	0x8f74221c

8f6070e8 <bs_set_timestamp>:
#include <platform/iomap.h>
#include <platform.h>

static uint32_t kernel_load_start;
void bs_set_timestamp(enum bs_entry bs_id)
{
8f6070e8:	e59f314c 	ldr	r3, [pc, #332]	; 8f60723c <bs_set_timestamp+0x154>
8f6070ec:	e92d4070 	push	{r4, r5, r6, r14}
8f6070f0:	e24dd010 	sub	r13, r13, #16
8f6070f4:	e5933000 	ldr	r3, [r3]
8f6070f8:	e58d300c 	str	r3, [r13, #12]
8f6070fc:	e3a03000 	mov	r3, #0
	addr_t bs_imem = get_bs_info_addr();
8f607100:	e1a0500e 	mov	r5, r14
{
8f607104:	e1a04000 	mov	r4, r0
	addr_t bs_imem = get_bs_info_addr();
8f607108:	ebffe92c 	bl	8f6015c0 <get_bs_info_addr>
	uint32_t clk_count = 0;

	if(bs_imem) {
8f60710c:	e2506000 	subs	r6, r0, #0
8f607110:	0a000028 	beq	8f6071b8 <bs_set_timestamp+0xd0>
		if (bs_id >= BS_MAX) {
8f607114:	e3540007 	cmp	r4, #7
8f607118:	8a000014 	bhi	8f607170 <bs_set_timestamp+0x88>
			dprintf(CRITICAL, "bad bs id: %u, max: %u\n", bs_id, BS_MAX);
			ASSERT(0);
		}

		if (bs_id == BS_KERNEL_LOAD_START) {
8f60711c:	e3540004 	cmp	r4, #4
8f607120:	0a00002c 	beq	8f6071d8 <bs_set_timestamp+0xf0>
			kernel_load_start = platform_get_sclk_count();
			return;
		}

		if(bs_id == BS_KERNEL_LOAD_DONE){
8f607124:	e3540005 	cmp	r4, #5
8f607128:	0a00002f 	beq	8f6071ec <bs_set_timestamp+0x104>
				writel(clk_count - kernel_load_start,
					bs_imem + (sizeof(uint32_t) * BS_KERNEL_LOAD_TIME));
			}
			return;
		}
		if(bs_id == BS_DTB_OVERLAY_START){
8f60712c:	e3540006 	cmp	r4, #6
8f607130:	0a000036 	beq	8f607210 <bs_set_timestamp+0x128>
			clk_count = platform_get_sclk_count();
			dprintf(INFO, "DTBO Overlay count start: %u\n", clk_count);
			return;
		}
		if(bs_id == BS_DTB_OVERLAY_END){
8f607134:	e3540007 	cmp	r4, #7
8f607138:	1a00001b 	bne	8f6071ac <bs_set_timestamp+0xc4>
			clk_count = platform_get_sclk_count();
8f60713c:	ebffe90c 	bl	8f601574 <platform_get_sclk_count>
			dprintf(INFO, "DTBO Overlay count done: %u\n", clk_count);
8f607140:	e59f30f4 	ldr	r3, [pc, #244]	; 8f60723c <bs_set_timestamp+0x154>
8f607144:	e5932000 	ldr	r2, [r3]
8f607148:	e59d300c 	ldr	r3, [r13, #12]
8f60714c:	e0332002 	eors	r2, r3, r2
8f607150:	e3a03000 	mov	r3, #0
			clk_count = platform_get_sclk_count();
8f607154:	e1a01000 	mov	r1, r0
			dprintf(INFO, "DTBO Overlay count done: %u\n", clk_count);
8f607158:	030106f4 	movweq	r0, #5876	; 0x16f4
8f60715c:	03480f70 	movteq	r0, #36720	; 0x8f70
8f607160:	1a000034 	bne	8f607238 <bs_set_timestamp+0x150>
				writel(clk_count,
					bs_imem + (sizeof(uint32_t) * bs_id));
			}
		}
	}
}
8f607164:	e28dd010 	add	r13, r13, #16
8f607168:	e8bd4070 	pop	{r4, r5, r6, r14}
			dprintf(INFO, "DTBO Overlay count done: %u\n", clk_count);
8f60716c:	ea00ae00 	b	8f632974 <_dprintf>
			dprintf(CRITICAL, "bad bs id: %u, max: %u\n", bs_id, BS_MAX);
8f607170:	e1a01004 	mov	r1, r4
8f607174:	e3a02008 	mov	r2, #8
8f607178:	e3010698 	movw	r0, #5784	; 0x1698
8f60717c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f607180:	eb00adfb 	bl	8f632974 <_dprintf>
			ASSERT(0);
8f607184:	e3072f64 	movw	r2, #32612	; 0x7f64
8f607188:	e3001130 	movw	r1, #304	; 0x130
8f60718c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f607190:	e3481f70 	movt	r1, #36720	; 0x8f70
8f607194:	e58d2000 	str	r2, [r13]
8f607198:	e3a0302c 	mov	r3, #44	; 0x2c
8f60719c:	e30126b0 	movw	r2, #5808	; 0x16b0
8f6071a0:	e1a00005 	mov	r0, r5
8f6071a4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6071a8:	eb00ae43 	bl	8f632abc <_panic>
			clk_count = platform_get_sclk_count();
8f6071ac:	ebffe8f0 	bl	8f601574 <platform_get_sclk_count>
			if(clk_count){
8f6071b0:	e3500000 	cmp	r0, #0
				writel(clk_count,
8f6071b4:	17860104 	strne	r0, [r6, r4, lsl #2]
}
8f6071b8:	e59f307c 	ldr	r3, [pc, #124]	; 8f60723c <bs_set_timestamp+0x154>
8f6071bc:	e5932000 	ldr	r2, [r3]
8f6071c0:	e59d300c 	ldr	r3, [r13, #12]
8f6071c4:	e0332002 	eors	r2, r3, r2
8f6071c8:	e3a03000 	mov	r3, #0
8f6071cc:	1a000019 	bne	8f607238 <bs_set_timestamp+0x150>
8f6071d0:	e28dd010 	add	r13, r13, #16
8f6071d4:	e8bd8070 	pop	{r4, r5, r6, r15}
			kernel_load_start = platform_get_sclk_count();
8f6071d8:	ebffe8e5 	bl	8f601574 <platform_get_sclk_count>
8f6071dc:	e30b3e48 	movw	r3, #48712	; 0xbe48
8f6071e0:	e3483f72 	movt	r3, #36722	; 0x8f72
8f6071e4:	e5830000 	str	r0, [r3]
			return;
8f6071e8:	eafffff2 	b	8f6071b8 <bs_set_timestamp+0xd0>
			clk_count = platform_get_sclk_count();
8f6071ec:	ebffe8e0 	bl	8f601574 <platform_get_sclk_count>
			if(clk_count){
8f6071f0:	e3500000 	cmp	r0, #0
8f6071f4:	0affffef 	beq	8f6071b8 <bs_set_timestamp+0xd0>
				writel(clk_count - kernel_load_start,
8f6071f8:	e30b3e48 	movw	r3, #48712	; 0xbe48
8f6071fc:	e3483f72 	movt	r3, #36722	; 0x8f72
8f607200:	e5933000 	ldr	r3, [r3]
8f607204:	e0400003 	sub	r0, r0, r3
8f607208:	e586000c 	str	r0, [r6, #12]
8f60720c:	eaffffe9 	b	8f6071b8 <bs_set_timestamp+0xd0>
			clk_count = platform_get_sclk_count();
8f607210:	ebffe8d7 	bl	8f601574 <platform_get_sclk_count>
			dprintf(INFO, "DTBO Overlay count start: %u\n", clk_count);
8f607214:	e59f3020 	ldr	r3, [pc, #32]	; 8f60723c <bs_set_timestamp+0x154>
8f607218:	e5932000 	ldr	r2, [r3]
8f60721c:	e59d300c 	ldr	r3, [r13, #12]
8f607220:	e0332002 	eors	r2, r3, r2
8f607224:	e3a03000 	mov	r3, #0
			clk_count = platform_get_sclk_count();
8f607228:	e1a01000 	mov	r1, r0
			dprintf(INFO, "DTBO Overlay count start: %u\n", clk_count);
8f60722c:	030106d4 	movweq	r0, #5844	; 0x16d4
8f607230:	03480f70 	movteq	r0, #36720	; 0x8f70
8f607234:	0affffca 	beq	8f607164 <bs_set_timestamp+0x7c>
}
8f607238:	eb00ae60 	bl	8f632bc0 <__stack_chk_fail>
8f60723c:	8f74221c 	.word	0x8f74221c

8f607240 <qgic_dist_config>:

static struct ihandler handler[NR_IRQS];

/* Intialize distributor */
void qgic_dist_config(uint32_t num_irq)
{
8f607240:	e59f30cc 	ldr	r3, [pc, #204]	; 8f607314 <qgic_dist_config+0xd4>
	uint32_t i;

	/* Set each interrupt line to use N-N software model
	 * and edge sensitive, active high
	 */
	for (i = 32; i < num_irq; i += 16)
8f607244:	e3500020 	cmp	r0, #32
{
8f607248:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60724c:	e24dd00c 	sub	r13, r13, #12
8f607250:	e5933000 	ldr	r3, [r3]
8f607254:	e58d3004 	str	r3, [r13, #4]
8f607258:	e3a03000 	mov	r3, #0
	for (i = 32; i < num_irq; i += 16)
8f60725c:	9a000025 	bls	8f6072f8 <qgic_dist_config+0xb8>
8f607260:	e3a03020 	mov	r3, #32
		writel(0xffffffff, GIC_DIST_CONFIG + i * 4 / 16);
8f607264:	e3e01000 	mvn	r1, #0
8f607268:	e7fb2153 	ubfx	r2, r3, #2, #28
	for (i = 32; i < num_irq; i += 16)
8f60726c:	e2833010 	add	r3, r3, #16
		writel(0xffffffff, GIC_DIST_CONFIG + i * 4 / 16);
8f607270:	e282240b 	add	r2, r2, #184549376	; 0xb000000
	for (i = 32; i < num_irq; i += 16)
8f607274:	e1500003 	cmp	r0, r3
		writel(0xffffffff, GIC_DIST_CONFIG + i * 4 / 16);
8f607278:	e5821c00 	str	r1, [r2, #3072]	; 0xc00
	for (i = 32; i < num_irq; i += 16)
8f60727c:	8afffff9 	bhi	8f607268 <qgic_dist_config+0x28>

	writel(0xffffffff, GIC_DIST_CONFIG + 4);
8f607280:	e3a0340b 	mov	r3, #184549376	; 0xb000000
8f607284:	e5831c04 	str	r1, [r3, #3076]	; 0xc04
	/*
	 * In bootloader we dont care about priority so
	 * setting up equal priorities for all
	 */
	for (i = 0; i < num_irq; i += 4)
		writel(0xa0a0a0a0, GIC_DIST_PRI + i * 4 / 4);
8f607288:	e30a10a0 	movw	r1, #41120	; 0xa0a0
8f60728c:	e34a10a0 	movt	r1, #41120	; 0xa0a0
	for (i = 32; i < num_irq; i += 16)
8f607290:	e3a03000 	mov	r3, #0
		writel(0xa0a0a0a0, GIC_DIST_PRI + i * 4 / 4);
8f607294:	e3c32103 	bic	r2, r3, #-1073741824	; 0xc0000000
	for (i = 0; i < num_irq; i += 4)
8f607298:	e2833004 	add	r3, r3, #4
		writel(0xa0a0a0a0, GIC_DIST_PRI + i * 4 / 4);
8f60729c:	e282240b 	add	r2, r2, #184549376	; 0xb000000
	for (i = 0; i < num_irq; i += 4)
8f6072a0:	e1500003 	cmp	r0, r3
		writel(0xa0a0a0a0, GIC_DIST_PRI + i * 4 / 4);
8f6072a4:	e5821400 	str	r1, [r2, #1024]	; 0x400
	for (i = 0; i < num_irq; i += 4)
8f6072a8:	8afffff9 	bhi	8f607294 <qgic_dist_config+0x54>
8f6072ac:	e3a03000 	mov	r3, #0

	/* Disabling interrupts */
	for (i = 0; i < num_irq; i += 32)
		writel(0xffffffff, GIC_DIST_ENABLE_CLEAR + i * 4 / 32);
8f6072b0:	e3e01000 	mvn	r1, #0
8f6072b4:	e7fa21d3 	ubfx	r2, r3, #3, #27
	for (i = 0; i < num_irq; i += 32)
8f6072b8:	e2833020 	add	r3, r3, #32
		writel(0xffffffff, GIC_DIST_ENABLE_CLEAR + i * 4 / 32);
8f6072bc:	e282240b 	add	r2, r2, #184549376	; 0xb000000
	for (i = 0; i < num_irq; i += 32)
8f6072c0:	e1500003 	cmp	r0, r3
		writel(0xffffffff, GIC_DIST_ENABLE_CLEAR + i * 4 / 32);
8f6072c4:	e5821180 	str	r1, [r2, #384]	; 0x180
	for (i = 0; i < num_irq; i += 32)
8f6072c8:	8afffff9 	bhi	8f6072b4 <qgic_dist_config+0x74>

	writel(0x0000ffff, GIC_DIST_ENABLE_SET);
8f6072cc:	e3a0340b 	mov	r3, #184549376	; 0xb000000
8f6072d0:	e30f2fff 	movw	r2, #65535	; 0xffff
8f6072d4:	e5832100 	str	r2, [r3, #256]	; 0x100
}
8f6072d8:	e59f3034 	ldr	r3, [pc, #52]	; 8f607314 <qgic_dist_config+0xd4>
8f6072dc:	e5932000 	ldr	r2, [r3]
8f6072e0:	e59d3004 	ldr	r3, [r13, #4]
8f6072e4:	e0332002 	eors	r2, r3, r2
8f6072e8:	e3a03000 	mov	r3, #0
8f6072ec:	1a000007 	bne	8f607310 <qgic_dist_config+0xd0>
8f6072f0:	e28dd00c 	add	r13, r13, #12
8f6072f4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	for (i = 0; i < num_irq; i += 4)
8f6072f8:	e3500000 	cmp	r0, #0
	writel(0xffffffff, GIC_DIST_CONFIG + 4);
8f6072fc:	e3a0340b 	mov	r3, #184549376	; 0xb000000
8f607300:	e3e02000 	mvn	r2, #0
8f607304:	e5832c04 	str	r2, [r3, #3076]	; 0xc04
	for (i = 0; i < num_irq; i += 4)
8f607308:	0affffef 	beq	8f6072cc <qgic_dist_config+0x8c>
8f60730c:	eaffffdd 	b	8f607288 <qgic_dist_config+0x48>
}
8f607310:	eb00ae2a 	bl	8f632bc0 <__stack_chk_fail>
8f607314:	8f74221c 	.word	0x8f74221c

8f607318 <qgic_init>:

/* Initialize QGIC. Called from platform specific init code */
void qgic_init(void)
{
8f607318:	e59f303c 	ldr	r3, [pc, #60]	; 8f60735c <qgic_init+0x44>
8f60731c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f607320:	e24dd00c 	sub	r13, r13, #12
8f607324:	e5933000 	ldr	r3, [r3]
8f607328:	e58d3004 	str	r3, [r13, #4]
8f60732c:	e3a03000 	mov	r3, #0
	qgic_dist_init();
8f607330:	eb001d88 	bl	8f60e958 <qgic_dist_init>
	qgic_cpu_init();
8f607334:	e59f3020 	ldr	r3, [pc, #32]	; 8f60735c <qgic_init+0x44>
8f607338:	e5932000 	ldr	r2, [r3]
8f60733c:	e59d3004 	ldr	r3, [r13, #4]
8f607340:	e0332002 	eors	r2, r3, r2
8f607344:	e3a03000 	mov	r3, #0
8f607348:	1a000002 	bne	8f607358 <qgic_init+0x40>
}
8f60734c:	e28dd00c 	add	r13, r13, #12
8f607350:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	qgic_cpu_init();
8f607354:	ea001db3 	b	8f60ea28 <qgic_cpu_init>
8f607358:	eb00ae18 	bl	8f632bc0 <__stack_chk_fail>
8f60735c:	8f74221c 	.word	0x8f74221c

8f607360 <gic_platform_irq>:

/* IRQ handler */
enum handler_return gic_platform_irq(struct arm_iframe *frame)
{
8f607360:	e59f3074 	ldr	r3, [pc, #116]	; 8f6073dc <gic_platform_irq+0x7c>
8f607364:	e92d4010 	push	{r4, r14}
8f607368:	e24dd008 	sub	r13, r13, #8
8f60736c:	e5933000 	ldr	r3, [r3]
8f607370:	e58d3004 	str	r3, [r13, #4]
8f607374:	e3a03000 	mov	r3, #0
	uint32_t num;
	enum handler_return ret;

	/* Read the interrupt number to be served*/
	num = qgic_read_iar();
8f607378:	eb001dc0 	bl	8f60ea80 <qgic_read_iar>

	if (num >= NR_IRQS)
8f60737c:	e3500f6b 	cmp	r0, #428	; 0x1ac
		return 0;
8f607380:	83a04000 	movhi	r4, #0
	if (num >= NR_IRQS)
8f607384:	8a00000a 	bhi	8f6073b4 <gic_platform_irq+0x54>

	ret = handler[num].func(handler[num].arg);
8f607388:	e30b3e4c 	movw	r3, #48716	; 0xbe4c
8f60738c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f607390:	e0832180 	add	r2, r3, r0, lsl #3
8f607394:	e1a04000 	mov	r4, r0
8f607398:	e7933180 	ldr	r3, [r3, r0, lsl #3]
8f60739c:	e5920004 	ldr	r0, [r2, #4]
8f6073a0:	e12fff33 	blx	r3
8f6073a4:	e1a03000 	mov	r3, r0

	/* End of interrupt */
	qgic_write_eoi(num);
8f6073a8:	e1a00004 	mov	r0, r4
	ret = handler[num].func(handler[num].arg);
8f6073ac:	e1a04003 	mov	r4, r3
	qgic_write_eoi(num);
8f6073b0:	eb001dc5 	bl	8f60eacc <qgic_write_eoi>

	return ret;
}
8f6073b4:	e59f3020 	ldr	r3, [pc, #32]	; 8f6073dc <gic_platform_irq+0x7c>
8f6073b8:	e5932000 	ldr	r2, [r3]
8f6073bc:	e59d3004 	ldr	r3, [r13, #4]
8f6073c0:	e0332002 	eors	r2, r3, r2
8f6073c4:	e3a03000 	mov	r3, #0
8f6073c8:	1a000002 	bne	8f6073d8 <gic_platform_irq+0x78>
8f6073cc:	e1a00004 	mov	r0, r4
8f6073d0:	e28dd008 	add	r13, r13, #8
8f6073d4:	e8bd8010 	pop	{r4, r15}
8f6073d8:	eb00adf8 	bl	8f632bc0 <__stack_chk_fail>
8f6073dc:	8f74221c 	.word	0x8f74221c

8f6073e0 <gic_platform_fiq>:

/* FIQ handler */
void gic_platform_fiq(struct arm_iframe *frame)
{
8f6073e0:	e59f304c 	ldr	r3, [pc, #76]	; 8f607434 <gic_platform_fiq+0x54>
8f6073e4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6073e8:	e24dd00c 	sub	r13, r13, #12
8f6073ec:	e5933000 	ldr	r3, [r3]
8f6073f0:	e58d3004 	str	r3, [r13, #4]
8f6073f4:	e3a03000 	mov	r3, #0
	PANIC_UNIMPLEMENTED;
8f6073f8:	e59f3034 	ldr	r3, [pc, #52]	; 8f607434 <gic_platform_fiq+0x54>
8f6073fc:	e5932000 	ldr	r2, [r3]
8f607400:	e59d3004 	ldr	r3, [r13, #4]
8f607404:	e0332002 	eors	r2, r3, r2
8f607408:	e3a03000 	mov	r3, #0
8f60740c:	1a000007 	bne	8f607430 <gic_platform_fiq+0x50>
8f607410:	e1a0000e 	mov	r0, r14
8f607414:	e3012760 	movw	r2, #5984	; 0x1760
8f607418:	e3011714 	movw	r1, #5908	; 0x1714
8f60741c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f607420:	e3481f70 	movt	r1, #36720	; 0x8f70
}
8f607424:	e28dd00c 	add	r13, r13, #12
8f607428:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	PANIC_UNIMPLEMENTED;
8f60742c:	ea00ada2 	b	8f632abc <_panic>
8f607430:	eb00ade2 	bl	8f632bc0 <__stack_chk_fail>
8f607434:	8f74221c 	.word	0x8f74221c

8f607438 <gic_mask_interrupt>:

/* Mask interrupt */
status_t gic_mask_interrupt(unsigned int vector)
{
	uint32_t reg = GIC_DIST_ENABLE_CLEAR + (vector / 32) * 4;
	uint32_t bit = 1 << (vector & 31);
8f607438:	e200201f 	and	r2, r0, #31
	uint32_t reg = GIC_DIST_ENABLE_CLEAR + (vector / 32) * 4;
8f60743c:	e1a002a0 	lsr	r0, r0, #5
8f607440:	e280050b 	add	r0, r0, #46137344	; 0x2c00000
	uint32_t bit = 1 << (vector & 31);
8f607444:	e3a03001 	mov	r3, #1
	uint32_t reg = GIC_DIST_ENABLE_CLEAR + (vector / 32) * 4;
8f607448:	e2800060 	add	r0, r0, #96	; 0x60
	uint32_t bit = 1 << (vector & 31);
8f60744c:	e1a03213 	lsl	r3, r3, r2
{
8f607450:	e59f2040 	ldr	r2, [pc, #64]	; 8f607498 <gic_mask_interrupt+0x60>
	uint32_t reg = GIC_DIST_ENABLE_CLEAR + (vector / 32) * 4;
8f607454:	e1a00100 	lsl	r0, r0, #2
{
8f607458:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60745c:	e24dd00c 	sub	r13, r13, #12
8f607460:	e5922000 	ldr	r2, [r2]
8f607464:	e58d2004 	str	r2, [r13, #4]
8f607468:	e3a02000 	mov	r2, #0

	writel(bit, reg);
8f60746c:	e5803000 	str	r3, [r0]

	return 0;
}
8f607470:	e59f3020 	ldr	r3, [pc, #32]	; 8f607498 <gic_mask_interrupt+0x60>
8f607474:	e5932000 	ldr	r2, [r3]
8f607478:	e59d3004 	ldr	r3, [r13, #4]
8f60747c:	e0332002 	eors	r2, r3, r2
8f607480:	e3a03000 	mov	r3, #0
8f607484:	1a000002 	bne	8f607494 <gic_mask_interrupt+0x5c>
8f607488:	e3a00000 	mov	r0, #0
8f60748c:	e28dd00c 	add	r13, r13, #12
8f607490:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f607494:	eb00adc9 	bl	8f632bc0 <__stack_chk_fail>
8f607498:	8f74221c 	.word	0x8f74221c

8f60749c <gic_unmask_interrupt>:

/* Un-mask interrupt */
status_t gic_unmask_interrupt(unsigned int vector)
{
	uint32_t reg = GIC_DIST_ENABLE_SET + (vector / 32) * 4;
	uint32_t bit = 1 << (vector & 31);
8f60749c:	e200201f 	and	r2, r0, #31
	uint32_t reg = GIC_DIST_ENABLE_SET + (vector / 32) * 4;
8f6074a0:	e1a002a0 	lsr	r0, r0, #5
8f6074a4:	e280050b 	add	r0, r0, #46137344	; 0x2c00000
	uint32_t bit = 1 << (vector & 31);
8f6074a8:	e3a03001 	mov	r3, #1
	uint32_t reg = GIC_DIST_ENABLE_SET + (vector / 32) * 4;
8f6074ac:	e2800040 	add	r0, r0, #64	; 0x40
	uint32_t bit = 1 << (vector & 31);
8f6074b0:	e1a03213 	lsl	r3, r3, r2
{
8f6074b4:	e59f2040 	ldr	r2, [pc, #64]	; 8f6074fc <gic_unmask_interrupt+0x60>
	uint32_t reg = GIC_DIST_ENABLE_SET + (vector / 32) * 4;
8f6074b8:	e1a00100 	lsl	r0, r0, #2
{
8f6074bc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6074c0:	e24dd00c 	sub	r13, r13, #12
8f6074c4:	e5922000 	ldr	r2, [r2]
8f6074c8:	e58d2004 	str	r2, [r13, #4]
8f6074cc:	e3a02000 	mov	r2, #0

	writel(bit, reg);
8f6074d0:	e5803000 	str	r3, [r0]

	return 0;
}
8f6074d4:	e59f3020 	ldr	r3, [pc, #32]	; 8f6074fc <gic_unmask_interrupt+0x60>
8f6074d8:	e5932000 	ldr	r2, [r3]
8f6074dc:	e59d3004 	ldr	r3, [r13, #4]
8f6074e0:	e0332002 	eors	r2, r3, r2
8f6074e4:	e3a03000 	mov	r3, #0
8f6074e8:	1a000002 	bne	8f6074f8 <gic_unmask_interrupt+0x5c>
8f6074ec:	e3a00000 	mov	r0, #0
8f6074f0:	e28dd00c 	add	r13, r13, #12
8f6074f4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6074f8:	eb00adb0 	bl	8f632bc0 <__stack_chk_fail>
8f6074fc:	8f74221c 	.word	0x8f74221c

8f607500 <gic_register_int_handler>:

/* Register interrupt handler */
void gic_register_int_handler(unsigned int vector, int_handler func, void *arg)
{
8f607500:	e59f30f8 	ldr	r3, [pc, #248]	; 8f607600 <gic_register_int_handler+0x100>
	ASSERT(vector < NR_IRQS);
8f607504:	e3500f6b 	cmp	r0, #428	; 0x1ac
{
8f607508:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f60750c:	e24dd014 	sub	r13, r13, #20
8f607510:	e5933000 	ldr	r3, [r3]
8f607514:	e58d300c 	str	r3, [r13, #12]
8f607518:	e3a03000 	mov	r3, #0
8f60751c:	e1a05000 	mov	r5, r0
8f607520:	e1a07001 	mov	r7, r1
8f607524:	e1a06002 	mov	r6, r2
	ASSERT(vector < NR_IRQS);
8f607528:	8a000028 	bhi	8f6075d0 <gic_register_int_handler+0xd0>
	critical_section_count++;
8f60752c:	e3014acc 	movw	r4, #6860	; 0x1acc
8f607530:	e3484f71 	movt	r4, #36721	; 0x8f71
8f607534:	e5942000 	ldr	r2, [r4]
8f607538:	e2823001 	add	r3, r2, #1
8f60753c:	e5843000 	str	r3, [r4]
	if (critical_section_count == 1)
8f607540:	e3530001 	cmp	r3, #1
8f607544:	0a00000d 	beq	8f607580 <gic_register_int_handler+0x80>

	enter_critical_section();
	handler[vector].func = func;
8f607548:	e30b3e4c 	movw	r3, #48716	; 0xbe4c
8f60754c:	e3483f72 	movt	r3, #36722	; 0x8f72
	critical_section_count--;
8f607550:	e5842000 	str	r2, [r4]
	handler[vector].arg = arg;
8f607554:	e0832185 	add	r2, r3, r5, lsl #3
	handler[vector].func = func;
8f607558:	e7837185 	str	r7, [r3, r5, lsl #3]
	handler[vector].arg = arg;
8f60755c:	e5826004 	str	r6, [r2, #4]
	exit_critical_section();
}
8f607560:	e59f3098 	ldr	r3, [pc, #152]	; 8f607600 <gic_register_int_handler+0x100>
8f607564:	e5932000 	ldr	r2, [r3]
8f607568:	e59d300c 	ldr	r3, [r13, #12]
8f60756c:	e0332002 	eors	r2, r3, r2
8f607570:	e3a03000 	mov	r3, #0
8f607574:	1a000020 	bne	8f6075fc <gic_register_int_handler+0xfc>
8f607578:	e28dd014 	add	r13, r13, #20
8f60757c:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		arch_disable_ints();
8f607580:	eb0066a4 	bl	8f621018 <arch_disable_ints>
	critical_section_count--;
8f607584:	e5943000 	ldr	r3, [r4]
8f607588:	e2433001 	sub	r3, r3, #1
8f60758c:	e5843000 	str	r3, [r4]
	if (critical_section_count == 0)
8f607590:	e3530000 	cmp	r3, #0
	handler[vector].func = func;
8f607594:	e30b3e4c 	movw	r3, #48716	; 0xbe4c
8f607598:	e3483f72 	movt	r3, #36722	; 0x8f72
	handler[vector].arg = arg;
8f60759c:	e0832185 	add	r2, r3, r5, lsl #3
	handler[vector].func = func;
8f6075a0:	e7837185 	str	r7, [r3, r5, lsl #3]
	handler[vector].arg = arg;
8f6075a4:	e5826004 	str	r6, [r2, #4]
8f6075a8:	1affffec 	bne	8f607560 <gic_register_int_handler+0x60>
		arch_enable_ints();
8f6075ac:	e59f304c 	ldr	r3, [pc, #76]	; 8f607600 <gic_register_int_handler+0x100>
8f6075b0:	e5932000 	ldr	r2, [r3]
8f6075b4:	e59d300c 	ldr	r3, [r13, #12]
8f6075b8:	e0332002 	eors	r2, r3, r2
8f6075bc:	e3a03000 	mov	r3, #0
8f6075c0:	1a00000d 	bne	8f6075fc <gic_register_int_handler+0xfc>
}
8f6075c4:	e28dd014 	add	r13, r13, #20
8f6075c8:	e8bd40f0 	pop	{r4, r5, r6, r7, r14}
8f6075cc:	ea00668d 	b	8f621008 <arch_enable_ints>
	ASSERT(vector < NR_IRQS);
8f6075d0:	e301374c 	movw	r3, #5964	; 0x174c
8f6075d4:	e1a0000e 	mov	r0, r14
8f6075d8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6075dc:	e3012728 	movw	r2, #5928	; 0x1728
8f6075e0:	e58d3000 	str	r3, [r13]
8f6075e4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6075e8:	e3a03080 	mov	r3, #128	; 0x80
8f6075ec:	e3001130 	movw	r1, #304	; 0x130
8f6075f0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6075f4:	eb00ad30 	bl	8f632abc <_panic>
8f6075f8:	eaffffcb 	b	8f60752c <gic_register_int_handler+0x2c>
}
8f6075fc:	eb00ad6f 	bl	8f632bc0 <__stack_chk_fail>
8f607600:	8f74221c 	.word	0x8f74221c

8f607604 <crc32>:
	0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
	0x2d02ef8dL
};

uint32_t crc32(uint32_t crc, const void *buf, size_t size)
{
8f607604:	e59f3064 	ldr	r3, [pc, #100]	; 8f607670 <crc32+0x6c>
	const uint8_t *p = buf;

	while (size--)
8f607608:	e3520000 	cmp	r2, #0
{
8f60760c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f607610:	e24dd00c 	sub	r13, r13, #12
8f607614:	e5933000 	ldr	r3, [r3]
8f607618:	e58d3004 	str	r3, [r13, #4]
8f60761c:	e3a03000 	mov	r3, #0
	while (size--)
8f607620:	0a000009 	beq	8f60764c <crc32+0x48>
8f607624:	e301c774 	movw	r12, #6004	; 0x1774
8f607628:	e0812002 	add	r2, r1, r2
8f60762c:	e348cf70 	movt	r12, #36720	; 0x8f70
		crc = crc32_table[(crc ^ *p++) & 0xff] ^ (crc >> 8);
8f607630:	e4d13001 	ldrb	r3, [r1], #1
8f607634:	e0233000 	eor	r3, r3, r0
	while (size--)
8f607638:	e1510002 	cmp	r1, r2
		crc = crc32_table[(crc ^ *p++) & 0xff] ^ (crc >> 8);
8f60763c:	e6ef3073 	uxtb	r3, r3
8f607640:	e79c3103 	ldr	r3, [r12, r3, lsl #2]
8f607644:	e0230420 	eor	r0, r3, r0, lsr #8
	while (size--)
8f607648:	1afffff8 	bne	8f607630 <crc32+0x2c>
	return crc;
}
8f60764c:	e59f301c 	ldr	r3, [pc, #28]	; 8f607670 <crc32+0x6c>
8f607650:	e5932000 	ldr	r2, [r3]
8f607654:	e59d3004 	ldr	r3, [r13, #4]
8f607658:	e0332002 	eors	r2, r3, r2
8f60765c:	e3a03000 	mov	r3, #0
8f607660:	1a000001 	bne	8f60766c <crc32+0x68>
8f607664:	e28dd00c 	add	r13, r13, #12
8f607668:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60766c:	eb00ad53 	bl	8f632bc0 <__stack_chk_fail>
8f607670:	8f74221c 	.word	0x8f74221c

8f607674 <load_sec_app>:

static bool lksec_app_loaded;
static int app_handle;

int load_sec_app()
{
8f607674:	e59f3080 	ldr	r3, [pc, #128]	; 8f6076fc <load_sec_app+0x88>
	/* start TZ app */
	app_handle = qseecom_start_app("keymaster");
8f607678:	e3010b74 	movw	r0, #7028	; 0x1b74
{
8f60767c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	app_handle = qseecom_start_app("keymaster");
8f607680:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f607684:	e24dd00c 	sub	r13, r13, #12
8f607688:	e5933000 	ldr	r3, [r3]
8f60768c:	e58d3004 	str	r3, [r13, #4]
8f607690:	e3a03000 	mov	r3, #0
	app_handle = qseecom_start_app("keymaster");
8f607694:	eb003ae3 	bl	8f616228 <qseecom_start_app>
8f607698:	e30c3bb4 	movw	r3, #52148	; 0xcbb4
8f60769c:	e3483f72 	movt	r3, #36722	; 0x8f72

	if (app_handle <= 0)
8f6076a0:	e3500000 	cmp	r0, #0
	app_handle = qseecom_start_app("keymaster");
8f6076a4:	e5830000 	str	r0, [r3]
	if (app_handle <= 0)
8f6076a8:	da00000c 	ble	8f6076e0 <load_sec_app+0x6c>
	{
		dprintf(CRITICAL, "Failure to load TZ app: lksecapp, error: %d\n", app_handle);
		return -1;
	}
	lksec_app_loaded = true;
8f6076ac:	e30c3bb8 	movw	r3, #52152	; 0xcbb8
8f6076b0:	e3483f72 	movt	r3, #36722	; 0x8f72
	return 0;
8f6076b4:	e3a00000 	mov	r0, #0
	lksec_app_loaded = true;
8f6076b8:	e3a02001 	mov	r2, #1
8f6076bc:	e5832000 	str	r2, [r3]
}
8f6076c0:	e59f3034 	ldr	r3, [pc, #52]	; 8f6076fc <load_sec_app+0x88>
8f6076c4:	e5932000 	ldr	r2, [r3]
8f6076c8:	e59d3004 	ldr	r3, [r13, #4]
8f6076cc:	e0332002 	eors	r2, r3, r2
8f6076d0:	e3a03000 	mov	r3, #0
8f6076d4:	1a000007 	bne	8f6076f8 <load_sec_app+0x84>
8f6076d8:	e28dd00c 	add	r13, r13, #12
8f6076dc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		dprintf(CRITICAL, "Failure to load TZ app: lksecapp, error: %d\n", app_handle);
8f6076e0:	e1a01000 	mov	r1, r0
8f6076e4:	e3010b80 	movw	r0, #7040	; 0x1b80
8f6076e8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6076ec:	eb00aca0 	bl	8f632974 <_dprintf>
		return -1;
8f6076f0:	e3e00000 	mvn	r0, #0
8f6076f4:	eafffff1 	b	8f6076c0 <load_sec_app+0x4c>
}
8f6076f8:	eb00ad30 	bl	8f632bc0 <__stack_chk_fail>
8f6076fc:	8f74221c 	.word	0x8f74221c

8f607700 <get_secapp_handle>:

int get_secapp_handle()
{
8f607700:	e92d4010 	push	{r4, r14}
	dprintf(INFO, "LK SEC APP Handle: 0x%x\n", app_handle);
8f607704:	e30c4bb4 	movw	r4, #52148	; 0xcbb4
8f607708:	e3484f72 	movt	r4, #36722	; 0x8f72
{
8f60770c:	e59f3044 	ldr	r3, [pc, #68]	; 8f607758 <get_secapp_handle+0x58>
8f607710:	e24dd008 	sub	r13, r13, #8
	dprintf(INFO, "LK SEC APP Handle: 0x%x\n", app_handle);
8f607714:	e3010bb0 	movw	r0, #7088	; 0x1bb0
8f607718:	e5941000 	ldr	r1, [r4]
8f60771c:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f607720:	e5933000 	ldr	r3, [r3]
8f607724:	e58d3004 	str	r3, [r13, #4]
8f607728:	e3a03000 	mov	r3, #0
	dprintf(INFO, "LK SEC APP Handle: 0x%x\n", app_handle);
8f60772c:	eb00ac90 	bl	8f632974 <_dprintf>
	return app_handle;
}
8f607730:	e59f3020 	ldr	r3, [pc, #32]	; 8f607758 <get_secapp_handle+0x58>
	return app_handle;
8f607734:	e5940000 	ldr	r0, [r4]
}
8f607738:	e5932000 	ldr	r2, [r3]
8f60773c:	e59d3004 	ldr	r3, [r13, #4]
8f607740:	e0332002 	eors	r2, r3, r2
8f607744:	e3a03000 	mov	r3, #0
8f607748:	1a000001 	bne	8f607754 <get_secapp_handle+0x54>
8f60774c:	e28dd008 	add	r13, r13, #8
8f607750:	e8bd8010 	pop	{r4, r15}
8f607754:	eb00ad19 	bl	8f632bc0 <__stack_chk_fail>
8f607758:	8f74221c 	.word	0x8f74221c

8f60775c <send_milestone_call_to_tz>:
	return 0;
#endif
}

int send_milestone_call_to_tz()
{
8f60775c:	e92d4030 	push	{r4, r5, r14}
	km_set_milestone_rsp_t rsp = {0};
	uint32_t version=0;
	req.cmd_id = KEYMASTER_MILESTONE_CALL;

	/* Milestone end command */
	ret = qseecom_send_command(app_handle, (void *)&req, sizeof(req), (void *)&rsp, sizeof(rsp));
8f607760:	e30c1bb4 	movw	r1, #52148	; 0xcbb4
{
8f607764:	e24dd01c 	sub	r13, r13, #28
	ret = qseecom_send_command(app_handle, (void *)&req, sizeof(req), (void *)&rsp, sizeof(rsp));
8f607768:	e3481f72 	movt	r1, #36722	; 0x8f72
{
8f60776c:	e59fe0e0 	ldr	r14, [pc, #224]	; 8f607854 <send_milestone_call_to_tz+0xf8>
	ret = qseecom_send_command(app_handle, (void *)&req, sizeof(req), (void *)&rsp, sizeof(rsp));
8f607770:	e3a02004 	mov	r2, #4
8f607774:	e5910000 	ldr	r0, [r1]
8f607778:	e28d3010 	add	r3, r13, #16
8f60777c:	e28d100c 	add	r1, r13, #12
8f607780:	e58d2000 	str	r2, [r13]
	km_set_milestone_rsp_t rsp = {0};
8f607784:	e3a0c000 	mov	r12, #0
{
8f607788:	e59ee000 	ldr	r14, [r14]
8f60778c:	e58de014 	str	r14, [r13, #20]
8f607790:	e3a0e000 	mov	r14, #0
	km_set_milestone_rsp_t rsp = {0};
8f607794:	e58dc010 	str	r12, [r13, #16]
	req.cmd_id = KEYMASTER_MILESTONE_CALL;
8f607798:	e3a0cf81 	mov	r12, #516	; 0x204
8f60779c:	e58dc00c 	str	r12, [r13, #12]
	ret = qseecom_send_command(app_handle, (void *)&req, sizeof(req), (void *)&rsp, sizeof(rsp));
8f6077a0:	eb003bbf 	bl	8f6166a4 <qseecom_send_command>

	if (ret < 0 || rsp.status < 0)
8f6077a4:	e59d1010 	ldr	r1, [r13, #16]
8f6077a8:	e2504000 	subs	r4, r0, #0
8f6077ac:	ba000022 	blt	8f60783c <send_milestone_call_to_tz+0xe0>
8f6077b0:	e3510000 	cmp	r1, #0
8f6077b4:	ba000020 	blt	8f60783c <send_milestone_call_to_tz+0xe0>
	{
		dprintf(CRITICAL, "Failed to send milestone end command: Error: %x\n", rsp.status);
		return -1;
	}
	version = qseecom_get_version();
8f6077b8:	eb003e2d 	bl	8f617074 <qseecom_get_version>
8f6077bc:	e1a05000 	mov	r5, r0
	if(allow_set_fuse(version)) {
8f6077c0:	eb003794 	bl	8f615618 <allow_set_fuse>
8f6077c4:	e3500000 	cmp	r0, #0
8f6077c8:	0a000014 	beq	8f607820 <send_milestone_call_to_tz+0xc4>
               ret = set_tamper_fuse_cmd(HLOS_BL_MILESTONE_FUSE);
8f6077cc:	e3a0000b 	mov	r0, #11
8f6077d0:	eb0033fe 	bl	8f6147d0 <set_tamper_fuse_cmd>
               if (ret) {
8f6077d4:	e3500000 	cmp	r0, #0
8f6077d8:	1a00000c 	bne	8f607810 <send_milestone_call_to_tz+0xb4>
	} else {
               dprintf(CRITICAL, "send_milestone_call_to_tz: TZ didn't support this feature! Version: major = %d, minor = %d, patch = %d\n",
			(version >> 22) & 0x3FF, (version >> 12) & 0x3FF, version & 0x3FF);
               return ret;
	}
	dprintf(CRITICAL, "Success ");
8f6077dc:	e3010cb8 	movw	r0, #7352	; 0x1cb8
8f6077e0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6077e4:	eb00ac62 	bl	8f632974 <_dprintf>
	return 0;
8f6077e8:	e3a04000 	mov	r4, #0
}
8f6077ec:	e59f3060 	ldr	r3, [pc, #96]	; 8f607854 <send_milestone_call_to_tz+0xf8>
8f6077f0:	e5932000 	ldr	r2, [r3]
8f6077f4:	e59d3014 	ldr	r3, [r13, #20]
8f6077f8:	e0332002 	eors	r2, r3, r2
8f6077fc:	e3a03000 	mov	r3, #0
8f607800:	1a000012 	bne	8f607850 <send_milestone_call_to_tz+0xf4>
8f607804:	e1a00004 	mov	r0, r4
8f607808:	e28dd01c 	add	r13, r13, #28
8f60780c:	e8bd8030 	pop	{r4, r5, r15}
                       dprintf(CRITICAL, "send_milestone_call_to_tz: set_tamper_fuse_cmd (HLOS_BL_MILESTONE_FUSE) fails!\n");
8f607810:	e3010c00 	movw	r0, #7168	; 0x1c00
8f607814:	e3480f70 	movt	r0, #36720	; 0x8f70
8f607818:	eb00ac55 	bl	8f632974 <_dprintf>
8f60781c:	eaffffee 	b	8f6077dc <send_milestone_call_to_tz+0x80>
               dprintf(CRITICAL, "send_milestone_call_to_tz: TZ didn't support this feature! Version: major = %d, minor = %d, patch = %d\n",
8f607820:	e7e93055 	ubfx	r3, r5, #0, #10
8f607824:	e7e92655 	ubfx	r2, r5, #12, #10
8f607828:	e1a01b25 	lsr	r1, r5, #22
8f60782c:	e3010c50 	movw	r0, #7248	; 0x1c50
8f607830:	e3480f70 	movt	r0, #36720	; 0x8f70
8f607834:	eb00ac4e 	bl	8f632974 <_dprintf>
               return ret;
8f607838:	eaffffeb 	b	8f6077ec <send_milestone_call_to_tz+0x90>
		dprintf(CRITICAL, "Failed to send milestone end command: Error: %x\n", rsp.status);
8f60783c:	e3010bcc 	movw	r0, #7116	; 0x1bcc
8f607840:	e3480f70 	movt	r0, #36720	; 0x8f70
		return -1;
8f607844:	e3e04000 	mvn	r4, #0
		dprintf(CRITICAL, "Failed to send milestone end command: Error: %x\n", rsp.status);
8f607848:	eb00ac49 	bl	8f632974 <_dprintf>
		return -1;
8f60784c:	eaffffe6 	b	8f6077ec <send_milestone_call_to_tz+0x90>
}
8f607850:	eb00acda 	bl	8f632bc0 <__stack_chk_fail>
8f607854:	8f74221c 	.word	0x8f74221c

8f607858 <is_sec_app_loaded>:

bool is_sec_app_loaded()
{
	return lksec_app_loaded;
8f607858:	e30c3bb8 	movw	r3, #52152	; 0xcbb8
8f60785c:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f607860:	e59f2038 	ldr	r2, [pc, #56]	; 8f6078a0 <is_sec_app_loaded+0x48>
8f607864:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f607868:	e24dd00c 	sub	r13, r13, #12
	return lksec_app_loaded;
8f60786c:	e5930000 	ldr	r0, [r3]
{
8f607870:	e5922000 	ldr	r2, [r2]
8f607874:	e58d2004 	str	r2, [r13, #4]
8f607878:	e3a02000 	mov	r2, #0
}
8f60787c:	e59f301c 	ldr	r3, [pc, #28]	; 8f6078a0 <is_sec_app_loaded+0x48>
8f607880:	e5932000 	ldr	r2, [r3]
8f607884:	e59d3004 	ldr	r3, [r13, #4]
8f607888:	e0332002 	eors	r2, r3, r2
8f60788c:	e3a03000 	mov	r3, #0
8f607890:	1a000001 	bne	8f60789c <is_sec_app_loaded+0x44>
8f607894:	e28dd00c 	add	r13, r13, #12
8f607898:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60789c:	eb00acc7 	bl	8f632bc0 <__stack_chk_fail>
8f6078a0:	8f74221c 	.word	0x8f74221c

8f6078a4 <rpm_smd_init>:

static uint32_t msg_id;
smd_channel_info_t ch;

void rpm_smd_init()
{
8f6078a4:	e59f3044 	ldr	r3, [pc, #68]	; 8f6078f0 <rpm_smd_init+0x4c>
8f6078a8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6078ac:	e24dd00c 	sub	r13, r13, #12
8f6078b0:	e5933000 	ldr	r3, [r3]
8f6078b4:	e58d3004 	str	r3, [r13, #4]
8f6078b8:	e3a03000 	mov	r3, #0
	smd_init(&ch, SMD_APPS_RPM);
8f6078bc:	e59f302c 	ldr	r3, [pc, #44]	; 8f6078f0 <rpm_smd_init+0x4c>
8f6078c0:	e5932000 	ldr	r2, [r3]
8f6078c4:	e59d3004 	ldr	r3, [r13, #4]
8f6078c8:	e0332002 	eors	r2, r3, r2
8f6078cc:	e3a03000 	mov	r3, #0
8f6078d0:	1a000005 	bne	8f6078ec <rpm_smd_init+0x48>
8f6078d4:	e3020234 	movw	r0, #8756	; 0x2234
8f6078d8:	e3a0100f 	mov	r1, #15
8f6078dc:	e3480f74 	movt	r0, #36724	; 0x8f74
}
8f6078e0:	e28dd00c 	add	r13, r13, #12
8f6078e4:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	smd_init(&ch, SMD_APPS_RPM);
8f6078e8:	ea0000f0 	b	8f607cb0 <smd_init>
8f6078ec:	eb00acb3 	bl	8f632bc0 <__stack_chk_fail>
8f6078f0:	8f74221c 	.word	0x8f74221c

8f6078f4 <rpm_smd_uninit>:

void rpm_smd_uninit()
{
8f6078f4:	e59f3040 	ldr	r3, [pc, #64]	; 8f60793c <rpm_smd_uninit+0x48>
8f6078f8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6078fc:	e24dd00c 	sub	r13, r13, #12
8f607900:	e5933000 	ldr	r3, [r3]
8f607904:	e58d3004 	str	r3, [r13, #4]
8f607908:	e3a03000 	mov	r3, #0
	smd_uninit(&ch);
8f60790c:	e59f3028 	ldr	r3, [pc, #40]	; 8f60793c <rpm_smd_uninit+0x48>
8f607910:	e5932000 	ldr	r2, [r3]
8f607914:	e59d3004 	ldr	r3, [r13, #4]
8f607918:	e0332002 	eors	r2, r3, r2
8f60791c:	e3a03000 	mov	r3, #0
8f607920:	1a000004 	bne	8f607938 <rpm_smd_uninit+0x44>
8f607924:	e3020234 	movw	r0, #8756	; 0x2234
8f607928:	e3480f74 	movt	r0, #36724	; 0x8f74
}
8f60792c:	e28dd00c 	add	r13, r13, #12
8f607930:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	smd_uninit(&ch);
8f607934:	ea00003d 	b	8f607a30 <smd_uninit>
8f607938:	eb00aca0 	bl	8f632bc0 <__stack_chk_fail>
8f60793c:	8f74221c 	.word	0x8f74221c

8f607940 <smd_get_channel_info>:
{
	int i = 0;

	for(i = 0; i< SMEM_NUM_SMD_STREAM_CHANNELS; i++)
	{
		if((smd_channel_alloc_entry[i].ctype & 0xFF) == ch_type)
8f607940:	e30232a0 	movw	r3, #8864	; 0x22a0
8f607944:	e3483f74 	movt	r3, #36724	; 0x8f74

	return 0;
}

int smd_get_channel_info(smd_channel_info_t *ch, uint32_t ch_type)
{
8f607948:	e92d4010 	push	{r4, r14}
8f60794c:	e1a04000 	mov	r4, r0
8f607950:	e24dd010 	sub	r13, r13, #16
8f607954:	e5933000 	ldr	r3, [r3]
8f607958:	e59f00cc 	ldr	r0, [pc, #204]	; 8f607a2c <smd_get_channel_info+0xec>
	int ret = 0;
	uint8_t *fifo_buf = NULL;
	uint32_t fifo_buf_size = 0;
8f60795c:	e3a02000 	mov	r2, #0
8f607960:	e283cb02 	add	r12, r3, #2048	; 0x800
{
8f607964:	e5900000 	ldr	r0, [r0]
8f607968:	e58d000c 	str	r0, [r13, #12]
8f60796c:	e3a00000 	mov	r0, #0
	uint32_t fifo_buf_size = 0;
8f607970:	e58d2004 	str	r2, [r13, #4]
	uint32_t size = 0;
8f607974:	e58d2008 	str	r2, [r13, #8]
	for(i = 0; i< SMEM_NUM_SMD_STREAM_CHANNELS; i++)
8f607978:	ea000002 	b	8f607988 <smd_get_channel_info+0x48>
8f60797c:	e2833020 	add	r3, r3, #32
8f607980:	e153000c 	cmp	r3, r12
8f607984:	0a000022 	beq	8f607a14 <smd_get_channel_info+0xd4>
		if((smd_channel_alloc_entry[i].ctype & 0xFF) == ch_type)
8f607988:	e5d32018 	ldrb	r2, [r3, #24]
8f60798c:	e1510002 	cmp	r1, r2
8f607990:	1afffff9 	bne	8f60797c <smd_get_channel_info+0x3c>
			memcpy(&ch->alloc_entry, &smd_channel_alloc_entry[i], sizeof(smd_channel_alloc_entry_t));
8f607994:	e3a02020 	mov	r2, #32
8f607998:	e1a01003 	mov	r1, r3
8f60799c:	e1a00004 	mov	r0, r4
8f6079a0:	eb00b204 	bl	8f6341b8 <memcpy>
	ret = smd_get_channel_entry(ch, ch_type);

	if (ret)
		return ret;

	ch->port_info = smem_get_alloc_entry(SMEM_SMD_BASE_ID + ch->alloc_entry.cid,
8f6079a4:	e5940014 	ldr	r0, [r4, #20]
8f6079a8:	e28d1008 	add	r1, r13, #8
8f6079ac:	e280000e 	add	r0, r0, #14
8f6079b0:	e6ff0070 	uxth	r0, r0
8f6079b4:	ebffebd0 	bl	8f6028fc <smem_get_alloc_entry>
										 &size);

	fifo_buf = smem_get_alloc_entry(SMEM_SMD_FIFO_BASE_ID + ch->alloc_entry.cid,
8f6079b8:	e5943014 	ldr	r3, [r4, #20]
8f6079bc:	e28d1004 	add	r1, r13, #4
	ch->port_info = smem_get_alloc_entry(SMEM_SMD_BASE_ID + ch->alloc_entry.cid,
8f6079c0:	e584002c 	str	r0, [r4, #44]	; 0x2c
	fifo_buf = smem_get_alloc_entry(SMEM_SMD_FIFO_BASE_ID + ch->alloc_entry.cid,
8f6079c4:	e2830e15 	add	r0, r3, #336	; 0x150
8f6079c8:	e2800002 	add	r0, r0, #2
8f6079cc:	e6ff0070 	uxth	r0, r0
8f6079d0:	ebffebc9 	bl	8f6028fc <smem_get_alloc_entry>
									&fifo_buf_size);

	fifo_buf_size /= 2;
8f6079d4:	e59d2004 	ldr	r2, [r13, #4]
8f6079d8:	e1a020a2 	lsr	r2, r2, #1
	ch->send_buf = fifo_buf;
	ch->recv_buf = fifo_buf + fifo_buf_size;
	ch->fifo_size = fifo_buf_size;
8f6079dc:	e5842028 	str	r2, [r4, #40]	; 0x28
	fifo_buf = smem_get_alloc_entry(SMEM_SMD_FIFO_BASE_ID + ch->alloc_entry.cid,
8f6079e0:	e1a03000 	mov	r3, r0
	return 0;
8f6079e4:	e3a00000 	mov	r0, #0
	ch->send_buf = fifo_buf;
8f6079e8:	e5843020 	str	r3, [r4, #32]
	ch->recv_buf = fifo_buf + fifo_buf_size;
8f6079ec:	e0833002 	add	r3, r3, r2
8f6079f0:	e5843024 	str	r3, [r4, #36]	; 0x24

	return ret;
}
8f6079f4:	e59f3030 	ldr	r3, [pc, #48]	; 8f607a2c <smd_get_channel_info+0xec>
8f6079f8:	e5932000 	ldr	r2, [r3]
8f6079fc:	e59d300c 	ldr	r3, [r13, #12]
8f607a00:	e0332002 	eors	r2, r3, r2
8f607a04:	e3a03000 	mov	r3, #0
8f607a08:	1a000006 	bne	8f607a28 <smd_get_channel_info+0xe8>
8f607a0c:	e28dd010 	add	r13, r13, #16
8f607a10:	e8bd8010 	pop	{r4, r15}
		dprintf(SPEW, "Channel not found, wait and retry for the update\n");
8f607a14:	e3010cc4 	movw	r0, #7364	; 0x1cc4
8f607a18:	e3480f70 	movt	r0, #36720	; 0x8f70
8f607a1c:	eb00abd4 	bl	8f632974 <_dprintf>
		return -1;
8f607a20:	e3e00000 	mvn	r0, #0
8f607a24:	eafffff2 	b	8f6079f4 <smd_get_channel_info+0xb4>
}
8f607a28:	eb00ac64 	bl	8f632bc0 <__stack_chk_fail>
8f607a2c:	8f74221c 	.word	0x8f74221c

8f607a30 <smd_uninit>:

	return 0;
}

void smd_uninit(smd_channel_info_t *ch)
{
8f607a30:	e59f3104 	ldr	r3, [pc, #260]	; 8f607b3c <smd_uninit+0x10c>
	event_init(&smd_closed, false, EVENT_FLAG_AUTOUNSIGNAL);
8f607a34:	e3a02001 	mov	r2, #1
{
8f607a38:	e92d4030 	push	{r4, r5, r14}
	event_init(&smd_closed, false, EVENT_FLAG_AUTOUNSIGNAL);
8f607a3c:	e3a01000 	mov	r1, #0
{
8f607a40:	e24dd014 	sub	r13, r13, #20
8f607a44:	e1a04000 	mov	r4, r0
	event_init(&smd_closed, false, EVENT_FLAG_AUTOUNSIGNAL);
8f607a48:	e30c0bbc 	movw	r0, #52156	; 0xcbbc
8f607a4c:	e3480f72 	movt	r0, #36722	; 0x8f72
{
8f607a50:	e5933000 	ldr	r3, [r3]
8f607a54:	e58d300c 	str	r3, [r13, #12]
8f607a58:	e3a03000 	mov	r3, #0
8f607a5c:	e1a0500e 	mov	r5, r14
	event_init(&smd_closed, false, EVENT_FLAG_AUTOUNSIGNAL);
8f607a60:	eb006bfb 	bl	8f622a54 <event_init>
void smd_set_state(smd_channel_info_t *ch, uint32_t state, uint32_t flag)
{
	uint32_t current_state;
	uint32_t size = 0;

	if(!ch->port_info)
8f607a64:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
	uint32_t size = 0;
8f607a68:	e3a02000 	mov	r2, #0
8f607a6c:	e58d2008 	str	r2, [r13, #8]
	if(!ch->port_info)
8f607a70:	e1530002 	cmp	r3, r2
8f607a74:	0a00001a 	beq	8f607ae4 <smd_uninit+0xb4>
		{
			smd_write_state(ch, SMD_SS_OPENED);
		}
		break;
		case SMD_SS_CLOSING:
		if(current_state == SMD_SS_OPENED)
8f607a78:	e5932000 	ldr	r2, [r3]
8f607a7c:	e3520002 	cmp	r2, #2
8f607a80:	1a000005 	bne	8f607a9c <smd_uninit+0x6c>
		ch->port_info->ch0.DTR_DSR = 0;
8f607a84:	e3a02000 	mov	r2, #0
	ch->port_info->ch0.stream_state = state;
8f607a88:	e3a01004 	mov	r1, #4
		ch->port_info->ch0.DTR_DSR = 0;
8f607a8c:	e5832004 	str	r2, [r3, #4]
		ch->port_info->ch0.CTS_RTS = 0;
8f607a90:	e5832008 	str	r2, [r3, #8]
		ch->port_info->ch0.CD = 0;
8f607a94:	e583200c 	str	r2, [r3, #12]
	ch->port_info->ch0.stream_state = state;
8f607a98:	e5831000 	str	r1, [r3]
	ch->port_info->ch0.state_updated = flag;
8f607a9c:	e3a01001 	mov	r1, #1
	writel(BIT(0), APCS_ALIAS0_IPC_INTERRUPT);
8f607aa0:	e3a02a01 	mov	r2, #4096	; 0x1000
		case SMD_SS_RESET_OPENING:
		default:
		break;
	}

	ch->current_state = state;
8f607aa4:	e3a00004 	mov	r0, #4
	writel(BIT(0), APCS_ALIAS0_IPC_INTERRUPT);
8f607aa8:	e3402b11 	movt	r2, #2833	; 0xb11
	ch->current_state = state;
8f607aac:	e5840030 	str	r0, [r4, #48]	; 0x30
	ch->port_info->ch0.state_updated = flag;
8f607ab0:	e583101c 	str	r1, [r3, #28]
	event_wait(&smd_closed);
8f607ab4:	e59f3080 	ldr	r3, [pc, #128]	; 8f607b3c <smd_uninit+0x10c>
	writel(BIT(0), APCS_ALIAS0_IPC_INTERRUPT);
8f607ab8:	e5821008 	str	r1, [r2, #8]
	event_wait(&smd_closed);
8f607abc:	e5932000 	ldr	r2, [r3]
8f607ac0:	e59d300c 	ldr	r3, [r13, #12]
8f607ac4:	e0332002 	eors	r2, r3, r2
8f607ac8:	e3a03000 	mov	r3, #0
8f607acc:	1a000019 	bne	8f607b38 <smd_uninit+0x108>
8f607ad0:	e30c0bbc 	movw	r0, #52156	; 0xcbbc
8f607ad4:	e3480f72 	movt	r0, #36722	; 0x8f72
}
8f607ad8:	e28dd014 	add	r13, r13, #20
8f607adc:	e8bd4030 	pop	{r4, r5, r14}
	event_wait(&smd_closed);
8f607ae0:	ea006bf2 	b	8f622ab0 <event_wait>
		ch->port_info = smem_get_alloc_entry(SMEM_SMD_BASE_ID + ch->alloc_entry.cid,
8f607ae4:	e5940014 	ldr	r0, [r4, #20]
8f607ae8:	e28d1008 	add	r1, r13, #8
8f607aec:	e280000e 	add	r0, r0, #14
8f607af0:	e6ff0070 	uxth	r0, r0
8f607af4:	ebffeb80 	bl	8f6028fc <smem_get_alloc_entry>
		ASSERT(ch->port_info);
8f607af8:	e3500000 	cmp	r0, #0
		ch->port_info = smem_get_alloc_entry(SMEM_SMD_BASE_ID + ch->alloc_entry.cid,
8f607afc:	e1a03000 	mov	r3, r0
8f607b00:	e584002c 	str	r0, [r4, #44]	; 0x2c
		ASSERT(ch->port_info);
8f607b04:	1affffdb 	bne	8f607a78 <smd_uninit+0x48>
8f607b08:	e300316e 	movw	r3, #366	; 0x16e
8f607b0c:	e3011d14 	movw	r1, #7444	; 0x1d14
8f607b10:	e3012cf8 	movw	r2, #7416	; 0x1cf8
8f607b14:	e3481f70 	movt	r1, #36720	; 0x8f70
8f607b18:	e3482f70 	movt	r2, #36720	; 0x8f70
8f607b1c:	e58d1000 	str	r1, [r13]
8f607b20:	e1a00005 	mov	r0, r5
8f607b24:	e3001130 	movw	r1, #304	; 0x130
8f607b28:	e3481f70 	movt	r1, #36720	; 0x8f70
8f607b2c:	eb00abe2 	bl	8f632abc <_panic>
	current_state = ch->port_info->ch0.stream_state;
8f607b30:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
8f607b34:	eaffffcf 	b	8f607a78 <smd_uninit+0x48>
	event_wait(&smd_closed);
8f607b38:	eb00ac20 	bl	8f632bc0 <__stack_chk_fail>
8f607b3c:	8f74221c 	.word	0x8f74221c

8f607b40 <smd_set_state>:
{
8f607b40:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f607b44:	e1a06002 	mov	r6, r2
8f607b48:	e24dd014 	sub	r13, r13, #20
8f607b4c:	e59f2158 	ldr	r2, [pc, #344]	; 8f607cac <smd_set_state+0x16c>
	uint32_t size = 0;
8f607b50:	e3a03000 	mov	r3, #0
{
8f607b54:	e1a05000 	mov	r5, r0
8f607b58:	e5922000 	ldr	r2, [r2]
8f607b5c:	e58d200c 	str	r2, [r13, #12]
8f607b60:	e3a02000 	mov	r2, #0
	uint32_t size = 0;
8f607b64:	e58d3008 	str	r3, [r13, #8]
	if(!ch->port_info)
8f607b68:	e590302c 	ldr	r3, [r0, #44]	; 0x2c
{
8f607b6c:	e1a04001 	mov	r4, r1
	if(!ch->port_info)
8f607b70:	e3530000 	cmp	r3, #0
8f607b74:	0a000035 	beq	8f607c50 <smd_set_state+0x110>
	current_state = ch->port_info->ch0.stream_state;
8f607b78:	e5932000 	ldr	r2, [r3]
	switch(state)
8f607b7c:	e3540004 	cmp	r4, #4
8f607b80:	979ff104 	ldrls	r15, [r15, r4, lsl #2]
8f607b84:	ea00000c 	b	8f607bbc <smd_set_state+0x7c>
8f607b88:	8f607c30 	.word	0x8f607c30
8f607b8c:	8f607c04 	.word	0x8f607c04
8f607b90:	8f607be4 	.word	0x8f607be4
8f607b94:	8f607bbc 	.word	0x8f607bbc
8f607b98:	8f607b9c 	.word	0x8f607b9c
		if(current_state == SMD_SS_OPENED)
8f607b9c:	e3520002 	cmp	r2, #2
8f607ba0:	1a000005 	bne	8f607bbc <smd_set_state+0x7c>
		ch->port_info->ch0.DTR_DSR = 0;
8f607ba4:	e3a02000 	mov	r2, #0
8f607ba8:	e5832004 	str	r2, [r3, #4]
		ch->port_info->ch0.CTS_RTS = 0;
8f607bac:	e5832008 	str	r2, [r3, #8]
		ch->port_info->ch0.CD = 0;
8f607bb0:	e583200c 	str	r2, [r3, #12]
	ch->port_info->ch0.stream_state = state;
8f607bb4:	e3a02004 	mov	r2, #4
8f607bb8:	e5832000 	str	r2, [r3]
	ch->current_state = state;
8f607bbc:	e5854030 	str	r4, [r5, #48]	; 0x30
	ch->port_info->ch0.state_updated = flag;
8f607bc0:	e583601c 	str	r6, [r3, #28]

	smd_state_update(ch, flag);
}
8f607bc4:	e59f30e0 	ldr	r3, [pc, #224]	; 8f607cac <smd_set_state+0x16c>
8f607bc8:	e5932000 	ldr	r2, [r3]
8f607bcc:	e59d300c 	ldr	r3, [r13, #12]
8f607bd0:	e0332002 	eors	r2, r3, r2
8f607bd4:	e3a03000 	mov	r3, #0
8f607bd8:	1a000032 	bne	8f607ca8 <smd_set_state+0x168>
8f607bdc:	e28dd014 	add	r13, r13, #20
8f607be0:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		if(current_state == SMD_SS_OPENING)
8f607be4:	e3520001 	cmp	r2, #1
8f607be8:	1afffff3 	bne	8f607bbc <smd_set_state+0x7c>
		ch->port_info->ch0.DTR_DSR = 1;
8f607bec:	e5832004 	str	r2, [r3, #4]
		ch->port_info->ch0.CTS_RTS = 1;
8f607bf0:	e5832008 	str	r2, [r3, #8]
		ch->port_info->ch0.CD = 1;
8f607bf4:	e583200c 	str	r2, [r3, #12]
	ch->port_info->ch0.stream_state = state;
8f607bf8:	e3a02002 	mov	r2, #2
8f607bfc:	e5832000 	str	r2, [r3]
}
8f607c00:	eaffffed 	b	8f607bbc <smd_set_state+0x7c>
		if(current_state == SMD_SS_CLOSING || current_state == SMD_SS_CLOSED)
8f607c04:	e3d22004 	bics	r2, r2, #4
8f607c08:	1affffeb 	bne	8f607bbc <smd_set_state+0x7c>
		ch->port_info->ch0.DTR_DSR = 0;
8f607c0c:	e5832004 	str	r2, [r3, #4]
		ch->port_info->ch0.CTS_RTS = 0;
8f607c10:	e5832008 	str	r2, [r3, #8]
		ch->port_info->ch0.CD = 0;
8f607c14:	e583200c 	str	r2, [r3, #12]
			ch->port_info->ch1.read_index = 0;
8f607c18:	e5832050 	str	r2, [r3, #80]	; 0x50
			ch->port_info->ch0.write_index = 0;
8f607c1c:	e5832028 	str	r2, [r3, #40]	; 0x28
			ch->port_info->ch0.mask_recv_intr = 0;
8f607c20:	e5832020 	str	r2, [r3, #32]
	ch->port_info->ch0.stream_state = state;
8f607c24:	e3a02001 	mov	r2, #1
8f607c28:	e5832000 	str	r2, [r3]
			ch->port_info->ch0.mask_recv_intr = 0;
8f607c2c:	eaffffe2 	b	8f607bbc <smd_set_state+0x7c>
		if(current_state == SMD_SS_OPENED)
8f607c30:	e3520002 	cmp	r2, #2
		ch->port_info->ch0.DTR_DSR = 0;
8f607c34:	e3a02000 	mov	r2, #0
8f607c38:	e5832004 	str	r2, [r3, #4]
		ch->port_info->ch0.CTS_RTS = 0;
8f607c3c:	e5832008 	str	r2, [r3, #8]
		ch->port_info->ch0.CD = 0;
8f607c40:	e583200c 	str	r2, [r3, #12]
		if(current_state == SMD_SS_OPENED)
8f607c44:	0affffda 	beq	8f607bb4 <smd_set_state+0x74>
	ch->port_info->ch0.stream_state = state;
8f607c48:	e5832000 	str	r2, [r3]
8f607c4c:	eaffffda 	b	8f607bbc <smd_set_state+0x7c>
		ch->port_info = smem_get_alloc_entry(SMEM_SMD_BASE_ID + ch->alloc_entry.cid,
8f607c50:	e5900014 	ldr	r0, [r0, #20]
8f607c54:	e28d1008 	add	r1, r13, #8
8f607c58:	e1a0700e 	mov	r7, r14
8f607c5c:	e280000e 	add	r0, r0, #14
8f607c60:	e6ff0070 	uxth	r0, r0
8f607c64:	ebffeb24 	bl	8f6028fc <smem_get_alloc_entry>
		ASSERT(ch->port_info);
8f607c68:	e3500000 	cmp	r0, #0
		ch->port_info = smem_get_alloc_entry(SMEM_SMD_BASE_ID + ch->alloc_entry.cid,
8f607c6c:	e1a03000 	mov	r3, r0
8f607c70:	e585002c 	str	r0, [r5, #44]	; 0x2c
		ASSERT(ch->port_info);
8f607c74:	1affffbf 	bne	8f607b78 <smd_set_state+0x38>
8f607c78:	e3013d14 	movw	r3, #7444	; 0x1d14
8f607c7c:	e1a00007 	mov	r0, r7
8f607c80:	e3483f70 	movt	r3, #36720	; 0x8f70
8f607c84:	e3012cf8 	movw	r2, #7416	; 0x1cf8
8f607c88:	e58d3000 	str	r3, [r13]
8f607c8c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f607c90:	e300316e 	movw	r3, #366	; 0x16e
8f607c94:	e3001130 	movw	r1, #304	; 0x130
8f607c98:	e3481f70 	movt	r1, #36720	; 0x8f70
8f607c9c:	eb00ab86 	bl	8f632abc <_panic>
	current_state = ch->port_info->ch0.stream_state;
8f607ca0:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
8f607ca4:	eaffffb3 	b	8f607b78 <smd_set_state+0x38>
}
8f607ca8:	eb00abc4 	bl	8f632bc0 <__stack_chk_fail>
8f607cac:	8f74221c 	.word	0x8f74221c

8f607cb0 <smd_init>:
{
8f607cb0:	e59f3184 	ldr	r3, [pc, #388]	; 8f607e3c <smd_init+0x18c>
8f607cb4:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
8f607cb8:	e1a08000 	mov	r8, r0
8f607cbc:	e24dd010 	sub	r13, r13, #16
8f607cc0:	e1a09001 	mov	r9, r1
	smd_channel_alloc_entry = (smd_channel_alloc_entry_t*)memalign(CACHE_LINE, SMD_CHANNEL_ALLOC_MAX);
8f607cc4:	e3a00040 	mov	r0, #64	; 0x40
8f607cc8:	e3a01b02 	mov	r1, #2048	; 0x800
{
8f607ccc:	e5933000 	ldr	r3, [r3]
8f607cd0:	e58d300c 	str	r3, [r13, #12]
8f607cd4:	e3a03000 	mov	r3, #0
	smd_channel_alloc_entry = (smd_channel_alloc_entry_t*)memalign(CACHE_LINE, SMD_CHANNEL_ALLOC_MAX);
8f607cd8:	e1a0a00e 	mov	r10, r14
8f607cdc:	eb00b0d8 	bl	8f634044 <memalign>
8f607ce0:	e30272a0 	movw	r7, #8864	; 0x22a0
8f607ce4:	e3487f74 	movt	r7, #36724	; 0x8f74
	ASSERT(smd_channel_alloc_entry);
8f607ce8:	e3500000 	cmp	r0, #0
	smd_channel_alloc_entry = (smd_channel_alloc_entry_t*)memalign(CACHE_LINE, SMD_CHANNEL_ALLOC_MAX);
8f607cec:	e5870000 	str	r0, [r7]
	ASSERT(smd_channel_alloc_entry);
8f607cf0:	0a000045 	beq	8f607e0c <smd_init+0x15c>
	dprintf(INFO, "Waiting for the RPM to populate smd channel table\n");
8f607cf4:	e3010d70 	movw	r0, #7536	; 0x1d70
8f607cf8:	e3480f70 	movt	r0, #36720	; 0x8f70
	uint64_t timeout = SMD_CHANNEL_ACCESS_RETRY;
8f607cfc:	e3044240 	movw	r4, #16960	; 0x4240
	dprintf(INFO, "Waiting for the RPM to populate smd channel table\n");
8f607d00:	eb00ab1b 	bl	8f632974 <_dprintf>
	uint64_t timeout = SMD_CHANNEL_ACCESS_RETRY;
8f607d04:	e340400f 	movt	r4, #15
8f607d08:	e3a06000 	mov	r6, #0
8f607d0c:	ea00000b 	b	8f607d40 <smd_init+0x90>
		chnl_found = smd_get_channel_info(ch, ch_type);
8f607d10:	e1a01009 	mov	r1, r9
8f607d14:	e1a00008 	mov	r0, r8
8f607d18:	ebffff08 	bl	8f607940 <smd_get_channel_info>
		timeout--;
8f607d1c:	e2544001 	subs	r4, r4, #1
8f607d20:	e2c66000 	sbc	r6, r6, #0
		chnl_found = smd_get_channel_info(ch, ch_type);
8f607d24:	e1a05000 	mov	r5, r0
		udelay(10);
8f607d28:	e3a0000a 	mov	r0, #10
8f607d2c:	eb001c0a 	bl	8f60ed5c <udelay>
	} while(timeout && chnl_found);
8f607d30:	e1843006 	orr	r3, r4, r6
8f607d34:	e3550000 	cmp	r5, #0
8f607d38:	13530000 	cmpne	r3, #0
8f607d3c:	0a000011 	beq	8f607d88 <smd_init+0xd8>
		ret = smem_read_alloc_entry(SMEM_CHANNEL_ALLOC_TBL,
8f607d40:	e5971000 	ldr	r1, [r7]
8f607d44:	e3a02b02 	mov	r2, #2048	; 0x800
8f607d48:	e3a0000d 	mov	r0, #13
8f607d4c:	ebffeab3 	bl	8f602820 <smem_read_alloc_entry>
		if(ret)
8f607d50:	e3500000 	cmp	r0, #0
8f607d54:	0affffed 	beq	8f607d10 <smd_init+0x60>
			dprintf(CRITICAL,"ERROR reading smem channel alloc tbl\n");
8f607d58:	e3010da4 	movw	r0, #7588	; 0x1da4
8f607d5c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f607d60:	eb00ab03 	bl	8f632974 <_dprintf>
			return -1;
8f607d64:	e3e00000 	mvn	r0, #0
}
8f607d68:	e59f30cc 	ldr	r3, [pc, #204]	; 8f607e3c <smd_init+0x18c>
8f607d6c:	e5932000 	ldr	r2, [r3]
8f607d70:	e59d300c 	ldr	r3, [r13, #12]
8f607d74:	e0332002 	eors	r2, r3, r2
8f607d78:	e3a03000 	mov	r3, #0
8f607d7c:	1a00002d 	bne	8f607e38 <smd_init+0x188>
8f607d80:	e28dd010 	add	r13, r13, #16
8f607d84:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
	if (!timeout)
8f607d88:	e1943006 	orrs	r3, r4, r6
8f607d8c:	0a000010 	beq	8f607dd4 <smd_init+0x124>
	register_int_handler(SMD_IRQ, smd_irq_handler, ch);
8f607d90:	e1a02008 	mov	r2, r8
8f607d94:	e3a000c8 	mov	r0, #200	; 0xc8
8f607d98:	e3071e40 	movw	r1, #32320	; 0x7e40
8f607d9c:	e3481f60 	movt	r1, #36704	; 0x8f60
8f607da0:	eb001d39 	bl	8f60f28c <register_int_handler>
	smd_set_state(ch, SMD_SS_OPENING, 1);
8f607da4:	e3a02001 	mov	r2, #1
8f607da8:	e1a01002 	mov	r1, r2
8f607dac:	e1a00008 	mov	r0, r8
8f607db0:	ebffff62 	bl	8f607b40 <smd_set_state>
	writel(BIT(0), APCS_ALIAS0_IPC_INTERRUPT);
8f607db4:	e3a03a01 	mov	r3, #4096	; 0x1000
8f607db8:	e3403b11 	movt	r3, #2833	; 0xb11
8f607dbc:	e3a02001 	mov	r2, #1
	unmask_interrupt(SMD_IRQ);
8f607dc0:	e3a000c8 	mov	r0, #200	; 0xc8
	writel(BIT(0), APCS_ALIAS0_IPC_INTERRUPT);
8f607dc4:	e5832008 	str	r2, [r3, #8]
	unmask_interrupt(SMD_IRQ);
8f607dc8:	eb001d1e 	bl	8f60f248 <unmask_interrupt>
	return 0;
8f607dcc:	e3a00000 	mov	r0, #0
8f607dd0:	eaffffe4 	b	8f607d68 <smd_init+0xb8>
		dprintf(CRITICAL, "Apps timed out waiting for RPM-->APPS channel entry\n");
8f607dd4:	e3010dcc 	movw	r0, #7628	; 0x1dcc
8f607dd8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f607ddc:	eb00aae4 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f607de0:	e307cf64 	movw	r12, #32612	; 0x7f64
8f607de4:	e3012cf8 	movw	r2, #7416	; 0x1cf8
8f607de8:	e348cf70 	movt	r12, #36720	; 0x8f70
8f607dec:	e3482f70 	movt	r2, #36720	; 0x8f70
8f607df0:	e3001130 	movw	r1, #304	; 0x130
8f607df4:	e3a03096 	mov	r3, #150	; 0x96
8f607df8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f607dfc:	e1a0000a 	mov	r0, r10
8f607e00:	e58dc000 	str	r12, [r13]
8f607e04:	eb00ab2c 	bl	8f632abc <_panic>
8f607e08:	eaffffe0 	b	8f607d90 <smd_init+0xe0>
	ASSERT(smd_channel_alloc_entry);
8f607e0c:	e3013d58 	movw	r3, #7512	; 0x1d58
8f607e10:	e3012cf8 	movw	r2, #7416	; 0x1cf8
8f607e14:	e3483f70 	movt	r3, #36720	; 0x8f70
8f607e18:	e3482f70 	movt	r2, #36720	; 0x8f70
8f607e1c:	e58d3000 	str	r3, [r13]
8f607e20:	e3001130 	movw	r1, #304	; 0x130
8f607e24:	e3a0307f 	mov	r3, #127	; 0x7f
8f607e28:	e3481f70 	movt	r1, #36720	; 0x8f70
8f607e2c:	e1a0000a 	mov	r0, r10
8f607e30:	eb00ab21 	bl	8f632abc <_panic>
8f607e34:	eaffffae 	b	8f607cf4 <smd_init+0x44>
}
8f607e38:	eb00ab60 	bl	8f632bc0 <__stack_chk_fail>
8f607e3c:	8f74221c 	.word	0x8f74221c

8f607e40 <smd_irq_handler>:
	arch_invalidate_cache_range((addr_t)smd_channel_alloc_entry,
			SMD_CHANNEL_ALLOC_MAX);
}

enum handler_return smd_irq_handler(void* data)
{
8f607e40:	e92d4030 	push	{r4, r5, r14}
8f607e44:	e24dd00c 	sub	r13, r13, #12
	smd_channel_info_t *ch = (smd_channel_info_t*)data;

	if(ch->current_state == SMD_SS_CLOSED)
8f607e48:	e5905030 	ldr	r5, [r0, #48]	; 0x30
{
8f607e4c:	e59f30e4 	ldr	r3, [pc, #228]	; 8f607f38 <smd_irq_handler+0xf8>
	if(ch->current_state == SMD_SS_CLOSED)
8f607e50:	e3550000 	cmp	r5, #0
{
8f607e54:	e5933000 	ldr	r3, [r3]
8f607e58:	e58d3004 	str	r3, [r13, #4]
8f607e5c:	e3a03000 	mov	r3, #0
	if(ch->current_state == SMD_SS_CLOSED)
8f607e60:	0a000024 	beq	8f607ef8 <smd_irq_handler+0xb8>
		}
		event_signal(&smd_closed, false);
		return INT_NO_RESCHEDULE;
	}

	if(ch->port_info->ch1.state_updated)
8f607e64:	e590302c 	ldr	r3, [r0, #44]	; 0x2c
8f607e68:	e1a04000 	mov	r4, r0
8f607e6c:	e5932048 	ldr	r2, [r3, #72]	; 0x48
		ch->port_info->ch1.state_updated = 0;

	/* Should we have to use a do while and change states until we complete */
	if(ch->current_state != ch->port_info->ch1.stream_state)
8f607e70:	e593102c 	ldr	r1, [r3, #44]	; 0x2c
	if(ch->port_info->ch1.state_updated)
8f607e74:	e3520000 	cmp	r2, #0
		ch->port_info->ch1.state_updated = 0;
8f607e78:	13a02000 	movne	r2, #0
8f607e7c:	15832048 	strne	r2, [r3, #72]	; 0x48
	if(ch->current_state != ch->port_info->ch1.stream_state)
8f607e80:	e1550001 	cmp	r5, r1
8f607e84:	1a00000a 	bne	8f607eb4 <smd_irq_handler+0x74>
	{
		smd_set_state(ch, ch->port_info->ch1.stream_state, 0);
	}

	if(ch->current_state == SMD_SS_CLOSING)
8f607e88:	e3510004 	cmp	r1, #4
8f607e8c:	0a00000d 	beq	8f607ec8 <smd_irq_handler+0x88>
		smd_notify_rpm();
		dprintf(SPEW,"Channel alloc freed\n");
	}

	return INT_NO_RESCHEDULE;
}
8f607e90:	e59f30a0 	ldr	r3, [pc, #160]	; 8f607f38 <smd_irq_handler+0xf8>
8f607e94:	e5932000 	ldr	r2, [r3]
8f607e98:	e59d3004 	ldr	r3, [r13, #4]
8f607e9c:	e0332002 	eors	r2, r3, r2
8f607ea0:	e3a03000 	mov	r3, #0
8f607ea4:	1a000022 	bne	8f607f34 <smd_irq_handler+0xf4>
8f607ea8:	e3a00000 	mov	r0, #0
8f607eac:	e28dd00c 	add	r13, r13, #12
8f607eb0:	e8bd8030 	pop	{r4, r5, r15}
		smd_set_state(ch, ch->port_info->ch1.stream_state, 0);
8f607eb4:	e3a02000 	mov	r2, #0
8f607eb8:	ebffff20 	bl	8f607b40 <smd_set_state>
	if(ch->current_state == SMD_SS_CLOSING)
8f607ebc:	e5941030 	ldr	r1, [r4, #48]	; 0x30
8f607ec0:	e3510004 	cmp	r1, #4
8f607ec4:	1afffff1 	bne	8f607e90 <smd_irq_handler+0x50>
		smd_set_state(ch, SMD_SS_CLOSED, 1);
8f607ec8:	e1a00004 	mov	r0, r4
8f607ecc:	e3a02001 	mov	r2, #1
8f607ed0:	e3a01000 	mov	r1, #0
8f607ed4:	ebffff19 	bl	8f607b40 <smd_set_state>
	writel(BIT(0), APCS_ALIAS0_IPC_INTERRUPT);
8f607ed8:	e3a03a01 	mov	r3, #4096	; 0x1000
8f607edc:	e3403b11 	movt	r3, #2833	; 0xb11
8f607ee0:	e3a02001 	mov	r2, #1
		dprintf(SPEW,"Channel alloc freed\n");
8f607ee4:	e3010e04 	movw	r0, #7684	; 0x1e04
8f607ee8:	e3480f70 	movt	r0, #36720	; 0x8f70
	writel(BIT(0), APCS_ALIAS0_IPC_INTERRUPT);
8f607eec:	e5832008 	str	r2, [r3, #8]
		dprintf(SPEW,"Channel alloc freed\n");
8f607ef0:	eb00aa9f 	bl	8f632974 <_dprintf>
8f607ef4:	eaffffe5 	b	8f607e90 <smd_irq_handler+0x50>
	arch_invalidate_cache_range((addr_t)smd_channel_alloc_entry,
8f607ef8:	e30242a0 	movw	r4, #8864	; 0x22a0
8f607efc:	e3484f74 	movt	r4, #36724	; 0x8f74
8f607f00:	e3a01b02 	mov	r1, #2048	; 0x800
8f607f04:	e5940000 	ldr	r0, [r4]
8f607f08:	eb00642e 	bl	8f620fc8 <arch_invalidate_cache_range>
		if(smd_channel_alloc_entry)
8f607f0c:	e5940000 	ldr	r0, [r4]
8f607f10:	e3500000 	cmp	r0, #0
8f607f14:	0a000001 	beq	8f607f20 <smd_irq_handler+0xe0>
			free(smd_channel_alloc_entry);
8f607f18:	eb00b07b 	bl	8f63410c <free>
			smd_channel_alloc_entry = NULL;
8f607f1c:	e5845000 	str	r5, [r4]
		event_signal(&smd_closed, false);
8f607f20:	e3a01000 	mov	r1, #0
8f607f24:	e30c0bbc 	movw	r0, #52156	; 0xcbbc
8f607f28:	e3480f72 	movt	r0, #36722	; 0x8f72
8f607f2c:	eb006b1e 	bl	8f622bac <event_signal>
		return INT_NO_RESCHEDULE;
8f607f30:	eaffffd6 	b	8f607e90 <smd_irq_handler+0x50>
}
8f607f34:	eb00ab21 	bl	8f632bc0 <__stack_chk_fail>
8f607f38:	8f74221c 	.word	0x8f74221c

8f607f3c <sdhci_reset>:
void sdhci_reset(struct sdhci_host *host, uint8_t mask)
{
	uint32_t reg;
	uint32_t timeout = SDHCI_RESET_MAX_TIMEOUT;

	REG_WRITE8(host, mask, SDHCI_RESET_REG);
8f607f3c:	e5903000 	ldr	r3, [r0]
{
8f607f40:	e59f20a8 	ldr	r2, [pc, #168]	; 8f607ff0 <sdhci_reset+0xb4>
8f607f44:	e92d4070 	push	{r4, r5, r6, r14}
8f607f48:	e24dd008 	sub	r13, r13, #8
8f607f4c:	e5922000 	ldr	r2, [r2]
8f607f50:	e58d2004 	str	r2, [r13, #4]
8f607f54:	e3a02000 	mov	r2, #0
	REG_WRITE8(host, mask, SDHCI_RESET_REG);
8f607f58:	e5c3102f 	strb	r1, [r3, #47]	; 0x2f

	/* Wait for the reset to complete */
	do {
		reg = REG_READ8(host, SDHCI_RESET_REG);
8f607f5c:	e5903000 	ldr	r3, [r0]
8f607f60:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
		reg &= mask;

		if (!reg)
8f607f64:	e1110003 	tst	r1, r3
8f607f68:	11a06000 	movne	r6, r0
8f607f6c:	11a05001 	movne	r5, r1
8f607f70:	13a04064 	movne	r4, #100	; 0x64
8f607f74:	1a000002 	bne	8f607f84 <sdhci_reset+0x48>
8f607f78:	ea000007 	b	8f607f9c <sdhci_reset+0x60>
			break;
		if (!timeout)
8f607f7c:	e2544001 	subs	r4, r4, #1
8f607f80:	0a00000d 	beq	8f607fbc <sdhci_reset+0x80>
			dprintf(CRITICAL, "Error: sdhci reset failed for: %x\n", mask);
			break;
		}

		timeout--;
		mdelay(1);
8f607f84:	e3a00001 	mov	r0, #1
8f607f88:	eb001b5b 	bl	8f60ecfc <mdelay>
		reg = REG_READ8(host, SDHCI_RESET_REG);
8f607f8c:	e5963000 	ldr	r3, [r6]
8f607f90:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
		if (!reg)
8f607f94:	e1130005 	tst	r3, r5
8f607f98:	1afffff7 	bne	8f607f7c <sdhci_reset+0x40>

	} while(1);
}
8f607f9c:	e59f304c 	ldr	r3, [pc, #76]	; 8f607ff0 <sdhci_reset+0xb4>
8f607fa0:	e5932000 	ldr	r2, [r3]
8f607fa4:	e59d3004 	ldr	r3, [r13, #4]
8f607fa8:	e0332002 	eors	r2, r3, r2
8f607fac:	e3a03000 	mov	r3, #0
8f607fb0:	1a00000d 	bne	8f607fec <sdhci_reset+0xb0>
8f607fb4:	e28dd008 	add	r13, r13, #8
8f607fb8:	e8bd8070 	pop	{r4, r5, r6, r15}
			dprintf(CRITICAL, "Error: sdhci reset failed for: %x\n", mask);
8f607fbc:	e59f302c 	ldr	r3, [pc, #44]	; 8f607ff0 <sdhci_reset+0xb4>
8f607fc0:	e5932000 	ldr	r2, [r3]
8f607fc4:	e59d3004 	ldr	r3, [r13, #4]
8f607fc8:	e0332002 	eors	r2, r3, r2
8f607fcc:	e3a03000 	mov	r3, #0
8f607fd0:	1a000005 	bne	8f607fec <sdhci_reset+0xb0>
8f607fd4:	e3010e1c 	movw	r0, #7708	; 0x1e1c
8f607fd8:	e1a01005 	mov	r1, r5
8f607fdc:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f607fe0:	e28dd008 	add	r13, r13, #8
8f607fe4:	e8bd4070 	pop	{r4, r5, r6, r14}
			dprintf(CRITICAL, "Error: sdhci reset failed for: %x\n", mask);
8f607fe8:	ea00aa61 	b	8f632974 <_dprintf>
}
8f607fec:	eb00aaf3 	bl	8f632bc0 <__stack_chk_fail>
8f607ff0:	8f74221c 	.word	0x8f74221c

8f607ff4 <sdhci_clk_supply>:
 *           2. Set the clock divider
 *           3. Check if clock stable
 *           4. Enable Clock
 */
uint32_t sdhci_clk_supply(struct sdhci_host *host, uint32_t clk)
{
8f607ff4:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f607ff8:	e24dd008 	sub	r13, r13, #8
	uint32_t div = 0;
	uint32_t freq = 0;
	uint16_t clk_val = 0;

	if (clk >= host->caps.base_clk_rate)
8f607ffc:	e590601c 	ldr	r6, [r0, #28]
{
8f608000:	e1a08000 	mov	r8, r0
8f608004:	e59f30b4 	ldr	r3, [pc, #180]	; 8f6080c0 <sdhci_clk_supply+0xcc>
8f608008:	e1a05001 	mov	r5, r1
	if (clk >= host->caps.base_clk_rate)
8f60800c:	e1560001 	cmp	r6, r1
{
8f608010:	e5933000 	ldr	r3, [r3]
8f608014:	e58d3004 	str	r3, [r13, #4]
8f608018:	e3a03000 	mov	r3, #0
	if (clk >= host->caps.base_clk_rate)
8f60801c:	93a03001 	movls	r3, #1
8f608020:	9a000010 	bls	8f608068 <sdhci_clk_supply+0x74>
		goto clk_ctrl;

	/* As per the sd spec div should be a multiplier of 2 */
	for (div = 2; div < SDHCI_CLK_MAX_DIV; div += 2) {
8f608024:	e3a04002 	mov	r4, #2
8f608028:	e30077fe 	movw	r7, #2046	; 0x7fe
8f60802c:	ea000002 	b	8f60803c <sdhci_clk_supply+0x48>
8f608030:	e2844002 	add	r4, r4, #2
8f608034:	e1540007 	cmp	r4, r7
8f608038:	0a00001d 	beq	8f6080b4 <sdhci_clk_supply+0xc0>
		freq = host->caps.base_clk_rate / div;
8f60803c:	e1a01004 	mov	r1, r4
8f608040:	e1a00006 	mov	r0, r6
8f608044:	fa00d2e3 	blx	8f63cbd8 <__udivsi3>
		if (freq <= clk)
8f608048:	e1550000 	cmp	r5, r0
8f60804c:	3afffff7 	bcc	8f608030 <sdhci_clk_supply+0x3c>
			break;
	}

	div >>= 1;
8f608050:	e1a030a4 	lsr	r3, r4, #1
	 * support a 10 bit divider value.
	 * This is needed when the divider value overflows
	 * the 8 bit range.
	 */
	clk_val = ((div & SDHCI_SDCLK_FREQ_MASK) << SDHCI_SDCLK_FREQ_SEL);
	clk_val |= ((div & SDHC_SDCLK_UP_BIT_MASK) >> SDHCI_SDCLK_FREQ_SEL)
8f608054:	e1a044a4 	lsr	r4, r4, #9
	clk_val = ((div & SDHCI_SDCLK_FREQ_MASK) << SDHCI_SDCLK_FREQ_SEL);
8f608058:	e1a03403 	lsl	r3, r3, #8
	clk_val |= ((div & SDHC_SDCLK_UP_BIT_MASK) >> SDHCI_SDCLK_FREQ_SEL)
8f60805c:	e1833304 	orr	r3, r3, r4, lsl #6
				<< SDHCI_SDCLK_UP_BIT_SEL;

	clk_val |= SDHCI_INT_CLK_EN;
8f608060:	e3833001 	orr	r3, r3, #1
8f608064:	e6ff3073 	uxth	r3, r3
	REG_WRITE16(host, clk_val, SDHCI_CLK_CTRL_REG);
8f608068:	e5981000 	ldr	r1, [r8]
8f60806c:	e281202c 	add	r2, r1, #44	; 0x2c
8f608070:	e1c132bc 	strh	r3, [r1, #44]	; 0x2c

	/* Check for clock stable */
	while (!(REG_READ16(host, SDHCI_CLK_CTRL_REG) & SDHCI_CLK_STABLE));
8f608074:	e1d230b0 	ldrh	r3, [r2]
8f608078:	e3130002 	tst	r3, #2
8f60807c:	0afffffc 	beq	8f608074 <sdhci_clk_supply+0x80>

	/* Now clock is stable, enable it */
	clk_val = REG_READ16(host, SDHCI_CLK_CTRL_REG);
8f608080:	e1d132bc 	ldrh	r3, [r1, #44]	; 0x2c
	clk_val |= SDHCI_CLK_EN;
8f608084:	e3833004 	orr	r3, r3, #4
	REG_WRITE16(host, clk_val, SDHCI_CLK_CTRL_REG);
8f608088:	e1c132bc 	strh	r3, [r1, #44]	; 0x2c
	host->cur_clk_rate = clk;

	DBG("\n %s: clock_rate: %d clock_div:0x%08x\n", __func__, clk, div);

	return 0;
}
8f60808c:	e59f302c 	ldr	r3, [pc, #44]	; 8f6080c0 <sdhci_clk_supply+0xcc>
	host->cur_clk_rate = clk;
8f608090:	e5885004 	str	r5, [r8, #4]
}
8f608094:	e5932000 	ldr	r2, [r3]
8f608098:	e59d3004 	ldr	r3, [r13, #4]
8f60809c:	e0332002 	eors	r2, r3, r2
8f6080a0:	e3a03000 	mov	r3, #0
8f6080a4:	1a000004 	bne	8f6080bc <sdhci_clk_supply+0xc8>
8f6080a8:	e3a00000 	mov	r0, #0
8f6080ac:	e28dd008 	add	r13, r13, #8
8f6080b0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
8f6080b4:	e30f3fc1 	movw	r3, #65473	; 0xffc1
8f6080b8:	eaffffea 	b	8f608068 <sdhci_clk_supply+0x74>
8f6080bc:	eb00aabf 	bl	8f632bc0 <__stack_chk_fail>
8f6080c0:	8f74221c 	.word	0x8f74221c

8f6080c4 <sdhci_set_uhs_mode>:
 * Details : SDR50/SDR104 mode is nothing but HS200
 *			 mode SDCC spec refers to it as SDR mode
 *			 & emmc spec refers as HS200 mode.
 */
void sdhci_set_uhs_mode(struct sdhci_host *host, uint32_t mode)
{
8f6080c4:	e59f3118 	ldr	r3, [pc, #280]	; 8f6081e4 <sdhci_set_uhs_mode+0x120>
	uint16_t ctrl = 0;
	uint32_t clk_val = 0;

	/* Disable the clock */
	clk = REG_READ16(host, SDHCI_CLK_CTRL_REG);
	clk &= ~SDHCI_CLK_EN;
8f6080c8:	e30f2ffb 	movw	r2, #65531	; 0xfffb
{
8f6080cc:	e92d4070 	push	{r4, r5, r6, r14}
8f6080d0:	e24dd010 	sub	r13, r13, #16
8f6080d4:	e5933000 	ldr	r3, [r3]
8f6080d8:	e58d300c 	str	r3, [r13, #12]
8f6080dc:	e3a03000 	mov	r3, #0
	clk = REG_READ16(host, SDHCI_CLK_CTRL_REG);
8f6080e0:	e5903000 	ldr	r3, [r0]
{
8f6080e4:	e1a05000 	mov	r5, r0
	REG_WRITE16(host, clk, SDHCI_CLK_CTRL_REG);

	ctrl = REG_READ16(host, SDHCI_HOST_CTRL2_REG);

	ctrl &= ~SDHCI_UHS_MODE_MASK;
8f6080e8:	e30f4ff8 	movw	r4, #65528	; 0xfff8
	clk = REG_READ16(host, SDHCI_CLK_CTRL_REG);
8f6080ec:	e1d302bc 	ldrh	r0, [r3, #44]	; 0x2c
	clk &= ~SDHCI_CLK_EN;
8f6080f0:	e0022000 	and	r2, r2, r0
	REG_WRITE16(host, clk, SDHCI_CLK_CTRL_REG);
8f6080f4:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
	ctrl = REG_READ16(host, SDHCI_HOST_CTRL2_REG);
8f6080f8:	e283203e 	add	r2, r3, #62	; 0x3e
8f6080fc:	e1d333be 	ldrh	r3, [r3, #62]	; 0x3e
	ctrl &= ~SDHCI_UHS_MODE_MASK;
8f608100:	e0044003 	and	r4, r4, r3

	/* Enable SDR50/SDR104/DDR50 mode */
	switch (mode)
8f608104:	e3510004 	cmp	r1, #4
8f608108:	979ff101 	ldrls	r15, [r15, r1, lsl #2]
8f60810c:	ea000022 	b	8f60819c <sdhci_set_uhs_mode+0xd8>
8f608110:	8f608124 	.word	0x8f608124
8f608114:	8f608168 	.word	0x8f608168
8f608118:	8f608178 	.word	0x8f608178
8f60811c:	8f608188 	.word	0x8f608188
8f608120:	8f608158 	.word	0x8f608158
8f608124:	e3071840 	movw	r1, #30784	; 0x7840
8f608128:	e340117d 	movt	r1, #381	; 0x17d
	};

	REG_WRITE16(host, ctrl, SDHCI_HOST_CTRL2_REG);

	/* Run the clock back */
	sdhci_clk_supply(host, clk_val);
8f60812c:	e59f30b0 	ldr	r3, [pc, #176]	; 8f6081e4 <sdhci_set_uhs_mode+0x120>
	REG_WRITE16(host, ctrl, SDHCI_HOST_CTRL2_REG);
8f608130:	e1c240b0 	strh	r4, [r2]
	sdhci_clk_supply(host, clk_val);
8f608134:	e5932000 	ldr	r2, [r3]
8f608138:	e59d300c 	ldr	r3, [r13, #12]
8f60813c:	e0332002 	eors	r2, r3, r2
8f608140:	e3a03000 	mov	r3, #0
8f608144:	1a000013 	bne	8f608198 <sdhci_set_uhs_mode+0xd4>
8f608148:	e1a00005 	mov	r0, r5
}
8f60814c:	e28dd010 	add	r13, r13, #16
8f608150:	e8bd4070 	pop	{r4, r5, r6, r14}
	sdhci_clk_supply(host, clk_val);
8f608154:	eaffffa6 	b	8f607ff4 <sdhci_clk_supply>
			clk_val = SDHCI_CLK_50MHZ;
8f608158:	e30f1080 	movw	r1, #61568	; 0xf080
			ctrl |= SDHCI_DDR50_MODE_EN;
8f60815c:	e3844004 	orr	r4, r4, #4
			clk_val = SDHCI_CLK_50MHZ;
8f608160:	e34012fa 	movt	r1, #762	; 0x2fa
			break;
8f608164:	eafffff0 	b	8f60812c <sdhci_set_uhs_mode+0x68>
			clk_val = SDHCI_CLK_50MHZ;
8f608168:	e30f1080 	movw	r1, #61568	; 0xf080
			ctrl |= SDHCI_SDR25_MODE_EN;
8f60816c:	e3844001 	orr	r4, r4, #1
			clk_val = SDHCI_CLK_50MHZ;
8f608170:	e34012fa 	movt	r1, #762	; 0x2fa
			break;
8f608174:	eaffffec 	b	8f60812c <sdhci_set_uhs_mode+0x68>
			clk_val = SDHCI_CLK_100MHZ;
8f608178:	e3a01ce1 	mov	r1, #57600	; 0xe100
			ctrl |= SDHCI_SDR50_MODE_EN;
8f60817c:	e3844002 	orr	r4, r4, #2
			clk_val = SDHCI_CLK_100MHZ;
8f608180:	e34015f5 	movt	r1, #1525	; 0x5f5
			break;
8f608184:	eaffffe8 	b	8f60812c <sdhci_set_uhs_mode+0x68>
			clk_val = SDHCI_CLK_200MHZ;
8f608188:	e3a01cc2 	mov	r1, #49664	; 0xc200
			ctrl |= SDHCI_SDR104_MODE_EN;
8f60818c:	e3844003 	orr	r4, r4, #3
			clk_val = SDHCI_CLK_200MHZ;
8f608190:	e3401beb 	movt	r1, #3051	; 0xbeb
			break;
8f608194:	eaffffe4 	b	8f60812c <sdhci_set_uhs_mode+0x68>
	sdhci_clk_supply(host, clk_val);
8f608198:	eb00aa88 	bl	8f632bc0 <__stack_chk_fail>
8f60819c:	e1a0600e 	mov	r6, r14
			dprintf(CRITICAL, "Error: Invalid UHS mode: %x\n", mode);
8f6081a0:	e3010e40 	movw	r0, #7744	; 0x1e40
8f6081a4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6081a8:	eb00a9f1 	bl	8f632974 <_dprintf>
			ASSERT(0);
8f6081ac:	e3072f64 	movw	r2, #32612	; 0x7f64
8f6081b0:	e300313d 	movw	r3, #317	; 0x13d
8f6081b4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6081b8:	e1a00006 	mov	r0, r6
8f6081bc:	e58d2000 	str	r2, [r13]
8f6081c0:	e3001130 	movw	r1, #304	; 0x130
8f6081c4:	e3012e60 	movw	r2, #7776	; 0x1e60
8f6081c8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6081cc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6081d0:	eb00aa39 	bl	8f632abc <_panic>
	REG_WRITE16(host, ctrl, SDHCI_HOST_CTRL2_REG);
8f6081d4:	e5952000 	ldr	r2, [r5]
	uint32_t clk_val = 0;
8f6081d8:	e3a01000 	mov	r1, #0
	REG_WRITE16(host, ctrl, SDHCI_HOST_CTRL2_REG);
8f6081dc:	e282203e 	add	r2, r2, #62	; 0x3e
8f6081e0:	eaffffd1 	b	8f60812c <sdhci_set_uhs_mode+0x68>
8f6081e4:	8f74221c 	.word	0x8f74221c

8f6081e8 <sdhci_set_bus_width>:
 * Arg     : Host & width
 * Return  : 0 on Sucess, 1 on Failure
 * Flow:   : Set the bus width for controller
 */
uint8_t sdhci_set_bus_width(struct sdhci_host *host, uint16_t width)
{
8f6081e8:	e59f3078 	ldr	r3, [pc, #120]	; 8f608268 <sdhci_set_bus_width+0x80>
8f6081ec:	e3510002 	cmp	r1, #2
8f6081f0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6081f4:	e24dd00c 	sub	r13, r13, #12
	uint16_t reg = 0;

	reg = REG_READ8(host, SDHCI_HOST_CTRL1_REG);
8f6081f8:	e590c000 	ldr	r12, [r0]
{
8f6081fc:	e5933000 	ldr	r3, [r3]
8f608200:	e58d3004 	str	r3, [r13, #4]
8f608204:	e3a03000 	mov	r3, #0
	reg = REG_READ8(host, SDHCI_HOST_CTRL1_REG);
8f608208:	e5dc3028 	ldrb	r3, [r12, #40]	; 0x28

	switch(width) {
8f60820c:	8a00000f 	bhi	8f608250 <sdhci_set_bus_width+0x68>
8f608210:	e1a02001 	mov	r2, r1
			return 1;
	}

	DBG("\n %s: bus width:0x%04x\n", __func__, width);

	REG_WRITE8(host, (reg | width), SDHCI_HOST_CTRL1_REG);
8f608214:	e302109c 	movw	r1, #8348	; 0x209c
8f608218:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60821c:	e6ef3073 	uxtb	r3, r3

	return 0;
8f608220:	e3a00000 	mov	r0, #0
	REG_WRITE8(host, (reg | width), SDHCI_HOST_CTRL1_REG);
8f608224:	e7d12082 	ldrb	r2, [r1, r2, lsl #1]
8f608228:	e1833002 	orr	r3, r3, r2
8f60822c:	e5cc3028 	strb	r3, [r12, #40]	; 0x28
}
8f608230:	e59f3030 	ldr	r3, [pc, #48]	; 8f608268 <sdhci_set_bus_width+0x80>
8f608234:	e5932000 	ldr	r2, [r3]
8f608238:	e59d3004 	ldr	r3, [r13, #4]
8f60823c:	e0332002 	eors	r2, r3, r2
8f608240:	e3a03000 	mov	r3, #0
8f608244:	1a000006 	bne	8f608264 <sdhci_set_bus_width+0x7c>
8f608248:	e28dd00c 	add	r13, r13, #12
8f60824c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
			dprintf(CRITICAL, "Bus width is invalid: %u\n", width);
8f608250:	e3010e7c 	movw	r0, #7804	; 0x1e7c
8f608254:	e3480f70 	movt	r0, #36720	; 0x8f70
8f608258:	eb00a9c5 	bl	8f632974 <_dprintf>
			return 1;
8f60825c:	e3a00001 	mov	r0, #1
8f608260:	eafffff2 	b	8f608230 <sdhci_set_bus_width+0x48>
}
8f608264:	eb00aa55 	bl	8f632bc0 <__stack_chk_fail>
8f608268:	8f74221c 	.word	0x8f74221c

8f60826c <sdhci_send_command>:
 *           2. If data is present, prepare adma table
 *           3. Run the command
 *           4. Check for command results & take action
 */
uint32_t sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
{
8f60826c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f608270:	e24dd024 	sub	r13, r13, #36	; 0x24
	struct desc_entry *sg_list = NULL;

	DBG("\n %s: START: cmd:%04d, arg:0x%08x, resp_type:0x%04x, data_present:%d\n",
				__func__, cmd->cmd_index, cmd->argument, cmd->resp_type, cmd->data_present);

	if (cmd->data_present)
8f608274:	e5d13008 	ldrb	r3, [r1, #8]
{
8f608278:	e1a06001 	mov	r6, r1
8f60827c:	e59f29ac 	ldr	r2, [pc, #2476]	; 8f608c30 <sdhci_send_command+0x9c4>
8f608280:	e1a0800e 	mov	r8, r14
	if (cmd->data_present)
8f608284:	e3530000 	cmp	r3, #0
{
8f608288:	e1a05000 	mov	r5, r0
8f60828c:	e5922000 	ldr	r2, [r2]
8f608290:	e58d201c 	str	r2, [r13, #28]
8f608294:	e3a02000 	mov	r2, #0
	if (cmd->data_present)
8f608298:	0a000002 	beq	8f6082a8 <sdhci_send_command+0x3c>
		ASSERT(cmd->data.data_ptr);
8f60829c:	e5913034 	ldr	r3, [r1, #52]	; 0x34
8f6082a0:	e3530000 	cmp	r3, #0
8f6082a4:	0a0000ad 	beq	8f608560 <sdhci_send_command+0x2f4>
	 * the cache is already flushed by the caller. As
	 * the data buffer we receive for write operation
	 * may not be aligned to cache boundary due to
	 * certain image formats like sparse image.
	 */
	if (cmd->trans_mode == SDHCI_READ_MODE)
8f6082a8:	e596301c 	ldr	r3, [r6, #28]
8f6082ac:	e3530010 	cmp	r3, #16
8f6082b0:	0a00002f 	beq	8f608374 <sdhci_send_command+0x108>
{
8f6082b4:	e3a0700a 	mov	r7, #10
		ASSERT(IS_CACHE_LINE_ALIGNED(cmd->data.data_ptr));

	do {
		present_state = REG_READ32(host, SDHCI_PRESENT_STATE_REG);
8f6082b8:	e5953000 	ldr	r3, [r5]
8f6082bc:	e5934024 	ldr	r4, [r3, #36]	; 0x24
		/* check if CMD & DAT lines are free */
		present_state &= SDHCI_STATE_CMD_DAT_MASK;

		if (!present_state)
8f6082c0:	e2144003 	ands	r4, r4, #3
8f6082c4:	0a000011 	beq	8f608310 <sdhci_send_command+0xa4>
			break;
		udelay(1000);
		retry++;
		if (retry == 10) {
8f6082c8:	e2477001 	sub	r7, r7, #1
		udelay(1000);
8f6082cc:	e3a00ffa 	mov	r0, #1000	; 0x3e8
8f6082d0:	eb001aa1 	bl	8f60ed5c <udelay>
		if (retry == 10) {
8f6082d4:	e21770ff 	ands	r7, r7, #255	; 0xff
8f6082d8:	1afffff6 	bne	8f6082b8 <sdhci_send_command+0x4c>
			dprintf(CRITICAL, "Error: CMD or DAT lines were never freed\n");
8f6082dc:	e3010ed8 	movw	r0, #7896	; 0x1ed8
8f6082e0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6082e4:	eb00a9a2 	bl	8f632974 <_dprintf>
			return 1;
8f6082e8:	e3a04001 	mov	r4, #1
	/* Free the scatter/gather list */
	if (sg_list)
		free(sg_list);

	return ret;
}
8f6082ec:	e59f393c 	ldr	r3, [pc, #2364]	; 8f608c30 <sdhci_send_command+0x9c4>
8f6082f0:	e5932000 	ldr	r2, [r3]
8f6082f4:	e59d301c 	ldr	r3, [r13, #28]
8f6082f8:	e0332002 	eors	r2, r3, r2
8f6082fc:	e3a03000 	mov	r3, #0
8f608300:	1a000228 	bne	8f608ba8 <sdhci_send_command+0x93c>
8f608304:	e1a00004 	mov	r0, r4
8f608308:	e28dd024 	add	r13, r13, #36	; 0x24
8f60830c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	switch(cmd->resp_type) {
8f608310:	e1d620ba 	ldrh	r2, [r6, #10]
8f608314:	e3520008 	cmp	r2, #8
8f608318:	8a00000b 	bhi	8f60834c <sdhci_send_command+0xe0>
8f60831c:	e3520008 	cmp	r2, #8
8f608320:	979ff102 	ldrls	r15, [r15, r2, lsl #2]
8f608324:	ea00000d 	b	8f608360 <sdhci_send_command+0xf4>
8f608328:	8f6083ac 	.word	0x8f6083ac
8f60832c:	8f6088bc 	.word	0x8f6088bc
8f608330:	8f608544 	.word	0x8f608544
8f608334:	8f608360 	.word	0x8f608360
8f608338:	8f608528 	.word	0x8f608528
8f60833c:	8f608360 	.word	0x8f608360
8f608340:	8f608360 	.word	0x8f608360
8f608344:	8f608360 	.word	0x8f608360
8f608348:	8f6088bc 	.word	0x8f6088bc
8f60834c:	e2422040 	sub	r2, r2, #64	; 0x40
8f608350:	e3c21040 	bic	r1, r2, #64	; 0x40
8f608354:	e6ff1071 	uxth	r1, r1
8f608358:	e3510000 	cmp	r1, #0
8f60835c:	0a00017c 	beq	8f608954 <sdhci_send_command+0x6e8>
			dprintf(CRITICAL, "Invalid response type for the command\n");
8f608360:	e3010f04 	movw	r0, #7940	; 0x1f04
8f608364:	e3480f70 	movt	r0, #36720	; 0x8f70
8f608368:	eb00a981 	bl	8f632974 <_dprintf>
			return 1;
8f60836c:	e3a04001 	mov	r4, #1
8f608370:	eaffffdd 	b	8f6082ec <sdhci_send_command+0x80>
		ASSERT(IS_CACHE_LINE_ALIGNED(cmd->data.data_ptr));
8f608374:	e5963034 	ldr	r3, [r6, #52]	; 0x34
8f608378:	e313003f 	tst	r3, #63	; 0x3f
8f60837c:	0affffcc 	beq	8f6082b4 <sdhci_send_command+0x48>
8f608380:	e3011eac 	movw	r1, #7852	; 0x1eac
8f608384:	e3012e60 	movw	r2, #7776	; 0x1e60
8f608388:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60838c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f608390:	e58d1000 	str	r1, [r13]
8f608394:	e3a03fc1 	mov	r3, #772	; 0x304
8f608398:	e3001130 	movw	r1, #304	; 0x130
8f60839c:	e1a00008 	mov	r0, r8
8f6083a0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6083a4:	eb00a9c4 	bl	8f632abc <_panic>
8f6083a8:	eaffffc1 	b	8f6082b4 <sdhci_send_command+0x48>
	flags |= (cmd->cmd_type << SDHCI_CMD_CMD_TYPE_BIT);
8f6083ac:	e5d67009 	ldrb	r7, [r6, #9]
	flags |= (cmd->data_present << SDHCI_CMD_DATA_PRESENT_BIT);
8f6083b0:	e5d62008 	ldrb	r2, [r6, #8]
	flags |= (cmd->cmd_type << SDHCI_CMD_CMD_TYPE_BIT);
8f6083b4:	e1a07307 	lsl	r7, r7, #6
8f6083b8:	e1877282 	orr	r7, r7, r2, lsl #5
	REG_WRITE8(host, SDHCI_CMD_TIMEOUT, SDHCI_TIMEOUT_REG);
8f6083bc:	e3a0200f 	mov	r2, #15
8f6083c0:	e5c3202e 	strb	r2, [r3, #46]	; 0x2e
	if (cmd->data_present)
8f6083c4:	e5d69008 	ldrb	r9, [r6, #8]
8f6083c8:	e3590000 	cmp	r9, #0
8f6083cc:	1a000084 	bne	8f6085e4 <sdhci_send_command+0x378>
	REG_WRITE32(host, cmd->argument, SDHCI_ARGUMENT_REG);
8f6083d0:	e5953000 	ldr	r3, [r5]
8f6083d4:	e5962004 	ldr	r2, [r6, #4]
8f6083d8:	e5832008 	str	r2, [r3, #8]
	if (cmd->data_present)
8f6083dc:	e5d63008 	ldrb	r3, [r6, #8]
8f6083e0:	e3530000 	cmp	r3, #0
8f6083e4:	0a00000f 	beq	8f608428 <sdhci_send_command+0x1bc>
		if (cmd->trans_mode == SDHCI_MMC_READ)
8f6083e8:	e596101c 	ldr	r1, [r6, #28]
8f6083ec:	e3510001 	cmp	r1, #1
8f6083f0:	1a0000f8 	bne	8f6087d8 <sdhci_send_command+0x56c>
			if(cmd->cmd_index == CMD21_SEND_TUNING_BLOCK)
8f6083f4:	e1d630b0 	ldrh	r3, [r6]
				sdhci_msm_toggle_cdr(host, true);
8f6083f8:	e1a00005 	mov	r0, r5
			trans_mode |= SDHCI_READ_MODE;
8f6083fc:	e3a04011 	mov	r4, #17
			if(cmd->cmd_index == CMD21_SEND_TUNING_BLOCK)
8f608400:	e3530015 	cmp	r3, #21
				sdhci_msm_toggle_cdr(host, false);
8f608404:	03a01000 	moveq	r1, #0
				sdhci_msm_toggle_cdr(host, true);
8f608408:	eb000404 	bl	8f609420 <sdhci_msm_toggle_cdr>
		if ((cmd->data.num_blocks > 1) && !cmd->rel_write) {
8f60840c:	e596303c 	ldr	r3, [r6, #60]	; 0x3c
8f608410:	e3530001 	cmp	r3, #1
8f608414:	9a000003 	bls	8f608428 <sdhci_send_command+0x1bc>
8f608418:	e5d62040 	ldrb	r2, [r6, #64]	; 0x40
8f60841c:	e3520000 	cmp	r2, #0
			trans_mode |= SDHCI_TRANS_MULTI | SDHCI_BLK_CNT_EN;
8f608420:	13844022 	orrne	r4, r4, #34	; 0x22
		if ((cmd->data.num_blocks > 1) && !cmd->rel_write) {
8f608424:	0a000130 	beq	8f6088ec <sdhci_send_command+0x680>
	REG_WRITE16(host, trans_mode, SDHCI_TRANS_MODE_REG);
8f608428:	e5953000 	ldr	r3, [r5]
	REG_WRITE16(host, SDHCI_PREP_CMD(cmd->cmd_index, flags), SDHCI_CMD_REG);
8f60842c:	e6ef2077 	uxtb	r2, r7
	uint64_t max_trans_retry = (cmd->cmd_timeout ? cmd->cmd_timeout : SDHCI_MAX_TRANS_RETRY);
8f608430:	e596802c 	ldr	r8, [r6, #44]	; 0x2c
8f608434:	e3a0a000 	mov	r10, #0
	REG_WRITE16(host, trans_mode, SDHCI_TRANS_MODE_REG);
8f608438:	e1c340bc 	strh	r4, [r3, #12]
		if (retry == SDHCI_MAX_CMD_RETRY) {
8f60843c:	e3054440 	movw	r4, #21568	; 0x5440
	REG_WRITE16(host, SDHCI_PREP_CMD(cmd->cmd_index, flags), SDHCI_CMD_REG);
8f608440:	e1d670b0 	ldrh	r7, [r6]
		if (retry == SDHCI_MAX_CMD_RETRY) {
8f608444:	e3404089 	movt	r4, #137	; 0x89
	REG_WRITE16(host, SDHCI_PREP_CMD(cmd->cmd_index, flags), SDHCI_CMD_REG);
8f608448:	e1822407 	orr	r2, r2, r7, lsl #8
	uint64_t max_trans_retry = (cmd->cmd_timeout ? cmd->cmd_timeout : SDHCI_MAX_TRANS_RETRY);
8f60844c:	e5967028 	ldr	r7, [r6, #40]	; 0x28
	REG_WRITE16(host, SDHCI_PREP_CMD(cmd->cmd_index, flags), SDHCI_CMD_REG);
8f608450:	e6ff2072 	uxth	r2, r2
8f608454:	e1c320be 	strh	r2, [r3, #14]
	uint64_t max_trans_retry = (cmd->cmd_timeout ? cmd->cmd_timeout : SDHCI_MAX_TRANS_RETRY);
8f608458:	e1972008 	orrs	r2, r7, r8
8f60845c:	03097680 	movweq	r7, #38528	; 0x9680
8f608460:	03a08000 	moveq	r8, #0
8f608464:	03407098 	movteq	r7, #152	; 0x98
8f608468:	ea00000a 	b	8f608498 <sdhci_send_command+0x22c>
		if (host->tuning_in_progress)
8f60846c:	e3520000 	cmp	r2, #0
8f608470:	0a000002 	beq	8f608480 <sdhci_send_command+0x214>
			err_status = REG_READ16(host, SDHCI_ERR_INT_STS_REG);
8f608474:	e1d323b2 	ldrh	r2, [r3, #50]	; 0x32
			if ((err_status & SDHCI_CMD_CRC_MASK) || (err_status & SDHCI_CMD_END_BIT_MASK)
8f608478:	e312000f 	tst	r2, #15
8f60847c:	1a000042 	bne	8f60858c <sdhci_send_command+0x320>
		if (retry == SDHCI_MAX_CMD_RETRY) {
8f608480:	e28aa001 	add	r10, r10, #1
		udelay(1);
8f608484:	e3a00001 	mov	r0, #1
8f608488:	eb001a33 	bl	8f60ed5c <udelay>
		if (retry == SDHCI_MAX_CMD_RETRY) {
8f60848c:	e15a0004 	cmp	r10, r4
8f608490:	0a0000d5 	beq	8f6087ec <sdhci_send_command+0x580>
		int_status = REG_READ16(host, SDHCI_NRML_INT_STS_REG);
8f608494:	e5953000 	ldr	r3, [r5]
8f608498:	e1d323b0 	ldrh	r2, [r3, #48]	; 0x30
8f60849c:	e2831030 	add	r1, r3, #48	; 0x30
		if((int_status  & SDHCI_INT_STS_CMD_COMPLETE) &&
8f6084a0:	e3120001 	tst	r2, #1
		int_status = REG_READ16(host, SDHCI_NRML_INT_STS_REG);
8f6084a4:	e6ff2072 	uxth	r2, r2
		if((int_status  & SDHCI_INT_STS_CMD_COMPLETE) &&
8f6084a8:	0a000003 	beq	8f6084bc <sdhci_send_command+0x250>
			!(REG_READ16(host, SDHCI_ERR_INT_STS_REG) & SDHCI_CMD_TIMEOUT_MASK))
8f6084ac:	e1d303b2 	ldrh	r0, [r3, #50]	; 0x32
8f6084b0:	e283c032 	add	r12, r3, #50	; 0x32
		if((int_status  & SDHCI_INT_STS_CMD_COMPLETE) &&
8f6084b4:	e3100001 	tst	r0, #1
8f6084b8:	0a000098 	beq	8f608720 <sdhci_send_command+0x4b4>
		else if (int_status & SDHCI_ERR_INT_STAT_MASK && !host->tuning_in_progress &&
8f6084bc:	e3120902 	tst	r2, #32768	; 0x8000
8f6084c0:	e595200c 	ldr	r2, [r5, #12]
8f6084c4:	0affffe8 	beq	8f60846c <sdhci_send_command+0x200>
8f6084c8:	e3520000 	cmp	r2, #0
8f6084cc:	1affffe8 	bne	8f608474 <sdhci_send_command+0x208>
				!((REG_READ16(host, SDHCI_ERR_INT_STS_REG) & SDHCI_DAT_TIMEOUT_MASK)))
8f6084d0:	e1d323b2 	ldrh	r2, [r3, #50]	; 0x32
8f6084d4:	e2833032 	add	r3, r3, #50	; 0x32
		else if (int_status & SDHCI_ERR_INT_STAT_MASK && !host->tuning_in_progress &&
8f6084d8:	e3120010 	tst	r2, #16
8f6084dc:	1affffe7 	bne	8f608480 <sdhci_send_command+0x214>
	int_status = REG_READ16(host, SDHCI_NRML_INT_STS_REG);
8f6084e0:	e1d120b0 	ldrh	r2, [r1]
	if (int_status & SDHCI_ERR_INT_STAT_MASK)
8f6084e4:	e3120902 	tst	r2, #32768	; 0x8000
		if ((REG_READ16(host, SDHCI_ERR_INT_STS_REG) & SDHCI_DAT_TIMEOUT_MASK) && trans_complete)
8f6084e8:	11a0c003 	movne	r12, r3
8f6084ec:	13a07000 	movne	r7, #0
	if (int_status & SDHCI_ERR_INT_STAT_MASK)
8f6084f0:	1a0000c6 	bne	8f608810 <sdhci_send_command+0x5a4>
	if (cmd->trans_mode == SDHCI_MMC_READ)
8f6084f4:	e596301c 	ldr	r3, [r6, #28]
8f6084f8:	e3530001 	cmp	r3, #1
8f6084fc:	1a000007 	bne	8f608520 <sdhci_send_command+0x2b4>
		arch_invalidate_cache_range((addr_t)cmd->data.data_ptr, (cmd->data.blk_sz) ? \
8f608500:	e5963038 	ldr	r3, [r6, #56]	; 0x38
8f608504:	e5960034 	ldr	r0, [r6, #52]	; 0x34
8f608508:	e3530000 	cmp	r3, #0
8f60850c:	1596103c 	ldrne	r1, [r6, #60]	; 0x3c
8f608510:	0596303c 	ldreq	r3, [r6, #60]	; 0x3c
8f608514:	10010391 	mulne	r1, r1, r3
8f608518:	01a01483 	lsleq	r1, r3, #9
8f60851c:	eb0062a9 	bl	8f620fc8 <arch_invalidate_cache_range>
	uint32_t ret = 0;
8f608520:	e3a04000 	mov	r4, #0
8f608524:	ea000029 	b	8f6085d0 <sdhci_send_command+0x364>
	flags |= (cmd->cmd_type << SDHCI_CMD_CMD_TYPE_BIT);
8f608528:	e5d67009 	ldrb	r7, [r6, #9]
	flags |= (cmd->data_present << SDHCI_CMD_DATA_PRESENT_BIT);
8f60852c:	e5d62008 	ldrb	r2, [r6, #8]
	flags |= (cmd->cmd_type << SDHCI_CMD_CMD_TYPE_BIT);
8f608530:	e1a07307 	lsl	r7, r7, #6
8f608534:	e1877282 	orr	r7, r7, r2, lsl #5
8f608538:	e3877001 	orr	r7, r7, #1
			flags |= (1 << SDHCI_CMD_CRC_CHECK_BIT);
8f60853c:	e3877008 	orr	r7, r7, #8
			break;
8f608540:	eaffff9d 	b	8f6083bc <sdhci_send_command+0x150>
	flags |= (cmd->cmd_type << SDHCI_CMD_CMD_TYPE_BIT);
8f608544:	e5d67009 	ldrb	r7, [r6, #9]
	flags |= (cmd->data_present << SDHCI_CMD_DATA_PRESENT_BIT);
8f608548:	e5d62008 	ldrb	r2, [r6, #8]
	flags |= (cmd->cmd_type << SDHCI_CMD_CMD_TYPE_BIT);
8f60854c:	e1a07307 	lsl	r7, r7, #6
8f608550:	e1877282 	orr	r7, r7, r2, lsl #5
8f608554:	e3877003 	orr	r7, r7, #3
			flags |= (1 << SDHCI_CMD_CRC_CHECK_BIT) | (1 << SDHCI_CMD_IDX_CHECK_BIT);
8f608558:	e3877018 	orr	r7, r7, #24
			break;
8f60855c:	eaffff96 	b	8f6083bc <sdhci_send_command+0x150>
		ASSERT(cmd->data.data_ptr);
8f608560:	e3011e98 	movw	r1, #7832	; 0x1e98
8f608564:	e3012e60 	movw	r2, #7776	; 0x1e60
8f608568:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60856c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f608570:	e58d1000 	str	r1, [r13]
8f608574:	e3a03fbe 	mov	r3, #760	; 0x2f8
8f608578:	e3001130 	movw	r1, #304	; 0x130
8f60857c:	e1a0000e 	mov	r0, r14
8f608580:	e3481f70 	movt	r1, #36720	; 0x8f70
8f608584:	eb00a94c 	bl	8f632abc <_panic>
8f608588:	eaffff46 	b	8f6082a8 <sdhci_send_command+0x3c>
	REG_WRITE8(host, mask, SDHCI_RESET_REG);
8f60858c:	e3a02006 	mov	r2, #6
8f608590:	e5c3202f 	strb	r2, [r3, #47]	; 0x2f
		reg = REG_READ8(host, SDHCI_RESET_REG);
8f608594:	e5953000 	ldr	r3, [r5]
8f608598:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
		if (!reg)
8f60859c:	e1130002 	tst	r3, r2
8f6085a0:	13a04064 	movne	r4, #100	; 0x64
8f6085a4:	1a000002 	bne	8f6085b4 <sdhci_send_command+0x348>
8f6085a8:	ea000007 	b	8f6085cc <sdhci_send_command+0x360>
		if (!timeout)
8f6085ac:	e2544001 	subs	r4, r4, #1
8f6085b0:	0a00012b 	beq	8f608a64 <sdhci_send_command+0x7f8>
		mdelay(1);
8f6085b4:	e3a00001 	mov	r0, #1
8f6085b8:	eb0019cf 	bl	8f60ecfc <mdelay>
		reg = REG_READ8(host, SDHCI_RESET_REG);
8f6085bc:	e5953000 	ldr	r3, [r5]
8f6085c0:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
		if (!reg)
8f6085c4:	e3130006 	tst	r3, #6
8f6085c8:	1afffff7 	bne	8f6085ac <sdhci_send_command+0x340>
		ret = 1;
8f6085cc:	e3a04001 	mov	r4, #1
	if (sg_list)
8f6085d0:	e3590000 	cmp	r9, #0
8f6085d4:	0affff44 	beq	8f6082ec <sdhci_send_command+0x80>
		free(sg_list);
8f6085d8:	e1a00009 	mov	r0, r9
8f6085dc:	eb00aeca 	bl	8f63410c <free>
8f6085e0:	eaffff41 	b	8f6082ec <sdhci_send_command+0x80>
	if (cmd->data.blk_sz)
8f6085e4:	e596a038 	ldr	r10, [r6, #56]	; 0x38
	num_blks = cmd->data.num_blocks;
8f6085e8:	e596303c 	ldr	r3, [r6, #60]	; 0x3c
	if (cmd->data.blk_sz)
8f6085ec:	e35a0000 	cmp	r10, #0
	data = cmd->data.data_ptr;
8f6085f0:	e5962034 	ldr	r2, [r6, #52]	; 0x34
		sz = num_blks * cmd->data.blk_sz;
8f6085f4:	100a039a 	mulne	r10, r10, r3
	num_blks = cmd->data.num_blocks;
8f6085f8:	e58d3008 	str	r3, [r13, #8]
		sz = num_blks * SDHCI_MMC_BLK_SZ;
8f6085fc:	059d3008 	ldreq	r3, [r13, #8]
	data = cmd->data.data_ptr;
8f608600:	e58d200c 	str	r2, [r13, #12]
		sz = num_blks * SDHCI_MMC_BLK_SZ;
8f608604:	01a0a483 	lsleq	r10, r3, #9
	if (len <= SDHCI_ADMA_DESC_LINE_SZ) {
8f608608:	e35a0801 	cmp	r10, #65536	; 0x10000
8f60860c:	9a0000da 	bls	8f60897c <sdhci_send_command+0x710>
		if (remain)
8f608610:	e6ff307a 	uxth	r3, r10
8f608614:	e3530000 	cmp	r3, #0
		sg_len = len / SDHCI_ADMA_DESC_LINE_SZ;
8f608618:	e1a0382a 	lsr	r3, r10, #16
8f60861c:	e58d3010 	str	r3, [r13, #16]
		if (remain)
8f608620:	1a0000b8 	bne	8f608908 <sdhci_send_command+0x69c>
		table_len = (sg_len * sizeof(struct desc_entry));
8f608624:	e59d3010 	ldr	r3, [r13, #16]
		sg_list = (struct desc_entry *) memalign(lcm(4, CACHE_LINE), ROUNDUP(table_len, CACHE_LINE));
8f608628:	e3a01040 	mov	r1, #64	; 0x40
8f60862c:	e3a00004 	mov	r0, #4
		table_len = (sg_len * sizeof(struct desc_entry));
8f608630:	e1a0b183 	lsl	r11, r3, #3
		sg_list = (struct desc_entry *) memalign(lcm(4, CACHE_LINE), ROUNDUP(table_len, CACHE_LINE));
8f608634:	eb00abcc 	bl	8f63356c <lcm>
8f608638:	e28b103f 	add	r1, r11, #63	; 0x3f
8f60863c:	e3c1103f 	bic	r1, r1, #63	; 0x3f
8f608640:	eb00ae7f 	bl	8f634044 <memalign>
		if (!sg_list) {
8f608644:	e2509000 	subs	r9, r0, #0
8f608648:	0a000157 	beq	8f608bac <sdhci_send_command+0x940>
		memset((void *) sg_list, 0, table_len);
8f60864c:	e1a0200b 	mov	r2, r11
8f608650:	e3a01000 	mov	r1, #0
8f608654:	e1a00009 	mov	r0, r9
8f608658:	eb00af19 	bl	8f6342c4 <memset>
		for (i = 0; i < (sg_len - 1); i++) {
8f60865c:	e59d3010 	ldr	r3, [r13, #16]
8f608660:	e2530001 	subs	r0, r3, #1
8f608664:	0a000126 	beq	8f608b04 <sdhci_send_command+0x898>
			sg_len++;
8f608668:	e59d100c 	ldr	r1, [r13, #12]
8f60866c:	e3a02000 	mov	r2, #0
8f608670:	e1a03009 	mov	r3, r9
				sg_list[i].len = (SDHCI_ADMA_DESC_LINE_SZ & 0xffff);
8f608674:	e1a0e002 	mov	r14, r2
				sg_list[i].tran_att = SDHCI_ADMA_TRANS_VALID | SDHCI_ADMA_TRANS_DATA;
8f608678:	e3a0c021 	mov	r12, #33	; 0x21
		for (i = 0; i < (sg_len - 1); i++) {
8f60867c:	e2822001 	add	r2, r2, #1
				sg_list[i].addr = (uint32_t)data;
8f608680:	e5831004 	str	r1, [r3, #4]
		for (i = 0; i < (sg_len - 1); i++) {
8f608684:	e1520000 	cmp	r2, r0
				sg_list[i].len = (SDHCI_ADMA_DESC_LINE_SZ & 0xffff);
8f608688:	e1c3e0b2 	strh	r14, [r3, #2]
				data += SDHCI_ADMA_DESC_LINE_SZ;
8f60868c:	e2811801 	add	r1, r1, #65536	; 0x10000
				sg_list[i].tran_att = SDHCI_ADMA_TRANS_VALID | SDHCI_ADMA_TRANS_DATA;
8f608690:	e0c3c0b8 	strh	r12, [r3], #8
		for (i = 0; i < (sg_len - 1); i++) {
8f608694:	3afffff8 	bcc	8f60867c <sdhci_send_command+0x410>
			sg_list[sg_len - 1].addr = (uint32_t)data;
8f608698:	e59d3010 	ldr	r3, [r13, #16]
				len -= SDHCI_ADMA_DESC_LINE_SZ;
8f60869c:	e3500000 	cmp	r0, #0
8f6086a0:	e1a00800 	lsl	r0, r0, #16
8f6086a4:	e24aa801 	sub	r10, r10, #65536	; 0x10000
			sg_list[sg_len - 1].addr = (uint32_t)data;
8f6086a8:	e243221e 	sub	r2, r3, #-536870911	; 0xe0000001
				data += SDHCI_ADMA_DESC_LINE_SZ;
8f6086ac:	e59d300c 	ldr	r3, [r13, #12]
				len -= SDHCI_ADMA_DESC_LINE_SZ;
8f6086b0:	e2601801 	rsb	r1, r0, #65536	; 0x10000
				data += SDHCI_ADMA_DESC_LINE_SZ;
8f6086b4:	03a00801 	moveq	r0, #65536	; 0x10000
			sg_list[sg_len - 1].addr = (uint32_t)data;
8f6086b8:	e0892182 	add	r2, r9, r2, lsl #3
				data += SDHCI_ADMA_DESC_LINE_SZ;
8f6086bc:	e0833000 	add	r3, r3, r0
				len -= SDHCI_ADMA_DESC_LINE_SZ;
8f6086c0:	03a01000 	moveq	r1, #0
			sg_list[sg_len - 1].addr = (uint32_t)data;
8f6086c4:	e5823004 	str	r3, [r2, #4]
				len -= SDHCI_ADMA_DESC_LINE_SZ;
8f6086c8:	e081300a 	add	r3, r1, r10
			sg_list[sg_len - 1].len = (len < SDHCI_ADMA_DESC_LINE_SZ) ? len : (SDHCI_ADMA_DESC_LINE_SZ & 0xffff);
8f6086cc:	e3530801 	cmp	r3, #65536	; 0x10000
8f6086d0:	36ff3073 	uxthcc	r3, r3
8f6086d4:	23a03000 	movcs	r3, #0
8f6086d8:	e1c230b2 	strh	r3, [r2, #2]
			sg_list[sg_len - 1].tran_att = SDHCI_ADMA_TRANS_VALID | SDHCI_ADMA_TRANS_DATA |
8f6086dc:	e3a03023 	mov	r3, #35	; 0x23
8f6086e0:	e1c230b0 	strh	r3, [r2]
	arch_clean_invalidate_cache_range((addr_t)sg_list, table_len);
8f6086e4:	e1a0100b 	mov	r1, r11
8f6086e8:	e1a00009 	mov	r0, r9
8f6086ec:	eb00622b 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	REG_WRITE32(host, (uint32_t) adma_addr, SDHCI_ADM_ADDR_REG);
8f6086f0:	e5953000 	ldr	r3, [r5]
8f6086f4:	e5839058 	str	r9, [r3, #88]	; 0x58
	if (cmd->data.blk_sz)
8f6086f8:	e5963038 	ldr	r3, [r6, #56]	; 0x38
8f6086fc:	e3530000 	cmp	r3, #0
		REG_WRITE16(host, cmd->data.blk_sz, SDHCI_BLKSZ_REG);
8f608700:	16ff2073 	uxthne	r2, r3
		REG_WRITE16(host, SDHCI_MMC_BLK_SZ, SDHCI_BLKSZ_REG);
8f608704:	05953000 	ldreq	r3, [r5]
8f608708:	03a02c02 	moveq	r2, #512	; 0x200
		REG_WRITE16(host, cmd->data.blk_sz, SDHCI_BLKSZ_REG);
8f60870c:	15953000 	ldrne	r3, [r5]
		REG_WRITE16(host, SDHCI_MMC_BLK_SZ, SDHCI_BLKSZ_REG);
8f608710:	e1c320b4 	strh	r2, [r3, #4]
	REG_WRITE16(host, num_blks, SDHCI_BLK_CNT_REG);
8f608714:	e1dd20b8 	ldrh	r2, [r13, #8]
8f608718:	e1c320b6 	strh	r2, [r3, #6]
	return adma_addr;
8f60871c:	eaffff2c 	b	8f6083d4 <sdhci_send_command+0x168>
	REG_WRITE16(host, SDHCI_INT_STS_CMD_COMPLETE, SDHCI_NRML_INT_STS_REG);
8f608720:	e3a00001 	mov	r0, #1
8f608724:	e1c100b0 	strh	r0, [r1]
	if (cmd->resp_type == SDHCI_CMD_RESP_R2) {
8f608728:	e1d620ba 	ldrh	r2, [r6, #10]
8f60872c:	e3520004 	cmp	r2, #4
			cmd->resp[0] = REG_READ32(host, SDHCI_RESP_REG);
8f608730:	15930010 	ldrne	r0, [r3, #16]
8f608734:	1586000c 	strne	r0, [r6, #12]
	if (cmd->resp_type == SDHCI_CMD_RESP_R2) {
8f608738:	0a00009f 	beq	8f6089bc <sdhci_send_command+0x750>
	if (cmd->data_present || cmd->resp_type == SDHCI_CMD_RESP_R1B) {
8f60873c:	e2422002 	sub	r2, r2, #2
8f608740:	e5d60008 	ldrb	r0, [r6, #8]
8f608744:	e16f2f12 	clz	r2, r2
8f608748:	e1a022a2 	lsr	r2, r2, #5
8f60874c:	e3500000 	cmp	r0, #0
8f608750:	13822001 	orrne	r2, r2, #1
8f608754:	e3520000 	cmp	r2, #0
8f608758:	0a0000a7 	beq	8f6089fc <sdhci_send_command+0x790>
8f60875c:	e3a04000 	mov	r4, #0
8f608760:	e1a0a004 	mov	r10, r4
8f608764:	ea00000d 	b	8f6087a0 <sdhci_send_command+0x534>
			if (host->tuning_in_progress)
8f608768:	e3520000 	cmp	r2, #0
8f60876c:	0a000002 	beq	8f60877c <sdhci_send_command+0x510>
				err_status = REG_READ16(host, SDHCI_ERR_INT_STS_REG);
8f608770:	e1d323b2 	ldrh	r2, [r3, #50]	; 0x32
				if ((err_status & SDHCI_DAT_TIMEOUT_MASK) || (err_status & SDHCI_DAT_CRC_MASK))
8f608774:	e3120030 	tst	r2, #48	; 0x30
8f608778:	1a0000bf 	bne	8f608a7c <sdhci_send_command+0x810>
			retry++;
8f60877c:	e2944001 	adds	r4, r4, #1
			udelay(1);
8f608780:	e3a00001 	mov	r0, #1
			retry++;
8f608784:	e2aaa000 	adc	r10, r10, #0
			udelay(1);
8f608788:	eb001973 	bl	8f60ed5c <udelay>
			if (retry == max_trans_retry) {
8f60878c:	e15a0008 	cmp	r10, r8
8f608790:	01540007 	cmpeq	r4, r7
8f608794:	0a0000af 	beq	8f608a58 <sdhci_send_command+0x7ec>
			int_status = REG_READ16(host, SDHCI_NRML_INT_STS_REG);
8f608798:	e5953000 	ldr	r3, [r5]
8f60879c:	e2831030 	add	r1, r3, #48	; 0x30
8f6087a0:	e1d120b0 	ldrh	r2, [r1]
			if (int_status & SDHCI_INT_STS_TRANS_COMPLETE)
8f6087a4:	e3120002 	tst	r2, #2
			int_status = REG_READ16(host, SDHCI_NRML_INT_STS_REG);
8f6087a8:	e6ff2072 	uxth	r2, r2
			if (int_status & SDHCI_INT_STS_TRANS_COMPLETE)
8f6087ac:	1a000097 	bne	8f608a10 <sdhci_send_command+0x7a4>
			else if (int_status & SDHCI_ERR_INT_STAT_MASK && !host->tuning_in_progress &&
8f6087b0:	e3120902 	tst	r2, #32768	; 0x8000
8f6087b4:	e595200c 	ldr	r2, [r5, #12]
8f6087b8:	0affffea 	beq	8f608768 <sdhci_send_command+0x4fc>
8f6087bc:	e3520000 	cmp	r2, #0
8f6087c0:	1affffea 	bne	8f608770 <sdhci_send_command+0x504>
					!((REG_READ16(host, SDHCI_ERR_INT_STS_REG) & SDHCI_DAT_TIMEOUT_MASK)))
8f6087c4:	e1d323b2 	ldrh	r2, [r3, #50]	; 0x32
8f6087c8:	e2833032 	add	r3, r3, #50	; 0x32
			else if (int_status & SDHCI_ERR_INT_STAT_MASK && !host->tuning_in_progress &&
8f6087cc:	e3120010 	tst	r2, #16
8f6087d0:	1affffe9 	bne	8f60877c <sdhci_send_command+0x510>
8f6087d4:	eaffff41 	b	8f6084e0 <sdhci_send_command+0x274>
			sdhci_msm_toggle_cdr(host, false);
8f6087d8:	e3a01000 	mov	r1, #0
8f6087dc:	e1a00005 	mov	r0, r5
8f6087e0:	eb00030e 	bl	8f609420 <sdhci_msm_toggle_cdr>
		trans_mode |= SDHCI_DMA_EN;
8f6087e4:	e3a04001 	mov	r4, #1
8f6087e8:	eaffff07 	b	8f60840c <sdhci_send_command+0x1a0>
			dprintf(CRITICAL, "Error: Command never completed\n");
8f6087ec:	e3010f48 	movw	r0, #8008	; 0x1f48
8f6087f0:	e3480f70 	movt	r0, #36720	; 0x8f70
				dprintf(CRITICAL, "Error: Transfer never completed\n");
8f6087f4:	eb00a85e 	bl	8f632974 <_dprintf>
	int_status = REG_READ16(host, SDHCI_NRML_INT_STS_REG);
8f6087f8:	e595c000 	ldr	r12, [r5]
8f6087fc:	e1dc33b0 	ldrh	r3, [r12, #48]	; 0x30
	if (int_status & SDHCI_ERR_INT_STAT_MASK)
8f608800:	e3130902 	tst	r3, #32768	; 0x8000
8f608804:	0affff70 	beq	8f6085cc <sdhci_send_command+0x360>
		if ((REG_READ16(host, SDHCI_ERR_INT_STS_REG) & SDHCI_DAT_TIMEOUT_MASK) && trans_complete)
8f608808:	e28cc032 	add	r12, r12, #50	; 0x32
			ret = 1;
8f60880c:	e3a07001 	mov	r7, #1
		if ((REG_READ16(host, SDHCI_ERR_INT_STS_REG) & SDHCI_DAT_TIMEOUT_MASK) && trans_complete)
8f608810:	e1dc30b0 	ldrh	r3, [r12]
	err = REG_READ16(host, SDHCI_ERR_INT_STS_REG);
8f608814:	e1dc30b0 	ldrh	r3, [r12]
	if (err & SDHCI_CMD_TIMEOUT_MASK) {
8f608818:	e3130001 	tst	r3, #1
	err = REG_READ16(host, SDHCI_ERR_INT_STS_REG);
8f60881c:	e6ff3073 	uxth	r3, r3
	if (err & SDHCI_CMD_TIMEOUT_MASK) {
8f608820:	1a0000ab 	bne	8f608ad4 <sdhci_send_command+0x868>
	} else if (err & SDHCI_CMD_CRC_MASK) {
8f608824:	e3130002 	tst	r3, #2
8f608828:	1a0000ba 	bne	8f608b18 <sdhci_send_command+0x8ac>
	} else if (err & SDHCI_CMD_END_BIT_MASK) {
8f60882c:	e3130004 	tst	r3, #4
8f608830:	1a0000bc 	bne	8f608b28 <sdhci_send_command+0x8bc>
	} else if (err & SDHCI_CMD_IDX_MASK) {
8f608834:	e3130008 	tst	r3, #8
8f608838:	1a0000be 	bne	8f608b38 <sdhci_send_command+0x8cc>
	} else if (err & SDHCI_DAT_TIMEOUT_MASK) {
8f60883c:	e3130010 	tst	r3, #16
8f608840:	1a0000c0 	bne	8f608b48 <sdhci_send_command+0x8dc>
	} else if (err & SDHCI_DAT_CRC_MASK) {
8f608844:	e3130020 	tst	r3, #32
8f608848:	1a0000c6 	bne	8f608b68 <sdhci_send_command+0x8fc>
	} else if (err & SDHCI_DAT_END_BIT_MASK) {
8f60884c:	e3130040 	tst	r3, #64	; 0x40
8f608850:	1a0000c0 	bne	8f608b58 <sdhci_send_command+0x8ec>
	} else if (err & SDHCI_CUR_LIM_MASK) {
8f608854:	e3130080 	tst	r3, #128	; 0x80
8f608858:	1a0000c6 	bne	8f608b78 <sdhci_send_command+0x90c>
	} else if (err & SDHCI_AUTO_CMD12_MASK) {
8f60885c:	e3130c01 	tst	r3, #256	; 0x100
8f608860:	1a0000c8 	bne	8f608b88 <sdhci_send_command+0x91c>
	} else if (err & SDHCI_ADMA_MASK) {
8f608864:	e3130c02 	tst	r3, #512	; 0x200
8f608868:	1a0000ca 	bne	8f608b98 <sdhci_send_command+0x92c>
	REG_WRITE8(host, mask, SDHCI_RESET_REG);
8f60886c:	e5953000 	ldr	r3, [r5]
8f608870:	e3a02006 	mov	r2, #6
8f608874:	e5c3202f 	strb	r2, [r3, #47]	; 0x2f
		reg = REG_READ8(host, SDHCI_RESET_REG);
8f608878:	e5953000 	ldr	r3, [r5]
8f60887c:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
		if (!reg)
8f608880:	e1130002 	tst	r3, r2
8f608884:	0a000009 	beq	8f6088b0 <sdhci_send_command+0x644>
			ret = 0;
8f608888:	e3a04064 	mov	r4, #100	; 0x64
8f60888c:	ea000001 	b	8f608898 <sdhci_send_command+0x62c>
		if (!timeout)
8f608890:	e2544001 	subs	r4, r4, #1
8f608894:	0a000089 	beq	8f608ac0 <sdhci_send_command+0x854>
		mdelay(1);
8f608898:	e3a00001 	mov	r0, #1
8f60889c:	eb001916 	bl	8f60ecfc <mdelay>
		reg = REG_READ8(host, SDHCI_RESET_REG);
8f6088a0:	e5953000 	ldr	r3, [r5]
8f6088a4:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
		if (!reg)
8f6088a8:	e3130006 	tst	r3, #6
8f6088ac:	1afffff7 	bne	8f608890 <sdhci_send_command+0x624>
	if (sdhci_cmd_complete(host, cmd))
8f6088b0:	e3570000 	cmp	r7, #0
8f6088b4:	0affff0e 	beq	8f6084f4 <sdhci_send_command+0x288>
8f6088b8:	eaffff43 	b	8f6085cc <sdhci_send_command+0x360>
	flags |= (cmd->cmd_type << SDHCI_CMD_CMD_TYPE_BIT);
8f6088bc:	e5d67009 	ldrb	r7, [r6, #9]
	switch(cmd->resp_type) {
8f6088c0:	e3520004 	cmp	r2, #4
	flags |= (cmd->data_present << SDHCI_CMD_DATA_PRESENT_BIT);
8f6088c4:	e5d61008 	ldrb	r1, [r6, #8]
	flags |= (cmd->cmd_type << SDHCI_CMD_CMD_TYPE_BIT);
8f6088c8:	e1a07307 	lsl	r7, r7, #6
8f6088cc:	e1877281 	orr	r7, r7, r1, lsl #5
8f6088d0:	e3877002 	orr	r7, r7, #2
	switch(cmd->resp_type) {
8f6088d4:	0affff18 	beq	8f60853c <sdhci_send_command+0x2d0>
8f6088d8:	82422040 	subhi	r2, r2, #64	; 0x40
8f6088dc:	8a000021 	bhi	8f608968 <sdhci_send_command+0x6fc>
8f6088e0:	e3520003 	cmp	r2, #3
8f6088e4:	0afffeb4 	beq	8f6083bc <sdhci_send_command+0x150>
8f6088e8:	eaffff1a 	b	8f608558 <sdhci_send_command+0x2ec>
			if (cmd->cmd23_support) {
8f6088ec:	e5962024 	ldr	r2, [r6, #36]	; 0x24
8f6088f0:	e3520000 	cmp	r2, #0
				trans_mode |= SDHCI_TRANS_MULTI | SDHCI_AUTO_CMD23_EN | SDHCI_BLK_CNT_EN;
8f6088f4:	1384402a 	orrne	r4, r4, #42	; 0x2a
				trans_mode |= SDHCI_TRANS_MULTI | SDHCI_AUTO_CMD12_EN | SDHCI_BLK_CNT_EN;
8f6088f8:	03844026 	orreq	r4, r4, #38	; 0x26
				REG_WRITE32(host, cmd->data.num_blocks, SDHCI_ARG2_REG);
8f6088fc:	15952000 	ldrne	r2, [r5]
8f608900:	15823000 	strne	r3, [r2]
8f608904:	eafffec7 	b	8f608428 <sdhci_send_command+0x1bc>
			sg_len++;
8f608908:	e2833001 	add	r3, r3, #1
		sg_list = (struct desc_entry *) memalign(lcm(4, CACHE_LINE), ROUNDUP(table_len, CACHE_LINE));
8f60890c:	e3a01040 	mov	r1, #64	; 0x40
8f608910:	e3a00004 	mov	r0, #4
			sg_len++;
8f608914:	e58d3014 	str	r3, [r13, #20]
8f608918:	e1a09003 	mov	r9, r3
		sg_list = (struct desc_entry *) memalign(lcm(4, CACHE_LINE), ROUNDUP(table_len, CACHE_LINE));
8f60891c:	eb00ab12 	bl	8f63356c <lcm>
		table_len = (sg_len * sizeof(struct desc_entry));
8f608920:	e1a0b189 	lsl	r11, r9, #3
		sg_list = (struct desc_entry *) memalign(lcm(4, CACHE_LINE), ROUNDUP(table_len, CACHE_LINE));
8f608924:	e28b103f 	add	r1, r11, #63	; 0x3f
8f608928:	e3c1103f 	bic	r1, r1, #63	; 0x3f
8f60892c:	eb00adc4 	bl	8f634044 <memalign>
		if (!sg_list) {
8f608930:	e2509000 	subs	r9, r0, #0
8f608934:	0a00009e 	beq	8f608bb4 <sdhci_send_command+0x948>
		memset((void *) sg_list, 0, table_len);
8f608938:	e1a0200b 	mov	r2, r11
8f60893c:	e3a01000 	mov	r1, #0
8f608940:	eb00ae5f 	bl	8f6342c4 <memset>
			sg_len++;
8f608944:	e59d3014 	ldr	r3, [r13, #20]
		for (i = 0; i < (sg_len - 1); i++) {
8f608948:	e59d0010 	ldr	r0, [r13, #16]
			sg_len++;
8f60894c:	e58d3010 	str	r3, [r13, #16]
8f608950:	eaffff44 	b	8f608668 <sdhci_send_command+0x3fc>
	flags |= (cmd->cmd_type << SDHCI_CMD_CMD_TYPE_BIT);
8f608954:	e5d67009 	ldrb	r7, [r6, #9]
	flags |= (cmd->data_present << SDHCI_CMD_DATA_PRESENT_BIT);
8f608958:	e5d61008 	ldrb	r1, [r6, #8]
	flags |= (cmd->cmd_type << SDHCI_CMD_CMD_TYPE_BIT);
8f60895c:	e1a07307 	lsl	r7, r7, #6
8f608960:	e1877281 	orr	r7, r7, r1, lsl #5
8f608964:	e3877002 	orr	r7, r7, #2
	switch(cmd->resp_type) {
8f608968:	e3c22040 	bic	r2, r2, #64	; 0x40
8f60896c:	e6ff2072 	uxth	r2, r2
8f608970:	e3520000 	cmp	r2, #0
8f608974:	1afffe90 	bne	8f6083bc <sdhci_send_command+0x150>
8f608978:	eafffef6 	b	8f608558 <sdhci_send_command+0x2ec>
		sg_list = (struct desc_entry *) memalign(lcm(4, CACHE_LINE), ROUNDUP(sizeof(struct desc_entry), CACHE_LINE));
8f60897c:	e3a01040 	mov	r1, #64	; 0x40
8f608980:	e3a00004 	mov	r0, #4
8f608984:	eb00aaf8 	bl	8f63356c <lcm>
8f608988:	e3a01040 	mov	r1, #64	; 0x40
8f60898c:	eb00adac 	bl	8f634044 <memalign>
		if (!sg_list) {
8f608990:	e2509000 	subs	r9, r0, #0
8f608994:	0a000097 	beq	8f608bf8 <sdhci_send_command+0x98c>
		sg_list[0].addr = (uint32_t)data;
8f608998:	e59d300c 	ldr	r3, [r13, #12]
		sg_list[0].len = (len < SDHCI_ADMA_DESC_LINE_SZ) ? len : (SDHCI_ADMA_DESC_LINE_SZ & 0xffff);
8f60899c:	e35a0801 	cmp	r10, #65536	; 0x10000
		table_len = sizeof(struct desc_entry);
8f6089a0:	e3a0b008 	mov	r11, #8
		sg_list[0].len = (len < SDHCI_ADMA_DESC_LINE_SZ) ? len : (SDHCI_ADMA_DESC_LINE_SZ & 0xffff);
8f6089a4:	03a0a000 	moveq	r10, #0
8f6089a8:	e1c9a0b2 	strh	r10, [r9, #2]
		sg_list[0].addr = (uint32_t)data;
8f6089ac:	e5893004 	str	r3, [r9, #4]
		sg_list[0].tran_att = SDHCI_ADMA_TRANS_VALID | SDHCI_ADMA_TRANS_DATA
8f6089b0:	e3a03023 	mov	r3, #35	; 0x23
8f6089b4:	e1c930b0 	strh	r3, [r9]
		table_len = sizeof(struct desc_entry);
8f6089b8:	eaffff49 	b	8f6086e4 <sdhci_send_command+0x478>
			cmd->resp[0] = REG_READ32(host, SDHCI_RESP_REG);
8f6089bc:	e2834010 	add	r4, r3, #16
8f6089c0:	e286a00c 	add	r10, r6, #12
			cmd->resp[i] = REG_READ32(host, SDHCI_RESP_REG + (i * 4));
8f6089c4:	e594e000 	ldr	r14, [r4]
			if (i != 0)
8f6089c8:	e3500001 	cmp	r0, #1
			cmd->resp[i] <<= SDHCI_RESP_LSHIFT;
8f6089cc:	e1a0e40e 	lsl	r14, r14, #8
8f6089d0:	e48ae004 	str	r14, [r10], #4
			if (i != 0)
8f6089d4:	0a000004 	beq	8f6089ec <sdhci_send_command+0x780>
				cmd->resp[i] |= (REG_READ32(host, SDHCI_RESP_REG + ((i-1) * 4)) >> SDHCI_RESP_RSHIFT);
8f6089d8:	e514b004 	ldr	r11, [r4, #-4]
		for (i = 0; i < 4; i++) {
8f6089dc:	e3500004 	cmp	r0, #4
				cmd->resp[i] |= (REG_READ32(host, SDHCI_RESP_REG + ((i-1) * 4)) >> SDHCI_RESP_RSHIFT);
8f6089e0:	e18eec2b 	orr	r14, r14, r11, lsr #24
8f6089e4:	e50ae004 	str	r14, [r10, #-4]
		for (i = 0; i < 4; i++) {
8f6089e8:	0affff53 	beq	8f60873c <sdhci_send_command+0x4d0>
8f6089ec:	e2800001 	add	r0, r0, #1
8f6089f0:	e2844004 	add	r4, r4, #4
8f6089f4:	e6ef0070 	uxtb	r0, r0
8f6089f8:	eafffff1 	b	8f6089c4 <sdhci_send_command+0x758>
	int_status = REG_READ16(host, SDHCI_NRML_INT_STS_REG);
8f6089fc:	e1d130b0 	ldrh	r3, [r1]
	if (int_status & SDHCI_ERR_INT_STAT_MASK)
8f608a00:	e3130902 	tst	r3, #32768	; 0x8000
8f608a04:	0afffeba 	beq	8f6084f4 <sdhci_send_command+0x288>
	uint8_t ret = 0;
8f608a08:	e1a07002 	mov	r7, r2
8f608a0c:	eaffff7f 	b	8f608810 <sdhci_send_command+0x5a4>
		REG_WRITE16(host, SDHCI_INT_STS_TRANS_COMPLETE, SDHCI_NRML_INT_STS_REG);
8f608a10:	e3a02002 	mov	r2, #2
8f608a14:	e1c120b0 	strh	r2, [r1]
	int_status = REG_READ16(host, SDHCI_NRML_INT_STS_REG);
8f608a18:	e1d120b0 	ldrh	r2, [r1]
	if (int_status & SDHCI_ERR_INT_STAT_MASK)
8f608a1c:	e3120902 	tst	r2, #32768	; 0x8000
8f608a20:	0afffeb3 	beq	8f6084f4 <sdhci_send_command+0x288>
		if ((REG_READ16(host, SDHCI_ERR_INT_STS_REG) & SDHCI_DAT_TIMEOUT_MASK) && trans_complete)
8f608a24:	e1d323b2 	ldrh	r2, [r3, #50]	; 0x32
8f608a28:	e283c032 	add	r12, r3, #50	; 0x32
8f608a2c:	e2122010 	ands	r2, r2, #16
	uint8_t ret = 0;
8f608a30:	01a07002 	moveq	r7, r2
		if ((REG_READ16(host, SDHCI_ERR_INT_STS_REG) & SDHCI_DAT_TIMEOUT_MASK) && trans_complete)
8f608a34:	0affff76 	beq	8f608814 <sdhci_send_command+0x5a8>
	REG_WRITE8(host, mask, SDHCI_RESET_REG);
8f608a38:	e3a02006 	mov	r2, #6
8f608a3c:	e5c3202f 	strb	r2, [r3, #47]	; 0x2f
		reg = REG_READ8(host, SDHCI_RESET_REG);
8f608a40:	e5953000 	ldr	r3, [r5]
8f608a44:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
		if (!reg)
8f608a48:	e1130002 	tst	r3, r2
			ret = 0;
8f608a4c:	13a07000 	movne	r7, #0
		if (!reg)
8f608a50:	1affff8c 	bne	8f608888 <sdhci_send_command+0x61c>
8f608a54:	eafffea6 	b	8f6084f4 <sdhci_send_command+0x288>
				dprintf(CRITICAL, "Error: Transfer never completed\n");
8f608a58:	e3010f68 	movw	r0, #8040	; 0x1f68
8f608a5c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f608a60:	eaffff63 	b	8f6087f4 <sdhci_send_command+0x588>
			dprintf(CRITICAL, "Error: sdhci reset failed for: %x\n", mask);
8f608a64:	e3a01006 	mov	r1, #6
8f608a68:	e3010e1c 	movw	r0, #7708	; 0x1e1c
8f608a6c:	e3480f70 	movt	r0, #36720	; 0x8f70
		ret = 1;
8f608a70:	e3a04001 	mov	r4, #1
			dprintf(CRITICAL, "Error: sdhci reset failed for: %x\n", mask);
8f608a74:	eb00a7be 	bl	8f632974 <_dprintf>
			break;
8f608a78:	eafffed4 	b	8f6085d0 <sdhci_send_command+0x364>
	REG_WRITE8(host, mask, SDHCI_RESET_REG);
8f608a7c:	e3a02006 	mov	r2, #6
8f608a80:	e5c3202f 	strb	r2, [r3, #47]	; 0x2f
		reg = REG_READ8(host, SDHCI_RESET_REG);
8f608a84:	e5953000 	ldr	r3, [r5]
8f608a88:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
		if (!reg)
8f608a8c:	e1130002 	tst	r3, r2
8f608a90:	0afffecd 	beq	8f6085cc <sdhci_send_command+0x360>
8f608a94:	e3a04064 	mov	r4, #100	; 0x64
8f608a98:	ea000001 	b	8f608aa4 <sdhci_send_command+0x838>
		if (!timeout)
8f608a9c:	e2544001 	subs	r4, r4, #1
8f608aa0:	0affffef 	beq	8f608a64 <sdhci_send_command+0x7f8>
		mdelay(1);
8f608aa4:	e3a00001 	mov	r0, #1
8f608aa8:	eb001893 	bl	8f60ecfc <mdelay>
		reg = REG_READ8(host, SDHCI_RESET_REG);
8f608aac:	e5953000 	ldr	r3, [r5]
8f608ab0:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
		if (!reg)
8f608ab4:	e3130006 	tst	r3, #6
8f608ab8:	1afffff7 	bne	8f608a9c <sdhci_send_command+0x830>
8f608abc:	eafffec2 	b	8f6085cc <sdhci_send_command+0x360>
			dprintf(CRITICAL, "Error: sdhci reset failed for: %x\n", mask);
8f608ac0:	e3a01006 	mov	r1, #6
8f608ac4:	e3010e1c 	movw	r0, #7708	; 0x1e1c
8f608ac8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f608acc:	eb00a7a8 	bl	8f632974 <_dprintf>
			break;
8f608ad0:	eaffff76 	b	8f6088b0 <sdhci_send_command+0x644>
		dprintf(CRITICAL, "Error: Command timeout error\n");
8f608ad4:	e3010f8c 	movw	r0, #8076	; 0x1f8c
8f608ad8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f608adc:	eb00a7a4 	bl	8f632974 <_dprintf>
	REG_WRITE8(host, mask, SDHCI_RESET_REG);
8f608ae0:	e5953000 	ldr	r3, [r5]
8f608ae4:	e3a02006 	mov	r2, #6
8f608ae8:	e5c3202f 	strb	r2, [r3, #47]	; 0x2f
		reg = REG_READ8(host, SDHCI_RESET_REG);
8f608aec:	e5953000 	ldr	r3, [r5]
8f608af0:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
		if (!reg)
8f608af4:	e1130002 	tst	r3, r2
8f608af8:	0afffeb3 	beq	8f6085cc <sdhci_send_command+0x360>
8f608afc:	e3a07001 	mov	r7, #1
8f608b00:	eaffff60 	b	8f608888 <sdhci_send_command+0x61c>
			sg_list[sg_len - 1].addr = (uint32_t)data;
8f608b04:	e59d300c 	ldr	r3, [r13, #12]
8f608b08:	e1a02009 	mov	r2, r9
8f608b0c:	e5893004 	str	r3, [r9, #4]
8f608b10:	e1a03000 	mov	r3, r0
8f608b14:	eafffeef 	b	8f6086d8 <sdhci_send_command+0x46c>
		dprintf(CRITICAL, "Error: Command CRC error\n");
8f608b18:	e3010fac 	movw	r0, #8108	; 0x1fac
8f608b1c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f608b20:	eb00a793 	bl	8f632974 <_dprintf>
		return 1;
8f608b24:	eaffffed 	b	8f608ae0 <sdhci_send_command+0x874>
		dprintf(CRITICAL, "Error: CMD end bit error\n");
8f608b28:	e3010fc8 	movw	r0, #8136	; 0x1fc8
8f608b2c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f608b30:	eb00a78f 	bl	8f632974 <_dprintf>
		return 1;
8f608b34:	eaffffe9 	b	8f608ae0 <sdhci_send_command+0x874>
		dprintf(CRITICAL, "Error: Command Index error\n");
8f608b38:	e3010fe4 	movw	r0, #8164	; 0x1fe4
8f608b3c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f608b40:	eb00a78b 	bl	8f632974 <_dprintf>
		return 1;
8f608b44:	eaffffe5 	b	8f608ae0 <sdhci_send_command+0x874>
		dprintf(CRITICAL, "Error: DATA time out error\n");
8f608b48:	e3020000 	movw	r0, #8192	; 0x2000
8f608b4c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f608b50:	eb00a787 	bl	8f632974 <_dprintf>
		return 1;
8f608b54:	eaffffe1 	b	8f608ae0 <sdhci_send_command+0x874>
		dprintf(CRITICAL, "Error: DATA end bit error\n");
8f608b58:	e3020034 	movw	r0, #8244	; 0x2034
8f608b5c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f608b60:	eb00a783 	bl	8f632974 <_dprintf>
		return 1;
8f608b64:	eaffffdd 	b	8f608ae0 <sdhci_send_command+0x874>
		dprintf(CRITICAL, "Error: DATA CRC error\n");
8f608b68:	e302001c 	movw	r0, #8220	; 0x201c
8f608b6c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f608b70:	eb00a77f 	bl	8f632974 <_dprintf>
		return 1;
8f608b74:	eaffffd9 	b	8f608ae0 <sdhci_send_command+0x874>
		dprintf(CRITICAL, "Error: Current limit error\n");
8f608b78:	e3020050 	movw	r0, #8272	; 0x2050
8f608b7c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f608b80:	eb00a77b 	bl	8f632974 <_dprintf>
		return 1;
8f608b84:	eaffffd5 	b	8f608ae0 <sdhci_send_command+0x874>
		dprintf(CRITICAL, "Error: Auto CMD12 error\n");
8f608b88:	e302006c 	movw	r0, #8300	; 0x206c
8f608b8c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f608b90:	eb00a777 	bl	8f632974 <_dprintf>
		return 1;
8f608b94:	eaffffd1 	b	8f608ae0 <sdhci_send_command+0x874>
		dprintf(CRITICAL, "Error: ADMA error\n");
8f608b98:	e3020088 	movw	r0, #8328	; 0x2088
8f608b9c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f608ba0:	eb00a773 	bl	8f632974 <_dprintf>
		return 1;
8f608ba4:	eaffffcd 	b	8f608ae0 <sdhci_send_command+0x874>
}
8f608ba8:	eb00a804 	bl	8f632bc0 <__stack_chk_fail>
		sg_len = len / SDHCI_ADMA_DESC_LINE_SZ;
8f608bac:	e59d3010 	ldr	r3, [r13, #16]
8f608bb0:	e58d3014 	str	r3, [r13, #20]
			ASSERT(0);
8f608bb4:	e59d3014 	ldr	r3, [r13, #20]
			dprintf(CRITICAL, "Error allocating memory\n");
8f608bb8:	e3010f2c 	movw	r0, #7980	; 0x1f2c
8f608bbc:	e3480f70 	movt	r0, #36720	; 0x8f70
			ASSERT(0);
8f608bc0:	e3a09000 	mov	r9, #0
8f608bc4:	e58d3010 	str	r3, [r13, #16]
			dprintf(CRITICAL, "Error allocating memory\n");
8f608bc8:	eb00a769 	bl	8f632974 <_dprintf>
			ASSERT(0);
8f608bcc:	e1a00008 	mov	r0, r8
8f608bd0:	e3073f64 	movw	r3, #32612	; 0x7f64
8f608bd4:	e3012e60 	movw	r2, #7776	; 0x1e60
8f608bd8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f608bdc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f608be0:	e58d3000 	str	r3, [r13]
8f608be4:	e3001130 	movw	r1, #304	; 0x130
8f608be8:	e300327e 	movw	r3, #638	; 0x27e
8f608bec:	e3481f70 	movt	r1, #36720	; 0x8f70
8f608bf0:	eb00a7b1 	bl	8f632abc <_panic>
8f608bf4:	eafffe94 	b	8f60864c <sdhci_send_command+0x3e0>
			dprintf(CRITICAL, "Error allocating memory\n");
8f608bf8:	e3010f2c 	movw	r0, #7980	; 0x1f2c
8f608bfc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f608c00:	eb00a75b 	bl	8f632974 <_dprintf>
			ASSERT(0);
8f608c04:	e1a00008 	mov	r0, r8
8f608c08:	e3073f64 	movw	r3, #32612	; 0x7f64
8f608c0c:	e3012e60 	movw	r2, #7776	; 0x1e60
8f608c10:	e3483f70 	movt	r3, #36720	; 0x8f70
8f608c14:	e3482f70 	movt	r2, #36720	; 0x8f70
8f608c18:	e58d3000 	str	r3, [r13]
8f608c1c:	e3001130 	movw	r1, #304	; 0x130
8f608c20:	e3003265 	movw	r3, #613	; 0x265
8f608c24:	e3481f70 	movt	r1, #36720	; 0x8f70
8f608c28:	eb00a7a3 	bl	8f632abc <_panic>
8f608c2c:	eaffff59 	b	8f608998 <sdhci_send_command+0x72c>
8f608c30:	8f74221c 	.word	0x8f74221c

8f608c34 <sdhci_init>:
 *           4. Set initial bus width
 *           5. Set Adma mode
 *           6. Enable the error status
 */
void sdhci_init(struct sdhci_host *host)
{
8f608c34:	e59f3168 	ldr	r3, [pc, #360]	; 8f608da4 <sdhci_init+0x170>


	DBG("\n %s: Host capability: cap1:0x%08x, cap2: 0x%08x\n", __func__, caps[0], caps[1]);

	host->caps.base_clk_rate = (caps[0] & SDHCI_CLK_RATE_MASK) >> SDHCI_CLK_RATE_BIT;
	host->caps.base_clk_rate *= 1000000;
8f608c38:	e304c240 	movw	r12, #16960	; 0x4240
	caps[0] = REG_READ32(host, SDHCI_CAPS_REG1);
8f608c3c:	e5901000 	ldr	r1, [r0]
	host->caps.base_clk_rate *= 1000000;
8f608c40:	e340c00f 	movt	r12, #15
{
8f608c44:	e92d4010 	push	{r4, r14}
8f608c48:	e24dd008 	sub	r13, r13, #8
8f608c4c:	e5933000 	ldr	r3, [r3]
8f608c50:	e58d3004 	str	r3, [r13, #4]
8f608c54:	e3a03000 	mov	r3, #0
8f608c58:	e1a04000 	mov	r4, r0
	caps[0] = REG_READ32(host, SDHCI_CAPS_REG1);
8f608c5c:	e5913040 	ldr	r3, [r1, #64]	; 0x40
	caps[1] = REG_READ32(host, SDHCI_CAPS_REG2);
8f608c60:	e5912044 	ldr	r2, [r1, #68]	; 0x44
	host->caps.base_clk_rate = (caps[0] & SDHCI_CLK_RATE_MASK) >> SDHCI_CLK_RATE_BIT;
8f608c64:	e7e70453 	ubfx	r0, r3, #8, #8

	/* Get the max block length for mmc */
	host->caps.max_blk_len = (caps[0] & SDHCI_BLK_LEN_MASK) >> SDHCI_BLK_LEN_BIT;

	/* 8 bit Bus width */
	if (caps[0] & SDHCI_8BIT_WIDTH_MASK)
8f608c68:	e3130701 	tst	r3, #262144	; 0x40000
	host->caps.base_clk_rate *= 1000000;
8f608c6c:	e000009c 	mul	r0, r12, r0
8f608c70:	e584001c 	str	r0, [r4, #28]
	host->caps.max_blk_len = (caps[0] & SDHCI_BLK_LEN_MASK) >> SDHCI_BLK_LEN_BIT;
8f608c74:	e7e10853 	ubfx	r0, r3, #16, #2
8f608c78:	e5840020 	str	r0, [r4, #32]
		host->caps.bus_width_8bit = 1;
8f608c7c:	13a00001 	movne	r0, #1
8f608c80:	15c40024 	strbne	r0, [r4, #36]	; 0x24

	/* Adma support */
	if (caps[0] & SDHCI_BLK_ADMA_MASK)
8f608c84:	e3130702 	tst	r3, #524288	; 0x80000
		host->caps.adma_support = 1;
8f608c88:	13a00001 	movne	r0, #1
8f608c8c:	15c40025 	strbne	r0, [r4, #37]	; 0x25

	/* Supported voltage */
	if (caps[0] & SDHCI_3_3_VOL_MASK)
8f608c90:	e3130401 	tst	r3, #16777216	; 0x1000000
8f608c94:	0a000030 	beq	8f608d5c <sdhci_init+0x128>
		host->caps.voltage = SDHCI_VOL_3_3;
8f608c98:	e3a0c00f 	mov	r12, #15
8f608c9c:	e3a0000e 	mov	r0, #14
8f608ca0:	e3a03007 	mov	r3, #7
8f608ca4:	e5c43026 	strb	r3, [r4, #38]	; 0x26
	host->caps.sdr50_support = (caps[1] & SDHCI_SDR50_MODE_MASK) ? 1 : 0;

	/* SDR104 mode support */
	host->caps.sdr104_support = (caps[1] & SDHCI_SDR104_MODE_MASK) ? 1 : 0;

	version = readl(host->msm_host->pwrctl_base + MCI_VERSION);
8f608ca8:	e5943030 	ldr	r3, [r4, #48]	; 0x30
	host->caps.ddr_support = (caps[1] & SDHCI_DDR50_MODE_MASK) ? 1 : 0;
8f608cac:	e7e0e152 	ubfx	r14, r2, #2, #1
8f608cb0:	e5c4e028 	strb	r14, [r4, #40]	; 0x28
	host->caps.sdr50_support = (caps[1] & SDHCI_SDR50_MODE_MASK) ? 1 : 0;
8f608cb4:	e202e001 	and	r14, r2, #1
	host->caps.sdr104_support = (caps[1] & SDHCI_SDR104_MODE_MASK) ? 1 : 0;
8f608cb8:	e7e020d2 	ubfx	r2, r2, #1, #1
	host->caps.sdr50_support = (caps[1] & SDHCI_SDR50_MODE_MASK) ? 1 : 0;
8f608cbc:	e5c4e029 	strb	r14, [r4, #41]	; 0x29
	host->caps.sdr104_support = (caps[1] & SDHCI_SDR104_MODE_MASK) ? 1 : 0;
8f608cc0:	e5c4202a 	strb	r2, [r4, #42]	; 0x2a
	version = readl(host->msm_host->pwrctl_base + MCI_VERSION);
8f608cc4:	e5933000 	ldr	r3, [r3]
8f608cc8:	e5933050 	ldr	r3, [r3, #80]	; 0x50

	host->major = (version & CORE_VERSION_MAJOR_MASK) >> CORE_VERSION_MAJOR_SHIFT;
8f608ccc:	e1a02e23 	lsr	r2, r3, #28
	host->minor = (version & CORE_VERSION_MINOR_MASK);
8f608cd0:	e6ef3073 	uxtb	r3, r3

	if (host->major == 0x1 && host->minor < 0x34)
		host->use_cdclp533 = true;
8f608cd4:	e3530033 	cmp	r3, #51	; 0x33
8f608cd8:	93520001 	cmpls	r2, #1
	host->minor = (version & CORE_VERSION_MINOR_MASK);
8f608cdc:	e1c431b2 	strh	r3, [r4, #18]
	host->major = (version & CORE_VERSION_MAJOR_MASK) >> CORE_VERSION_MAJOR_SHIFT;
8f608ce0:	e5c42010 	strb	r2, [r4, #16]
		host->use_cdclp533 = true;
8f608ce4:	03a03001 	moveq	r3, #1
8f608ce8:	13a03000 	movne	r3, #0
8f608cec:	e5843014 	str	r3, [r4, #20]
	REG_WRITE8(host, voltage, SDHCI_PWR_CTRL_REG);
8f608cf0:	e5c10029 	strb	r0, [r1, #41]	; 0x29
	REG_WRITE8(host, voltage, SDHCI_PWR_CTRL_REG);
8f608cf4:	e5943000 	ldr	r3, [r4]
8f608cf8:	e5c3c029 	strb	r12, [r3, #41]	; 0x29

	/* Set bus power on */
	sdhci_set_bus_power_on(host);

	/* Wait for power interrupt to be handled */
	event_wait(host->sdhc_event);
8f608cfc:	e5940018 	ldr	r0, [r4, #24]
8f608d00:	eb00676a 	bl	8f622ab0 <event_wait>
	reg = REG_READ8(host, SDHCI_HOST_CTRL1_REG);
8f608d04:	e5940000 	ldr	r0, [r4]
	REG_WRITE8(host, SDHCI_ADMA_32BIT, SDHCI_HOST_CTRL1_REG);
8f608d08:	e3a0c010 	mov	r12, #16
	REG_WRITE16(host, SDHCI_ERR_INT_STS_EN, SDHCI_ERR_INT_STS_EN_REG);
8f608d0c:	e3e02000 	mvn	r2, #0
	REG_WRITE16(host, SDHCI_NRML_INT_STS_EN, SDHCI_NRML_INT_STS_EN_REG);
8f608d10:	e3a0100b 	mov	r1, #11
	reg = REG_READ8(host, SDHCI_HOST_CTRL1_REG);
8f608d14:	e5d03028 	ldrb	r3, [r0, #40]	; 0x28
8f608d18:	e6ef3073 	uxtb	r3, r3
	REG_WRITE8(host, (reg | width), SDHCI_HOST_CTRL1_REG);
8f608d1c:	e5c03028 	strb	r3, [r0, #40]	; 0x28
	REG_WRITE8(host, SDHCI_ADMA_32BIT, SDHCI_HOST_CTRL1_REG);
8f608d20:	e5943000 	ldr	r3, [r4]
8f608d24:	e5c3c028 	strb	r12, [r3, #40]	; 0x28
	sdhci_set_adma_mode(host);

	/*
	 * Enable error status
	 */
	sdhci_error_status_enable(host);
8f608d28:	e5943000 	ldr	r3, [r4]
	REG_WRITE16(host, SDHCI_NRML_INT_STS_EN, SDHCI_NRML_INT_STS_EN_REG);
8f608d2c:	e1c313b4 	strh	r1, [r3, #52]	; 0x34
	REG_WRITE16(host, SDHCI_ERR_INT_STS_EN, SDHCI_ERR_INT_STS_EN_REG);
8f608d30:	e1c323b6 	strh	r2, [r3, #54]	; 0x36
	REG_WRITE16(host, SDHCI_NRML_INT_SIG_EN, SDHCI_NRML_INT_SIG_EN_REG);
8f608d34:	e1c313b8 	strh	r1, [r3, #56]	; 0x38
	REG_WRITE16(host, SDHCI_ERR_INT_SIG_EN, SDHCI_ERR_INT_SIG_EN_REG);
8f608d38:	e1c323ba 	strh	r2, [r3, #58]	; 0x3a
}
8f608d3c:	e59f3060 	ldr	r3, [pc, #96]	; 8f608da4 <sdhci_init+0x170>
8f608d40:	e5932000 	ldr	r2, [r3]
8f608d44:	e59d3004 	ldr	r3, [r13, #4]
8f608d48:	e0332002 	eors	r2, r3, r2
8f608d4c:	e3a03000 	mov	r3, #0
8f608d50:	1a000012 	bne	8f608da0 <sdhci_init+0x16c>
8f608d54:	e28dd008 	add	r13, r13, #8
8f608d58:	e8bd8010 	pop	{r4, r15}
	else if (caps[0] & SDHCI_3_0_VOL_MASK)
8f608d5c:	e3130402 	tst	r3, #33554432	; 0x2000000
8f608d60:	0a000004 	beq	8f608d78 <sdhci_init+0x144>
		host->caps.voltage = SDHCI_VOL_3_0;
8f608d64:	e3a03006 	mov	r3, #6
8f608d68:	e3a0c00d 	mov	r12, #13
8f608d6c:	e3a0000c 	mov	r0, #12
8f608d70:	e5c43026 	strb	r3, [r4, #38]	; 0x26
8f608d74:	eaffffcb 	b	8f608ca8 <sdhci_init+0x74>
	else if (caps[0] & SDHCI_1_8_VOL_MASK)
8f608d78:	e3130301 	tst	r3, #67108864	; 0x4000000
	voltage <<= SDHCI_BUS_VOL_SEL;
8f608d7c:	05d40026 	ldrbeq	r0, [r4, #38]	; 0x26
		host->caps.voltage = SDHCI_VOL_1_8;
8f608d80:	13a03005 	movne	r3, #5
8f608d84:	13a0c00b 	movne	r12, #11
8f608d88:	13a0000a 	movne	r0, #10
8f608d8c:	15c43026 	strbne	r3, [r4, #38]	; 0x26
	voltage <<= SDHCI_BUS_VOL_SEL;
8f608d90:	01a00080 	lsleq	r0, r0, #1
8f608d94:	06ef0070 	uxtbeq	r0, r0
	voltage |= SDHCI_BUS_PWR_EN;
8f608d98:	0380c001 	orreq	r12, r0, #1
		host->caps.voltage = SDHCI_VOL_1_8;
8f608d9c:	eaffffc1 	b	8f608ca8 <sdhci_init+0x74>
}
8f608da0:	eb00a786 	bl	8f632bc0 <__stack_chk_fail>
8f608da4:	8f74221c 	.word	0x8f74221c

8f608da8 <sdhci_int_handler>:
 * Details : This is power control interrupt handler.
 *           Once we receive the interrupt, we will ack the power control
 *           register that we have successfully completed pmic transactions
 */
static enum handler_return sdhci_int_handler(struct sdhci_msm_data *data)
{
8f608da8:	e59f305c 	ldr	r3, [pc, #92]	; 8f608e0c <sdhci_int_handler+0x64>
		ack |= SDCC_HC_IO_SIG_SUCC;

	/* Write success to power control register */
	writel(ack, (data->pwrctl_base + SDCC_HC_PWRCTL_CTL_REG));

	event_signal(data->sdhc_event, false);
8f608dac:	e3a01000 	mov	r1, #0
{
8f608db0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f608db4:	e24dd00c 	sub	r13, r13, #12
8f608db8:	e5933000 	ldr	r3, [r3]
8f608dbc:	e58d3004 	str	r3, [r13, #4]
8f608dc0:	e3a03000 	mov	r3, #0
	status = readl(data->pwrctl_base + SDCC_HC_PWRCTL_MASK_REG);
8f608dc4:	e5903000 	ldr	r3, [r0]
	event_signal(data->sdhc_event, false);
8f608dc8:	e5900010 	ldr	r0, [r0, #16]
	status = readl(data->pwrctl_base + SDCC_HC_PWRCTL_MASK_REG);
8f608dcc:	e59320e0 	ldr	r2, [r3, #224]	; 0xe0
		ack |= SDCC_HC_IO_SIG_SUCC;
8f608dd0:	e312000c 	tst	r2, #12
8f608dd4:	03a02001 	moveq	r2, #1
8f608dd8:	13a02005 	movne	r2, #5
	writel(ack, (data->pwrctl_base + SDCC_HC_PWRCTL_CTL_REG));
8f608ddc:	e58320e8 	str	r2, [r3, #232]	; 0xe8
	event_signal(data->sdhc_event, false);
8f608de0:	eb006771 	bl	8f622bac <event_signal>

	return 0;
}
8f608de4:	e59f3020 	ldr	r3, [pc, #32]	; 8f608e0c <sdhci_int_handler+0x64>
8f608de8:	e5932000 	ldr	r2, [r3]
8f608dec:	e59d3004 	ldr	r3, [r13, #4]
8f608df0:	e0332002 	eors	r2, r3, r2
8f608df4:	e3a03000 	mov	r3, #0
8f608df8:	1a000002 	bne	8f608e08 <sdhci_int_handler+0x60>
8f608dfc:	e3a00000 	mov	r0, #0
8f608e00:	e28dd00c 	add	r13, r13, #12
8f608e04:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f608e08:	eb00a76c 	bl	8f632bc0 <__stack_chk_fail>
8f608e0c:	8f74221c 	.word	0x8f74221c

8f608e10 <sdhci_msm_config_dll>:
	REG_WRITE32(host, core_cfg, SDCC_DLL_CONFIG_REG);
}

/* Configure DLL with delay value based on 'phase' */
static uint32_t sdhci_msm_config_dll(struct sdhci_host *host, uint32_t phase)
{
8f608e10:	e59f3120 	ldr	r3, [pc, #288]	; 8f608f38 <sdhci_msm_config_dll+0x128>
	uint32_t core_cfg = 0;
	uint32_t timeout = SDHCI_DLL_TIMEOUT;

	/* Gray code values from SWI */
	uint32_t gray_code [] = { 0x0, 0x1, 0x3, 0x2, 0x6, 0x7, 0x5, 0x4, 0xC, 0xD, 0xF, 0xE, 0xA, 0xB, 0x9, 0x8 };
8f608e14:	e302c224 	movw	r12, #8740	; 0x2224
8f608e18:	e348cf70 	movt	r12, #36720	; 0x8f70
{
8f608e1c:	e92d4070 	push	{r4, r5, r6, r14}
8f608e20:	e24dd048 	sub	r13, r13, #72	; 0x48
8f608e24:	e5933000 	ldr	r3, [r3]
8f608e28:	e58d3044 	str	r3, [r13, #68]	; 0x44
8f608e2c:	e3a03000 	mov	r3, #0
8f608e30:	e1a06000 	mov	r6, r0
8f608e34:	e1a04001 	mov	r4, r1
	uint32_t gray_code [] = { 0x0, 0x1, 0x3, 0x2, 0x6, 0x7, 0x5, 0x4, 0xC, 0xD, 0xF, 0xE, 0xA, 0xB, 0x9, 0x8 };
8f608e38:	e28de004 	add	r14, r13, #4
8f608e3c:	e8bc000f 	ldm	r12!, {r0, r1, r2, r3}
8f608e40:	e8ae000f 	stmia	r14!, {r0, r1, r2, r3}
8f608e44:	e8bc000f 	ldm	r12!, {r0, r1, r2, r3}
8f608e48:	e8ae000f 	stmia	r14!, {r0, r1, r2, r3}
8f608e4c:	e8bc000f 	ldm	r12!, {r0, r1, r2, r3}
8f608e50:	e8ae000f 	stmia	r14!, {r0, r1, r2, r3}
8f608e54:	e89c000f 	ldm	r12, {r0, r1, r2, r3}
8f608e58:	e88e000f 	stm	r14, {r0, r1, r2, r3}

	/* set CDR_EN & CLK_OUT_EN to 0 and
	 * CDR_EXT_EN & DLL_EN to 1*/
	core_cfg = REG_READ32(host, SDCC_DLL_CONFIG_REG);
8f608e5c:	e5962000 	ldr	r2, [r6]
8f608e60:	e5923100 	ldr	r3, [r2, #256]	; 0x100
	core_cfg &= ~(SDCC_DLL_CDR_EN | SDCC_DLL_CLK_OUT_EN);
8f608e64:	e3c33806 	bic	r3, r3, #393216	; 0x60000
	core_cfg |= (SDCC_DLL_CDR_EXT_EN | SDCC_DLL_EN);
8f608e68:	e3833809 	orr	r3, r3, #589824	; 0x90000
	REG_WRITE32(host, core_cfg, SDCC_DLL_CONFIG_REG);
8f608e6c:	e5823100 	str	r3, [r2, #256]	; 0x100

	/* Wait until CLK_OUT_EN is 0 */
	while(REG_READ32(host, SDCC_DLL_CONFIG_REG) & SDCC_DLL_CLK_OUT_EN);
8f608e70:	e5960000 	ldr	r0, [r6]
8f608e74:	e2802c01 	add	r2, r0, #256	; 0x100
8f608e78:	e5923000 	ldr	r3, [r2]
8f608e7c:	e2135701 	ands	r5, r3, #262144	; 0x40000
8f608e80:	1afffffc 	bne	8f608e78 <sdhci_msm_config_dll+0x68>

	REG_RMW32(host, SDCC_DLL_CONFIG_REG, SDCC_DLL_GRAY_CODE_START, SDCC_DLL_GRAY_CODE_WIDTH, gray_code[phase]);
8f608e84:	e28d3048 	add	r3, r13, #72	; 0x48
8f608e88:	e0834104 	add	r4, r3, r4, lsl #2
8f608e8c:	e5903100 	ldr	r3, [r0, #256]	; 0x100
8f608e90:	e5142044 	ldr	r2, [r4, #-68]	; 0xffffffbc
8f608e94:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000

	REG_WRITE32(host, (REG_READ32(host, SDCC_DLL_CONFIG_REG) | SDCC_DLL_CLK_OUT_EN), SDCC_DLL_CONFIG_REG);

	/* Wait until CLK_OUT_EN is 1, wait time 50us */
	while(!(REG_READ32(host, SDCC_DLL_CONFIG_REG) & SDCC_DLL_CLK_OUT_EN))
8f608e98:	e3a04032 	mov	r4, #50	; 0x32
	REG_RMW32(host, SDCC_DLL_CONFIG_REG, SDCC_DLL_GRAY_CODE_START, SDCC_DLL_GRAY_CODE_WIDTH, gray_code[phase]);
8f608e9c:	e1833a02 	orr	r3, r3, r2, lsl #20
8f608ea0:	e5803100 	str	r3, [r0, #256]	; 0x100
	REG_WRITE32(host, (REG_READ32(host, SDCC_DLL_CONFIG_REG) | SDCC_DLL_CLK_OUT_EN), SDCC_DLL_CONFIG_REG);
8f608ea4:	e5962000 	ldr	r2, [r6]
8f608ea8:	e5923100 	ldr	r3, [r2, #256]	; 0x100
8f608eac:	e3833701 	orr	r3, r3, #262144	; 0x40000
8f608eb0:	e5823100 	str	r3, [r2, #256]	; 0x100
	while(!(REG_READ32(host, SDCC_DLL_CONFIG_REG) & SDCC_DLL_CLK_OUT_EN))
8f608eb4:	ea000003 	b	8f608ec8 <sdhci_msm_config_dll+0xb8>
	{
		timeout--;
		udelay(1);
8f608eb8:	e3a00001 	mov	r0, #1
8f608ebc:	eb0017a6 	bl	8f60ed5c <udelay>
		if (!timeout)
8f608ec0:	e2544001 	subs	r4, r4, #1
8f608ec4:	0a000011 	beq	8f608f10 <sdhci_msm_config_dll+0x100>
	while(!(REG_READ32(host, SDCC_DLL_CONFIG_REG) & SDCC_DLL_CLK_OUT_EN))
8f608ec8:	e5963000 	ldr	r3, [r6]
8f608ecc:	e2832c01 	add	r2, r3, #256	; 0x100
8f608ed0:	e5933100 	ldr	r3, [r3, #256]	; 0x100
8f608ed4:	e3130701 	tst	r3, #262144	; 0x40000
8f608ed8:	0afffff6 	beq	8f608eb8 <sdhci_msm_config_dll+0xa8>
			dprintf(CRITICAL, "%s: clk_out_en timed out: %08x\n", __func__, REG_READ32(host, SDCC_DLL_CONFIG_REG));
			return 1;
		}
	}

	core_cfg = REG_READ32(host, SDCC_DLL_CONFIG_REG);
8f608edc:	e5923000 	ldr	r3, [r2]

	core_cfg |= SDCC_DLL_CDR_EN;
	core_cfg &= ~SDCC_DLL_CDR_EXT_EN;
8f608ee0:	e3c33702 	bic	r3, r3, #524288	; 0x80000
8f608ee4:	e3833802 	orr	r3, r3, #131072	; 0x20000

	REG_WRITE32(host, core_cfg, SDCC_DLL_CONFIG_REG);
8f608ee8:	e5823000 	str	r3, [r2]

	return 0;
}
8f608eec:	e59f3044 	ldr	r3, [pc, #68]	; 8f608f38 <sdhci_msm_config_dll+0x128>
8f608ef0:	e5932000 	ldr	r2, [r3]
8f608ef4:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f608ef8:	e0332002 	eors	r2, r3, r2
8f608efc:	e3a03000 	mov	r3, #0
8f608f00:	1a00000b 	bne	8f608f34 <sdhci_msm_config_dll+0x124>
8f608f04:	e1a00005 	mov	r0, r5
8f608f08:	e28dd048 	add	r13, r13, #72	; 0x48
8f608f0c:	e8bd8070 	pop	{r4, r5, r6, r15}
			dprintf(CRITICAL, "%s: clk_out_en timed out: %08x\n", __func__, REG_READ32(host, SDCC_DLL_CONFIG_REG));
8f608f10:	e5963000 	ldr	r3, [r6]
8f608f14:	e3021264 	movw	r1, #8804	; 0x2264
8f608f18:	e30200a4 	movw	r0, #8356	; 0x20a4
8f608f1c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f608f20:	e3480f70 	movt	r0, #36720	; 0x8f70
			return 1;
8f608f24:	e3a05001 	mov	r5, #1
			dprintf(CRITICAL, "%s: clk_out_en timed out: %08x\n", __func__, REG_READ32(host, SDCC_DLL_CONFIG_REG));
8f608f28:	e5932100 	ldr	r2, [r3, #256]	; 0x100
8f608f2c:	eb00a690 	bl	8f632974 <_dprintf>
			return 1;
8f608f30:	eaffffed 	b	8f608eec <sdhci_msm_config_dll+0xdc>
}
8f608f34:	eb00a721 	bl	8f632bc0 <__stack_chk_fail>
8f608f38:	8f74221c 	.word	0x8f74221c

8f608f3c <msm_set_dll_freq.isra.0>:
	if (host->cur_clk_rate <= 112000000)
8f608f3c:	e3a03b3f 	mov	r3, #64512	; 0xfc00
8f608f40:	e34036ac 	movt	r3, #1708	; 0x6ac
8f608f44:	e1510003 	cmp	r1, r3
static void msm_set_dll_freq(struct sdhci_host *host)
8f608f48:	e59f30dc 	ldr	r3, [pc, #220]	; 8f60902c <msm_set_dll_freq.isra.0+0xf0>
8f608f4c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f608f50:	e24dd00c 	sub	r13, r13, #12
8f608f54:	e5933000 	ldr	r3, [r3]
8f608f58:	e58d3004 	str	r3, [r13, #4]
8f608f5c:	e3a03000 	mov	r3, #0
	if (host->cur_clk_rate <= 112000000)
8f608f60:	93a03000 	movls	r3, #0
8f608f64:	9a000004 	bls	8f608f7c <msm_set_dll_freq.isra.0+0x40>
	else if (host->cur_clk_rate <= 125000000)
8f608f68:	e3053940 	movw	r3, #22848	; 0x5940
8f608f6c:	e3403773 	movt	r3, #1907	; 0x773
8f608f70:	e1510003 	cmp	r1, r3
8f608f74:	93a03401 	movls	r3, #16777216	; 0x1000000
8f608f78:	8a00000b 	bhi	8f608fac <msm_set_dll_freq.isra.0+0x70>
	REG_RMW32(host, SDCC_DLL_CONFIG_REG, SDCC_DLL_CONFIG_MCLK_START, SDCC_DLL_CONFIG_MCLK_WIDTH, reg_val);
8f608f7c:	e5901100 	ldr	r1, [r0, #256]	; 0x100
8f608f80:	e3c11407 	bic	r1, r1, #117440512	; 0x7000000
8f608f84:	e1811003 	orr	r1, r1, r3
}
8f608f88:	e59f309c 	ldr	r3, [pc, #156]	; 8f60902c <msm_set_dll_freq.isra.0+0xf0>
	REG_RMW32(host, SDCC_DLL_CONFIG_REG, SDCC_DLL_CONFIG_MCLK_START, SDCC_DLL_CONFIG_MCLK_WIDTH, reg_val);
8f608f8c:	e5801100 	str	r1, [r0, #256]	; 0x100
}
8f608f90:	e5932000 	ldr	r2, [r3]
8f608f94:	e59d3004 	ldr	r3, [r13, #4]
8f608f98:	e0332002 	eors	r2, r3, r2
8f608f9c:	e3a03000 	mov	r3, #0
8f608fa0:	1a000020 	bne	8f609028 <msm_set_dll_freq.isra.0+0xec>
8f608fa4:	e28dd00c 	add	r13, r13, #12
8f608fa8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	else if (host->cur_clk_rate <= 137000000)
8f608fac:	e3073440 	movw	r3, #29760	; 0x7440
8f608fb0:	e340382a 	movt	r3, #2090	; 0x82a
8f608fb4:	e1510003 	cmp	r1, r3
8f608fb8:	93a03402 	movls	r3, #33554432	; 0x2000000
8f608fbc:	9affffee 	bls	8f608f7c <msm_set_dll_freq.isra.0+0x40>
	else if (host->cur_clk_rate <= 150000000)
8f608fc0:	e30d3180 	movw	r3, #53632	; 0xd180
8f608fc4:	e34038f0 	movt	r3, #2288	; 0x8f0
8f608fc8:	e1510003 	cmp	r1, r3
8f608fcc:	93a03403 	movls	r3, #50331648	; 0x3000000
8f608fd0:	9affffe9 	bls	8f608f7c <msm_set_dll_freq.isra.0+0x40>
	else if (host->cur_clk_rate <= 162000000)
8f608fd4:	e30e3c80 	movw	r3, #60544	; 0xec80
8f608fd8:	e34039a7 	movt	r3, #2471	; 0x9a7
8f608fdc:	e1510003 	cmp	r1, r3
8f608fe0:	93a03301 	movls	r3, #67108864	; 0x4000000
8f608fe4:	9affffe4 	bls	8f608f7c <msm_set_dll_freq.isra.0+0x40>
	else if (host->cur_clk_rate <= 175000000)
8f608fe8:	e30439c0 	movw	r3, #18880	; 0x49c0
8f608fec:	e3403a6e 	movt	r3, #2670	; 0xa6e
8f608ff0:	e1510003 	cmp	r1, r3
8f608ff4:	93a03405 	movls	r3, #83886080	; 0x5000000
8f608ff8:	9affffdf 	bls	8f608f7c <msm_set_dll_freq.isra.0+0x40>
	else if (host->cur_clk_rate <= 187000000)
8f608ffc:	e30634c0 	movw	r3, #25792	; 0x64c0
8f609000:	e3403b25 	movt	r3, #2853	; 0xb25
8f609004:	e1510003 	cmp	r1, r3
8f609008:	93a03406 	movls	r3, #100663296	; 0x6000000
8f60900c:	9affffda 	bls	8f608f7c <msm_set_dll_freq.isra.0+0x40>
	else if (host->cur_clk_rate <= 200000000)
8f609010:	e3a03cc2 	mov	r3, #49664	; 0xc200
8f609014:	e3403beb 	movt	r3, #3051	; 0xbeb
8f609018:	e1510003 	cmp	r1, r3
8f60901c:	93a03407 	movls	r3, #117440512	; 0x7000000
8f609020:	83a03000 	movhi	r3, #0
8f609024:	eaffffd4 	b	8f608f7c <msm_set_dll_freq.isra.0+0x40>
}
8f609028:	eb00a6e4 	bl	8f632bc0 <__stack_chk_fail>
8f60902c:	8f74221c 	.word	0x8f74221c

8f609030 <sdhci_msm_init_dll>:
{
8f609030:	e59f31ec 	ldr	r3, [pc, #492]	; 8f609224 <sdhci_msm_init_dll+0x1f4>
8f609034:	e92d4070 	push	{r4, r5, r6, r14}
8f609038:	e24dd008 	sub	r13, r13, #8
8f60903c:	e5933000 	ldr	r3, [r3]
8f609040:	e58d3004 	str	r3, [r13, #4]
8f609044:	e3a03000 	mov	r3, #0
	pwr_save = REG_READ32(host, SDCC_VENDOR_SPECIFIC_FUNC) & SDCC_DLL_PWR_SAVE_EN;
8f609048:	e5903000 	ldr	r3, [r0]
	if (host->major == 1 && host->minor >= 0x42)
8f60904c:	e5d02010 	ldrb	r2, [r0, #16]
{
8f609050:	e1a05000 	mov	r5, r0
	pwr_save = REG_READ32(host, SDCC_VENDOR_SPECIFIC_FUNC) & SDCC_DLL_PWR_SAVE_EN;
8f609054:	e593610c 	ldr	r6, [r3, #268]	; 0x10c
	if (host->major == 1 && host->minor >= 0x42)
8f609058:	e3520001 	cmp	r2, #1
	pwr_save = REG_READ32(host, SDCC_VENDOR_SPECIFIC_FUNC) & SDCC_DLL_PWR_SAVE_EN;
8f60905c:	e2066002 	and	r6, r6, #2
	if (host->major == 1 && host->minor >= 0x42)
8f609060:	0a00003b 	beq	8f609154 <sdhci_msm_init_dll+0x124>
	if (pwr_save)
8f609064:	e3560000 	cmp	r6, #0
		REG_WRITE32(host, (REG_READ32(host, SDCC_VENDOR_SPECIFIC_FUNC) & ~SDCC_DLL_PWR_SAVE_EN), SDCC_VENDOR_SPECIFIC_FUNC);
8f609068:	1593210c 	ldrne	r2, [r3, #268]	; 0x10c
8f60906c:	13c22002 	bicne	r2, r2, #2
8f609070:	1583210c 	strne	r2, [r3, #268]	; 0x10c
	REG_WRITE32(host, (REG_READ32(host, SDCC_DLL_CONFIG_REG) | SDCC_DLL_RESET_EN), SDCC_DLL_CONFIG_REG);
8f609074:	15953000 	ldrne	r3, [r5]
8f609078:	e5932100 	ldr	r2, [r3, #256]	; 0x100
8f60907c:	e3822101 	orr	r2, r2, #1073741824	; 0x40000000
8f609080:	e5832100 	str	r2, [r3, #256]	; 0x100
	REG_WRITE32(host, (REG_READ32(host, SDCC_DLL_CONFIG_REG) | SDCC_DLL_PDN_EN), SDCC_DLL_CONFIG_REG);
8f609084:	e5952000 	ldr	r2, [r5]
8f609088:	e5923100 	ldr	r3, [r2, #256]	; 0x100
8f60908c:	e3833202 	orr	r3, r3, #536870912	; 0x20000000
8f609090:	e5823100 	str	r3, [r2, #256]	; 0x100
	msm_set_dll_freq(host);
8f609094:	e1c500d0 	ldrd	r0, [r5]
8f609098:	ebffffa7 	bl	8f608f3c <msm_set_dll_freq.isra.0>
	if (host->major == 1 && host->minor >= 0x42)
8f60909c:	e5d53010 	ldrb	r3, [r5, #16]
8f6090a0:	e3530001 	cmp	r3, #1
8f6090a4:	0a000040 	beq	8f6091ac <sdhci_msm_init_dll+0x17c>
	REG_WRITE32(host, (REG_READ32(host, SDCC_DLL_CONFIG_REG) & ~SDCC_DLL_RESET_EN), SDCC_DLL_CONFIG_REG);
8f6090a8:	e5952000 	ldr	r2, [r5]
8f6090ac:	e5923100 	ldr	r3, [r2, #256]	; 0x100
8f6090b0:	e3c33101 	bic	r3, r3, #1073741824	; 0x40000000
8f6090b4:	e5823100 	str	r3, [r2, #256]	; 0x100
	REG_WRITE32(host, (REG_READ32(host, SDCC_DLL_CONFIG_REG) & ~SDCC_DLL_PDN_EN), SDCC_DLL_CONFIG_REG);
8f6090b8:	e5952000 	ldr	r2, [r5]
8f6090bc:	e5923100 	ldr	r3, [r2, #256]	; 0x100
8f6090c0:	e3c33202 	bic	r3, r3, #536870912	; 0x20000000
8f6090c4:	e5823100 	str	r3, [r2, #256]	; 0x100
	if (host->major == 1 && host->minor >= 0x42)
8f6090c8:	e5d53010 	ldrb	r3, [r5, #16]
8f6090cc:	e3530001 	cmp	r3, #1
8f6090d0:	0a00002b 	beq	8f609184 <sdhci_msm_init_dll+0x154>
	REG_WRITE32(host, (REG_READ32(host, SDCC_DLL_CONFIG_REG) | SDCC_DLL_EN), SDCC_DLL_CONFIG_REG);
8f6090d4:	e5952000 	ldr	r2, [r5]
	while(!((REG_READ32(host, SDCC_REG_DLL_STATUS)) & SDCC_DLL_LOCK_STAT))
8f6090d8:	e3a04032 	mov	r4, #50	; 0x32
	REG_WRITE32(host, (REG_READ32(host, SDCC_DLL_CONFIG_REG) | SDCC_DLL_EN), SDCC_DLL_CONFIG_REG);
8f6090dc:	e5923100 	ldr	r3, [r2, #256]	; 0x100
8f6090e0:	e3833801 	orr	r3, r3, #65536	; 0x10000
8f6090e4:	e5823100 	str	r3, [r2, #256]	; 0x100
	REG_WRITE32(host, (REG_READ32(host, SDCC_DLL_CONFIG_REG) | SDCC_DLL_CLK_OUT_EN), SDCC_DLL_CONFIG_REG);
8f6090e8:	e5952000 	ldr	r2, [r5]
8f6090ec:	e5923100 	ldr	r3, [r2, #256]	; 0x100
8f6090f0:	e3833701 	orr	r3, r3, #262144	; 0x40000
8f6090f4:	e5823100 	str	r3, [r2, #256]	; 0x100
	while(!((REG_READ32(host, SDCC_REG_DLL_STATUS)) & SDCC_DLL_LOCK_STAT))
8f6090f8:	ea000003 	b	8f60910c <sdhci_msm_init_dll+0xdc>
		udelay(1);
8f6090fc:	e3a00001 	mov	r0, #1
8f609100:	eb001715 	bl	8f60ed5c <udelay>
		if (!timeout)
8f609104:	e2544001 	subs	r4, r4, #1
8f609108:	0a00003b 	beq	8f6091fc <sdhci_msm_init_dll+0x1cc>
	while(!((REG_READ32(host, SDCC_REG_DLL_STATUS)) & SDCC_DLL_LOCK_STAT))
8f60910c:	e5953000 	ldr	r3, [r5]
8f609110:	e5932108 	ldr	r2, [r3, #264]	; 0x108
8f609114:	e3120080 	tst	r2, #128	; 0x80
8f609118:	0afffff7 	beq	8f6090fc <sdhci_msm_init_dll+0xcc>
	if (pwr_save)
8f60911c:	e3560000 	cmp	r6, #0
		REG_WRITE32(host, (REG_READ32(host, SDCC_VENDOR_SPECIFIC_FUNC) | SDCC_DLL_PWR_SAVE_EN), SDCC_VENDOR_SPECIFIC_FUNC);
8f609120:	1593210c 	ldrne	r2, [r3, #268]	; 0x10c
	return 0;
8f609124:	13a06000 	movne	r6, #0
		REG_WRITE32(host, (REG_READ32(host, SDCC_VENDOR_SPECIFIC_FUNC) | SDCC_DLL_PWR_SAVE_EN), SDCC_VENDOR_SPECIFIC_FUNC);
8f609128:	13822002 	orrne	r2, r2, #2
8f60912c:	1583210c 	strne	r2, [r3, #268]	; 0x10c
}
8f609130:	e59f30ec 	ldr	r3, [pc, #236]	; 8f609224 <sdhci_msm_init_dll+0x1f4>
8f609134:	e5932000 	ldr	r2, [r3]
8f609138:	e59d3004 	ldr	r3, [r13, #4]
8f60913c:	e0332002 	eors	r2, r3, r2
8f609140:	e3a03000 	mov	r3, #0
8f609144:	1a000035 	bne	8f609220 <sdhci_msm_init_dll+0x1f0>
8f609148:	e1a00006 	mov	r0, r6
8f60914c:	e28dd008 	add	r13, r13, #8
8f609150:	e8bd8070 	pop	{r4, r5, r6, r15}
	if (host->major == 1 && host->minor >= 0x42)
8f609154:	e1d021b2 	ldrh	r2, [r0, #18]
8f609158:	e3520041 	cmp	r2, #65	; 0x41
8f60915c:	9affffc0 	bls	8f609064 <sdhci_msm_init_dll+0x34>
		REG_WRITE32(host, (REG_READ32(host, SDCC_DLL_CONFIG_REG) & ~SDCC_DLL_CLK_OUT_EN), SDCC_DLL_CONFIG_REG);
8f609160:	e5932100 	ldr	r2, [r3, #256]	; 0x100
8f609164:	e3c22701 	bic	r2, r2, #262144	; 0x40000
8f609168:	e5832100 	str	r2, [r3, #256]	; 0x100
		REG_WRITE32(host, (REG_READ32(host, SDCC_HC_REG_DLL_CONFIG_2) | SDCC_DLL_CLOCK_DISABLE), SDCC_HC_REG_DLL_CONFIG_2);
8f60916c:	e5902000 	ldr	r2, [r0]
8f609170:	e59231b4 	ldr	r3, [r2, #436]	; 0x1b4
8f609174:	e3833602 	orr	r3, r3, #2097152	; 0x200000
8f609178:	e58231b4 	str	r3, [r2, #436]	; 0x1b4
		REG_WRITE32(host, (REG_READ32(host, SDCC_VENDOR_SPECIFIC_FUNC) & ~SDCC_DLL_PWR_SAVE_EN), SDCC_VENDOR_SPECIFIC_FUNC);
8f60917c:	e5903000 	ldr	r3, [r0]
}
8f609180:	eaffffb7 	b	8f609064 <sdhci_msm_init_dll+0x34>
	if (host->major == 1 && host->minor >= 0x42)
8f609184:	e1d531b2 	ldrh	r3, [r5, #18]
8f609188:	e3530041 	cmp	r3, #65	; 0x41
8f60918c:	9affffd0 	bls	8f6090d4 <sdhci_msm_init_dll+0xa4>
		msm_set_dll_freq(host);
8f609190:	e1c500d0 	ldrd	r0, [r5]
8f609194:	ebffff68 	bl	8f608f3c <msm_set_dll_freq.isra.0>
		REG_WRITE32(host, (REG_READ32(host, SDCC_HC_REG_DLL_CONFIG_2) & ~SDCC_DLL_CLOCK_DISABLE), SDCC_HC_REG_DLL_CONFIG_2);
8f609198:	e5952000 	ldr	r2, [r5]
8f60919c:	e59231b4 	ldr	r3, [r2, #436]	; 0x1b4
8f6091a0:	e3c33602 	bic	r3, r3, #2097152	; 0x200000
8f6091a4:	e58231b4 	str	r3, [r2, #436]	; 0x1b4
8f6091a8:	eaffffc9 	b	8f6090d4 <sdhci_msm_init_dll+0xa4>
	if (host->major == 1 && host->minor >= 0x42)
8f6091ac:	e1d531b2 	ldrh	r3, [r5, #18]
8f6091b0:	e3530041 	cmp	r3, #65	; 0x41
8f6091b4:	9affffbb 	bls	8f6090a8 <sdhci_msm_init_dll+0x78>
		dll_cfg2 = REG_READ32(host, SDCC_HC_REG_DLL_CONFIG_2);
8f6091b8:	e5951000 	ldr	r1, [r5]
			mclk_clk_freq = (host->cur_clk_rate / TCXO_FREQ) * 8;
8f6091bc:	e3012d85 	movw	r2, #7557	; 0x1d85
8f6091c0:	e3462fd9 	movt	r2, #28633	; 0x6fd9
		udelay(5);
8f6091c4:	e3a00005 	mov	r0, #5
		dll_cfg2 = REG_READ32(host, SDCC_HC_REG_DLL_CONFIG_2);
8f6091c8:	e59131b4 	ldr	r3, [r1, #436]	; 0x1b4
		if (dll_cfg2 & SDCC_FLL_CYCLE_CNT)
8f6091cc:	e3130701 	tst	r3, #262144	; 0x40000
			mclk_clk_freq = (host->cur_clk_rate / TCXO_FREQ) * 8;
8f6091d0:	e5953004 	ldr	r3, [r5, #4]
8f6091d4:	e0832392 	umull	r2, r3, r2, r3
		REG_WRITE32(host, ((REG_READ32(host, SDCC_HC_REG_DLL_CONFIG_2) & ~(0xFF << 10)) | (mclk_clk_freq << 10)), SDCC_HC_REG_DLL_CONFIG_2);
8f6091d8:	e59121b4 	ldr	r2, [r1, #436]	; 0x1b4
8f6091dc:	e3c22bff 	bic	r2, r2, #261120	; 0x3fc00
			mclk_clk_freq = (host->cur_clk_rate / TCXO_FREQ) * 8;
8f6091e0:	e1a03ba3 	lsr	r3, r3, #23
8f6091e4:	11a03183 	lslne	r3, r3, #3
			mclk_clk_freq = (host->cur_clk_rate / TCXO_FREQ) * 4;
8f6091e8:	01a03103 	lsleq	r3, r3, #2
		REG_WRITE32(host, ((REG_READ32(host, SDCC_HC_REG_DLL_CONFIG_2) & ~(0xFF << 10)) | (mclk_clk_freq << 10)), SDCC_HC_REG_DLL_CONFIG_2);
8f6091ec:	e1823503 	orr	r3, r2, r3, lsl #10
8f6091f0:	e58131b4 	str	r3, [r1, #436]	; 0x1b4
		udelay(5);
8f6091f4:	eb0016d8 	bl	8f60ed5c <udelay>
8f6091f8:	eaffffaa 	b	8f6090a8 <sdhci_msm_init_dll+0x78>
			dprintf(CRITICAL, "%s: Failed to get DLL lock: 0x%08x\n", __func__, REG_READ32(host, SDCC_REG_DLL_STATUS));
8f6091fc:	e5953000 	ldr	r3, [r5]
8f609200:	e302127c 	movw	r1, #8828	; 0x227c
8f609204:	e30200c4 	movw	r0, #8388	; 0x20c4
8f609208:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60920c:	e3480f70 	movt	r0, #36720	; 0x8f70
			return 1;
8f609210:	e3a06001 	mov	r6, #1
			dprintf(CRITICAL, "%s: Failed to get DLL lock: 0x%08x\n", __func__, REG_READ32(host, SDCC_REG_DLL_STATUS));
8f609214:	e5932108 	ldr	r2, [r3, #264]	; 0x108
8f609218:	eb00a5d5 	bl	8f632974 <_dprintf>
			return 1;
8f60921c:	eaffffc3 	b	8f609130 <sdhci_msm_init_dll+0x100>
}
8f609220:	eb00a666 	bl	8f632bc0 <__stack_chk_fail>
8f609224:	8f74221c 	.word	0x8f74221c

8f609228 <sdhci_msm_init>:
	REG_WRITE32(host, 0xA1C, SDCC_VENDOR_SPECIFIC_FUNC);
8f609228:	e5903000 	ldr	r3, [r0]
{
8f60922c:	e59f212c 	ldr	r2, [pc, #300]	; 8f609360 <sdhci_msm_init+0x138>
8f609230:	e92d4030 	push	{r4, r5, r14}
8f609234:	e24dd00c 	sub	r13, r13, #12
8f609238:	e5922000 	ldr	r2, [r2]
8f60923c:	e58d2004 	str	r2, [r13, #4]
8f609240:	e3a02000 	mov	r2, #0
	REG_WRITE32(host, 0xA1C, SDCC_VENDOR_SPECIFIC_FUNC);
8f609244:	e3002a1c 	movw	r2, #2588	; 0xa1c
8f609248:	e583210c 	str	r2, [r3, #268]	; 0x10c
{
8f60924c:	e1a04001 	mov	r4, r1
	RMWREG32((config->pwrctl_base + SDCC_MCI_HC_MODE), SDHCI_HC_START_BIT, SDHCI_HC_WIDTH, SDHCI_HC_MODE_EN);
8f609250:	e5912000 	ldr	r2, [r1]
{
8f609254:	e1a05000 	mov	r5, r0
	RMWREG32((config->pwrctl_base + SDCC_MCI_HC_MODE), SDHCI_HC_START_BIT, SDHCI_HC_WIDTH, SDHCI_HC_MODE_EN);
8f609258:	e5923078 	ldr	r3, [r2, #120]	; 0x78
8f60925c:	e3833001 	orr	r3, r3, #1
8f609260:	e5823078 	str	r3, [r2, #120]	; 0x78
	RMWREG32((config->pwrctl_base + SDCC_MCI_HC_MODE), FF_CLK_SW_RST_DIS_START, FF_CLK_SW_RST_DIS_WIDTH, 1);
8f609264:	e5912000 	ldr	r2, [r1]
	sdhci_reset(host, SDHCI_SOFT_RESET);
8f609268:	e3a01001 	mov	r1, #1
	RMWREG32((config->pwrctl_base + SDCC_MCI_HC_MODE), FF_CLK_SW_RST_DIS_START, FF_CLK_SW_RST_DIS_WIDTH, 1);
8f60926c:	e5923078 	ldr	r3, [r2, #120]	; 0x78
8f609270:	e3833a02 	orr	r3, r3, #8192	; 0x2000
8f609274:	e5823078 	str	r3, [r2, #120]	; 0x78
	sdhci_reset(host, SDHCI_SOFT_RESET);
8f609278:	ebfffb2f 	bl	8f607f3c <sdhci_reset>
	if(config->use_io_switch)
8f60927c:	e5d4300c 	ldrb	r3, [r4, #12]
8f609280:	e3530000 	cmp	r3, #0
		io_switch = REG_READ32(host, SDCC_VENDOR_SPECIFIC_FUNC);
8f609284:	15952000 	ldrne	r2, [r5]
8f609288:	1592310c 	ldrne	r3, [r2, #268]	; 0x10c
		io_switch |= HC_IO_PAD_PWR_SWITCH | HC_IO_PAD_PWR_SWITCH_EN;
8f60928c:	13833906 	orrne	r3, r3, #98304	; 0x18000
		REG_WRITE32(host, io_switch, SDCC_VENDOR_SPECIFIC_FUNC);
8f609290:	1582310c 	strne	r3, [r2, #268]	; 0x10c
	irq_stat = readl(data->pwrctl_base + SDCC_HC_PWRCTL_STATUS_REG);
8f609294:	e5943000 	ldr	r3, [r4]
8f609298:	e59320dc 	ldr	r2, [r3, #220]	; 0xdc
	if (irq_stat & (SDCC_HC_BUS_ON | SDCC_HC_BUS_OFF))
8f60929c:	e3120003 	tst	r2, #3
	writel(irq_stat, (data->pwrctl_base + SDCC_HC_PWRCTL_CLEAR_REG));
8f6092a0:	e58320e4 	str	r2, [r3, #228]	; 0xe4
	irq_ctl = readl(data->pwrctl_base + SDCC_HC_PWRCTL_CTL_REG);
8f6092a4:	e5941000 	ldr	r1, [r4]
8f6092a8:	e59130e8 	ldr	r3, [r1, #232]	; 0xe8
		irq_ctl |= SDCC_HC_BUS_ON_OFF_SUCC;
8f6092ac:	13833001 	orrne	r3, r3, #1
	if (irq_stat & (SDCC_HC_IO_SIG_LOW | SDCC_HC_IO_SIG_HIGH))
8f6092b0:	e312000c 	tst	r2, #12
		irq_ctl |= SDCC_HC_IO_SIG_SUCC;
8f6092b4:	13833004 	orrne	r3, r3, #4
	register_int_handler(config->pwr_irq, (int_handler)sdhci_int_handler, (void *)config);
8f6092b8:	e1a02004 	mov	r2, r4
	writel(irq_ctl, (data->pwrctl_base + SDCC_HC_PWRCTL_CTL_REG));
8f6092bc:	e58130e8 	str	r3, [r1, #232]	; 0xe8
	register_int_handler(config->pwr_irq, (int_handler)sdhci_int_handler, (void *)config);
8f6092c0:	e3081da8 	movw	r1, #36264	; 0x8da8
8f6092c4:	e5940004 	ldr	r0, [r4, #4]
8f6092c8:	e3481f60 	movt	r1, #36704	; 0x8f60
8f6092cc:	eb0017ee 	bl	8f60f28c <register_int_handler>
	unmask_interrupt(config->pwr_irq);
8f6092d0:	e5940004 	ldr	r0, [r4, #4]
8f6092d4:	eb0017db 	bl	8f60f248 <unmask_interrupt>
	writel(SDCC_HC_PWR_CTRL_INT, (config->pwrctl_base + SDCC_HC_PWRCTL_MASK_REG));
8f6092d8:	e5942000 	ldr	r2, [r4]
	version = readl(host->msm_host->pwrctl_base + MCI_VERSION);
8f6092dc:	e5953030 	ldr	r3, [r5, #48]	; 0x30
	writel(SDCC_HC_PWR_CTRL_INT, (config->pwrctl_base + SDCC_HC_PWRCTL_MASK_REG));
8f6092e0:	e3a0100f 	mov	r1, #15
8f6092e4:	e58210e0 	str	r1, [r2, #224]	; 0xe0
	version = readl(host->msm_host->pwrctl_base + MCI_VERSION);
8f6092e8:	e5933000 	ldr	r3, [r3]
8f6092ec:	e5933050 	ldr	r3, [r3, #80]	; 0x50
	host->minor = (version & CORE_VERSION_MINOR_MASK);
8f6092f0:	e6ef2073 	uxtb	r2, r3
	host->major = (version & CORE_VERSION_MAJOR_MASK) >> CORE_VERSION_MAJOR_SHIFT;
8f6092f4:	e1a03e23 	lsr	r3, r3, #28
	if (host->major >= 1 && host->minor != 0x11 && host->minor != 0x12)
8f6092f8:	e2421011 	sub	r1, r2, #17
	host->major = (version & CORE_VERSION_MAJOR_MASK) >> CORE_VERSION_MAJOR_SHIFT;
8f6092fc:	e5c53010 	strb	r3, [r5, #16]
	if (host->major >= 1 && host->minor != 0x11 && host->minor != 0x12)
8f609300:	e3530000 	cmp	r3, #0
8f609304:	13510001 	cmpne	r1, #1
	host->minor = (version & CORE_VERSION_MINOR_MASK);
8f609308:	e1c521b2 	strh	r2, [r5, #18]
	if (host->major >= 1 && host->minor != 0x11 && host->minor != 0x12)
8f60930c:	8a00000a 	bhi	8f60933c <sdhci_msm_init+0x114>
	config->tuning_done = false;
8f609310:	e3a03000 	mov	r3, #0
8f609314:	e1c430b8 	strh	r3, [r4, #8]
	host->tuning_in_progress = false;
8f609318:	e585300c 	str	r3, [r5, #12]
}
8f60931c:	e59f303c 	ldr	r3, [pc, #60]	; 8f609360 <sdhci_msm_init+0x138>
8f609320:	e5932000 	ldr	r2, [r3]
8f609324:	e59d3004 	ldr	r3, [r13, #4]
8f609328:	e0332002 	eors	r2, r3, r2
8f60932c:	e3a03000 	mov	r3, #0
8f609330:	1a000009 	bne	8f60935c <sdhci_msm_init+0x134>
8f609334:	e28dd00c 	add	r13, r13, #12
8f609338:	e8bd8030 	pop	{r4, r5, r15}
		caps = REG_READ32(host, SDHCI_CAPS_REG1);
8f60933c:	e5952000 	ldr	r2, [r5]
		if (config->slot == 0x1)
8f609340:	e5d4300b 	ldrb	r3, [r4, #11]
8f609344:	e3530001 	cmp	r3, #1
		caps = REG_READ32(host, SDHCI_CAPS_REG1);
8f609348:	e5923040 	ldr	r3, [r2, #64]	; 0x40
			REG_WRITE32(host, (caps | SDHCI_1_8_VOL_MASK), SDCC_HC_VENDOR_SPECIFIC_CAPABILITIES0);
8f60934c:	03833301 	orreq	r3, r3, #67108864	; 0x4000000
			REG_WRITE32(host, (caps | SDHCI_3_0_VOL_MASK), SDCC_HC_VENDOR_SPECIFIC_CAPABILITIES0);
8f609350:	13833402 	orrne	r3, r3, #33554432	; 0x2000000
8f609354:	e582311c 	str	r3, [r2, #284]	; 0x11c
8f609358:	eaffffec 	b	8f609310 <sdhci_msm_init+0xe8>
}
8f60935c:	eb00a617 	bl	8f632bc0 <__stack_chk_fail>
8f609360:	8f74221c 	.word	0x8f74221c

8f609364 <sdhci_msm_set_mci_clk>:
{
8f609364:	e59f30b0 	ldr	r3, [pc, #176]	; 8f60941c <sdhci_msm_set_mci_clk+0xb8>
8f609368:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60936c:	e24dd00c 	sub	r13, r13, #12
8f609370:	e5933000 	ldr	r3, [r3]
8f609374:	e58d3004 	str	r3, [r13, #4]
8f609378:	e3a03000 	mov	r3, #0
	if (host->timing == MMC_HS400_TIMING)
8f60937c:	e5903008 	ldr	r3, [r0, #8]
		REG_RMW32(host, SDCC_VENDOR_SPECIFIC_FUNC, SDCC_HC_MCLK_HS400_START, SDCC_HC_MCLK_HS400_WIDTH, SDCC_HC_MCLK_SEL_HS400);
8f609380:	e5902000 	ldr	r2, [r0]
	if (host->timing == MMC_HS400_TIMING)
8f609384:	e3530003 	cmp	r3, #3
8f609388:	0a00000e 	beq	8f6093c8 <sdhci_msm_set_mci_clk+0x64>
		REG_RMW32(host, SDCC_VENDOR_SPECIFIC_FUNC, SDCC_HC_MCLK_SEL_IN_START, SDCC_HC_MCLK_SEL_IN_WIDTH, 0x0);
8f60938c:	e592310c 	ldr	r3, [r2, #268]	; 0x10c
8f609390:	e3c3370e 	bic	r3, r3, #3670016	; 0x380000
8f609394:	e582310c 	str	r3, [r2, #268]	; 0x10c
		REG_RMW32(host, SDCC_VENDOR_SPECIFIC_FUNC, SDCC_HC_MCLK_SEL_IN_EN_START, SDCC_HC_MCLK_SEL_IN_EN_WIDTH, 0x0);
8f609398:	e5902000 	ldr	r2, [r0]
8f60939c:	e592310c 	ldr	r3, [r2, #268]	; 0x10c
8f6093a0:	e3c33701 	bic	r3, r3, #262144	; 0x40000
8f6093a4:	e582310c 	str	r3, [r2, #268]	; 0x10c
}
8f6093a8:	e59f306c 	ldr	r3, [pc, #108]	; 8f60941c <sdhci_msm_set_mci_clk+0xb8>
8f6093ac:	e5932000 	ldr	r2, [r3]
8f6093b0:	e59d3004 	ldr	r3, [r13, #4]
8f6093b4:	e0332002 	eors	r2, r3, r2
8f6093b8:	e3a03000 	mov	r3, #0
8f6093bc:	1a000015 	bne	8f609418 <sdhci_msm_set_mci_clk+0xb4>
8f6093c0:	e28dd00c 	add	r13, r13, #12
8f6093c4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	msm_host = host->msm_host;
8f6093c8:	e5901030 	ldr	r1, [r0, #48]	; 0x30
		REG_RMW32(host, SDCC_VENDOR_SPECIFIC_FUNC, SDCC_HC_MCLK_HS400_START, SDCC_HC_MCLK_HS400_WIDTH, SDCC_HC_MCLK_SEL_HS400);
8f6093cc:	e592310c 	ldr	r3, [r2, #268]	; 0x10c
8f6093d0:	e3833c03 	orr	r3, r3, #768	; 0x300
8f6093d4:	e582310c 	str	r3, [r2, #268]	; 0x10c
		if (msm_host->tuning_done && !msm_host->calibration_done)
8f6093d8:	e5d13008 	ldrb	r3, [r1, #8]
8f6093dc:	e3530000 	cmp	r3, #0
8f6093e0:	0afffff0 	beq	8f6093a8 <sdhci_msm_set_mci_clk+0x44>
8f6093e4:	e5d13009 	ldrb	r3, [r1, #9]
8f6093e8:	e3530000 	cmp	r3, #0
8f6093ec:	1affffed 	bne	8f6093a8 <sdhci_msm_set_mci_clk+0x44>
			REG_RMW32(host, SDCC_VENDOR_SPECIFIC_FUNC, SDCC_HC_MCLK_SEL_IN_START, SDCC_HC_MCLK_SEL_IN_WIDTH, SDCC_HC_MCLK_SEL_IN_HS400);
8f6093f0:	e5902000 	ldr	r2, [r0]
8f6093f4:	e592310c 	ldr	r3, [r2, #268]	; 0x10c
8f6093f8:	e3c3370e 	bic	r3, r3, #3670016	; 0x380000
8f6093fc:	e3833603 	orr	r3, r3, #3145728	; 0x300000
8f609400:	e582310c 	str	r3, [r2, #268]	; 0x10c
			REG_RMW32(host, SDCC_VENDOR_SPECIFIC_FUNC, SDCC_HC_MCLK_SEL_IN_EN_START, SDCC_HC_MCLK_SEL_IN_EN_WIDTH, SDCC_HC_MCLK_SEL_IN_EN);
8f609404:	e5902000 	ldr	r2, [r0]
8f609408:	e592310c 	ldr	r3, [r2, #268]	; 0x10c
8f60940c:	e3833701 	orr	r3, r3, #262144	; 0x40000
8f609410:	e582310c 	str	r3, [r2, #268]	; 0x10c
8f609414:	eaffffe3 	b	8f6093a8 <sdhci_msm_set_mci_clk+0x44>
}
8f609418:	eb00a5e8 	bl	8f632bc0 <__stack_chk_fail>
8f60941c:	8f74221c 	.word	0x8f74221c

8f609420 <sdhci_msm_toggle_cdr>:
{
8f609420:	e59f3054 	ldr	r3, [pc, #84]	; 8f60947c <sdhci_msm_toggle_cdr+0x5c>
	if (enable)
8f609424:	e3510000 	cmp	r1, #0
{
8f609428:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60942c:	e24dd00c 	sub	r13, r13, #12
	core_cfg = REG_READ32(host, SDCC_DLL_CONFIG_REG);
8f609430:	e5902000 	ldr	r2, [r0]
{
8f609434:	e5933000 	ldr	r3, [r3]
8f609438:	e58d3004 	str	r3, [r13, #4]
8f60943c:	e3a03000 	mov	r3, #0
	core_cfg = REG_READ32(host, SDCC_DLL_CONFIG_REG);
8f609440:	e5923100 	ldr	r3, [r2, #256]	; 0x100
		core_cfg &= ~SDCC_DLL_CDR_EXT_EN;
8f609444:	13c33702 	bicne	r3, r3, #524288	; 0x80000
		core_cfg &= ~SDCC_DLL_CDR_EN;
8f609448:	03c33802 	biceq	r3, r3, #131072	; 0x20000
		core_cfg &= ~SDCC_DLL_CDR_EXT_EN;
8f60944c:	13833802 	orrne	r3, r3, #131072	; 0x20000
		core_cfg |= SDCC_DLL_CDR_EXT_EN;
8f609450:	03833702 	orreq	r3, r3, #524288	; 0x80000
	REG_WRITE32(host, core_cfg, SDCC_DLL_CONFIG_REG);
8f609454:	e5823100 	str	r3, [r2, #256]	; 0x100
}
8f609458:	e59f301c 	ldr	r3, [pc, #28]	; 8f60947c <sdhci_msm_toggle_cdr+0x5c>
8f60945c:	e5932000 	ldr	r2, [r3]
8f609460:	e59d3004 	ldr	r3, [r13, #4]
8f609464:	e0332002 	eors	r2, r3, r2
8f609468:	e3a03000 	mov	r3, #0
8f60946c:	1a000001 	bne	8f609478 <sdhci_msm_toggle_cdr+0x58>
8f609470:	e28dd00c 	add	r13, r13, #12
8f609474:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f609478:	eb00a5d0 	bl	8f632bc0 <__stack_chk_fail>
8f60947c:	8f74221c 	.word	0x8f74221c

8f609480 <sdhci_msm_execute_tuning>:
 * Arg     : Host structure & bus width
 * Return  : 0 on Success, 1 on Failure
 * Flow:   : Execute Tuning sequence for HS200 and calibration for hs400
 */
uint32_t sdhci_msm_execute_tuning(struct sdhci_host *host, struct mmc_card *card, uint32_t bus_width)
{
8f609480:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f609484:	e24dde53 	sub	r13, r13, #1328	; 0x530
8f609488:	e24dd00c 	sub	r13, r13, #12
8f60948c:	e59f37f4 	ldr	r3, [pc, #2036]	; 8f609c88 <sdhci_msm_execute_tuning+0x808>
8f609490:	e1a05000 	mov	r5, r0
8f609494:	e1a06002 	mov	r6, r2
8f609498:	e58d1010 	str	r1, [r13, #16]
	uint32_t *tuning_block;
	uint32_t *tuning_data;
	uint32_t tuned_phases[MAX_PHASES] = {0};
8f60949c:	e3a02040 	mov	r2, #64	; 0x40
8f6094a0:	e3a01000 	mov	r1, #0
8f6094a4:	e28d0020 	add	r0, r13, #32
{
8f6094a8:	e5933000 	ldr	r3, [r3]
8f6094ac:	e58d3534 	str	r3, [r13, #1332]	; 0x534
8f6094b0:	e3a03000 	mov	r3, #0
	uint32_t tuned_phases[MAX_PHASES] = {0};
8f6094b4:	e1a0400e 	mov	r4, r14
8f6094b8:	eb00ab81 	bl	8f6342c4 <memset>
		size = sizeof(tuning_block_128);
	}
	else
	{
		tuning_block = (uint32_t *)tuning_block_64;
		size = sizeof(tuning_block_64);
8f6094bc:	e3560002 	cmp	r6, #2
8f6094c0:	e3022290 	movw	r2, #8848	; 0x2290
8f6094c4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6094c8:	03a0b080 	moveq	r11, #128	; 0x80
8f6094cc:	13a0b040 	movne	r11, #64	; 0x40
	host->tuning_in_progress = true;
8f6094d0:	e3a03001 	mov	r3, #1
	}

	tuning_data = (uint32_t *) memalign(CACHE_LINE, ROUNDUP(size, CACHE_LINE));
8f6094d4:	e1a0100b 	mov	r1, r11
	host->tuning_in_progress = true;
8f6094d8:	e585300c 	str	r3, [r5, #12]
	tuning_data = (uint32_t *) memalign(CACHE_LINE, ROUNDUP(size, CACHE_LINE));
8f6094dc:	e3a00040 	mov	r0, #64	; 0x40
	msm_host = host->msm_host;
8f6094e0:	e5956030 	ldr	r6, [r5, #48]	; 0x30
		size = sizeof(tuning_block_64);
8f6094e4:	e3023310 	movw	r3, #8976	; 0x2310
8f6094e8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6094ec:	01a03002 	moveq	r3, r2
8f6094f0:	e58d300c 	str	r3, [r13, #12]
	tuning_data = (uint32_t *) memalign(CACHE_LINE, ROUNDUP(size, CACHE_LINE));
8f6094f4:	eb00aad2 	bl	8f634044 <memalign>

	ASSERT(tuning_data);
8f6094f8:	e250a000 	subs	r10, r0, #0
8f6094fc:	0a000181 	beq	8f609b08 <sdhci_msm_execute_tuning+0x688>

	/* Calibration for CDCLP533 needed for HS400 mode */
	if (msm_host->tuning_done && !msm_host->calibration_done && host->timing == MMC_HS400_TIMING)
8f609500:	e5d63008 	ldrb	r3, [r6, #8]
8f609504:	e3530000 	cmp	r3, #0
8f609508:	0a000002 	beq	8f609518 <sdhci_msm_execute_tuning+0x98>
8f60950c:	e5d63009 	ldrb	r3, [r6, #9]
8f609510:	e3530000 	cmp	r3, #0
8f609514:	0a000065 	beq	8f6096b0 <sdhci_msm_execute_tuning+0x230>
			msm_host->calibration_done = true;
		goto out;
	}

	/* Reset & Initialize the DLL block */
	if (sdhci_msm_init_dll(host))
8f609518:	e1a00005 	mov	r0, r5
8f60951c:	ebfffec3 	bl	8f609030 <sdhci_msm_init_dll>
8f609520:	e3500000 	cmp	r0, #0
8f609524:	1a00004a 	bne	8f609654 <sdhci_msm_execute_tuning+0x1d4>
		cmd.cmd_index = CMD21_SEND_TUNING_BLOCK;
		cmd.argument = 0x0;
		cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
		cmd.resp_type = SDHCI_CMD_RESP_R1;
		cmd.trans_mode = SDHCI_MMC_READ;
		cmd.data_present = 0x1;
8f609528:	e3a03001 	mov	r3, #1
	bool drv_type_changed = false;
8f60952c:	e58d0014 	str	r0, [r13, #20]
		cmd.data_present = 0x1;
8f609530:	e3403001 	movt	r3, #1
	uint8_t drv_type = 0;
8f609534:	e58d001c 	str	r0, [r13, #28]
		cmd.data_present = 0x1;
8f609538:	e58d3018 	str	r3, [r13, #24]
	struct mmc_command cmd = {0};
8f60953c:	e3a02048 	mov	r2, #72	; 0x48
8f609540:	e3a01000 	mov	r1, #0
8f609544:	e28d00a0 	add	r0, r13, #160	; 0xa0
	tuned_phase_cnt = 0;
8f609548:	e3a06000 	mov	r6, #0
	struct mmc_command cmd = {0};
8f60954c:	eb00ab5c 	bl	8f6342c4 <memset>
	struct mmc_command sts_cmd = {0};
8f609550:	e28d00e8 	add	r0, r13, #232	; 0xe8
8f609554:	e3a02048 	mov	r2, #72	; 0x48
8f609558:	e3a01000 	mov	r1, #0
8f60955c:	eb00ab58 	bl	8f6342c4 <memset>
		cmd.cmd_index = CMD21_SEND_TUNING_BLOCK;
8f609560:	e28d80a0 	add	r8, r13, #160	; 0xa0
8f609564:	e59d9018 	ldr	r9, [r13, #24]
	tuned_phase_cnt = 0;
8f609568:	e58d6008 	str	r6, [r13, #8]
8f60956c:	ea00000f 	b	8f6095b0 <sdhci_msm_execute_tuning+0x130>
				}
				break;
			}
		}

		if (!err && !memcmp(tuning_data, tuning_block, size))
8f609570:	e59d100c 	ldr	r1, [r13, #12]
8f609574:	e1a0200b 	mov	r2, r11
8f609578:	e1a0000a 	mov	r0, r10
8f60957c:	eb00ab95 	bl	8f6343d8 <memcmp>
8f609580:	e3500000 	cmp	r0, #0
8f609584:	1a000006 	bne	8f6095a4 <sdhci_msm_execute_tuning+0x124>
				tuned_phases[tuned_phase_cnt++] = phase;
8f609588:	e59d2008 	ldr	r2, [r13, #8]
8f60958c:	e28d3e53 	add	r3, r13, #1328	; 0x530
8f609590:	e2833008 	add	r3, r3, #8
8f609594:	e0833102 	add	r3, r3, r2, lsl #2
8f609598:	e5036518 	str	r6, [r3, #-1304]	; 0xfffffae8
8f60959c:	e2823001 	add	r3, r2, #1
8f6095a0:	e58d3008 	str	r3, [r13, #8]

		phase++;
8f6095a4:	e2866001 	add	r6, r6, #1
	while (phase < MAX_PHASES)
8f6095a8:	e3560010 	cmp	r6, #16
8f6095ac:	0a0000ab 	beq	8f609860 <sdhci_msm_execute_tuning+0x3e0>
		if (sdhci_msm_config_dll(host, phase))
8f6095b0:	e1a01006 	mov	r1, r6
8f6095b4:	e1a00005 	mov	r0, r5
8f6095b8:	ebfffe14 	bl	8f608e10 <sdhci_msm_config_dll>
8f6095bc:	e2504000 	subs	r4, r0, #0
8f6095c0:	1a000023 	bne	8f609654 <sdhci_msm_execute_tuning+0x1d4>
		err = sdhci_send_command(host, &cmd);
8f6095c4:	e1a01008 	mov	r1, r8
8f6095c8:	e1a00005 	mov	r0, r5
		cmd.cmd_index = CMD21_SEND_TUNING_BLOCK;
8f6095cc:	e3a03015 	mov	r3, #21
		cmd.trans_mode = SDHCI_MMC_READ;
8f6095d0:	e3a07001 	mov	r7, #1
		cmd.cmd_index = CMD21_SEND_TUNING_BLOCK;
8f6095d4:	e1c830b0 	strh	r3, [r8]
		cmd.argument = 0x0;
8f6095d8:	e58d40a4 	str	r4, [r13, #164]	; 0xa4
		cmd.data_present = 0x1;
8f6095dc:	e58d90a8 	str	r9, [r13, #168]	; 0xa8
		cmd.data.blk_sz = size;
8f6095e0:	e1cdadf4 	strd	r10, [r13, #212]	; 0xd4
		cmd.trans_mode = SDHCI_MMC_READ;
8f6095e4:	e58d70bc 	str	r7, [r13, #188]	; 0xbc
		cmd.data.num_blocks = 0x1;
8f6095e8:	e58d70dc 	str	r7, [r13, #220]	; 0xdc
		err = sdhci_send_command(host, &cmd);
8f6095ec:	ebfffb1e 	bl	8f60826c <sdhci_send_command>
		if(err)
8f6095f0:	e3500000 	cmp	r0, #0
8f6095f4:	0affffdd 	beq	8f609570 <sdhci_msm_execute_tuning+0xf0>
			sts_cmd.argument = card->rca << 16;
8f6095f8:	e59d3010 	ldr	r3, [r13, #16]
			sts_cmd.resp_type = SDHCI_CMD_RESP_R1;
8f6095fc:	e1cd7fb2 	strh	r7, [r13, #242]	; 0xf2
8f609600:	e3a07032 	mov	r7, #50	; 0x32
			sts_cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f609604:	e5cd40f1 	strb	r4, [r13, #241]	; 0xf1
			sts_cmd.argument = card->rca << 16;
8f609608:	e5933000 	ldr	r3, [r3]
8f60960c:	e1a03803 	lsl	r3, r3, #16
8f609610:	e58d30ec 	str	r3, [r13, #236]	; 0xec
			sts_cmd.cmd_index = CMD13_SEND_STATUS;
8f609614:	e3a0300d 	mov	r3, #13
8f609618:	e1cd3eb8 	strh	r3, [r13, #232]	; 0xe8
				sts_err = sdhci_send_command(host, &sts_cmd);
8f60961c:	e28d10e8 	add	r1, r13, #232	; 0xe8
8f609620:	e1a00005 	mov	r0, r5
8f609624:	ebfffb10 	bl	8f60826c <sdhci_send_command>
				if( sts_err || (MMC_CARD_STATUS(sts_cmd.resp[0]) != MMC_TRAN_STATE) )
8f609628:	e3500000 	cmp	r0, #0
8f60962c:	1a000003 	bne	8f609640 <sdhci_msm_execute_tuning+0x1c0>
8f609630:	e59d30f4 	ldr	r3, [r13, #244]	; 0xf4
8f609634:	e7e334d3 	ubfx	r3, r3, #9, #4
8f609638:	e3530004 	cmp	r3, #4
8f60963c:	0affffd8 	beq	8f6095a4 <sdhci_msm_execute_tuning+0x124>
					udelay(10);
8f609640:	e3a0000a 	mov	r0, #10
8f609644:	eb0015c4 	bl	8f60ed5c <udelay>
			while(sts_retry)
8f609648:	e2577001 	subs	r7, r7, #1
8f60964c:	1afffff2 	bne	8f60961c <sdhci_msm_execute_tuning+0x19c>
8f609650:	eaffffd3 	b	8f6095a4 <sdhci_msm_execute_tuning+0x124>
8f609654:	e30c6bd8 	movw	r6, #52184	; 0xcbd8
8f609658:	e3486f72 	movt	r6, #36722	; 0x8f72
			if (phases_per_row[i] > max_phases)
8f60965c:	e3a04001 	mov	r4, #1

out:
	/* If all the tuning phases passed, send CMD21 after enabling
	 * CDR to make sure right tuning phase is selected by CDR
	 */
	if (attempt_cdr_unlock)
8f609660:	e5963000 	ldr	r3, [r6]
8f609664:	e3530000 	cmp	r3, #0
8f609668:	1a000113 	bne	8f609abc <sdhci_msm_execute_tuning+0x63c>
		{
			DBG("\n: %s: Sending CMD21 after CDR enable with default phases fail\n", __func__);
		}
	}

	free(tuning_data);
8f60966c:	e1a0000a 	mov	r0, r10
8f609670:	eb00aaa5 	bl	8f63410c <free>
	/* Tuning done */
	host->tuning_in_progress = false;
	host->msm_host->tuning_done = true;
8f609674:	e5953030 	ldr	r3, [r5, #48]	; 0x30
8f609678:	e3a02001 	mov	r2, #1
	host->tuning_in_progress = false;
8f60967c:	e3a01000 	mov	r1, #0
8f609680:	e585100c 	str	r1, [r5, #12]
	host->msm_host->tuning_done = true;
8f609684:	e5c32008 	strb	r2, [r3, #8]
	return ret;
}
8f609688:	e59f35f8 	ldr	r3, [pc, #1528]	; 8f609c88 <sdhci_msm_execute_tuning+0x808>
8f60968c:	e5932000 	ldr	r2, [r3]
8f609690:	e59d3534 	ldr	r3, [r13, #1332]	; 0x534
8f609694:	e0332002 	eors	r2, r3, r2
8f609698:	e3a03000 	mov	r3, #0
8f60969c:	1a000173 	bne	8f609c70 <sdhci_msm_execute_tuning+0x7f0>
8f6096a0:	e1a00004 	mov	r0, r4
8f6096a4:	e28dde53 	add	r13, r13, #1328	; 0x530
8f6096a8:	e28dd00c 	add	r13, r13, #12
8f6096ac:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	if (msm_host->tuning_done && !msm_host->calibration_done && host->timing == MMC_HS400_TIMING)
8f6096b0:	e5953008 	ldr	r3, [r5, #8]
8f6096b4:	e3530003 	cmp	r3, #3
8f6096b8:	1affff96 	bne	8f609518 <sdhci_msm_execute_tuning+0x98>
	if (sdhci_msm_init_dll(host))
8f6096bc:	e1a00005 	mov	r0, r5
8f6096c0:	ebfffe5a 	bl	8f609030 <sdhci_msm_init_dll>
8f6096c4:	e3500000 	cmp	r0, #0
8f6096c8:	1affffe1 	bne	8f609654 <sdhci_msm_execute_tuning+0x1d4>
	if (sdhci_msm_config_dll(host, host->msm_host->saved_phase))
8f6096cc:	e5953030 	ldr	r3, [r5, #48]	; 0x30
8f6096d0:	e1a00005 	mov	r0, r5
8f6096d4:	e5d3100a 	ldrb	r1, [r3, #10]
8f6096d8:	ebfffdcc 	bl	8f608e10 <sdhci_msm_config_dll>
8f6096dc:	e2504000 	subs	r4, r0, #0
8f6096e0:	1affffdb 	bne	8f609654 <sdhci_msm_execute_tuning+0x1d4>
	REG_WRITE32(host, (REG_READ32(host, SDCC_DLL_CONFIG_REG) | CMD_DAT_TRACK_SEL), SDCC_DLL_CONFIG_REG);
8f6096e4:	e5952000 	ldr	r2, [r5]
8f6096e8:	e5923100 	ldr	r3, [r2, #256]	; 0x100
8f6096ec:	e3833001 	orr	r3, r3, #1
8f6096f0:	e5823100 	str	r3, [r2, #256]	; 0x100
	if (host->use_cdclp533)
8f6096f4:	e5953014 	ldr	r3, [r5, #20]
8f6096f8:	e3530000 	cmp	r3, #0
8f6096fc:	0a00012d 	beq	8f609bb8 <sdhci_msm_execute_tuning+0x738>
	REG_WRITE32(host, (REG_READ32(host, SDCC_CDC_DDR200_CFG) & ~CDC_T4_DLY_SEL), SDCC_CDC_DDR200_CFG);
8f609700:	e5952000 	ldr	r2, [r5]
	REG_WRITE32(host, 0x11800EC,  SDCC_CSR_CDC_CTRL_CFG0);
8f609704:	e3a0e0ec 	mov	r14, #236	; 0xec
8f609708:	e340e118 	movt	r14, #280	; 0x118
	REG_WRITE32(host, 0x3011111,  SDCC_CSR_CDC_CTRL_CFG1);
8f60970c:	e301c111 	movw	r12, #4369	; 0x1111
8f609710:	e340c301 	movt	r12, #769	; 0x301
	REG_WRITE32(host, 0x1201000,  SDCC_CSR_CDC_CAL_TIMER_CFG0);
8f609714:	e3a00a01 	mov	r0, #4096	; 0x1000
	REG_WRITE32(host, (REG_READ32(host, SDCC_CDC_DDR200_CFG) & ~CDC_T4_DLY_SEL), SDCC_CDC_DDR200_CFG);
8f609718:	e5923184 	ldr	r3, [r2, #388]	; 0x184
	REG_WRITE32(host, 0x1201000,  SDCC_CSR_CDC_CAL_TIMER_CFG0);
8f60971c:	e3400120 	movt	r0, #288	; 0x120
	REG_WRITE32(host, 0x4,        SDCC_CSR_CDC_CAL_TIMER_CFG1);
8f609720:	e3a09004 	mov	r9, #4
	REG_WRITE32(host, 0xCB732020, SDCC_CSR_CDC_REFCOUNT_CFG);
8f609724:	e3021020 	movw	r1, #8224	; 0x2020
	REG_WRITE32(host, (REG_READ32(host, SDCC_CDC_DDR200_CFG) & ~CDC_T4_DLY_SEL), SDCC_CDC_DDR200_CFG);
8f609728:	e3c33001 	bic	r3, r3, #1
8f60972c:	e5823184 	str	r3, [r2, #388]	; 0x184
	REG_WRITE32(host, (REG_READ32(host, SDCC_CDC_DDR200_CFG) & ~START_CDC_TRAFFIC), SDCC_CDC_DDR200_CFG);
8f609730:	e5952000 	ldr	r2, [r5]
	REG_WRITE32(host, 0xCB732020, SDCC_CSR_CDC_REFCOUNT_CFG);
8f609734:	e34c1b73 	movt	r1, #52083	; 0xcb73
	while (!(REG_READ32(host, SDCC_CSR_CDC_STATUS0) & BIT(0)))
8f609738:	e3a07032 	mov	r7, #50	; 0x32
	REG_WRITE32(host, (REG_READ32(host, SDCC_CDC_DDR200_CFG) & ~START_CDC_TRAFFIC), SDCC_CDC_DDR200_CFG);
8f60973c:	e5923184 	ldr	r3, [r2, #388]	; 0x184
8f609740:	e3c33040 	bic	r3, r3, #64	; 0x40
8f609744:	e5823184 	str	r3, [r2, #388]	; 0x184
	REG_WRITE32(host, (REG_READ32(host, SDCC_VENDOR_SPEC_CSR_CDC_CFG) & ~CDC_SWITCH_BYPASS_OFF), SDCC_VENDOR_SPEC_CSR_CDC_CFG);
8f609748:	e5958000 	ldr	r8, [r5]
	REG_WRITE32(host, 0x16334,    SDCC_CDC_SLAVE_DDA_CFG);
8f60974c:	e3062334 	movw	r2, #25396	; 0x6334
8f609750:	e3402001 	movt	r2, #1
	REG_WRITE32(host, (REG_READ32(host, SDCC_VENDOR_SPEC_CSR_CDC_CFG) & ~CDC_SWITCH_BYPASS_OFF), SDCC_VENDOR_SPEC_CSR_CDC_CFG);
8f609754:	e5983178 	ldr	r3, [r8, #376]	; 0x178
8f609758:	e3c33001 	bic	r3, r3, #1
8f60975c:	e5883178 	str	r3, [r8, #376]	; 0x178
	REG_WRITE32(host, (REG_READ32(host, SDCC_VENDOR_SPEC_CSR_CDC_CFG) | CDC_SWITCH_RC_EN), SDCC_VENDOR_SPEC_CSR_CDC_CFG);
8f609760:	e5958000 	ldr	r8, [r5]
8f609764:	e5983178 	ldr	r3, [r8, #376]	; 0x178
8f609768:	e3833002 	orr	r3, r3, #2
8f60976c:	e5883178 	str	r3, [r8, #376]	; 0x178
	REG_WRITE32(host, (REG_READ32(host, SDCC_CDC_DDR200_CFG) & ~START_CDC_TRAFFIC), SDCC_CDC_DDR200_CFG);
8f609770:	e5958000 	ldr	r8, [r5]
8f609774:	e5983184 	ldr	r3, [r8, #388]	; 0x184
8f609778:	e3c33040 	bic	r3, r3, #64	; 0x40
8f60977c:	e5883184 	str	r3, [r8, #388]	; 0x184
	REG_WRITE32(host, 0x11800EC,  SDCC_CSR_CDC_CTRL_CFG0);
8f609780:	e5953000 	ldr	r3, [r5]
8f609784:	e583e130 	str	r14, [r3, #304]	; 0x130
	REG_WRITE32(host, 0x3011111,  SDCC_CSR_CDC_CTRL_CFG1);
8f609788:	e5953000 	ldr	r3, [r5]
8f60978c:	e583c134 	str	r12, [r3, #308]	; 0x134
	REG_WRITE32(host, 0x1201000,  SDCC_CSR_CDC_CAL_TIMER_CFG0);
8f609790:	e5953000 	ldr	r3, [r5]
8f609794:	e5830138 	str	r0, [r3, #312]	; 0x138
	REG_WRITE32(host, 0x4,        SDCC_CSR_CDC_CAL_TIMER_CFG1);
8f609798:	e5953000 	ldr	r3, [r5]
8f60979c:	e583913c 	str	r9, [r3, #316]	; 0x13c
	REG_WRITE32(host, 0xCB732020, SDCC_CSR_CDC_REFCOUNT_CFG);
8f6097a0:	e5953000 	ldr	r3, [r5]
8f6097a4:	e5831140 	str	r1, [r3, #320]	; 0x140
	REG_WRITE32(host, 0xB19,      SDCC_CSR_CDC_COARSE_CAL_CFG);
8f6097a8:	e3001b19 	movw	r1, #2841	; 0xb19
8f6097ac:	e5953000 	ldr	r3, [r5]
8f6097b0:	e5831144 	str	r1, [r3, #324]	; 0x144
	REG_WRITE32(host, 0x4E2,      SDCC_CSR_CDC_DELAY_CFG);
8f6097b4:	e30014e2 	movw	r1, #1250	; 0x4e2
8f6097b8:	e5953000 	ldr	r3, [r5]
8f6097bc:	e5831150 	str	r1, [r3, #336]	; 0x150
	REG_WRITE32(host, 0x0,        SDCC_CDC_OFFSET_CFG);
8f6097c0:	e5953000 	ldr	r3, [r5]
8f6097c4:	e583414c 	str	r4, [r3, #332]	; 0x14c
	REG_WRITE32(host, 0x16334,    SDCC_CDC_SLAVE_DDA_CFG);
8f6097c8:	e5953000 	ldr	r3, [r5]
8f6097cc:	e5832160 	str	r2, [r3, #352]	; 0x160
	REG_WRITE32(host, (REG_READ32(host, SDCC_CSR_CDC_CTRL_CFG0) | CDC_SW_TRIGGER_FULL_CALIB), SDCC_CSR_CDC_CTRL_CFG0);
8f6097d0:	e5952000 	ldr	r2, [r5]
8f6097d4:	e5923130 	ldr	r3, [r2, #304]	; 0x130
8f6097d8:	e3833801 	orr	r3, r3, #65536	; 0x10000
8f6097dc:	e5823130 	str	r3, [r2, #304]	; 0x130
	REG_WRITE32(host, (REG_READ32(host, SDCC_CSR_CDC_CTRL_CFG0) & ~CDC_SW_TRIGGER_FULL_CALIB), SDCC_CSR_CDC_CTRL_CFG0);
8f6097e0:	e5952000 	ldr	r2, [r5]
8f6097e4:	e5923130 	ldr	r3, [r2, #304]	; 0x130
8f6097e8:	e3c33801 	bic	r3, r3, #65536	; 0x10000
8f6097ec:	e5823130 	str	r3, [r2, #304]	; 0x130
	REG_WRITE32(host, (REG_READ32(host, SDCC_CSR_CDC_CTRL_CFG0) | CDC_HW_AUTO_CAL_EN), SDCC_CSR_CDC_CTRL_CFG0);
8f6097f0:	e5952000 	ldr	r2, [r5]
8f6097f4:	e5923130 	ldr	r3, [r2, #304]	; 0x130
8f6097f8:	e3833802 	orr	r3, r3, #131072	; 0x20000
8f6097fc:	e5823130 	str	r3, [r2, #304]	; 0x130
	REG_WRITE32(host, (REG_READ32(host, SDCC_CSR_CDC_CAL_TIMER_CFG0) | CDC_TIMER_EN), SDCC_CSR_CDC_CAL_TIMER_CFG0);
8f609800:	e5952000 	ldr	r2, [r5]
8f609804:	e5923138 	ldr	r3, [r2, #312]	; 0x138
8f609808:	e3833801 	orr	r3, r3, #65536	; 0x10000
8f60980c:	e5823138 	str	r3, [r2, #312]	; 0x138
	while (!(REG_READ32(host, SDCC_CSR_CDC_STATUS0) & BIT(0)))
8f609810:	ea000003 	b	8f609824 <sdhci_msm_execute_tuning+0x3a4>
		mdelay(1);
8f609814:	e3a00001 	mov	r0, #1
8f609818:	eb001537 	bl	8f60ecfc <mdelay>
		if (!timeout)
8f60981c:	e2577001 	subs	r7, r7, #1
8f609820:	0a0000fd 	beq	8f609c1c <sdhci_msm_execute_tuning+0x79c>
	while (!(REG_READ32(host, SDCC_CSR_CDC_STATUS0) & BIT(0)))
8f609824:	e5952000 	ldr	r2, [r5]
8f609828:	e5923164 	ldr	r3, [r2, #356]	; 0x164
8f60982c:	e2133001 	ands	r3, r3, #1
8f609830:	0afffff7 	beq	8f609814 <sdhci_msm_execute_tuning+0x394>
	cdc_err = REG_READ32(host, SDCC_CSR_CDC_STATUS0) & CSR_CDC_ERROR_MASK;
8f609834:	e5921164 	ldr	r1, [r2, #356]	; 0x164
	if (cdc_err)
8f609838:	e2111407 	ands	r1, r1, #117440512	; 0x7000000
8f60983c:	1a000104 	bne	8f609c54 <sdhci_msm_execute_tuning+0x7d4>
	REG_WRITE32(host, (REG_READ32(host, SDCC_CDC_DDR200_CFG) | START_CDC_TRAFFIC), SDCC_CDC_DDR200_CFG);
8f609840:	e5923184 	ldr	r3, [r2, #388]	; 0x184
8f609844:	e3833040 	orr	r3, r3, #64	; 0x40
8f609848:	e5823184 	str	r3, [r2, #388]	; 0x184
			msm_host->calibration_done = true;
8f60984c:	e3a03001 	mov	r3, #1
8f609850:	e5c63009 	strb	r3, [r6, #9]
8f609854:	e30c6bd8 	movw	r6, #52184	; 0xcbd8
8f609858:	e3486f72 	movt	r6, #36722	; 0x8f72
8f60985c:	eaffff7f 	b	8f609660 <sdhci_msm_execute_tuning+0x1e0>
	if (tuned_phase_cnt == MAX_PHASES)
8f609860:	e59d3008 	ldr	r3, [r13, #8]
8f609864:	e3530010 	cmp	r3, #16
8f609868:	1a0000bf 	bne	8f609b6c <sdhci_msm_execute_tuning+0x6ec>
8f60986c:	e59d701c 	ldr	r7, [r13, #28]
8f609870:	e59d3014 	ldr	r3, [r13, #20]
8f609874:	e59d6010 	ldr	r6, [r13, #16]
8f609878:	ea000006 	b	8f609898 <sdhci_msm_execute_tuning+0x418>
			if (mmc_set_drv_type(host, card, drv_type))
8f60987c:	e1a02007 	mov	r2, r7
8f609880:	e1a01006 	mov	r1, r6
8f609884:	e1a00005 	mov	r0, r5
8f609888:	eb00029d 	bl	8f60a304 <mmc_set_drv_type>
8f60988c:	e3a03001 	mov	r3, #1
8f609890:	e3500000 	cmp	r0, #0
8f609894:	1a000098 	bne	8f609afc <sdhci_msm_execute_tuning+0x67c>
		while(++drv_type <= MX_DRV_SUPPORTED_HS200)
8f609898:	e2877001 	add	r7, r7, #1
8f60989c:	e6ef7077 	uxtb	r7, r7
8f6098a0:	e3570003 	cmp	r7, #3
8f6098a4:	9afffff4 	bls	8f60987c <sdhci_msm_execute_tuning+0x3fc>
	if (drv_type_changed)
8f6098a8:	e3530000 	cmp	r3, #0
8f6098ac:	e58d3014 	str	r3, [r13, #20]
8f6098b0:	0a00009f 	beq	8f609b34 <sdhci_msm_execute_tuning+0x6b4>
		mmc_set_drv_type(host, card, 0);
8f6098b4:	e59d1010 	ldr	r1, [r13, #16]
8f6098b8:	e3a02000 	mov	r2, #0
8f6098bc:	e1a00005 	mov	r0, r5
		attempt_cdr_unlock = true;
8f6098c0:	e30c6bd8 	movw	r6, #52184	; 0xcbd8
8f6098c4:	e3486f72 	movt	r6, #36722	; 0x8f72
		mmc_set_drv_type(host, card, 0);
8f6098c8:	eb00028d 	bl	8f60a304 <mmc_set_drv_type>
		dprintf(CRITICAL, "WARNING: All phase passed.The selected phase may not be optimal\n");
8f6098cc:	e302019c 	movw	r0, #8604	; 0x219c
8f6098d0:	e3480f70 	movt	r0, #36720	; 0x8f70
		attempt_cdr_unlock = true;
8f6098d4:	e3a03001 	mov	r3, #1
8f6098d8:	e5863000 	str	r3, [r6]
		dprintf(CRITICAL, "WARNING: All phase passed.The selected phase may not be optimal\n");
8f6098dc:	eb00a424 	bl	8f632974 <_dprintf>
8f6098e0:	e3a08000 	mov	r8, #0
	int sub_phases[MAX_PHASES][MAX_PHASES]={{0}};
8f6098e4:	e3a02b01 	mov	r2, #1024	; 0x400
8f6098e8:	e3a01000 	mov	r1, #0
8f6098ec:	e28d0f4d 	add	r0, r13, #308	; 0x134
8f6098f0:	eb00aa73 	bl	8f6342c4 <memset>
	uint32_t phases_per_row[MAX_PHASES] = {0};
8f6098f4:	e28d0060 	add	r0, r13, #96	; 0x60
8f6098f8:	e3a02040 	mov	r2, #64	; 0x40
8f6098fc:	e3a01000 	mov	r1, #0
8f609900:	eb00aa6f 	bl	8f6342c4 <memset>
	if (!phase_table[0] && phase_table[total_phases - 1] == (MAX_PHASES - 1))
8f609904:	e59dc020 	ldr	r12, [r13, #32]
8f609908:	e35c0000 	cmp	r12, #0
8f60990c:	13a08000 	movne	r8, #0
8f609910:	1a000007 	bne	8f609934 <sdhci_msm_execute_tuning+0x4b4>
8f609914:	e59d2008 	ldr	r2, [r13, #8]
8f609918:	e28d3e53 	add	r3, r13, #1328	; 0x530
8f60991c:	e2833008 	add	r3, r3, #8
8f609920:	e0833102 	add	r3, r3, r2, lsl #2
8f609924:	e513351c 	ldr	r3, [r3, #-1308]	; 0xfffffae4
	if (found_loop && total_phases < MAX_PHASES)
8f609928:	e353000f 	cmp	r3, #15
8f60992c:	13a08000 	movne	r8, #0
8f609930:	02088001 	andeq	r8, r8, #1
	for (i = 0; i < total_phases; i++)
8f609934:	e3a02000 	mov	r2, #0
8f609938:	e59d9008 	ldr	r9, [r13, #8]
8f60993c:	e28de020 	add	r14, r13, #32
	uint32_t col_index = 0;
8f609940:	e1a07002 	mov	r7, r2
	uint32_t row_index = 0;
8f609944:	e1a01002 	mov	r1, r2
	for (i = 0; i < total_phases; i++)
8f609948:	e1a00002 	mov	r0, r2
8f60994c:	e1a03002 	mov	r3, r2
8f609950:	ea000004 	b	8f609968 <sdhci_msm_execute_tuning+0x4e8>
		phases_per_row[row_index]++;
8f609954:	e1a03101 	lsl	r3, r1, #2
8f609958:	e2832e52 	add	r2, r3, #1312	; 0x520
8f60995c:	e2822018 	add	r2, r2, #24
8f609960:	e08d2002 	add	r2, r13, r2
8f609964:	e51224d8 	ldr	r2, [r2, #-1240]	; 0xfffffb28
8f609968:	e2833e52 	add	r3, r3, #1312	; 0x520
8f60996c:	e2822001 	add	r2, r2, #1
8f609970:	e2833018 	add	r3, r3, #24
		if ((i + 1) == total_phases)
8f609974:	e2800001 	add	r0, r0, #1
		phases_per_row[row_index]++;
8f609978:	e08d3003 	add	r3, r13, r3
		if ((i + 1) == total_phases)
8f60997c:	e1500009 	cmp	r0, r9
		phases_per_row[row_index]++;
8f609980:	e50324d8 	str	r2, [r3, #-1240]	; 0xfffffb28
		sub_phases[row_index][col_index] = phase_table[i];
8f609984:	e0873201 	add	r3, r7, r1, lsl #4
8f609988:	e28d2e53 	add	r2, r13, #1328	; 0x530
8f60998c:	e2822008 	add	r2, r2, #8
8f609990:	e0823103 	add	r3, r2, r3, lsl #2
8f609994:	e503c404 	str	r12, [r3, #-1028]	; 0xfffffbfc
		if ((i + 1) == total_phases)
8f609998:	0a000007 	beq	8f6099bc <sdhci_msm_execute_tuning+0x53c>
		if (phase_table[i]+1 != phase_table[i+1])
8f60999c:	e28c3001 	add	r3, r12, #1
8f6099a0:	e5bec004 	ldr	r12, [r14, #4]!
8f6099a4:	e153000c 	cmp	r3, r12
		col_index++;
8f6099a8:	02877001 	addeq	r7, r7, #1
			row_index++;
8f6099ac:	12811001 	addne	r1, r1, #1
			col_index = 0;
8f6099b0:	13a07000 	movne	r7, #0
	for (i = 0; i < total_phases; i++)
8f6099b4:	e1500009 	cmp	r0, r9
8f6099b8:	3affffe5 	bcc	8f609954 <sdhci_msm_execute_tuning+0x4d4>
	if (found_loop && total_phases < MAX_PHASES)
8f6099bc:	e3580000 	cmp	r8, #0
			if (phases_per_row[i] > max_phases)
8f6099c0:	059d0060 	ldreq	r0, [r13, #96]	; 0x60
	if (found_loop && total_phases < MAX_PHASES)
8f6099c4:	0a00001b 	beq	8f609a38 <sdhci_msm_execute_tuning+0x5b8>
		for (i = phases_per_row[phase_15_row_idx] ; i < MAX_PHASES ; i++)
8f6099c8:	e1a03101 	lsl	r3, r1, #2
8f6099cc:	e2832e52 	add	r2, r3, #1312	; 0x520
8f6099d0:	e2822018 	add	r2, r2, #24
8f6099d4:	e08d2002 	add	r2, r13, r2
8f6099d8:	e51274d8 	ldr	r7, [r2, #-1240]	; 0xfffffb28
8f6099dc:	e357000f 	cmp	r7, #15
8f6099e0:	8a00008b 	bhi	8f609c14 <sdhci_msm_execute_tuning+0x794>
8f6099e4:	e087c201 	add	r12, r7, r1, lsl #4
8f6099e8:	e28d0f4d 	add	r0, r13, #308	; 0x134
			if (++j >= phases_per_row[phases_0_row_idx])
8f6099ec:	e59d8060 	ldr	r8, [r13, #96]	; 0x60
8f6099f0:	e2679010 	rsb	r9, r7, #16
8f6099f4:	e080c10c 	add	r12, r0, r12, lsl #2
		j = 0;
8f6099f8:	e3a02000 	mov	r2, #0
8f6099fc:	e24cc004 	sub	r12, r12, #4
8f609a00:	ea000001 	b	8f609a0c <sdhci_msm_execute_tuning+0x58c>
		for (i = phases_per_row[phase_15_row_idx] ; i < MAX_PHASES ; i++)
8f609a04:	e1520009 	cmp	r2, r9
8f609a08:	0a000004 	beq	8f609a20 <sdhci_msm_execute_tuning+0x5a0>
			sub_phases[phase_15_row_idx][i] = sub_phases[phases_0_row_idx][j];
8f609a0c:	e490e004 	ldr	r14, [r0], #4
			if (++j >= phases_per_row[phases_0_row_idx])
8f609a10:	e2822001 	add	r2, r2, #1
8f609a14:	e1520008 	cmp	r2, r8
			sub_phases[phase_15_row_idx][i] = sub_phases[phases_0_row_idx][j];
8f609a18:	e5ace004 	str	r14, [r12, #4]!
			if (++j >= phases_per_row[phases_0_row_idx])
8f609a1c:	3afffff8 	bcc	8f609a04 <sdhci_msm_execute_tuning+0x584>
		phases_per_row[phase_15_row_idx] = phases_per_row[phase_15_row_idx] + phases_per_row[phases_0_row_idx];
8f609a20:	e2833e52 	add	r3, r3, #1312	; 0x520
8f609a24:	e3a00000 	mov	r0, #0
8f609a28:	e2833018 	add	r3, r3, #24
8f609a2c:	e0877008 	add	r7, r7, r8
8f609a30:	e08d3003 	add	r3, r13, r3
8f609a34:	e50374d8 	str	r7, [r3, #-1240]	; 0xfffffb28
	uint32_t max_phases_row = 0;
8f609a38:	e3a0c000 	mov	r12, #0
8f609a3c:	e28de060 	add	r14, r13, #96	; 0x60
	uint32_t max_phases = 0;
8f609a40:	e1a0200c 	mov	r2, r12
		for (i = 0 ; i <= row_index; i++)
8f609a44:	e1a0300c 	mov	r3, r12
8f609a48:	ea000000 	b	8f609a50 <sdhci_msm_execute_tuning+0x5d0>
			if (phases_per_row[i] > max_phases)
8f609a4c:	e5be0004 	ldr	r0, [r14, #4]!
8f609a50:	e1500002 	cmp	r0, r2
8f609a54:	81a02000 	movhi	r2, r0
8f609a58:	91a0000c 	movls	r0, r12
8f609a5c:	81a00003 	movhi	r0, r3
		for (i = 0 ; i <= row_index; i++)
8f609a60:	e1510003 	cmp	r1, r3
			if (phases_per_row[i] > max_phases)
8f609a64:	e1a0c000 	mov	r12, r0
		for (i = 0 ; i <= row_index; i++)
8f609a68:	e2833001 	add	r3, r3, #1
8f609a6c:	1afffff6 	bne	8f609a4c <sdhci_msm_execute_tuning+0x5cc>
	max_phases_3_4_idx = (max_phases * 3) / 4;
8f609a70:	e0822082 	add	r2, r2, r2, lsl #1
	selected_phase = sub_phases[max_phases_row][max_phases_3_4_idx];
8f609a74:	e28d3e53 	add	r3, r13, #1328	; 0x530
	if (max_phases_3_4_idx)
8f609a78:	e3520003 	cmp	r2, #3
	selected_phase = sub_phases[max_phases_row][max_phases_3_4_idx];
8f609a7c:	e2833008 	add	r3, r3, #8
	max_phases_3_4_idx = (max_phases * 3) / 4;
8f609a80:	e1a02122 	lsr	r2, r2, #2
		max_phases_3_4_idx--;
8f609a84:	82422001 	subhi	r2, r2, #1
	selected_phase = sub_phases[max_phases_row][max_phases_3_4_idx];
8f609a88:	e0822200 	add	r2, r2, r0, lsl #4
8f609a8c:	e0832102 	add	r2, r3, r2, lsl #2
8f609a90:	e5127404 	ldr	r7, [r2, #-1028]	; 0xfffffbfc
		if (ret < 0)
8f609a94:	e3570000 	cmp	r7, #0
8f609a98:	ba00002e 	blt	8f609b58 <sdhci_msm_execute_tuning+0x6d8>
		if (sdhci_msm_config_dll(host, phase))
8f609a9c:	e1a01007 	mov	r1, r7
8f609aa0:	e1a00005 	mov	r0, r5
8f609aa4:	ebfffcd9 	bl	8f608e10 <sdhci_msm_config_dll>
8f609aa8:	e3500000 	cmp	r0, #0
		host->msm_host->saved_phase = phase;
8f609aac:	05953030 	ldreq	r3, [r5, #48]	; 0x30
8f609ab0:	01a04000 	moveq	r4, r0
8f609ab4:	05c3700a 	strbeq	r7, [r3, #10]
8f609ab8:	eafffee8 	b	8f609660 <sdhci_msm_execute_tuning+0x1e0>
		if (!sdhci_send_command(host, &cmd))
8f609abc:	e28d10a0 	add	r1, r13, #160	; 0xa0
8f609ac0:	e1a00005 	mov	r0, r5
		cmd.cmd_index = CMD21_SEND_TUNING_BLOCK;
8f609ac4:	e3a03015 	mov	r3, #21
		cmd.data.blk_sz = size;
8f609ac8:	e58db0d8 	str	r11, [r13, #216]	; 0xd8
		cmd.cmd_index = CMD21_SEND_TUNING_BLOCK;
8f609acc:	e1cd3ab0 	strh	r3, [r13, #160]	; 0xa0
		cmd.trans_mode = SDHCI_MMC_READ;
8f609ad0:	e3a03001 	mov	r3, #1
		cmd.data.data_ptr = tuning_data;
8f609ad4:	e58da0d4 	str	r10, [r13, #212]	; 0xd4
		cmd.trans_mode = SDHCI_MMC_READ;
8f609ad8:	e58d30bc 	str	r3, [r13, #188]	; 0xbc
		cmd.data.num_blocks = 0x1;
8f609adc:	e58d30dc 	str	r3, [r13, #220]	; 0xdc
		cmd.argument = 0x0;
8f609ae0:	e3a03000 	mov	r3, #0
8f609ae4:	e58d30a4 	str	r3, [r13, #164]	; 0xa4
		cmd.data_present = 0x1;
8f609ae8:	e3a03001 	mov	r3, #1
8f609aec:	e3403001 	movt	r3, #1
8f609af0:	e58d30a8 	str	r3, [r13, #168]	; 0xa8
		if (!sdhci_send_command(host, &cmd))
8f609af4:	ebfff9dc 	bl	8f60826c <sdhci_send_command>
8f609af8:	eafffedb 	b	8f60966c <sdhci_msm_execute_tuning+0x1ec>
8f609afc:	e58d701c 	str	r7, [r13, #28]
8f609b00:	e58d3014 	str	r3, [r13, #20]
8f609b04:	eafffe8c 	b	8f60953c <sdhci_msm_execute_tuning+0xbc>
	ASSERT(tuning_data);
8f609b08:	e1a00004 	mov	r0, r4
8f609b0c:	e3023108 	movw	r3, #8456	; 0x2108
8f609b10:	e30220e8 	movw	r2, #8424	; 0x20e8
8f609b14:	e3483f70 	movt	r3, #36720	; 0x8f70
8f609b18:	e3482f70 	movt	r2, #36720	; 0x8f70
8f609b1c:	e58d3000 	str	r3, [r13]
8f609b20:	e3001130 	movw	r1, #304	; 0x130
8f609b24:	e30032dd 	movw	r3, #733	; 0x2dd
8f609b28:	e3481f70 	movt	r1, #36720	; 0x8f70
8f609b2c:	eb00a3e2 	bl	8f632abc <_panic>
8f609b30:	eafffe72 	b	8f609500 <sdhci_msm_execute_tuning+0x80>
		attempt_cdr_unlock = true;
8f609b34:	e30c6bd8 	movw	r6, #52184	; 0xcbd8
8f609b38:	e3486f72 	movt	r6, #36722	; 0x8f72
		dprintf(CRITICAL, "WARNING: All phase passed.The selected phase may not be optimal\n");
8f609b3c:	e302019c 	movw	r0, #8604	; 0x219c
8f609b40:	e3480f70 	movt	r0, #36720	; 0x8f70
8f609b44:	e1a08003 	mov	r8, r3
		attempt_cdr_unlock = true;
8f609b48:	e3a03001 	mov	r3, #1
8f609b4c:	e5863000 	str	r3, [r6]
		dprintf(CRITICAL, "WARNING: All phase passed.The selected phase may not be optimal\n");
8f609b50:	eb00a387 	bl	8f632974 <_dprintf>
	if (tuned_phase_cnt)
8f609b54:	eaffff62 	b	8f6098e4 <sdhci_msm_execute_tuning+0x464>
			dprintf(CRITICAL, "Failed in selecting the tuning phase\n");
8f609b58:	e30201e0 	movw	r0, #8672	; 0x21e0
8f609b5c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f609b60:	eb00a383 	bl	8f632974 <_dprintf>
			goto out;
8f609b64:	e3a04001 	mov	r4, #1
8f609b68:	eafffebc 	b	8f609660 <sdhci_msm_execute_tuning+0x1e0>
	if (drv_type_changed)
8f609b6c:	e59d3014 	ldr	r3, [r13, #20]
8f609b70:	e3530000 	cmp	r3, #0
8f609b74:	1a00003e 	bne	8f609c74 <sdhci_msm_execute_tuning+0x7f4>
	if (tuned_phase_cnt)
8f609b78:	e59d3008 	ldr	r3, [r13, #8]
8f609b7c:	e3530000 	cmp	r3, #0
8f609b80:	0a000005 	beq	8f609b9c <sdhci_msm_execute_tuning+0x71c>
	if (found_loop && total_phases < MAX_PHASES)
8f609b84:	e353000f 	cmp	r3, #15
8f609b88:	e30c6bd8 	movw	r6, #52184	; 0xcbd8
8f609b8c:	e3486f72 	movt	r6, #36722	; 0x8f72
8f609b90:	83a08000 	movhi	r8, #0
8f609b94:	93a08001 	movls	r8, #1
8f609b98:	eaffff51 	b	8f6098e4 <sdhci_msm_execute_tuning+0x464>
		dprintf(CRITICAL, "Failed to get tuned phase\n");
8f609b9c:	e3020208 	movw	r0, #8712	; 0x2208
8f609ba0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f609ba4:	e30c6bd8 	movw	r6, #52184	; 0xcbd8
8f609ba8:	eb00a371 	bl	8f632974 <_dprintf>
		ret = 1;
8f609bac:	e3486f72 	movt	r6, #36722	; 0x8f72
		dprintf(CRITICAL, "Failed to get tuned phase\n");
8f609bb0:	e3a04001 	mov	r4, #1
8f609bb4:	eafffea9 	b	8f609660 <sdhci_msm_execute_tuning+0x1e0>
	REG_WRITE32(host, target_ddr_cfg_val(), target_ddr_cfg_reg());
8f609bb8:	e5958000 	ldr	r8, [r5]
8f609bbc:	eb006046 	bl	8f621cdc <target_ddr_cfg_reg>
8f609bc0:	e1a07000 	mov	r7, r0
8f609bc4:	eb006032 	bl	8f621c94 <target_ddr_cfg_val>
8f609bc8:	e7880007 	str	r0, [r8, r7]
	while (!(REG_READ32(host, SDCC_REG_DLL_STATUS) & DDR_DLL_LOCK_JDR))
8f609bcc:	e3a07032 	mov	r7, #50	; 0x32
	REG_WRITE32(host, (REG_READ32(host, SDCC_HC_REG_DLL_CONFIG_2) | DDR_CAL_EN), SDCC_HC_REG_DLL_CONFIG_2);
8f609bd0:	e5952000 	ldr	r2, [r5]
8f609bd4:	e59231b4 	ldr	r3, [r2, #436]	; 0x1b4
8f609bd8:	e3833001 	orr	r3, r3, #1
8f609bdc:	e58231b4 	str	r3, [r2, #436]	; 0x1b4
	while (!(REG_READ32(host, SDCC_REG_DLL_STATUS) & DDR_DLL_LOCK_JDR))
8f609be0:	ea000003 	b	8f609bf4 <sdhci_msm_execute_tuning+0x774>
		mdelay(1);
8f609be4:	e3a00001 	mov	r0, #1
8f609be8:	eb001443 	bl	8f60ecfc <mdelay>
		if (!timeout)
8f609bec:	e2577001 	subs	r7, r7, #1
8f609bf0:	0a000010 	beq	8f609c38 <sdhci_msm_execute_tuning+0x7b8>
	while (!(REG_READ32(host, SDCC_REG_DLL_STATUS) & DDR_DLL_LOCK_JDR))
8f609bf4:	e5953000 	ldr	r3, [r5]
8f609bf8:	e5932108 	ldr	r2, [r3, #264]	; 0x108
8f609bfc:	e3120b02 	tst	r2, #2048	; 0x800
8f609c00:	0afffff7 	beq	8f609be4 <sdhci_msm_execute_tuning+0x764>
	REG_WRITE32(host, (REG_READ32(host, SDCC_HC_VENDOR_SPECIFIC_FUNC3) | PWRSAVE_DLL), SDCC_HC_VENDOR_SPECIFIC_FUNC3);
8f609c04:	e59321b0 	ldr	r2, [r3, #432]	; 0x1b0
8f609c08:	e3822008 	orr	r2, r2, #8
8f609c0c:	e58321b0 	str	r2, [r3, #432]	; 0x1b0
	return 0;
8f609c10:	eaffff0d 	b	8f60984c <sdhci_msm_execute_tuning+0x3cc>
		phases_per_row[phase_15_row_idx] = phases_per_row[phase_15_row_idx] + phases_per_row[phases_0_row_idx];
8f609c14:	e59d8060 	ldr	r8, [r13, #96]	; 0x60
8f609c18:	eaffff80 	b	8f609a20 <sdhci_msm_execute_tuning+0x5a0>
			dprintf(CRITICAL, "Error: Calibration done in CDC status not set\n");
8f609c1c:	e3020114 	movw	r0, #8468	; 0x2114
8f609c20:	e3480f70 	movt	r0, #36720	; 0x8f70
8f609c24:	e30c6bd8 	movw	r6, #52184	; 0xcbd8
8f609c28:	eb00a351 	bl	8f632974 <_dprintf>
			return 1;
8f609c2c:	e3486f72 	movt	r6, #36722	; 0x8f72
8f609c30:	e3a04001 	mov	r4, #1
8f609c34:	eafffe89 	b	8f609660 <sdhci_msm_execute_tuning+0x1e0>
			dprintf(CRITICAL, "Error: DLL lock for hs400 operation is not set\n");
8f609c38:	e302016c 	movw	r0, #8556	; 0x216c
8f609c3c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f609c40:	e30c6bd8 	movw	r6, #52184	; 0xcbd8
8f609c44:	eb00a34a 	bl	8f632974 <_dprintf>
			return 1;
8f609c48:	e3486f72 	movt	r6, #36722	; 0x8f72
8f609c4c:	e3a04001 	mov	r4, #1
8f609c50:	eafffe82 	b	8f609660 <sdhci_msm_execute_tuning+0x1e0>
		dprintf(CRITICAL, "CDC error set during calibration: %x\n", cdc_err);
8f609c54:	e3020144 	movw	r0, #8516	; 0x2144
8f609c58:	e3480f70 	movt	r0, #36720	; 0x8f70
		return 1;
8f609c5c:	e1a04003 	mov	r4, r3
8f609c60:	e30c6bd8 	movw	r6, #52184	; 0xcbd8
		dprintf(CRITICAL, "CDC error set during calibration: %x\n", cdc_err);
8f609c64:	eb00a342 	bl	8f632974 <_dprintf>
		return 1;
8f609c68:	e3486f72 	movt	r6, #36722	; 0x8f72
8f609c6c:	eafffe7b 	b	8f609660 <sdhci_msm_execute_tuning+0x1e0>
}
8f609c70:	eb00a3d2 	bl	8f632bc0 <__stack_chk_fail>
		mmc_set_drv_type(host, card, 0);
8f609c74:	e59d1010 	ldr	r1, [r13, #16]
8f609c78:	e3a02000 	mov	r2, #0
8f609c7c:	e1a00005 	mov	r0, r5
8f609c80:	eb00019f 	bl	8f60a304 <mmc_set_drv_type>
	if (tuned_phase_cnt == MAX_PHASES)
8f609c84:	eaffffbb 	b	8f609b78 <sdhci_msm_execute_tuning+0x6f8>
8f609c88:	8f74221c 	.word	0x8f74221c

8f609c8c <sdhci_mode_disable>:

/*
 * API to disable HC mode
 */
void sdhci_mode_disable(struct sdhci_host *host)
{
8f609c8c:	e59f3048 	ldr	r3, [pc, #72]	; 8f609cdc <sdhci_mode_disable+0x50>
8f609c90:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f609c94:	e24dd00c 	sub	r13, r13, #12
8f609c98:	e5933000 	ldr	r3, [r3]
8f609c9c:	e58d3004 	str	r3, [r13, #4]
8f609ca0:	e3a03000 	mov	r3, #0
	/* Disable HC mode */
	RMWREG32((host->msm_host->pwrctl_base + SDCC_MCI_HC_MODE), SDHCI_HC_START_BIT, SDHCI_HC_WIDTH, 0);
8f609ca4:	e5903030 	ldr	r3, [r0, #48]	; 0x30
8f609ca8:	e5932000 	ldr	r2, [r3]
8f609cac:	e5923078 	ldr	r3, [r2, #120]	; 0x78
8f609cb0:	e3c33001 	bic	r3, r3, #1
8f609cb4:	e5823078 	str	r3, [r2, #120]	; 0x78
}
8f609cb8:	e59f301c 	ldr	r3, [pc, #28]	; 8f609cdc <sdhci_mode_disable+0x50>
8f609cbc:	e5932000 	ldr	r2, [r3]
8f609cc0:	e59d3004 	ldr	r3, [r13, #4]
8f609cc4:	e0332002 	eors	r2, r3, r2
8f609cc8:	e3a03000 	mov	r3, #0
8f609ccc:	1a000001 	bne	8f609cd8 <sdhci_mode_disable+0x4c>
8f609cd0:	e28dd00c 	add	r13, r13, #12
8f609cd4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f609cd8:	eb00a3b8 	bl	8f632bc0 <__stack_chk_fail>
8f609cdc:	8f74221c 	.word	0x8f74221c

8f609ce0 <mmc_switch_cmd>:
 * Return  : 0 on Success, 1 on Failure
 * Flow    : Send switch command to the card to set the ext attribute @ index
 */
static uint32_t mmc_switch_cmd(struct sdhci_host *host, struct mmc_card *card,
							   uint32_t access, uint32_t index, uint32_t value)
{
8f609ce0:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f609ce4:	e24dd098 	sub	r13, r13, #152	; 0x98
8f609ce8:	e1a07003 	mov	r7, r3
8f609cec:	e59f3140 	ldr	r3, [pc, #320]	; 8f609e34 <mmc_switch_cmd+0x154>
8f609cf0:	e1a04002 	mov	r4, r2
8f609cf4:	e59d80b0 	ldr	r8, [r13, #176]	; 0xb0
8f609cf8:	e1a05000 	mov	r5, r0

	struct mmc_command cmd;
	uint32_t mmc_ret = 0;
	uint32_t mmc_status;

	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f609cfc:	e3a02048 	mov	r2, #72	; 0x48
{
8f609d00:	e1a06001 	mov	r6, r1
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f609d04:	e1a0000d 	mov	r0, r13
8f609d08:	e3a01000 	mov	r1, #0
{
8f609d0c:	e5933000 	ldr	r3, [r3]
8f609d10:	e58d3094 	str	r3, [r13, #148]	; 0x94
8f609d14:	e3a03000 	mov	r3, #0
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f609d18:	eb00a969 	bl	8f6342c4 <memset>
	 * [2:0] cmd set
	 */
	cmd.cmd_index = CMD6_SWITCH_FUNC;
	cmd.argument |= (access << 24);
	cmd.argument |= (index << 16);
	cmd.argument |= (value << 8);
8f609d1c:	e59dc004 	ldr	r12, [r13, #4]
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
	cmd.resp_type = SDHCI_CMD_RESP_R1B;

	mmc_ret = sdhci_send_command(host, &cmd);
8f609d20:	e1a0100d 	mov	r1, r13
8f609d24:	e1a00005 	mov	r0, r5
	cmd.argument |= (value << 8);
8f609d28:	e18cc408 	orr	r12, r12, r8, lsl #8
8f609d2c:	e18c3807 	orr	r3, r12, r7, lsl #16
8f609d30:	e1832c04 	orr	r2, r3, r4, lsl #24
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f609d34:	e3a03000 	mov	r3, #0
	cmd.argument |= (value << 8);
8f609d38:	e58d2004 	str	r2, [r13, #4]
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f609d3c:	e5cd3009 	strb	r3, [r13, #9]
	cmd.cmd_index = CMD6_SWITCH_FUNC;
8f609d40:	e3a03006 	mov	r3, #6
8f609d44:	e1cd30b0 	strh	r3, [r13]
	cmd.resp_type = SDHCI_CMD_RESP_R1B;
8f609d48:	e3a03002 	mov	r3, #2
8f609d4c:	e1cd30ba 	strh	r3, [r13, #10]
	mmc_ret = sdhci_send_command(host, &cmd);
8f609d50:	ebfff945 	bl	8f60826c <sdhci_send_command>
	if (mmc_ret) {
8f609d54:	e2504000 	subs	r4, r0, #0
8f609d58:	1a000027 	bne	8f609dfc <mmc_switch_cmd+0x11c>
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f609d5c:	e3a02048 	mov	r2, #72	; 0x48
8f609d60:	e1a01004 	mov	r1, r4
8f609d64:	e08d0002 	add	r0, r13, r2
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f609d68:	e3a07001 	mov	r7, #1
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f609d6c:	eb00a954 	bl	8f6342c4 <memset>
	cmd.argument = card->rca << 16;
8f609d70:	e5963000 	ldr	r3, [r6]
	mmc_ret = sdhci_send_command(host, &cmd);
8f609d74:	e28d1048 	add	r1, r13, #72	; 0x48
8f609d78:	e1a00005 	mov	r0, r5
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f609d7c:	e5cd4051 	strb	r4, [r13, #81]	; 0x51
	cmd.argument = card->rca << 16;
8f609d80:	e1a03803 	lsl	r3, r3, #16
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f609d84:	e1cd75b2 	strh	r7, [r13, #82]	; 0x52
	cmd.argument = card->rca << 16;
8f609d88:	e58d304c 	str	r3, [r13, #76]	; 0x4c
	cmd.cmd_index = CMD13_SEND_STATUS;
8f609d8c:	e3a0300d 	mov	r3, #13
8f609d90:	e1cd34b8 	strh	r3, [r13, #72]	; 0x48
	mmc_ret = sdhci_send_command(host, &cmd);
8f609d94:	ebfff934 	bl	8f60826c <sdhci_send_command>
	if (mmc_ret)
8f609d98:	e2504000 	subs	r4, r0, #0
8f609d9c:	1a00001a 	bne	8f609e0c <mmc_switch_cmd+0x12c>
	if ((cmd.resp[0] >> 31) & 0x01)
8f609da0:	e59d5054 	ldr	r5, [r13, #84]	; 0x54
8f609da4:	e3550000 	cmp	r5, #0
		return 1;
8f609da8:	b1a04007 	movlt	r4, r7
	if ((cmd.resp[0] >> 31) & 0x01)
8f609dac:	ba000016 	blt	8f609e0c <mmc_switch_cmd+0x12c>
	if (mmc_ret) {
		dprintf(CRITICAL, "Get card status failed\n");
		return mmc_ret;
	}

	if (MMC_CARD_STATUS(mmc_status) != MMC_TRAN_STATE) {
8f609db0:	e7e334d5 	ubfx	r3, r5, #9, #4
8f609db4:	e3530004 	cmp	r3, #4
8f609db8:	0a000004 	beq	8f609dd0 <mmc_switch_cmd+0xf0>
		dprintf(CRITICAL, "Switch cmd failed. Card not in tran state %x\n", mmc_status);
8f609dbc:	e302037c 	movw	r0, #9084	; 0x237c
8f609dc0:	e1a01005 	mov	r1, r5
8f609dc4:	e3480f70 	movt	r0, #36720	; 0x8f70
		mmc_ret = 1;
8f609dc8:	e1a04007 	mov	r4, r7
		dprintf(CRITICAL, "Switch cmd failed. Card not in tran state %x\n", mmc_status);
8f609dcc:	eb00a2e8 	bl	8f632974 <_dprintf>
	}

	if (mmc_status & MMC_SWITCH_FUNC_ERR_FLAG) {
8f609dd0:	e3150080 	tst	r5, #128	; 0x80
8f609dd4:	1a000010 	bne	8f609e1c <mmc_switch_cmd+0x13c>
		dprintf(CRITICAL, "Switch cmd failed. Switch Error.\n");
		mmc_ret = 1;
	}

	return mmc_ret;
}
8f609dd8:	e59f3054 	ldr	r3, [pc, #84]	; 8f609e34 <mmc_switch_cmd+0x154>
8f609ddc:	e5932000 	ldr	r2, [r3]
8f609de0:	e59d3094 	ldr	r3, [r13, #148]	; 0x94
8f609de4:	e0332002 	eors	r2, r3, r2
8f609de8:	e3a03000 	mov	r3, #0
8f609dec:	1a00000f 	bne	8f609e30 <mmc_switch_cmd+0x150>
8f609df0:	e1a00004 	mov	r0, r4
8f609df4:	e28dd098 	add	r13, r13, #152	; 0x98
8f609df8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
		dprintf(CRITICAL, "CMD6 send failed\n");
8f609dfc:	e3020350 	movw	r0, #9040	; 0x2350
8f609e00:	e3480f70 	movt	r0, #36720	; 0x8f70
8f609e04:	eb00a2da 	bl	8f632974 <_dprintf>
		return mmc_ret;
8f609e08:	eafffff2 	b	8f609dd8 <mmc_switch_cmd+0xf8>
		dprintf(CRITICAL, "Get card status failed\n");
8f609e0c:	e3020364 	movw	r0, #9060	; 0x2364
8f609e10:	e3480f70 	movt	r0, #36720	; 0x8f70
8f609e14:	eb00a2d6 	bl	8f632974 <_dprintf>
		return mmc_ret;
8f609e18:	eaffffee 	b	8f609dd8 <mmc_switch_cmd+0xf8>
		dprintf(CRITICAL, "Switch cmd failed. Switch Error.\n");
8f609e1c:	e30203ac 	movw	r0, #9132	; 0x23ac
8f609e20:	e3480f70 	movt	r0, #36720	; 0x8f70
8f609e24:	eb00a2d2 	bl	8f632974 <_dprintf>
		mmc_ret = 1;
8f609e28:	e3a04001 	mov	r4, #1
8f609e2c:	eaffffe9 	b	8f609dd8 <mmc_switch_cmd+0xf8>
}
8f609e30:	eb00a362 	bl	8f632bc0 <__stack_chk_fail>
8f609e34:	8f74221c 	.word	0x8f74221c

8f609e38 <mmc_get_ext_csd>:
{
8f609e38:	e59f30e4 	ldr	r3, [pc, #228]	; 8f609f24 <mmc_get_ext_csd+0xec>
8f609e3c:	e92d4070 	push	{r4, r5, r6, r14}
8f609e40:	e1a04001 	mov	r4, r1
8f609e44:	e24dd058 	sub	r13, r13, #88	; 0x58
8f609e48:	e1a05000 	mov	r5, r0
	card->ext_csd = memalign(CACHE_LINE, ROUNDUP(512, CACHE_LINE));
8f609e4c:	e3a01c02 	mov	r1, #512	; 0x200
8f609e50:	e3a00040 	mov	r0, #64	; 0x40
{
8f609e54:	e5933000 	ldr	r3, [r3]
8f609e58:	e58d3054 	str	r3, [r13, #84]	; 0x54
8f609e5c:	e3a03000 	mov	r3, #0
	card->ext_csd = memalign(CACHE_LINE, ROUNDUP(512, CACHE_LINE));
8f609e60:	e1a0600e 	mov	r6, r14
8f609e64:	eb00a876 	bl	8f634044 <memalign>
	ASSERT(card->ext_csd);
8f609e68:	e3500000 	cmp	r0, #0
	card->ext_csd = memalign(CACHE_LINE, ROUNDUP(512, CACHE_LINE));
8f609e6c:	e5840020 	str	r0, [r4, #32]
	ASSERT(card->ext_csd);
8f609e70:	0a00001e 	beq	8f609ef0 <mmc_get_ext_csd+0xb8>
	memset(card->ext_csd, 0, sizeof(card->ext_csd));
8f609e74:	e3a02004 	mov	r2, #4
8f609e78:	e3a01000 	mov	r1, #0
8f609e7c:	eb00a910 	bl	8f6342c4 <memset>
	arch_invalidate_cache_range((addr_t) card->ext_csd, 512);
8f609e80:	e5940020 	ldr	r0, [r4, #32]
8f609e84:	e3a01c02 	mov	r1, #512	; 0x200
8f609e88:	eb005c4e 	bl	8f620fc8 <arch_invalidate_cache_range>
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f609e8c:	e3a01000 	mov	r1, #0
8f609e90:	e3a02048 	mov	r2, #72	; 0x48
8f609e94:	e28d0008 	add	r0, r13, #8
8f609e98:	eb00a909 	bl	8f6342c4 <memset>
	cmd.data.data_ptr = card->ext_csd;
8f609e9c:	e5942020 	ldr	r2, [r4, #32]
	cmd.data.num_blocks = 1;
8f609ea0:	e3a03001 	mov	r3, #1
	mmc_ret = sdhci_send_command(host, &cmd);
8f609ea4:	e28d1008 	add	r1, r13, #8
8f609ea8:	e1a00005 	mov	r0, r5
	cmd.cmd_index = CMD8_SEND_EXT_CSD;
8f609eac:	e3a0c008 	mov	r12, #8
	cmd.data.data_ptr = card->ext_csd;
8f609eb0:	e58d203c 	str	r2, [r13, #60]	; 0x3c
	cmd.data_present = 0x1;
8f609eb4:	e1a02003 	mov	r2, r3
	cmd.data.num_blocks = 1;
8f609eb8:	e58d3044 	str	r3, [r13, #68]	; 0x44
	cmd.data_present = 0x1;
8f609ebc:	e3402001 	movt	r2, #1
	cmd.trans_mode = SDHCI_MMC_READ;
8f609ec0:	e58d3024 	str	r3, [r13, #36]	; 0x24
	cmd.data_present = 0x1;
8f609ec4:	e58d2010 	str	r2, [r13, #16]
	cmd.cmd_index = CMD8_SEND_EXT_CSD;
8f609ec8:	e1cdc0b8 	strh	r12, [r13, #8]
	mmc_ret = sdhci_send_command(host, &cmd);
8f609ecc:	ebfff8e6 	bl	8f60826c <sdhci_send_command>
}
8f609ed0:	e59f304c 	ldr	r3, [pc, #76]	; 8f609f24 <mmc_get_ext_csd+0xec>
8f609ed4:	e5932000 	ldr	r2, [r3]
8f609ed8:	e59d3054 	ldr	r3, [r13, #84]	; 0x54
8f609edc:	e0332002 	eors	r2, r3, r2
8f609ee0:	e3a03000 	mov	r3, #0
8f609ee4:	1a00000d 	bne	8f609f20 <mmc_get_ext_csd+0xe8>
8f609ee8:	e28dd058 	add	r13, r13, #88	; 0x58
8f609eec:	e8bd8070 	pop	{r4, r5, r6, r15}
	ASSERT(card->ext_csd);
8f609ef0:	e1a00006 	mov	r0, r6
8f609ef4:	e30223f0 	movw	r2, #9200	; 0x23f0
8f609ef8:	e30032b6 	movw	r3, #694	; 0x2b6
8f609efc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f609f00:	e3001130 	movw	r1, #304	; 0x130
8f609f04:	e58d2000 	str	r2, [r13]
8f609f08:	e3481f70 	movt	r1, #36720	; 0x8f70
8f609f0c:	e30223d0 	movw	r2, #9168	; 0x23d0
8f609f10:	e3482f70 	movt	r2, #36720	; 0x8f70
8f609f14:	eb00a2e8 	bl	8f632abc <_panic>
	memset(card->ext_csd, 0, sizeof(card->ext_csd));
8f609f18:	e5940020 	ldr	r0, [r4, #32]
8f609f1c:	eaffffd4 	b	8f609e74 <mmc_get_ext_csd+0x3c>
}
8f609f20:	eb00a326 	bl	8f632bc0 <__stack_chk_fail>
8f609f24:	8f74221c 	.word	0x8f74221c

8f609f28 <mmc_parse_response>:

	return dev;
}

static uint32_t mmc_parse_response(uint32_t resp)
{
8f609f28:	e59f20fc 	ldr	r2, [pc, #252]	; 8f60a02c <mmc_parse_response+0x104>
	/* Trying to write beyond card capacity */
	if (resp & MMC_R1_ADDR_OUT_OF_RANGE) {
8f609f2c:	e2503000 	subs	r3, r0, #0
{
8f609f30:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f609f34:	e24dd00c 	sub	r13, r13, #12
8f609f38:	e5922000 	ldr	r2, [r2]
8f609f3c:	e58d2004 	str	r2, [r13, #4]
8f609f40:	e3a02000 	mov	r2, #0
	if (resp & MMC_R1_ADDR_OUT_OF_RANGE) {
8f609f44:	ba000023 	blt	8f609fd8 <mmc_parse_response+0xb0>
		dprintf(CRITICAL, "Attempting to read or write beyond the Device capacity\n");
		return 1;
	}

	/* Misaligned address not matching block length */
	if (resp & MMC_R1_ADDR_ERR) {
8f609f48:	e3130101 	tst	r3, #1073741824	; 0x40000000
8f609f4c:	1a00001c 	bne	8f609fc4 <mmc_parse_response+0x9c>
		dprintf(CRITICAL, "The misaligned address did not match the block length used\n");
		return 1;
	}

	/* Invalid block length */
	if (resp & MMC_R1_BLOCK_LEN_ERR) {
8f609f50:	e3130202 	tst	r3, #536870912	; 0x20000000
8f609f54:	1a000024 	bne	8f609fec <mmc_parse_response+0xc4>
		dprintf(CRITICAL, "The transferred bytes does not match the block length\n");
		return 1;
	}

	/* Tried to program write protected block */
	if (resp & MMC_R1_WP_VIOLATION) {
8f609f58:	e3130301 	tst	r3, #67108864	; 0x4000000
8f609f5c:	1a00000e 	bne	8f609f9c <mmc_parse_response+0x74>
		dprintf(CRITICAL, "Attempt to program a write protected block\n");
		return 1;
	}

	/* card controller error */
	if (resp & MMC_R1_CC_ERROR) {
8f609f60:	e3130601 	tst	r3, #1048576	; 0x100000
8f609f64:	1a000025 	bne	8f60a000 <mmc_parse_response+0xd8>
		dprintf(CRITICAL, "Device error occurred, which is not related to the host command\n");
		return 1;
	}

	/* Generic error */
	if (resp & MMC_R1_GENERIC_ERR) {
8f609f68:	e2130702 	ands	r0, r3, #524288	; 0x80000
8f609f6c:	1a000028 	bne	8f60a014 <mmc_parse_response+0xec>
		dprintf(CRITICAL, "A generic Device error\n");
		return 1;
	}

	/* Finally check for card in TRAN state */
	if (MMC_CARD_STATUS(resp) != MMC_TRAN_STATE) {
8f609f70:	e7e334d3 	ubfx	r3, r3, #9, #4
8f609f74:	e3530004 	cmp	r3, #4
8f609f78:	1a00000c 	bne	8f609fb0 <mmc_parse_response+0x88>
		dprintf(CRITICAL, "MMC card is not in TRAN state\n");
		return 1;
	}

	return 0;
}
8f609f7c:	e59f30a8 	ldr	r3, [pc, #168]	; 8f60a02c <mmc_parse_response+0x104>
8f609f80:	e5932000 	ldr	r2, [r3]
8f609f84:	e59d3004 	ldr	r3, [r13, #4]
8f609f88:	e0332002 	eors	r2, r3, r2
8f609f8c:	e3a03000 	mov	r3, #0
8f609f90:	1a000024 	bne	8f60a028 <mmc_parse_response+0x100>
8f609f94:	e28dd00c 	add	r13, r13, #12
8f609f98:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		dprintf(CRITICAL, "Attempt to program a write protected block\n");
8f609f9c:	e30204ac 	movw	r0, #9388	; 0x24ac
8f609fa0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f609fa4:	eb00a272 	bl	8f632974 <_dprintf>
		return 1;
8f609fa8:	e3a00001 	mov	r0, #1
8f609fac:	eafffff2 	b	8f609f7c <mmc_parse_response+0x54>
		dprintf(CRITICAL, "MMC card is not in TRAN state\n");
8f609fb0:	e3020534 	movw	r0, #9524	; 0x2534
8f609fb4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f609fb8:	eb00a26d 	bl	8f632974 <_dprintf>
		return 1;
8f609fbc:	e3a00001 	mov	r0, #1
8f609fc0:	eaffffed 	b	8f609f7c <mmc_parse_response+0x54>
		dprintf(CRITICAL, "The misaligned address did not match the block length used\n");
8f609fc4:	e3020438 	movw	r0, #9272	; 0x2438
8f609fc8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f609fcc:	eb00a268 	bl	8f632974 <_dprintf>
		return 1;
8f609fd0:	e3a00001 	mov	r0, #1
8f609fd4:	eaffffe8 	b	8f609f7c <mmc_parse_response+0x54>
		dprintf(CRITICAL, "Attempting to read or write beyond the Device capacity\n");
8f609fd8:	e3020400 	movw	r0, #9216	; 0x2400
8f609fdc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f609fe0:	eb00a263 	bl	8f632974 <_dprintf>
		return 1;
8f609fe4:	e3a00001 	mov	r0, #1
8f609fe8:	eaffffe3 	b	8f609f7c <mmc_parse_response+0x54>
		dprintf(CRITICAL, "The transferred bytes does not match the block length\n");
8f609fec:	e3020474 	movw	r0, #9332	; 0x2474
8f609ff0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f609ff4:	eb00a25e 	bl	8f632974 <_dprintf>
		return 1;
8f609ff8:	e3a00001 	mov	r0, #1
8f609ffc:	eaffffde 	b	8f609f7c <mmc_parse_response+0x54>
		dprintf(CRITICAL, "Device error occurred, which is not related to the host command\n");
8f60a000:	e30204d8 	movw	r0, #9432	; 0x24d8
8f60a004:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a008:	eb00a259 	bl	8f632974 <_dprintf>
		return 1;
8f60a00c:	e3a00001 	mov	r0, #1
8f60a010:	eaffffd9 	b	8f609f7c <mmc_parse_response+0x54>
		dprintf(CRITICAL, "A generic Device error\n");
8f60a014:	e302051c 	movw	r0, #9500	; 0x251c
8f60a018:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a01c:	eb00a254 	bl	8f632974 <_dprintf>
		return 1;
8f60a020:	e3a00001 	mov	r0, #1
8f60a024:	eaffffd4 	b	8f609f7c <mmc_parse_response+0x54>
}
8f60a028:	eb00a2e4 	bl	8f632bc0 <__stack_chk_fail>
8f60a02c:	8f74221c 	.word	0x8f74221c

8f60a030 <mmc_stop_command>:

static uint32_t mmc_stop_command(struct mmc_device *dev)
{
8f60a030:	e92d4010 	push	{r4, r14}
8f60a034:	e24dd050 	sub	r13, r13, #80	; 0x50
8f60a038:	e59f3098 	ldr	r3, [pc, #152]	; 8f60a0d8 <mmc_stop_command+0xa8>
8f60a03c:	e1a04000 	mov	r4, r0
	struct mmc_command cmd;
	uint32_t mmc_ret = 0;

	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60a040:	e3a02048 	mov	r2, #72	; 0x48
8f60a044:	e3a01000 	mov	r1, #0
8f60a048:	e1a0000d 	mov	r0, r13
{
8f60a04c:	e5933000 	ldr	r3, [r3]
8f60a050:	e58d304c 	str	r3, [r13, #76]	; 0x4c
8f60a054:	e3a03000 	mov	r3, #0
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60a058:	eb00a899 	bl	8f6342c4 <memset>

	cmd.cmd_index = CMD12_STOP_TRANSMISSION;
	cmd.argument = (dev->card.rca << 16);
8f60a05c:	e5943038 	ldr	r3, [r4, #56]	; 0x38
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
	cmd.resp_type = SDHCI_CMD_RESP_R1;

	mmc_ret = sdhci_send_command(&dev->host, &cmd);
8f60a060:	e1a00004 	mov	r0, r4
8f60a064:	e1a0100d 	mov	r1, r13
	cmd.cmd_index = CMD12_STOP_TRANSMISSION;
8f60a068:	e3a0c00c 	mov	r12, #12
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60a06c:	e3a02000 	mov	r2, #0
	cmd.argument = (dev->card.rca << 16);
8f60a070:	e1a03803 	lsl	r3, r3, #16
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60a074:	e5cd2009 	strb	r2, [r13, #9]
	cmd.cmd_index = CMD12_STOP_TRANSMISSION;
8f60a078:	e1cdc0b0 	strh	r12, [r13]
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60a07c:	e3a02001 	mov	r2, #1
	cmd.argument = (dev->card.rca << 16);
8f60a080:	e58d3004 	str	r3, [r13, #4]
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60a084:	e1cd20ba 	strh	r2, [r13, #10]
	mmc_ret = sdhci_send_command(&dev->host, &cmd);
8f60a088:	ebfff877 	bl	8f60826c <sdhci_send_command>
	if(mmc_ret)
8f60a08c:	e2504000 	subs	r4, r0, #0
8f60a090:	1a00000b 	bne	8f60a0c4 <mmc_stop_command+0x94>
	}

	/* Response contains 32 bit Card status.
	 * Parse the errors & provide relevant information */

	return mmc_parse_response(cmd.resp[0]);
8f60a094:	e59d000c 	ldr	r0, [r13, #12]
8f60a098:	ebffffa2 	bl	8f609f28 <mmc_parse_response>
8f60a09c:	e1a04000 	mov	r4, r0
}
8f60a0a0:	e59f3030 	ldr	r3, [pc, #48]	; 8f60a0d8 <mmc_stop_command+0xa8>
8f60a0a4:	e5932000 	ldr	r2, [r3]
8f60a0a8:	e59d304c 	ldr	r3, [r13, #76]	; 0x4c
8f60a0ac:	e0332002 	eors	r2, r3, r2
8f60a0b0:	e3a03000 	mov	r3, #0
8f60a0b4:	1a000006 	bne	8f60a0d4 <mmc_stop_command+0xa4>
8f60a0b8:	e1a00004 	mov	r0, r4
8f60a0bc:	e28dd050 	add	r13, r13, #80	; 0x50
8f60a0c0:	e8bd8010 	pop	{r4, r15}
		dprintf(CRITICAL, "Failed to send stop command\n");
8f60a0c4:	e3020554 	movw	r0, #9556	; 0x2554
8f60a0c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a0cc:	eb00a228 	bl	8f632974 <_dprintf>
		return mmc_ret;
8f60a0d0:	eafffff2 	b	8f60a0a0 <mmc_stop_command+0x70>
}
8f60a0d4:	eb00a2b9 	bl	8f632bc0 <__stack_chk_fail>
8f60a0d8:	8f74221c 	.word	0x8f74221c

8f60a0dc <mmc_set_ddr_mode>:
{
8f60a0dc:	e92d4070 	push	{r4, r5, r6, r14}
8f60a0e0:	e24dd010 	sub	r13, r13, #16
8f60a0e4:	e59f2090 	ldr	r2, [pc, #144]	; 8f60a17c <mmc_set_ddr_mode+0xa0>
	mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
8f60a0e8:	e3a03006 	mov	r3, #6
8f60a0ec:	e58d3000 	str	r3, [r13]
8f60a0f0:	e3a030b7 	mov	r3, #183	; 0xb7
{
8f60a0f4:	e5922000 	ldr	r2, [r2]
8f60a0f8:	e58d200c 	str	r2, [r13, #12]
8f60a0fc:	e3a02000 	mov	r2, #0
	mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
8f60a100:	e3a02003 	mov	r2, #3
{
8f60a104:	e1a05000 	mov	r5, r0
8f60a108:	e1a06001 	mov	r6, r1
	mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
8f60a10c:	ebfffef3 	bl	8f609ce0 <mmc_switch_cmd>
	if (mmc_ret) {
8f60a110:	e2504000 	subs	r4, r0, #0
8f60a114:	1a00000d 	bne	8f60a150 <mmc_set_ddr_mode+0x74>
	MMC_SAVE_TIMING(host, SDHCI_DDR50_MODE);
8f60a118:	e3a01004 	mov	r1, #4
	sdhci_set_uhs_mode(host, SDHCI_DDR50_MODE);
8f60a11c:	e1a00005 	mov	r0, r5
	MMC_SAVE_TIMING(host, SDHCI_DDR50_MODE);
8f60a120:	e5851008 	str	r1, [r5, #8]
	sdhci_set_uhs_mode(host, SDHCI_DDR50_MODE);
8f60a124:	e3a04000 	mov	r4, #0
8f60a128:	ebfff7e5 	bl	8f6080c4 <sdhci_set_uhs_mode>
}
8f60a12c:	e59f3048 	ldr	r3, [pc, #72]	; 8f60a17c <mmc_set_ddr_mode+0xa0>
8f60a130:	e5932000 	ldr	r2, [r3]
8f60a134:	e59d300c 	ldr	r3, [r13, #12]
8f60a138:	e0332002 	eors	r2, r3, r2
8f60a13c:	e3a03000 	mov	r3, #0
8f60a140:	1a00000c 	bne	8f60a178 <mmc_set_ddr_mode+0x9c>
8f60a144:	e1a00004 	mov	r0, r4
8f60a148:	e28dd010 	add	r13, r13, #16
8f60a14c:	e8bd8070 	pop	{r4, r5, r6, r15}
		dprintf(CRITICAL, "Switch cmd failed\n");
8f60a150:	e3020574 	movw	r0, #9588	; 0x2574
8f60a154:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a158:	eb00a205 	bl	8f632974 <_dprintf>
	if (mmc_ret) {
8f60a15c:	e21440ff 	ands	r4, r4, #255	; 0xff
8f60a160:	0affffec 	beq	8f60a118 <mmc_set_ddr_mode+0x3c>
		dprintf(CRITICAL, "Failure to set DDR mode for Card(RCA:%x)\n",
8f60a164:	e5961000 	ldr	r1, [r6]
8f60a168:	e3020588 	movw	r0, #9608	; 0x2588
8f60a16c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a170:	eb00a1ff 	bl	8f632974 <_dprintf>
		return mmc_ret;
8f60a174:	eaffffec 	b	8f60a12c <mmc_set_ddr_mode+0x50>
}
8f60a178:	eb00a290 	bl	8f632bc0 <__stack_chk_fail>
8f60a17c:	8f74221c 	.word	0x8f74221c

8f60a180 <mmc_set_hs200_mode>:
{
8f60a180:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f60a184:	e24dd014 	sub	r13, r13, #20
8f60a188:	e59f3170 	ldr	r3, [pc, #368]	; 8f60a300 <mmc_set_hs200_mode+0x180>
8f60a18c:	e1a07002 	mov	r7, r2
	mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
8f60a190:	e58d2000 	str	r2, [r13]
8f60a194:	e3a02003 	mov	r2, #3
{
8f60a198:	e5933000 	ldr	r3, [r3]
8f60a19c:	e58d300c 	str	r3, [r13, #12]
8f60a1a0:	e3a03000 	mov	r3, #0
	mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
8f60a1a4:	e3a030b7 	mov	r3, #183	; 0xb7
{
8f60a1a8:	e1a05000 	mov	r5, r0
8f60a1ac:	e1a06001 	mov	r6, r1
	mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
8f60a1b0:	ebfffeca 	bl	8f609ce0 <mmc_switch_cmd>
	if (mmc_ret) {
8f60a1b4:	e2504000 	subs	r4, r0, #0
8f60a1b8:	1a000034 	bne	8f60a290 <mmc_set_hs200_mode+0x110>
	mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE, MMC_EXT_MMC_HS_TIMING, MMC_HS200_TIMING);
8f60a1bc:	e3a02002 	mov	r2, #2
8f60a1c0:	e3a030b9 	mov	r3, #185	; 0xb9
8f60a1c4:	e58d2000 	str	r2, [r13]
8f60a1c8:	e1a01006 	mov	r1, r6
8f60a1cc:	e3a02003 	mov	r2, #3
8f60a1d0:	e1a00005 	mov	r0, r5
8f60a1d4:	ebfffec1 	bl	8f609ce0 <mmc_switch_cmd>
	if (mmc_ret) {
8f60a1d8:	e2504000 	subs	r4, r0, #0
8f60a1dc:	1a000033 	bne	8f60a2b0 <mmc_set_hs200_mode+0x130>
	sdhci_set_uhs_mode(host, SDHCI_SDR104_MODE);
8f60a1e0:	e3a01003 	mov	r1, #3
8f60a1e4:	e1a00005 	mov	r0, r5
8f60a1e8:	ebfff7b5 	bl	8f6080c4 <sdhci_set_uhs_mode>
	if (host->caps.hs400_support && mmc_card_supports_hs400_mode(card))
8f60a1ec:	e5d5302c 	ldrb	r3, [r5, #44]	; 0x2c
8f60a1f0:	e3530000 	cmp	r3, #0
8f60a1f4:	1a000013 	bne	8f60a248 <mmc_set_hs200_mode+0xc8>
	if ((mmc_ret = sdhci_msm_execute_tuning(host, card, width)))
8f60a1f8:	e1a02007 	mov	r2, r7
8f60a1fc:	e1a01006 	mov	r1, r6
8f60a200:	e1a00005 	mov	r0, r5
8f60a204:	ebfffc9d 	bl	8f609480 <sdhci_msm_execute_tuning>
8f60a208:	e2504000 	subs	r4, r0, #0
8f60a20c:	1a00002c 	bne	8f60a2c4 <mmc_set_hs200_mode+0x144>
	if (host->timing == MMC_HS400_TIMING)
8f60a210:	e5953008 	ldr	r3, [r5, #8]
8f60a214:	e3530003 	cmp	r3, #3
		MMC_SAVE_TIMING(host, MMC_HS200_TIMING);
8f60a218:	13a03002 	movne	r3, #2
8f60a21c:	15853008 	strne	r3, [r5, #8]
	if (host->timing == MMC_HS400_TIMING)
8f60a220:	0a00002b 	beq	8f60a2d4 <mmc_set_hs200_mode+0x154>
}
8f60a224:	e59f30d4 	ldr	r3, [pc, #212]	; 8f60a300 <mmc_set_hs200_mode+0x180>
8f60a228:	e5932000 	ldr	r2, [r3]
8f60a22c:	e59d300c 	ldr	r3, [r13, #12]
8f60a230:	e0332002 	eors	r2, r3, r2
8f60a234:	e3a03000 	mov	r3, #0
8f60a238:	1a00002f 	bne	8f60a2fc <mmc_set_hs200_mode+0x17c>
8f60a23c:	e1a00004 	mov	r0, r4
8f60a240:	e28dd014 	add	r13, r13, #20
8f60a244:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
	if (MMC_CARD_MMC(card)) {
8f60a248:	e5963018 	ldr	r3, [r6, #24]
8f60a24c:	e2433003 	sub	r3, r3, #3
8f60a250:	e3530001 	cmp	r3, #1
8f60a254:	8affffe7 	bhi	8f60a1f8 <mmc_set_hs200_mode+0x78>
		if (card->ext_csd[MMC_DEVICE_TYPE] & MMC_HS_HS400_MODE)
8f60a258:	e5963020 	ldr	r3, [r6, #32]
8f60a25c:	e5d330c4 	ldrb	r3, [r3, #196]	; 0xc4
8f60a260:	e31300c0 	tst	r3, #192	; 0xc0
8f60a264:	0affffe3 	beq	8f60a1f8 <mmc_set_hs200_mode+0x78>
		sdhci_msm_set_mci_clk(host);
8f60a268:	e1a00005 	mov	r0, r5
		MMC_SAVE_TIMING(host, MMC_HS400_TIMING);
8f60a26c:	e3a03003 	mov	r3, #3
8f60a270:	e5853008 	str	r3, [r5, #8]
		sdhci_msm_set_mci_clk(host);
8f60a274:	ebfffc3a 	bl	8f609364 <sdhci_msm_set_mci_clk>
		clock_config_mmc(host->msm_host->slot, SDHCI_CLK_400MHZ);
8f60a278:	e5953030 	ldr	r3, [r5, #48]	; 0x30
8f60a27c:	e3a01b21 	mov	r1, #33792	; 0x8400
8f60a280:	e34117d7 	movt	r1, #6103	; 0x17d7
8f60a284:	e5d3000b 	ldrb	r0, [r3, #11]
8f60a288:	ebffde92 	bl	8f601cd8 <clock_config_mmc>
8f60a28c:	eaffffd9 	b	8f60a1f8 <mmc_set_hs200_mode+0x78>
		dprintf(CRITICAL, "Switch cmd failed\n");
8f60a290:	e3020574 	movw	r0, #9588	; 0x2574
8f60a294:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a298:	eb00a1b5 	bl	8f632974 <_dprintf>
		dprintf(CRITICAL, "Failure to set wide bus for Card(RCA:%x)\n",
8f60a29c:	e5961000 	ldr	r1, [r6]
8f60a2a0:	e30205b4 	movw	r0, #9652	; 0x25b4
8f60a2a4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a2a8:	eb00a1b1 	bl	8f632974 <_dprintf>
		return mmc_ret;
8f60a2ac:	eaffffdc 	b	8f60a224 <mmc_set_hs200_mode+0xa4>
		dprintf(CRITICAL, "Switch cmd returned failure %d\n", __LINE__);
8f60a2b0:	e3a01d0e 	mov	r1, #896	; 0x380
8f60a2b4:	e30205e0 	movw	r0, #9696	; 0x25e0
8f60a2b8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a2bc:	eb00a1ac 	bl	8f632974 <_dprintf>
		return mmc_ret;
8f60a2c0:	eaffffd7 	b	8f60a224 <mmc_set_hs200_mode+0xa4>
		dprintf(CRITICAL, "Tuning for hs200 failed\n");
8f60a2c4:	e3020600 	movw	r0, #9728	; 0x2600
8f60a2c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a2cc:	eb00a1a8 	bl	8f632974 <_dprintf>
8f60a2d0:	eaffffce 	b	8f60a210 <mmc_set_hs200_mode+0x90>
		sdhci_msm_set_mci_clk(host);
8f60a2d4:	e1a00005 	mov	r0, r5
		MMC_SAVE_TIMING(host, MMC_HS200_TIMING);
8f60a2d8:	e3a03002 	mov	r3, #2
8f60a2dc:	e5853008 	str	r3, [r5, #8]
		sdhci_msm_set_mci_clk(host);
8f60a2e0:	ebfffc1f 	bl	8f609364 <sdhci_msm_set_mci_clk>
		clock_config_mmc(host->msm_host->slot, MMC_CLK_192MHZ);
8f60a2e4:	e5953030 	ldr	r3, [r5, #48]	; 0x30
8f60a2e8:	e3a01a0b 	mov	r1, #45056	; 0xb000
8f60a2ec:	e3401b71 	movt	r1, #2929	; 0xb71
8f60a2f0:	e5d3000b 	ldrb	r0, [r3, #11]
8f60a2f4:	ebffde77 	bl	8f601cd8 <clock_config_mmc>
8f60a2f8:	eaffffc9 	b	8f60a224 <mmc_set_hs200_mode+0xa4>
}
8f60a2fc:	eb00a22f 	bl	8f632bc0 <__stack_chk_fail>
8f60a300:	8f74221c 	.word	0x8f74221c

8f60a304 <mmc_set_drv_type>:
	if (MMC_CARD_MMC(card)) {
8f60a304:	e591c018 	ldr	r12, [r1, #24]
{
8f60a308:	e92d4010 	push	{r4, r14}
	if (MMC_CARD_MMC(card)) {
8f60a30c:	e24cc003 	sub	r12, r12, #3
{
8f60a310:	e59fe070 	ldr	r14, [pc, #112]	; 8f60a388 <mmc_set_drv_type+0x84>
	if (MMC_CARD_MMC(card)) {
8f60a314:	e35c0001 	cmp	r12, #1
{
8f60a318:	e24dd010 	sub	r13, r13, #16
8f60a31c:	e59ee000 	ldr	r14, [r14]
8f60a320:	e58de00c 	str	r14, [r13, #12]
8f60a324:	e3a0e000 	mov	r14, #0
	bool drv_type_changed = false;
8f60a328:	83a04000 	movhi	r4, #0
	if (MMC_CARD_MMC(card)) {
8f60a32c:	9a000008 	bls	8f60a354 <mmc_set_drv_type+0x50>
}
8f60a330:	e59f3050 	ldr	r3, [pc, #80]	; 8f60a388 <mmc_set_drv_type+0x84>
8f60a334:	e5932000 	ldr	r2, [r3]
8f60a338:	e59d300c 	ldr	r3, [r13, #12]
8f60a33c:	e0332002 	eors	r2, r3, r2
8f60a340:	e3a03000 	mov	r3, #0
8f60a344:	1a00000e 	bne	8f60a384 <mmc_set_drv_type+0x80>
8f60a348:	e1a00004 	mov	r0, r4
8f60a34c:	e28dd010 	add	r13, r13, #16
8f60a350:	e8bd8010 	pop	{r4, r15}
		if (card->ext_csd[MMC_EXT_MMC_DRV_STRENGTH] & (1 << drv_type)){
8f60a354:	e5913020 	ldr	r3, [r1, #32]
8f60a358:	e5d340c5 	ldrb	r4, [r3, #197]	; 0xc5
8f60a35c:	e1a04254 	asr	r4, r4, r2
8f60a360:	e2144001 	ands	r4, r4, #1
8f60a364:	0afffff1 	beq	8f60a330 <mmc_set_drv_type+0x2c>
	uint32_t value = ((drv_type << 4) | MMC_HS200_TIMING);
8f60a368:	e1a02202 	lsl	r2, r2, #4
			mmc_switch_cmd(host, card, MMC_ACCESS_WRITE, MMC_EXT_MMC_HS_TIMING, value);
8f60a36c:	e3a030b9 	mov	r3, #185	; 0xb9
	uint32_t value = ((drv_type << 4) | MMC_HS200_TIMING);
8f60a370:	e3822002 	orr	r2, r2, #2
			mmc_switch_cmd(host, card, MMC_ACCESS_WRITE, MMC_EXT_MMC_HS_TIMING, value);
8f60a374:	e58d2000 	str	r2, [r13]
8f60a378:	e3a02003 	mov	r2, #3
8f60a37c:	ebfffe57 	bl	8f609ce0 <mmc_switch_cmd>
			drv_type_changed = true;
8f60a380:	eaffffea 	b	8f60a330 <mmc_set_drv_type+0x2c>
}
8f60a384:	eb00a20d 	bl	8f632bc0 <__stack_chk_fail>
8f60a388:	8f74221c 	.word	0x8f74221c

8f60a38c <mmc_set_hs400_mode>:
{
8f60a38c:	e59f31bc 	ldr	r3, [pc, #444]	; 8f60a550 <mmc_set_hs400_mode+0x1c4>
	if (width != DATA_BUS_WIDTH_8BIT)
8f60a390:	e3520002 	cmp	r2, #2
{
8f60a394:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f60a398:	e24dd010 	sub	r13, r13, #16
8f60a39c:	e5933000 	ldr	r3, [r3]
8f60a3a0:	e58d300c 	str	r3, [r13, #12]
8f60a3a4:	e3a03000 	mov	r3, #0
8f60a3a8:	e1a06002 	mov	r6, r2
	if (width != DATA_BUS_WIDTH_8BIT)
8f60a3ac:	0a00000d 	beq	8f60a3e8 <mmc_set_hs400_mode+0x5c>
		dprintf(CRITICAL, "Bus width is not 8-bit, cannot switch to hs400: %u\n", width);
8f60a3b0:	e302061c 	movw	r0, #9756	; 0x261c
8f60a3b4:	e1a01002 	mov	r1, r2
8f60a3b8:	e3480f70 	movt	r0, #36720	; 0x8f70
		return 1;
8f60a3bc:	e3a04001 	mov	r4, #1
		dprintf(CRITICAL, "Bus width is not 8-bit, cannot switch to hs400: %u\n", width);
8f60a3c0:	eb00a16b 	bl	8f632974 <_dprintf>
}
8f60a3c4:	e59f3184 	ldr	r3, [pc, #388]	; 8f60a550 <mmc_set_hs400_mode+0x1c4>
8f60a3c8:	e5932000 	ldr	r2, [r3]
8f60a3cc:	e59d300c 	ldr	r3, [r13, #12]
8f60a3d0:	e0332002 	eors	r2, r3, r2
8f60a3d4:	e3a03000 	mov	r3, #0
8f60a3d8:	1a00005b 	bne	8f60a54c <mmc_set_hs400_mode+0x1c0>
8f60a3dc:	e1a00004 	mov	r0, r4
8f60a3e0:	e28dd010 	add	r13, r13, #16
8f60a3e4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
	mmc_ret = mmc_set_hs200_mode(host, card, width);
8f60a3e8:	e1a05000 	mov	r5, r0
8f60a3ec:	e1a07001 	mov	r7, r1
8f60a3f0:	ebffff62 	bl	8f60a180 <mmc_set_hs200_mode>
	if (mmc_ret)
8f60a3f4:	e2504000 	subs	r4, r0, #0
8f60a3f8:	1a000033 	bne	8f60a4cc <mmc_set_hs400_mode+0x140>
	sdhci_set_uhs_mode(host, SDHCI_SDR12_MODE);
8f60a3fc:	e1a01004 	mov	r1, r4
8f60a400:	e1a00005 	mov	r0, r5
	MMC_SAVE_TIMING(host, SDHCI_SDR12_MODE);
8f60a404:	e5854008 	str	r4, [r5, #8]
	mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
8f60a408:	e3a08001 	mov	r8, #1
	sdhci_set_uhs_mode(host, SDHCI_SDR12_MODE);
8f60a40c:	ebfff72c 	bl	8f6080c4 <sdhci_set_uhs_mode>
	mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
8f60a410:	e3a030b9 	mov	r3, #185	; 0xb9
8f60a414:	e3a02003 	mov	r2, #3
8f60a418:	e1a01007 	mov	r1, r7
8f60a41c:	e1a00005 	mov	r0, r5
8f60a420:	e58d8000 	str	r8, [r13]
8f60a424:	ebfffe2d 	bl	8f609ce0 <mmc_switch_cmd>
	if (mmc_ret) {
8f60a428:	e2504000 	subs	r4, r0, #0
8f60a42c:	1a000034 	bne	8f60a504 <mmc_set_hs400_mode+0x178>
	sdhci_set_uhs_mode(host, SDHCI_SDR25_MODE);
8f60a430:	e1a01008 	mov	r1, r8
8f60a434:	e1a00005 	mov	r0, r5
	MMC_SAVE_TIMING(host, SDHCI_SDR25_MODE);
8f60a438:	e5858008 	str	r8, [r5, #8]
	sdhci_set_uhs_mode(host, SDHCI_SDR25_MODE);
8f60a43c:	ebfff720 	bl	8f6080c4 <sdhci_set_uhs_mode>
	mmc_ret = mmc_set_ddr_mode(host, card);
8f60a440:	e1a01007 	mov	r1, r7
8f60a444:	e1a00005 	mov	r0, r5
8f60a448:	ebffff23 	bl	8f60a0dc <mmc_set_ddr_mode>
	if (mmc_ret)
8f60a44c:	e2504000 	subs	r4, r0, #0
8f60a450:	1a000024 	bne	8f60a4e8 <mmc_set_hs400_mode+0x15c>
	mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE, MMC_EXT_MMC_HS_TIMING, MMC_HS400_TIMING);
8f60a454:	e3a08003 	mov	r8, #3
8f60a458:	e3a030b9 	mov	r3, #185	; 0xb9
8f60a45c:	e1a02008 	mov	r2, r8
8f60a460:	e1a01007 	mov	r1, r7
8f60a464:	e1a00005 	mov	r0, r5
8f60a468:	e58d8000 	str	r8, [r13]
8f60a46c:	ebfffe1b 	bl	8f609ce0 <mmc_switch_cmd>
	if (mmc_ret)
8f60a470:	e2504000 	subs	r4, r0, #0
8f60a474:	1a00002d 	bne	8f60a530 <mmc_set_hs400_mode+0x1a4>
	sdhci_set_uhs_mode(host, SDHCI_SDR104_MODE);
8f60a478:	e1a01008 	mov	r1, r8
8f60a47c:	e1a00005 	mov	r0, r5
	MMC_SAVE_TIMING(host, MMC_HS400_TIMING);
8f60a480:	e5858008 	str	r8, [r5, #8]
	sdhci_set_uhs_mode(host, SDHCI_SDR104_MODE);
8f60a484:	ebfff70e 	bl	8f6080c4 <sdhci_set_uhs_mode>
	sdhci_msm_set_mci_clk(host);
8f60a488:	e1a00005 	mov	r0, r5
8f60a48c:	ebfffbb4 	bl	8f609364 <sdhci_msm_set_mci_clk>
	clock_config_mmc(host->msm_host->slot, SDHCI_CLK_400MHZ);
8f60a490:	e5953030 	ldr	r3, [r5, #48]	; 0x30
8f60a494:	e3a01b21 	mov	r1, #33792	; 0x8400
8f60a498:	e34117d7 	movt	r1, #6103	; 0x17d7
8f60a49c:	e5d3000b 	ldrb	r0, [r3, #11]
8f60a4a0:	ebffde0c 	bl	8f601cd8 <clock_config_mmc>
	if ((mmc_ret = sdhci_msm_execute_tuning(host, card, width)))
8f60a4a4:	e1a02006 	mov	r2, r6
8f60a4a8:	e1a01007 	mov	r1, r7
8f60a4ac:	e1a00005 	mov	r0, r5
8f60a4b0:	ebfffbf2 	bl	8f609480 <sdhci_msm_execute_tuning>
8f60a4b4:	e2504000 	subs	r4, r0, #0
8f60a4b8:	0affffc1 	beq	8f60a3c4 <mmc_set_hs400_mode+0x38>
		dprintf(CRITICAL, "Tuning for hs400 failed\n");
8f60a4bc:	e30206e0 	movw	r0, #9952	; 0x26e0
8f60a4c0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a4c4:	eb00a12a 	bl	8f632974 <_dprintf>
8f60a4c8:	eaffffbd 	b	8f60a3c4 <mmc_set_hs400_mode+0x38>
		dprintf(CRITICAL, "Failure Setting HS200 mode %s\t%d\n",__func__, __LINE__);
8f60a4cc:	e3a02e41 	mov	r2, #1040	; 0x410
8f60a4d0:	e30311b4 	movw	r1, #12724	; 0x31b4
8f60a4d4:	e3020650 	movw	r0, #9808	; 0x2650
8f60a4d8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60a4dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a4e0:	eb00a123 	bl	8f632974 <_dprintf>
		return mmc_ret;
8f60a4e4:	eaffffb6 	b	8f60a3c4 <mmc_set_hs400_mode+0x38>
		dprintf(CRITICAL, "Failure setting DDR mode:%s\t%d\n", __func__, __LINE__);
8f60a4e8:	e3002427 	movw	r2, #1063	; 0x427
8f60a4ec:	e30311b4 	movw	r1, #12724	; 0x31b4
8f60a4f0:	e302069c 	movw	r0, #9884	; 0x269c
8f60a4f4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60a4f8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a4fc:	eb00a11c 	bl	8f632974 <_dprintf>
		return mmc_ret;
8f60a500:	eaffffaf 	b	8f60a3c4 <mmc_set_hs400_mode+0x38>
		dprintf(CRITICAL, "Switch cmd returned failure %d\n", __LINE__);
8f60a504:	e3a01e3e 	mov	r1, #992	; 0x3e0
8f60a508:	e30205e0 	movw	r0, #9696	; 0x25e0
8f60a50c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a510:	eb00a117 	bl	8f632974 <_dprintf>
		dprintf(CRITICAL, "Error adjusting interface speed!:%s\t%d\n", __func__, __LINE__);
8f60a514:	e300241f 	movw	r2, #1055	; 0x41f
8f60a518:	e30311b4 	movw	r1, #12724	; 0x31b4
8f60a51c:	e3020674 	movw	r0, #9844	; 0x2674
8f60a520:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60a524:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a528:	eb00a111 	bl	8f632974 <_dprintf>
		return mmc_ret;
8f60a52c:	eaffffa4 	b	8f60a3c4 <mmc_set_hs400_mode+0x38>
		dprintf(CRITICAL, "Switch cmd returned failure %s\t%d\n",__func__,  __LINE__);
8f60a530:	e3a02e43 	mov	r2, #1072	; 0x430
8f60a534:	e30311b4 	movw	r1, #12724	; 0x31b4
8f60a538:	e30206bc 	movw	r0, #9916	; 0x26bc
8f60a53c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60a540:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a544:	eb00a10a 	bl	8f632974 <_dprintf>
		return mmc_ret;
8f60a548:	eaffff9d 	b	8f60a3c4 <mmc_set_hs400_mode+0x38>
}
8f60a54c:	eb00a19b 	bl	8f632bc0 <__stack_chk_fail>
8f60a550:	8f74221c 	.word	0x8f74221c

8f60a554 <mmc_sd_card_init>:
{
8f60a554:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f60a558:	e24dd09c 	sub	r13, r13, #156	; 0x9c
8f60a55c:	e59f31d0 	ldr	r3, [pc, #464]	; 8f60a734 <mmc_sd_card_init+0x1e0>
8f60a560:	e1a07001 	mov	r7, r1
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60a564:	e3a02048 	mov	r2, #72	; 0x48
8f60a568:	e3a01000 	mov	r1, #0
{
8f60a56c:	e1a06000 	mov	r6, r0
	card->rca = SD_CARD_RCA;
8f60a570:	e3a04003 	mov	r4, #3
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60a574:	e1a0000d 	mov	r0, r13
		cmd.cmd_index = CMD8_SEND_IF_COND;
8f60a578:	e3a09008 	mov	r9, #8
		cmd.argument = MMC_SD_HC_VOLT_SUPPLIED;
8f60a57c:	e30051aa 	movw	r5, #426	; 0x1aa
{
8f60a580:	e5933000 	ldr	r3, [r3]
8f60a584:	e58d3094 	str	r3, [r13, #148]	; 0x94
8f60a588:	e3a03000 	mov	r3, #0
	card->rca = SD_CARD_RCA;
8f60a58c:	e3a08000 	mov	r8, #0
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60a590:	eb00a74b 	bl	8f6342c4 <memset>
	card->rca = SD_CARD_RCA;
8f60a594:	e5878000 	str	r8, [r7]
		if (sdhci_send_command(host, &cmd))
8f60a598:	e1a0100d 	mov	r1, r13
8f60a59c:	e1a00006 	mov	r0, r6
		cmd.resp_type = SDHCI_CMD_RESP_R7;
8f60a5a0:	e3a03080 	mov	r3, #128	; 0x80
		cmd.cmd_index = CMD8_SEND_IF_COND;
8f60a5a4:	e1cd90b0 	strh	r9, [r13]
		cmd.argument = MMC_SD_HC_VOLT_SUPPLIED;
8f60a5a8:	e58d5004 	str	r5, [r13, #4]
		cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60a5ac:	e5cd8009 	strb	r8, [r13, #9]
		cmd.resp_type = SDHCI_CMD_RESP_R7;
8f60a5b0:	e1cd30ba 	strh	r3, [r13, #10]
		if (sdhci_send_command(host, &cmd))
8f60a5b4:	ebfff72c 	bl	8f60826c <sdhci_send_command>
8f60a5b8:	e3500000 	cmp	r0, #0
8f60a5bc:	1a000056 	bne	8f60a71c <mmc_sd_card_init+0x1c8>
			if (cmd.resp[0] == MMC_SD_HC_VOLT_SUPPLIED)
8f60a5c0:	e59d300c 	ldr	r3, [r13, #12]
8f60a5c4:	e1530005 	cmp	r3, r5
8f60a5c8:	0a000007 	beq	8f60a5ec <mmc_sd_card_init+0x98>
		mdelay(1);
8f60a5cc:	e3a00001 	mov	r0, #1
8f60a5d0:	eb0011c9 	bl	8f60ecfc <mdelay>
	for (i = 0 ;i < SD_CMD8_MAX_RETRY; i++)
8f60a5d4:	e2443001 	sub	r3, r4, #1
8f60a5d8:	e21340ff 	ands	r4, r3, #255	; 0xff
8f60a5dc:	1affffed 	bne	8f60a598 <mmc_sd_card_init+0x44>
	if (i == SD_CMD8_MAX_RETRY && (cmd.resp[0] != MMC_SD_HC_VOLT_SUPPLIED))
8f60a5e0:	e59d300c 	ldr	r3, [r13, #12]
8f60a5e4:	e1530005 	cmp	r3, r5
8f60a5e8:	1a000046 	bne	8f60a708 <mmc_sd_card_init+0x1b4>
		cmd.argument = MMC_SD_OCR | MMC_SD_HC_HCS;
8f60a5ec:	e3a08902 	mov	r8, #32768	; 0x8000
	card->rca = SD_CARD_RCA;
8f60a5f0:	e3a04014 	mov	r4, #20
		cmd.argument = MMC_SD_OCR | MMC_SD_HC_HCS;
8f60a5f4:	e34480ff 	movt	r8, #16639	; 0x40ff
8f60a5f8:	ea000012 	b	8f60a648 <mmc_sd_card_init+0xf4>
		if (sdhci_send_command(host, &cmd))
8f60a5fc:	e1a0100d 	mov	r1, r13
8f60a600:	e1a00006 	mov	r0, r6
		cmd.cmd_index = ACMD41_SEND_OP_COND;
8f60a604:	e3a0c029 	mov	r12, #41	; 0x29
		cmd.resp_type = SDHCI_CMD_RESP_R3;
8f60a608:	e3a02008 	mov	r2, #8
		cmd.cmd_index = ACMD41_SEND_OP_COND;
8f60a60c:	e1cdc0b0 	strh	r12, [r13]
		cmd.argument = MMC_SD_OCR | MMC_SD_HC_HCS;
8f60a610:	e58d8004 	str	r8, [r13, #4]
		cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60a614:	e5cd3009 	strb	r3, [r13, #9]
		cmd.resp_type = SDHCI_CMD_RESP_R3;
8f60a618:	e1cd20ba 	strh	r2, [r13, #10]
		if (sdhci_send_command(host, &cmd))
8f60a61c:	ebfff712 	bl	8f60826c <sdhci_send_command>
8f60a620:	e2505000 	subs	r5, r0, #0
8f60a624:	1a000027 	bne	8f60a6c8 <mmc_sd_card_init+0x174>
			if (cmd.resp[0] & MMC_SD_DEV_READY)
8f60a628:	e59d300c 	ldr	r3, [r13, #12]
8f60a62c:	e3530000 	cmp	r3, #0
8f60a630:	ba000029 	blt	8f60a6dc <mmc_sd_card_init+0x188>
	for (i = 0; i < SD_ACMD41_MAX_RETRY; i++)
8f60a634:	e2444001 	sub	r4, r4, #1
		mdelay(50);
8f60a638:	e3a00032 	mov	r0, #50	; 0x32
8f60a63c:	eb0011ae 	bl	8f60ecfc <mdelay>
	for (i = 0; i < SD_ACMD41_MAX_RETRY; i++)
8f60a640:	e21440ff 	ands	r4, r4, #255	; 0xff
8f60a644:	0a000027 	beq	8f60a6e8 <mmc_sd_card_init+0x194>
		if (mmc_send_app_cmd(host, card))
8f60a648:	e5975000 	ldr	r5, [r7]
	struct mmc_command cmd = {0};
8f60a64c:	e3a02048 	mov	r2, #72	; 0x48
8f60a650:	e3a01000 	mov	r1, #0
8f60a654:	e08d0002 	add	r0, r13, r2
8f60a658:	eb00a719 	bl	8f6342c4 <memset>
	if (sdhci_send_command(host, &cmd))
8f60a65c:	e28d1048 	add	r1, r13, #72	; 0x48
8f60a660:	e1a00006 	mov	r0, r6
	cmd.cmd_index = CMD55_APP_CMD;
8f60a664:	e3a03037 	mov	r3, #55	; 0x37
	cmd.argument = (card->rca << 16);
8f60a668:	e1a05805 	lsl	r5, r5, #16
	cmd.cmd_index = CMD55_APP_CMD;
8f60a66c:	e1cd34b8 	strh	r3, [r13, #72]	; 0x48
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60a670:	e3a09001 	mov	r9, #1
	cmd.argument = (card->rca << 16);
8f60a674:	e58d504c 	str	r5, [r13, #76]	; 0x4c
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60a678:	e1cd95b2 	strh	r9, [r13, #82]	; 0x52
	if (sdhci_send_command(host, &cmd))
8f60a67c:	ebfff6fa 	bl	8f60826c <sdhci_send_command>
8f60a680:	e2503000 	subs	r3, r0, #0
8f60a684:	0affffdc 	beq	8f60a5fc <mmc_sd_card_init+0xa8>
		dprintf(CRITICAL, "Failed Sending CMD55\n");
8f60a688:	e3020758 	movw	r0, #10072	; 0x2758
8f60a68c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a690:	eb00a0b7 	bl	8f632974 <_dprintf>
			dprintf(CRITICAL, "Failed sending App command\n");
8f60a694:	e3020770 	movw	r0, #10096	; 0x2770
8f60a698:	e3480f70 	movt	r0, #36720	; 0x8f70
			return 1;
8f60a69c:	e1a05009 	mov	r5, r9
			dprintf(CRITICAL, "Failed sending App command\n");
8f60a6a0:	eb00a0b3 	bl	8f632974 <_dprintf>
}
8f60a6a4:	e59f3088 	ldr	r3, [pc, #136]	; 8f60a734 <mmc_sd_card_init+0x1e0>
8f60a6a8:	e5932000 	ldr	r2, [r3]
8f60a6ac:	e59d3094 	ldr	r3, [r13, #148]	; 0x94
8f60a6b0:	e0332002 	eors	r2, r3, r2
8f60a6b4:	e3a03000 	mov	r3, #0
8f60a6b8:	1a00001c 	bne	8f60a730 <mmc_sd_card_init+0x1dc>
8f60a6bc:	e1a00005 	mov	r0, r5
8f60a6c0:	e28dd09c 	add	r13, r13, #156	; 0x9c
8f60a6c4:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
			dprintf(CRITICAL, "Failure sending ACMD41\n");
8f60a6c8:	e302078c 	movw	r0, #10124	; 0x278c
8f60a6cc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a6d0:	eb00a0a7 	bl	8f632974 <_dprintf>
			return 1;
8f60a6d4:	e1a05009 	mov	r5, r9
8f60a6d8:	eafffff1 	b	8f60a6a4 <mmc_sd_card_init+0x150>
				if (cmd.resp[0] & (1 << 30))
8f60a6dc:	e7e03f53 	ubfx	r3, r3, #30, #1
8f60a6e0:	e5873018 	str	r3, [r7, #24]
	if (i == SD_ACMD41_MAX_RETRY && !(cmd.resp[0] & MMC_SD_DEV_READY))
8f60a6e4:	eaffffee 	b	8f60a6a4 <mmc_sd_card_init+0x150>
8f60a6e8:	e59d300c 	ldr	r3, [r13, #12]
8f60a6ec:	e3530000 	cmp	r3, #0
8f60a6f0:	baffffeb 	blt	8f60a6a4 <mmc_sd_card_init+0x150>
		dprintf(CRITICAL, "Error: ACMD41 response timed out\n");
8f60a6f4:	e30207a4 	movw	r0, #10148	; 0x27a4
8f60a6f8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a6fc:	eb00a09c 	bl	8f632974 <_dprintf>
		return 1;
8f60a700:	e1a05009 	mov	r5, r9
8f60a704:	eaffffe6 	b	8f60a6a4 <mmc_sd_card_init+0x150>
		dprintf(CRITICAL, "Error: CMD8 response timed out\n");
8f60a708:	e3020738 	movw	r0, #10040	; 0x2738
8f60a70c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a710:	eb00a097 	bl	8f632974 <_dprintf>
		return 1;
8f60a714:	e3a05001 	mov	r5, #1
8f60a718:	eaffffe1 	b	8f60a6a4 <mmc_sd_card_init+0x150>
			dprintf(CRITICAL, "The response for CMD8 does not match the supplied value\n");
8f60a71c:	e30206fc 	movw	r0, #9980	; 0x26fc
8f60a720:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a724:	eb00a092 	bl	8f632974 <_dprintf>
			return 1;
8f60a728:	e3a05001 	mov	r5, #1
8f60a72c:	eaffffdc 	b	8f60a6a4 <mmc_sd_card_init+0x150>
}
8f60a730:	eb00a122 	bl	8f632bc0 <__stack_chk_fail>
8f60a734:	8f74221c 	.word	0x8f74221c

8f60a738 <mmc_sd_set_bus_width>:
{
8f60a738:	e92d4070 	push	{r4, r5, r6, r14}
8f60a73c:	e24dd098 	sub	r13, r13, #152	; 0x98
8f60a740:	e59f30dc 	ldr	r3, [pc, #220]	; 8f60a824 <mmc_sd_set_bus_width+0xec>
8f60a744:	e1a04001 	mov	r4, r1
8f60a748:	e1a05000 	mov	r5, r0
	struct mmc_command cmd = {0};
8f60a74c:	e3a01000 	mov	r1, #0
{
8f60a750:	e1a06002 	mov	r6, r2
	struct mmc_command cmd = {0};
8f60a754:	e1a0000d 	mov	r0, r13
8f60a758:	e3a02048 	mov	r2, #72	; 0x48
{
8f60a75c:	e5933000 	ldr	r3, [r3]
8f60a760:	e58d3094 	str	r3, [r13, #148]	; 0x94
8f60a764:	e3a03000 	mov	r3, #0
	struct mmc_command cmd = {0};
8f60a768:	eb00a6d5 	bl	8f6342c4 <memset>
	if (mmc_send_app_cmd(host, card))
8f60a76c:	e5944000 	ldr	r4, [r4]
	struct mmc_command cmd = {0};
8f60a770:	e3a02048 	mov	r2, #72	; 0x48
8f60a774:	e3a01000 	mov	r1, #0
8f60a778:	e08d0002 	add	r0, r13, r2
8f60a77c:	eb00a6d0 	bl	8f6342c4 <memset>
	if (sdhci_send_command(host, &cmd))
8f60a780:	e28d1048 	add	r1, r13, #72	; 0x48
8f60a784:	e1a00005 	mov	r0, r5
	cmd.cmd_index = CMD55_APP_CMD;
8f60a788:	e3a03037 	mov	r3, #55	; 0x37
	cmd.argument = (card->rca << 16);
8f60a78c:	e1a04804 	lsl	r4, r4, #16
	cmd.cmd_index = CMD55_APP_CMD;
8f60a790:	e1cd34b8 	strh	r3, [r13, #72]	; 0x48
	cmd.argument = (card->rca << 16);
8f60a794:	e58d404c 	str	r4, [r13, #76]	; 0x4c
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60a798:	e3a04001 	mov	r4, #1
8f60a79c:	e1cd45b2 	strh	r4, [r13, #82]	; 0x52
	if (sdhci_send_command(host, &cmd))
8f60a7a0:	ebfff6b1 	bl	8f60826c <sdhci_send_command>
8f60a7a4:	e2503000 	subs	r3, r0, #0
8f60a7a8:	1a000014 	bne	8f60a800 <mmc_sd_set_bus_width+0xc8>
	cmd.argument = (width == DATA_BUS_WIDTH_4BIT) ? (1<<1) : 0;
8f60a7ac:	e1560004 	cmp	r6, r4
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60a7b0:	e1a02000 	mov	r2, r0
	if (sdhci_send_command(host, &cmd))
8f60a7b4:	e1a0100d 	mov	r1, r13
8f60a7b8:	e1a00005 	mov	r0, r5
	cmd.argument = (width == DATA_BUS_WIDTH_4BIT) ? (1<<1) : 0;
8f60a7bc:	03a03002 	moveq	r3, #2
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60a7c0:	e5cd2009 	strb	r2, [r13, #9]
	cmd.argument = (width == DATA_BUS_WIDTH_4BIT) ? (1<<1) : 0;
8f60a7c4:	e58d3004 	str	r3, [r13, #4]
	cmd.cmd_index = ACMD6_SET_BUS_WIDTH;
8f60a7c8:	e3a03006 	mov	r3, #6
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60a7cc:	e1cd40ba 	strh	r4, [r13, #10]
	cmd.cmd_index = ACMD6_SET_BUS_WIDTH;
8f60a7d0:	e1cd30b0 	strh	r3, [r13]
	if (sdhci_send_command(host, &cmd))
8f60a7d4:	ebfff6a4 	bl	8f60826c <sdhci_send_command>
8f60a7d8:	e2500000 	subs	r0, r0, #0
8f60a7dc:	13a00001 	movne	r0, #1
}
8f60a7e0:	e59f303c 	ldr	r3, [pc, #60]	; 8f60a824 <mmc_sd_set_bus_width+0xec>
8f60a7e4:	e5932000 	ldr	r2, [r3]
8f60a7e8:	e59d3094 	ldr	r3, [r13, #148]	; 0x94
8f60a7ec:	e0332002 	eors	r2, r3, r2
8f60a7f0:	e3a03000 	mov	r3, #0
8f60a7f4:	1a000009 	bne	8f60a820 <mmc_sd_set_bus_width+0xe8>
8f60a7f8:	e28dd098 	add	r13, r13, #152	; 0x98
8f60a7fc:	e8bd8070 	pop	{r4, r5, r6, r15}
		dprintf(CRITICAL, "Failed Sending CMD55\n");
8f60a800:	e3020758 	movw	r0, #10072	; 0x2758
8f60a804:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a808:	eb00a059 	bl	8f632974 <_dprintf>
		dprintf(CRITICAL, "Failed sending App command\n");
8f60a80c:	e3020770 	movw	r0, #10096	; 0x2770
8f60a810:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a814:	eb00a056 	bl	8f632974 <_dprintf>
		return 1;
8f60a818:	e1a00004 	mov	r0, r4
8f60a81c:	eaffffef 	b	8f60a7e0 <mmc_sd_set_bus_width+0xa8>
}
8f60a820:	eb00a0e6 	bl	8f632bc0 <__stack_chk_fail>
8f60a824:	8f74221c 	.word	0x8f74221c

8f60a828 <mmc_sd_set_hs>:
{
8f60a828:	e92d4070 	push	{r4, r5, r6, r14}
8f60a82c:	e24dd050 	sub	r13, r13, #80	; 0x50
8f60a830:	e59f30a8 	ldr	r3, [pc, #168]	; 8f60a8e0 <mmc_sd_set_hs+0xb8>
8f60a834:	e1a05000 	mov	r5, r0
       struct mmc_command cmd = {0};
8f60a838:	e3a02048 	mov	r2, #72	; 0x48
8f60a83c:	e3a01000 	mov	r1, #0
8f60a840:	e1a0000d 	mov	r0, r13
       cmd.trans_mode = SDHCI_MMC_READ;
8f60a844:	e3a06001 	mov	r6, #1
{
8f60a848:	e5933000 	ldr	r3, [r3]
8f60a84c:	e58d304c 	str	r3, [r13, #76]	; 0x4c
8f60a850:	e3a03000 	mov	r3, #0
       struct mmc_command cmd = {0};
8f60a854:	eb00a69a 	bl	8f6342c4 <memset>
       if (sdhci_send_command(host, &cmd))
8f60a858:	e1a0100d 	mov	r1, r13
8f60a85c:	e1a00005 	mov	r0, r5
       cmd.cmd_index = CMD6_SWITCH_FUNC;
8f60a860:	e3a03006 	mov	r3, #6
       cmd.trans_mode = SDHCI_MMC_READ;
8f60a864:	e58d601c 	str	r6, [r13, #28]
       cmd.cmd_index = CMD6_SWITCH_FUNC;
8f60a868:	e1cd30b0 	strh	r3, [r13]
       cmd.argument = MMC_SD_SWITCH_HS;
8f60a86c:	e30f3ff1 	movw	r3, #65521	; 0xfff1
       cmd.data.num_blocks = 0x1;
8f60a870:	e58d603c 	str	r6, [r13, #60]	; 0x3c
       cmd.argument = MMC_SD_SWITCH_HS;
8f60a874:	e34830ff 	movt	r3, #33023	; 0x80ff
8f60a878:	e58d3004 	str	r3, [r13, #4]
       cmd.data_present = 0x1;
8f60a87c:	e1a03006 	mov	r3, r6
8f60a880:	e3403001 	movt	r3, #1
8f60a884:	e58d3008 	str	r3, [r13, #8]
       cmd.data.data_ptr = switch_resp;
8f60a888:	e30c3c80 	movw	r3, #52352	; 0xcc80
8f60a88c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f60a890:	e58d3034 	str	r3, [r13, #52]	; 0x34
       cmd.data.blk_sz = 0x40;
8f60a894:	e3a03040 	mov	r3, #64	; 0x40
8f60a898:	e58d3038 	str	r3, [r13, #56]	; 0x38
       if (sdhci_send_command(host, &cmd))
8f60a89c:	ebfff672 	bl	8f60826c <sdhci_send_command>
8f60a8a0:	e2504000 	subs	r4, r0, #0
             return 1;
8f60a8a4:	11a04006 	movne	r4, r6
       if (sdhci_send_command(host, &cmd))
8f60a8a8:	1a000002 	bne	8f60a8b8 <mmc_sd_set_hs+0x90>
	sdhci_set_uhs_mode(host, SDHCI_SDR25_MODE);
8f60a8ac:	e1a01006 	mov	r1, r6
8f60a8b0:	e1a00005 	mov	r0, r5
8f60a8b4:	ebfff602 	bl	8f6080c4 <sdhci_set_uhs_mode>
}
8f60a8b8:	e59f3020 	ldr	r3, [pc, #32]	; 8f60a8e0 <mmc_sd_set_hs+0xb8>
8f60a8bc:	e5932000 	ldr	r2, [r3]
8f60a8c0:	e59d304c 	ldr	r3, [r13, #76]	; 0x4c
8f60a8c4:	e0332002 	eors	r2, r3, r2
8f60a8c8:	e3a03000 	mov	r3, #0
8f60a8cc:	1a000002 	bne	8f60a8dc <mmc_sd_set_hs+0xb4>
8f60a8d0:	e1a00004 	mov	r0, r4
8f60a8d4:	e28dd050 	add	r13, r13, #80	; 0x50
8f60a8d8:	e8bd8070 	pop	{r4, r5, r6, r15}
8f60a8dc:	eb00a0b7 	bl	8f632bc0 <__stack_chk_fail>
8f60a8e0:	8f74221c 	.word	0x8f74221c

8f60a8e4 <mmc_init>:
{
8f60a8e4:	e59f3f94 	ldr	r3, [pc, #3988]	; 8f60b880 <mmc_init+0xf9c>
8f60a8e8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f60a8ec:	e1a05000 	mov	r5, r0
8f60a8f0:	e24dd0fc 	sub	r13, r13, #252	; 0xfc
	dev = (struct mmc_device *) malloc (sizeof(struct mmc_device));
8f60a8f4:	e3a00f46 	mov	r0, #280	; 0x118
{
8f60a8f8:	e5933000 	ldr	r3, [r3]
8f60a8fc:	e58d30f4 	str	r3, [r13, #244]	; 0xf4
8f60a900:	e3a03000 	mov	r3, #0
	dev = (struct mmc_device *) malloc (sizeof(struct mmc_device));
8f60a904:	e1a0800e 	mov	r8, r14
8f60a908:	eb00a5bb 	bl	8f633ffc <malloc>
	if (!dev) {
8f60a90c:	e2504000 	subs	r4, r0, #0
8f60a910:	0a0004af 	beq	8f60bbd4 <mmc_init+0x12f0>
	ASSERT(data);
8f60a914:	e3550000 	cmp	r5, #0
8f60a918:	0a00037f 	beq	8f60b71c <mmc_init+0xe38>
	memset((struct mmc_card *)&dev->card, 0, sizeof(struct mmc_card));
8f60a91c:	e2846038 	add	r6, r4, #56	; 0x38
	memcpy((void*)&dev->config, (void*)data, sizeof(struct mmc_config_data));
8f60a920:	e3a0201c 	mov	r2, #28
8f60a924:	e1a01005 	mov	r1, r5
8f60a928:	e28400f8 	add	r0, r4, #248	; 0xf8
8f60a92c:	eb00a621 	bl	8f6341b8 <memcpy>
	memset((struct mmc_card *)&dev->card, 0, sizeof(struct mmc_card));
8f60a930:	e3a020c0 	mov	r2, #192	; 0xc0
8f60a934:	e3a01000 	mov	r1, #0
8f60a938:	e1a00006 	mov	r0, r6
8f60a93c:	eb00a660 	bl	8f6342c4 <memset>
	dprintf(SPEW, " Initializing MMC host data structure and clock!\n");
8f60a940:	e30207e8 	movw	r0, #10216	; 0x27e8
8f60a944:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60a948:	eb00a009 	bl	8f632974 <_dprintf>
	event_init(&sdhc_event, false, EVENT_FLAG_AUTOUNSIGNAL);
8f60a94c:	e28d0010 	add	r0, r13, #16
8f60a950:	e3a02001 	mov	r2, #1
8f60a954:	e3a01000 	mov	r1, #0
8f60a958:	eb00603d 	bl	8f622a54 <event_init>
	host->sdhc_event = &sdhc_event;
8f60a95c:	e28d3010 	add	r3, r13, #16
8f60a960:	e5843018 	str	r3, [r4, #24]
	data = (struct sdhci_msm_data *) malloc(sizeof(struct sdhci_msm_data));
8f60a964:	e3a00014 	mov	r0, #20
	host->base = cfg->sdhc_base;
8f60a968:	e5943100 	ldr	r3, [r4, #256]	; 0x100
8f60a96c:	e5843000 	str	r3, [r4]
	host->caps.hs200_support = cfg->hs200_support;
8f60a970:	e5d43110 	ldrb	r3, [r4, #272]	; 0x110
8f60a974:	e5c4302b 	strb	r3, [r4, #43]	; 0x2b
	host->caps.hs400_support = cfg->hs400_support;
8f60a978:	e5d43111 	ldrb	r3, [r4, #273]	; 0x111
8f60a97c:	e5c4302c 	strb	r3, [r4, #44]	; 0x2c
	data = (struct sdhci_msm_data *) malloc(sizeof(struct sdhci_msm_data));
8f60a980:	eb00a59d 	bl	8f633ffc <malloc>
	ASSERT(data);
8f60a984:	e2507000 	subs	r7, r0, #0
8f60a988:	0a00036e 	beq	8f60b748 <mmc_init+0xe64>
	data->sdhc_event = &sdhc_event;
8f60a98c:	e28d3010 	add	r3, r13, #16
8f60a990:	e5873010 	str	r3, [r7, #16]
	data->pwrctl_base = cfg->pwrctl_base;
8f60a994:	e5943104 	ldr	r3, [r4, #260]	; 0x104
	data->slot = cfg->slot;
8f60a998:	e5d400f8 	ldrb	r0, [r4, #248]	; 0xf8
	host->msm_host = data;
8f60a99c:	e5847030 	str	r7, [r4, #48]	; 0x30
	data->pwrctl_base = cfg->pwrctl_base;
8f60a9a0:	e5873000 	str	r3, [r7]
	data->pwr_irq = cfg->pwr_irq;
8f60a9a4:	e59430fc 	ldr	r3, [r4, #252]	; 0xfc
	data->slot = cfg->slot;
8f60a9a8:	e5c7000b 	strb	r0, [r7, #11]
	data->pwr_irq = cfg->pwr_irq;
8f60a9ac:	e5873004 	str	r3, [r7, #4]
	data->use_io_switch = cfg->use_io_switch;
8f60a9b0:	e5d43112 	ldrb	r3, [r4, #274]	; 0x112
8f60a9b4:	e5c7300c 	strb	r3, [r7, #12]
	clock_init_mmc(cfg->slot);
8f60a9b8:	ebffdc9b 	bl	8f601c2c <clock_init_mmc>
	clock_config_mmc(cfg->slot, cfg->max_clk_rate);
8f60a9bc:	e5d400f8 	ldrb	r0, [r4, #248]	; 0xf8
8f60a9c0:	e594110c 	ldr	r1, [r4, #268]	; 0x10c
8f60a9c4:	ebffdcc3 	bl	8f601cd8 <clock_config_mmc>
	if (cfg->slot == 1)
8f60a9c8:	e5d400f8 	ldrb	r0, [r4, #248]	; 0xf8
8f60a9cc:	e3500001 	cmp	r0, #1
8f60a9d0:	0a000175 	beq	8f60afac <mmc_init+0x6c8>
	sdhci_msm_init(host, data);
8f60a9d4:	e1a01007 	mov	r1, r7
8f60a9d8:	e1a00004 	mov	r0, r4
8f60a9dc:	ebfffa11 	bl	8f609228 <sdhci_msm_init>
	sdhci_init(host);
8f60a9e0:	e1a00004 	mov	r0, r4
8f60a9e4:	ebfff892 	bl	8f608c34 <sdhci_init>
	mmc_ret = sdhci_clk_supply(host, SDHCI_CLK_400KHZ);
8f60a9e8:	e3a01d6a 	mov	r1, #6784	; 0x1a80
8f60a9ec:	e1a00004 	mov	r0, r4
8f60a9f0:	e3401006 	movt	r1, #6
8f60a9f4:	ebfff57e 	bl	8f607ff4 <sdhci_clk_supply>
	if (mmc_ret) {
8f60a9f8:	e21070ff 	ands	r7, r0, #255	; 0xff
8f60a9fc:	1a000199 	bne	8f60b068 <mmc_init+0x784>
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60aa00:	e1a01007 	mov	r1, r7
8f60aa04:	e3a02048 	mov	r2, #72	; 0x48
	card->status = MMC_STATUS_INACTIVE;
8f60aa08:	e5847054 	str	r7, [r4, #84]	; 0x54
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60aa0c:	e28d0098 	add	r0, r13, #152	; 0x98
	card->ocr = MMC_OCR_27_36 | MMC_OCR_SEC_MODE;
8f60aa10:	e3a03902 	mov	r3, #32768	; 0x8000
8f60aa14:	e34430ff 	movt	r3, #16639	; 0x40ff
8f60aa18:	e584303c 	str	r3, [r4, #60]	; 0x3c
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60aa1c:	eb00a628 	bl	8f6342c4 <memset>
	return sdhci_send_command(host, &cmd);
8f60aa20:	e28d1098 	add	r1, r13, #152	; 0x98
8f60aa24:	e1a00004 	mov	r0, r4
	cmd.cmd_index = CMD0_GO_IDLE_STATE;
8f60aa28:	e1cd79b8 	strh	r7, [r13, #152]	; 0x98
	cmd.argument = 0;
8f60aa2c:	e58d709c 	str	r7, [r13, #156]	; 0x9c
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60aa30:	e5cd70a1 	strb	r7, [r13, #161]	; 0xa1
	cmd.resp_type = SDHCI_CMD_RESP_NONE;
8f60aa34:	e1cd7ab2 	strh	r7, [r13, #162]	; 0xa2
	return sdhci_send_command(host, &cmd);
8f60aa38:	ebfff60b 	bl	8f60826c <sdhci_send_command>
	if (mmc_return) {
8f60aa3c:	e21070ff 	ands	r7, r0, #255	; 0xff
8f60aa40:	1a00014a 	bne	8f60af70 <mmc_init+0x68c>
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60aa44:	e1a01007 	mov	r1, r7
8f60aa48:	e28d0098 	add	r0, r13, #152	; 0x98
8f60aa4c:	e3a02048 	mov	r2, #72	; 0x48
8f60aa50:	eb00a61b 	bl	8f6342c4 <memset>
	cmd.argument = card->ocr;
8f60aa54:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60aa58:	e5cd70a1 	strb	r7, [r13, #161]	; 0xa1
	cmd.resp_type = SDHCI_CMD_RESP_R3;
8f60aa5c:	e3a07ffa 	mov	r7, #1000	; 0x3e8
	cmd.argument = card->ocr;
8f60aa60:	e58d309c 	str	r3, [r13, #156]	; 0x9c
	cmd.cmd_index = CMD1_SEND_OP_COND;
8f60aa64:	e3a03001 	mov	r3, #1
8f60aa68:	e1cd39b8 	strh	r3, [r13, #152]	; 0x98
	cmd.resp_type = SDHCI_CMD_RESP_R3;
8f60aa6c:	e3a03008 	mov	r3, #8
8f60aa70:	e1cd3ab2 	strh	r3, [r13, #162]	; 0xa2
		mmc_ret = sdhci_send_command(host, &cmd);
8f60aa74:	e28d1098 	add	r1, r13, #152	; 0x98
8f60aa78:	e1a00004 	mov	r0, r4
8f60aa7c:	ebfff5fa 	bl	8f60826c <sdhci_send_command>
		if (mmc_ret)
8f60aa80:	e3500000 	cmp	r0, #0
8f60aa84:	1a000173 	bne	8f60b058 <mmc_init+0x774>
		mmc_resp = cmd.resp[0];
8f60aa88:	e59d30a4 	ldr	r3, [r13, #164]	; 0xa4
		if (!(mmc_resp & MMC_OCR_BUSY)) {
8f60aa8c:	e3530000 	cmp	r3, #0
8f60aa90:	aa000169 	bge	8f60b03c <mmc_init+0x758>
	if (mmc_resp & MMC_OCR_SEC_MODE)
8f60aa94:	e3130101 	tst	r3, #1073741824	; 0x40000000
	card->ocr = mmc_resp;
8f60aa98:	e584303c 	str	r3, [r4, #60]	; 0x3c
		card->type = MMC_TYPE_MMCHC;
8f60aa9c:	13a03003 	movne	r3, #3
8f60aaa0:	15843050 	strne	r3, [r4, #80]	; 0x50
	if (mmc_resp & MMC_OCR_SEC_MODE)
8f60aaa4:	0a0000d4 	beq	8f60adfc <mmc_init+0x518>
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60aaa8:	e3a02048 	mov	r2, #72	; 0x48
8f60aaac:	e3a01000 	mov	r1, #0
8f60aab0:	e28d0098 	add	r0, r13, #152	; 0x98
8f60aab4:	eb00a602 	bl	8f6342c4 <memset>
	mmc_ret = sdhci_send_command(host, &cmd);
8f60aab8:	e28d1098 	add	r1, r13, #152	; 0x98
8f60aabc:	e1a00004 	mov	r0, r4
	cmd.argument = 0;
8f60aac0:	e3a03000 	mov	r3, #0
8f60aac4:	e58d309c 	str	r3, [r13, #156]	; 0x9c
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60aac8:	e5cd30a1 	strb	r3, [r13, #161]	; 0xa1
	cmd.cmd_index = CMD2_ALL_SEND_CID;
8f60aacc:	e3a03002 	mov	r3, #2
8f60aad0:	e1cd39b8 	strh	r3, [r13, #152]	; 0x98
	cmd.resp_type = SDHCI_CMD_RESP_R2;
8f60aad4:	e3a03004 	mov	r3, #4
8f60aad8:	e1cd3ab2 	strh	r3, [r13, #162]	; 0xa2
	mmc_ret = sdhci_send_command(host, &cmd);
8f60aadc:	ebfff5e2 	bl	8f60826c <sdhci_send_command>
	if (mmc_ret) {
8f60aae0:	e2507000 	subs	r7, r0, #0
8f60aae4:	0a00004c 	beq	8f60ac1c <mmc_init+0x338>
		dprintf(CRITICAL,"Failure getting card's CID number!\n");
8f60aae8:	e3020954 	movw	r0, #10580	; 0x2954
8f60aaec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60aaf0:	eb009f9f 	bl	8f632974 <_dprintf>
	if (mmc_ret) {
8f60aaf4:	e6ef0077 	uxtb	r0, r7
8f60aaf8:	e3500000 	cmp	r0, #0
8f60aafc:	1a000115 	bne	8f60af58 <mmc_init+0x674>
	dprintf(INFO, "Done initialization of the card\n");
8f60ab00:	e3020d80 	movw	r0, #11648	; 0x2d80
8f60ab04:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60ab08:	eb009f99 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "erase_grpsize: %d\n", card->csd.erase_grp_size);
8f60ab0c:	e59410cc 	ldr	r1, [r4, #204]	; 0xcc
8f60ab10:	e3020da4 	movw	r0, #11684	; 0x2da4
8f60ab14:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60ab18:	eb009f95 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "erase_grpmult: %d\n", card->csd.erase_grp_mult);
8f60ab1c:	e59410d0 	ldr	r1, [r4, #208]	; 0xd0
8f60ab20:	e3020db8 	movw	r0, #11704	; 0x2db8
8f60ab24:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60ab28:	eb009f91 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "wp_grpsize: %d\n", card->csd.wp_grp_size);
8f60ab2c:	e59410d4 	ldr	r1, [r4, #212]	; 0xd4
8f60ab30:	e3020dcc 	movw	r0, #11724	; 0x2dcc
8f60ab34:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60ab38:	eb009f8d 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "wp_grpen: %d\n", card->csd.wp_grp_enable);
8f60ab3c:	e5d410d8 	ldrb	r1, [r4, #216]	; 0xd8
8f60ab40:	e3020ddc 	movw	r0, #11740	; 0x2ddc
8f60ab44:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60ab48:	e2011001 	and	r1, r1, #1
8f60ab4c:	eb009f88 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "perm_wp: %d\n", card->csd.perm_wp);
8f60ab50:	e5d410d8 	ldrb	r1, [r4, #216]	; 0xd8
8f60ab54:	e3020dec 	movw	r0, #11756	; 0x2dec
8f60ab58:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60ab5c:	e7e010d1 	ubfx	r1, r1, #1, #1
8f60ab60:	eb009f83 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "temp_wp: %d\n", card->csd.temp_wp);
8f60ab64:	e5d410d8 	ldrb	r1, [r4, #216]	; 0xd8
8f60ab68:	e3020dfc 	movw	r0, #11772	; 0x2dfc
8f60ab6c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60ab70:	e7e01151 	ubfx	r1, r1, #2, #1
8f60ab74:	eb009f7e 	bl	8f632974 <_dprintf>
	mmc_sdhci_bdev_t *bdev = malloc(sizeof(mmc_sdhci_bdev_t));
8f60ab78:	e3a00050 	mov	r0, #80	; 0x50
8f60ab7c:	eb00a51e 	bl	8f633ffc <malloc>
	snprintf(name, sizeof(name), "hd%d", data->slot);
8f60ab80:	e5d53000 	ldrb	r3, [r5]
8f60ab84:	e3a01014 	mov	r1, #20
8f60ab88:	e3022e0c 	movw	r2, #11788	; 0x2e0c
8f60ab8c:	e3482f70 	movt	r2, #36720	; 0x8f70
	mmc_sdhci_bdev_t *bdev = malloc(sizeof(mmc_sdhci_bdev_t));
8f60ab90:	e1a05000 	mov	r5, r0
	snprintf(name, sizeof(name), "hd%d", data->slot);
8f60ab94:	e28d00e0 	add	r0, r13, #224	; 0xe0
8f60ab98:	eb00a4e8 	bl	8f633f40 <snprintf>
	bio_initialize_bdev(&bdev->dev, name, dev->card.block_size, dev->card.capacity / dev->card.block_size);
8f60ab9c:	e5946040 	ldr	r6, [r4, #64]	; 0x40
8f60aba0:	e1c404d8 	ldrd	r0, [r4, #72]	; 0x48
8f60aba4:	e3a03000 	mov	r3, #0
8f60aba8:	e1a02006 	mov	r2, r6
8f60abac:	fa00c97c 	blx	8f63d1a4 <__aeabi_uldivmod>
8f60abb0:	e1a02006 	mov	r2, r6
8f60abb4:	e28d10e0 	add	r1, r13, #224	; 0xe0
8f60abb8:	e1a03000 	mov	r3, r0
8f60abbc:	e1a00005 	mov	r0, r5
8f60abc0:	eb00b25c 	bl	8f637538 <bio_initialize_bdev>
	bio_register_device(&bdev->dev);
8f60abc4:	e1a00005 	mov	r0, r5
	bdev->dev.read_block = mmc_sdhci_bdev_read_block;
8f60abc8:	e30b3cdc 	movw	r3, #48348	; 0xbcdc
	bdev->mmcdev = dev;
8f60abcc:	e5854048 	str	r4, [r5, #72]	; 0x48
	bdev->dev.read_block = mmc_sdhci_bdev_read_block;
8f60abd0:	e3483f60 	movt	r3, #36704	; 0x8f60
8f60abd4:	e5853030 	str	r3, [r5, #48]	; 0x30
	bdev->dev.write_block = mmc_sdhci_bdev_write_block;
8f60abd8:	e30b3f2c 	movw	r3, #48940	; 0xbf2c
8f60abdc:	e3483f60 	movt	r3, #36704	; 0x8f60
8f60abe0:	e5853038 	str	r3, [r5, #56]	; 0x38
	bio_register_device(&bdev->dev);
8f60abe4:	eb00b283 	bl	8f6375f8 <bio_register_device>
	partition_publish(name, 0);
8f60abe8:	e28d00e0 	add	r0, r13, #224	; 0xe0
8f60abec:	e3a02000 	mov	r2, #0
8f60abf0:	e3a03000 	mov	r3, #0
8f60abf4:	eb00b6a8 	bl	8f63869c <partition_publish>
}
8f60abf8:	e59f3c80 	ldr	r3, [pc, #3200]	; 8f60b880 <mmc_init+0xf9c>
8f60abfc:	e5932000 	ldr	r2, [r3]
8f60ac00:	e59d30f4 	ldr	r3, [r13, #244]	; 0xf4
8f60ac04:	e0332002 	eors	r2, r3, r2
8f60ac08:	e3a03000 	mov	r3, #0
8f60ac0c:	1a0003ef 	bne	8f60bbd0 <mmc_init+0x12ec>
8f60ac10:	e1a00004 	mov	r0, r4
8f60ac14:	e28dd0fc 	add	r13, r13, #252	; 0xfc
8f60ac18:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	if (MMC_CARD_SD(card)) {
8f60ac1c:	e5943050 	ldr	r3, [r4, #80]	; 0x50
8f60ac20:	e3530001 	cmp	r3, #1
		mmc_cid.mid = UNPACK_BITS(raw_cid, 120, 8, mmc_sizeof);
8f60ac24:	e59d30b0 	ldr	r3, [r13, #176]	; 0xb0
	if (MMC_CARD_SD(card)) {
8f60ac28:	9a000229 	bls	8f60b4d4 <mmc_init+0xbf0>
		mmc_cid.oid = UNPACK_BITS(raw_cid, 104, 16, mmc_sizeof);
8f60ac2c:	e7ef1453 	ubfx	r1, r3, #8, #16
8f60ac30:	e28d0057 	add	r0, r13, #87	; 0x57
8f60ac34:	e58d1054 	str	r1, [r13, #84]	; 0x54
8f60ac38:	e3a02058 	mov	r2, #88	; 0x58
		mmc_cid.mid = UNPACK_BITS(raw_cid, 120, 8, mmc_sizeof);
8f60ac3c:	e1a01c23 	lsr	r1, r3, #24
8f60ac40:	e58d1050 	str	r1, [r13, #80]	; 0x50
			mmc_cid.pnm[i] = (uint8_t)UNPACK_BITS(raw_cid, (104 - 8 * (i + 1)),
8f60ac44:	ea00000b 	b	8f60ac78 <mmc_init+0x394>
8f60ac48:	e2821007 	add	r1, r2, #7
8f60ac4c:	e1a032a2 	lsr	r3, r2, #5
8f60ac50:	e15302a1 	cmp	r3, r1, lsr #5
8f60ac54:	e28d10f8 	add	r1, r13, #248	; 0xf8
8f60ac58:	e0813103 	add	r3, r1, r3, lsl #2
8f60ac5c:	e202101f 	and	r1, r2, #31
8f60ac60:	359dc0ac 	ldrcc	r12, [r13, #172]	; 0xac
8f60ac64:	e2422008 	sub	r2, r2, #8
8f60ac68:	e5133054 	ldr	r3, [r3, #-84]	; 0xffffffac
8f60ac6c:	e1a03133 	lsr	r3, r3, r1
8f60ac70:	32611020 	rsbcc	r1, r1, #32
8f60ac74:	3183311c 	orrcc	r3, r3, r12, lsl r1
		for (i = 0; i < 6; i++) {
8f60ac78:	e3520030 	cmp	r2, #48	; 0x30
			mmc_cid.pnm[i] = (uint8_t)UNPACK_BITS(raw_cid, (104 - 8 * (i + 1)),
8f60ac7c:	e5e03001 	strb	r3, [r0, #1]!
		for (i = 0; i < 6; i++) {
8f60ac80:	1afffff0 	bne	8f60ac48 <mmc_init+0x364>
		mmc_cid.psn = UNPACK_BITS(raw_cid, 16, 32, mmc_sizeof);
8f60ac84:	e59d30a4 	ldr	r3, [r13, #164]	; 0xa4
		mmc_cid.pnm[6] = 0;
8f60ac88:	e3a02000 	mov	r2, #0
		mmc_cid.prv = UNPACK_BITS(raw_cid, 48, 8, mmc_sizeof);
8f60ac8c:	e59d10a8 	ldr	r1, [r13, #168]	; 0xa8
8f60ac90:	e28d7058 	add	r7, r13, #88	; 0x58
		mmc_cid.pnm[6] = 0;
8f60ac94:	e5cd205e 	strb	r2, [r13, #94]	; 0x5e
		mmc_cid.year += 1997;
8f60ac98:	e7e32653 	ubfx	r2, r3, #12, #4
8f60ac9c:	e2822d1f 	add	r2, r2, #1984	; 0x7c0
8f60aca0:	e282200d 	add	r2, r2, #13
8f60aca4:	e58d206c 	str	r2, [r13, #108]	; 0x6c
		mmc_cid.psn = UNPACK_BITS(raw_cid, 16, 32, mmc_sizeof);
8f60aca8:	e1a02801 	lsl	r2, r1, #16
		mmc_cid.prv = UNPACK_BITS(raw_cid, 48, 8, mmc_sizeof);
8f60acac:	e7e71851 	ubfx	r1, r1, #16, #8
		mmc_cid.psn = UNPACK_BITS(raw_cid, 16, 32, mmc_sizeof);
8f60acb0:	e1822823 	orr	r2, r2, r3, lsr #16
		mmc_cid.prv = UNPACK_BITS(raw_cid, 48, 8, mmc_sizeof);
8f60acb4:	e58d1060 	str	r1, [r13, #96]	; 0x60
		mmc_cid.month = UNPACK_BITS(raw_cid, 8, 4, mmc_sizeof);
8f60acb8:	e7e33453 	ubfx	r3, r3, #8, #4
		mmc_cid.psn = UNPACK_BITS(raw_cid, 16, 32, mmc_sizeof);
8f60acbc:	e58d2064 	str	r2, [r13, #100]	; 0x64
		mmc_cid.month = UNPACK_BITS(raw_cid, 8, 4, mmc_sizeof);
8f60acc0:	e58d3068 	str	r3, [r13, #104]	; 0x68
	memcpy((struct mmc_cid *)&card->cid,
8f60acc4:	e3a02020 	mov	r2, #32
8f60acc8:	e28d1050 	add	r1, r13, #80	; 0x50
8f60accc:	e284007c 	add	r0, r4, #124	; 0x7c
8f60acd0:	eb00a538 	bl	8f6341b8 <memcpy>
	dprintf(SPEW, "Decoded CID fields:\n");
8f60acd4:	e30208ac 	movw	r0, #10412	; 0x28ac
8f60acd8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60acdc:	eb009f24 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "Manufacturer ID: %x\n", mmc_cid.mid);
8f60ace0:	e59d1050 	ldr	r1, [r13, #80]	; 0x50
8f60ace4:	e30208c4 	movw	r0, #10436	; 0x28c4
8f60ace8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60acec:	eb009f20 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "OEM ID: 0x%x\n", mmc_cid.oid);
8f60acf0:	e59d1054 	ldr	r1, [r13, #84]	; 0x54
8f60acf4:	e30208dc 	movw	r0, #10460	; 0x28dc
8f60acf8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60acfc:	eb009f1c 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "Product Name: %s\n", mmc_cid.pnm);
8f60ad00:	e1a01007 	mov	r1, r7
8f60ad04:	e30208ec 	movw	r0, #10476	; 0x28ec
8f60ad08:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60ad0c:	eb009f18 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "Product revision: %d.%d\n", (mmc_cid.prv >> 4),
8f60ad10:	e59d1060 	ldr	r1, [r13, #96]	; 0x60
8f60ad14:	e3020900 	movw	r0, #10496	; 0x2900
8f60ad18:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60ad1c:	e201200f 	and	r2, r1, #15
8f60ad20:	e1a01221 	lsr	r1, r1, #4
8f60ad24:	eb009f12 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "Product serial number: %X\n", mmc_cid.psn);
8f60ad28:	e59d1064 	ldr	r1, [r13, #100]	; 0x64
8f60ad2c:	e302091c 	movw	r0, #10524	; 0x291c
8f60ad30:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60ad34:	eb009f0e 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "Manufacturing date: %d %d\n", mmc_cid.month, mmc_cid.year);
8f60ad38:	e59d206c 	ldr	r2, [r13, #108]	; 0x6c
8f60ad3c:	e59d1068 	ldr	r1, [r13, #104]	; 0x68
8f60ad40:	e3020938 	movw	r0, #10552	; 0x2938
8f60ad44:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60ad48:	eb009f09 	bl	8f632974 <_dprintf>
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60ad4c:	e28d0098 	add	r0, r13, #152	; 0x98
8f60ad50:	e3a02048 	mov	r2, #72	; 0x48
8f60ad54:	e3a01000 	mov	r1, #0
8f60ad58:	eb00a559 	bl	8f6342c4 <memset>
	if (MMC_CARD_SD(card)) {
8f60ad5c:	e5943050 	ldr	r3, [r4, #80]	; 0x50
8f60ad60:	e3530001 	cmp	r3, #1
8f60ad64:	9a000092 	bls	8f60afb4 <mmc_init+0x6d0>
		card->rca = (cmd.argument >> 16);
8f60ad68:	e3a03002 	mov	r3, #2
		mmc_ret = sdhci_send_command(host, &cmd);
8f60ad6c:	e28d1098 	add	r1, r13, #152	; 0x98
		card->rca = (cmd.argument >> 16);
8f60ad70:	e5843038 	str	r3, [r4, #56]	; 0x38
		mmc_ret = sdhci_send_command(host, &cmd);
8f60ad74:	e1a00004 	mov	r0, r4
		cmd.cmd_index = CMD3_SEND_RELATIVE_ADDR;
8f60ad78:	e3a03003 	mov	r3, #3
8f60ad7c:	e1cd39b8 	strh	r3, [r13, #152]	; 0x98
		cmd.argument = (MMC_RCA << 16);
8f60ad80:	e3a03802 	mov	r3, #131072	; 0x20000
8f60ad84:	e58d309c 	str	r3, [r13, #156]	; 0x9c
		cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60ad88:	e3a03000 	mov	r3, #0
8f60ad8c:	e5cd30a1 	strb	r3, [r13, #161]	; 0xa1
		cmd.resp_type = SDHCI_CMD_RESP_R6;
8f60ad90:	e3a03040 	mov	r3, #64	; 0x40
8f60ad94:	e1cd3ab2 	strh	r3, [r13, #162]	; 0xa2
		mmc_ret = sdhci_send_command(host, &cmd);
8f60ad98:	ebfff533 	bl	8f60826c <sdhci_send_command>
	if (mmc_return) {
8f60ad9c:	e2507000 	subs	r7, r0, #0
8f60ada0:	1a000098 	bne	8f60b008 <mmc_init+0x724>
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60ada4:	e3a02048 	mov	r2, #72	; 0x48
8f60ada8:	e3a01000 	mov	r1, #0
8f60adac:	e28d0098 	add	r0, r13, #152	; 0x98
8f60adb0:	eb00a543 	bl	8f6342c4 <memset>
	mmc_arg |= card->rca << 16;
8f60adb4:	e5943038 	ldr	r3, [r4, #56]	; 0x38
	mmc_ret = sdhci_send_command(host, &cmd);
8f60adb8:	e28d1098 	add	r1, r13, #152	; 0x98
8f60adbc:	e1a00004 	mov	r0, r4
	mmc_arg |= card->rca << 16;
8f60adc0:	e1a03803 	lsl	r3, r3, #16
	cmd.argument = mmc_arg;
8f60adc4:	e58d309c 	str	r3, [r13, #156]	; 0x9c
	cmd.cmd_index = CMD9_SEND_CSD;
8f60adc8:	e3a03009 	mov	r3, #9
8f60adcc:	e1cd39b8 	strh	r3, [r13, #152]	; 0x98
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60add0:	e3a03000 	mov	r3, #0
8f60add4:	e5cd30a1 	strb	r3, [r13, #161]	; 0xa1
	cmd.resp_type = SDHCI_CMD_RESP_R2;
8f60add8:	e3a03004 	mov	r3, #4
8f60addc:	e1cd3ab2 	strh	r3, [r13, #162]	; 0xa2
	mmc_ret = sdhci_send_command(host, &cmd);
8f60ade0:	ebfff521 	bl	8f60826c <sdhci_send_command>
	if (mmc_ret)
8f60ade4:	e2507000 	subs	r7, r0, #0
8f60ade8:	0a000006 	beq	8f60ae08 <mmc_init+0x524>
		dprintf(CRITICAL,"Failure getting card's CSD information!\n");
8f60adec:	e3020998 	movw	r0, #10648	; 0x2998
8f60adf0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60adf4:	eb009ede 	bl	8f632974 <_dprintf>
		return mmc_return;
8f60adf8:	eaffff3d 	b	8f60aaf4 <mmc_init+0x210>
		card->type = MMC_TYPE_STD_MMC;
8f60adfc:	e3a03004 	mov	r3, #4
8f60ae00:	e5843050 	str	r3, [r4, #80]	; 0x50
	if (mmc_return) {
8f60ae04:	eaffff27 	b	8f60aaa8 <mmc_init+0x1c4>
	memcpy(card->raw_csd, cmd.resp, sizeof(cmd.resp));
8f60ae08:	e28d10a4 	add	r1, r13, #164	; 0xa4
8f60ae0c:	e3a02010 	mov	r2, #16
8f60ae10:	e284005c 	add	r0, r4, #92	; 0x5c
8f60ae14:	eb00a4e7 	bl	8f6341b8 <memcpy>
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60ae18:	e3a02048 	mov	r2, #72	; 0x48
8f60ae1c:	e28d0098 	add	r0, r13, #152	; 0x98
8f60ae20:	e1a01007 	mov	r1, r7
8f60ae24:	eb00a526 	bl	8f6342c4 <memset>
	mmc_arg |= card->rca << 16;
8f60ae28:	e5943038 	ldr	r3, [r4, #56]	; 0x38
	cmd.cmd_index = CMD7_SELECT_DESELECT_CARD;
8f60ae2c:	e3a02007 	mov	r2, #7
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60ae30:	e5cd70a1 	strb	r7, [r13, #161]	; 0xa1
	if (card->rca) {
8f60ae34:	e3530000 	cmp	r3, #0
	cmd.cmd_index = CMD7_SELECT_DESELECT_CARD;
8f60ae38:	e1cd29b8 	strh	r2, [r13, #152]	; 0x98
	mmc_arg |= card->rca << 16;
8f60ae3c:	e1a02803 	lsl	r2, r3, #16
	cmd.argument = mmc_arg;
8f60ae40:	e58d209c 	str	r2, [r13, #156]	; 0x9c
	if (card->rca) {
8f60ae44:	1a000069 	bne	8f60aff0 <mmc_init+0x70c>
		cmd.resp_type = SDHCI_CMD_RESP_NONE;
8f60ae48:	e1cd3ab2 	strh	r3, [r13, #162]	; 0xa2
	mmc_ret = sdhci_send_command(host, &cmd);
8f60ae4c:	e28d1098 	add	r1, r13, #152	; 0x98
8f60ae50:	e1a00004 	mov	r0, r4
8f60ae54:	ebfff504 	bl	8f60826c <sdhci_send_command>
	if (mmc_return) {
8f60ae58:	e2507000 	subs	r7, r0, #0
8f60ae5c:	1a0002c4 	bne	8f60b974 <mmc_init+0x1090>
	if (MMC_CARD_SD(card))
8f60ae60:	e5943050 	ldr	r3, [r4, #80]	; 0x50
	card->status = MMC_STATUS_ACTIVE;
8f60ae64:	e3a08001 	mov	r8, #1
8f60ae68:	e5848054 	str	r8, [r4, #84]	; 0x54
	if (MMC_CARD_SD(card))
8f60ae6c:	e3530001 	cmp	r3, #1
8f60ae70:	9a000068 	bls	8f60b018 <mmc_init+0x734>
	mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
8f60ae74:	e3a030b9 	mov	r3, #185	; 0xb9
8f60ae78:	e3a02003 	mov	r2, #3
8f60ae7c:	e1a01006 	mov	r1, r6
8f60ae80:	e1a00004 	mov	r0, r4
8f60ae84:	e58d8000 	str	r8, [r13]
8f60ae88:	ebfffb94 	bl	8f609ce0 <mmc_switch_cmd>
	if (mmc_ret) {
8f60ae8c:	e2507000 	subs	r7, r0, #0
8f60ae90:	1a000237 	bne	8f60b774 <mmc_init+0xe90>
	sdhci_set_uhs_mode(host, SDHCI_SDR25_MODE);
8f60ae94:	e1a01008 	mov	r1, r8
8f60ae98:	e1a00004 	mov	r0, r4
	MMC_SAVE_TIMING(host, SDHCI_SDR25_MODE);
8f60ae9c:	e5848008 	str	r8, [r4, #8]
	sdhci_set_uhs_mode(host, SDHCI_SDR25_MODE);
8f60aea0:	ebfff487 	bl	8f6080c4 <sdhci_set_uhs_mode>
	if (MMC_CARD_MMC(card))
8f60aea4:	e5943050 	ldr	r3, [r4, #80]	; 0x50
8f60aea8:	e2433003 	sub	r3, r3, #3
8f60aeac:	e3530001 	cmp	r3, #1
8f60aeb0:	9a000072 	bls	8f60b080 <mmc_init+0x79c>
	struct mmc_command cmd = {0};
8f60aeb4:	e3a02048 	mov	r2, #72	; 0x48
8f60aeb8:	e3a01000 	mov	r1, #0
8f60aebc:	e28d0050 	add	r0, r13, #80	; 0x50
	cmd.cmd_index = CMD55_APP_CMD;
8f60aec0:	e3a09037 	mov	r9, #55	; 0x37
	struct mmc_command cmd = {0};
8f60aec4:	eb00a4fe 	bl	8f6342c4 <memset>
	if (mmc_send_app_cmd(host, card))
8f60aec8:	e5947038 	ldr	r7, [r4, #56]	; 0x38
	struct mmc_command cmd = {0};
8f60aecc:	e3a02048 	mov	r2, #72	; 0x48
8f60aed0:	e3a01000 	mov	r1, #0
8f60aed4:	e28d0098 	add	r0, r13, #152	; 0x98
8f60aed8:	eb00a4f9 	bl	8f6342c4 <memset>
	if (sdhci_send_command(host, &cmd))
8f60aedc:	e28d1098 	add	r1, r13, #152	; 0x98
8f60aee0:	e1a00004 	mov	r0, r4
	cmd.argument = (card->rca << 16);
8f60aee4:	e1a07807 	lsl	r7, r7, #16
	cmd.cmd_index = CMD55_APP_CMD;
8f60aee8:	e1cd99b8 	strh	r9, [r13, #152]	; 0x98
	cmd.argument = (card->rca << 16);
8f60aeec:	e58d709c 	str	r7, [r13, #156]	; 0x9c
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60aef0:	e3a07001 	mov	r7, #1
8f60aef4:	e1cd7ab2 	strh	r7, [r13, #162]	; 0xa2
	if (sdhci_send_command(host, &cmd))
8f60aef8:	ebfff4db 	bl	8f60826c <sdhci_send_command>
8f60aefc:	e3500000 	cmp	r0, #0
8f60af00:	1a000250 	bne	8f60b848 <mmc_init+0xf64>
	cmd.argument = 0x0;
8f60af04:	e58d0054 	str	r0, [r13, #84]	; 0x54
	if (sdhci_send_command(host, &cmd))
8f60af08:	e28d1050 	add	r1, r13, #80	; 0x50
8f60af0c:	e1a00004 	mov	r0, r4
	cmd.cmd_index = ACMD51_READ_CARD_SCR;
8f60af10:	e3a03033 	mov	r3, #51	; 0x33
	cmd.data.blk_sz = 0x8;
8f60af14:	e3a02008 	mov	r2, #8
	cmd.data_present = 0x1;
8f60af18:	e3a0a001 	mov	r10, #1
	cmd.data.data_ptr = scr_resp;
8f60af1c:	e30cbc40 	movw	r11, #52288	; 0xcc40
	cmd.data_present = 0x1;
8f60af20:	e340a001 	movt	r10, #1
	cmd.data.data_ptr = scr_resp;
8f60af24:	e348bf72 	movt	r11, #36722	; 0x8f72
	cmd.trans_mode = SDHCI_MMC_READ;
8f60af28:	e58d706c 	str	r7, [r13, #108]	; 0x6c
	cmd.data.num_blocks = 0x1;
8f60af2c:	e58d708c 	str	r7, [r13, #140]	; 0x8c
	cmd.cmd_index = ACMD51_READ_CARD_SCR;
8f60af30:	e1cd35b0 	strh	r3, [r13, #80]	; 0x50
	cmd.data_present = 0x1;
8f60af34:	e58da058 	str	r10, [r13, #88]	; 0x58
	cmd.data.data_ptr = scr_resp;
8f60af38:	e58db084 	str	r11, [r13, #132]	; 0x84
	cmd.data.blk_sz = 0x8;
8f60af3c:	e58d2088 	str	r2, [r13, #136]	; 0x88
	if (sdhci_send_command(host, &cmd))
8f60af40:	ebfff4c9 	bl	8f60826c <sdhci_send_command>
8f60af44:	e2508000 	subs	r8, r0, #0
8f60af48:	0a000129 	beq	8f60b3f4 <mmc_init+0xb10>
			dprintf(CRITICAL, "Failure getting card's SCR register\n");
8f60af4c:	e3020a60 	movw	r0, #10848	; 0x2a60
8f60af50:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60af54:	eb009e86 	bl	8f632974 <_dprintf>
		dprintf(CRITICAL, "Failed detecting MMC/SDC @ slot%d\n",
8f60af58:	e5d410f8 	ldrb	r1, [r4, #248]	; 0xf8
8f60af5c:	e3020d5c 	movw	r0, #11612	; 0x2d5c
8f60af60:	e3480f70 	movt	r0, #36720	; 0x8f70
		return NULL;
8f60af64:	e3a04000 	mov	r4, #0
		dprintf(CRITICAL, "Failed detecting MMC/SDC @ slot%d\n",
8f60af68:	eb009e81 	bl	8f632974 <_dprintf>
		return NULL;
8f60af6c:	eaffff21 	b	8f60abf8 <mmc_init+0x314>
		dprintf(CRITICAL, "Failure resetting MMC cards!\n");
8f60af70:	e3020840 	movw	r0, #10304	; 0x2840
8f60af74:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60af78:	eb009e7d 	bl	8f632974 <_dprintf>
		dprintf(CRITICAL, "MMC card failed to respond, try for SD card\n");
8f60af7c:	e3020e64 	movw	r0, #11876	; 0x2e64
8f60af80:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60af84:	eb009e7a 	bl	8f632974 <_dprintf>
		mmc_return = mmc_sd_card_init(host, card);
8f60af88:	e1a01006 	mov	r1, r6
8f60af8c:	e1a00004 	mov	r0, r4
8f60af90:	ebfffd6f 	bl	8f60a554 <mmc_sd_card_init>
		if (mmc_return)
8f60af94:	e2507000 	subs	r7, r0, #0
8f60af98:	0afffec2 	beq	8f60aaa8 <mmc_init+0x1c4>
			dprintf(CRITICAL, "Failed to initialize SD card\n");
8f60af9c:	e302088c 	movw	r0, #10380	; 0x288c
8f60afa0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60afa4:	eb009e72 	bl	8f632974 <_dprintf>
			return mmc_return;
8f60afa8:	eafffed1 	b	8f60aaf4 <mmc_init+0x210>
		clock_config_cdc(cfg->slot);
8f60afac:	eb005a3d 	bl	8f6218a8 <clock_config_cdc>
8f60afb0:	eafffe87 	b	8f60a9d4 <mmc_init+0xf0>
		mmc_ret = sdhci_send_command(host, &cmd);
8f60afb4:	e28d1098 	add	r1, r13, #152	; 0x98
8f60afb8:	e1a00004 	mov	r0, r4
		cmd.argument = 0;
8f60afbc:	e3a03000 	mov	r3, #0
8f60afc0:	e58d309c 	str	r3, [r13, #156]	; 0x9c
		cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60afc4:	e5cd30a1 	strb	r3, [r13, #161]	; 0xa1
		cmd.cmd_index = CMD3_SEND_RELATIVE_ADDR;
8f60afc8:	e3a03003 	mov	r3, #3
8f60afcc:	e1cd39b8 	strh	r3, [r13, #152]	; 0x98
		cmd.resp_type = SDHCI_CMD_RESP_R6;
8f60afd0:	e3a03040 	mov	r3, #64	; 0x40
8f60afd4:	e1cd3ab2 	strh	r3, [r13, #162]	; 0xa2
		mmc_ret = sdhci_send_command(host, &cmd);
8f60afd8:	ebfff4a3 	bl	8f60826c <sdhci_send_command>
		if (mmc_ret)
8f60afdc:	e2507000 	subs	r7, r0, #0
8f60afe0:	1a000008 	bne	8f60b008 <mmc_init+0x724>
		card->rca = (cmd.resp[0] >> 16);
8f60afe4:	e1dd3ab6 	ldrh	r3, [r13, #166]	; 0xa6
8f60afe8:	e5843038 	str	r3, [r4, #56]	; 0x38
	if (mmc_return) {
8f60afec:	eaffff6c 	b	8f60ada4 <mmc_init+0x4c0>
		if (MMC_CARD_SD(card))
8f60aff0:	e5943050 	ldr	r3, [r4, #80]	; 0x50
8f60aff4:	e3530001 	cmp	r3, #1
			cmd.resp_type = SDHCI_CMD_RESP_R1B;
8f60aff8:	93a03002 	movls	r3, #2
			cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60affc:	83a03001 	movhi	r3, #1
8f60b000:	e1cd3ab2 	strh	r3, [r13, #162]	; 0xa2
8f60b004:	eaffff90 	b	8f60ae4c <mmc_init+0x568>
		dprintf(CRITICAL, "Failure getting card's RCA!\n");
8f60b008:	e3020978 	movw	r0, #10616	; 0x2978
8f60b00c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b010:	eb009e57 	bl	8f632974 <_dprintf>
		return mmc_return;
8f60b014:	eafffeb6 	b	8f60aaf4 <mmc_init+0x210>
		mmc_return = mmc_sd_set_hs(host, card);
8f60b018:	e1a01006 	mov	r1, r6
8f60b01c:	e1a00004 	mov	r0, r4
8f60b020:	ebfffe00 	bl	8f60a828 <mmc_sd_set_hs>
		if (mmc_return)
8f60b024:	e2507000 	subs	r7, r0, #0
8f60b028:	0affff9d 	beq	8f60aea4 <mmc_init+0x5c0>
			dprintf(CRITICAL, "Failed to set HS for SD card\n");
8f60b02c:	e30209f0 	movw	r0, #10736	; 0x29f0
8f60b030:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b034:	eb009e4e 	bl	8f632974 <_dprintf>
			return mmc_return;
8f60b038:	eafffead 	b	8f60aaf4 <mmc_init+0x210>
			mdelay(1);
8f60b03c:	e3a00001 	mov	r0, #1
8f60b040:	eb000f2d 	bl	8f60ecfc <mdelay>
	} while (mmc_retry < MMC_MAX_COMMAND_RETRY);
8f60b044:	e2577001 	subs	r7, r7, #1
8f60b048:	1afffe89 	bne	8f60aa74 <mmc_init+0x190>
		dprintf(CRITICAL, "Card has busy status set. Init did not complete\n");
8f60b04c:	e3020e94 	movw	r0, #11924	; 0x2e94
8f60b050:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b054:	eb009e46 	bl	8f632974 <_dprintf>
		dprintf(CRITICAL, "Failure getting OCR response from MMC Card\n");
8f60b058:	e3020860 	movw	r0, #10336	; 0x2860
8f60b05c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b060:	eb009e43 	bl	8f632974 <_dprintf>
		return mmc_return;
8f60b064:	eaffffc4 	b	8f60af7c <mmc_init+0x698>
		dprintf(CRITICAL, "Error Initializing MMC host : %u\n", mmc_ret);
8f60b068:	e1a01007 	mov	r1, r7
8f60b06c:	e302081c 	movw	r0, #10268	; 0x281c
8f60b070:	e3480f70 	movt	r0, #36720	; 0x8f70
		return NULL;
8f60b074:	e3a04000 	mov	r4, #0
		dprintf(CRITICAL, "Error Initializing MMC host : %u\n", mmc_ret);
8f60b078:	eb009e3d 	bl	8f632974 <_dprintf>
		return NULL;
8f60b07c:	eafffedd 	b	8f60abf8 <mmc_init+0x314>
			mmc_return = mmc_get_ext_csd(host, card);
8f60b080:	e1a01006 	mov	r1, r6
8f60b084:	e1a00004 	mov	r0, r4
8f60b088:	ebfffb6a 	bl	8f609e38 <mmc_get_ext_csd>
			if (mmc_return) {
8f60b08c:	e2507000 	subs	r7, r0, #0
8f60b090:	1a00029d 	bne	8f60bb0c <mmc_init+0x1228>
	if (MMC_CARD_SD(card)) {
8f60b094:	e5942050 	ldr	r2, [r4, #80]	; 0x50
	mmc_csd.cmmc_structure = UNPACK_BITS(raw_csd, 126, 2, mmc_sizeof);
8f60b098:	e5943068 	ldr	r3, [r4, #104]	; 0x68
	if (MMC_CARD_SD(card)) {
8f60b09c:	e3520001 	cmp	r2, #1
	mmc_csd.cmmc_structure = UNPACK_BITS(raw_csd, 126, 2, mmc_sizeof);
8f60b0a0:	e1a02f23 	lsr	r2, r3, #30
8f60b0a4:	e58d2010 	str	r2, [r13, #16]
	if (MMC_CARD_SD(card)) {
8f60b0a8:	9a00013c 	bls	8f60b5a0 <mmc_init+0xcbc>
		mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit]) / 10;
8f60b0ac:	e7e319d3 	ubfx	r1, r3, #19, #4
8f60b0b0:	e30321e8 	movw	r2, #12776	; 0x31e8
8f60b0b4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60b0b8:	e7e20853 	ubfx	r0, r3, #16, #3
		mmc_csd.nsac_clk_cycle = UNPACK_BITS(raw_csd, 104, 8, mmc_sizeof) * 100;
8f60b0bc:	e7e7c453 	ubfx	r12, r3, #8, #8
		mmc_csd.spec_vers = UNPACK_BITS(raw_csd, 122, 4, mmc_sizeof);
8f60b0c0:	e7e33d53 	ubfx	r3, r3, #26, #4
		mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit]) / 10;
8f60b0c4:	e7922101 	ldr	r2, [r2, r1, lsl #2]
8f60b0c8:	e30311c8 	movw	r1, #12744	; 0x31c8
8f60b0cc:	e3481f70 	movt	r1, #36720	; 0x8f70
		mmc_csd.spec_vers = UNPACK_BITS(raw_csd, 122, 4, mmc_sizeof);
8f60b0d0:	e58d3014 	str	r3, [r13, #20]
		mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit]) / 10;
8f60b0d4:	e7911100 	ldr	r1, [r1, r0, lsl #2]
8f60b0d8:	e30c0ccd 	movw	r0, #52429	; 0xcccd
8f60b0dc:	e34c0ccc 	movt	r0, #52428	; 0xcccc
8f60b0e0:	e0020291 	mul	r2, r1, r2
		mmc_csd.write_blk_len = 1 << UNPACK_BITS(raw_csd, 22, 4, mmc_sizeof);
8f60b0e4:	e594105c 	ldr	r1, [r4, #92]	; 0x5c
		mmc_csd.wp_grp_enable = UNPACK_BITS(raw_csd, 31, 1, mmc_sizeof);
8f60b0e8:	e7e0e6d1 	ubfx	r14, r1, #13, #1
8f60b0ec:	e1a03fa1 	lsr	r3, r1, #31
		mmc_csd.write_blk_partial = UNPACK_BITS(raw_csd, 21, 1, mmc_sizeof);
8f60b0f0:	e1a07aa1 	lsr	r7, r1, #21
		mmc_csd.wp_grp_enable = UNPACK_BITS(raw_csd, 31, 1, mmc_sizeof);
8f60b0f4:	e183308e 	orr	r3, r3, r14, lsl #1
8f60b0f8:	e7e0e651 	ubfx	r14, r1, #12, #1
		mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit]) / 10;
8f60b0fc:	e0820290 	umull	r0, r2, r0, r2
		mmc_csd.wp_grp_enable = UNPACK_BITS(raw_csd, 31, 1, mmc_sizeof);
8f60b100:	e183310e 	orr	r3, r3, r14, lsl #2
		mmc_csd.nsac_clk_cycle = UNPACK_BITS(raw_csd, 104, 8, mmc_sizeof) * 100;
8f60b104:	e3a0e064 	mov	r14, #100	; 0x64
		mmc_csd.c_size_mult = UNPACK_BITS(raw_csd, 47, 3, mmc_sizeof);
8f60b108:	e5940060 	ldr	r0, [r4, #96]	; 0x60
		mmc_csd.nsac_clk_cycle = UNPACK_BITS(raw_csd, 104, 8, mmc_sizeof) * 100;
8f60b10c:	e00c0c9e 	mul	r12, r14, r12
		mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit]) / 10;
8f60b110:	e1a021a2 	lsr	r2, r2, #3
8f60b114:	e58d2038 	str	r2, [r13, #56]	; 0x38
		mmc_csd.card_cmd_class = UNPACK_BITS(raw_csd, 84, 12, mmc_sizeof);
8f60b118:	e5942064 	ldr	r2, [r4, #100]	; 0x64
		mmc_csd.nsac_clk_cycle = UNPACK_BITS(raw_csd, 104, 8, mmc_sizeof) * 100;
8f60b11c:	e58dc034 	str	r12, [r13, #52]	; 0x34
		mmc_csd.wp_grp_enable = UNPACK_BITS(raw_csd, 31, 1, mmc_sizeof);
8f60b120:	e7e0c6d2 	ubfx	r12, r2, #13, #1
8f60b124:	e7e0e752 	ubfx	r14, r2, #14, #1
8f60b128:	e183320c 	orr	r3, r3, r12, lsl #4
		mmc_csd.c_size = UNPACK_BITS(raw_csd, 62, 12, mmc_sizeof);
8f60b12c:	e1a0c102 	lsl	r12, r2, #2
		mmc_csd.wp_grp_enable = UNPACK_BITS(raw_csd, 31, 1, mmc_sizeof);
8f60b130:	e183328e 	orr	r3, r3, r14, lsl #5
8f60b134:	e7e0e7d2 	ubfx	r14, r2, #15, #1
		mmc_csd.c_size = UNPACK_BITS(raw_csd, 62, 12, mmc_sizeof);
8f60b138:	e18ccf20 	orr	r12, r12, r0, lsr #30
		mmc_csd.wp_grp_enable = UNPACK_BITS(raw_csd, 31, 1, mmc_sizeof);
8f60b13c:	e183330e 	orr	r3, r3, r14, lsl #6
8f60b140:	e5dde04c 	ldrb	r14, [r13, #76]	; 0x4c
8f60b144:	e7ebc05c 	ubfx	r12, r12, #0, #12
8f60b148:	e1833387 	orr	r3, r3, r7, lsl #7
8f60b14c:	e20ee008 	and	r14, r14, #8
		mmc_csd.c_size = UNPACK_BITS(raw_csd, 62, 12, mmc_sizeof);
8f60b150:	e58dc030 	str	r12, [r13, #48]	; 0x30
		mmc_csd.wp_grp_enable = UNPACK_BITS(raw_csd, 31, 1, mmc_sizeof);
8f60b154:	e183300e 	orr	r3, r3, r14
8f60b158:	e5cd304c 	strb	r3, [r13, #76]	; 0x4c
8f60b15c:	e3003fff 	movw	r3, #4095	; 0xfff
		if (mmc_csd.c_size != 0xFFF) {
8f60b160:	e15c0003 	cmp	r12, r3
		mmc_csd.write_blk_len = 1 << UNPACK_BITS(raw_csd, 22, 4, mmc_sizeof);
8f60b164:	e7e3eb51 	ubfx	r14, r1, #22, #4
8f60b168:	e3a03001 	mov	r3, #1
		mmc_csd.r2w_factor = UNPACK_BITS(raw_csd, 26, 3, mmc_sizeof);
8f60b16c:	e7e21d51 	ubfx	r1, r1, #26, #3
8f60b170:	e58d1024 	str	r1, [r13, #36]	; 0x24
		mmc_csd.read_blk_len =  1 << UNPACK_BITS(raw_csd, 80, 4, mmc_sizeof);
8f60b174:	e7e31852 	ubfx	r1, r2, #16, #4
		mmc_csd.write_blk_len = 1 << UNPACK_BITS(raw_csd, 22, 4, mmc_sizeof);
8f60b178:	e1a0ee13 	lsl	r14, r3, r14
		mmc_csd.card_cmd_class = UNPACK_BITS(raw_csd, 84, 12, mmc_sizeof);
8f60b17c:	e1a02a22 	lsr	r2, r2, #20
		mmc_csd.read_blk_len =  1 << UNPACK_BITS(raw_csd, 80, 4, mmc_sizeof);
8f60b180:	e1a03113 	lsl	r3, r3, r1
		mmc_csd.card_cmd_class = UNPACK_BITS(raw_csd, 84, 12, mmc_sizeof);
8f60b184:	e58d2018 	str	r2, [r13, #24]
		mmc_csd.erase_grp_size = UNPACK_BITS(raw_csd, 42, 5, mmc_sizeof);
8f60b188:	e7e41550 	ubfx	r1, r0, #10, #5
8f60b18c:	e7e227d0 	ubfx	r2, r0, #15, #3
8f60b190:	e58d1040 	str	r1, [r13, #64]	; 0x40
		mmc_csd.write_blk_len = 1 << UNPACK_BITS(raw_csd, 22, 4, mmc_sizeof);
8f60b194:	e58de01c 	str	r14, [r13, #28]
		mmc_csd.erase_grp_mult = UNPACK_BITS(raw_csd, 37, 5, mmc_sizeof);
8f60b198:	e7e412d0 	ubfx	r1, r0, #5, #5
		mmc_csd.read_blk_len =  1 << UNPACK_BITS(raw_csd, 80, 4, mmc_sizeof);
8f60b19c:	e58d3020 	str	r3, [r13, #32]
		mmc_csd.wp_grp_size = UNPACK_BITS(raw_csd, 32, 5, mmc_sizeof);
8f60b1a0:	e200001f 	and	r0, r0, #31
		mmc_csd.erase_grp_mult = UNPACK_BITS(raw_csd, 37, 5, mmc_sizeof);
8f60b1a4:	e58d1044 	str	r1, [r13, #68]	; 0x44
		mmc_csd.tran_speed = 0x00;
8f60b1a8:	e3a01000 	mov	r1, #0
		mmc_csd.c_size_mult = UNPACK_BITS(raw_csd, 47, 3, mmc_sizeof);
8f60b1ac:	e58d202c 	str	r2, [r13, #44]	; 0x2c
		mmc_csd.wp_grp_size = UNPACK_BITS(raw_csd, 32, 5, mmc_sizeof);
8f60b1b0:	e58d0048 	str	r0, [r13, #72]	; 0x48
		mmc_csd.tran_speed = 0x00;
8f60b1b4:	e58d103c 	str	r1, [r13, #60]	; 0x3c
		if (mmc_csd.c_size != 0xFFF) {
8f60b1b8:	0a0001ca 	beq	8f60b8e8 <mmc_init+0x1004>
			mmc_temp = (1 << (mmc_csd.c_size_mult + 2)) * (mmc_csd.c_size + 1);
8f60b1bc:	e28cc001 	add	r12, r12, #1
8f60b1c0:	e2822002 	add	r2, r2, #2
			card->capacity = (unsigned long long) mmc_temp * mmc_csd.read_blk_len;
8f60b1c4:	e1a01fc3 	asr	r1, r3, #31
			mmc_temp = (1 << (mmc_csd.c_size_mult + 2)) * (mmc_csd.c_size + 1);
8f60b1c8:	e1a0c21c 	lsl	r12, r12, r2
			card->capacity = (unsigned long long) mmc_temp * mmc_csd.read_blk_len;
8f60b1cc:	e082339c 	umull	r3, r2, r12, r3
8f60b1d0:	e02c219c 	mla	r12, r12, r1, r2
8f60b1d4:	e5843048 	str	r3, [r4, #72]	; 0x48
8f60b1d8:	e584c04c 	str	r12, [r4, #76]	; 0x4c
	memcpy((struct mmc_csd *)&card->csd,(struct mmc_csd *)&mmc_csd,
8f60b1dc:	e28d1010 	add	r1, r13, #16
8f60b1e0:	e284009c 	add	r0, r4, #156	; 0x9c
8f60b1e4:	e3a02040 	mov	r2, #64	; 0x40
8f60b1e8:	eb00a3f2 	bl	8f6341b8 <memcpy>
	if (MMC_CARD_MMC(card)) {
8f60b1ec:	e5943050 	ldr	r3, [r4, #80]	; 0x50
8f60b1f0:	e2433003 	sub	r3, r3, #3
8f60b1f4:	e3530001 	cmp	r3, #1
8f60b1f8:	9a0000d6 	bls	8f60b558 <mmc_init+0xc74>
		card->wp_grp_size = (card->csd.wp_grp_size + 1) * (card->csd.erase_grp_size + 1) \
8f60b1fc:	e59430cc 	ldr	r3, [r4, #204]	; 0xcc
8f60b200:	e59420d4 	ldr	r2, [r4, #212]	; 0xd4
8f60b204:	e2833001 	add	r3, r3, #1
8f60b208:	e0233392 	mla	r3, r2, r3, r3
						* (card->csd.erase_grp_mult + 1);
8f60b20c:	e59420d0 	ldr	r2, [r4, #208]	; 0xd0
8f60b210:	e0233392 	mla	r3, r2, r3, r3
		card->wp_grp_size = (card->csd.wp_grp_size + 1) * (card->csd.erase_grp_size + 1) \
8f60b214:	e5843044 	str	r3, [r4, #68]	; 0x44
	dprintf(SPEW, "Decoded CSD fields:\n");
8f60b218:	e3020aac 	movw	r0, #10924	; 0x2aac
8f60b21c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b220:	eb009dd3 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "cmmc_structure: %u\n", mmc_csd.cmmc_structure);
8f60b224:	e59d1010 	ldr	r1, [r13, #16]
8f60b228:	e3020ac4 	movw	r0, #10948	; 0x2ac4
8f60b22c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b230:	eb009dcf 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "card_cmd_class: %x\n", mmc_csd.card_cmd_class);
8f60b234:	e59d1018 	ldr	r1, [r13, #24]
8f60b238:	e3020ad8 	movw	r0, #10968	; 0x2ad8
8f60b23c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b240:	eb009dcb 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "write_blk_len: %u\n", mmc_csd.write_blk_len);
8f60b244:	e59d101c 	ldr	r1, [r13, #28]
8f60b248:	e3020aec 	movw	r0, #10988	; 0x2aec
8f60b24c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b250:	eb009dc7 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "read_blk_len: %u\n", mmc_csd.read_blk_len);
8f60b254:	e59d1020 	ldr	r1, [r13, #32]
8f60b258:	e3020b00 	movw	r0, #11008	; 0x2b00
8f60b25c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b260:	eb009dc3 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "r2w_factor: %u\n", mmc_csd.r2w_factor);
8f60b264:	e59d1024 	ldr	r1, [r13, #36]	; 0x24
8f60b268:	e3020b14 	movw	r0, #11028	; 0x2b14
8f60b26c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b270:	eb009dbf 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "sector_size: %u\n", mmc_csd.sector_size);
8f60b274:	e59d1028 	ldr	r1, [r13, #40]	; 0x28
8f60b278:	e3020b24 	movw	r0, #11044	; 0x2b24
8f60b27c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b280:	eb009dbb 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "c_size_mult:%u\n", mmc_csd.c_size_mult);
8f60b284:	e59d102c 	ldr	r1, [r13, #44]	; 0x2c
8f60b288:	e3020b38 	movw	r0, #11064	; 0x2b38
8f60b28c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b290:	eb009db7 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "c_size: %u\n", mmc_csd.c_size);
8f60b294:	e59d1030 	ldr	r1, [r13, #48]	; 0x30
8f60b298:	e3020b48 	movw	r0, #11080	; 0x2b48
8f60b29c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b2a0:	eb009db3 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "nsac_clk_cycle: %u\n", mmc_csd.nsac_clk_cycle);
8f60b2a4:	e59d1034 	ldr	r1, [r13, #52]	; 0x34
8f60b2a8:	e3020b54 	movw	r0, #11092	; 0x2b54
8f60b2ac:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b2b0:	eb009daf 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "taac_ns: %u\n", mmc_csd.taac_ns);
8f60b2b4:	e59d1038 	ldr	r1, [r13, #56]	; 0x38
8f60b2b8:	e3020b68 	movw	r0, #11112	; 0x2b68
8f60b2bc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b2c0:	eb009dab 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "tran_speed: %u kbps\n", mmc_csd.tran_speed);
8f60b2c4:	e59d103c 	ldr	r1, [r13, #60]	; 0x3c
8f60b2c8:	e3020b78 	movw	r0, #11128	; 0x2b78
8f60b2cc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b2d0:	eb009da7 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "erase_blk_len: %u\n", mmc_csd.erase_blk_len);
8f60b2d4:	e5dd104c 	ldrb	r1, [r13, #76]	; 0x4c
8f60b2d8:	e3020b90 	movw	r0, #11152	; 0x2b90
8f60b2dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b2e0:	e7e011d1 	ubfx	r1, r1, #3, #1
8f60b2e4:	eb009da2 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "read_blk_misalign: %u\n", mmc_csd.read_blk_misalign);
8f60b2e8:	e5dd104c 	ldrb	r1, [r13, #76]	; 0x4c
8f60b2ec:	e3020ba4 	movw	r0, #11172	; 0x2ba4
8f60b2f0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b2f4:	e7e01251 	ubfx	r1, r1, #4, #1
8f60b2f8:	eb009d9d 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "write_blk_misalign: %u\n", mmc_csd.write_blk_misalign);
8f60b2fc:	e5dd104c 	ldrb	r1, [r13, #76]	; 0x4c
8f60b300:	e3020bbc 	movw	r0, #11196	; 0x2bbc
8f60b304:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b308:	e7e012d1 	ubfx	r1, r1, #5, #1
8f60b30c:	eb009d98 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "read_blk_partial: %u\n", mmc_csd.read_blk_partial);
8f60b310:	e5dd104c 	ldrb	r1, [r13, #76]	; 0x4c
8f60b314:	e3020bd4 	movw	r0, #11220	; 0x2bd4
8f60b318:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b31c:	e7e01351 	ubfx	r1, r1, #6, #1
8f60b320:	eb009d93 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "write_blk_partial: %u\n", mmc_csd.write_blk_partial);
8f60b324:	e5dd104c 	ldrb	r1, [r13, #76]	; 0x4c
8f60b328:	e3020bec 	movw	r0, #11244	; 0x2bec
8f60b32c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b330:	e1a013a1 	lsr	r1, r1, #7
8f60b334:	eb009d8e 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "wp_grp_size: %u\n", card->wp_grp_size);
8f60b338:	e5941044 	ldr	r1, [r4, #68]	; 0x44
8f60b33c:	e3020c04 	movw	r0, #11268	; 0x2c04
8f60b340:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b344:	eb009d8a 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "Card Capacity: %llu Bytes\n", card->capacity);
8f60b348:	e1c424d8 	ldrd	r2, [r4, #72]	; 0x48
8f60b34c:	e3020c18 	movw	r0, #11288	; 0x2c18
8f60b350:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b354:	eb009d86 	bl	8f632974 <_dprintf>
	if (MMC_CARD_MMC(card))
8f60b358:	e5943050 	ldr	r3, [r4, #80]	; 0x50
8f60b35c:	e2433003 	sub	r3, r3, #3
8f60b360:	e3530001 	cmp	r3, #1
8f60b364:	9a00010a 	bls	8f60b794 <mmc_init+0xeb0>
		if (card->scr.bus_widths & SD_SCR_WIDTH_4BIT)
8f60b368:	e59480dc 	ldr	r8, [r4, #220]	; 0xdc
		mmc_return = mmc_sd_set_bus_width(host, card, bus_width);
8f60b36c:	e1a01006 	mov	r1, r6
8f60b370:	e1a00004 	mov	r0, r4
		if (card->scr.bus_widths & SD_SCR_WIDTH_4BIT)
8f60b374:	e7e08158 	ubfx	r8, r8, #2, #1
		mmc_return = mmc_sd_set_bus_width(host, card, bus_width);
8f60b378:	e1a02008 	mov	r2, r8
8f60b37c:	ebfffced 	bl	8f60a738 <mmc_sd_set_bus_width>
		if (mmc_return)
8f60b380:	e2507000 	subs	r7, r0, #0
8f60b384:	1a00017f 	bne	8f60b988 <mmc_init+0x10a4>
		mmc_return = sdhci_set_bus_width(host, bus_width);
8f60b388:	e1a01008 	mov	r1, r8
8f60b38c:	e1a00004 	mov	r0, r4
8f60b390:	ebfff394 	bl	8f6081e8 <sdhci_set_bus_width>
		if (mmc_return)
8f60b394:	e3500000 	cmp	r0, #0
8f60b398:	1a0001df 	bne	8f60bb1c <mmc_init+0x1238>
	if (MMC_CARD_MMC(card)) {
8f60b39c:	e5943050 	ldr	r3, [r4, #80]	; 0x50
	card->block_size = MMC_BLK_SZ;
8f60b3a0:	e3a02c02 	mov	r2, #512	; 0x200
8f60b3a4:	e5842040 	str	r2, [r4, #64]	; 0x40
	if (MMC_CARD_MMC(card)) {
8f60b3a8:	e2433003 	sub	r3, r3, #3
8f60b3ac:	e3530001 	cmp	r3, #1
8f60b3b0:	8afffdd2 	bhi	8f60ab00 <mmc_init+0x21c>
		if (!card->ext_csd[MMC_EXT_CSD_RST_N_FUNC])
8f60b3b4:	e5943058 	ldr	r3, [r4, #88]	; 0x58
8f60b3b8:	e5d330a2 	ldrb	r3, [r3, #162]	; 0xa2
8f60b3bc:	e3530000 	cmp	r3, #0
8f60b3c0:	1afffdce 	bne	8f60ab00 <mmc_init+0x21c>
			mmc_return = mmc_switch_cmd(host, card, MMC_SET_BIT, MMC_EXT_CSD_RST_N_FUNC, RST_N_FUNC_ENABLE);
8f60b3c4:	e3a02001 	mov	r2, #1
8f60b3c8:	e3a030a2 	mov	r3, #162	; 0xa2
8f60b3cc:	e1a01006 	mov	r1, r6
8f60b3d0:	e1a00004 	mov	r0, r4
8f60b3d4:	e58d2000 	str	r2, [r13]
8f60b3d8:	ebfffa40 	bl	8f609ce0 <mmc_switch_cmd>
			if (mmc_return)
8f60b3dc:	e2507000 	subs	r7, r0, #0
8f60b3e0:	0afffdc6 	beq	8f60ab00 <mmc_init+0x21c>
				dprintf(CRITICAL, "Failed to enable RST_n_FUNCTION\n");
8f60b3e4:	e3020d38 	movw	r0, #11576	; 0x2d38
8f60b3e8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b3ec:	eb009d60 	bl	8f632974 <_dprintf>
				return mmc_return;
8f60b3f0:	eafffdbf 	b	8f60aaf4 <mmc_init+0x210>
	memcpy(raw_scr, scr_resp, sizeof(raw_scr));
8f60b3f4:	e3a02008 	mov	r2, #8
8f60b3f8:	e1a0100b 	mov	r1, r11
8f60b3fc:	e28d0098 	add	r0, r13, #152	; 0x98
8f60b400:	eb00a36c 	bl	8f6341b8 <memcpy>
	card->raw_scr[0] = swap_endian32(raw_scr[0]);
8f60b404:	e59d3098 	ldr	r3, [r13, #152]	; 0x98
8f60b408:	e59d209c 	ldr	r2, [r13, #156]	; 0x9c
	struct mmc_command cmd = {0};
8f60b40c:	e1a01008 	mov	r1, r8
8f60b410:	e6bf3f33 	rev	r3, r3
8f60b414:	e28d0050 	add	r0, r13, #80	; 0x50
8f60b418:	e6bf2f32 	rev	r2, r2
	card->raw_scr[0] = swap_endian32(raw_scr[0]);
8f60b41c:	e584306c 	str	r3, [r4, #108]	; 0x6c
	card->raw_scr[1] = swap_endian32(raw_scr[1]);
8f60b420:	e5842070 	str	r2, [r4, #112]	; 0x70
	card->scr.bus_widths = (card->raw_scr[0] & SD_SCR_BUS_WIDTH_MASK) >> SD_SCR_BUS_WIDTH;
8f60b424:	e7e32853 	ubfx	r2, r3, #16, #4
8f60b428:	e58420dc 	str	r2, [r4, #220]	; 0xdc
	card->scr.cmd23_support = (card->raw_scr[0] & SD_SCR_CMD23_SUPPORT);
8f60b42c:	e2032002 	and	r2, r3, #2
8f60b430:	e58420e8 	str	r2, [r4, #232]	; 0xe8
	card->scr.sd_spec = (card->raw_scr[0] & SD_SCR_SD_SPEC_MASK) >> SD_SCR_SD_SPEC;
8f60b434:	e7e32c53 	ubfx	r2, r3, #24, #4
	card->scr.sd3_spec = (card->raw_scr[0] & SD_SCR_SD_SPEC3_MASK) >> SD_SCR_SD_SPEC3;
8f60b438:	e7e037d3 	ubfx	r3, r3, #15, #1
	card->scr.sd_spec = (card->raw_scr[0] & SD_SCR_SD_SPEC_MASK) >> SD_SCR_SD_SPEC;
8f60b43c:	e58420e0 	str	r2, [r4, #224]	; 0xe0
	card->scr.sd3_spec = (card->raw_scr[0] & SD_SCR_SD_SPEC3_MASK) >> SD_SCR_SD_SPEC3;
8f60b440:	e58430e4 	str	r3, [r4, #228]	; 0xe4
	struct mmc_command cmd = {0};
8f60b444:	e3a02048 	mov	r2, #72	; 0x48
8f60b448:	eb00a39d 	bl	8f6342c4 <memset>
	struct mmc_command cmd = {0};
8f60b44c:	e1a01008 	mov	r1, r8
8f60b450:	e5948038 	ldr	r8, [r4, #56]	; 0x38
8f60b454:	e3a02048 	mov	r2, #72	; 0x48
8f60b458:	e28d0098 	add	r0, r13, #152	; 0x98
8f60b45c:	eb00a398 	bl	8f6342c4 <memset>
	if (sdhci_send_command(host, &cmd))
8f60b460:	e28d1098 	add	r1, r13, #152	; 0x98
8f60b464:	e1a00004 	mov	r0, r4
	cmd.argument = (card->rca << 16);
8f60b468:	e1a08808 	lsl	r8, r8, #16
	cmd.cmd_index = CMD55_APP_CMD;
8f60b46c:	e1cd99b8 	strh	r9, [r13, #152]	; 0x98
	cmd.argument = (card->rca << 16);
8f60b470:	e58d809c 	str	r8, [r13, #156]	; 0x9c
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60b474:	e1cd7ab2 	strh	r7, [r13, #162]	; 0xa2
	if (sdhci_send_command(host, &cmd))
8f60b478:	ebfff37b 	bl	8f60826c <sdhci_send_command>
8f60b47c:	e3500000 	cmp	r0, #0
8f60b480:	1a0000f7 	bne	8f60b864 <mmc_init+0xf80>
	cmd.argument = 0x0;
8f60b484:	e58d0054 	str	r0, [r13, #84]	; 0x54
	if (sdhci_send_command(host, &cmd))
8f60b488:	e28d1050 	add	r1, r13, #80	; 0x50
8f60b48c:	e1a00004 	mov	r0, r4
	cmd.cmd_index = ACMD13_SEND_SD_STATUS;
8f60b490:	e3a0300d 	mov	r3, #13
	cmd.trans_mode = SDHCI_MMC_READ;
8f60b494:	e58d706c 	str	r7, [r13, #108]	; 0x6c
	cmd.data.blk_sz = 0x40;
8f60b498:	e3a08040 	mov	r8, #64	; 0x40
	cmd.data.num_blocks = 0x1;
8f60b49c:	e58d708c 	str	r7, [r13, #140]	; 0x8c
	cmd.data.data_ptr = raw_sd_status;
8f60b4a0:	e30c7c00 	movw	r7, #52224	; 0xcc00
	cmd.data_present = 0x1;
8f60b4a4:	e58da058 	str	r10, [r13, #88]	; 0x58
	cmd.data.data_ptr = raw_sd_status;
8f60b4a8:	e3487f72 	movt	r7, #36722	; 0x8f72
	cmd.cmd_index = ACMD13_SEND_SD_STATUS;
8f60b4ac:	e1cd35b0 	strh	r3, [r13, #80]	; 0x50
	cmd.data.data_ptr = raw_sd_status;
8f60b4b0:	e58d7084 	str	r7, [r13, #132]	; 0x84
	cmd.data.blk_sz = 0x40;
8f60b4b4:	e58d8088 	str	r8, [r13, #136]	; 0x88
	if (sdhci_send_command(host, &cmd))
8f60b4b8:	ebfff36b 	bl	8f60826c <sdhci_send_command>
8f60b4bc:	e3500000 	cmp	r0, #0
8f60b4c0:	0a000111 	beq	8f60b90c <mmc_init+0x1028>
			dprintf(CRITICAL, "Failed to get SSR from the card\n");
8f60b4c4:	e3020a88 	movw	r0, #10888	; 0x2a88
8f60b4c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b4cc:	eb009d28 	bl	8f632974 <_dprintf>
			return 1;
8f60b4d0:	eafffea0 	b	8f60af58 <mmc_init+0x674>
		mmc_cid.mid = UNPACK_BITS(raw_cid, 120, 8, mmc_sizeof);
8f60b4d4:	e28d7058 	add	r7, r13, #88	; 0x58
		mmc_cid.oid = UNPACK_BITS(raw_cid, 104, 16, mmc_sizeof);
8f60b4d8:	e3a02058 	mov	r2, #88	; 0x58
		for (i = 0; i < 5; i++) {
8f60b4dc:	e3520038 	cmp	r2, #56	; 0x38
		mmc_cid.oid = UNPACK_BITS(raw_cid, 104, 16, mmc_sizeof);
8f60b4e0:	e7ef1453 	ubfx	r1, r3, #8, #16
8f60b4e4:	e58d1054 	str	r1, [r13, #84]	; 0x54
		mmc_cid.mid = UNPACK_BITS(raw_cid, 120, 8, mmc_sizeof);
8f60b4e8:	e1a01c23 	lsr	r1, r3, #24
8f60b4ec:	e58d1050 	str	r1, [r13, #80]	; 0x50
			mmc_cid.pnm[i] = (uint8_t)UNPACK_BITS(raw_cid,
8f60b4f0:	e1a01007 	mov	r1, r7
8f60b4f4:	e4c13001 	strb	r3, [r1], #1
		for (i = 0; i < 5; i++) {
8f60b4f8:	0a000006 	beq	8f60b518 <mmc_init+0xc34>
			mmc_cid.pnm[i] = (uint8_t)UNPACK_BITS(raw_cid,
8f60b4fc:	e202001f 	and	r0, r2, #31
8f60b500:	e59d30ac 	ldr	r3, [r13, #172]	; 0xac
8f60b504:	e2422008 	sub	r2, r2, #8
		for (i = 0; i < 5; i++) {
8f60b508:	e3520038 	cmp	r2, #56	; 0x38
			mmc_cid.pnm[i] = (uint8_t)UNPACK_BITS(raw_cid,
8f60b50c:	e1a03033 	lsr	r3, r3, r0
8f60b510:	e4c13001 	strb	r3, [r1], #1
		for (i = 0; i < 5; i++) {
8f60b514:	1afffff8 	bne	8f60b4fc <mmc_init+0xc18>
		mmc_cid.psn = UNPACK_BITS(raw_cid, 24, 32, mmc_sizeof);
8f60b518:	e59d30a4 	ldr	r3, [r13, #164]	; 0xa4
		mmc_cid.pnm[5] = 0;
8f60b51c:	e3a01000 	mov	r1, #0
		mmc_cid.prv = UNPACK_BITS(raw_cid, 56, 8, mmc_sizeof);
8f60b520:	e59d20a8 	ldr	r2, [r13, #168]	; 0xa8
		mmc_cid.pnm[5] = 0;
8f60b524:	e5cd105d 	strb	r1, [r13, #93]	; 0x5d
		mmc_cid.pnm[6] = 0;
8f60b528:	e5cd105e 	strb	r1, [r13, #94]	; 0x5e
		mmc_cid.year += 2000;
8f60b52c:	e7e71653 	ubfx	r1, r3, #12, #8
8f60b530:	e2811e7d 	add	r1, r1, #2000	; 0x7d0
8f60b534:	e58d106c 	str	r1, [r13, #108]	; 0x6c
		mmc_cid.psn = UNPACK_BITS(raw_cid, 24, 32, mmc_sizeof);
8f60b538:	e1a01402 	lsl	r1, r2, #8
		mmc_cid.prv = UNPACK_BITS(raw_cid, 56, 8, mmc_sizeof);
8f60b53c:	e1a02c22 	lsr	r2, r2, #24
8f60b540:	e58d2060 	str	r2, [r13, #96]	; 0x60
		mmc_cid.psn = UNPACK_BITS(raw_cid, 24, 32, mmc_sizeof);
8f60b544:	e1812c23 	orr	r2, r1, r3, lsr #24
		mmc_cid.month = UNPACK_BITS(raw_cid, 8, 4, mmc_sizeof);
8f60b548:	e7e33453 	ubfx	r3, r3, #8, #4
		mmc_cid.psn = UNPACK_BITS(raw_cid, 24, 32, mmc_sizeof);
8f60b54c:	e58d2064 	str	r2, [r13, #100]	; 0x64
		mmc_cid.month = UNPACK_BITS(raw_cid, 8, 4, mmc_sizeof);
8f60b550:	e58d3068 	str	r3, [r13, #104]	; 0x68
		mmc_cid.year += 2000;
8f60b554:	eafffdda 	b	8f60acc4 <mmc_init+0x3e0>
		if (card->ext_csd[MMC_ERASE_GRP_DEF])
8f60b558:	e5942058 	ldr	r2, [r4, #88]	; 0x58
8f60b55c:	e5d230af 	ldrb	r3, [r2, #175]	; 0xaf
8f60b560:	e3530000 	cmp	r3, #0
			card->wp_grp_size = (card->csd.wp_grp_size + 1) * (card->csd.erase_grp_size + 1) \
8f60b564:	059430cc 	ldreq	r3, [r4, #204]	; 0xcc
8f60b568:	059410d4 	ldreq	r1, [r4, #212]	; 0xd4
8f60b56c:	02833001 	addeq	r3, r3, #1
			card->wp_grp_size = MMC_HC_ERASE_MULT * card->ext_csd[MMC_HC_ERASE_GRP_SIZE] / MMC_BLK_SZ;
8f60b570:	15d230e0 	ldrbne	r3, [r2, #224]	; 0xe0
			card->wp_grp_size = (card->csd.wp_grp_size + 1) * (card->csd.erase_grp_size + 1) \
8f60b574:	00233391 	mlaeq	r3, r1, r3, r3
						  * (card->csd.erase_grp_mult + 1);
8f60b578:	059410d0 	ldreq	r1, [r4, #208]	; 0xd0
			card->wp_grp_size = MMC_HC_ERASE_MULT * card->ext_csd[MMC_HC_ERASE_GRP_SIZE] / MMC_BLK_SZ;
8f60b57c:	11a03503 	lslne	r3, r3, #10
						  * (card->csd.erase_grp_mult + 1);
8f60b580:	00233391 	mlaeq	r3, r1, r3, r3
8f60b584:	e5843044 	str	r3, [r4, #68]	; 0x44
		card->rpmb_size = RPMB_PART_MIN_SIZE * card->ext_csd[RPMB_SIZE_MULT];
8f60b588:	e5d230a8 	ldrb	r3, [r2, #168]	; 0xa8
8f60b58c:	e1a03883 	lsl	r3, r3, #17
8f60b590:	e5843074 	str	r3, [r4, #116]	; 0x74
		card->rel_wr_count = card->ext_csd[REL_WR_SEC_C];
8f60b594:	e5d230de 	ldrb	r3, [r2, #222]	; 0xde
8f60b598:	e5843078 	str	r3, [r4, #120]	; 0x78
8f60b59c:	eaffff1d 	b	8f60b218 <mmc_init+0x934>
		if (mmc_csd.cmmc_structure == 1) {
8f60b5a0:	e3520001 	cmp	r2, #1
8f60b5a4:	0a00011e 	beq	8f60ba24 <mmc_init+0x1140>
			mmc_temp = UNPACK_BITS(raw_csd, 22, 4, mmc_sizeof);
8f60b5a8:	e594205c 	ldr	r2, [r4, #92]	; 0x5c
			mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit])
8f60b5ac:	e7e3b9d3 	ubfx	r11, r3, #19, #4
			mmc_csd.card_cmd_class = UNPACK_BITS(raw_csd, 84, 12, mmc_sizeof);
8f60b5b0:	e5941064 	ldr	r1, [r4, #100]	; 0x64
			mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit])
8f60b5b4:	e30371e8 	movw	r7, #12776	; 0x31e8
8f60b5b8:	e7e3cb52 	ubfx	r12, r2, #22, #4
8f60b5bc:	e3487f70 	movt	r7, #36720	; 0x8f70
			mmc_csd.write_blk_len = (mmc_temp > 8 && mmc_temp < 12) ?
8f60b5c0:	e24c0009 	sub	r0, r12, #9
			mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit])
8f60b5c4:	e7e2a853 	ubfx	r10, r3, #16, #3
									(1 << mmc_temp) : 512;
8f60b5c8:	e3500002 	cmp	r0, #2
			mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit])
8f60b5cc:	e797b10b 	ldr	r11, [r7, r11, lsl #2]
			mmc_csd.card_cmd_class = UNPACK_BITS(raw_csd, 84, 12, mmc_sizeof);
8f60b5d0:	e1a00a21 	lsr	r0, r1, #20
			mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit])
8f60b5d4:	e30371c8 	movw	r7, #12744	; 0x31c8
8f60b5d8:	e3487f70 	movt	r7, #36720	; 0x8f70
			mmc_csd.card_cmd_class = UNPACK_BITS(raw_csd, 84, 12, mmc_sizeof);
8f60b5dc:	e58d0018 	str	r0, [r13, #24]
									(1 << mmc_temp) : 512;
8f60b5e0:	93a00001 	movls	r0, #1
8f60b5e4:	83a00c02 	movhi	r0, #512	; 0x200
8f60b5e8:	91a00c10 	lslls	r0, r0, r12
			mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit])
8f60b5ec:	e797710a 	ldr	r7, [r7, r10, lsl #2]
8f60b5f0:	e7e3c851 	ubfx	r12, r1, #16, #4
			mmc_csd.write_blk_len = (mmc_temp > 8 && mmc_temp < 12) ?
8f60b5f4:	e58d001c 	str	r0, [r13, #28]
			mmc_csd.read_blk_len = (mmc_temp > 8 && mmc_temp < 12) ?
8f60b5f8:	e24c0009 	sub	r0, r12, #9
			mmc_csd.tran_speed = (xfer_rate_value[mmc_value] *
8f60b5fc:	e7e391d3 	ubfx	r9, r3, #3, #4
								   (1 << mmc_temp) : 512;
8f60b600:	e3500002 	cmp	r0, #2
								 xfer_rate_unit[mmc_unit]) / 10;
8f60b604:	e2038007 	and	r8, r3, #7
			mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit])
8f60b608:	e00b0b97 	mul	r11, r7, r11
			mmc_csd.tran_speed = (xfer_rate_value[mmc_value] *
8f60b60c:	e3037248 	movw	r7, #12872	; 0x3248
8f60b610:	e3487f70 	movt	r7, #36720	; 0x8f70
								   (1 << mmc_temp) : 512;
8f60b614:	93a00001 	movls	r0, #1
8f60b618:	91a00c10 	lslls	r0, r0, r12
8f60b61c:	83a0ec02 	movhi	r14, #512	; 0x200
			mmc_csd.tran_speed = (xfer_rate_value[mmc_value] *
8f60b620:	e7977109 	ldr	r7, [r7, r9, lsl #2]
								 xfer_rate_unit[mmc_unit]) / 10;
8f60b624:	e3039228 	movw	r9, #12840	; 0x3228
8f60b628:	e3489f70 	movt	r9, #36720	; 0x8f70
			card->capacity = (unsigned long long)mmc_temp * mmc_csd.read_blk_len;
8f60b62c:	91a0cfc0 	asrls	r12, r0, #31
8f60b630:	958dc00c 	strls	r12, [r13, #12]
8f60b634:	83a00000 	movhi	r0, #0
			mmc_csd.sector_size = UNPACK_BITS(raw_csd, 39, 7, mmc_sizeof) + 1;
8f60b638:	e594c060 	ldr	r12, [r4, #96]	; 0x60
			card->capacity = (unsigned long long)mmc_temp * mmc_csd.read_blk_len;
8f60b63c:	91a0e000 	movls	r14, r0
			mmc_csd.tran_speed = (xfer_rate_value[mmc_value] *
8f60b640:	e7998108 	ldr	r8, [r9, r8, lsl #2]
			mmc_csd.nsac_clk_cycle = UNPACK_BITS(raw_csd, 104, 8, mmc_sizeof)
8f60b644:	e7e73453 	ubfx	r3, r3, #8, #8
8f60b648:	858d000c 	strhi	r0, [r13, #12]
								   (1 << mmc_temp) : 512;
8f60b64c:	81a0000e 	movhi	r0, r14
			mmc_csd.read_blk_len = (mmc_temp > 8 && mmc_temp < 12) ?
8f60b650:	e58d0020 	str	r0, [r13, #32]
			mmc_csd.c_size = UNPACK_BITS(raw_csd, 62, 12, mmc_sizeof);
8f60b654:	e1a00101 	lsl	r0, r1, #2
			mmc_csd.tran_speed = (xfer_rate_value[mmc_value] *
8f60b658:	e0070798 	mul	r7, r8, r7
			mmc_csd.c_size = UNPACK_BITS(raw_csd, 62, 12, mmc_sizeof);
8f60b65c:	e1800f2c 	orr	r0, r0, r12, lsr #30
8f60b660:	e7eb0050 	ubfx	r0, r0, #0, #12
8f60b664:	e7e287dc 	ubfx	r8, r12, #15, #3
8f60b668:	e58d0030 	str	r0, [r13, #48]	; 0x30
			mmc_temp = (1 << (mmc_csd.c_size_mult + 2)) * (mmc_csd.c_size + 1);
8f60b66c:	e2800001 	add	r0, r0, #1
			mmc_csd.c_size_mult = UNPACK_BITS(raw_csd, 47, 3, mmc_sizeof);
8f60b670:	e58d802c 	str	r8, [r13, #44]	; 0x2c
			mmc_temp = (1 << (mmc_csd.c_size_mult + 2)) * (mmc_csd.c_size + 1);
8f60b674:	e2888002 	add	r8, r8, #2
8f60b678:	e1a00810 	lsl	r0, r0, r8
							  / 10;
8f60b67c:	e30c8ccd 	movw	r8, #52429	; 0xcccd
8f60b680:	e34c8ccc 	movt	r8, #52428	; 0xcccc
8f60b684:	e08b9b98 	umull	r9, r11, r8, r11
								 xfer_rate_unit[mmc_unit]) / 10;
8f60b688:	e0878798 	umull	r8, r7, r8, r7
			card->capacity = (unsigned long long)mmc_temp * mmc_csd.read_blk_len;
8f60b68c:	e59d800c 	ldr	r8, [r13, #12]
							  / 10;
8f60b690:	e1a0b1ab 	lsr	r11, r11, #3
			mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit])
8f60b694:	e58db038 	str	r11, [r13, #56]	; 0x38
								 xfer_rate_unit[mmc_unit]) / 10;
8f60b698:	e1a071a7 	lsr	r7, r7, #3
			mmc_csd.tran_speed = (xfer_rate_value[mmc_value] *
8f60b69c:	e58d703c 	str	r7, [r13, #60]	; 0x3c
			card->capacity = (unsigned long long)mmc_temp * mmc_csd.read_blk_len;
8f60b6a0:	e087ee90 	umull	r14, r7, r0, r14
8f60b6a4:	e0207890 	mla	r0, r0, r8, r7
8f60b6a8:	e584e048 	str	r14, [r4, #72]	; 0x48
			mmc_csd.wp_grp_enable = UNPACK_BITS(raw_csd, 31, 1, mmc_sizeof);
8f60b6ac:	e7e0e6d2 	ubfx	r14, r2, #13, #1
			card->capacity = (unsigned long long)mmc_temp * mmc_csd.read_blk_len;
8f60b6b0:	e584004c 	str	r0, [r4, #76]	; 0x4c
			mmc_csd.wp_grp_enable = UNPACK_BITS(raw_csd, 31, 1, mmc_sizeof);
8f60b6b4:	e1a00fa2 	lsr	r0, r2, #31
8f60b6b8:	e180008e 	orr	r0, r0, r14, lsl #1
8f60b6bc:	e7e0e652 	ubfx	r14, r2, #12, #1
8f60b6c0:	e180010e 	orr	r0, r0, r14, lsl #2
			mmc_csd.nsac_clk_cycle = UNPACK_BITS(raw_csd, 104, 8, mmc_sizeof)
8f60b6c4:	e3a0e064 	mov	r14, #100	; 0x64
8f60b6c8:	e003039e 	mul	r3, r14, r3
8f60b6cc:	e58d3034 	str	r3, [r13, #52]	; 0x34
			mmc_csd.wp_grp_enable = UNPACK_BITS(raw_csd, 31, 1, mmc_sizeof);
8f60b6d0:	e7e0375c 	ubfx	r3, r12, #14, #1
8f60b6d4:	e1803183 	orr	r3, r0, r3, lsl #3
8f60b6d8:	e7e006d1 	ubfx	r0, r1, #13, #1
8f60b6dc:	e1833200 	orr	r3, r3, r0, lsl #4
8f60b6e0:	e7e00751 	ubfx	r0, r1, #14, #1
8f60b6e4:	e7e017d1 	ubfx	r1, r1, #15, #1
8f60b6e8:	e1833280 	orr	r3, r3, r0, lsl #5
8f60b6ec:	e1833301 	orr	r3, r3, r1, lsl #6
			mmc_csd.write_blk_partial = UNPACK_BITS(raw_csd, 21, 1, mmc_sizeof);
8f60b6f0:	e1a01aa2 	lsr	r1, r2, #21
			mmc_csd.r2w_factor = UNPACK_BITS(raw_csd, 26, 3, mmc_sizeof);
8f60b6f4:	e7e22d52 	ubfx	r2, r2, #26, #3
8f60b6f8:	e58d2024 	str	r2, [r13, #36]	; 0x24
			mmc_csd.wp_grp_enable = UNPACK_BITS(raw_csd, 31, 1, mmc_sizeof);
8f60b6fc:	e1833381 	orr	r3, r3, r1, lsl #7
8f60b700:	e5cd304c 	strb	r3, [r13, #76]	; 0x4c
			mmc_csd.sector_size = UNPACK_BITS(raw_csd, 39, 7, mmc_sizeof) + 1;
8f60b704:	e7e633dc 	ubfx	r3, r12, #7, #7
			mmc_csd.wp_grp_size = UNPACK_BITS(raw_csd, 32, 7, mmc_sizeof);
8f60b708:	e20cc07f 	and	r12, r12, #127	; 0x7f
			mmc_csd.sector_size = UNPACK_BITS(raw_csd, 39, 7, mmc_sizeof) + 1;
8f60b70c:	e2833001 	add	r3, r3, #1
			mmc_csd.wp_grp_size = UNPACK_BITS(raw_csd, 32, 7, mmc_sizeof);
8f60b710:	e58dc048 	str	r12, [r13, #72]	; 0x48
			mmc_csd.sector_size = UNPACK_BITS(raw_csd, 39, 7, mmc_sizeof) + 1;
8f60b714:	e58d3028 	str	r3, [r13, #40]	; 0x28
			card->capacity = (unsigned long long)mmc_temp * mmc_csd.read_blk_len;
8f60b718:	eafffeaf 	b	8f60b1dc <mmc_init+0x8f8>
	ASSERT(data);
8f60b71c:	e30315ec 	movw	r1, #13804	; 0x35ec
8f60b720:	e30223d0 	movw	r2, #9168	; 0x23d0
8f60b724:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60b728:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60b72c:	e58d1000 	str	r1, [r13]
8f60b730:	e3003733 	movw	r3, #1843	; 0x733
8f60b734:	e3001130 	movw	r1, #304	; 0x130
8f60b738:	e1a00008 	mov	r0, r8
8f60b73c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60b740:	eb009cdd 	bl	8f632abc <_panic>
8f60b744:	eafffc74 	b	8f60a91c <mmc_init+0x38>
	ASSERT(data);
8f60b748:	e1a00008 	mov	r0, r8
8f60b74c:	e30335ec 	movw	r3, #13804	; 0x35ec
8f60b750:	e30223d0 	movw	r2, #9168	; 0x23d0
8f60b754:	e3483f70 	movt	r3, #36720	; 0x8f70
8f60b758:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60b75c:	e58d3000 	str	r3, [r13]
8f60b760:	e3001130 	movw	r1, #304	; 0x130
8f60b764:	e3003464 	movw	r3, #1124	; 0x464
8f60b768:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60b76c:	eb009cd2 	bl	8f632abc <_panic>
8f60b770:	eafffc85 	b	8f60a98c <mmc_init+0xa8>
		dprintf(CRITICAL, "Switch cmd returned failure %d\n", __LINE__);
8f60b774:	e3a01e3e 	mov	r1, #992	; 0x3e0
8f60b778:	e30205e0 	movw	r0, #9696	; 0x25e0
8f60b77c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b780:	eb009c7b 	bl	8f632974 <_dprintf>
			dprintf(CRITICAL, "Error adjusting interface speed!\n");
8f60b784:	e3020a10 	movw	r0, #10768	; 0x2a10
8f60b788:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b78c:	eb009c78 	bl	8f632974 <_dprintf>
			return mmc_return;
8f60b790:	eafffcd7 	b	8f60aaf4 <mmc_init+0x210>
		if (cfg->bus_width == DATA_BUS_WIDTH_8BIT && host->caps.bus_width_8bit)
8f60b794:	e2843f42 	add	r3, r4, #264	; 0x108
8f60b798:	e1d310b0 	ldrh	r1, [r3]
8f60b79c:	e3510002 	cmp	r1, #2
8f60b7a0:	0a0000e1 	beq	8f60bb2c <mmc_init+0x1248>
		else if (cfg->bus_width == DATA_BUS_WIDTH_4BIT)
8f60b7a4:	e2418001 	sub	r8, r1, #1
8f60b7a8:	e16f8f18 	clz	r8, r8
8f60b7ac:	e1a082a8 	lsr	r8, r8, #5
		mmc_return = sdhci_set_bus_width(host, bus_width);
8f60b7b0:	e6ff1078 	uxth	r1, r8
8f60b7b4:	e1a00004 	mov	r0, r4
8f60b7b8:	ebfff28a 	bl	8f6081e8 <sdhci_set_bus_width>
		if (mmc_return) {
8f60b7bc:	e3500000 	cmp	r0, #0
8f60b7c0:	1a0000d5 	bne	8f60bb1c <mmc_init+0x1238>
		if (host->caps.hs400_support && mmc_card_supports_hs400_mode(card))
8f60b7c4:	e5d4302c 	ldrb	r3, [r4, #44]	; 0x2c
8f60b7c8:	e3530000 	cmp	r3, #0
8f60b7cc:	0a00002c 	beq	8f60b884 <mmc_init+0xfa0>
	if (MMC_CARD_MMC(card)) {
8f60b7d0:	e5943050 	ldr	r3, [r4, #80]	; 0x50
8f60b7d4:	e2433003 	sub	r3, r3, #3
8f60b7d8:	e3530001 	cmp	r3, #1
8f60b7dc:	8a00006d 	bhi	8f60b998 <mmc_init+0x10b4>
		if (card->ext_csd[MMC_DEVICE_TYPE] & MMC_HS_HS400_MODE)
8f60b7e0:	e5942058 	ldr	r2, [r4, #88]	; 0x58
8f60b7e4:	e5d230c4 	ldrb	r3, [r2, #196]	; 0xc4
8f60b7e8:	e31300c0 	tst	r3, #192	; 0xc0
8f60b7ec:	1a0000e5 	bne	8f60bb88 <mmc_init+0x12a4>
		else if (host->caps.sdr104_support && mmc_card_supports_hs200_mode(card))
8f60b7f0:	e5d4102a 	ldrb	r1, [r4, #42]	; 0x2a
8f60b7f4:	e3510000 	cmp	r1, #0
8f60b7f8:	1a00002a 	bne	8f60b8a8 <mmc_init+0xfc4>
		} else if (host->caps.ddr_support && mmc_card_supports_ddr_mode(card)) {
8f60b7fc:	e5d43028 	ldrb	r3, [r4, #40]	; 0x28
8f60b800:	e3530000 	cmp	r3, #0
8f60b804:	0a000066 	beq	8f60b9a4 <mmc_init+0x10c0>
		if (card->ext_csd[MMC_DEVICE_TYPE] & MMC_HS_HS400_MODE)
8f60b808:	e5d230c4 	ldrb	r3, [r2, #196]	; 0xc4
		if (card->ext_csd[MMC_DEVICE_TYPE] & MMC_HS_DDR_MODE)
8f60b80c:	e313000c 	tst	r3, #12
8f60b810:	0a000063 	beq	8f60b9a4 <mmc_init+0x10c0>
			dprintf(INFO, "SDHC Running in DDR mode\n");
8f60b814:	e3020cf4 	movw	r0, #11508	; 0x2cf4
8f60b818:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b81c:	eb009c54 	bl	8f632974 <_dprintf>
			mmc_return = mmc_set_ddr_mode(host, card);
8f60b820:	e1a01006 	mov	r1, r6
8f60b824:	e1a00004 	mov	r0, r4
8f60b828:	ebfffa2b 	bl	8f60a0dc <mmc_set_ddr_mode>
			if (mmc_return) {
8f60b82c:	e3500000 	cmp	r0, #0
8f60b830:	0afffed9 	beq	8f60b39c <mmc_init+0xab8>
				dprintf(CRITICAL, "Failure to set DDR mode for Card(RCA:%x)\n",
8f60b834:	e5941038 	ldr	r1, [r4, #56]	; 0x38
8f60b838:	e3020588 	movw	r0, #9608	; 0x2588
8f60b83c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b840:	eb009c4b 	bl	8f632974 <_dprintf>
				return mmc_return;
8f60b844:	eafffdc3 	b	8f60af58 <mmc_init+0x674>
		dprintf(CRITICAL, "Failed Sending CMD55\n");
8f60b848:	e3020758 	movw	r0, #10072	; 0x2758
8f60b84c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b850:	eb009c47 	bl	8f632974 <_dprintf>
		dprintf(CRITICAL, "Failed sending App command\n");
8f60b854:	e3020770 	movw	r0, #10096	; 0x2770
8f60b858:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b85c:	eb009c44 	bl	8f632974 <_dprintf>
		return 1;
8f60b860:	eafffdb9 	b	8f60af4c <mmc_init+0x668>
		dprintf(CRITICAL, "Failed Sending CMD55\n");
8f60b864:	e3020758 	movw	r0, #10072	; 0x2758
8f60b868:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b86c:	eb009c40 	bl	8f632974 <_dprintf>
		dprintf(CRITICAL, "Failed sending App command\n");
8f60b870:	e3020770 	movw	r0, #10096	; 0x2770
8f60b874:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b878:	eb009c3d 	bl	8f632974 <_dprintf>
		return 1;
8f60b87c:	eaffff10 	b	8f60b4c4 <mmc_init+0xbe0>
8f60b880:	8f74221c 	.word	0x8f74221c
		else if (host->caps.sdr104_support && mmc_card_supports_hs200_mode(card))
8f60b884:	e5d4302a 	ldrb	r3, [r4, #42]	; 0x2a
8f60b888:	e3530000 	cmp	r3, #0
8f60b88c:	0a0000ab 	beq	8f60bb40 <mmc_init+0x125c>
	if (MMC_CARD_MMC(card)) {
8f60b890:	e5943050 	ldr	r3, [r4, #80]	; 0x50
8f60b894:	e2433003 	sub	r3, r3, #3
8f60b898:	e3530001 	cmp	r3, #1
8f60b89c:	8a000040 	bhi	8f60b9a4 <mmc_init+0x10c0>
		if (card->ext_csd[MMC_DEVICE_TYPE] & MMC_HS_HS400_MODE)
8f60b8a0:	e5943058 	ldr	r3, [r4, #88]	; 0x58
8f60b8a4:	e5d330c4 	ldrb	r3, [r3, #196]	; 0xc4
		if (card->ext_csd[MMC_DEVICE_TYPE] & MMC_HS_HS200_MODE)
8f60b8a8:	e3130030 	tst	r3, #48	; 0x30
8f60b8ac:	0a0000c3 	beq	8f60bbc0 <mmc_init+0x12dc>
			dprintf(INFO, "SDHC Running in HS200 mode\n");
8f60b8b0:	e3020cac 	movw	r0, #11436	; 0x2cac
8f60b8b4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b8b8:	eb009c2d 	bl	8f632974 <_dprintf>
			mmc_return = mmc_set_hs200_mode(host, card, bus_width);
8f60b8bc:	e1a02008 	mov	r2, r8
8f60b8c0:	e1a01006 	mov	r1, r6
8f60b8c4:	e1a00004 	mov	r0, r4
8f60b8c8:	ebfffa2c 	bl	8f60a180 <mmc_set_hs200_mode>
			if (mmc_return) {
8f60b8cc:	e2507000 	subs	r7, r0, #0
8f60b8d0:	0afffeb1 	beq	8f60b39c <mmc_init+0xab8>
				dprintf(CRITICAL, "Failure to set HS200 mode for Card(RCA:%x)\n",
8f60b8d4:	e5941038 	ldr	r1, [r4, #56]	; 0x38
8f60b8d8:	e3020cc8 	movw	r0, #11464	; 0x2cc8
8f60b8dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b8e0:	eb009c23 	bl	8f632974 <_dprintf>
				return mmc_return;
8f60b8e4:	eafffc82 	b	8f60aaf4 <mmc_init+0x210>
						| card->ext_csd[MMC_SEC_COUNT1];
8f60b8e8:	e5943058 	ldr	r3, [r4, #88]	; 0x58
8f60b8ec:	e59330d4 	ldr	r3, [r3, #212]	; 0xd4
			card->capacity = sec_count * MMC_BLK_SZ;
8f60b8f0:	e1a02fc3 	asr	r2, r3, #31
8f60b8f4:	e1a02482 	lsl	r2, r2, #9
8f60b8f8:	e1822ba3 	orr	r2, r2, r3, lsr #23
8f60b8fc:	e1a03483 	lsl	r3, r3, #9
8f60b900:	e584204c 	str	r2, [r4, #76]	; 0x4c
8f60b904:	e5843048 	str	r3, [r4, #72]	; 0x48
8f60b908:	eafffe33 	b	8f60b1dc <mmc_init+0x8f8>
	memcpy(sd_status, raw_sd_status, sizeof(sd_status));
8f60b90c:	e1a02008 	mov	r2, r8
8f60b910:	e1a01007 	mov	r1, r7
8f60b914:	e28d0098 	add	r0, r13, #152	; 0x98
8f60b918:	eb00a226 	bl	8f6341b8 <memcpy>
	for (i = 15, j = 0; i >=0 ; i--, j++)
8f60b91c:	e28d10d4 	add	r1, r13, #212	; 0xd4
8f60b920:	e28d2094 	add	r2, r13, #148	; 0x94
8f60b924:	e1a00001 	mov	r0, r1
		sd_status[i] = swap_endian32(sd_status[j]);
8f60b928:	e5b23004 	ldr	r3, [r2, #4]!
	for (i = 15, j = 0; i >=0 ; i--, j++)
8f60b92c:	e1520000 	cmp	r2, r0
8f60b930:	e6bf3f33 	rev	r3, r3
		sd_status[i] = swap_endian32(sd_status[j]);
8f60b934:	e4013004 	str	r3, [r1], #-4
	for (i = 15, j = 0; i >=0 ; i--, j++)
8f60b938:	1afffffa 	bne	8f60b928 <mmc_init+0x1044>
	au_size = UNPACK_BITS(status, MMC_SD_AU_SIZE_BIT, MMC_SD_AU_SIZE_LEN, 32);
8f60b93c:	e59d30cc 	ldr	r3, [r13, #204]	; 0xcc
	card->ssr.num_aus = UNPACK_BITS(status, MMC_SD_ERASE_SIZE_BIT, MMC_SD_ERASE_SIZE_LEN, 32);
8f60b940:	e5dd20cb 	ldrb	r2, [r13, #203]	; 0xcb
8f60b944:	e1822403 	orr	r2, r2, r3, lsl #8
	card->ssr.au_size = 1 << (au_size + 4);
8f60b948:	e7e33653 	ubfx	r3, r3, #12, #4
8f60b94c:	e2833004 	add	r3, r3, #4
8f60b950:	e6ff2072 	uxth	r2, r2
	card->ssr.num_aus = UNPACK_BITS(status, MMC_SD_ERASE_SIZE_BIT, MMC_SD_ERASE_SIZE_LEN, 32);
8f60b954:	e58420f0 	str	r2, [r4, #240]	; 0xf0
	if (!card->ssr.num_aus)
8f60b958:	e3520000 	cmp	r2, #0
	card->ssr.au_size = 1 << (au_size + 4);
8f60b95c:	e3a02001 	mov	r2, #1
8f60b960:	e1a03312 	lsl	r3, r2, r3
8f60b964:	e58430ec 	str	r3, [r4, #236]	; 0xec
		card->ssr.num_aus = 0x10;
8f60b968:	03a03010 	moveq	r3, #16
8f60b96c:	058430f0 	streq	r3, [r4, #240]	; 0xf0
8f60b970:	eafffdc7 	b	8f60b094 <mmc_init+0x7b0>
		dprintf(CRITICAL, "Failure selecting the Card with RCA: %x\n",card->rca);
8f60b974:	e5941038 	ldr	r1, [r4, #56]	; 0x38
8f60b978:	e30209c4 	movw	r0, #10692	; 0x29c4
8f60b97c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b980:	eb009bfb 	bl	8f632974 <_dprintf>
		return mmc_return;
8f60b984:	eafffc5a 	b	8f60aaf4 <mmc_init+0x210>
			dprintf(CRITICAL, "Failed to set bus width for the card\n");
8f60b988:	e3020d10 	movw	r0, #11536	; 0x2d10
8f60b98c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b990:	eb009bf7 	bl	8f632974 <_dprintf>
			return mmc_return;
8f60b994:	eafffc56 	b	8f60aaf4 <mmc_init+0x210>
		else if (host->caps.sdr104_support && mmc_card_supports_hs200_mode(card))
8f60b998:	e5d4302a 	ldrb	r3, [r4, #42]	; 0x2a
8f60b99c:	e3530000 	cmp	r3, #0
8f60b9a0:	0a000066 	beq	8f60bb40 <mmc_init+0x125c>
			dprintf(INFO, "SDHC Running in High Speed mode\n");
8f60b9a4:	e3020e40 	movw	r0, #11840	; 0x2e40
8f60b9a8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60b9ac:	eb009bf0 	bl	8f632974 <_dprintf>
	mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
8f60b9b0:	e3a09001 	mov	r9, #1
8f60b9b4:	e3a030b9 	mov	r3, #185	; 0xb9
8f60b9b8:	e3a02003 	mov	r2, #3
8f60b9bc:	e1a01006 	mov	r1, r6
8f60b9c0:	e1a00004 	mov	r0, r4
8f60b9c4:	e58d9000 	str	r9, [r13]
8f60b9c8:	ebfff8c4 	bl	8f609ce0 <mmc_switch_cmd>
	if (mmc_ret) {
8f60b9cc:	e2507000 	subs	r7, r0, #0
8f60b9d0:	1a000063 	bne	8f60bb64 <mmc_init+0x1280>
	sdhci_set_uhs_mode(host, SDHCI_SDR25_MODE);
8f60b9d4:	e1a01009 	mov	r1, r9
8f60b9d8:	e1a00004 	mov	r0, r4
	MMC_SAVE_TIMING(host, SDHCI_SDR25_MODE);
8f60b9dc:	e5849008 	str	r9, [r4, #8]
	sdhci_set_uhs_mode(host, SDHCI_SDR25_MODE);
8f60b9e0:	ebfff1b7 	bl	8f6080c4 <sdhci_set_uhs_mode>
	mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
8f60b9e4:	e3a030b7 	mov	r3, #183	; 0xb7
8f60b9e8:	e3a02003 	mov	r2, #3
8f60b9ec:	e1a01006 	mov	r1, r6
8f60b9f0:	e1a00004 	mov	r0, r4
			mmc_return = mmc_set_bus_width(host, card, bus_width);
8f60b9f4:	e58d8000 	str	r8, [r13]
	mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
8f60b9f8:	ebfff8b8 	bl	8f609ce0 <mmc_switch_cmd>
	if (mmc_ret) {
8f60b9fc:	e2507000 	subs	r7, r0, #0
8f60ba00:	0afffe65 	beq	8f60b39c <mmc_init+0xab8>
		dprintf(CRITICAL, "Switch cmd failed\n");
8f60ba04:	e3020574 	movw	r0, #9588	; 0x2574
8f60ba08:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60ba0c:	eb009bd8 	bl	8f632974 <_dprintf>
				dprintf(CRITICAL, "Failure to set wide bus for Card(RCA:%x)\n",
8f60ba10:	e5941038 	ldr	r1, [r4, #56]	; 0x38
8f60ba14:	e30205b4 	movw	r0, #9652	; 0x25b4
8f60ba18:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60ba1c:	eb009bd4 	bl	8f632974 <_dprintf>
				return mmc_return;
8f60ba20:	eafffc33 	b	8f60aaf4 <mmc_init+0x210>
			mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit])
8f60ba24:	e7e319d3 	ubfx	r1, r3, #19, #4
8f60ba28:	e30321e8 	movw	r2, #12776	; 0x31e8
8f60ba2c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60ba30:	e7e2e853 	ubfx	r14, r3, #16, #3
			mmc_csd.tran_speed = (xfer_rate_value[mmc_value] *
8f60ba34:	e7e301d3 	ubfx	r0, r3, #3, #4
								 xfer_rate_unit[mmc_unit]) / 10;
8f60ba38:	e203c007 	and	r12, r3, #7
			mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit])
8f60ba3c:	e7921101 	ldr	r1, [r2, r1, lsl #2]
8f60ba40:	e30321c8 	movw	r2, #12744	; 0x31c8
8f60ba44:	e3482f70 	movt	r2, #36720	; 0x8f70
			mmc_csd.nsac_clk_cycle = UNPACK_BITS(raw_csd, 104, 8, mmc_sizeof)
8f60ba48:	e7e73453 	ubfx	r3, r3, #8, #8
			mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit])
8f60ba4c:	e792210e 	ldr	r2, [r2, r14, lsl #2]
8f60ba50:	e0010192 	mul	r1, r2, r1
			mmc_csd.tran_speed = (xfer_rate_value[mmc_value] *
8f60ba54:	e3032248 	movw	r2, #12872	; 0x3248
8f60ba58:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60ba5c:	e7922100 	ldr	r2, [r2, r0, lsl #2]
								 xfer_rate_unit[mmc_unit]) / 10;
8f60ba60:	e3030228 	movw	r0, #12840	; 0x3228
8f60ba64:	e3480f70 	movt	r0, #36720	; 0x8f70
			mmc_csd.tran_speed = (xfer_rate_value[mmc_value] *
8f60ba68:	e790010c 	ldr	r0, [r0, r12, lsl #2]
8f60ba6c:	e0020290 	mul	r2, r0, r2
							   / 10;
8f60ba70:	e30c0ccd 	movw	r0, #52429	; 0xcccd
8f60ba74:	e34c0ccc 	movt	r0, #52428	; 0xcccc
8f60ba78:	e081c190 	umull	r12, r1, r0, r1
								 xfer_rate_unit[mmc_unit]) / 10;
8f60ba7c:	e0820290 	umull	r0, r2, r0, r2
							   / 10;
8f60ba80:	e1a011a1 	lsr	r1, r1, #3
			mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit])
8f60ba84:	e58d1038 	str	r1, [r13, #56]	; 0x38
			mmc_csd.nsac_clk_cycle = UNPACK_BITS(raw_csd, 104, 8, mmc_sizeof)
8f60ba88:	e3a01064 	mov	r1, #100	; 0x64
8f60ba8c:	e0030391 	mul	r3, r1, r3
								 xfer_rate_unit[mmc_unit]) / 10;
8f60ba90:	e1a021a2 	lsr	r2, r2, #3
			mmc_csd.tran_speed = (xfer_rate_value[mmc_value] *
8f60ba94:	e58d203c 	str	r2, [r13, #60]	; 0x3c
			mmc_csd.card_cmd_class = UNPACK_BITS(raw_csd, 84, 12, mmc_sizeof);
8f60ba98:	e5942064 	ldr	r2, [r4, #100]	; 0x64
			mmc_csd.perm_wp = UNPACK_BITS(raw_csd, 13, 1, mmc_sizeof);
8f60ba9c:	e594105c 	ldr	r1, [r4, #92]	; 0x5c
			mmc_csd.nsac_clk_cycle = UNPACK_BITS(raw_csd, 104, 8, mmc_sizeof)
8f60baa0:	e58d3034 	str	r3, [r13, #52]	; 0x34
			mmc_csd.c_size  = UNPACK_BITS(raw_csd, 48, 22, mmc_sizeof);
8f60baa4:	e1d436b2 	ldrh	r3, [r4, #98]	; 0x62
8f60baa8:	e1833802 	orr	r3, r3, r2, lsl #16
			mmc_csd.card_cmd_class = UNPACK_BITS(raw_csd, 84, 12, mmc_sizeof);
8f60baac:	e1a02a22 	lsr	r2, r2, #20
8f60bab0:	e58d2018 	str	r2, [r13, #24]
			mmc_csd.wp_grp_enable = 0x0;
8f60bab4:	e7e026d1 	ubfx	r2, r1, #13, #1
8f60bab8:	e7f53053 	ubfx	r3, r3, #0, #22
8f60babc:	e7e01651 	ubfx	r1, r1, #12, #1
8f60bac0:	e1a02082 	lsl	r2, r2, #1
			mmc_csd.c_size  = UNPACK_BITS(raw_csd, 48, 22, mmc_sizeof);
8f60bac4:	e58d3030 	str	r3, [r13, #48]	; 0x30
			card->capacity = (unsigned long long) (1 + mmc_csd.c_size) * 512 * 1024;
8f60bac8:	e2833001 	add	r3, r3, #1
			mmc_csd.wp_grp_enable = 0x0;
8f60bacc:	e3822008 	orr	r2, r2, #8
8f60bad0:	e1822101 	orr	r2, r2, r1, lsl #2
8f60bad4:	e5cd204c 	strb	r2, [r13, #76]	; 0x4c
			mmc_csd.write_blk_len = 512;
8f60bad8:	e3a02c02 	mov	r2, #512	; 0x200
8f60badc:	e58d201c 	str	r2, [r13, #28]
			mmc_csd.read_blk_len = 512;
8f60bae0:	e58d2020 	str	r2, [r13, #32]
			mmc_csd.c_size_mult = 0;
8f60bae4:	e3a02000 	mov	r2, #0
8f60bae8:	e58d202c 	str	r2, [r13, #44]	; 0x2c
			mmc_csd.wp_grp_size = 0x0;
8f60baec:	e58d2048 	str	r2, [r13, #72]	; 0x48
			card->capacity = (unsigned long long) (1 + mmc_csd.c_size) * 512 * 1024;
8f60baf0:	e1a026a3 	lsr	r2, r3, #13
8f60baf4:	e1a03983 	lsl	r3, r3, #19
8f60baf8:	e584204c 	str	r2, [r4, #76]	; 0x4c
8f60bafc:	e5843048 	str	r3, [r4, #72]	; 0x48
			mmc_csd.r2w_factor = 0x2;
8f60bb00:	e3a03002 	mov	r3, #2
8f60bb04:	e58d3024 	str	r3, [r13, #36]	; 0x24
			card->capacity = (unsigned long long) (1 + mmc_csd.c_size) * 512 * 1024;
8f60bb08:	eafffdb3 	b	8f60b1dc <mmc_init+0x8f8>
				dprintf(CRITICAL, "Failure getting card's ExtCSD information!\n");
8f60bb0c:	e3020a34 	movw	r0, #10804	; 0x2a34
8f60bb10:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60bb14:	eb009b96 	bl	8f632974 <_dprintf>
				return mmc_return;
8f60bb18:	eafffbf5 	b	8f60aaf4 <mmc_init+0x210>
			dprintf(CRITICAL, "Failed to set bus width for host controller\n");
8f60bb1c:	e3020c34 	movw	r0, #11316	; 0x2c34
8f60bb20:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60bb24:	eb009b92 	bl	8f632974 <_dprintf>
			return mmc_return;
8f60bb28:	eafffd0a 	b	8f60af58 <mmc_init+0x674>
		if (cfg->bus_width == DATA_BUS_WIDTH_8BIT && host->caps.bus_width_8bit)
8f60bb2c:	e5d48024 	ldrb	r8, [r4, #36]	; 0x24
8f60bb30:	e3580000 	cmp	r8, #0
8f60bb34:	01a01008 	moveq	r1, r8
				bus_width = DATA_BUS_WIDTH_8BIT;
8f60bb38:	11a08001 	movne	r8, r1
8f60bb3c:	eaffff1c 	b	8f60b7b4 <mmc_init+0xed0>
		} else if (host->caps.ddr_support && mmc_card_supports_ddr_mode(card)) {
8f60bb40:	e5d43028 	ldrb	r3, [r4, #40]	; 0x28
8f60bb44:	e3530000 	cmp	r3, #0
8f60bb48:	0affff95 	beq	8f60b9a4 <mmc_init+0x10c0>
	if (MMC_CARD_MMC(card)) {
8f60bb4c:	e5943050 	ldr	r3, [r4, #80]	; 0x50
8f60bb50:	e2433003 	sub	r3, r3, #3
8f60bb54:	e3530001 	cmp	r3, #1
8f60bb58:	8affff91 	bhi	8f60b9a4 <mmc_init+0x10c0>
8f60bb5c:	e5942058 	ldr	r2, [r4, #88]	; 0x58
8f60bb60:	eaffff28 	b	8f60b808 <mmc_init+0xf24>
		dprintf(CRITICAL, "Switch cmd returned failure %d\n", __LINE__);
8f60bb64:	e3a01e3e 	mov	r1, #992	; 0x3e0
8f60bb68:	e30205e0 	movw	r0, #9696	; 0x25e0
8f60bb6c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60bb70:	eb009b7f 	bl	8f632974 <_dprintf>
				dprintf(CRITICAL, "Failure to enalbe HS mode for Card(RCA:%x)\n",
8f60bb74:	e5941038 	ldr	r1, [r4, #56]	; 0x38
8f60bb78:	e3020e14 	movw	r0, #11796	; 0x2e14
8f60bb7c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60bb80:	eb009b7b 	bl	8f632974 <_dprintf>
				return mmc_return;
8f60bb84:	eafffbda 	b	8f60aaf4 <mmc_init+0x210>
			dprintf(INFO, "SDHC Running in HS400 mode\n");
8f60bb88:	e3020c64 	movw	r0, #11364	; 0x2c64
8f60bb8c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60bb90:	eb009b77 	bl	8f632974 <_dprintf>
			mmc_return = mmc_set_hs400_mode(host, card, bus_width);
8f60bb94:	e1a02008 	mov	r2, r8
8f60bb98:	e1a01006 	mov	r1, r6
8f60bb9c:	e1a00004 	mov	r0, r4
8f60bba0:	ebfff9f9 	bl	8f60a38c <mmc_set_hs400_mode>
			if (mmc_return)
8f60bba4:	e2507000 	subs	r7, r0, #0
8f60bba8:	0afffdfb 	beq	8f60b39c <mmc_init+0xab8>
				dprintf(CRITICAL, "Failure to set HS400 mode for Card(RCA:%x)\n",
8f60bbac:	e5941038 	ldr	r1, [r4, #56]	; 0x38
8f60bbb0:	e3020c80 	movw	r0, #11392	; 0x2c80
8f60bbb4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60bbb8:	eb009b6d 	bl	8f632974 <_dprintf>
				return mmc_return;
8f60bbbc:	eafffbcc 	b	8f60aaf4 <mmc_init+0x210>
		} else if (host->caps.ddr_support && mmc_card_supports_ddr_mode(card)) {
8f60bbc0:	e5d42028 	ldrb	r2, [r4, #40]	; 0x28
8f60bbc4:	e3520000 	cmp	r2, #0
8f60bbc8:	1affff0f 	bne	8f60b80c <mmc_init+0xf28>
8f60bbcc:	eaffff74 	b	8f60b9a4 <mmc_init+0x10c0>
}
8f60bbd0:	eb009bfa 	bl	8f632bc0 <__stack_chk_fail>
		dprintf(CRITICAL, "Error allocating mmc device\n");
8f60bbd4:	e30207c8 	movw	r0, #10184	; 0x27c8
8f60bbd8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60bbdc:	eb009b64 	bl	8f632974 <_dprintf>
		return NULL;
8f60bbe0:	eafffc04 	b	8f60abf8 <mmc_init+0x314>

8f60bbe4 <mmc_sdhci_read>:
 * Return  : 0 on Success, non zero on success
 * Flow    : Fill in the command structure & send the command
 */
uint32_t mmc_sdhci_read(struct mmc_device *dev, void *dest,
						uint64_t blk_addr, uint32_t num_blocks)
{
8f60bbe4:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f60bbe8:	e24dd054 	sub	r13, r13, #84	; 0x54
8f60bbec:	e59f30e4 	ldr	r3, [pc, #228]	; 8f60bcd8 <mmc_sdhci_read+0xf4>
8f60bbf0:	e1a04000 	mov	r4, r0
8f60bbf4:	e1a06001 	mov	r6, r1
8f60bbf8:	e1a07002 	mov	r7, r2
	uint32_t mmc_ret = 0;
	struct mmc_command cmd;
	struct mmc_card *card = &dev->card;

	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60bbfc:	e3a01000 	mov	r1, #0
8f60bc00:	e3a02048 	mov	r2, #72	; 0x48
8f60bc04:	e1a0000d 	mov	r0, r13
{
8f60bc08:	e59d5068 	ldr	r5, [r13, #104]	; 0x68
8f60bc0c:	e5933000 	ldr	r3, [r3]
8f60bc10:	e58d304c 	str	r3, [r13, #76]	; 0x4c
8f60bc14:	e3a03000 	mov	r3, #0
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60bc18:	eb00a1a9 	bl	8f6342c4 <memset>

	/* CMD17/18 Format:
	 * [31:0] Data Address
	 */
	if (num_blocks == 1)
		cmd.cmd_index = CMD17_READ_SINGLE_BLOCK;
8f60bc1c:	e3550001 	cmp	r5, #1
	/*
	 * Standard emmc cards use byte mode addressing
	 * convert the block address to byte address before
	 * sending the command
	 */
	if (card->type == MMC_TYPE_STD_MMC)
8f60bc20:	e5943050 	ldr	r3, [r4, #80]	; 0x50
		cmd.cmd_index = CMD17_READ_SINGLE_BLOCK;
8f60bc24:	13a02012 	movne	r2, #18
8f60bc28:	03a02011 	moveq	r2, #17
	if (card->type == MMC_TYPE_STD_MMC)
8f60bc2c:	e3530004 	cmp	r3, #4
8f60bc30:	e1cd20b0 	strh	r2, [r13]
8f60bc34:	0a00001a 	beq	8f60bca4 <mmc_sdhci_read+0xc0>
	 * For emmc by default use CMD23.
	 * Also as per SDCC spec always use CMD23 to stop
	 * multiblock read/write if UHS (Ultra High Speed) is
	 * enabled
	 */
	if (MMC_CARD_SD(card))
8f60bc38:	e3530001 	cmp	r3, #1
	cmd.trans_mode = SDHCI_MMC_READ;
8f60bc3c:	e3a03001 	mov	r3, #1
	cmd.data_present = 0x1;
8f60bc40:	e1a02003 	mov	r2, r3
	cmd.trans_mode = SDHCI_MMC_READ;
8f60bc44:	e58d301c 	str	r3, [r13, #28]
		cmd.cmd23_support = dev->card.scr.cmd23_support;
8f60bc48:	959430e8 	ldrls	r3, [r4, #232]	; 0xe8
	cmd.data_present = 0x1;
8f60bc4c:	e3402001 	movt	r2, #1
		cmd.argument = blk_addr;
8f60bc50:	e58d7004 	str	r7, [r13, #4]
	cmd.data_present = 0x1;
8f60bc54:	e58d2008 	str	r2, [r13, #8]

	cmd.data.data_ptr = dest;
	cmd.data.num_blocks = num_blocks;

	/* send command */
	mmc_ret = sdhci_send_command(&dev->host, &cmd);
8f60bc58:	e1a0100d 	mov	r1, r13
8f60bc5c:	e1a00004 	mov	r0, r4
8f60bc60:	e58d3024 	str	r3, [r13, #36]	; 0x24
	cmd.data.data_ptr = dest;
8f60bc64:	e58d6034 	str	r6, [r13, #52]	; 0x34
	cmd.data.num_blocks = num_blocks;
8f60bc68:	e58d503c 	str	r5, [r13, #60]	; 0x3c
	mmc_ret = sdhci_send_command(&dev->host, &cmd);
8f60bc6c:	ebfff17e 	bl	8f60826c <sdhci_send_command>

	/* For multi block read failures send stop command */
	if (mmc_ret && num_blocks > 1)
8f60bc70:	e3500000 	cmp	r0, #0
8f60bc74:	13550001 	cmpne	r5, #1
8f60bc78:	8a000012 	bhi	8f60bcc8 <mmc_sdhci_read+0xe4>

	/*
	 * Response contains 32 bit Card status.
	 * Parse the errors & provide relevant information
	 */
	return mmc_parse_response(cmd.resp[0]);
8f60bc7c:	e59d000c 	ldr	r0, [r13, #12]
8f60bc80:	ebfff8a8 	bl	8f609f28 <mmc_parse_response>
}
8f60bc84:	e59f304c 	ldr	r3, [pc, #76]	; 8f60bcd8 <mmc_sdhci_read+0xf4>
8f60bc88:	e5932000 	ldr	r2, [r3]
8f60bc8c:	e59d304c 	ldr	r3, [r13, #76]	; 0x4c
8f60bc90:	e0332002 	eors	r2, r3, r2
8f60bc94:	e3a03000 	mov	r3, #0
8f60bc98:	1a00000d 	bne	8f60bcd4 <mmc_sdhci_read+0xf0>
8f60bc9c:	e28dd054 	add	r13, r13, #84	; 0x54
8f60bca0:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		cmd.argument = blk_addr * card->block_size;
8f60bca4:	e5942040 	ldr	r2, [r4, #64]	; 0x40
	cmd.trans_mode = SDHCI_MMC_READ;
8f60bca8:	e3a03001 	mov	r3, #1
8f60bcac:	e58d301c 	str	r3, [r13, #28]
		cmd.argument = blk_addr * card->block_size;
8f60bcb0:	e0070297 	mul	r7, r7, r2
	cmd.data_present = 0x1;
8f60bcb4:	e1a02003 	mov	r2, r3
8f60bcb8:	e3402001 	movt	r2, #1
8f60bcbc:	e58d2008 	str	r2, [r13, #8]
		cmd.argument = blk_addr * card->block_size;
8f60bcc0:	e58d7004 	str	r7, [r13, #4]
	if (MMC_CARD_SD(card))
8f60bcc4:	eaffffe3 	b	8f60bc58 <mmc_sdhci_read+0x74>
		return mmc_stop_command(dev);
8f60bcc8:	e1a00004 	mov	r0, r4
8f60bccc:	ebfff8d7 	bl	8f60a030 <mmc_stop_command>
8f60bcd0:	eaffffeb 	b	8f60bc84 <mmc_sdhci_read+0xa0>
}
8f60bcd4:	eb009bb9 	bl	8f632bc0 <__stack_chk_fail>
8f60bcd8:	8f74221c 	.word	0x8f74221c

8f60bcdc <mmc_sdhci_bdev_read_block>:
{
8f60bcdc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f60bce0:	e1a05001 	mov	r5, r1
	uint32_t block_size = bdev->dev.block_size;
8f60bce4:	e5908018 	ldr	r8, [r0, #24]
{
8f60bce8:	e24dd01c 	sub	r13, r13, #28
8f60bcec:	e59f1134 	ldr	r1, [pc, #308]	; 8f60be28 <mmc_sdhci_bdev_read_block+0x14c>
8f60bcf0:	e1a0a000 	mov	r10, r0
	while (data_len > read_size) {
8f60bcf4:	e3a09cfe 	mov	r9, #65024	; 0xfe00
	arch_clean_invalidate_cache_range((addr_t)(sptr), data_len);
8f60bcf8:	e1a00005 	mov	r0, r5
	uint32_t data_len = count * block_size;
8f60bcfc:	e0060893 	mul	r6, r3, r8
{
8f60bd00:	e5911000 	ldr	r1, [r1]
8f60bd04:	e58d1014 	str	r1, [r13, #20]
8f60bd08:	e3a01000 	mov	r1, #0
	while (data_len > read_size) {
8f60bd0c:	e34091ff 	movt	r9, #511	; 0x1ff
	uint64_t data_addr = (uint64_t)((uint64_t)block * block_size);
8f60bd10:	e0874892 	umull	r4, r7, r2, r8
	arch_clean_invalidate_cache_range((addr_t)(sptr), data_len);
8f60bd14:	e1a01006 	mov	r1, r6
	uint32_t data_len = count * block_size;
8f60bd18:	e58d600c 	str	r6, [r13, #12]
	arch_clean_invalidate_cache_range((addr_t)(sptr), data_len);
8f60bd1c:	eb00549f 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	while (data_len > read_size) {
8f60bd20:	e1560009 	cmp	r6, r9
8f60bd24:	9a000024 	bls	8f60bdbc <mmc_sdhci_bdev_read_block+0xe0>
		ret = mmc_sdhci_read(bdev->mmcdev, (void *)sptr, (data_addr / block_size), (read_size / block_size));
8f60bd28:	e1a01008 	mov	r1, r8
8f60bd2c:	e1a00009 	mov	r0, r9
8f60bd30:	fa00c3a8 	blx	8f63cbd8 <__udivsi3>
8f60bd34:	e1a0b000 	mov	r11, r0
8f60bd38:	ea000009 	b	8f60bd64 <mmc_sdhci_bdev_read_block+0x88>
		data_len -= read_size;
8f60bd3c:	e28664fe 	add	r6, r6, #-33554432	; 0xfe000000
		data_addr += read_size;
8f60bd40:	e3a03cfe 	mov	r3, #65024	; 0xfe00
8f60bd44:	e34031ff 	movt	r3, #511	; 0x1ff
		data_len -= read_size;
8f60bd48:	e2866c02 	add	r6, r6, #512	; 0x200
		data_addr += read_size;
8f60bd4c:	e0944003 	adds	r4, r4, r3
		sptr += read_size;
8f60bd50:	e2855402 	add	r5, r5, #33554432	; 0x2000000
		data_addr += read_size;
8f60bd54:	e2a77000 	adc	r7, r7, #0
	while (data_len > read_size) {
8f60bd58:	e1560009 	cmp	r6, r9
		sptr += read_size;
8f60bd5c:	e2455c02 	sub	r5, r5, #512	; 0x200
	while (data_len > read_size) {
8f60bd60:	9a00001b 	bls	8f60bdd4 <mmc_sdhci_bdev_read_block+0xf8>
		ret = mmc_sdhci_read(bdev->mmcdev, (void *)sptr, (data_addr / block_size), (read_size / block_size));
8f60bd64:	e1a02008 	mov	r2, r8
8f60bd68:	e3a03000 	mov	r3, #0
8f60bd6c:	e1a00004 	mov	r0, r4
8f60bd70:	e1a01007 	mov	r1, r7
8f60bd74:	fa00c50a 	blx	8f63d1a4 <__aeabi_uldivmod>
8f60bd78:	e58db000 	str	r11, [r13]
8f60bd7c:	e1a02000 	mov	r2, r0
8f60bd80:	e1a03001 	mov	r3, r1
8f60bd84:	e59a0048 	ldr	r0, [r10, #72]	; 0x48
8f60bd88:	e1a01005 	mov	r1, r5
8f60bd8c:	ebffff94 	bl	8f60bbe4 <mmc_sdhci_read>
		if (ret)
8f60bd90:	e3500000 	cmp	r0, #0
8f60bd94:	0affffe8 	beq	8f60bd3c <mmc_sdhci_bdev_read_block+0x60>
			return ERR_IO;
8f60bd98:	e3e00013 	mvn	r0, #19
}
8f60bd9c:	e59f3084 	ldr	r3, [pc, #132]	; 8f60be28 <mmc_sdhci_bdev_read_block+0x14c>
8f60bda0:	e5932000 	ldr	r2, [r3]
8f60bda4:	e59d3014 	ldr	r3, [r13, #20]
8f60bda8:	e0332002 	eors	r2, r3, r2
8f60bdac:	e3a03000 	mov	r3, #0
8f60bdb0:	1a00001b 	bne	8f60be24 <mmc_sdhci_bdev_read_block+0x148>
8f60bdb4:	e28dd01c 	add	r13, r13, #28
8f60bdb8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	if (data_len)
8f60bdbc:	e59d300c 	ldr	r3, [r13, #12]
8f60bdc0:	e3530000 	cmp	r3, #0
8f60bdc4:	1a000001 	bne	8f60bdd0 <mmc_sdhci_bdev_read_block+0xf4>
		return count * block_size;
8f60bdc8:	e59d000c 	ldr	r0, [r13, #12]
8f60bdcc:	eafffff2 	b	8f60bd9c <mmc_sdhci_bdev_read_block+0xc0>
8f60bdd0:	e59d600c 	ldr	r6, [r13, #12]
		ret = mmc_sdhci_read(bdev->mmcdev, (void *)sptr, (data_addr / block_size), (data_len / block_size));
8f60bdd4:	e1a02008 	mov	r2, r8
8f60bdd8:	e3a03000 	mov	r3, #0
8f60bddc:	e1a00004 	mov	r0, r4
8f60bde0:	e1a01007 	mov	r1, r7
8f60bde4:	fa00c4ee 	blx	8f63d1a4 <__aeabi_uldivmod>
8f60bde8:	e59a9048 	ldr	r9, [r10, #72]	; 0x48
8f60bdec:	e1a07000 	mov	r7, r0
8f60bdf0:	e1a04001 	mov	r4, r1
8f60bdf4:	e1a00006 	mov	r0, r6
8f60bdf8:	e1a01008 	mov	r1, r8
8f60bdfc:	fa00c375 	blx	8f63cbd8 <__udivsi3>
8f60be00:	e1a02007 	mov	r2, r7
8f60be04:	e1a03004 	mov	r3, r4
8f60be08:	e1a01005 	mov	r1, r5
8f60be0c:	e58d0000 	str	r0, [r13]
8f60be10:	e1a00009 	mov	r0, r9
8f60be14:	ebffff72 	bl	8f60bbe4 <mmc_sdhci_read>
	if (ret)
8f60be18:	e3500000 	cmp	r0, #0
8f60be1c:	0affffe9 	beq	8f60bdc8 <mmc_sdhci_bdev_read_block+0xec>
8f60be20:	eaffffdc 	b	8f60bd98 <mmc_sdhci_bdev_read_block+0xbc>
}
8f60be24:	eb009b65 	bl	8f632bc0 <__stack_chk_fail>
8f60be28:	8f74221c 	.word	0x8f74221c

8f60be2c <mmc_sdhci_write>:
 * Return  : 0 on Success, non zero on success
 * Flow    : Fill in the command structure & send the command
 */
uint32_t mmc_sdhci_write(struct mmc_device *dev, void *src,
						 uint64_t blk_addr, uint32_t num_blocks)
{
8f60be2c:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f60be30:	e24dd054 	sub	r13, r13, #84	; 0x54
8f60be34:	e59f30ec 	ldr	r3, [pc, #236]	; 8f60bf28 <mmc_sdhci_write+0xfc>
8f60be38:	e1a04000 	mov	r4, r0
8f60be3c:	e1a06001 	mov	r6, r1
8f60be40:	e1a07002 	mov	r7, r2
	uint32_t mmc_ret = 0;
	struct mmc_command cmd;
	struct mmc_card *card = &dev->card;

	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60be44:	e3a01000 	mov	r1, #0
8f60be48:	e3a02048 	mov	r2, #72	; 0x48
8f60be4c:	e1a0000d 	mov	r0, r13
{
8f60be50:	e59d5068 	ldr	r5, [r13, #104]	; 0x68
8f60be54:	e5933000 	ldr	r3, [r3]
8f60be58:	e58d304c 	str	r3, [r13, #76]	; 0x4c
8f60be5c:	e3a03000 	mov	r3, #0
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60be60:	eb00a117 	bl	8f6342c4 <memset>
	/* CMD24/25 Format:
	 * [31:0] Data Address
	 */

	if (num_blocks == 1)
		cmd.cmd_index = CMD24_WRITE_SINGLE_BLOCK;
8f60be64:	e3550001 	cmp	r5, #1
	/*
	 * Standard emmc cards use byte mode addressing
	 * convert the block address to byte address before
	 * sending the command
	 */
	if (card->type == MMC_TYPE_STD_MMC)
8f60be68:	e5943050 	ldr	r3, [r4, #80]	; 0x50
		cmd.cmd_index = CMD24_WRITE_SINGLE_BLOCK;
8f60be6c:	13a02019 	movne	r2, #25
8f60be70:	03a02018 	moveq	r2, #24
	if (card->type == MMC_TYPE_STD_MMC)
8f60be74:	e3530004 	cmp	r3, #4
8f60be78:	e1cd20b0 	strh	r2, [r13]
8f60be7c:	0a00001c 	beq	8f60bef4 <mmc_sdhci_write+0xc8>
	 * For emmc by default use CMD23.
	 * Also as per SDCC spec always use CMD23 to stop
	 * multiblock read/write if UHS (Ultra High Speed) is
	 * enabled
	 */
	if (MMC_CARD_SD(card))
8f60be80:	e3530001 	cmp	r3, #1
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60be84:	e3a03000 	mov	r3, #0
8f60be88:	e5cd3009 	strb	r3, [r13, #9]
	cmd.trans_mode = SDHCI_MMC_WRITE;
8f60be8c:	e58d301c 	str	r3, [r13, #28]
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60be90:	e3a03001 	mov	r3, #1
8f60be94:	e1cd30ba 	strh	r3, [r13, #10]
		cmd.cmd23_support = dev->card.scr.cmd23_support;
8f60be98:	959430e8 	ldrls	r3, [r4, #232]	; 0xe8
		cmd.argument = blk_addr;
8f60be9c:	e58d7004 	str	r7, [r13, #4]
	cmd.data_present = 0x1;
	cmd.data.data_ptr = src;
	cmd.data.num_blocks = num_blocks;

	/* send command */
	mmc_ret = sdhci_send_command(&dev->host, &cmd);
8f60bea0:	e1a0100d 	mov	r1, r13
8f60bea4:	e1a00004 	mov	r0, r4
8f60bea8:	e58d3024 	str	r3, [r13, #36]	; 0x24
	cmd.data_present = 0x1;
8f60beac:	e3a03001 	mov	r3, #1
	cmd.data.data_ptr = src;
8f60beb0:	e58d6034 	str	r6, [r13, #52]	; 0x34
	cmd.data_present = 0x1;
8f60beb4:	e5cd3008 	strb	r3, [r13, #8]
	cmd.data.num_blocks = num_blocks;
8f60beb8:	e58d503c 	str	r5, [r13, #60]	; 0x3c
	mmc_ret = sdhci_send_command(&dev->host, &cmd);
8f60bebc:	ebfff0ea 	bl	8f60826c <sdhci_send_command>

	/* For multi block write failures send stop command */
	if (mmc_ret && num_blocks > 1)
8f60bec0:	e3500000 	cmp	r0, #0
8f60bec4:	13550001 	cmpne	r5, #1
8f60bec8:	8a000012 	bhi	8f60bf18 <mmc_sdhci_write+0xec>

	/*
	 * Response contains 32 bit Card status.
	 * Parse the errors & provide relevant information
	 */
	return mmc_parse_response(cmd.resp[0]);
8f60becc:	e59d000c 	ldr	r0, [r13, #12]
8f60bed0:	ebfff814 	bl	8f609f28 <mmc_parse_response>
}
8f60bed4:	e59f304c 	ldr	r3, [pc, #76]	; 8f60bf28 <mmc_sdhci_write+0xfc>
8f60bed8:	e5932000 	ldr	r2, [r3]
8f60bedc:	e59d304c 	ldr	r3, [r13, #76]	; 0x4c
8f60bee0:	e0332002 	eors	r2, r3, r2
8f60bee4:	e3a03000 	mov	r3, #0
8f60bee8:	1a00000d 	bne	8f60bf24 <mmc_sdhci_write+0xf8>
8f60beec:	e28dd054 	add	r13, r13, #84	; 0x54
8f60bef0:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		cmd.argument = blk_addr * card->block_size;
8f60bef4:	e5942040 	ldr	r2, [r4, #64]	; 0x40
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60bef8:	e3a03000 	mov	r3, #0
8f60befc:	e5cd3009 	strb	r3, [r13, #9]
	cmd.trans_mode = SDHCI_MMC_WRITE;
8f60bf00:	e58d301c 	str	r3, [r13, #28]
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60bf04:	e3a03001 	mov	r3, #1
		cmd.argument = blk_addr * card->block_size;
8f60bf08:	e0070297 	mul	r7, r7, r2
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60bf0c:	e1cd30ba 	strh	r3, [r13, #10]
		cmd.argument = blk_addr * card->block_size;
8f60bf10:	e58d7004 	str	r7, [r13, #4]
	if (MMC_CARD_SD(card))
8f60bf14:	eaffffe1 	b	8f60bea0 <mmc_sdhci_write+0x74>
		return mmc_stop_command(dev);
8f60bf18:	e1a00004 	mov	r0, r4
8f60bf1c:	ebfff843 	bl	8f60a030 <mmc_stop_command>
8f60bf20:	eaffffeb 	b	8f60bed4 <mmc_sdhci_write+0xa8>
}
8f60bf24:	eb009b25 	bl	8f632bc0 <__stack_chk_fail>
8f60bf28:	8f74221c 	.word	0x8f74221c

8f60bf2c <mmc_sdhci_bdev_write_block>:
{
8f60bf2c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f60bf30:	e1a05001 	mov	r5, r1
	uint32_t block_size = bdev->dev.block_size;
8f60bf34:	e5908018 	ldr	r8, [r0, #24]
{
8f60bf38:	e24dd01c 	sub	r13, r13, #28
8f60bf3c:	e59f1134 	ldr	r1, [pc, #308]	; 8f60c078 <mmc_sdhci_bdev_write_block+0x14c>
8f60bf40:	e1a0a000 	mov	r10, r0
	while (data_len > write_size) {
8f60bf44:	e3a09cfe 	mov	r9, #65024	; 0xfe00
	arch_clean_invalidate_cache_range((addr_t)sptr, data_len);
8f60bf48:	e1a00005 	mov	r0, r5
	uint32_t data_len = count * block_size;
8f60bf4c:	e0060893 	mul	r6, r3, r8
{
8f60bf50:	e5911000 	ldr	r1, [r1]
8f60bf54:	e58d1014 	str	r1, [r13, #20]
8f60bf58:	e3a01000 	mov	r1, #0
	while (data_len > write_size) {
8f60bf5c:	e34091ff 	movt	r9, #511	; 0x1ff
	uint64_t data_addr = (uint64_t)((uint64_t)block * block_size);
8f60bf60:	e0874892 	umull	r4, r7, r2, r8
	arch_clean_invalidate_cache_range((addr_t)sptr, data_len);
8f60bf64:	e1a01006 	mov	r1, r6
	uint32_t data_len = count * block_size;
8f60bf68:	e58d600c 	str	r6, [r13, #12]
	arch_clean_invalidate_cache_range((addr_t)sptr, data_len);
8f60bf6c:	eb00540b 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	while (data_len > write_size) {
8f60bf70:	e1560009 	cmp	r6, r9
8f60bf74:	9a000024 	bls	8f60c00c <mmc_sdhci_bdev_write_block+0xe0>
		val = mmc_sdhci_write(bdev->mmcdev, (void *)sptr, (data_addr / block_size), (write_size / block_size));
8f60bf78:	e1a01008 	mov	r1, r8
8f60bf7c:	e1a00009 	mov	r0, r9
8f60bf80:	fa00c314 	blx	8f63cbd8 <__udivsi3>
8f60bf84:	e1a0b000 	mov	r11, r0
8f60bf88:	ea000009 	b	8f60bfb4 <mmc_sdhci_bdev_write_block+0x88>
		data_len -= write_size;
8f60bf8c:	e28664fe 	add	r6, r6, #-33554432	; 0xfe000000
		data_addr += write_size;
8f60bf90:	e3a03cfe 	mov	r3, #65024	; 0xfe00
8f60bf94:	e34031ff 	movt	r3, #511	; 0x1ff
		data_len -= write_size;
8f60bf98:	e2866c02 	add	r6, r6, #512	; 0x200
		data_addr += write_size;
8f60bf9c:	e0944003 	adds	r4, r4, r3
		sptr += write_size;
8f60bfa0:	e2855402 	add	r5, r5, #33554432	; 0x2000000
		data_addr += write_size;
8f60bfa4:	e2a77000 	adc	r7, r7, #0
	while (data_len > write_size) {
8f60bfa8:	e1560009 	cmp	r6, r9
		sptr += write_size;
8f60bfac:	e2455c02 	sub	r5, r5, #512	; 0x200
	while (data_len > write_size) {
8f60bfb0:	9a00001b 	bls	8f60c024 <mmc_sdhci_bdev_write_block+0xf8>
		val = mmc_sdhci_write(bdev->mmcdev, (void *)sptr, (data_addr / block_size), (write_size / block_size));
8f60bfb4:	e1a02008 	mov	r2, r8
8f60bfb8:	e3a03000 	mov	r3, #0
8f60bfbc:	e1a00004 	mov	r0, r4
8f60bfc0:	e1a01007 	mov	r1, r7
8f60bfc4:	fa00c476 	blx	8f63d1a4 <__aeabi_uldivmod>
8f60bfc8:	e58db000 	str	r11, [r13]
8f60bfcc:	e1a02000 	mov	r2, r0
8f60bfd0:	e1a03001 	mov	r3, r1
8f60bfd4:	e59a0048 	ldr	r0, [r10, #72]	; 0x48
8f60bfd8:	e1a01005 	mov	r1, r5
8f60bfdc:	ebffff92 	bl	8f60be2c <mmc_sdhci_write>
		if (val)
8f60bfe0:	e3500000 	cmp	r0, #0
8f60bfe4:	0affffe8 	beq	8f60bf8c <mmc_sdhci_bdev_write_block+0x60>
			return ERR_IO;
8f60bfe8:	e3e00013 	mvn	r0, #19
}
8f60bfec:	e59f3084 	ldr	r3, [pc, #132]	; 8f60c078 <mmc_sdhci_bdev_write_block+0x14c>
8f60bff0:	e5932000 	ldr	r2, [r3]
8f60bff4:	e59d3014 	ldr	r3, [r13, #20]
8f60bff8:	e0332002 	eors	r2, r3, r2
8f60bffc:	e3a03000 	mov	r3, #0
8f60c000:	1a00001b 	bne	8f60c074 <mmc_sdhci_bdev_write_block+0x148>
8f60c004:	e28dd01c 	add	r13, r13, #28
8f60c008:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	if (data_len)
8f60c00c:	e59d300c 	ldr	r3, [r13, #12]
8f60c010:	e3530000 	cmp	r3, #0
8f60c014:	1a000001 	bne	8f60c020 <mmc_sdhci_bdev_write_block+0xf4>
		return count * block_size;
8f60c018:	e59d000c 	ldr	r0, [r13, #12]
8f60c01c:	eafffff2 	b	8f60bfec <mmc_sdhci_bdev_write_block+0xc0>
8f60c020:	e59d600c 	ldr	r6, [r13, #12]
		val = mmc_sdhci_write(bdev->mmcdev, (void *)sptr, (data_addr / block_size), (data_len / block_size));
8f60c024:	e1a02008 	mov	r2, r8
8f60c028:	e3a03000 	mov	r3, #0
8f60c02c:	e1a00004 	mov	r0, r4
8f60c030:	e1a01007 	mov	r1, r7
8f60c034:	fa00c45a 	blx	8f63d1a4 <__aeabi_uldivmod>
8f60c038:	e59a9048 	ldr	r9, [r10, #72]	; 0x48
8f60c03c:	e1a07000 	mov	r7, r0
8f60c040:	e1a04001 	mov	r4, r1
8f60c044:	e1a00006 	mov	r0, r6
8f60c048:	e1a01008 	mov	r1, r8
8f60c04c:	fa00c2e1 	blx	8f63cbd8 <__udivsi3>
8f60c050:	e1a02007 	mov	r2, r7
8f60c054:	e1a03004 	mov	r3, r4
8f60c058:	e1a01005 	mov	r1, r5
8f60c05c:	e58d0000 	str	r0, [r13]
8f60c060:	e1a00009 	mov	r0, r9
8f60c064:	ebffff70 	bl	8f60be2c <mmc_sdhci_write>
	if (val)
8f60c068:	e3500000 	cmp	r0, #0
8f60c06c:	0affffe9 	beq	8f60c018 <mmc_sdhci_bdev_write_block+0xec>
8f60c070:	eaffffdc 	b	8f60bfe8 <mmc_sdhci_bdev_write_block+0xbc>
}
8f60c074:	eb009ad1 	bl	8f632bc0 <__stack_chk_fail>
8f60c078:	8f74221c 	.word	0x8f74221c

8f60c07c <mmc_sdhci_erase>:
 * Arg     : mmc device structure, block address and length
 * Return  : 0 on Success, non zero on failure
 * Flow    : Fill in the command structure & send the command
 */
uint32_t mmc_sdhci_erase(struct mmc_device *dev, uint32_t blk_addr, uint64_t len)
{
8f60c07c:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f60c080:	e1a06000 	mov	r6, r0
	/*
	 * Calculate the erase unit size,
	 * 1. Based on emmc 4.5 spec for emmc card
	 * 2. Use SD Card Status info for SD cards
	 */
	if (MMC_CARD_MMC(card))
8f60c084:	e5900050 	ldr	r0, [r0, #80]	; 0x50
{
8f60c088:	e1a05001 	mov	r5, r1
8f60c08c:	e59f1344 	ldr	r1, [pc, #836]	; 8f60c3d8 <mmc_sdhci_erase+0x35c>
8f60c090:	e24dd09c 	sub	r13, r13, #156	; 0x9c
	if (MMC_CARD_MMC(card))
8f60c094:	e2400003 	sub	r0, r0, #3
8f60c098:	e3500001 	cmp	r0, #1
{
8f60c09c:	e5911000 	ldr	r1, [r1]
8f60c0a0:	e58d1094 	str	r1, [r13, #148]	; 0x94
8f60c0a4:	e3a01000 	mov	r1, #0
	if (MMC_CARD_MMC(card))
8f60c0a8:	9a00009a 	bls	8f60c318 <mmc_sdhci_erase+0x29c>
			erase_unit_sz = (MMC_HC_ERASE_MULT * dev->card.ext_csd[MMC_HC_ERASE_GRP_SIZE]) / MMC_BLK_SZ;
		else
			erase_unit_sz = (dev->card.csd.erase_grp_size + 1) * (dev->card.csd.erase_grp_mult + 1);
	}
	else
		erase_unit_sz = dev->card.ssr.au_size * dev->card.ssr.num_aus;
8f60c0ac:	e59670ec 	ldr	r7, [r6, #236]	; 0xec
8f60c0b0:	e59610f0 	ldr	r1, [r6, #240]	; 0xf0
8f60c0b4:	e0070791 	mul	r7, r1, r7


	/* Convert length in blocks */
	len = len / MMC_BLK_SZ;
8f60c0b8:	e1a044a2 	lsr	r4, r2, #9
8f60c0bc:	e1844b83 	orr	r4, r4, r3, lsl #23
8f60c0c0:	e1a014a3 	lsr	r1, r3, #9

	if (len < erase_unit_sz)
8f60c0c4:	e1540007 	cmp	r4, r7
8f60c0c8:	e2d13000 	sbcs	r3, r1, #0
8f60c0cc:	3a0000a8 	bcc	8f60c374 <mmc_sdhci_erase+0x2f8>
		dprintf(CRITICAL, "Requested length is less than min erase group size\n");
		return 1;
	}

	/* Calculate erase groups based on the length in blocks */
	num_erase_grps = len / erase_unit_sz;
8f60c0d0:	e1a00004 	mov	r0, r4
8f60c0d4:	e1a02007 	mov	r2, r7
8f60c0d8:	e3a03000 	mov	r3, #0

	/* Last address of the erase range */
	erase_end = blk_addr + ((num_erase_grps - 1) * erase_unit_sz);

	/* Boundary check for overlap */
	blk_end = blk_addr + len;
8f60c0dc:	e0854004 	add	r4, r5, r4
	num_erase_grps = len / erase_unit_sz;
8f60c0e0:	fa00c42f 	blx	8f63d1a4 <__aeabi_uldivmod>
	erase_end = blk_addr + ((num_erase_grps - 1) * erase_unit_sz);
8f60c0e4:	e2409001 	sub	r9, r0, #1
	num_erase_grps = len / erase_unit_sz;
8f60c0e8:	e1a08000 	mov	r8, r0
	erase_end = blk_addr + ((num_erase_grps - 1) * erase_unit_sz);
8f60c0ec:	e0295997 	mla	r9, r7, r9, r5

	if (erase_end > blk_end)
8f60c0f0:	e1590004 	cmp	r9, r4
8f60c0f4:	8a000099 	bhi	8f60c360 <mmc_sdhci_erase+0x2e4>
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60c0f8:	e3a02048 	mov	r2, #72	; 0x48
8f60c0fc:	e3a01000 	mov	r1, #0
8f60c100:	e08d0002 	add	r0, r13, r2
8f60c104:	eb00a06e 	bl	8f6342c4 <memset>
	if (MMC_CARD_MMC(card))
8f60c108:	e5963050 	ldr	r3, [r6, #80]	; 0x50
8f60c10c:	e2432003 	sub	r2, r3, #3
8f60c110:	e3520001 	cmp	r2, #1
		cmd.cmd_index = CMD32_ERASE_WR_BLK_START;
8f60c114:	83a03020 	movhi	r3, #32
8f60c118:	81cd34b8 	strhhi	r3, [r13, #72]	; 0x48
	if (MMC_CARD_MMC(card))
8f60c11c:	9a000066 	bls	8f60c2bc <mmc_sdhci_erase+0x240>
	if (sdhci_send_command(&dev->host, &cmd))
8f60c120:	e28d1048 	add	r1, r13, #72	; 0x48
8f60c124:	e1a00006 	mov	r0, r6
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60c128:	e3a03000 	mov	r3, #0
8f60c12c:	e58d504c 	str	r5, [r13, #76]	; 0x4c
8f60c130:	e5cd3051 	strb	r3, [r13, #81]	; 0x51
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60c134:	e3a03001 	mov	r3, #1
8f60c138:	e1cd35b2 	strh	r3, [r13, #82]	; 0x52
	if (sdhci_send_command(&dev->host, &cmd))
8f60c13c:	ebfff04a 	bl	8f60826c <sdhci_send_command>
8f60c140:	e2501000 	subs	r1, r0, #0
8f60c144:	1a000080 	bne	8f60c34c <mmc_sdhci_erase+0x2d0>
	if (MMC_ADDR_OUT_OF_RANGE(cmd.resp[0]))
8f60c148:	e59d3054 	ldr	r3, [r13, #84]	; 0x54
8f60c14c:	e3530000 	cmp	r3, #0
8f60c150:	ba00007a 	blt	8f60c340 <mmc_sdhci_erase+0x2c4>
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60c154:	e3a02048 	mov	r2, #72	; 0x48
8f60c158:	e08d0002 	add	r0, r13, r2
8f60c15c:	eb00a058 	bl	8f6342c4 <memset>
	if (MMC_CARD_MMC(card))
8f60c160:	e5963050 	ldr	r3, [r6, #80]	; 0x50
8f60c164:	e2432003 	sub	r2, r3, #3
8f60c168:	e3520001 	cmp	r2, #1
		cmd.cmd_index = CMD33_ERASE_WR_BLK_END;
8f60c16c:	83a03021 	movhi	r3, #33	; 0x21
8f60c170:	81cd34b8 	strhhi	r3, [r13, #72]	; 0x48
	if (MMC_CARD_MMC(card))
8f60c174:	9a000056 	bls	8f60c2d4 <mmc_sdhci_erase+0x258>
	if (sdhci_send_command(&dev->host, &cmd))
8f60c178:	e28d1048 	add	r1, r13, #72	; 0x48
8f60c17c:	e1a00006 	mov	r0, r6
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60c180:	e3a03000 	mov	r3, #0
8f60c184:	e58d904c 	str	r9, [r13, #76]	; 0x4c
8f60c188:	e5cd3051 	strb	r3, [r13, #81]	; 0x51
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60c18c:	e3a03001 	mov	r3, #1
8f60c190:	e1cd35b2 	strh	r3, [r13, #82]	; 0x52
	if (sdhci_send_command(&dev->host, &cmd))
8f60c194:	ebfff034 	bl	8f60826c <sdhci_send_command>
8f60c198:	e2505000 	subs	r5, r0, #0
8f60c19c:	1a00007c 	bne	8f60c394 <mmc_sdhci_erase+0x318>
	if (MMC_ADDR_OUT_OF_RANGE(cmd.resp[0]))
8f60c1a0:	e59d3054 	ldr	r3, [r13, #84]	; 0x54
8f60c1a4:	e3530000 	cmp	r3, #0
8f60c1a8:	ba000076 	blt	8f60c388 <mmc_sdhci_erase+0x30c>

	/*
	 * As per emmc 4.5 spec section 7.4.27, calculate the erase timeout
	 * erase_timeout = 300ms * ERASE_TIMEOUT_MULT * num_erase_grps
	 */
	if (MMC_CARD_MMC(card))
8f60c1ac:	e5963050 	ldr	r3, [r6, #80]	; 0x50
8f60c1b0:	e2433003 	sub	r3, r3, #3
8f60c1b4:	e3530001 	cmp	r3, #1
8f60c1b8:	9a00007a 	bls	8f60c3a8 <mmc_sdhci_erase+0x32c>
		erase_timeout = (300 * 1000 * card->ext_csd[MMC_ERASE_TIMEOUT_MULT] * num_erase_grps);
	else
		erase_timeout = (300 * 1000 * num_erase_grps);
8f60c1bc:	e30943e0 	movw	r4, #37856	; 0x93e0
8f60c1c0:	e3404004 	movt	r4, #4
8f60c1c4:	e0040894 	mul	r4, r4, r8
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60c1c8:	e3a02048 	mov	r2, #72	; 0x48
8f60c1cc:	e3a01000 	mov	r1, #0
8f60c1d0:	e1a0000d 	mov	r0, r13
8f60c1d4:	eb00a03a 	bl	8f6342c4 <memset>
	if (sdhci_send_command(&dev->host, &cmd))
8f60c1d8:	e1a0100d 	mov	r1, r13
8f60c1dc:	e1a00006 	mov	r0, r6
	cmd.argument = 0x00000000;
8f60c1e0:	e3a03000 	mov	r3, #0
	cmd.cmd_timeout = erase_timeout;
8f60c1e4:	e58d4028 	str	r4, [r13, #40]	; 0x28
	cmd.argument = 0x00000000;
8f60c1e8:	e58d3004 	str	r3, [r13, #4]
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60c1ec:	e5cd3009 	strb	r3, [r13, #9]
	cmd.resp_type = SDHCI_CMD_RESP_R1B;
8f60c1f0:	e3a03002 	mov	r3, #2
	cmd.cmd_timeout = erase_timeout;
8f60c1f4:	e58d502c 	str	r5, [r13, #44]	; 0x2c
	cmd.resp_type = SDHCI_CMD_RESP_R1B;
8f60c1f8:	e1cd30ba 	strh	r3, [r13, #10]
	cmd.cmd_index = CMD38_ERASE;
8f60c1fc:	e3a03026 	mov	r3, #38	; 0x26
8f60c200:	e1cd30b0 	strh	r3, [r13]
	if (sdhci_send_command(&dev->host, &cmd))
8f60c204:	ebfff018 	bl	8f60826c <sdhci_send_command>
8f60c208:	e2508000 	subs	r8, r0, #0
8f60c20c:	1a000039 	bne	8f60c2f8 <mmc_sdhci_erase+0x27c>
			dprintf(CRITICAL, "Write Protect set for the region, only partial space was erased\n");
8f60c210:	e3029ff4 	movw	r9, #12276	; 0x2ff4
8f60c214:	e3489f70 	movt	r9, #36720	; 0x8f70
8f60c218:	e3027710 	movw	r7, #10000	; 0x2710
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60c21c:	e3a02048 	mov	r2, #72	; 0x48
8f60c220:	e3a01000 	mov	r1, #0
8f60c224:	e08d0002 	add	r0, r13, r2
8f60c228:	eb00a025 	bl	8f6342c4 <memset>
	cmd.argument = card->rca << 16;
8f60c22c:	e5963038 	ldr	r3, [r6, #56]	; 0x38
	mmc_ret = sdhci_send_command(host, &cmd);
8f60c230:	e28d1048 	add	r1, r13, #72	; 0x48
8f60c234:	e1a00006 	mov	r0, r6
	cmd.cmd_index = CMD13_SEND_STATUS;
8f60c238:	e3a0c00d 	mov	r12, #13
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60c23c:	e3a02001 	mov	r2, #1
	cmd.argument = card->rca << 16;
8f60c240:	e1a03803 	lsl	r3, r3, #16
	cmd.cmd_index = CMD13_SEND_STATUS;
8f60c244:	e1cdc4b8 	strh	r12, [r13, #72]	; 0x48
	cmd.argument = card->rca << 16;
8f60c248:	e58d304c 	str	r3, [r13, #76]	; 0x4c
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60c24c:	e5cd8051 	strb	r8, [r13, #81]	; 0x51
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60c250:	e1cd25b2 	strh	r2, [r13, #82]	; 0x52
	mmc_ret = sdhci_send_command(host, &cmd);
8f60c254:	ebfff004 	bl	8f60826c <sdhci_send_command>
	if (mmc_ret)
8f60c258:	e2505000 	subs	r5, r0, #0
8f60c25c:	1a000022 	bne	8f60c2ec <mmc_sdhci_erase+0x270>
	if ((cmd.resp[0] >> 31) & 0x01)
8f60c260:	e59d4054 	ldr	r4, [r13, #84]	; 0x54
8f60c264:	e3540000 	cmp	r4, #0
8f60c268:	ba00001f 	blt	8f60c2ec <mmc_sdhci_erase+0x270>
		if (status & MMC_R1_WP_ERASE_SKIP)
8f60c26c:	e3140902 	tst	r4, #32768	; 0x8000
8f60c270:	1a000025 	bne	8f60c30c <mmc_sdhci_erase+0x290>
		udelay(1000);
8f60c274:	e3a00ffa 	mov	r0, #1000	; 0x3e8
8f60c278:	eb000ab7 	bl	8f60ed5c <udelay>
		if (retry == MMC_MAX_CARD_STAT_RETRY)
8f60c27c:	e2577001 	subs	r7, r7, #1
8f60c280:	0a00004f 	beq	8f60c3c4 <mmc_sdhci_erase+0x348>
	} while(!(status & MMC_READY_FOR_DATA) || (MMC_CARD_STATUS(status) == MMC_PROG_STATE));
8f60c284:	e3140c01 	tst	r4, #256	; 0x100
8f60c288:	0affffe3 	beq	8f60c21c <mmc_sdhci_erase+0x1a0>
8f60c28c:	e7e344d4 	ubfx	r4, r4, #9, #4
8f60c290:	e3540007 	cmp	r4, #7
8f60c294:	0affffe0 	beq	8f60c21c <mmc_sdhci_erase+0x1a0>
		dprintf(CRITICAL, "Failed to erase the specified partition\n");
		return 1;
	}

	return 0;
}
8f60c298:	e59f3138 	ldr	r3, [pc, #312]	; 8f60c3d8 <mmc_sdhci_erase+0x35c>
8f60c29c:	e5932000 	ldr	r2, [r3]
8f60c2a0:	e59d3094 	ldr	r3, [r13, #148]	; 0x94
8f60c2a4:	e0332002 	eors	r2, r3, r2
8f60c2a8:	e3a03000 	mov	r3, #0
8f60c2ac:	1a000048 	bne	8f60c3d4 <mmc_sdhci_erase+0x358>
8f60c2b0:	e1a00005 	mov	r0, r5
8f60c2b4:	e28dd09c 	add	r13, r13, #156	; 0x9c
8f60c2b8:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
	if (card->type == MMC_TYPE_STD_MMC)
8f60c2bc:	e3530004 	cmp	r3, #4
		cmd.cmd_index = CMD35_ERASE_GROUP_START;
8f60c2c0:	e3a03023 	mov	r3, #35	; 0x23
8f60c2c4:	e1cd34b8 	strh	r3, [r13, #72]	; 0x48
		cmd.argument = erase_start * card->block_size;
8f60c2c8:	05963040 	ldreq	r3, [r6, #64]	; 0x40
8f60c2cc:	00050593 	muleq	r5, r3, r5
8f60c2d0:	eaffff92 	b	8f60c120 <mmc_sdhci_erase+0xa4>
	if (card->type == MMC_TYPE_STD_MMC)
8f60c2d4:	e3530004 	cmp	r3, #4
		cmd.cmd_index = CMD36_ERASE_GROUP_END;
8f60c2d8:	e3a03024 	mov	r3, #36	; 0x24
8f60c2dc:	e1cd34b8 	strh	r3, [r13, #72]	; 0x48
		cmd.argument = erase_end * card->block_size;
8f60c2e0:	05963040 	ldreq	r3, [r6, #64]	; 0x40
8f60c2e4:	00090993 	muleq	r9, r3, r9
8f60c2e8:	eaffffa2 	b	8f60c178 <mmc_sdhci_erase+0xfc>
			dprintf(CRITICAL, "Failed to get card status after erase\n");
8f60c2ec:	e3020fcc 	movw	r0, #12236	; 0x2fcc
8f60c2f0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c2f4:	eb00999e 	bl	8f632974 <_dprintf>
		dprintf(CRITICAL, "Failed to erase the specified partition\n");
8f60c2f8:	e3030074 	movw	r0, #12404	; 0x3074
8f60c2fc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c300:	eb00999b 	bl	8f632974 <_dprintf>
		return 1;
8f60c304:	e3a05001 	mov	r5, #1
8f60c308:	eaffffe2 	b	8f60c298 <mmc_sdhci_erase+0x21c>
			dprintf(CRITICAL, "Write Protect set for the region, only partial space was erased\n");
8f60c30c:	e1a00009 	mov	r0, r9
8f60c310:	eb009997 	bl	8f632974 <_dprintf>
8f60c314:	eaffffd6 	b	8f60c274 <mmc_sdhci_erase+0x1f8>
		if (dev->card.ext_csd[MMC_ERASE_GRP_DEF])
8f60c318:	e5961058 	ldr	r1, [r6, #88]	; 0x58
8f60c31c:	e5d100af 	ldrb	r0, [r1, #175]	; 0xaf
8f60c320:	e3500000 	cmp	r0, #0
			erase_unit_sz = (dev->card.csd.erase_grp_size + 1) * (dev->card.csd.erase_grp_mult + 1);
8f60c324:	059670d0 	ldreq	r7, [r6, #208]	; 0xd0
			erase_unit_sz = (MMC_HC_ERASE_MULT * dev->card.ext_csd[MMC_HC_ERASE_GRP_SIZE]) / MMC_BLK_SZ;
8f60c328:	15d170e0 	ldrbne	r7, [r1, #224]	; 0xe0
			erase_unit_sz = (dev->card.csd.erase_grp_size + 1) * (dev->card.csd.erase_grp_mult + 1);
8f60c32c:	059610cc 	ldreq	r1, [r6, #204]	; 0xcc
8f60c330:	02877001 	addeq	r7, r7, #1
			erase_unit_sz = (MMC_HC_ERASE_MULT * dev->card.ext_csd[MMC_HC_ERASE_GRP_SIZE]) / MMC_BLK_SZ;
8f60c334:	11a07507 	lslne	r7, r7, #10
			erase_unit_sz = (dev->card.csd.erase_grp_size + 1) * (dev->card.csd.erase_grp_mult + 1);
8f60c338:	00277791 	mlaeq	r7, r1, r7, r7
8f60c33c:	eaffff5d 	b	8f60c0b8 <mmc_sdhci_erase+0x3c>
		dprintf(CRITICAL, "Address for CMD35 is out of range\n");
8f60c340:	e3020f34 	movw	r0, #12084	; 0x2f34
8f60c344:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c348:	eb009989 	bl	8f632974 <_dprintf>
		dprintf(CRITICAL, "Failed to send erase grp start address\n");
8f60c34c:	e3020f58 	movw	r0, #12120	; 0x2f58
8f60c350:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c354:	eb009986 	bl	8f632974 <_dprintf>
		return 1;
8f60c358:	e3a05001 	mov	r5, #1
8f60c35c:	eaffffcd 	b	8f60c298 <mmc_sdhci_erase+0x21c>
		dprintf(CRITICAL, "The erase group overlaps the max requested for erase\n");
8f60c360:	e3020efc 	movw	r0, #12028	; 0x2efc
8f60c364:	e3480f70 	movt	r0, #36720	; 0x8f70
		erase_end -= erase_unit_sz;
8f60c368:	e0499007 	sub	r9, r9, r7
		dprintf(CRITICAL, "The erase group overlaps the max requested for erase\n");
8f60c36c:	eb009980 	bl	8f632974 <_dprintf>
		erase_end -= erase_unit_sz;
8f60c370:	eaffff60 	b	8f60c0f8 <mmc_sdhci_erase+0x7c>
		dprintf(CRITICAL, "Requested length is less than min erase group size\n");
8f60c374:	e3020ec8 	movw	r0, #11976	; 0x2ec8
8f60c378:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c37c:	eb00997c 	bl	8f632974 <_dprintf>
		return 1;
8f60c380:	e3a05001 	mov	r5, #1
8f60c384:	eaffffc3 	b	8f60c298 <mmc_sdhci_erase+0x21c>
		dprintf(CRITICAL, "Address for CMD36 is out of range\n");
8f60c388:	e3020f80 	movw	r0, #12160	; 0x2f80
8f60c38c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c390:	eb009977 	bl	8f632974 <_dprintf>
		dprintf(CRITICAL, "Failed to send erase grp end address\n");
8f60c394:	e3020fa4 	movw	r0, #12196	; 0x2fa4
8f60c398:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c39c:	eb009974 	bl	8f632974 <_dprintf>
		return 1;
8f60c3a0:	e3a05001 	mov	r5, #1
8f60c3a4:	eaffffbb 	b	8f60c298 <mmc_sdhci_erase+0x21c>
		erase_timeout = (300 * 1000 * card->ext_csd[MMC_ERASE_TIMEOUT_MULT] * num_erase_grps);
8f60c3a8:	e5963058 	ldr	r3, [r6, #88]	; 0x58
8f60c3ac:	e5d340df 	ldrb	r4, [r3, #223]	; 0xdf
8f60c3b0:	e0080498 	mul	r8, r8, r4
8f60c3b4:	e30943e0 	movw	r4, #37856	; 0x93e0
8f60c3b8:	e3404004 	movt	r4, #4
8f60c3bc:	e0040894 	mul	r4, r4, r8
8f60c3c0:	eaffff80 	b	8f60c1c8 <mmc_sdhci_erase+0x14c>
			dprintf(CRITICAL, "Card status check timed out after sending erase command\n");
8f60c3c4:	e3030038 	movw	r0, #12344	; 0x3038
8f60c3c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c3cc:	eb009968 	bl	8f632974 <_dprintf>
			return 1;
8f60c3d0:	eaffffc8 	b	8f60c2f8 <mmc_sdhci_erase+0x27c>
}
8f60c3d4:	eb0099f9 	bl	8f632bc0 <__stack_chk_fail>
8f60c3d8:	8f74221c 	.word	0x8f74221c

8f60c3dc <mmc_put_card_to_sleep>:
	return 0;
}

/* Function to put the mmc card to sleep */
void mmc_put_card_to_sleep(struct mmc_device *dev)
{
8f60c3dc:	e92d4010 	push	{r4, r14}
8f60c3e0:	e24dd050 	sub	r13, r13, #80	; 0x50
8f60c3e4:	e59f30d4 	ldr	r3, [pc, #212]	; 8f60c4c0 <mmc_put_card_to_sleep+0xe4>
8f60c3e8:	e1a04000 	mov	r4, r0
	struct mmc_command cmd = {0};
8f60c3ec:	e3a02048 	mov	r2, #72	; 0x48
8f60c3f0:	e3a01000 	mov	r1, #0
8f60c3f4:	e1a0000d 	mov	r0, r13
{
8f60c3f8:	e5933000 	ldr	r3, [r3]
8f60c3fc:	e58d304c 	str	r3, [r13, #76]	; 0x4c
8f60c400:	e3a03000 	mov	r3, #0
	struct mmc_command cmd = {0};
8f60c404:	eb009fae 	bl	8f6342c4 <memset>
	cmd.argument = 0x00000000;
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
	cmd.resp_type = SDHCI_CMD_RESP_NONE;

	/* send command */
	if(sdhci_send_command(&dev->host, &cmd))
8f60c408:	e1a0100d 	mov	r1, r13
8f60c40c:	e1a00004 	mov	r0, r4
	cmd.cmd_index = CMD7_SELECT_DESELECT_CARD;
8f60c410:	e3a03007 	mov	r3, #7
8f60c414:	e1cd30b0 	strh	r3, [r13]
	if(sdhci_send_command(&dev->host, &cmd))
8f60c418:	ebffef93 	bl	8f60826c <sdhci_send_command>
8f60c41c:	e2503000 	subs	r3, r0, #0
8f60c420:	1a00001f 	bne	8f60c4a4 <mmc_put_card_to_sleep+0xc8>
	{
		dprintf(CRITICAL, "card deselect error: %s\n", __func__);
		return;
	}
	if(MMC_CARD_MMC(card)){
8f60c424:	e5942050 	ldr	r2, [r4, #80]	; 0x50
8f60c428:	e2422003 	sub	r2, r2, #3
8f60c42c:	e3520001 	cmp	r2, #1
8f60c430:	9a000007 	bls	8f60c454 <mmc_put_card_to_sleep+0x78>

		/* send command */
		if(sdhci_send_command(&dev->host, &cmd))
			dprintf(CRITICAL, "card sleep error: %s\n", __func__);
	}
}
8f60c434:	e59f3084 	ldr	r3, [pc, #132]	; 8f60c4c0 <mmc_put_card_to_sleep+0xe4>
8f60c438:	e5932000 	ldr	r2, [r3]
8f60c43c:	e59d304c 	ldr	r3, [r13, #76]	; 0x4c
8f60c440:	e0332002 	eors	r2, r3, r2
8f60c444:	e3a03000 	mov	r3, #0
8f60c448:	1a00001b 	bne	8f60c4bc <mmc_put_card_to_sleep+0xe0>
8f60c44c:	e28dd050 	add	r13, r13, #80	; 0x50
8f60c450:	e8bd8010 	pop	{r4, r15}
		cmd.argument = (card->rca << MMC_CARD_RCA_BIT) | MMC_CARD_SLEEP;
8f60c454:	e5942038 	ldr	r2, [r4, #56]	; 0x38
		if(sdhci_send_command(&dev->host, &cmd))
8f60c458:	e1a0100d 	mov	r1, r13
		cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60c45c:	e5cd3009 	strb	r3, [r13, #9]
		if(sdhci_send_command(&dev->host, &cmd))
8f60c460:	e1a00004 	mov	r0, r4
		cmd.cmd_index = CMD5_SLEEP_AWAKE;
8f60c464:	e3a0e005 	mov	r14, #5
		cmd.resp_type = SDHCI_CMD_RESP_R1B;
8f60c468:	e3a0c002 	mov	r12, #2
		cmd.argument = (card->rca << MMC_CARD_RCA_BIT) | MMC_CARD_SLEEP;
8f60c46c:	e1a03802 	lsl	r3, r2, #16
		cmd.cmd_index = CMD5_SLEEP_AWAKE;
8f60c470:	e1cde0b0 	strh	r14, [r13]
		cmd.argument = (card->rca << MMC_CARD_RCA_BIT) | MMC_CARD_SLEEP;
8f60c474:	e3833902 	orr	r3, r3, #32768	; 0x8000
		cmd.resp_type = SDHCI_CMD_RESP_R1B;
8f60c478:	e1cdc0ba 	strh	r12, [r13, #10]
		cmd.argument = (card->rca << MMC_CARD_RCA_BIT) | MMC_CARD_SLEEP;
8f60c47c:	e58d3004 	str	r3, [r13, #4]
		if(sdhci_send_command(&dev->host, &cmd))
8f60c480:	ebffef79 	bl	8f60826c <sdhci_send_command>
8f60c484:	e3500000 	cmp	r0, #0
8f60c488:	0affffe9 	beq	8f60c434 <mmc_put_card_to_sleep+0x58>
			dprintf(CRITICAL, "card sleep error: %s\n", __func__);
8f60c48c:	e303119c 	movw	r1, #12700	; 0x319c
8f60c490:	e30300bc 	movw	r0, #12476	; 0x30bc
8f60c494:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60c498:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c49c:	eb009934 	bl	8f632974 <_dprintf>
8f60c4a0:	eaffffe3 	b	8f60c434 <mmc_put_card_to_sleep+0x58>
		dprintf(CRITICAL, "card deselect error: %s\n", __func__);
8f60c4a4:	e303119c 	movw	r1, #12700	; 0x319c
8f60c4a8:	e30300a0 	movw	r0, #12448	; 0x30a0
8f60c4ac:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60c4b0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c4b4:	eb00992e 	bl	8f632974 <_dprintf>
		return;
8f60c4b8:	eaffffdd 	b	8f60c434 <mmc_put_card_to_sleep+0x58>
}
8f60c4bc:	eb0099bf 	bl	8f632bc0 <__stack_chk_fail>
8f60c4c0:	8f74221c 	.word	0x8f74221c

8f60c4c4 <mmc_sdhci_rpmb_send>:

	return 0;
}

uint32_t mmc_sdhci_rpmb_send(struct mmc_device *dev, struct mmc_command *cmd)
{
8f60c4c4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	uint32_t retry = 5;
	uint32_t status;
	uint32_t rel_write = 0;
	uint32_t ret = 1;

	ASSERT(cmd);
8f60c4c8:	e2518000 	subs	r8, r1, #0
{
8f60c4cc:	e59f3260 	ldr	r3, [pc, #608]	; 8f60c734 <mmc_sdhci_rpmb_send+0x270>
8f60c4d0:	e24dd064 	sub	r13, r13, #100	; 0x64
8f60c4d4:	e1a04000 	mov	r4, r0
8f60c4d8:	e5933000 	ldr	r3, [r3]
8f60c4dc:	e58d305c 	str	r3, [r13, #92]	; 0x5c
8f60c4e0:	e3a03000 	mov	r3, #0
	ASSERT(cmd);
8f60c4e4:	0a000084 	beq	8f60c6fc <mmc_sdhci_rpmb_send+0x238>
	part_access = dev->card.ext_csd[MMC_PARTITION_CONFIG] & ~PARTITION_ACCESS_MASK;
8f60c4e8:	e5942058 	ldr	r2, [r4, #88]	; 0x58
	ret = mmc_switch_cmd(&dev->host, &dev->card, MMC_ACCESS_WRITE, MMC_PARTITION_CONFIG, part_access);
8f60c4ec:	e2841038 	add	r1, r4, #56	; 0x38
8f60c4f0:	e3a030b3 	mov	r3, #179	; 0xb3
8f60c4f4:	e1a00004 	mov	r0, r4
8f60c4f8:	e58d1008 	str	r1, [r13, #8]
	part_access = dev->card.ext_csd[MMC_PARTITION_CONFIG] & ~PARTITION_ACCESS_MASK;
8f60c4fc:	e5d250b3 	ldrb	r5, [r2, #179]	; 0xb3
	ret = mmc_switch_cmd(&dev->host, &dev->card, MMC_ACCESS_WRITE, MMC_PARTITION_CONFIG, part_access);
8f60c500:	e3a02003 	mov	r2, #3
	part_access = dev->card.ext_csd[MMC_PARTITION_CONFIG] & ~PARTITION_ACCESS_MASK;
8f60c504:	e3c55007 	bic	r5, r5, #7
	part_access |= type;
8f60c508:	e3855003 	orr	r5, r5, #3
	ret = mmc_switch_cmd(&dev->host, &dev->card, MMC_ACCESS_WRITE, MMC_PARTITION_CONFIG, part_access);
8f60c50c:	e58d5000 	str	r5, [r13]
8f60c510:	ebfff5f2 	bl	8f609ce0 <mmc_switch_cmd>
	if (ret)
8f60c514:	e2507000 	subs	r7, r0, #0
8f60c518:	1a000064 	bne	8f60c6b0 <mmc_sdhci_rpmb_send+0x1ec>
	dev->card.ext_csd[MMC_PARTITION_CONFIG] = part_access;
8f60c51c:	e5943058 	ldr	r3, [r4, #88]	; 0x58
	struct mmc_command cmd = {0};
8f60c520:	e1a09007 	mov	r9, r7
	dev->card.ext_csd[MMC_PARTITION_CONFIG] = part_access;
8f60c524:	e5c350b3 	strb	r5, [r3, #179]	; 0xb3
	uint32_t retry = 5;
8f60c528:	e3a05005 	mov	r5, #5
8f60c52c:	e28830d8 	add	r3, r8, #216	; 0xd8
8f60c530:	e58d300c 	str	r3, [r13, #12]
	if (mmc_sdhci_switch_part(dev, PART_ACCESS_RPMB))
		return 1;

	for (i = 0; i < MAX_RPMB_CMDS; i++)
	{
		if (!cmd[i].cmd_index)
8f60c534:	e1d830b0 	ldrh	r3, [r8]
8f60c538:	e3530000 	cmp	r3, #0
8f60c53c:	0a000040 	beq	8f60c644 <mmc_sdhci_rpmb_send+0x180>
			break;

		if (cmd[i].write_flag == true)
8f60c540:	e5983030 	ldr	r3, [r8, #48]	; 0x30
	struct mmc_command cmd = {0};
8f60c544:	e3a01000 	mov	r1, #0
			rel_write = BIT(31);
		else
			rel_write = 0;

		/* 2. Set the block count using cmd23 */
		if (mmc_sdhci_set_blk_cnt(dev, cmd[i].data.num_blocks, rel_write))
8f60c548:	e598603c 	ldr	r6, [r8, #60]	; 0x3c
	struct mmc_command cmd = {0};
8f60c54c:	e3a02048 	mov	r2, #72	; 0x48
			rel_write = 0;
8f60c550:	e3530001 	cmp	r3, #1
	struct mmc_command cmd = {0};
8f60c554:	e28d0010 	add	r0, r13, #16
			rel_write = 0;
8f60c558:	11a0a001 	movne	r10, r1
8f60c55c:	03a0a102 	moveq	r10, #-2147483648	; 0x80000000
	cmd.argument = blk_cnt & 0x0000ffff;
8f60c560:	e6ff6076 	uxth	r6, r6
	struct mmc_command cmd = {0};
8f60c564:	eb009f56 	bl	8f6342c4 <memset>
	if (sdhci_send_command(&dev->host, &cmd))
8f60c568:	e28d1010 	add	r1, r13, #16
8f60c56c:	e1a00004 	mov	r0, r4
	cmd.argument |= rel_write;
8f60c570:	e186600a 	orr	r6, r6, r10
	cmd.cmd_index = CMD23_SET_BLOCK_COUNT;
8f60c574:	e3a03017 	mov	r3, #23
	cmd.argument |= rel_write;
8f60c578:	e58d6014 	str	r6, [r13, #20]
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60c57c:	e3a06001 	mov	r6, #1
	cmd.cmd_index = CMD23_SET_BLOCK_COUNT;
8f60c580:	e1cd31b0 	strh	r3, [r13, #16]
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60c584:	e1cd61ba 	strh	r6, [r13, #26]
	if (sdhci_send_command(&dev->host, &cmd))
8f60c588:	ebffef37 	bl	8f60826c <sdhci_send_command>
8f60c58c:	e3500000 	cmp	r0, #0
8f60c590:	1a00004c 	bne	8f60c6c8 <mmc_sdhci_rpmb_send+0x204>
			goto err;

		/* 3. Send the command */
		if (sdhci_send_command(&dev->host, &cmd[i]))
8f60c594:	e1a01008 	mov	r1, r8
8f60c598:	e1a00004 	mov	r0, r4
8f60c59c:	ebffef32 	bl	8f60826c <sdhci_send_command>
8f60c5a0:	e3500000 	cmp	r0, #0
8f60c5a4:	1a00005f 	bne	8f60c728 <mmc_sdhci_rpmb_send+0x264>
	cmd.cmd_index = CMD13_SEND_STATUS;
8f60c5a8:	e3a0a00d 	mov	r10, #13
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60c5ac:	e3a02048 	mov	r2, #72	; 0x48
8f60c5b0:	e3a01000 	mov	r1, #0
8f60c5b4:	e28d0010 	add	r0, r13, #16
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60c5b8:	e3a06001 	mov	r6, #1
	memset((struct mmc_command *)&cmd, 0, sizeof(struct mmc_command));
8f60c5bc:	eb009f40 	bl	8f6342c4 <memset>
	cmd.argument = card->rca << 16;
8f60c5c0:	e5943038 	ldr	r3, [r4, #56]	; 0x38
	mmc_ret = sdhci_send_command(host, &cmd);
8f60c5c4:	e28d1010 	add	r1, r13, #16
8f60c5c8:	e1a00004 	mov	r0, r4
	cmd.cmd_index = CMD13_SEND_STATUS;
8f60c5cc:	e1cda1b0 	strh	r10, [r13, #16]
	cmd.argument = card->rca << 16;
8f60c5d0:	e1a03803 	lsl	r3, r3, #16
	cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
8f60c5d4:	e5cd9019 	strb	r9, [r13, #25]
	cmd.argument = card->rca << 16;
8f60c5d8:	e58d3014 	str	r3, [r13, #20]
	cmd.resp_type = SDHCI_CMD_RESP_R1;
8f60c5dc:	e1cd61ba 	strh	r6, [r13, #26]
	mmc_ret = sdhci_send_command(host, &cmd);
8f60c5e0:	ebffef21 	bl	8f60826c <sdhci_send_command>
	if (mmc_ret)
8f60c5e4:	e3500000 	cmp	r0, #0
8f60c5e8:	1a000011 	bne	8f60c634 <mmc_sdhci_rpmb_send+0x170>
	if ((cmd.resp[0] >> 31) & 0x01)
8f60c5ec:	e59db01c 	ldr	r11, [r13, #28]
8f60c5f0:	e35b0000 	cmp	r11, #0
8f60c5f4:	ba00000e 	blt	8f60c634 <mmc_sdhci_rpmb_send+0x170>
			{
				dprintf(CRITICAL, "Failed to get card status after rpmb operations\n");
				goto err;
			}

			retry--;
8f60c5f8:	e2455001 	sub	r5, r5, #1
			udelay(500);
8f60c5fc:	e3a00f7d 	mov	r0, #500	; 0x1f4
8f60c600:	eb0009d5 	bl	8f60ed5c <udelay>
			if (!retry)
8f60c604:	e3550000 	cmp	r5, #0
8f60c608:	0a000023 	beq	8f60c69c <mmc_sdhci_rpmb_send+0x1d8>
			{
				dprintf(CRITICAL, "Card status check timed out after rpmb operations\n");
				goto err;
			}
		} while(!(status & MMC_READY_FOR_DATA) || (MMC_CARD_STATUS(status) == MMC_PROG_STATE));
8f60c60c:	e31b0c01 	tst	r11, #256	; 0x100
8f60c610:	0affffe5 	beq	8f60c5ac <mmc_sdhci_rpmb_send+0xe8>
8f60c614:	e7e334db 	ubfx	r3, r11, #9, #4
8f60c618:	e3530007 	cmp	r3, #7
8f60c61c:	0affffe2 	beq	8f60c5ac <mmc_sdhci_rpmb_send+0xe8>
	for (i = 0; i < MAX_RPMB_CMDS; i++)
8f60c620:	e59d300c 	ldr	r3, [r13, #12]
8f60c624:	e2888048 	add	r8, r8, #72	; 0x48
8f60c628:	e1530008 	cmp	r3, r8
8f60c62c:	0a000004 	beq	8f60c644 <mmc_sdhci_rpmb_send+0x180>
8f60c630:	eaffffbf 	b	8f60c534 <mmc_sdhci_rpmb_send+0x70>
				dprintf(CRITICAL, "Failed to get card status after rpmb operations\n");
8f60c634:	e303011c 	movw	r0, #12572	; 0x311c
8f60c638:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c63c:	eb0098cc 	bl	8f632974 <_dprintf>
	uint32_t ret = 1;
8f60c640:	e3a07001 	mov	r7, #1
	part_access = dev->card.ext_csd[MMC_PARTITION_CONFIG] & ~PARTITION_ACCESS_MASK;
8f60c644:	e5942058 	ldr	r2, [r4, #88]	; 0x58
	ret = mmc_switch_cmd(&dev->host, &dev->card, MMC_ACCESS_WRITE, MMC_PARTITION_CONFIG, part_access);
8f60c648:	e3a030b3 	mov	r3, #179	; 0xb3
8f60c64c:	e59d1008 	ldr	r1, [r13, #8]
8f60c650:	e1a00004 	mov	r0, r4
	part_access = dev->card.ext_csd[MMC_PARTITION_CONFIG] & ~PARTITION_ACCESS_MASK;
8f60c654:	e5d250b3 	ldrb	r5, [r2, #179]	; 0xb3
	ret = mmc_switch_cmd(&dev->host, &dev->card, MMC_ACCESS_WRITE, MMC_PARTITION_CONFIG, part_access);
8f60c658:	e3a02003 	mov	r2, #3
	part_access = dev->card.ext_csd[MMC_PARTITION_CONFIG] & ~PARTITION_ACCESS_MASK;
8f60c65c:	e3c55007 	bic	r5, r5, #7
	ret = mmc_switch_cmd(&dev->host, &dev->card, MMC_ACCESS_WRITE, MMC_PARTITION_CONFIG, part_access);
8f60c660:	e58d5000 	str	r5, [r13]
8f60c664:	ebfff59d 	bl	8f609ce0 <mmc_switch_cmd>
	if (ret)
8f60c668:	e3500000 	cmp	r0, #0
	dev->card.ext_csd[MMC_PARTITION_CONFIG] = part_access;
8f60c66c:	05943058 	ldreq	r3, [r4, #88]	; 0x58
8f60c670:	05c350b3 	strbeq	r5, [r3, #179]	; 0xb3
	if (ret)
8f60c674:	1a00001a 	bne	8f60c6e4 <mmc_sdhci_rpmb_send+0x220>
	/* 5. Switch the partition back to default type */
	if (mmc_sdhci_switch_part(dev, PART_ACCESS_DEFAULT))
		ret = 1;

	return ret;
}
8f60c678:	e59f30b4 	ldr	r3, [pc, #180]	; 8f60c734 <mmc_sdhci_rpmb_send+0x270>
8f60c67c:	e5932000 	ldr	r2, [r3]
8f60c680:	e59d305c 	ldr	r3, [r13, #92]	; 0x5c
8f60c684:	e0332002 	eors	r2, r3, r2
8f60c688:	e3a03000 	mov	r3, #0
8f60c68c:	1a000027 	bne	8f60c730 <mmc_sdhci_rpmb_send+0x26c>
8f60c690:	e1a00007 	mov	r0, r7
8f60c694:	e28dd064 	add	r13, r13, #100	; 0x64
8f60c698:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
				dprintf(CRITICAL, "Card status check timed out after rpmb operations\n");
8f60c69c:	e3030150 	movw	r0, #12624	; 0x3150
8f60c6a0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c6a4:	eb0098b2 	bl	8f632974 <_dprintf>
	uint32_t ret = 1;
8f60c6a8:	e1a07006 	mov	r7, r6
				goto err;
8f60c6ac:	eaffffe4 	b	8f60c644 <mmc_sdhci_rpmb_send+0x180>
		dprintf(CRITICAL, "Failed to switch partition to type: %u\n", type);
8f60c6b0:	e3a01003 	mov	r1, #3
8f60c6b4:	e30300d8 	movw	r0, #12504	; 0x30d8
8f60c6b8:	e3480f70 	movt	r0, #36720	; 0x8f70
		return 1;
8f60c6bc:	e3a07001 	mov	r7, #1
		dprintf(CRITICAL, "Failed to switch partition to type: %u\n", type);
8f60c6c0:	eb0098ab 	bl	8f632974 <_dprintf>
		return 1;
8f60c6c4:	eaffffeb 	b	8f60c678 <mmc_sdhci_rpmb_send+0x1b4>
		dprintf(CRITICAL, "Set block count failed: %s\n", __func__);
8f60c6c8:	e3031184 	movw	r1, #12676	; 0x3184
8f60c6cc:	e3030100 	movw	r0, #12544	; 0x3100
8f60c6d0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60c6d4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c6d8:	eb0098a5 	bl	8f632974 <_dprintf>
	uint32_t ret = 1;
8f60c6dc:	e1a07006 	mov	r7, r6
8f60c6e0:	eaffffd7 	b	8f60c644 <mmc_sdhci_rpmb_send+0x180>
		dprintf(CRITICAL, "Failed to switch partition to type: %u\n", type);
8f60c6e4:	e3a01000 	mov	r1, #0
8f60c6e8:	e30300d8 	movw	r0, #12504	; 0x30d8
8f60c6ec:	e3480f70 	movt	r0, #36720	; 0x8f70
		ret = 1;
8f60c6f0:	e3a07001 	mov	r7, #1
		dprintf(CRITICAL, "Failed to switch partition to type: %u\n", type);
8f60c6f4:	eb00989e 	bl	8f632974 <_dprintf>
		return 1;
8f60c6f8:	eaffffde 	b	8f60c678 <mmc_sdhci_rpmb_send+0x1b4>
	ASSERT(cmd);
8f60c6fc:	e30310d4 	movw	r1, #12500	; 0x30d4
8f60c700:	e30223d0 	movw	r2, #9168	; 0x23d0
8f60c704:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60c708:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60c70c:	e58d1000 	str	r1, [r13]
8f60c710:	e3003a07 	movw	r3, #2567	; 0xa07
8f60c714:	e1a0000e 	mov	r0, r14
8f60c718:	e3001130 	movw	r1, #304	; 0x130
8f60c71c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60c720:	eb0098e5 	bl	8f632abc <_panic>
8f60c724:	eaffff6f 	b	8f60c4e8 <mmc_sdhci_rpmb_send+0x24>
	uint32_t ret = 1;
8f60c728:	e1a07006 	mov	r7, r6
8f60c72c:	eaffffc4 	b	8f60c644 <mmc_sdhci_rpmb_send+0x180>
}
8f60c730:	eb009922 	bl	8f632bc0 <__stack_chk_fail>
8f60c734:	8f74221c 	.word	0x8f74221c

8f60c738 <ufs_write>:
8f60c738:	e59f3038 	ldr	r3, [pc, #56]	; 8f60c778 <ufs_write+0x40>
8f60c73c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60c740:	e24dd00c 	sub	r13, r13, #12
8f60c744:	e5933000 	ldr	r3, [r3]
8f60c748:	e58d3004 	str	r3, [r13, #4]
8f60c74c:	e3a03000 	mov	r3, #0
8f60c750:	e59f3020 	ldr	r3, [pc, #32]	; 8f60c778 <ufs_write+0x40>
8f60c754:	e5932000 	ldr	r2, [r3]
8f60c758:	e59d3004 	ldr	r3, [r13, #4]
8f60c75c:	e0332002 	eors	r2, r3, r2
8f60c760:	e3a03000 	mov	r3, #0
8f60c764:	1a000002 	bne	8f60c774 <ufs_write+0x3c>
8f60c768:	e3a00000 	mov	r0, #0
8f60c76c:	e28dd00c 	add	r13, r13, #12
8f60c770:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60c774:	eb009911 	bl	8f632bc0 <__stack_chk_fail>
8f60c778:	8f74221c 	.word	0x8f74221c

8f60c77c <ufs_read>:
{
	return 0;
}

__WEAK int ufs_read(struct ufs_dev *dev, uint64_t data_addr, addr_t in, uint32_t len)
{
8f60c77c:	e59f3038 	ldr	r3, [pc, #56]	; 8f60c7bc <ufs_read+0x40>
8f60c780:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60c784:	e24dd00c 	sub	r13, r13, #12
8f60c788:	e5933000 	ldr	r3, [r3]
8f60c78c:	e58d3004 	str	r3, [r13, #4]
8f60c790:	e3a03000 	mov	r3, #0
	return 0;
}
8f60c794:	e59f3020 	ldr	r3, [pc, #32]	; 8f60c7bc <ufs_read+0x40>
8f60c798:	e5932000 	ldr	r2, [r3]
8f60c79c:	e59d3004 	ldr	r3, [r13, #4]
8f60c7a0:	e0332002 	eors	r2, r3, r2
8f60c7a4:	e3a03000 	mov	r3, #0
8f60c7a8:	1a000002 	bne	8f60c7b8 <ufs_read+0x3c>
8f60c7ac:	e3a00000 	mov	r0, #0
8f60c7b0:	e28dd00c 	add	r13, r13, #12
8f60c7b4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60c7b8:	eb009900 	bl	8f632bc0 <__stack_chk_fail>
8f60c7bc:	8f74221c 	.word	0x8f74221c

8f60c7c0 <ufs_get_page_size>:
8f60c7c0:	e59f3038 	ldr	r3, [pc, #56]	; 8f60c800 <ufs_get_page_size+0x40>
8f60c7c4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60c7c8:	e24dd00c 	sub	r13, r13, #12
8f60c7cc:	e5933000 	ldr	r3, [r3]
8f60c7d0:	e58d3004 	str	r3, [r13, #4]
8f60c7d4:	e3a03000 	mov	r3, #0
8f60c7d8:	e59f3020 	ldr	r3, [pc, #32]	; 8f60c800 <ufs_get_page_size+0x40>
8f60c7dc:	e5932000 	ldr	r2, [r3]
8f60c7e0:	e59d3004 	ldr	r3, [r13, #4]
8f60c7e4:	e0332002 	eors	r2, r3, r2
8f60c7e8:	e3a03000 	mov	r3, #0
8f60c7ec:	1a000002 	bne	8f60c7fc <ufs_get_page_size+0x3c>
8f60c7f0:	e3a00000 	mov	r0, #0
8f60c7f4:	e28dd00c 	add	r13, r13, #12
8f60c7f8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60c7fc:	eb0098ef 	bl	8f632bc0 <__stack_chk_fail>
8f60c800:	8f74221c 	.word	0x8f74221c

8f60c804 <mmc_zero_out>:
 * Return  : Returns 0
 * Flow    : Erase the card from specified addr
 */

static uint32_t mmc_zero_out(struct mmc_device* dev, uint32_t blk_addr, uint32_t num_blks)
{
8f60c804:	e59f30fc 	ldr	r3, [pc, #252]	; 8f60c908 <mmc_zero_out+0x104>
8f60c808:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f60c80c:	e24dd010 	sub	r13, r13, #16
8f60c810:	e5933000 	ldr	r3, [r3]
8f60c814:	e58d300c 	str	r3, [r13, #12]
8f60c818:	e3a03000 	mov	r3, #0
8f60c81c:	e1a08000 	mov	r8, r0
8f60c820:	e1a06001 	mov	r6, r1
8f60c824:	e1a05002 	mov	r5, r2
 * Return  : Returns the block size of the storage
 * Flow    : Get the block size form the card
 */
uint32_t mmc_get_device_blocksize()
{
	if (platform_boot_dev_isemmc())
8f60c828:	eb00542e 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f60c82c:	e3500000 	cmp	r0, #0
8f60c830:	0a000023 	beq	8f60c8c4 <mmc_zero_out+0xc0>
	dev = target_mmc_device();
8f60c834:	ebffcf81 	bl	8f600640 <target_mmc_device>
	{
		struct mmc_card *card;

		card = get_mmc_card();

		return card->block_size;
8f60c838:	e5904040 	ldr	r4, [r0, #64]	; 0x40
	uint32_t scratch_size = target_get_max_flash_size();
8f60c83c:	ebffd2d6 	bl	8f60139c <target_get_max_flash_size>
	uint32_t erase_size = (block_size * num_blks);
8f60c840:	e0040594 	mul	r4, r4, r5
	dprintf(INFO, "erasing 0x%x:0x%x\n", blk_addr, num_blks);
8f60c844:	e1a02005 	mov	r2, r5
8f60c848:	e1a01006 	mov	r1, r6
	uint32_t scratch_size = target_get_max_flash_size();
8f60c84c:	e1a07000 	mov	r7, r0
	dprintf(INFO, "erasing 0x%x:0x%x\n", blk_addr, num_blks);
8f60c850:	e3030288 	movw	r0, #12936	; 0x3288
8f60c854:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c858:	eb009845 	bl	8f632974 <_dprintf>
	if (erase_size <= scratch_size)
8f60c85c:	e1540007 	cmp	r4, r7
8f60c860:	8a00001b 	bhi	8f60c8d4 <mmc_zero_out+0xd0>
		out = (uint32_t *) target_get_scratch_address();
8f60c864:	ebffd2ba 	bl	8f601354 <target_get_scratch_address>
	memset((void *)out, 0, erase_size);
8f60c868:	e1a02004 	mov	r2, r4
8f60c86c:	e3a01000 	mov	r1, #0
		out = (uint32_t *) target_get_scratch_address();
8f60c870:	e1a07000 	mov	r7, r0
	memset((void *)out, 0, erase_size);
8f60c874:	eb009e92 	bl	8f6342c4 <memset>
	arch_clean_invalidate_cache_range((addr_t) out , erase_size);
8f60c878:	e1a01004 	mov	r1, r4
8f60c87c:	e1a00007 	mov	r0, r7
8f60c880:	eb0051c6 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	if (mmc_sdhci_write(dev, out, blk_addr, num_blks))
8f60c884:	e1a02006 	mov	r2, r6
8f60c888:	e1a01007 	mov	r1, r7
8f60c88c:	e1a00008 	mov	r0, r8
8f60c890:	e3a03000 	mov	r3, #0
8f60c894:	e58d5000 	str	r5, [r13]
8f60c898:	ebfffd63 	bl	8f60be2c <mmc_sdhci_write>
8f60c89c:	e3500000 	cmp	r0, #0
8f60c8a0:	1a000011 	bne	8f60c8ec <mmc_zero_out+0xe8>
}
8f60c8a4:	e59f305c 	ldr	r3, [pc, #92]	; 8f60c908 <mmc_zero_out+0x104>
8f60c8a8:	e5932000 	ldr	r2, [r3]
8f60c8ac:	e59d300c 	ldr	r3, [r13, #12]
8f60c8b0:	e0332002 	eors	r2, r3, r2
8f60c8b4:	e3a03000 	mov	r3, #0
8f60c8b8:	1a000011 	bne	8f60c904 <mmc_zero_out+0x100>
8f60c8bc:	e28dd010 	add	r13, r13, #16
8f60c8c0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
	}
	else
	{
		void *dev;

		dev = target_mmc_device();
8f60c8c4:	ebffcf5d 	bl	8f600640 <target_mmc_device>

		return ufs_get_page_size((struct ufs_dev *)dev);
8f60c8c8:	ebffffbc 	bl	8f60c7c0 <ufs_get_page_size>
8f60c8cc:	e1a04000 	mov	r4, r0
8f60c8d0:	eaffffd9 	b	8f60c83c <mmc_zero_out+0x38>
		dprintf(CRITICAL, "Erase Fail: Erase size: %u is bigger than scratch region\n", scratch_size);
8f60c8d4:	e1a01007 	mov	r1, r7
8f60c8d8:	e303029c 	movw	r0, #12956	; 0x329c
8f60c8dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c8e0:	eb009823 	bl	8f632974 <_dprintf>
		return 1;
8f60c8e4:	e3a00001 	mov	r0, #1
8f60c8e8:	eaffffed 	b	8f60c8a4 <mmc_zero_out+0xa0>
		dprintf(CRITICAL, "failed to erase the partition: %x\n", blk_addr);
8f60c8ec:	e1a01006 	mov	r1, r6
8f60c8f0:	e30302d8 	movw	r0, #13016	; 0x32d8
8f60c8f4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60c8f8:	eb00981d 	bl	8f632974 <_dprintf>
		return 1;
8f60c8fc:	e3a00001 	mov	r0, #1
8f60c900:	eaffffe7 	b	8f60c8a4 <mmc_zero_out+0xa0>
}
8f60c904:	eb0098ad 	bl	8f632bc0 <__stack_chk_fail>
8f60c908:	8f74221c 	.word	0x8f74221c

8f60c90c <ufs_get_serial_num>:
{
8f60c90c:	e59f3038 	ldr	r3, [pc, #56]	; 8f60c94c <ufs_get_serial_num+0x40>
8f60c910:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60c914:	e24dd00c 	sub	r13, r13, #12
8f60c918:	e5933000 	ldr	r3, [r3]
8f60c91c:	e58d3004 	str	r3, [r13, #4]
8f60c920:	e3a03000 	mov	r3, #0
}
8f60c924:	e59f3020 	ldr	r3, [pc, #32]	; 8f60c94c <ufs_get_serial_num+0x40>
8f60c928:	e5932000 	ldr	r2, [r3]
8f60c92c:	e59d3004 	ldr	r3, [r13, #4]
8f60c930:	e0332002 	eors	r2, r3, r2
8f60c934:	e3a03000 	mov	r3, #0
8f60c938:	1a000002 	bne	8f60c948 <ufs_get_serial_num+0x3c>
8f60c93c:	e3a00000 	mov	r0, #0
8f60c940:	e28dd00c 	add	r13, r13, #12
8f60c944:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60c948:	eb00989c 	bl	8f632bc0 <__stack_chk_fail>
8f60c94c:	8f74221c 	.word	0x8f74221c

8f60c950 <ufs_get_dev_capacity>:
{
8f60c950:	e59f303c 	ldr	r3, [pc, #60]	; 8f60c994 <ufs_get_dev_capacity+0x44>
8f60c954:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60c958:	e24dd00c 	sub	r13, r13, #12
8f60c95c:	e5933000 	ldr	r3, [r3]
8f60c960:	e58d3004 	str	r3, [r13, #4]
8f60c964:	e3a03000 	mov	r3, #0
}
8f60c968:	e59f3024 	ldr	r3, [pc, #36]	; 8f60c994 <ufs_get_dev_capacity+0x44>
8f60c96c:	e5932000 	ldr	r2, [r3]
8f60c970:	e59d3004 	ldr	r3, [r13, #4]
8f60c974:	e0332002 	eors	r2, r3, r2
8f60c978:	e3a03000 	mov	r3, #0
8f60c97c:	1a000003 	bne	8f60c990 <ufs_get_dev_capacity+0x40>
8f60c980:	e3a00000 	mov	r0, #0
8f60c984:	e3a01000 	mov	r1, #0
8f60c988:	e28dd00c 	add	r13, r13, #12
8f60c98c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60c990:	eb00988a 	bl	8f632bc0 <__stack_chk_fail>
8f60c994:	8f74221c 	.word	0x8f74221c

8f60c998 <ufs_erase>:
{
8f60c998:	e59f3038 	ldr	r3, [pc, #56]	; 8f60c9d8 <ufs_erase+0x40>
8f60c99c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60c9a0:	e24dd00c 	sub	r13, r13, #12
8f60c9a4:	e5933000 	ldr	r3, [r3]
8f60c9a8:	e58d3004 	str	r3, [r13, #4]
8f60c9ac:	e3a03000 	mov	r3, #0
}
8f60c9b0:	e59f3020 	ldr	r3, [pc, #32]	; 8f60c9d8 <ufs_erase+0x40>
8f60c9b4:	e5932000 	ldr	r2, [r3]
8f60c9b8:	e59d3004 	ldr	r3, [r13, #4]
8f60c9bc:	e0332002 	eors	r2, r3, r2
8f60c9c0:	e3a03000 	mov	r3, #0
8f60c9c4:	1a000002 	bne	8f60c9d4 <ufs_erase+0x3c>
8f60c9c8:	e3a00000 	mov	r0, #0
8f60c9cc:	e28dd00c 	add	r13, r13, #12
8f60c9d0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60c9d4:	eb009879 	bl	8f632bc0 <__stack_chk_fail>
8f60c9d8:	8f74221c 	.word	0x8f74221c

8f60c9dc <ufs_get_num_of_luns>:
{
8f60c9dc:	e59f3038 	ldr	r3, [pc, #56]	; 8f60ca1c <ufs_get_num_of_luns+0x40>
8f60c9e0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60c9e4:	e24dd00c 	sub	r13, r13, #12
8f60c9e8:	e5933000 	ldr	r3, [r3]
8f60c9ec:	e58d3004 	str	r3, [r13, #4]
8f60c9f0:	e3a03000 	mov	r3, #0
}
8f60c9f4:	e59f3020 	ldr	r3, [pc, #32]	; 8f60ca1c <ufs_get_num_of_luns+0x40>
8f60c9f8:	e5932000 	ldr	r2, [r3]
8f60c9fc:	e59d3004 	ldr	r3, [r13, #4]
8f60ca00:	e0332002 	eors	r2, r3, r2
8f60ca04:	e3a03000 	mov	r3, #0
8f60ca08:	1a000002 	bne	8f60ca18 <ufs_get_num_of_luns+0x3c>
8f60ca0c:	e3a00000 	mov	r0, #0
8f60ca10:	e28dd00c 	add	r13, r13, #12
8f60ca14:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60ca18:	eb009868 	bl	8f632bc0 <__stack_chk_fail>
8f60ca1c:	8f74221c 	.word	0x8f74221c

8f60ca20 <mmc_write>:
{
8f60ca20:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f60ca24:	e1a06003 	mov	r6, r3
8f60ca28:	e59f3254 	ldr	r3, [pc, #596]	; 8f60cc84 <mmc_write+0x264>
8f60ca2c:	e24dd01c 	sub	r13, r13, #28
8f60ca30:	e1a0a00e 	mov	r10, r14
8f60ca34:	e1a07001 	mov	r7, r1
8f60ca38:	e5933000 	ldr	r3, [r3]
8f60ca3c:	e58d3014 	str	r3, [r13, #20]
8f60ca40:	e3a03000 	mov	r3, #0
8f60ca44:	e1a05002 	mov	r5, r2
8f60ca48:	e1a04000 	mov	r4, r0
	dev = target_mmc_device();
8f60ca4c:	ebffcefb 	bl	8f600640 <target_mmc_device>
8f60ca50:	e1a09000 	mov	r9, r0
	if (platform_boot_dev_isemmc())
8f60ca54:	eb0053a3 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f60ca58:	e3500000 	cmp	r0, #0
8f60ca5c:	0a000047 	beq	8f60cb80 <mmc_write+0x160>
	dev = target_mmc_device();
8f60ca60:	ebffcef6 	bl	8f600640 <target_mmc_device>
		return card->block_size;
8f60ca64:	e5908040 	ldr	r8, [r0, #64]	; 0x40
	ASSERT(!(data_addr % block_size));
8f60ca68:	e1a02008 	mov	r2, r8
8f60ca6c:	e3a03000 	mov	r3, #0
8f60ca70:	e1a00004 	mov	r0, r4
8f60ca74:	e1a01007 	mov	r1, r7
8f60ca78:	fa00c1c9 	blx	8f63d1a4 <__aeabi_uldivmod>
8f60ca7c:	e1923003 	orrs	r3, r2, r3
8f60ca80:	1a000073 	bne	8f60cc54 <mmc_write+0x234>
	if (data_len % block_size)
8f60ca84:	e1a00005 	mov	r0, r5
8f60ca88:	e1a01008 	mov	r1, r8
8f60ca8c:	fa00c0e8 	blx	8f63ce34 <__aeabi_uidivmod>
	arch_clean_invalidate_cache_range((addr_t)in, data_len);
8f60ca90:	e1a00006 	mov	r0, r6
	if (data_len % block_size)
8f60ca94:	e3510000 	cmp	r1, #0
		data_len = ROUNDUP(data_len, block_size);
8f60ca98:	12455001 	subne	r5, r5, #1
8f60ca9c:	12682000 	rsbne	r2, r8, #0
8f60caa0:	10855008 	addne	r5, r5, r8
8f60caa4:	10055002 	andne	r5, r5, r2
	arch_clean_invalidate_cache_range((addr_t)in, data_len);
8f60caa8:	e1a01005 	mov	r1, r5
8f60caac:	eb00513b 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	if (platform_boot_dev_isemmc())
8f60cab0:	eb00538c 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f60cab4:	e3500000 	cmp	r0, #0
8f60cab8:	0a000034 	beq	8f60cb90 <mmc_write+0x170>
		while (data_len > write_size) {
8f60cabc:	e3a0acfe 	mov	r10, #65024	; 0xfe00
8f60cac0:	e340a1ff 	movt	r10, #511	; 0x1ff
8f60cac4:	e155000a 	cmp	r5, r10
8f60cac8:	9a00003e 	bls	8f60cbc8 <mmc_write+0x1a8>
			val = mmc_sdhci_write((struct mmc_device *)dev, (void *)sptr, (data_addr / block_size), (write_size / block_size));
8f60cacc:	e1a01008 	mov	r1, r8
8f60cad0:	e1a0000a 	mov	r0, r10
8f60cad4:	fa00c03f 	blx	8f63cbd8 <__udivsi3>
8f60cad8:	e58d000c 	str	r0, [r13, #12]
8f60cadc:	ea000009 	b	8f60cb08 <mmc_write+0xe8>
			data_len -= write_size;
8f60cae0:	e28554fe 	add	r5, r5, #-33554432	; 0xfe000000
			data_addr += write_size;
8f60cae4:	e3a03cfe 	mov	r3, #65024	; 0xfe00
8f60cae8:	e34031ff 	movt	r3, #511	; 0x1ff
			data_len -= write_size;
8f60caec:	e2855c02 	add	r5, r5, #512	; 0x200
			data_addr += write_size;
8f60caf0:	e0944003 	adds	r4, r4, r3
			sptr += write_size;
8f60caf4:	e2866402 	add	r6, r6, #33554432	; 0x2000000
			data_addr += write_size;
8f60caf8:	e2a77000 	adc	r7, r7, #0
		while (data_len > write_size) {
8f60cafc:	e155000a 	cmp	r5, r10
			sptr += write_size;
8f60cb00:	e2466c02 	sub	r6, r6, #512	; 0x200
		while (data_len > write_size) {
8f60cb04:	9a000031 	bls	8f60cbd0 <mmc_write+0x1b0>
			val = mmc_sdhci_write((struct mmc_device *)dev, (void *)sptr, (data_addr / block_size), (write_size / block_size));
8f60cb08:	e1a02008 	mov	r2, r8
8f60cb0c:	e3a03000 	mov	r3, #0
8f60cb10:	e1a00004 	mov	r0, r4
8f60cb14:	e1a01007 	mov	r1, r7
8f60cb18:	fa00c1a1 	blx	8f63d1a4 <__aeabi_uldivmod>
8f60cb1c:	e1a03001 	mov	r3, r1
8f60cb20:	e59d100c 	ldr	r1, [r13, #12]
8f60cb24:	e1a02000 	mov	r2, r0
8f60cb28:	e1a0b000 	mov	r11, r0
8f60cb2c:	e1a00009 	mov	r0, r9
8f60cb30:	e58d1000 	str	r1, [r13]
8f60cb34:	e1a01006 	mov	r1, r6
8f60cb38:	ebfffcbb 	bl	8f60be2c <mmc_sdhci_write>
			if (val)
8f60cb3c:	e3500000 	cmp	r0, #0
8f60cb40:	0affffe6 	beq	8f60cae0 <mmc_write+0xc0>
				dprintf(CRITICAL, "Failed Writing block @ %x\n",(unsigned int)(data_addr / block_size));
8f60cb44:	e58d000c 	str	r0, [r13, #12]
8f60cb48:	e1a0100b 	mov	r1, r11
8f60cb4c:	e303033c 	movw	r0, #13116	; 0x333c
8f60cb50:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60cb54:	eb009786 	bl	8f632974 <_dprintf>
				return val;
8f60cb58:	e59d300c 	ldr	r3, [r13, #12]
}
8f60cb5c:	e59f2120 	ldr	r2, [pc, #288]	; 8f60cc84 <mmc_write+0x264>
8f60cb60:	e5921000 	ldr	r1, [r2]
8f60cb64:	e59d2014 	ldr	r2, [r13, #20]
8f60cb68:	e0321001 	eors	r1, r2, r1
8f60cb6c:	e3a02000 	mov	r2, #0
8f60cb70:	1a000042 	bne	8f60cc80 <mmc_write+0x260>
8f60cb74:	e1a00003 	mov	r0, r3
8f60cb78:	e28dd01c 	add	r13, r13, #28
8f60cb7c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		dev = target_mmc_device();
8f60cb80:	ebffceae 	bl	8f600640 <target_mmc_device>
		return ufs_get_page_size((struct ufs_dev *)dev);
8f60cb84:	ebffff0d 	bl	8f60c7c0 <ufs_get_page_size>
8f60cb88:	e1a08000 	mov	r8, r0
8f60cb8c:	eaffffb5 	b	8f60ca68 <mmc_write+0x48>
		ret = ufs_write((struct ufs_dev *)dev, data_addr, (addr_t)in, (data_len / block_size));
8f60cb90:	e1a01008 	mov	r1, r8
8f60cb94:	e1a00005 	mov	r0, r5
8f60cb98:	fa00c00e 	blx	8f63cbd8 <__udivsi3>
8f60cb9c:	e1a02004 	mov	r2, r4
8f60cba0:	e58d6000 	str	r6, [r13]
8f60cba4:	e1a03000 	mov	r3, r0
8f60cba8:	e1a00009 	mov	r0, r9
8f60cbac:	e58d3004 	str	r3, [r13, #4]
8f60cbb0:	e1a03007 	mov	r3, r7
8f60cbb4:	ebfffedf 	bl	8f60c738 <ufs_write>
		if (ret)
8f60cbb8:	e3500000 	cmp	r0, #0
8f60cbbc:	1a00001d 	bne	8f60cc38 <mmc_write+0x218>
			val = 1;
8f60cbc0:	e3a03000 	mov	r3, #0
8f60cbc4:	eaffffe4 	b	8f60cb5c <mmc_write+0x13c>
		if (data_len)
8f60cbc8:	e3550000 	cmp	r5, #0
8f60cbcc:	0afffffb 	beq	8f60cbc0 <mmc_write+0x1a0>
			val = mmc_sdhci_write((struct mmc_device *)dev, (void *)sptr, (data_addr / block_size), (data_len / block_size));
8f60cbd0:	e1a02008 	mov	r2, r8
8f60cbd4:	e3a03000 	mov	r3, #0
8f60cbd8:	e1a00004 	mov	r0, r4
8f60cbdc:	e1a01007 	mov	r1, r7
8f60cbe0:	fa00c16f 	blx	8f63d1a4 <__aeabi_uldivmod>
8f60cbe4:	e1a04000 	mov	r4, r0
8f60cbe8:	e1a07001 	mov	r7, r1
8f60cbec:	e1a00005 	mov	r0, r5
8f60cbf0:	e1a01008 	mov	r1, r8
8f60cbf4:	fa00bff7 	blx	8f63cbd8 <__udivsi3>
8f60cbf8:	e1a03007 	mov	r3, r7
8f60cbfc:	e1a01006 	mov	r1, r6
8f60cc00:	e1a02000 	mov	r2, r0
8f60cc04:	e1a00009 	mov	r0, r9
8f60cc08:	e58d2000 	str	r2, [r13]
8f60cc0c:	e1a02004 	mov	r2, r4
8f60cc10:	ebfffc85 	bl	8f60be2c <mmc_sdhci_write>
		if (val)
8f60cc14:	e2503000 	subs	r3, r0, #0
8f60cc18:	0affffcf 	beq	8f60cb5c <mmc_write+0x13c>
			dprintf(CRITICAL, "Failed Writing block @ %x\n",(unsigned int)(data_addr / block_size));
8f60cc1c:	e1a01004 	mov	r1, r4
8f60cc20:	e303033c 	movw	r0, #13116	; 0x333c
8f60cc24:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60cc28:	e58d300c 	str	r3, [r13, #12]
8f60cc2c:	eb009750 	bl	8f632974 <_dprintf>
8f60cc30:	e59d300c 	ldr	r3, [r13, #12]
8f60cc34:	eaffffc8 	b	8f60cb5c <mmc_write+0x13c>
			dprintf(CRITICAL, "Error: UFS write failed writing to block: %llu\n", data_addr);
8f60cc38:	e1a03007 	mov	r3, r7
8f60cc3c:	e1a02004 	mov	r2, r4
8f60cc40:	e3030358 	movw	r0, #13144	; 0x3358
8f60cc44:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60cc48:	eb009749 	bl	8f632974 <_dprintf>
			val = 1;
8f60cc4c:	e3a03001 	mov	r3, #1
8f60cc50:	eaffffc1 	b	8f60cb5c <mmc_write+0x13c>
	ASSERT(!(data_addr % block_size));
8f60cc54:	e1a0000a 	mov	r0, r10
8f60cc58:	e3033320 	movw	r3, #13088	; 0x3320
8f60cc5c:	e30322fc 	movw	r2, #13052	; 0x32fc
8f60cc60:	e3483f70 	movt	r3, #36720	; 0x8f70
8f60cc64:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60cc68:	e58d3000 	str	r3, [r13]
8f60cc6c:	e3001130 	movw	r1, #304	; 0x130
8f60cc70:	e3a0307a 	mov	r3, #122	; 0x7a
8f60cc74:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60cc78:	eb00978f 	bl	8f632abc <_panic>
8f60cc7c:	eaffff80 	b	8f60ca84 <mmc_write+0x64>
}
8f60cc80:	eb0097ce 	bl	8f632bc0 <__stack_chk_fail>
8f60cc84:	8f74221c 	.word	0x8f74221c

8f60cc88 <mmc_read>:
{
8f60cc88:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f60cc8c:	e1a05003 	mov	r5, r3
8f60cc90:	e59f326c 	ldr	r3, [pc, #620]	; 8f60cf04 <mmc_read+0x27c>
8f60cc94:	e24dd01c 	sub	r13, r13, #28
8f60cc98:	e1a0b00e 	mov	r11, r14
8f60cc9c:	e1a08001 	mov	r8, r1
8f60cca0:	e5933000 	ldr	r3, [r3]
8f60cca4:	e58d3014 	str	r3, [r13, #20]
8f60cca8:	e3a03000 	mov	r3, #0
8f60ccac:	e1a06002 	mov	r6, r2
8f60ccb0:	e1a04000 	mov	r4, r0
	dev = target_mmc_device();
8f60ccb4:	ebffce61 	bl	8f600640 <target_mmc_device>
8f60ccb8:	e1a0a000 	mov	r10, r0
	if (platform_boot_dev_isemmc())
8f60ccbc:	eb005309 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f60ccc0:	e3500000 	cmp	r0, #0
8f60ccc4:	0a000044 	beq	8f60cddc <mmc_read+0x154>
	dev = target_mmc_device();
8f60ccc8:	ebffce5c 	bl	8f600640 <target_mmc_device>
		return card->block_size;
8f60cccc:	e5909040 	ldr	r9, [r0, #64]	; 0x40
	ASSERT(!(data_addr % block_size));
8f60ccd0:	e1a02009 	mov	r2, r9
8f60ccd4:	e3a03000 	mov	r3, #0
8f60ccd8:	e1a00004 	mov	r0, r4
8f60ccdc:	e1a01008 	mov	r1, r8
8f60cce0:	fa00c12f 	blx	8f63d1a4 <__aeabi_uldivmod>
8f60cce4:	e1923003 	orrs	r3, r2, r3
8f60cce8:	1a00006e 	bne	8f60cea8 <mmc_read+0x220>
	ASSERT(!(data_len % block_size));
8f60ccec:	e1a01009 	mov	r1, r9
8f60ccf0:	e1a00005 	mov	r0, r5
8f60ccf4:	fa00c04e 	blx	8f63ce34 <__aeabi_uidivmod>
8f60ccf8:	e3510000 	cmp	r1, #0
8f60ccfc:	e1a07000 	mov	r7, r0
8f60cd00:	1a000073 	bne	8f60ced4 <mmc_read+0x24c>
	arch_clean_invalidate_cache_range((addr_t)(out), data_len);
8f60cd04:	e1a01005 	mov	r1, r5
8f60cd08:	e1a00006 	mov	r0, r6
8f60cd0c:	eb0050a3 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	if (platform_boot_dev_isemmc())
8f60cd10:	eb0052f4 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f60cd14:	e3500000 	cmp	r0, #0
8f60cd18:	0a000033 	beq	8f60cdec <mmc_read+0x164>
		while (data_len > read_size) {
8f60cd1c:	e3a0bcfe 	mov	r11, #65024	; 0xfe00
8f60cd20:	e340b1ff 	movt	r11, #511	; 0x1ff
8f60cd24:	e155000b 	cmp	r5, r11
8f60cd28:	9a00003c 	bls	8f60ce20 <mmc_read+0x198>
			ret = mmc_sdhci_read((struct mmc_device *)dev, (void *)sptr, (data_addr / block_size), (read_size / block_size));
8f60cd2c:	e1a01009 	mov	r1, r9
8f60cd30:	e1a0000b 	mov	r0, r11
8f60cd34:	fa00bfa7 	blx	8f63cbd8 <__udivsi3>
8f60cd38:	e58d000c 	str	r0, [r13, #12]
8f60cd3c:	ea000009 	b	8f60cd68 <mmc_read+0xe0>
			data_len -= read_size;
8f60cd40:	e28554fe 	add	r5, r5, #-33554432	; 0xfe000000
			data_addr += read_size;
8f60cd44:	e3a03cfe 	mov	r3, #65024	; 0xfe00
8f60cd48:	e34031ff 	movt	r3, #511	; 0x1ff
			data_len -= read_size;
8f60cd4c:	e2855c02 	add	r5, r5, #512	; 0x200
			data_addr += read_size;
8f60cd50:	e0944003 	adds	r4, r4, r3
			sptr += read_size;
8f60cd54:	e2866402 	add	r6, r6, #33554432	; 0x2000000
			data_addr += read_size;
8f60cd58:	e2a88000 	adc	r8, r8, #0
		while (data_len > read_size) {
8f60cd5c:	e155000b 	cmp	r5, r11
			sptr += read_size;
8f60cd60:	e2466c02 	sub	r6, r6, #512	; 0x200
		while (data_len > read_size) {
8f60cd64:	9a000030 	bls	8f60ce2c <mmc_read+0x1a4>
			ret = mmc_sdhci_read((struct mmc_device *)dev, (void *)sptr, (data_addr / block_size), (read_size / block_size));
8f60cd68:	e1a02009 	mov	r2, r9
8f60cd6c:	e3a03000 	mov	r3, #0
8f60cd70:	e1a00004 	mov	r0, r4
8f60cd74:	e1a01008 	mov	r1, r8
8f60cd78:	fa00c109 	blx	8f63d1a4 <__aeabi_uldivmod>
8f60cd7c:	e1a03001 	mov	r3, r1
8f60cd80:	e59d100c 	ldr	r1, [r13, #12]
8f60cd84:	e1a02000 	mov	r2, r0
8f60cd88:	e1a07000 	mov	r7, r0
8f60cd8c:	e1a0000a 	mov	r0, r10
8f60cd90:	e58d1000 	str	r1, [r13]
8f60cd94:	e1a01006 	mov	r1, r6
8f60cd98:	ebfffb91 	bl	8f60bbe4 <mmc_sdhci_read>
			if (ret)
8f60cd9c:	e3500000 	cmp	r0, #0
8f60cda0:	0affffe6 	beq	8f60cd40 <mmc_read+0xb8>
				dprintf(CRITICAL, "Failed Reading block @ %x\n",(unsigned int) (data_addr / block_size));
8f60cda4:	e1a09000 	mov	r9, r0
8f60cda8:	e1a01007 	mov	r1, r7
8f60cdac:	e30303a4 	movw	r0, #13220	; 0x33a4
8f60cdb0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60cdb4:	eb0096ee 	bl	8f632974 <_dprintf>
}
8f60cdb8:	e59f3144 	ldr	r3, [pc, #324]	; 8f60cf04 <mmc_read+0x27c>
8f60cdbc:	e5932000 	ldr	r2, [r3]
8f60cdc0:	e59d3014 	ldr	r3, [r13, #20]
8f60cdc4:	e0332002 	eors	r2, r3, r2
8f60cdc8:	e3a03000 	mov	r3, #0
8f60cdcc:	1a00004b 	bne	8f60cf00 <mmc_read+0x278>
8f60cdd0:	e1a00009 	mov	r0, r9
8f60cdd4:	e28dd01c 	add	r13, r13, #28
8f60cdd8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		dev = target_mmc_device();
8f60cddc:	ebffce17 	bl	8f600640 <target_mmc_device>
		return ufs_get_page_size((struct ufs_dev *)dev);
8f60cde0:	ebfffe76 	bl	8f60c7c0 <ufs_get_page_size>
8f60cde4:	e1a09000 	mov	r9, r0
8f60cde8:	eaffffb8 	b	8f60ccd0 <mmc_read+0x48>
		ret = ufs_read((struct ufs_dev *) dev, data_addr, (addr_t)out, (data_len / block_size));
8f60cdec:	e1a03008 	mov	r3, r8
8f60cdf0:	e1a0000a 	mov	r0, r10
8f60cdf4:	e1a02004 	mov	r2, r4
8f60cdf8:	e58d7004 	str	r7, [r13, #4]
8f60cdfc:	e58d6000 	str	r6, [r13]
8f60ce00:	ebfffe5d 	bl	8f60c77c <ufs_read>
		if (ret)
8f60ce04:	e2503000 	subs	r3, r0, #0
8f60ce08:	e1a09003 	mov	r9, r3
8f60ce0c:	1a00001f 	bne	8f60ce90 <mmc_read+0x208>
		arch_invalidate_cache_range((addr_t)out, data_len);
8f60ce10:	e1a01005 	mov	r1, r5
8f60ce14:	e1a00006 	mov	r0, r6
8f60ce18:	eb00506a 	bl	8f620fc8 <arch_invalidate_cache_range>
8f60ce1c:	eaffffe5 	b	8f60cdb8 <mmc_read+0x130>
		if (data_len)
8f60ce20:	e3550000 	cmp	r5, #0
8f60ce24:	01a09005 	moveq	r9, r5
8f60ce28:	0affffe2 	beq	8f60cdb8 <mmc_read+0x130>
			ret = mmc_sdhci_read((struct mmc_device *)dev, (void *)sptr, (data_addr / block_size), (data_len / block_size));
8f60ce2c:	e1a02009 	mov	r2, r9
8f60ce30:	e3a03000 	mov	r3, #0
8f60ce34:	e1a00004 	mov	r0, r4
8f60ce38:	e1a01008 	mov	r1, r8
8f60ce3c:	fa00c0d8 	blx	8f63d1a4 <__aeabi_uldivmod>
8f60ce40:	e1a04000 	mov	r4, r0
8f60ce44:	e1a07001 	mov	r7, r1
8f60ce48:	e1a00005 	mov	r0, r5
8f60ce4c:	e1a01009 	mov	r1, r9
8f60ce50:	fa00bf60 	blx	8f63cbd8 <__udivsi3>
8f60ce54:	e1a03007 	mov	r3, r7
8f60ce58:	e1a01006 	mov	r1, r6
8f60ce5c:	e1a02000 	mov	r2, r0
8f60ce60:	e1a0000a 	mov	r0, r10
8f60ce64:	e58d2000 	str	r2, [r13]
8f60ce68:	e1a02004 	mov	r2, r4
8f60ce6c:	ebfffb5c 	bl	8f60bbe4 <mmc_sdhci_read>
		if (ret)
8f60ce70:	e2503000 	subs	r3, r0, #0
8f60ce74:	e1a09003 	mov	r9, r3
8f60ce78:	0affffce 	beq	8f60cdb8 <mmc_read+0x130>
			dprintf(CRITICAL, "Failed Reading block @ %x\n",(unsigned int) (data_addr / block_size));
8f60ce7c:	e1a01004 	mov	r1, r4
8f60ce80:	e30303a4 	movw	r0, #13220	; 0x33a4
8f60ce84:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60ce88:	eb0096b9 	bl	8f632974 <_dprintf>
8f60ce8c:	eaffffc9 	b	8f60cdb8 <mmc_read+0x130>
			dprintf(CRITICAL, "Error: UFS read failed writing to block: %llu\n", data_addr);
8f60ce90:	e1a02004 	mov	r2, r4
8f60ce94:	e1a03008 	mov	r3, r8
8f60ce98:	e30303c0 	movw	r0, #13248	; 0x33c0
8f60ce9c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60cea0:	eb0096b3 	bl	8f632974 <_dprintf>
8f60cea4:	eaffffd9 	b	8f60ce10 <mmc_read+0x188>
	ASSERT(!(data_addr % block_size));
8f60cea8:	e3033320 	movw	r3, #13088	; 0x3320
8f60ceac:	e30322fc 	movw	r2, #13052	; 0x32fc
8f60ceb0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f60ceb4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60ceb8:	e58d3000 	str	r3, [r13]
8f60cebc:	e3001130 	movw	r1, #304	; 0x130
8f60cec0:	e3a030bd 	mov	r3, #189	; 0xbd
8f60cec4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60cec8:	e1a0000b 	mov	r0, r11
8f60cecc:	eb0096fa 	bl	8f632abc <_panic>
8f60ced0:	eaffff85 	b	8f60ccec <mmc_read+0x64>
	ASSERT(!(data_len % block_size));
8f60ced4:	e1a0000b 	mov	r0, r11
8f60ced8:	e3033388 	movw	r3, #13192	; 0x3388
8f60cedc:	e30322fc 	movw	r2, #13052	; 0x32fc
8f60cee0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f60cee4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60cee8:	e58d3000 	str	r3, [r13]
8f60ceec:	e3001130 	movw	r1, #304	; 0x130
8f60cef0:	e3a030be 	mov	r3, #190	; 0xbe
8f60cef4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60cef8:	eb0096ef 	bl	8f632abc <_panic>
8f60cefc:	eaffff80 	b	8f60cd04 <mmc_read+0x7c>
}
8f60cf00:	eb00972e 	bl	8f632bc0 <__stack_chk_fail>
8f60cf04:	8f74221c 	.word	0x8f74221c

8f60cf08 <mmc_get_eraseunit_size>:
{
8f60cf08:	e59f3084 	ldr	r3, [pc, #132]	; 8f60cf94 <mmc_get_eraseunit_size+0x8c>
8f60cf0c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60cf10:	e24dd00c 	sub	r13, r13, #12
8f60cf14:	e5933000 	ldr	r3, [r3]
8f60cf18:	e58d3004 	str	r3, [r13, #4]
8f60cf1c:	e3a03000 	mov	r3, #0
	if (platform_boot_dev_isemmc()) {
8f60cf20:	eb005270 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f60cf24:	e3500000 	cmp	r0, #0
8f60cf28:	1a000007 	bne	8f60cf4c <mmc_get_eraseunit_size+0x44>
}
8f60cf2c:	e59f3060 	ldr	r3, [pc, #96]	; 8f60cf94 <mmc_get_eraseunit_size+0x8c>
8f60cf30:	e5932000 	ldr	r2, [r3]
8f60cf34:	e59d3004 	ldr	r3, [r13, #4]
8f60cf38:	e0332002 	eors	r2, r3, r2
8f60cf3c:	e3a03000 	mov	r3, #0
8f60cf40:	1a000012 	bne	8f60cf90 <mmc_get_eraseunit_size+0x88>
8f60cf44:	e28dd00c 	add	r13, r13, #12
8f60cf48:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		dev = target_mmc_device();
8f60cf4c:	ebffcdbb 	bl	8f600640 <target_mmc_device>
		if (MMC_CARD_MMC(card))
8f60cf50:	e5903050 	ldr	r3, [r0, #80]	; 0x50
8f60cf54:	e2433003 	sub	r3, r3, #3
8f60cf58:	e3530001 	cmp	r3, #1
			erase_unit_sz = dev->card.ssr.au_size * dev->card.ssr.num_aus;
8f60cf5c:	859030ec 	ldrhi	r3, [r0, #236]	; 0xec
8f60cf60:	859000f0 	ldrhi	r0, [r0, #240]	; 0xf0
8f60cf64:	80000390 	mulhi	r0, r0, r3
	return erase_unit_sz;
8f60cf68:	8affffef 	bhi	8f60cf2c <mmc_get_eraseunit_size+0x24>
			if (dev->card.ext_csd[MMC_ERASE_GRP_DEF])
8f60cf6c:	e5903058 	ldr	r3, [r0, #88]	; 0x58
8f60cf70:	e5d320af 	ldrb	r2, [r3, #175]	; 0xaf
8f60cf74:	e3520000 	cmp	r2, #0
				erase_unit_sz = (dev->card.csd.erase_grp_size + 1) * (dev->card.csd.erase_grp_mult + 1);
8f60cf78:	01c02cdc 	ldrdeq	r2, [r0, #204]	; 0xcc
				erase_unit_sz = (MMC_HC_ERASE_MULT * dev->card.ext_csd[MMC_HC_ERASE_GRP_SIZE]) / MMC_BLK_SZ;
8f60cf7c:	15d300e0 	ldrbne	r0, [r3, #224]	; 0xe0
				erase_unit_sz = (dev->card.csd.erase_grp_size + 1) * (dev->card.csd.erase_grp_mult + 1);
8f60cf80:	02830001 	addeq	r0, r3, #1
				erase_unit_sz = (MMC_HC_ERASE_MULT * dev->card.ext_csd[MMC_HC_ERASE_GRP_SIZE]) / MMC_BLK_SZ;
8f60cf84:	11a00500 	lslne	r0, r0, #10
				erase_unit_sz = (dev->card.csd.erase_grp_size + 1) * (dev->card.csd.erase_grp_mult + 1);
8f60cf88:	00200092 	mlaeq	r0, r2, r0, r0
8f60cf8c:	eaffffe6 	b	8f60cf2c <mmc_get_eraseunit_size+0x24>
}
8f60cf90:	eb00970a 	bl	8f632bc0 <__stack_chk_fail>
8f60cf94:	8f74221c 	.word	0x8f74221c

8f60cf98 <mmc_erase_card>:
{
8f60cf98:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f60cf9c:	e1a05003 	mov	r5, r3
8f60cfa0:	e59f3310 	ldr	r3, [pc, #784]	; 8f60d2b8 <mmc_erase_card+0x320>
8f60cfa4:	e24dd01c 	sub	r13, r13, #28
8f60cfa8:	e1a0a00e 	mov	r10, r14
8f60cfac:	e1a08000 	mov	r8, r0
8f60cfb0:	e5933000 	ldr	r3, [r3]
8f60cfb4:	e58d3014 	str	r3, [r13, #20]
8f60cfb8:	e3a03000 	mov	r3, #0
8f60cfbc:	e1a07001 	mov	r7, r1
8f60cfc0:	e1a0b002 	mov	r11, r2
	if (platform_boot_dev_isemmc())
8f60cfc4:	eb005247 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f60cfc8:	e3500000 	cmp	r0, #0
8f60cfcc:	0a000078 	beq	8f60d1b4 <mmc_erase_card+0x21c>
	dev = target_mmc_device();
8f60cfd0:	ebffcd9a 	bl	8f600640 <target_mmc_device>
		return card->block_size;
8f60cfd4:	e5906040 	ldr	r6, [r0, #64]	; 0x40
	dev = target_mmc_device();
8f60cfd8:	ebffcd98 	bl	8f600640 <target_mmc_device>
8f60cfdc:	e1a02006 	mov	r2, r6
8f60cfe0:	e3a03000 	mov	r3, #0
8f60cfe4:	e1a01007 	mov	r1, r7
8f60cfe8:	e1a09000 	mov	r9, r0
	ASSERT(!(addr % block_size));
8f60cfec:	e1a00008 	mov	r0, r8
8f60cff0:	fa00c06b 	blx	8f63d1a4 <__aeabi_uldivmod>
8f60cff4:	e1923003 	orrs	r3, r2, r3
8f60cff8:	e1a04000 	mov	r4, r0
8f60cffc:	1a000086 	bne	8f60d21c <mmc_erase_card+0x284>
	ASSERT(!(len % block_size));
8f60d000:	e1a01005 	mov	r1, r5
8f60d004:	e1a0000b 	mov	r0, r11
8f60d008:	e1a02006 	mov	r2, r6
8f60d00c:	e3a03000 	mov	r3, #0
8f60d010:	fa00c063 	blx	8f63d1a4 <__aeabi_uldivmod>
8f60d014:	e1923003 	orrs	r3, r2, r3
8f60d018:	e1a05000 	mov	r5, r0
8f60d01c:	1a000089 	bne	8f60d248 <mmc_erase_card+0x2b0>
	if (platform_boot_dev_isemmc())
8f60d020:	eb005230 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f60d024:	e3500000 	cmp	r0, #0
8f60d028:	0a000051 	beq	8f60d174 <mmc_erase_card+0x1dc>
		erase_unit_sz = mmc_get_eraseunit_size();
8f60d02c:	ebffffb5 	bl	8f60cf08 <mmc_get_eraseunit_size>
		blk_addr = addr / block_size;
8f60d030:	e1a0a004 	mov	r10, r4
		blk_count = len / block_size;
8f60d034:	e1a08005 	mov	r8, r5
		erase_unit_sz = mmc_get_eraseunit_size();
8f60d038:	e1a07000 	mov	r7, r0
		dprintf(SPEW, "erase_unit_sz:0x%x\n", erase_unit_sz);
8f60d03c:	e303041c 	movw	r0, #13340	; 0x341c
8f60d040:	e1a01007 	mov	r1, r7
8f60d044:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60d048:	eb009649 	bl	8f632974 <_dprintf>
		dprintf(INFO, "Erasing card: 0x%x:0x%x\n", blk_addr, blk_count);
8f60d04c:	e1a02005 	mov	r2, r5
8f60d050:	e1a01004 	mov	r1, r4
8f60d054:	e3030430 	movw	r0, #13360	; 0x3430
8f60d058:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60d05c:	eb009644 	bl	8f632974 <_dprintf>
8f60d060:	e1a01007 	mov	r1, r7
8f60d064:	e1a00004 	mov	r0, r4
8f60d068:	fa00bf71 	blx	8f63ce34 <__aeabi_uidivmod>
		head_unit = blk_addr / erase_unit_sz;
8f60d06c:	e58d000c 	str	r0, [r13, #12]
		tail_unit = (blk_addr + blk_count - 1) / erase_unit_sz;
8f60d070:	e0840005 	add	r0, r4, r5
8f60d074:	e2400001 	sub	r0, r0, #1
8f60d078:	e1a0b001 	mov	r11, r1
8f60d07c:	e1a01007 	mov	r1, r7
8f60d080:	fa00bed4 	blx	8f63cbd8 <__udivsi3>
		if (tail_unit - head_unit <= 1)
8f60d084:	e59d300c 	ldr	r3, [r13, #12]
8f60d088:	e0400003 	sub	r0, r0, r3
8f60d08c:	e3500001 	cmp	r0, #1
8f60d090:	9a00004b 	bls	8f60d1c4 <mmc_erase_card+0x22c>
		unaligned_blks = erase_unit_sz - (blk_addr % erase_unit_sz);
8f60d094:	e047200b 	sub	r2, r7, r11
		if (unaligned_blks < erase_unit_sz)
8f60d098:	e58d200c 	str	r2, [r13, #12]
8f60d09c:	e1570002 	cmp	r7, r2
8f60d0a0:	9a000017 	bls	8f60d104 <mmc_erase_card+0x16c>
			dprintf(SPEW, "Handling unaligned head blocks\n");
8f60d0a4:	e303046c 	movw	r0, #13420	; 0x346c
8f60d0a8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60d0ac:	eb009630 	bl	8f632974 <_dprintf>
			if (mmc_zero_out(dev, blk_addr, unaligned_blks))
8f60d0b0:	e59d200c 	ldr	r2, [r13, #12]
8f60d0b4:	e1a01004 	mov	r1, r4
8f60d0b8:	e1a00009 	mov	r0, r9
8f60d0bc:	ebfffdd0 	bl	8f60c804 <mmc_zero_out>
8f60d0c0:	e3500000 	cmp	r0, #0
8f60d0c4:	1a00004d 	bne	8f60d200 <mmc_erase_card+0x268>
			blk_addr += unaligned_blks;
8f60d0c8:	e59d200c 	ldr	r2, [r13, #12]
			blk_count -= unaligned_blks;
8f60d0cc:	e04b8007 	sub	r8, r11, r7
8f60d0d0:	e0858008 	add	r8, r5, r8
			tail_unit = (blk_addr + blk_count - 1) / erase_unit_sz;
8f60d0d4:	e1a01007 	mov	r1, r7
			blk_addr += unaligned_blks;
8f60d0d8:	e084a002 	add	r10, r4, r2
			tail_unit = (blk_addr + blk_count - 1) / erase_unit_sz;
8f60d0dc:	e08a0008 	add	r0, r10, r8
8f60d0e0:	e2400001 	sub	r0, r0, #1
8f60d0e4:	fa00bebb 	blx	8f63cbd8 <__udivsi3>
			head_unit = blk_addr / erase_unit_sz;
8f60d0e8:	e1a01007 	mov	r1, r7
			tail_unit = (blk_addr + blk_count - 1) / erase_unit_sz;
8f60d0ec:	e1a04000 	mov	r4, r0
			head_unit = blk_addr / erase_unit_sz;
8f60d0f0:	e1a0000a 	mov	r0, r10
8f60d0f4:	fa00beb7 	blx	8f63cbd8 <__udivsi3>
			if (tail_unit - head_unit <= 1)
8f60d0f8:	e0444000 	sub	r4, r4, r0
8f60d0fc:	e3540001 	cmp	r4, #1
8f60d100:	9a000060 	bls	8f60d288 <mmc_erase_card+0x2f0>
		unaligned_blks = blk_count % erase_unit_sz;
8f60d104:	e1a00008 	mov	r0, r8
8f60d108:	e1a01007 	mov	r1, r7
8f60d10c:	fa00bf48 	blx	8f63ce34 <__aeabi_uidivmod>
		dprintf(SPEW, "Performing SDHCI erase: 0x%x:0x%x\n", blk_addr,(unsigned int)blks_to_erase);
8f60d110:	e303048c 	movw	r0, #13452	; 0x348c
8f60d114:	e3480f70 	movt	r0, #36720	; 0x8f70
		blks_to_erase = blk_count - unaligned_blks;
8f60d118:	e0488001 	sub	r8, r8, r1
		unaligned_blks = blk_count % erase_unit_sz;
8f60d11c:	e1a04001 	mov	r4, r1
		dprintf(SPEW, "Performing SDHCI erase: 0x%x:0x%x\n", blk_addr,(unsigned int)blks_to_erase);
8f60d120:	e1a0100a 	mov	r1, r10
8f60d124:	e1a02008 	mov	r2, r8
8f60d128:	eb009611 	bl	8f632974 <_dprintf>
		if (mmc_sdhci_erase((struct mmc_device *)dev, blk_addr, blks_to_erase * block_size))
8f60d12c:	e0832896 	umull	r2, r3, r6, r8
8f60d130:	e1a0100a 	mov	r1, r10
8f60d134:	e1a00009 	mov	r0, r9
8f60d138:	ebfffbcf 	bl	8f60c07c <mmc_sdhci_erase>
8f60d13c:	e3500000 	cmp	r0, #0
8f60d140:	1a00004b 	bne	8f60d274 <mmc_erase_card+0x2dc>
		if (unaligned_blks)
8f60d144:	e3540000 	cmp	r4, #0
8f60d148:	0a000010 	beq	8f60d190 <mmc_erase_card+0x1f8>
			dprintf(SPEW, "Handling unaligned tail blocks\n");
8f60d14c:	e30304c4 	movw	r0, #13508	; 0x34c4
8f60d150:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60d154:	eb009606 	bl	8f632974 <_dprintf>
			if (mmc_zero_out(dev, blk_addr, unaligned_blks))
8f60d158:	e088100a 	add	r1, r8, r10
8f60d15c:	e1a02004 	mov	r2, r4
8f60d160:	e1a00009 	mov	r0, r9
8f60d164:	ebfffda6 	bl	8f60c804 <mmc_zero_out>
8f60d168:	e2500000 	subs	r0, r0, #0
8f60d16c:	13a00001 	movne	r0, #1
8f60d170:	ea000007 	b	8f60d194 <mmc_erase_card+0x1fc>
		if(ufs_erase((struct ufs_dev *)dev, addr, (len / block_size)))
8f60d174:	e1a02008 	mov	r2, r8
8f60d178:	e1a03007 	mov	r3, r7
8f60d17c:	e1a00009 	mov	r0, r9
8f60d180:	e58d5000 	str	r5, [r13]
8f60d184:	ebfffe03 	bl	8f60c998 <ufs_erase>
8f60d188:	e3500000 	cmp	r0, #0
8f60d18c:	1a00001d 	bne	8f60d208 <mmc_erase_card+0x270>
	return 0;
8f60d190:	e3a00000 	mov	r0, #0
}
8f60d194:	e59f311c 	ldr	r3, [pc, #284]	; 8f60d2b8 <mmc_erase_card+0x320>
8f60d198:	e5932000 	ldr	r2, [r3]
8f60d19c:	e59d3014 	ldr	r3, [r13, #20]
8f60d1a0:	e0332002 	eors	r2, r3, r2
8f60d1a4:	e3a03000 	mov	r3, #0
8f60d1a8:	1a000041 	bne	8f60d2b4 <mmc_erase_card+0x31c>
8f60d1ac:	e28dd01c 	add	r13, r13, #28
8f60d1b0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		dev = target_mmc_device();
8f60d1b4:	ebffcd21 	bl	8f600640 <target_mmc_device>
		return ufs_get_page_size((struct ufs_dev *)dev);
8f60d1b8:	ebfffd80 	bl	8f60c7c0 <ufs_get_page_size>
8f60d1bc:	e1a06000 	mov	r6, r0
8f60d1c0:	eaffff84 	b	8f60cfd8 <mmc_erase_card+0x40>
			dprintf(INFO, "SDHCI unit erase not required\n");
8f60d1c4:	e303044c 	movw	r0, #13388	; 0x344c
8f60d1c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60d1cc:	eb0095e8 	bl	8f632974 <_dprintf>
			return mmc_zero_out(dev, blk_addr, blk_count);
8f60d1d0:	e59f30e0 	ldr	r3, [pc, #224]	; 8f60d2b8 <mmc_erase_card+0x320>
8f60d1d4:	e5932000 	ldr	r2, [r3]
8f60d1d8:	e59d3014 	ldr	r3, [r13, #20]
8f60d1dc:	e0332002 	eors	r2, r3, r2
8f60d1e0:	e3a03000 	mov	r3, #0
8f60d1e4:	01a02005 	moveq	r2, r5
8f60d1e8:	01a01004 	moveq	r1, r4
8f60d1ec:	1a000030 	bne	8f60d2b4 <mmc_erase_card+0x31c>
				return mmc_zero_out(dev, blk_addr, blk_count);
8f60d1f0:	e1a00009 	mov	r0, r9
}
8f60d1f4:	e28dd01c 	add	r13, r13, #28
8f60d1f8:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
				return mmc_zero_out(dev, blk_addr, blk_count);
8f60d1fc:	eafffd80 	b	8f60c804 <mmc_zero_out>
				return 1;
8f60d200:	e3a00001 	mov	r0, #1
8f60d204:	eaffffe2 	b	8f60d194 <mmc_erase_card+0x1fc>
			dprintf(CRITICAL, "mmc_erase_card: UFS erase failed\n");
8f60d208:	e30304e4 	movw	r0, #13540	; 0x34e4
8f60d20c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60d210:	eb0095d7 	bl	8f632974 <_dprintf>
			return 1;
8f60d214:	e3a00001 	mov	r0, #1
8f60d218:	eaffffdd 	b	8f60d194 <mmc_erase_card+0x1fc>
	ASSERT(!(addr % block_size));
8f60d21c:	e30333f0 	movw	r3, #13296	; 0x33f0
8f60d220:	e30322fc 	movw	r2, #13052	; 0x32fc
8f60d224:	e3483f70 	movt	r3, #36720	; 0x8f70
8f60d228:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60d22c:	e58d3000 	str	r3, [r13]
8f60d230:	e3001130 	movw	r1, #304	; 0x130
8f60d234:	e3a03f56 	mov	r3, #344	; 0x158
8f60d238:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60d23c:	e1a0000a 	mov	r0, r10
8f60d240:	eb00961d 	bl	8f632abc <_panic>
8f60d244:	eaffff6d 	b	8f60d000 <mmc_erase_card+0x68>
	ASSERT(!(len % block_size));
8f60d248:	e1a0000a 	mov	r0, r10
8f60d24c:	e3033408 	movw	r3, #13320	; 0x3408
8f60d250:	e30322fc 	movw	r2, #13052	; 0x32fc
8f60d254:	e3483f70 	movt	r3, #36720	; 0x8f70
8f60d258:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60d25c:	e58d3000 	str	r3, [r13]
8f60d260:	e3001130 	movw	r1, #304	; 0x130
8f60d264:	e3003159 	movw	r3, #345	; 0x159
8f60d268:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60d26c:	eb009612 	bl	8f632abc <_panic>
8f60d270:	eaffff6a 	b	8f60d020 <mmc_erase_card+0x88>
			dprintf(CRITICAL, "MMC erase failed\n");
8f60d274:	e30304b0 	movw	r0, #13488	; 0x34b0
8f60d278:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60d27c:	eb0095bc 	bl	8f632974 <_dprintf>
			return 1;
8f60d280:	e3a00001 	mov	r0, #1
8f60d284:	eaffffc2 	b	8f60d194 <mmc_erase_card+0x1fc>
				dprintf(INFO, "SDHCI unit erase not required\n");
8f60d288:	e303044c 	movw	r0, #13388	; 0x344c
8f60d28c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60d290:	eb0095b7 	bl	8f632974 <_dprintf>
				return mmc_zero_out(dev, blk_addr, blk_count);
8f60d294:	e59f301c 	ldr	r3, [pc, #28]	; 8f60d2b8 <mmc_erase_card+0x320>
8f60d298:	e5932000 	ldr	r2, [r3]
8f60d29c:	e59d3014 	ldr	r3, [r13, #20]
8f60d2a0:	e0332002 	eors	r2, r3, r2
8f60d2a4:	e3a03000 	mov	r3, #0
8f60d2a8:	01a02008 	moveq	r2, r8
8f60d2ac:	01a0100a 	moveq	r1, r10
8f60d2b0:	0affffce 	beq	8f60d1f0 <mmc_erase_card+0x258>
}
8f60d2b4:	eb009641 	bl	8f632bc0 <__stack_chk_fail>
8f60d2b8:	8f74221c 	.word	0x8f74221c

8f60d2bc <mmc_get_psn>:
{
8f60d2bc:	e59f3054 	ldr	r3, [pc, #84]	; 8f60d318 <mmc_get_psn+0x5c>
8f60d2c0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60d2c4:	e24dd00c 	sub	r13, r13, #12
8f60d2c8:	e5933000 	ldr	r3, [r3]
8f60d2cc:	e58d3004 	str	r3, [r13, #4]
8f60d2d0:	e3a03000 	mov	r3, #0
	if (platform_boot_dev_isemmc())
8f60d2d4:	eb005183 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f60d2d8:	e3500000 	cmp	r0, #0
8f60d2dc:	0a000009 	beq	8f60d308 <mmc_get_psn+0x4c>
	dev = target_mmc_device();
8f60d2e0:	ebffccd6 	bl	8f600640 <target_mmc_device>
		return card->cid.psn;
8f60d2e4:	e5900090 	ldr	r0, [r0, #144]	; 0x90
}
8f60d2e8:	e59f3028 	ldr	r3, [pc, #40]	; 8f60d318 <mmc_get_psn+0x5c>
8f60d2ec:	e5932000 	ldr	r2, [r3]
8f60d2f0:	e59d3004 	ldr	r3, [r13, #4]
8f60d2f4:	e0332002 	eors	r2, r3, r2
8f60d2f8:	e3a03000 	mov	r3, #0
8f60d2fc:	1a000004 	bne	8f60d314 <mmc_get_psn+0x58>
8f60d300:	e28dd00c 	add	r13, r13, #12
8f60d304:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		dev = target_mmc_device();
8f60d308:	ebffcccc 	bl	8f600640 <target_mmc_device>
		return ufs_get_serial_num((struct ufs_dev *)dev);
8f60d30c:	ebfffd7e 	bl	8f60c90c <ufs_get_serial_num>
8f60d310:	eafffff4 	b	8f60d2e8 <mmc_get_psn+0x2c>
}
8f60d314:	eb009629 	bl	8f632bc0 <__stack_chk_fail>
8f60d318:	8f74221c 	.word	0x8f74221c

8f60d31c <mmc_get_device_capacity>:
{
8f60d31c:	e59f3054 	ldr	r3, [pc, #84]	; 8f60d378 <mmc_get_device_capacity+0x5c>
8f60d320:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60d324:	e24dd00c 	sub	r13, r13, #12
8f60d328:	e5933000 	ldr	r3, [r3]
8f60d32c:	e58d3004 	str	r3, [r13, #4]
8f60d330:	e3a03000 	mov	r3, #0
	if (platform_boot_dev_isemmc())
8f60d334:	eb00516b 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f60d338:	e3500000 	cmp	r0, #0
8f60d33c:	0a000009 	beq	8f60d368 <mmc_get_device_capacity+0x4c>
	dev = target_mmc_device();
8f60d340:	ebffccbe 	bl	8f600640 <target_mmc_device>
		return card->capacity;
8f60d344:	e1c004d8 	ldrd	r0, [r0, #72]	; 0x48
}
8f60d348:	e59f3028 	ldr	r3, [pc, #40]	; 8f60d378 <mmc_get_device_capacity+0x5c>
8f60d34c:	e5932000 	ldr	r2, [r3]
8f60d350:	e59d3004 	ldr	r3, [r13, #4]
8f60d354:	e0332002 	eors	r2, r3, r2
8f60d358:	e3a03000 	mov	r3, #0
8f60d35c:	1a000004 	bne	8f60d374 <mmc_get_device_capacity+0x58>
8f60d360:	e28dd00c 	add	r13, r13, #12
8f60d364:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		dev = target_mmc_device();
8f60d368:	ebffccb4 	bl	8f600640 <target_mmc_device>
		return ufs_get_dev_capacity((struct ufs_dev *)dev);
8f60d36c:	ebfffd77 	bl	8f60c950 <ufs_get_dev_capacity>
8f60d370:	eafffff4 	b	8f60d348 <mmc_get_device_capacity+0x2c>
}
8f60d374:	eb009611 	bl	8f632bc0 <__stack_chk_fail>
8f60d378:	8f74221c 	.word	0x8f74221c

8f60d37c <mmc_get_device_blocksize>:
{
8f60d37c:	e59f3054 	ldr	r3, [pc, #84]	; 8f60d3d8 <mmc_get_device_blocksize+0x5c>
8f60d380:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60d384:	e24dd00c 	sub	r13, r13, #12
8f60d388:	e5933000 	ldr	r3, [r3]
8f60d38c:	e58d3004 	str	r3, [r13, #4]
8f60d390:	e3a03000 	mov	r3, #0
	if (platform_boot_dev_isemmc())
8f60d394:	eb005153 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f60d398:	e3500000 	cmp	r0, #0
8f60d39c:	0a000009 	beq	8f60d3c8 <mmc_get_device_blocksize+0x4c>
	dev = target_mmc_device();
8f60d3a0:	ebffcca6 	bl	8f600640 <target_mmc_device>
		return card->block_size;
8f60d3a4:	e5900040 	ldr	r0, [r0, #64]	; 0x40
	}
}
8f60d3a8:	e59f3028 	ldr	r3, [pc, #40]	; 8f60d3d8 <mmc_get_device_blocksize+0x5c>
8f60d3ac:	e5932000 	ldr	r2, [r3]
8f60d3b0:	e59d3004 	ldr	r3, [r13, #4]
8f60d3b4:	e0332002 	eors	r2, r3, r2
8f60d3b8:	e3a03000 	mov	r3, #0
8f60d3bc:	1a000004 	bne	8f60d3d4 <mmc_get_device_blocksize+0x58>
8f60d3c0:	e28dd00c 	add	r13, r13, #12
8f60d3c4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		dev = target_mmc_device();
8f60d3c8:	ebffcc9c 	bl	8f600640 <target_mmc_device>
		return ufs_get_page_size((struct ufs_dev *)dev);
8f60d3cc:	ebfffcfb 	bl	8f60c7c0 <ufs_get_page_size>
8f60d3d0:	eafffff4 	b	8f60d3a8 <mmc_get_device_blocksize+0x2c>
}
8f60d3d4:	eb0095f9 	bl	8f632bc0 <__stack_chk_fail>
8f60d3d8:	8f74221c 	.word	0x8f74221c

8f60d3dc <mmc_page_size>:
 * Arg     : None
 * Return  : Returns the page size for the card
 * Flow    : Get the page size for storage
 */
uint32_t mmc_page_size()
{
8f60d3dc:	e59f304c 	ldr	r3, [pc, #76]	; 8f60d430 <mmc_page_size+0x54>
8f60d3e0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60d3e4:	e24dd00c 	sub	r13, r13, #12
8f60d3e8:	e5933000 	ldr	r3, [r3]
8f60d3ec:	e58d3004 	str	r3, [r13, #4]
8f60d3f0:	e3a03000 	mov	r3, #0
	if (platform_boot_dev_isemmc())
8f60d3f4:	eb00513b 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f60d3f8:	e3500000 	cmp	r0, #0
	{
		return BOARD_KERNEL_PAGESIZE;
8f60d3fc:	13a00b02 	movne	r0, #2048	; 0x800
	if (platform_boot_dev_isemmc())
8f60d400:	1a000001 	bne	8f60d40c <mmc_page_size+0x30>
	}
	else
	{
		void *dev;

		dev = target_mmc_device();
8f60d404:	ebffcc8d 	bl	8f600640 <target_mmc_device>

		return ufs_get_page_size((struct ufs_dev *)dev);
8f60d408:	ebfffcec 	bl	8f60c7c0 <ufs_get_page_size>
	}
}
8f60d40c:	e59f301c 	ldr	r3, [pc, #28]	; 8f60d430 <mmc_page_size+0x54>
8f60d410:	e5932000 	ldr	r2, [r3]
8f60d414:	e59d3004 	ldr	r3, [r13, #4]
8f60d418:	e0332002 	eors	r2, r3, r2
8f60d41c:	e3a03000 	mov	r3, #0
8f60d420:	1a000001 	bne	8f60d42c <mmc_page_size+0x50>
8f60d424:	e28dd00c 	add	r13, r13, #12
8f60d428:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60d42c:	eb0095e3 	bl	8f632bc0 <__stack_chk_fail>
8f60d430:	8f74221c 	.word	0x8f74221c

8f60d434 <mmc_set_lun>:
 * Function     : mmc set LUN for ufs
 * Arg          : LUN number
 * Return type  : void
 */
void mmc_set_lun(uint8_t lun)
{
8f60d434:	e59f304c 	ldr	r3, [pc, #76]	; 8f60d488 <mmc_set_lun+0x54>
8f60d438:	e92d4030 	push	{r4, r5, r14}
8f60d43c:	e24dd00c 	sub	r13, r13, #12
8f60d440:	e5933000 	ldr	r3, [r3]
8f60d444:	e58d3004 	str	r3, [r13, #4]
8f60d448:	e3a03000 	mov	r3, #0
8f60d44c:	e1a05000 	mov	r5, r0
	void *dev;
	dev = target_mmc_device();
8f60d450:	ebffcc7a 	bl	8f600640 <target_mmc_device>
8f60d454:	e1a04000 	mov	r4, r0

	if (!platform_boot_dev_isemmc())
8f60d458:	eb005122 	bl	8f6218e8 <platform_boot_dev_isemmc>
	{
		((struct ufs_dev*)dev)->current_lun = lun;
	}
}
8f60d45c:	e59f3024 	ldr	r3, [pc, #36]	; 8f60d488 <mmc_set_lun+0x54>
	if (!platform_boot_dev_isemmc())
8f60d460:	e3500000 	cmp	r0, #0
		((struct ufs_dev*)dev)->current_lun = lun;
8f60d464:	05c45009 	strbeq	r5, [r4, #9]
}
8f60d468:	e5932000 	ldr	r2, [r3]
8f60d46c:	e59d3004 	ldr	r3, [r13, #4]
8f60d470:	e0332002 	eors	r2, r3, r2
8f60d474:	e3a03000 	mov	r3, #0
8f60d478:	1a000001 	bne	8f60d484 <mmc_set_lun+0x50>
8f60d47c:	e28dd00c 	add	r13, r13, #12
8f60d480:	e8bd8030 	pop	{r4, r5, r15}
8f60d484:	eb0095cd 	bl	8f632bc0 <__stack_chk_fail>
8f60d488:	8f74221c 	.word	0x8f74221c

8f60d48c <mmc_get_lun>:
 * Function     : mmc get LUN from ufs
 * Arg          : LUN number
 * Return type  : lun number for UFS and 0 for emmc
 */
uint8_t mmc_get_lun(void)
{
8f60d48c:	e59f304c 	ldr	r3, [pc, #76]	; 8f60d4e0 <mmc_get_lun+0x54>
8f60d490:	e92d4010 	push	{r4, r14}
8f60d494:	e24dd008 	sub	r13, r13, #8
8f60d498:	e5933000 	ldr	r3, [r3]
8f60d49c:	e58d3004 	str	r3, [r13, #4]
8f60d4a0:	e3a03000 	mov	r3, #0
	void *dev;
	uint8_t lun=0;

	dev = target_mmc_device();
8f60d4a4:	ebffcc65 	bl	8f600640 <target_mmc_device>
8f60d4a8:	e1a04000 	mov	r4, r0

	if (!platform_boot_dev_isemmc())
8f60d4ac:	eb00510d 	bl	8f6218e8 <platform_boot_dev_isemmc>
	{
		lun = ((struct ufs_dev*)dev)->current_lun;
	}

	return lun;
}
8f60d4b0:	e59f3028 	ldr	r3, [pc, #40]	; 8f60d4e0 <mmc_get_lun+0x54>
	if (!platform_boot_dev_isemmc())
8f60d4b4:	e3500000 	cmp	r0, #0
		lun = ((struct ufs_dev*)dev)->current_lun;
8f60d4b8:	05d40009 	ldrbeq	r0, [r4, #9]
	uint8_t lun=0;
8f60d4bc:	13a00000 	movne	r0, #0
}
8f60d4c0:	e5932000 	ldr	r2, [r3]
8f60d4c4:	e59d3004 	ldr	r3, [r13, #4]
8f60d4c8:	e0332002 	eors	r2, r3, r2
8f60d4cc:	e3a03000 	mov	r3, #0
8f60d4d0:	1a000001 	bne	8f60d4dc <mmc_get_lun+0x50>
8f60d4d4:	e28dd008 	add	r13, r13, #8
8f60d4d8:	e8bd8010 	pop	{r4, r15}
8f60d4dc:	eb0095b7 	bl	8f632bc0 <__stack_chk_fail>
8f60d4e0:	8f74221c 	.word	0x8f74221c

8f60d4e4 <menu_volume_down_func>:
	}
}

/* update select option's background when volume down key is pressed */
static void menu_volume_down_func (struct select_msg_info* msg_info)
{
8f60d4e4:	e59f3108 	ldr	r3, [pc, #264]	; 8f60d5f4 <menu_volume_down_func+0x110>
8f60d4e8:	e92d4010 	push	{r4, r14}
8f60d4ec:	e24dd008 	sub	r13, r13, #8
8f60d4f0:	e5933000 	ldr	r3, [r3]
8f60d4f4:	e58d3004 	str	r3, [r13, #4]
8f60d4f8:	e3a03000 	mov	r3, #0
	msg_info->info.option_index++;
8f60d4fc:	e5903040 	ldr	r3, [r0, #64]	; 0x40
	if (msg_info->info.option_index >= msg_info->info.option_num)
8f60d500:	e590103c 	ldr	r1, [r0, #60]	; 0x3c
{
8f60d504:	e1a04000 	mov	r4, r0
	msg_info->info.option_index++;
8f60d508:	e2832001 	add	r2, r3, #1
8f60d50c:	e5802040 	str	r2, [r0, #64]	; 0x40
	if (msg_info->info.option_index >= msg_info->info.option_num)
8f60d510:	e1520001 	cmp	r2, r1
8f60d514:	3a000022 	bcc	8f60d5a4 <menu_volume_down_func+0xc0>
		msg_info->info.option_index = 0;

	if (msg_info->info.msg_type == DISPLAY_MENU_FASTBOOT) {
8f60d518:	e5903044 	ldr	r3, [r0, #68]	; 0x44
		msg_info->info.option_index = 0;
8f60d51c:	e3a02000 	mov	r2, #0
8f60d520:	e5802040 	str	r2, [r0, #64]	; 0x40
	if (msg_info->info.msg_type == DISPLAY_MENU_FASTBOOT) {
8f60d524:	e3530005 	cmp	r3, #5
8f60d528:	0a000013 	beq	8f60d57c <menu_volume_down_func+0x98>
		fbcon_draw_msg_background(msg_info->info.option_start[0],
8f60d52c:	e5942028 	ldr	r2, [r4, #40]	; 0x28
8f60d530:	e3a03001 	mov	r3, #1
8f60d534:	e5940000 	ldr	r0, [r4]
8f60d538:	e5941014 	ldr	r1, [r4, #20]
8f60d53c:	eb0089c0 	bl	8f62fc44 <fbcon_draw_msg_background>
		fbcon_draw_msg_background(msg_info->info.option_start[msg_info->info.option_num - 1],
8f60d540:	e59f30ac 	ldr	r3, [pc, #172]	; 8f60d5f4 <menu_volume_down_func+0x110>
8f60d544:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
8f60d548:	e5932000 	ldr	r2, [r3]
8f60d54c:	e59d3004 	ldr	r3, [r13, #4]
8f60d550:	e0332002 	eors	r2, r3, r2
8f60d554:	e3a03000 	mov	r3, #0
8f60d558:	e0844100 	add	r4, r4, r0, lsl #2
8f60d55c:	1a000023 	bne	8f60d5f0 <menu_volume_down_func+0x10c>
		fbcon_draw_msg_background(msg_info->info.option_start[msg_info->info.option_index - 1],
8f60d560:	e5942024 	ldr	r2, [r4, #36]	; 0x24
8f60d564:	e3a03000 	mov	r3, #0
8f60d568:	e5941010 	ldr	r1, [r4, #16]
8f60d56c:	e5140004 	ldr	r0, [r4, #-4]
		display_fastboot_menu_renew(msg_info);
	} else {
		update_volume_down_bg(msg_info);
	}
}
8f60d570:	e28dd008 	add	r13, r13, #8
8f60d574:	e8bd4010 	pop	{r4, r14}
		fbcon_draw_msg_background(msg_info->info.option_start[msg_info->info.option_index - 1],
8f60d578:	ea0089b1 	b	8f62fc44 <fbcon_draw_msg_background>
		display_fastboot_menu_renew(msg_info);
8f60d57c:	e59f3070 	ldr	r3, [pc, #112]	; 8f60d5f4 <menu_volume_down_func+0x110>
8f60d580:	e5932000 	ldr	r2, [r3]
8f60d584:	e59d3004 	ldr	r3, [r13, #4]
8f60d588:	e0332002 	eors	r2, r3, r2
8f60d58c:	e3a03000 	mov	r3, #0
8f60d590:	1a000016 	bne	8f60d5f0 <menu_volume_down_func+0x10c>
8f60d594:	e1a00004 	mov	r0, r4
}
8f60d598:	e28dd008 	add	r13, r13, #8
8f60d59c:	e8bd4010 	pop	{r4, r14}
		display_fastboot_menu_renew(msg_info);
8f60d5a0:	ea000292 	b	8f60dff0 <display_fastboot_menu_renew>
	if (msg_info->info.msg_type == DISPLAY_MENU_FASTBOOT) {
8f60d5a4:	e5901044 	ldr	r1, [r0, #68]	; 0x44
8f60d5a8:	e3510005 	cmp	r1, #5
8f60d5ac:	0afffff2 	beq	8f60d57c <menu_volume_down_func+0x98>
	if (msg_info->info.option_index == 0) {
8f60d5b0:	e3520000 	cmp	r2, #0
8f60d5b4:	0affffdc 	beq	8f60d52c <menu_volume_down_func+0x48>
		fbcon_draw_msg_background(msg_info->info.option_start[msg_info->info.option_index],
8f60d5b8:	e0800103 	add	r0, r0, r3, lsl #2
8f60d5bc:	e3a03001 	mov	r3, #1
8f60d5c0:	e590202c 	ldr	r2, [r0, #44]	; 0x2c
8f60d5c4:	e5901018 	ldr	r1, [r0, #24]
8f60d5c8:	e5900004 	ldr	r0, [r0, #4]
8f60d5cc:	eb00899c 	bl	8f62fc44 <fbcon_draw_msg_background>
		fbcon_draw_msg_background(msg_info->info.option_start[msg_info->info.option_index - 1],
8f60d5d0:	e59f301c 	ldr	r3, [pc, #28]	; 8f60d5f4 <menu_volume_down_func+0x110>
8f60d5d4:	e5940040 	ldr	r0, [r4, #64]	; 0x40
8f60d5d8:	e5932000 	ldr	r2, [r3]
8f60d5dc:	e59d3004 	ldr	r3, [r13, #4]
8f60d5e0:	e0332002 	eors	r2, r3, r2
8f60d5e4:	e3a03000 	mov	r3, #0
8f60d5e8:	e0844100 	add	r4, r4, r0, lsl #2
8f60d5ec:	0affffdb 	beq	8f60d560 <menu_volume_down_func+0x7c>
8f60d5f0:	eb009572 	bl	8f632bc0 <__stack_chk_fail>
8f60d5f4:	8f74221c 	.word	0x8f74221c

8f60d5f8 <menu_volume_up_func>:
{
8f60d5f8:	e59f3128 	ldr	r3, [pc, #296]	; 8f60d728 <menu_volume_up_func+0x130>
8f60d5fc:	e92d4010 	push	{r4, r14}
8f60d600:	e24dd008 	sub	r13, r13, #8
8f60d604:	e5933000 	ldr	r3, [r3]
8f60d608:	e58d3004 	str	r3, [r13, #4]
8f60d60c:	e3a03000 	mov	r3, #0
	if (msg_info->info.option_index == 0)
8f60d610:	e5903040 	ldr	r3, [r0, #64]	; 0x40
{
8f60d614:	e1a04000 	mov	r4, r0
	if (msg_info->info.option_index == 0)
8f60d618:	e3530000 	cmp	r3, #0
8f60d61c:	1a00000f 	bne	8f60d660 <menu_volume_up_func+0x68>
	if (msg_info->info.msg_type == DISPLAY_MENU_FASTBOOT) {
8f60d620:	e5902044 	ldr	r2, [r0, #68]	; 0x44
		msg_info->info.option_index = msg_info->info.option_num - 1;
8f60d624:	e590303c 	ldr	r3, [r0, #60]	; 0x3c
	if (msg_info->info.msg_type == DISPLAY_MENU_FASTBOOT) {
8f60d628:	e3520005 	cmp	r2, #5
		msg_info->info.option_index = msg_info->info.option_num - 1;
8f60d62c:	e2433001 	sub	r3, r3, #1
8f60d630:	e5803040 	str	r3, [r0, #64]	; 0x40
	if (msg_info->info.msg_type == DISPLAY_MENU_FASTBOOT) {
8f60d634:	1a000026 	bne	8f60d6d4 <menu_volume_up_func+0xdc>
		display_fastboot_menu_renew(msg_info);
8f60d638:	e59f30e8 	ldr	r3, [pc, #232]	; 8f60d728 <menu_volume_up_func+0x130>
8f60d63c:	e5932000 	ldr	r2, [r3]
8f60d640:	e59d3004 	ldr	r3, [r13, #4]
8f60d644:	e0332002 	eors	r2, r3, r2
8f60d648:	e3a03000 	mov	r3, #0
8f60d64c:	1a000034 	bne	8f60d724 <menu_volume_up_func+0x12c>
8f60d650:	e1a00004 	mov	r0, r4
}
8f60d654:	e28dd008 	add	r13, r13, #8
8f60d658:	e8bd4010 	pop	{r4, r14}
		display_fastboot_menu_renew(msg_info);
8f60d65c:	ea000263 	b	8f60dff0 <display_fastboot_menu_renew>
	if (msg_info->info.msg_type == DISPLAY_MENU_FASTBOOT) {
8f60d660:	e5901044 	ldr	r1, [r0, #68]	; 0x44
		msg_info->info.option_index--;
8f60d664:	e2432001 	sub	r2, r3, #1
8f60d668:	e5802040 	str	r2, [r0, #64]	; 0x40
	if (msg_info->info.msg_type == DISPLAY_MENU_FASTBOOT) {
8f60d66c:	e3510005 	cmp	r1, #5
8f60d670:	0afffff0 	beq	8f60d638 <menu_volume_up_func+0x40>
	if (msg_info->info.option_index == msg_info->info.option_num - 1) {
8f60d674:	e590103c 	ldr	r1, [r0, #60]	; 0x3c
8f60d678:	e1530001 	cmp	r3, r1
8f60d67c:	0a000014 	beq	8f60d6d4 <menu_volume_up_func+0xdc>
		fbcon_draw_msg_background(msg_info->info.option_start[msg_info->info.option_index],
8f60d680:	e0801102 	add	r1, r0, r2, lsl #2
8f60d684:	e3a03001 	mov	r3, #1
8f60d688:	e7900102 	ldr	r0, [r0, r2, lsl #2]
8f60d68c:	e5912028 	ldr	r2, [r1, #40]	; 0x28
8f60d690:	e5911014 	ldr	r1, [r1, #20]
8f60d694:	eb00896a 	bl	8f62fc44 <fbcon_draw_msg_background>
		fbcon_draw_msg_background(msg_info->info.option_start[msg_info->info.option_index + 1],
8f60d698:	e59f3088 	ldr	r3, [pc, #136]	; 8f60d728 <menu_volume_up_func+0x130>
8f60d69c:	e5940040 	ldr	r0, [r4, #64]	; 0x40
8f60d6a0:	e5932000 	ldr	r2, [r3]
8f60d6a4:	e59d3004 	ldr	r3, [r13, #4]
8f60d6a8:	e0332002 	eors	r2, r3, r2
8f60d6ac:	e3a03000 	mov	r3, #0
8f60d6b0:	e0844100 	add	r4, r4, r0, lsl #2
8f60d6b4:	1a00001a 	bne	8f60d724 <menu_volume_up_func+0x12c>
8f60d6b8:	e594202c 	ldr	r2, [r4, #44]	; 0x2c
8f60d6bc:	e3a03000 	mov	r3, #0
8f60d6c0:	e5941018 	ldr	r1, [r4, #24]
8f60d6c4:	e5940004 	ldr	r0, [r4, #4]
}
8f60d6c8:	e28dd008 	add	r13, r13, #8
8f60d6cc:	e8bd4010 	pop	{r4, r14}
		fbcon_draw_msg_background(msg_info->info.option_start[msg_info->info.option_index + 1],
8f60d6d0:	ea00895b 	b	8f62fc44 <fbcon_draw_msg_background>
		fbcon_draw_msg_background(msg_info->info.option_start[0],
8f60d6d4:	e5942028 	ldr	r2, [r4, #40]	; 0x28
8f60d6d8:	e3a03000 	mov	r3, #0
8f60d6dc:	e5940000 	ldr	r0, [r4]
8f60d6e0:	e5941014 	ldr	r1, [r4, #20]
8f60d6e4:	eb008956 	bl	8f62fc44 <fbcon_draw_msg_background>
		fbcon_draw_msg_background(msg_info->info.option_start[msg_info->info.option_num - 1],
8f60d6e8:	e59f3038 	ldr	r3, [pc, #56]	; 8f60d728 <menu_volume_up_func+0x130>
8f60d6ec:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
8f60d6f0:	e5932000 	ldr	r2, [r3]
8f60d6f4:	e59d3004 	ldr	r3, [r13, #4]
8f60d6f8:	e0332002 	eors	r2, r3, r2
8f60d6fc:	e3a03000 	mov	r3, #0
8f60d700:	e0844100 	add	r4, r4, r0, lsl #2
8f60d704:	1a000006 	bne	8f60d724 <menu_volume_up_func+0x12c>
8f60d708:	e5942024 	ldr	r2, [r4, #36]	; 0x24
8f60d70c:	e3a03001 	mov	r3, #1
8f60d710:	e5941010 	ldr	r1, [r4, #16]
8f60d714:	e5140004 	ldr	r0, [r4, #-4]
}
8f60d718:	e28dd008 	add	r13, r13, #8
8f60d71c:	e8bd4010 	pop	{r4, r14}
		fbcon_draw_msg_background(msg_info->info.option_start[msg_info->info.option_index + 1],
8f60d720:	ea008947 	b	8f62fc44 <fbcon_draw_msg_background>
8f60d724:	eb009525 	bl	8f632bc0 <__stack_chk_fail>
8f60d728:	8f74221c 	.word	0x8f74221c

8f60d72c <power_key_func>:
	display_bootverify_option_menu_renew(msg_info);
}

/* update device's status via select option */
static void power_key_func(struct select_msg_info* msg_info)
{
8f60d72c:	e59f3224 	ldr	r3, [pc, #548]	; 8f60d958 <power_key_func+0x22c>
8f60d730:	e92d4030 	push	{r4, r5, r14}
8f60d734:	e24dd014 	sub	r13, r13, #20
8f60d738:	e5933000 	ldr	r3, [r3]
8f60d73c:	e58d300c 	str	r3, [r13, #12]
8f60d740:	e3a03000 	mov	r3, #0
	int reason = -1;

	switch (msg_info->info.msg_type) {
8f60d744:	e5903044 	ldr	r3, [r0, #68]	; 0x44
{
8f60d748:	e1a04000 	mov	r4, r0
	switch (msg_info->info.msg_type) {
8f60d74c:	e353000a 	cmp	r3, #10
8f60d750:	979ff103 	ldrls	r15, [r15, r3, lsl #2]
8f60d754:	ea000074 	b	8f60d92c <power_key_func+0x200>
8f60d758:	8f60d794 	.word	0x8f60d794
8f60d75c:	8f60d794 	.word	0x8f60d794
8f60d760:	8f60d794 	.word	0x8f60d794
8f60d764:	8f60d80c 	.word	0x8f60d80c
8f60d768:	8f60d7c0 	.word	0x8f60d7c0
8f60d76c:	8f60d828 	.word	0x8f60d828
8f60d770:	8f60d7c0 	.word	0x8f60d7c0
8f60d774:	8f60d794 	.word	0x8f60d794
8f60d778:	8f60d784 	.word	0x8f60d784
8f60d77c:	8f60d7c0 	.word	0x8f60d7c0
8f60d780:	8f60d7c0 	.word	0x8f60d7c0
		case DISPLAY_MENU_RED:
		case DISPLAY_MENU_LOGGING:
			reason = CONTINUE;
			break;
		case DISPLAY_MENU_EIO:
			pwr_key_is_pressed = true;
8f60d784:	e3003690 	movw	r3, #1680	; 0x690
8f60d788:	e3483f74 	movt	r3, #36724	; 0x8f74
8f60d78c:	e3a02001 	mov	r2, #1
8f60d790:	e5832000 	str	r2, [r3]
	fbcon_clear();
8f60d794:	eb008a13 	bl	8f62ffe8 <fbcon_clear>
			msg_info->info.is_exit = true;
8f60d798:	e3a03001 	mov	r3, #1
8f60d79c:	e584304c 	str	r3, [r4, #76]	; 0x4c
	}

	if (reason != -1) {
		update_device_status(msg_info, reason);
	}
}
8f60d7a0:	e59f31b0 	ldr	r3, [pc, #432]	; 8f60d958 <power_key_func+0x22c>
8f60d7a4:	e5932000 	ldr	r2, [r3]
8f60d7a8:	e59d300c 	ldr	r3, [r13, #12]
8f60d7ac:	e0332002 	eors	r2, r3, r2
8f60d7b0:	e3a03000 	mov	r3, #0
8f60d7b4:	1a00004a 	bne	8f60d8e4 <power_key_func+0x1b8>
8f60d7b8:	e28dd014 	add	r13, r13, #20
8f60d7bc:	e8bd8030 	pop	{r4, r5, r15}
			if(msg_info->info.option_index < ARRAY_SIZE(unlock_index_action))
8f60d7c0:	e5903040 	ldr	r3, [r0, #64]	; 0x40
8f60d7c4:	e3530001 	cmp	r3, #1
8f60d7c8:	8afffff4 	bhi	8f60d7a0 <power_key_func+0x74>
				reason = unlock_index_action[msg_info->info.option_index];
8f60d7cc:	e30325c0 	movw	r2, #13760	; 0x35c0
8f60d7d0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60d7d4:	e7925103 	ldr	r5, [r2, r3, lsl #2]
	if (reason != -1) {
8f60d7d8:	e3750001 	cmn	r5, #1
8f60d7dc:	0affffef 	beq	8f60d7a0 <power_key_func+0x74>
	fbcon_clear();
8f60d7e0:	eb008a00 	bl	8f62ffe8 <fbcon_clear>
	switch (reason) {
8f60d7e4:	e3550006 	cmp	r5, #6
8f60d7e8:	979ff105 	ldrls	r15, [r15, r5, lsl #2]
8f60d7ec:	eaffffeb 	b	8f60d7a0 <power_key_func+0x74>
8f60d7f0:	8f60d908 	.word	0x8f60d908
8f60d7f4:	8f60d8e8 	.word	0x8f60d8e8
8f60d7f8:	8f60d8c0 	.word	0x8f60d8c0
8f60d7fc:	8f60d898 	.word	0x8f60d898
8f60d800:	8f60d884 	.word	0x8f60d884
8f60d804:	8f60d798 	.word	0x8f60d798
8f60d808:	8f60d844 	.word	0x8f60d844
			if(msg_info->info.option_index < ARRAY_SIZE(verify_index_action))
8f60d80c:	e5903040 	ldr	r3, [r0, #64]	; 0x40
8f60d810:	e3530004 	cmp	r3, #4
8f60d814:	8affffe1 	bhi	8f60d7a0 <power_key_func+0x74>
				reason = verify_index_action[msg_info->info.option_index];
8f60d818:	e30325c8 	movw	r2, #13768	; 0x35c8
8f60d81c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60d820:	e7925103 	ldr	r5, [r2, r3, lsl #2]
8f60d824:	eaffffeb 	b	8f60d7d8 <power_key_func+0xac>
			if(msg_info->info.option_index < ARRAY_SIZE(fastboot_index_action))
8f60d828:	e5903040 	ldr	r3, [r0, #64]	; 0x40
8f60d82c:	e3530004 	cmp	r3, #4
8f60d830:	8affffda 	bhi	8f60d7a0 <power_key_func+0x74>
				reason = fastboot_index_action[msg_info->info.option_index];
8f60d834:	e3032528 	movw	r2, #13608	; 0x3528
8f60d838:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60d83c:	e7925103 	ldr	r5, [r2, r3, lsl #2]
8f60d840:	eaffffe4 	b	8f60d7d8 <power_key_func+0xac>
			memset(&ffbm_page_buffer, 0, sizeof(ffbm_page_buffer));
8f60d844:	e28d0004 	add	r0, r13, #4
8f60d848:	e3a02008 	mov	r2, #8
8f60d84c:	e3a01000 	mov	r1, #0
8f60d850:	eb009a9b 	bl	8f6342c4 <memset>
			snprintf(ffbm_page_buffer, sizeof(ffbm_page_buffer), "ffbm-00");
8f60d854:	e28d0004 	add	r0, r13, #4
8f60d858:	e3a01008 	mov	r1, #8
8f60d85c:	e3032520 	movw	r2, #13600	; 0x3520
8f60d860:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60d864:	eb0099b5 	bl	8f633f40 <snprintf>
			write_misc(0, ffbm_page_buffer, sizeof(ffbm_page_buffer));
8f60d868:	e28d1004 	add	r1, r13, #4
8f60d86c:	e3a02008 	mov	r2, #8
8f60d870:	e3a00000 	mov	r0, #0
8f60d874:	eb0087b0 	bl	8f62f73c <write_misc>
			reboot_device(0);
8f60d878:	e3a00000 	mov	r0, #0
8f60d87c:	eb004aa5 	bl	8f620318 <reboot_device>
}
8f60d880:	eaffffc6 	b	8f60d7a0 <power_key_func+0x74>
			before_time = current_time();
8f60d884:	eb0004fa 	bl	8f60ec74 <current_time>
8f60d888:	e30c3cc0 	movw	r3, #52416	; 0xccc0
8f60d88c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f60d890:	e5830000 	str	r0, [r3]
			break;
8f60d894:	eaffffc1 	b	8f60d7a0 <power_key_func+0x74>
			reboot_device(FASTBOOT_MODE);
8f60d898:	e59f30b8 	ldr	r3, [pc, #184]	; 8f60d958 <power_key_func+0x22c>
8f60d89c:	e5932000 	ldr	r2, [r3]
8f60d8a0:	e59d300c 	ldr	r3, [r13, #12]
8f60d8a4:	e0332002 	eors	r2, r3, r2
8f60d8a8:	e3a03000 	mov	r3, #0
8f60d8ac:	03a00002 	moveq	r0, #2
8f60d8b0:	1a00000b 	bne	8f60d8e4 <power_key_func+0x1b8>
}
8f60d8b4:	e28dd014 	add	r13, r13, #20
8f60d8b8:	e8bd4030 	pop	{r4, r5, r14}
			reboot_device(FASTBOOT_MODE);
8f60d8bc:	ea004a95 	b	8f620318 <reboot_device>
			reset_device_unlock_status(msg_info->info.msg_type);
8f60d8c0:	e5940044 	ldr	r0, [r4, #68]	; 0x44
8f60d8c4:	eb000151 	bl	8f60de10 <reset_device_unlock_status>
			reboot_device(RECOVERY_MODE);
8f60d8c8:	e59f3088 	ldr	r3, [pc, #136]	; 8f60d958 <power_key_func+0x22c>
8f60d8cc:	e5932000 	ldr	r2, [r3]
8f60d8d0:	e59d300c 	ldr	r3, [r13, #12]
8f60d8d4:	e0332002 	eors	r2, r3, r2
8f60d8d8:	e3a03000 	mov	r3, #0
8f60d8dc:	03a00001 	moveq	r0, #1
8f60d8e0:	0afffff3 	beq	8f60d8b4 <power_key_func+0x188>
}
8f60d8e4:	eb0094b5 	bl	8f632bc0 <__stack_chk_fail>
			reboot_device(0);
8f60d8e8:	e59f3068 	ldr	r3, [pc, #104]	; 8f60d958 <power_key_func+0x22c>
8f60d8ec:	e5932000 	ldr	r2, [r3]
8f60d8f0:	e59d300c 	ldr	r3, [r13, #12]
8f60d8f4:	e0332002 	eors	r2, r3, r2
8f60d8f8:	e3a03000 	mov	r3, #0
8f60d8fc:	03a00000 	moveq	r0, #0
8f60d900:	0affffeb 	beq	8f60d8b4 <power_key_func+0x188>
8f60d904:	eafffff6 	b	8f60d8e4 <power_key_func+0x1b8>
			shutdown_device();
8f60d908:	e59f3048 	ldr	r3, [pc, #72]	; 8f60d958 <power_key_func+0x22c>
8f60d90c:	e5932000 	ldr	r2, [r3]
8f60d910:	e59d300c 	ldr	r3, [r13, #12]
8f60d914:	e0332002 	eors	r2, r3, r2
8f60d918:	e3a03000 	mov	r3, #0
8f60d91c:	1afffff0 	bne	8f60d8e4 <power_key_func+0x1b8>
}
8f60d920:	e28dd014 	add	r13, r13, #20
8f60d924:	e8bd4030 	pop	{r4, r5, r14}
			shutdown_device();
8f60d928:	ea004ab8 	b	8f620410 <shutdown_device>
			dprintf(CRITICAL,"Unsupported menu type\n");
8f60d92c:	e59f3024 	ldr	r3, [pc, #36]	; 8f60d958 <power_key_func+0x22c>
8f60d930:	e5932000 	ldr	r2, [r3]
8f60d934:	e59d300c 	ldr	r3, [r13, #12]
8f60d938:	e0332002 	eors	r2, r3, r2
8f60d93c:	e3a03000 	mov	r3, #0
8f60d940:	1affffe7 	bne	8f60d8e4 <power_key_func+0x1b8>
8f60d944:	e3030508 	movw	r0, #13576	; 0x3508
8f60d948:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f60d94c:	e28dd014 	add	r13, r13, #20
8f60d950:	e8bd4030 	pop	{r4, r5, r14}
			dprintf(CRITICAL,"Unsupported menu type\n");
8f60d954:	ea009406 	b	8f632974 <_dprintf>
8f60d958:	8f74221c 	.word	0x8f74221c

8f60d95c <boot_warning_volume_keys_func>:
{
8f60d95c:	e59f3040 	ldr	r3, [pc, #64]	; 8f60d9a4 <boot_warning_volume_keys_func+0x48>
8f60d960:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60d964:	e24dd00c 	sub	r13, r13, #12
	msg_info->last_msg_type = msg_info->info.msg_type;
8f60d968:	e5902044 	ldr	r2, [r0, #68]	; 0x44
{
8f60d96c:	e5933000 	ldr	r3, [r3]
8f60d970:	e58d3004 	str	r3, [r13, #4]
8f60d974:	e3a03000 	mov	r3, #0
	display_bootverify_option_menu_renew(msg_info);
8f60d978:	e59f3024 	ldr	r3, [pc, #36]	; 8f60d9a4 <boot_warning_volume_keys_func+0x48>
	msg_info->last_msg_type = msg_info->info.msg_type;
8f60d97c:	e5802054 	str	r2, [r0, #84]	; 0x54
	display_bootverify_option_menu_renew(msg_info);
8f60d980:	e5932000 	ldr	r2, [r3]
8f60d984:	e59d3004 	ldr	r3, [r13, #4]
8f60d988:	e0332002 	eors	r2, r3, r2
8f60d98c:	e3a03000 	mov	r3, #0
8f60d990:	1a000002 	bne	8f60d9a0 <boot_warning_volume_keys_func+0x44>
}
8f60d994:	e28dd00c 	add	r13, r13, #12
8f60d998:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	display_bootverify_option_menu_renew(msg_info);
8f60d99c:	ea000145 	b	8f60deb8 <display_bootverify_option_menu_renew>
8f60d9a0:	eb009486 	bl	8f632bc0 <__stack_chk_fail>
8f60d9a4:	8f74221c 	.word	0x8f74221c

8f60d9a8 <keys_detect_init>:
	},

};

void keys_detect_init()
{
8f60d9a8:	e59f3088 	ldr	r3, [pc, #136]	; 8f60da38 <keys_detect_init+0x90>
8f60d9ac:	e92d4010 	push	{r4, r14}
8f60d9b0:	e24dd008 	sub	r13, r13, #8
8f60d9b4:	e30142f0 	movw	r4, #4848	; 0x12f0
8f60d9b8:	e5933000 	ldr	r3, [r3]
8f60d9bc:	e58d3004 	str	r3, [r13, #4]
8f60d9c0:	e3a03000 	mov	r3, #0
8f60d9c4:	e3484f71 	movt	r4, #36721	; 0x8f71
8f60d9c8:	ea000001 	b	8f60d9d4 <keys_detect_init+0x2c>
		if(!keys[VOLUME_UP].keys_pressed_func() &&
			!keys[VOLUME_DOWN].keys_pressed_func() &&
			!keys[POWER_KEY].keys_pressed_func()) {
			break;
		}
		thread_sleep(KEY_DETECT_FREQUENCY);
8f60d9cc:	e3a00032 	mov	r0, #50	; 0x32
8f60d9d0:	eb005a2c 	bl	8f624288 <thread_sleep>
		if(!keys[VOLUME_UP].keys_pressed_func() &&
8f60d9d4:	e5943004 	ldr	r3, [r4, #4]
8f60d9d8:	e12fff33 	blx	r3
8f60d9dc:	e3500000 	cmp	r0, #0
8f60d9e0:	1afffff9 	bne	8f60d9cc <keys_detect_init+0x24>
			!keys[VOLUME_DOWN].keys_pressed_func() &&
8f60d9e4:	e594300c 	ldr	r3, [r4, #12]
8f60d9e8:	e12fff33 	blx	r3
		if(!keys[VOLUME_UP].keys_pressed_func() &&
8f60d9ec:	e3500000 	cmp	r0, #0
8f60d9f0:	1afffff5 	bne	8f60d9cc <keys_detect_init+0x24>
			!keys[POWER_KEY].keys_pressed_func()) {
8f60d9f4:	e5943014 	ldr	r3, [r4, #20]
8f60d9f8:	e12fff33 	blx	r3
			!keys[VOLUME_DOWN].keys_pressed_func() &&
8f60d9fc:	e3500000 	cmp	r0, #0
8f60da00:	1afffff1 	bne	8f60d9cc <keys_detect_init+0x24>
	}

	before_time = current_time();
8f60da04:	eb00049a 	bl	8f60ec74 <current_time>
8f60da08:	e30c3cc0 	movw	r3, #52416	; 0xccc0
8f60da0c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f60da10:	e5830000 	str	r0, [r3]
}
8f60da14:	e59f301c 	ldr	r3, [pc, #28]	; 8f60da38 <keys_detect_init+0x90>
8f60da18:	e5932000 	ldr	r2, [r3]
8f60da1c:	e59d3004 	ldr	r3, [r13, #4]
8f60da20:	e0332002 	eors	r2, r3, r2
8f60da24:	e3a03000 	mov	r3, #0
8f60da28:	1a000001 	bne	8f60da34 <keys_detect_init+0x8c>
8f60da2c:	e28dd008 	add	r13, r13, #8
8f60da30:	e8bd8010 	pop	{r4, r15}
8f60da34:	eb009461 	bl	8f632bc0 <__stack_chk_fail>
8f60da38:	8f74221c 	.word	0x8f74221c

8f60da3c <select_msg_keys_detect>:

int select_msg_keys_detect(void *param) {
8f60da3c:	e59f31e4 	ldr	r3, [pc, #484]	; 8f60dc28 <select_msg_keys_detect+0x1ec>
8f60da40:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f60da44:	e24dd00c 	sub	r13, r13, #12
8f60da48:	e1a06000 	mov	r6, r0
8f60da4c:	e5933000 	ldr	r3, [r3]
8f60da50:	e58d3004 	str	r3, [r13, #4]
8f60da54:	e3a03000 	mov	r3, #0
	struct select_msg_info *msg_info = (struct select_msg_info*)param;

	msg_lock_init();
8f60da58:	e30152f0 	movw	r5, #4848	; 0x12f0
8f60da5c:	eb000286 	bl	8f60e47c <msg_lock_init>
		 *	eg: 5->0
		 * 2: update device's status via select option's index
		 */
		if (is_key_pressed(VOLUME_UP)) {
			mutex_acquire(&msg_info->msg_lock);
			menu_pages_action[msg_info->info.msg_type].up_action_func(msg_info);
8f60da60:	e303853c 	movw	r8, #13628	; 0x353c
		}

		mutex_acquire(&msg_info->msg_lock);
		/* Never time out if the timeout_time is 0 */
		if(msg_info->info.timeout_time) {
			if ((current_time() - before_time) > msg_info->info.timeout_time)
8f60da64:	e30c9cc0 	movw	r9, #52416	; 0xccc0
	keys_detect_init();
8f60da68:	ebffffce 	bl	8f60d9a8 <keys_detect_init>
			mutex_acquire(&msg_info->msg_lock);
8f60da6c:	e2867058 	add	r7, r6, #88	; 0x58
8f60da70:	e3485f71 	movt	r5, #36721	; 0x8f71
			menu_pages_action[msg_info->info.msg_type].up_action_func(msg_info);
8f60da74:	e3488f70 	movt	r8, #36720	; 0x8f70
			if ((current_time() - before_time) > msg_info->info.timeout_time)
8f60da78:	e3489f72 	movt	r9, #36722	; 0x8f72
8f60da7c:	ea000013 	b	8f60dad0 <select_msg_keys_detect+0x94>
	if (keys[keys_type].keys_pressed_func()) {
8f60da80:	e595300c 	ldr	r3, [r5, #12]
8f60da84:	e12fff33 	blx	r3
8f60da88:	e3500000 	cmp	r0, #0
8f60da8c:	1a00003c 	bne	8f60db84 <select_msg_keys_detect+0x148>
8f60da90:	e5953014 	ldr	r3, [r5, #20]
8f60da94:	e12fff33 	blx	r3
8f60da98:	e3500000 	cmp	r0, #0
8f60da9c:	1a00004c 	bne	8f60dbd4 <select_msg_keys_detect+0x198>
		mutex_acquire(&msg_info->msg_lock);
8f60daa0:	e1a00007 	mov	r0, r7
8f60daa4:	eb005548 	bl	8f622fcc <mutex_acquire>
		if(msg_info->info.timeout_time) {
8f60daa8:	e5963048 	ldr	r3, [r6, #72]	; 0x48
8f60daac:	e3530000 	cmp	r3, #0
8f60dab0:	1a00001e 	bne	8f60db30 <select_msg_keys_detect+0xf4>
				msg_info->info.is_exit = true;
		}

		if (msg_info->info.is_exit) {
8f60dab4:	e596304c 	ldr	r3, [r6, #76]	; 0x4c
8f60dab8:	e3530000 	cmp	r3, #0
8f60dabc:	1a000023 	bne	8f60db50 <select_msg_keys_detect+0x114>
			msg_info->info.rel_exit = true;
			mutex_release(&msg_info->msg_lock);
			break;
		}
		mutex_release(&msg_info->msg_lock);
8f60dac0:	e1a00007 	mov	r0, r7
8f60dac4:	eb00558e 	bl	8f623104 <mutex_release>
		thread_sleep(KEY_DETECT_FREQUENCY);
8f60dac8:	e3a00032 	mov	r0, #50	; 0x32
8f60dacc:	eb0059ed 	bl	8f624288 <thread_sleep>
	if (keys[keys_type].keys_pressed_func()) {
8f60dad0:	e5953004 	ldr	r3, [r5, #4]
8f60dad4:	e12fff33 	blx	r3
8f60dad8:	e3500000 	cmp	r0, #0
8f60dadc:	0affffe7 	beq	8f60da80 <select_msg_keys_detect+0x44>
8f60dae0:	e3a0400a 	mov	r4, #10
		while(count++ < 10 && keys[keys_type].keys_pressed_func())
8f60dae4:	e5953004 	ldr	r3, [r5, #4]
8f60dae8:	e12fff33 	blx	r3
8f60daec:	e3500000 	cmp	r0, #0
8f60daf0:	0a000003 	beq	8f60db04 <select_msg_keys_detect+0xc8>
			thread_sleep(100);
8f60daf4:	e3a00064 	mov	r0, #100	; 0x64
8f60daf8:	eb0059e2 	bl	8f624288 <thread_sleep>
		while(count++ < 10 && keys[keys_type].keys_pressed_func())
8f60dafc:	e2544001 	subs	r4, r4, #1
8f60db00:	1afffff7 	bne	8f60dae4 <select_msg_keys_detect+0xa8>
			mutex_acquire(&msg_info->msg_lock);
8f60db04:	e1a00007 	mov	r0, r7
8f60db08:	eb00552f 	bl	8f622fcc <mutex_acquire>
			menu_pages_action[msg_info->info.msg_type].up_action_func(msg_info);
8f60db0c:	e5963044 	ldr	r3, [r6, #68]	; 0x44
8f60db10:	e3a0200c 	mov	r2, #12
8f60db14:	e1a00006 	mov	r0, r6
8f60db18:	e0030392 	mul	r3, r2, r3
8f60db1c:	e7983003 	ldr	r3, [r8, r3]
8f60db20:	e12fff33 	blx	r3
			mutex_release(&msg_info->msg_lock);
8f60db24:	e1a00007 	mov	r0, r7
8f60db28:	eb005575 	bl	8f623104 <mutex_release>
8f60db2c:	eaffffdb 	b	8f60daa0 <select_msg_keys_detect+0x64>
			if ((current_time() - before_time) > msg_info->info.timeout_time)
8f60db30:	eb00044f 	bl	8f60ec74 <current_time>
8f60db34:	e5992000 	ldr	r2, [r9]
8f60db38:	e5963048 	ldr	r3, [r6, #72]	; 0x48
8f60db3c:	e0400002 	sub	r0, r0, r2
8f60db40:	e1500003 	cmp	r0, r3
8f60db44:	9affffda 	bls	8f60dab4 <select_msg_keys_detect+0x78>
				msg_info->info.is_exit = true;
8f60db48:	e3a03001 	mov	r3, #1
8f60db4c:	e586304c 	str	r3, [r6, #76]	; 0x4c
			msg_info->info.rel_exit = true;
8f60db50:	e3a03001 	mov	r3, #1
			mutex_release(&msg_info->msg_lock);
8f60db54:	e1a00007 	mov	r0, r7
			msg_info->info.rel_exit = true;
8f60db58:	e5863050 	str	r3, [r6, #80]	; 0x50
			mutex_release(&msg_info->msg_lock);
8f60db5c:	eb005568 	bl	8f623104 <mutex_release>
	}

	return 0;
}
8f60db60:	e59f30c0 	ldr	r3, [pc, #192]	; 8f60dc28 <select_msg_keys_detect+0x1ec>
8f60db64:	e5932000 	ldr	r2, [r3]
8f60db68:	e59d3004 	ldr	r3, [r13, #4]
8f60db6c:	e0332002 	eors	r2, r3, r2
8f60db70:	e3a03000 	mov	r3, #0
8f60db74:	1a00002a 	bne	8f60dc24 <select_msg_keys_detect+0x1e8>
8f60db78:	e3a00000 	mov	r0, #0
8f60db7c:	e28dd00c 	add	r13, r13, #12
8f60db80:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
8f60db84:	e3a0400a 	mov	r4, #10
		while(count++ < 10 && keys[keys_type].keys_pressed_func())
8f60db88:	e595300c 	ldr	r3, [r5, #12]
8f60db8c:	e12fff33 	blx	r3
8f60db90:	e3500000 	cmp	r0, #0
8f60db94:	0a000003 	beq	8f60dba8 <select_msg_keys_detect+0x16c>
			thread_sleep(100);
8f60db98:	e3a00064 	mov	r0, #100	; 0x64
8f60db9c:	eb0059b9 	bl	8f624288 <thread_sleep>
		while(count++ < 10 && keys[keys_type].keys_pressed_func())
8f60dba0:	e2544001 	subs	r4, r4, #1
8f60dba4:	1afffff7 	bne	8f60db88 <select_msg_keys_detect+0x14c>
			mutex_acquire(&msg_info->msg_lock);
8f60dba8:	e1a00007 	mov	r0, r7
8f60dbac:	eb005506 	bl	8f622fcc <mutex_acquire>
			menu_pages_action[msg_info->info.msg_type].down_action_func(msg_info);
8f60dbb0:	e5963044 	ldr	r3, [r6, #68]	; 0x44
8f60dbb4:	e3a0200c 	mov	r2, #12
8f60dbb8:	e1a00006 	mov	r0, r6
8f60dbbc:	e0238392 	mla	r3, r2, r3, r8
8f60dbc0:	e5933004 	ldr	r3, [r3, #4]
8f60dbc4:	e12fff33 	blx	r3
			mutex_release(&msg_info->msg_lock);
8f60dbc8:	e1a00007 	mov	r0, r7
8f60dbcc:	eb00554c 	bl	8f623104 <mutex_release>
8f60dbd0:	eaffffb2 	b	8f60daa0 <select_msg_keys_detect+0x64>
8f60dbd4:	e3a0400a 	mov	r4, #10
		while(count++ < 10 && keys[keys_type].keys_pressed_func())
8f60dbd8:	e5953014 	ldr	r3, [r5, #20]
8f60dbdc:	e12fff33 	blx	r3
8f60dbe0:	e3500000 	cmp	r0, #0
8f60dbe4:	0a000003 	beq	8f60dbf8 <select_msg_keys_detect+0x1bc>
			thread_sleep(100);
8f60dbe8:	e3a00064 	mov	r0, #100	; 0x64
8f60dbec:	eb0059a5 	bl	8f624288 <thread_sleep>
		while(count++ < 10 && keys[keys_type].keys_pressed_func())
8f60dbf0:	e2544001 	subs	r4, r4, #1
8f60dbf4:	1afffff7 	bne	8f60dbd8 <select_msg_keys_detect+0x19c>
			mutex_acquire(&msg_info->msg_lock);
8f60dbf8:	e1a00007 	mov	r0, r7
8f60dbfc:	eb0054f2 	bl	8f622fcc <mutex_acquire>
			menu_pages_action[msg_info->info.msg_type].enter_action_func(msg_info);
8f60dc00:	e5963044 	ldr	r3, [r6, #68]	; 0x44
8f60dc04:	e3a0200c 	mov	r2, #12
8f60dc08:	e1a00006 	mov	r0, r6
8f60dc0c:	e0238392 	mla	r3, r2, r3, r8
8f60dc10:	e5933008 	ldr	r3, [r3, #8]
8f60dc14:	e12fff33 	blx	r3
			mutex_release(&msg_info->msg_lock);
8f60dc18:	e1a00007 	mov	r0, r7
8f60dc1c:	eb005538 	bl	8f623104 <mutex_release>
8f60dc20:	eaffff9e 	b	8f60daa0 <select_msg_keys_detect+0x64>
}
8f60dc24:	eb0093e5 	bl	8f632bc0 <__stack_chk_fail>
8f60dc28:	8f74221c 	.word	0x8f74221c

8f60dc2c <wait_for_exit>:

static int big_factor = 2;
static int common_factor = 1;

static void wait_for_exit()
{
8f60dc2c:	e92d4030 	push	{r4, r5, r14}
	struct select_msg_info *select_msg;
	select_msg = &msg_info;

	mutex_acquire(&select_msg->msg_lock);
8f60dc30:	e30c5ccc 	movw	r5, #52428	; 0xcccc
{
8f60dc34:	e59f3090 	ldr	r3, [pc, #144]	; 8f60dccc <wait_for_exit+0xa0>
	mutex_acquire(&select_msg->msg_lock);
8f60dc38:	e3485f72 	movt	r5, #36722	; 0x8f72
{
8f60dc3c:	e24dd00c 	sub	r13, r13, #12
	mutex_acquire(&select_msg->msg_lock);
8f60dc40:	e2850058 	add	r0, r5, #88	; 0x58
{
8f60dc44:	e5933000 	ldr	r3, [r3]
8f60dc48:	e58d3004 	str	r3, [r13, #4]
8f60dc4c:	e3a03000 	mov	r3, #0
	mutex_acquire(&select_msg->msg_lock);
8f60dc50:	eb0054dd 	bl	8f622fcc <mutex_acquire>
	while(!select_msg->info.rel_exit == true) {
8f60dc54:	e5953050 	ldr	r3, [r5, #80]	; 0x50
8f60dc58:	e3530000 	cmp	r3, #0
8f60dc5c:	1a000009 	bne	8f60dc88 <wait_for_exit+0x5c>
		mutex_release(&select_msg->msg_lock);
8f60dc60:	e2854058 	add	r4, r5, #88	; 0x58
8f60dc64:	e1a00004 	mov	r0, r4
8f60dc68:	eb005525 	bl	8f623104 <mutex_release>
		thread_sleep(10);
8f60dc6c:	e3a0000a 	mov	r0, #10
8f60dc70:	eb005984 	bl	8f624288 <thread_sleep>
		mutex_acquire(&select_msg->msg_lock);
8f60dc74:	e1a00004 	mov	r0, r4
8f60dc78:	eb0054d3 	bl	8f622fcc <mutex_acquire>
	while(!select_msg->info.rel_exit == true) {
8f60dc7c:	e5953050 	ldr	r3, [r5, #80]	; 0x50
8f60dc80:	e3530000 	cmp	r3, #0
8f60dc84:	0afffff6 	beq	8f60dc64 <wait_for_exit+0x38>
	}
	mutex_release(&select_msg->msg_lock);
8f60dc88:	e59f0040 	ldr	r0, [pc, #64]	; 8f60dcd0 <wait_for_exit+0xa4>
8f60dc8c:	eb00551c 	bl	8f623104 <mutex_release>

	is_thread_start = false;
8f60dc90:	e30c3cc8 	movw	r3, #52424	; 0xccc8
8f60dc94:	e3483f72 	movt	r3, #36722	; 0x8f72
8f60dc98:	e3a02000 	mov	r2, #0
8f60dc9c:	e5832000 	str	r2, [r3]
	fbcon_clear();
8f60dca0:	eb0088d0 	bl	8f62ffe8 <fbcon_clear>
	display_image_on_screen();
8f60dca4:	e59f3020 	ldr	r3, [pc, #32]	; 8f60dccc <wait_for_exit+0xa0>
8f60dca8:	e5932000 	ldr	r2, [r3]
8f60dcac:	e59d3004 	ldr	r3, [r13, #4]
8f60dcb0:	e0332002 	eors	r2, r3, r2
8f60dcb4:	e3a03000 	mov	r3, #0
8f60dcb8:	1a000002 	bne	8f60dcc8 <wait_for_exit+0x9c>
}
8f60dcbc:	e28dd00c 	add	r13, r13, #12
8f60dcc0:	e8bd4030 	pop	{r4, r5, r14}
	display_image_on_screen();
8f60dcc4:	ea008b60 	b	8f630a4c <display_image_on_screen>
8f60dcc8:	eb0093bc 	bl	8f632bc0 <__stack_chk_fail>
8f60dccc:	8f74221c 	.word	0x8f74221c
8f60dcd0:	8f72cd24 	.word	0x8f72cd24

8f60dcd4 <set_message_factor>:

	wait_for_exit();
}

static void set_message_factor()
{
8f60dcd4:	e59f30a0 	ldr	r3, [pc, #160]	; 8f60dd7c <set_message_factor+0xa8>
8f60dcd8:	e92d4010 	push	{r4, r14}
8f60dcdc:	e24dd008 	sub	r13, r13, #8
8f60dce0:	e5933000 	ldr	r3, [r3]
8f60dce4:	e58d3004 	str	r3, [r13, #4]
8f60dce8:	e3a03000 	mov	r3, #0
	uint32_t tmp_factor = 0;
	uint32_t max_x_count = 0;
	uint32_t max_x = 0;

	if (fbcon_get_width() < fbcon_get_height())
8f60dcec:	eb0089e4 	bl	8f630484 <fbcon_get_width>
8f60dcf0:	e1a04000 	mov	r4, r0
8f60dcf4:	eb0089f7 	bl	8f6304d8 <fbcon_get_height>
		max_x_count = CHAR_NUM_PERROW_POR;
	else
		max_x_count = CHAR_NUM_PERROW_HOR;
8f60dcf8:	e1540000 	cmp	r4, r0
8f60dcfc:	33a0402d 	movcc	r4, #45	; 0x2d
8f60dd00:	23a04050 	movcs	r4, #80	; 0x50

	max_x = fbcon_get_max_x();
8f60dd04:	eb0089cb 	bl	8f630438 <fbcon_get_max_x>
	tmp_factor = max_x/max_x_count;
8f60dd08:	e1a01004 	mov	r1, r4
8f60dd0c:	fa00bbb1 	blx	8f63cbd8 <__udivsi3>

	if(tmp_factor <= 1) {
8f60dd10:	e3500001 	cmp	r0, #1
8f60dd14:	9a00000e 	bls	8f60dd54 <set_message_factor+0x80>
		big_factor = 2;
		common_factor = 1;
	} else {
		big_factor = tmp_factor*2;
8f60dd18:	e3013308 	movw	r3, #4872	; 0x1308
		common_factor = tmp_factor;
8f60dd1c:	e301230c 	movw	r2, #4876	; 0x130c
		big_factor = tmp_factor*2;
8f60dd20:	e3483f71 	movt	r3, #36721	; 0x8f71
		common_factor = tmp_factor;
8f60dd24:	e3482f71 	movt	r2, #36721	; 0x8f71
		big_factor = tmp_factor*2;
8f60dd28:	e1a01080 	lsl	r1, r0, #1
		common_factor = tmp_factor;
8f60dd2c:	e5820000 	str	r0, [r2]
		big_factor = tmp_factor*2;
8f60dd30:	e5831000 	str	r1, [r3]
	}
}
8f60dd34:	e59f3040 	ldr	r3, [pc, #64]	; 8f60dd7c <set_message_factor+0xa8>
8f60dd38:	e5932000 	ldr	r2, [r3]
8f60dd3c:	e59d3004 	ldr	r3, [r13, #4]
8f60dd40:	e0332002 	eors	r2, r3, r2
8f60dd44:	e3a03000 	mov	r3, #0
8f60dd48:	1a00000a 	bne	8f60dd78 <set_message_factor+0xa4>
8f60dd4c:	e28dd008 	add	r13, r13, #8
8f60dd50:	e8bd8010 	pop	{r4, r15}
		big_factor = 2;
8f60dd54:	e3012308 	movw	r2, #4872	; 0x1308
		common_factor = 1;
8f60dd58:	e301330c 	movw	r3, #4876	; 0x130c
		big_factor = 2;
8f60dd5c:	e3482f71 	movt	r2, #36721	; 0x8f71
		common_factor = 1;
8f60dd60:	e3483f71 	movt	r3, #36721	; 0x8f71
		big_factor = 2;
8f60dd64:	e3a00002 	mov	r0, #2
		common_factor = 1;
8f60dd68:	e3a01001 	mov	r1, #1
		big_factor = 2;
8f60dd6c:	e5820000 	str	r0, [r2]
		common_factor = 1;
8f60dd70:	e5831000 	str	r1, [r3]
8f60dd74:	eaffffee 	b	8f60dd34 <set_message_factor+0x60>
}
8f60dd78:	eb009390 	bl	8f632bc0 <__stack_chk_fail>
8f60dd7c:	8f74221c 	.word	0x8f74221c

8f60dd80 <exit_menu_keys_detection>:
{
8f60dd80:	e59f3084 	ldr	r3, [pc, #132]	; 8f60de0c <exit_menu_keys_detection+0x8c>
8f60dd84:	e92d4010 	push	{r4, r14}
8f60dd88:	e24dd008 	sub	r13, r13, #8
8f60dd8c:	e5933000 	ldr	r3, [r3]
8f60dd90:	e58d3004 	str	r3, [r13, #4]
8f60dd94:	e3a03000 	mov	r3, #0
	if (is_display_disabled())
8f60dd98:	eb005110 	bl	8f6221e0 <is_display_disabled>
8f60dd9c:	e3500000 	cmp	r0, #0
8f60dda0:	0a000007 	beq	8f60ddc4 <exit_menu_keys_detection+0x44>
}
8f60dda4:	e59f3060 	ldr	r3, [pc, #96]	; 8f60de0c <exit_menu_keys_detection+0x8c>
8f60dda8:	e5932000 	ldr	r2, [r3]
8f60ddac:	e59d3004 	ldr	r3, [r13, #4]
8f60ddb0:	e0332002 	eors	r2, r3, r2
8f60ddb4:	e3a03000 	mov	r3, #0
8f60ddb8:	1a000012 	bne	8f60de08 <exit_menu_keys_detection+0x88>
8f60ddbc:	e28dd008 	add	r13, r13, #8
8f60ddc0:	e8bd8010 	pop	{r4, r15}
	mutex_acquire(&select_msg->msg_lock);
8f60ddc4:	e30c4ccc 	movw	r4, #52428	; 0xcccc
8f60ddc8:	e3484f72 	movt	r4, #36722	; 0x8f72
8f60ddcc:	e2840058 	add	r0, r4, #88	; 0x58
8f60ddd0:	eb00547d 	bl	8f622fcc <mutex_acquire>
	mutex_release(&select_msg->msg_lock);
8f60ddd4:	e2840058 	add	r0, r4, #88	; 0x58
	select_msg->info.is_exit = true;
8f60ddd8:	e3a03001 	mov	r3, #1
8f60dddc:	e584304c 	str	r3, [r4, #76]	; 0x4c
	mutex_release(&select_msg->msg_lock);
8f60dde0:	eb0054c7 	bl	8f623104 <mutex_release>
	wait_for_exit();
8f60dde4:	e59f3020 	ldr	r3, [pc, #32]	; 8f60de0c <exit_menu_keys_detection+0x8c>
8f60dde8:	e5932000 	ldr	r2, [r3]
8f60ddec:	e59d3004 	ldr	r3, [r13, #4]
8f60ddf0:	e0332002 	eors	r2, r3, r2
8f60ddf4:	e3a03000 	mov	r3, #0
8f60ddf8:	1a000002 	bne	8f60de08 <exit_menu_keys_detection+0x88>
}
8f60ddfc:	e28dd008 	add	r13, r13, #8
8f60de00:	e8bd4010 	pop	{r4, r14}
	wait_for_exit();
8f60de04:	eaffff88 	b	8f60dc2c <wait_for_exit>
}
8f60de08:	eb00936c 	bl	8f632bc0 <__stack_chk_fail>
8f60de0c:	8f74221c 	.word	0x8f74221c

8f60de10 <reset_device_unlock_status>:
                     [DISPLAY_MENU_UNLOCK_CRITICAL]: critical unlock the device
                     [DISPLAY_MENU_LOCK]: lock the device
                     [DISPLAY_MENU_LOCK_CRITICAL]: critical lock the device
 **/
void reset_device_unlock_status (int type)
{
8f60de10:	e59f309c 	ldr	r3, [pc, #156]	; 8f60deb4 <reset_device_unlock_status+0xa4>
	struct recovery_message msg;

	if (type == DISPLAY_MENU_LOCK ||
8f60de14:	e2402009 	sub	r2, r0, #9
{
8f60de18:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60de1c:	e24ddd11 	sub	r13, r13, #1088	; 0x440
8f60de20:	e24dd00c 	sub	r13, r13, #12
8f60de24:	e5933000 	ldr	r3, [r3]
8f60de28:	e58d3444 	str	r3, [r13, #1092]	; 0x444
8f60de2c:	e3a03000 	mov	r3, #0
		type == DISPLAY_MENU_UNLOCK ||
8f60de30:	e3c03002 	bic	r3, r0, #2
	if (type == DISPLAY_MENU_LOCK ||
8f60de34:	e3530004 	cmp	r3, #4
8f60de38:	13520001 	cmpne	r2, #1
8f60de3c:	8a000012 	bhi	8f60de8c <reset_device_unlock_status+0x7c>
		type == DISPLAY_MENU_LOCK_CRITICAL ||
		type == DISPLAY_MENU_UNLOCK_CRITICAL) {
		set_device_unlock_value (munlock_info[type].unlock_type,
8f60de40:	e3033cdc 	movw	r3, #15580	; 0x3cdc
8f60de44:	e3483f70 	movt	r3, #36720	; 0x8f70
8f60de48:	e0832180 	add	r2, r3, r0, lsl #3
8f60de4c:	e7930180 	ldr	r0, [r3, r0, lsl #3]
8f60de50:	e5921004 	ldr	r1, [r2, #4]
8f60de54:	eb006b3d 	bl	8f628b50 <set_device_unlock_value>
				munlock_info[type].unlock_value);
		memset(&msg, 0, sizeof(msg));
8f60de58:	e3a02d11 	mov	r2, #1088	; 0x440
8f60de5c:	e3a01000 	mov	r1, #0
8f60de60:	e28d0004 	add	r0, r13, #4
8f60de64:	eb009916 	bl	8f6342c4 <memset>
		snprintf(msg.recovery, sizeof(msg.recovery), "recovery\n--wipe_data");
8f60de68:	e3a01b01 	mov	r1, #1024	; 0x400
8f60de6c:	e28d0044 	add	r0, r13, #68	; 0x44
8f60de70:	e30325dc 	movw	r2, #13788	; 0x35dc
8f60de74:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60de78:	eb009830 	bl	8f633f40 <snprintf>
		write_misc(0, &msg, sizeof(msg));
8f60de7c:	e28d1004 	add	r1, r13, #4
8f60de80:	e3a02d11 	mov	r2, #1088	; 0x440
8f60de84:	e3a00000 	mov	r0, #0
8f60de88:	eb00862b 	bl	8f62f73c <write_misc>
	}
}
8f60de8c:	e59f3020 	ldr	r3, [pc, #32]	; 8f60deb4 <reset_device_unlock_status+0xa4>
8f60de90:	e5932000 	ldr	r2, [r3]
8f60de94:	e59d3444 	ldr	r3, [r13, #1092]	; 0x444
8f60de98:	e0332002 	eors	r2, r3, r2
8f60de9c:	e3a03000 	mov	r3, #0
8f60dea0:	1a000002 	bne	8f60deb0 <reset_device_unlock_status+0xa0>
8f60dea4:	e28ddd11 	add	r13, r13, #1088	; 0x440
8f60dea8:	e28dd00c 	add	r13, r13, #12
8f60deac:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60deb0:	eb009342 	bl	8f632bc0 <__stack_chk_fail>
8f60deb4:	8f74221c 	.word	0x8f74221c

8f60deb8 <display_bootverify_option_menu_renew>:
}
#endif

/* msg_lock need to be holded when call this function. */
void display_bootverify_option_menu_renew(struct select_msg_info *msg_info)
{
8f60deb8:	e59f312c 	ldr	r3, [pc, #300]	; 8f60dfec <display_bootverify_option_menu_renew+0x134>
8f60debc:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
8f60dec0:	e1a07000 	mov	r7, r0
8f60dec4:	e24dd008 	sub	r13, r13, #8

	fbcon_clear();
	memset(&msg_info->info, 0, sizeof(struct menu_info));

	len = ARRAY_SIZE(verify_option_menu);
	display_fbcon_menu_message("Options menu:\n\n",
8f60dec8:	e30345f4 	movw	r4, #13812	; 0x35f4
{
8f60decc:	e5933000 	ldr	r3, [r3]
8f60ded0:	e58d3004 	str	r3, [r13, #4]
8f60ded4:	e3a03000 	mov	r3, #0
	fbcon_clear();
8f60ded8:	eb008842 	bl	8f62ffe8 <fbcon_clear>
	memset(&msg_info->info, 0, sizeof(struct menu_info));
8f60dedc:	e3a02054 	mov	r2, #84	; 0x54
8f60dee0:	e3a01000 	mov	r1, #0
8f60dee4:	e1a00007 	mov	r0, r7
	display_fbcon_menu_message("Options menu:\n\n",
8f60dee8:	e3484f70 	movt	r4, #36720	; 0x8f70
	memset(&msg_info->info, 0, sizeof(struct menu_info));
8f60deec:	eb0098f4 	bl	8f6342c4 <memset>
	display_fbcon_menu_message("Options menu:\n\n",
8f60def0:	e3013308 	movw	r3, #4872	; 0x1308
8f60def4:	e3483f71 	movt	r3, #36721	; 0x8f71
	while(*str != 0) {
8f60def8:	e3a0004f 	mov	r0, #79	; 0x4f
	display_fbcon_menu_message("Options menu:\n\n",
8f60defc:	e5935000 	ldr	r5, [r3]
		fbcon_putc_factor(*str++, type, scale_factor);
8f60df00:	e1a02005 	mov	r2, r5
8f60df04:	e3a01000 	mov	r1, #0
8f60df08:	eb00886c 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60df0c:	e5f40001 	ldrb	r0, [r4, #1]!
8f60df10:	e3500000 	cmp	r0, #0
8f60df14:	1afffff9 	bne	8f60df00 <display_bootverify_option_menu_renew+0x48>
		FBCON_COMMON_MSG, big_factor);
	display_fbcon_menu_message("Press volume key to select, and "\
8f60df18:	e301830c 	movw	r8, #4876	; 0x130c
8f60df1c:	e3488f71 	movt	r8, #36721	; 0x8f71
8f60df20:	e3034604 	movw	r4, #13828	; 0x3604
8f60df24:	e3484f70 	movt	r4, #36720	; 0x8f70
8f60df28:	e5985000 	ldr	r5, [r8]
	while(*str != 0) {
8f60df2c:	e3a00050 	mov	r0, #80	; 0x50
		fbcon_putc_factor(*str++, type, scale_factor);
8f60df30:	e1a02005 	mov	r2, r5
8f60df34:	e3a01000 	mov	r1, #0
8f60df38:	eb008860 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60df3c:	e5f40001 	ldrb	r0, [r4, #1]!
8f60df40:	e3500000 	cmp	r0, #0
8f60df44:	1afffff9 	bne	8f60df30 <display_bootverify_option_menu_renew+0x78>
8f60df48:	e3039d34 	movw	r9, #15668	; 0x3d34
8f60df4c:	e2476004 	sub	r6, r7, #4
8f60df50:	e3489f70 	movt	r9, #36720	; 0x8f70
8f60df54:	e287a010 	add	r10, r7, #16
		"press power key to select\n\n", FBCON_COMMON_MSG, common_factor);

	for (i = 0; i < len; i++) {
		fbcon_draw_line(FBCON_COMMON_MSG);
8f60df58:	e3a00000 	mov	r0, #0
8f60df5c:	eb0087cd 	bl	8f62fe98 <fbcon_draw_line>
		msg_info->info.option_start[i] = fbcon_get_current_line();
8f60df60:	eb008921 	bl	8f6303ec <fbcon_get_current_line>
		display_fbcon_menu_message(verify_option_menu[i],
8f60df64:	e4994004 	ldr	r4, [r9], #4
8f60df68:	e5985000 	ldr	r5, [r8]
		msg_info->info.option_start[i] = fbcon_get_current_line();
8f60df6c:	e5a60004 	str	r0, [r6, #4]!
	while(*str != 0) {
8f60df70:	e5d40000 	ldrb	r0, [r4]
8f60df74:	e3500000 	cmp	r0, #0
8f60df78:	0a000005 	beq	8f60df94 <display_bootverify_option_menu_renew+0xdc>
		fbcon_putc_factor(*str++, type, scale_factor);
8f60df7c:	e1a02005 	mov	r2, r5
8f60df80:	e3a01000 	mov	r1, #0
8f60df84:	eb00884d 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60df88:	e5f40001 	ldrb	r0, [r4, #1]!
8f60df8c:	e3500000 	cmp	r0, #0
8f60df90:	1afffff9 	bne	8f60df7c <display_bootverify_option_menu_renew+0xc4>
			FBCON_COMMON_MSG, common_factor);
		msg_info->info.option_bg[i]= fbcon_get_current_bg();
8f60df94:	eb008964 	bl	8f63052c <fbcon_get_current_bg>
8f60df98:	e5860028 	str	r0, [r6, #40]	; 0x28
		msg_info->info.option_end[i]= fbcon_get_current_line();
8f60df9c:	eb008912 	bl	8f6303ec <fbcon_get_current_line>
	for (i = 0; i < len; i++) {
8f60dfa0:	e15a0006 	cmp	r10, r6
		msg_info->info.option_end[i]= fbcon_get_current_line();
8f60dfa4:	e5860014 	str	r0, [r6, #20]
	for (i = 0; i < len; i++) {
8f60dfa8:	1affffea 	bne	8f60df58 <display_bootverify_option_menu_renew+0xa0>
	}

	fbcon_draw_line(FBCON_COMMON_MSG);
8f60dfac:	e3a00000 	mov	r0, #0
8f60dfb0:	eb0087b8 	bl	8f62fe98 <fbcon_draw_line>
	msg_info->info.msg_type = DISPLAY_MENU_MORE_OPTION;
	msg_info->info.option_num = len;
8f60dfb4:	e3a03005 	mov	r3, #5
8f60dfb8:	e587303c 	str	r3, [r7, #60]	; 0x3c
	msg_info->info.msg_type = DISPLAY_MENU_MORE_OPTION;
8f60dfbc:	e3a02003 	mov	r2, #3

	/* Initialize the option index */
	msg_info->info.option_index= len;
8f60dfc0:	e5873040 	str	r3, [r7, #64]	; 0x40
}
8f60dfc4:	e59f3020 	ldr	r3, [pc, #32]	; 8f60dfec <display_bootverify_option_menu_renew+0x134>
	msg_info->info.msg_type = DISPLAY_MENU_MORE_OPTION;
8f60dfc8:	e5872044 	str	r2, [r7, #68]	; 0x44
}
8f60dfcc:	e5932000 	ldr	r2, [r3]
8f60dfd0:	e59d3004 	ldr	r3, [r13, #4]
8f60dfd4:	e0332002 	eors	r2, r3, r2
8f60dfd8:	e3a03000 	mov	r3, #0
8f60dfdc:	1a000001 	bne	8f60dfe8 <display_bootverify_option_menu_renew+0x130>
8f60dfe0:	e28dd008 	add	r13, r13, #8
8f60dfe4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
8f60dfe8:	eb0092f4 	bl	8f632bc0 <__stack_chk_fail>
8f60dfec:	8f74221c 	.word	0x8f74221c

8f60dff0 <display_fastboot_menu_renew>:

/* msg_lock need to be holded when call this function. */
void display_fastboot_menu_renew(struct select_msg_info *fastboot_msg_info)
{
8f60dff0:	e59f3480 	ldr	r3, [pc, #1152]	; 8f60e478 <display_fastboot_menu_renew+0x488>
8f60dff4:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f60dff8:	e1a05000 	mov	r5, r0
	char msg[128];

	/* The fastboot menu is switched base on the option index
	 * So it's need to store the index for the menu switching
	 */
	uint32_t option_index = fastboot_msg_info->info.option_index;
8f60dffc:	e5906040 	ldr	r6, [r0, #64]	; 0x40
{
8f60e000:	e24dd0d4 	sub	r13, r13, #212	; 0xd4
8f60e004:	e5933000 	ldr	r3, [r3]
8f60e008:	e58d30cc 	str	r3, [r13, #204]	; 0xcc
8f60e00c:	e3a03000 	mov	r3, #0

	fbcon_clear();
8f60e010:	eb0087f4 	bl	8f62ffe8 <fbcon_clear>
	memset(&fastboot_msg_info->info, 0, sizeof(struct menu_info));
8f60e014:	e3a02054 	mov	r2, #84	; 0x54
8f60e018:	e3a01000 	mov	r1, #0
8f60e01c:	e1a00005 	mov	r0, r5
8f60e020:	eb0098a7 	bl	8f6342c4 <memset>

	len = ARRAY_SIZE(fastboot_option_menu);
	switch(option_index) {
8f60e024:	e3560002 	cmp	r6, #2
8f60e028:	8a000107 	bhi	8f60e44c <display_fastboot_menu_renew+0x45c>
8f60e02c:	e3560000 	cmp	r6, #0
8f60e030:	1a00010c 	bne	8f60e468 <display_fastboot_menu_renew+0x478>
8f60e034:	e3a09007 	mov	r9, #7
		case 0:
			msg_type = FBCON_GREEN_MSG;
8f60e038:	e1a07009 	mov	r7, r9
		case 5:
			fbcon_flush();
			goto end;
	}

	fbcon_draw_line(msg_type);
8f60e03c:	e1a00009 	mov	r0, r9
8f60e040:	eb008794 	bl	8f62fe98 <fbcon_draw_line>
	display_fbcon_menu_message(fastboot_option_menu[option_index],
8f60e044:	e3033cc4 	movw	r3, #15556	; 0x3cc4
8f60e048:	e3483f70 	movt	r3, #36720	; 0x8f70
8f60e04c:	e7934106 	ldr	r4, [r3, r6, lsl #2]
8f60e050:	e3013308 	movw	r3, #4872	; 0x1308
8f60e054:	e3483f71 	movt	r3, #36721	; 0x8f71
	while(*str != 0) {
8f60e058:	e5d40000 	ldrb	r0, [r4]
	display_fbcon_menu_message(fastboot_option_menu[option_index],
8f60e05c:	e5938000 	ldr	r8, [r3]
	while(*str != 0) {
8f60e060:	e3500000 	cmp	r0, #0
8f60e064:	0a000005 	beq	8f60e080 <display_fastboot_menu_renew+0x90>
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e068:	e1a02008 	mov	r2, r8
8f60e06c:	e1a01007 	mov	r1, r7
8f60e070:	eb008812 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e074:	e5f40001 	ldrb	r0, [r4, #1]!
8f60e078:	e3500000 	cmp	r0, #0
8f60e07c:	1afffff9 	bne	8f60e068 <display_fastboot_menu_renew+0x78>
		msg_type, big_factor);
	fbcon_draw_line(msg_type);
	display_fbcon_menu_message("\n\nPress volume key to select, and "\
8f60e080:	e301430c 	movw	r4, #4876	; 0x130c
8f60e084:	e3484f71 	movt	r4, #36721	; 0x8f71
	fbcon_draw_line(msg_type);
8f60e088:	e1a00009 	mov	r0, r9
	display_fbcon_menu_message("\n\nPress volume key to select, and "\
8f60e08c:	e3037640 	movw	r7, #13888	; 0x3640
	fbcon_draw_line(msg_type);
8f60e090:	eb008780 	bl	8f62fe98 <fbcon_draw_line>
	display_fbcon_menu_message("\n\nPress volume key to select, and "\
8f60e094:	e5948000 	ldr	r8, [r4]
8f60e098:	e3487f70 	movt	r7, #36720	; 0x8f70
	while(*str != 0) {
8f60e09c:	e3a0000a 	mov	r0, #10
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e0a0:	e1a02008 	mov	r2, r8
8f60e0a4:	e3a01000 	mov	r1, #0
8f60e0a8:	eb008804 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e0ac:	e5f70001 	ldrb	r0, [r7, #1]!
8f60e0b0:	e3500000 	cmp	r0, #0
8f60e0b4:	1afffff9 	bne	8f60e0a0 <display_fastboot_menu_renew+0xb0>
		"press power key to select\n\n", FBCON_COMMON_MSG, common_factor);

	display_fbcon_menu_message("FASTBOOT MODE\n", FBCON_RED_MSG, common_factor);
8f60e0b8:	e5948000 	ldr	r8, [r4]
8f60e0bc:	e3037680 	movw	r7, #13952	; 0x3680
8f60e0c0:	e3487f70 	movt	r7, #36720	; 0x8f70
	while(*str != 0) {
8f60e0c4:	e3a00046 	mov	r0, #70	; 0x46
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e0c8:	e1a02008 	mov	r2, r8
8f60e0cc:	e3a01006 	mov	r1, #6
8f60e0d0:	eb0087fa 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e0d4:	e5f70001 	ldrb	r0, [r7, #1]!
8f60e0d8:	e3500000 	cmp	r0, #0
8f60e0dc:	1afffff9 	bne	8f60e0c8 <display_fastboot_menu_renew+0xd8>

	get_product_name((unsigned char *) msg_buf);
8f60e0e0:	e28d000c 	add	r0, r13, #12
8f60e0e4:	eb0074aa 	bl	8f62b394 <get_product_name>
	snprintf(msg, sizeof(msg), "PRODUCT_NAME - %s\n", msg_buf);
8f60e0e8:	e28d300c 	add	r3, r13, #12
8f60e0ec:	e28d004c 	add	r0, r13, #76	; 0x4c
8f60e0f0:	e30326c4 	movw	r2, #14020	; 0x36c4
8f60e0f4:	e3a01080 	mov	r1, #128	; 0x80
8f60e0f8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60e0fc:	eb00978f 	bl	8f633f40 <snprintf>
	while(*str != 0) {
8f60e100:	e5dd004c 	ldrb	r0, [r13, #76]	; 0x4c
	display_fbcon_menu_message(msg, FBCON_COMMON_MSG, common_factor);
8f60e104:	e5948000 	ldr	r8, [r4]
	while(*str != 0) {
8f60e108:	e3500000 	cmp	r0, #0
8f60e10c:	128d704c 	addne	r7, r13, #76	; 0x4c
8f60e110:	0a000005 	beq	8f60e12c <display_fastboot_menu_renew+0x13c>
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e114:	e1a02008 	mov	r2, r8
8f60e118:	e3a01000 	mov	r1, #0
8f60e11c:	eb0087e7 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e120:	e5f70001 	ldrb	r0, [r7, #1]!
8f60e124:	e3500000 	cmp	r0, #0
8f60e128:	1afffff9 	bne	8f60e114 <display_fastboot_menu_renew+0x124>

	if (lk2nd_dev.model) {
8f60e12c:	e301813c 	movw	r8, #4412	; 0x113c
8f60e130:	e3488f74 	movt	r8, #36724	; 0x8f74
8f60e134:	e5983004 	ldr	r3, [r8, #4]
8f60e138:	e3530000 	cmp	r3, #0
8f60e13c:	0a00000f 	beq	8f60e180 <display_fastboot_menu_renew+0x190>
		snprintf(msg, sizeof(msg), "MODEL - %s\n", lk2nd_dev.model);
8f60e140:	e28d004c 	add	r0, r13, #76	; 0x4c
8f60e144:	e30326d8 	movw	r2, #14040	; 0x36d8
8f60e148:	e3a01080 	mov	r1, #128	; 0x80
8f60e14c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60e150:	eb00977a 	bl	8f633f40 <snprintf>
	while(*str != 0) {
8f60e154:	e5dd004c 	ldrb	r0, [r13, #76]	; 0x4c
		display_fbcon_menu_message(msg, FBCON_COMMON_MSG, common_factor);
8f60e158:	e5949000 	ldr	r9, [r4]
	while(*str != 0) {
8f60e15c:	e3500000 	cmp	r0, #0
8f60e160:	0a000006 	beq	8f60e180 <display_fastboot_menu_renew+0x190>
8f60e164:	e28d704c 	add	r7, r13, #76	; 0x4c
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e168:	e1a02009 	mov	r2, r9
8f60e16c:	e3a01000 	mov	r1, #0
8f60e170:	eb0087d2 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e174:	e5f70001 	ldrb	r0, [r7, #1]!
8f60e178:	e3500000 	cmp	r0, #0
8f60e17c:	1afffff9 	bne	8f60e168 <display_fastboot_menu_renew+0x178>
	}

	memset(msg_buf, 0, sizeof(msg_buf));
8f60e180:	e3a02040 	mov	r2, #64	; 0x40
8f60e184:	e3a01000 	mov	r1, #0
8f60e188:	e28d000c 	add	r0, r13, #12
8f60e18c:	eb00984c 	bl	8f6342c4 <memset>
	smem_get_hw_platform_name((unsigned char *) msg_buf, sizeof(msg_buf));
8f60e190:	e3a01040 	mov	r1, #64	; 0x40
8f60e194:	e28d000c 	add	r0, r13, #12
8f60e198:	ebffd279 	bl	8f602b84 <smem_get_hw_platform_name>
	snprintf(msg, sizeof(msg), "VARIANT - %s %s\n",
		msg_buf, target_is_emmc_boot()? "eMMC":"UFS");
8f60e19c:	eb004e37 	bl	8f621a80 <target_is_emmc_boot>
	snprintf(msg, sizeof(msg), "VARIANT - %s %s\n",
8f60e1a0:	e3032698 	movw	r2, #13976	; 0x3698
8f60e1a4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60e1a8:	e3033690 	movw	r3, #13968	; 0x3690
8f60e1ac:	e3a01080 	mov	r1, #128	; 0x80
8f60e1b0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f60e1b4:	e3500000 	cmp	r0, #0
8f60e1b8:	e28d004c 	add	r0, r13, #76	; 0x4c
8f60e1bc:	01a03002 	moveq	r3, r2
8f60e1c0:	e30326e4 	movw	r2, #14052	; 0x36e4
8f60e1c4:	e58d3000 	str	r3, [r13]
8f60e1c8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60e1cc:	e28d300c 	add	r3, r13, #12
8f60e1d0:	eb00975a 	bl	8f633f40 <snprintf>
	while(*str != 0) {
8f60e1d4:	e5dd004c 	ldrb	r0, [r13, #76]	; 0x4c
	display_fbcon_menu_message(msg, FBCON_COMMON_MSG, common_factor);
8f60e1d8:	e5949000 	ldr	r9, [r4]
	while(*str != 0) {
8f60e1dc:	e3500000 	cmp	r0, #0
8f60e1e0:	128d704c 	addne	r7, r13, #76	; 0x4c
8f60e1e4:	0a000005 	beq	8f60e200 <display_fastboot_menu_renew+0x210>
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e1e8:	e1a02009 	mov	r2, r9
8f60e1ec:	e3a01000 	mov	r1, #0
8f60e1f0:	eb0087b2 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e1f4:	e5f70001 	ldrb	r0, [r7, #1]!
8f60e1f8:	e3500000 	cmp	r0, #0
8f60e1fc:	1afffff9 	bne	8f60e1e8 <display_fastboot_menu_renew+0x1f8>

	memset(msg_buf, 0, sizeof(msg_buf));
8f60e200:	e3a02040 	mov	r2, #64	; 0x40
8f60e204:	e3a01000 	mov	r1, #0
8f60e208:	e28d000c 	add	r0, r13, #12
8f60e20c:	eb00982c 	bl	8f6342c4 <memset>
	get_bootloader_version((unsigned char *) msg_buf);
8f60e210:	e28d000c 	add	r0, r13, #12
8f60e214:	eb007474 	bl	8f62b3ec <get_bootloader_version>
	snprintf(msg, sizeof(msg), "BOOTLOADER VERSION - %s\n",
8f60e218:	e28d300c 	add	r3, r13, #12
8f60e21c:	e28d004c 	add	r0, r13, #76	; 0x4c
8f60e220:	e30326f8 	movw	r2, #14072	; 0x36f8
8f60e224:	e3a01080 	mov	r1, #128	; 0x80
8f60e228:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60e22c:	eb009743 	bl	8f633f40 <snprintf>
	while(*str != 0) {
8f60e230:	e5dd004c 	ldrb	r0, [r13, #76]	; 0x4c
		msg_buf);
	display_fbcon_menu_message(msg, FBCON_COMMON_MSG, common_factor);
8f60e234:	e5949000 	ldr	r9, [r4]
	while(*str != 0) {
8f60e238:	e3500000 	cmp	r0, #0
8f60e23c:	128d704c 	addne	r7, r13, #76	; 0x4c
8f60e240:	0a000005 	beq	8f60e25c <display_fastboot_menu_renew+0x26c>
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e244:	e1a02009 	mov	r2, r9
8f60e248:	e3a01000 	mov	r1, #0
8f60e24c:	eb00879b 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e250:	e5f70001 	ldrb	r0, [r7, #1]!
8f60e254:	e3500000 	cmp	r0, #0
8f60e258:	1afffff9 	bne	8f60e244 <display_fastboot_menu_renew+0x254>

	memset(msg_buf, 0, sizeof(msg_buf));
8f60e25c:	e3a02040 	mov	r2, #64	; 0x40
8f60e260:	e3a01000 	mov	r1, #0
8f60e264:	e28d000c 	add	r0, r13, #12
8f60e268:	eb009815 	bl	8f6342c4 <memset>
	get_baseband_version((unsigned char *) msg_buf);
8f60e26c:	e28d000c 	add	r0, r13, #12
8f60e270:	eb007473 	bl	8f62b444 <get_baseband_version>
	snprintf(msg, sizeof(msg), "BASEBAND VERSION - %s\n",
8f60e274:	e28d300c 	add	r3, r13, #12
8f60e278:	e28d004c 	add	r0, r13, #76	; 0x4c
8f60e27c:	e3032714 	movw	r2, #14100	; 0x3714
8f60e280:	e3a01080 	mov	r1, #128	; 0x80
8f60e284:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60e288:	eb00972c 	bl	8f633f40 <snprintf>
	while(*str != 0) {
8f60e28c:	e5dd004c 	ldrb	r0, [r13, #76]	; 0x4c
		msg_buf);
	display_fbcon_menu_message(msg, FBCON_COMMON_MSG, common_factor);
8f60e290:	e5949000 	ldr	r9, [r4]
	while(*str != 0) {
8f60e294:	e3500000 	cmp	r0, #0
8f60e298:	128d704c 	addne	r7, r13, #76	; 0x4c
8f60e29c:	0a000005 	beq	8f60e2b8 <display_fastboot_menu_renew+0x2c8>
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e2a0:	e1a02009 	mov	r2, r9
8f60e2a4:	e3a01000 	mov	r1, #0
8f60e2a8:	eb008784 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e2ac:	e5f70001 	ldrb	r0, [r7, #1]!
8f60e2b0:	e3500000 	cmp	r0, #0
8f60e2b4:	1afffff9 	bne	8f60e2a0 <display_fastboot_menu_renew+0x2b0>

	if (lk2nd_dev.panel.name) {
8f60e2b8:	e5983030 	ldr	r3, [r8, #48]	; 0x30
8f60e2bc:	e3530000 	cmp	r3, #0
8f60e2c0:	0a00000f 	beq	8f60e304 <display_fastboot_menu_renew+0x314>
		snprintf(msg, sizeof(msg), "PANEL - %s\n", lk2nd_dev.panel.name);
8f60e2c4:	e28d004c 	add	r0, r13, #76	; 0x4c
8f60e2c8:	e3032740 	movw	r2, #14144	; 0x3740
8f60e2cc:	e3a01080 	mov	r1, #128	; 0x80
8f60e2d0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60e2d4:	eb009719 	bl	8f633f40 <snprintf>
	while(*str != 0) {
8f60e2d8:	e5dd004c 	ldrb	r0, [r13, #76]	; 0x4c
		display_fbcon_menu_message(msg, FBCON_COMMON_MSG, common_factor);
8f60e2dc:	e5948000 	ldr	r8, [r4]
	while(*str != 0) {
8f60e2e0:	e3500000 	cmp	r0, #0
8f60e2e4:	0a000006 	beq	8f60e304 <display_fastboot_menu_renew+0x314>
8f60e2e8:	e28d704c 	add	r7, r13, #76	; 0x4c
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e2ec:	e1a02008 	mov	r2, r8
8f60e2f0:	e3a01000 	mov	r1, #0
8f60e2f4:	eb008771 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e2f8:	e5f70001 	ldrb	r0, [r7, #1]!
8f60e2fc:	e3500000 	cmp	r0, #0
8f60e300:	1afffff9 	bne	8f60e2ec <display_fastboot_menu_renew+0x2fc>
	}

	memset(msg_buf, 0, sizeof(msg_buf));
8f60e304:	e3a02040 	mov	r2, #64	; 0x40
8f60e308:	e3a01000 	mov	r1, #0
8f60e30c:	e28d000c 	add	r0, r13, #12
8f60e310:	eb0097eb 	bl	8f6342c4 <memset>
	target_serialno((unsigned char *) msg_buf);
8f60e314:	e28d000c 	add	r0, r13, #12
8f60e318:	ebffc9ec 	bl	8f600ad0 <target_serialno>
	snprintf(msg, sizeof(msg), "SERIAL NUMBER - %s\n", msg_buf);
8f60e31c:	e28d300c 	add	r3, r13, #12
8f60e320:	e28d004c 	add	r0, r13, #76	; 0x4c
8f60e324:	e303272c 	movw	r2, #14124	; 0x372c
8f60e328:	e3a01080 	mov	r1, #128	; 0x80
8f60e32c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60e330:	eb009702 	bl	8f633f40 <snprintf>
	while(*str != 0) {
8f60e334:	e5dd004c 	ldrb	r0, [r13, #76]	; 0x4c
	display_fbcon_menu_message(msg, FBCON_COMMON_MSG, common_factor);
8f60e338:	e5948000 	ldr	r8, [r4]
	while(*str != 0) {
8f60e33c:	e3500000 	cmp	r0, #0
8f60e340:	128d704c 	addne	r7, r13, #76	; 0x4c
8f60e344:	0a000005 	beq	8f60e360 <display_fastboot_menu_renew+0x370>
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e348:	e1a02008 	mov	r2, r8
8f60e34c:	e3a01000 	mov	r1, #0
8f60e350:	eb00875a 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e354:	e5f70001 	ldrb	r0, [r7, #1]!
8f60e358:	e3500000 	cmp	r0, #0
8f60e35c:	1afffff9 	bne	8f60e348 <display_fastboot_menu_renew+0x358>

	snprintf(msg, sizeof(msg), "SECURE BOOT - %s\n",
		is_secure_boot_enable()? "enabled":"disabled");
8f60e360:	eb001ba5 	bl	8f6151fc <is_secure_boot_enable>
	snprintf(msg, sizeof(msg), "SECURE BOOT - %s\n",
8f60e364:	e30326a4 	movw	r2, #13988	; 0x36a4
8f60e368:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60e36c:	e303369c 	movw	r3, #13980	; 0x369c
8f60e370:	e3a01080 	mov	r1, #128	; 0x80
8f60e374:	e3483f70 	movt	r3, #36720	; 0x8f70
8f60e378:	e3500000 	cmp	r0, #0
8f60e37c:	e28d004c 	add	r0, r13, #76	; 0x4c
8f60e380:	01a03002 	moveq	r3, r2
8f60e384:	e303274c 	movw	r2, #14156	; 0x374c
8f60e388:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60e38c:	eb0096eb 	bl	8f633f40 <snprintf>
	while(*str != 0) {
8f60e390:	e5dd004c 	ldrb	r0, [r13, #76]	; 0x4c
	display_fbcon_menu_message(msg, FBCON_COMMON_MSG, common_factor);
8f60e394:	e5948000 	ldr	r8, [r4]
	while(*str != 0) {
8f60e398:	e3500000 	cmp	r0, #0
8f60e39c:	128d704c 	addne	r7, r13, #76	; 0x4c
8f60e3a0:	0a000005 	beq	8f60e3bc <display_fastboot_menu_renew+0x3cc>
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e3a4:	e1a02008 	mov	r2, r8
8f60e3a8:	e3a01000 	mov	r1, #0
8f60e3ac:	eb008743 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e3b0:	e5f70001 	ldrb	r0, [r7, #1]!
8f60e3b4:	e3500000 	cmp	r0, #0
8f60e3b8:	1afffff9 	bne	8f60e3a4 <display_fastboot_menu_renew+0x3b4>

	snprintf(msg, sizeof(msg), "DEVICE STATE - %s\n",
		is_device_locked()? "locked":"unlocked");
8f60e3bc:	eb007436 	bl	8f62b49c <is_device_locked>
	snprintf(msg, sizeof(msg), "DEVICE STATE - %s\n",
8f60e3c0:	e30326b8 	movw	r2, #14008	; 0x36b8
8f60e3c4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60e3c8:	e30336b0 	movw	r3, #14000	; 0x36b0
8f60e3cc:	e3a01080 	mov	r1, #128	; 0x80
8f60e3d0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f60e3d4:	e3500000 	cmp	r0, #0
8f60e3d8:	e28d004c 	add	r0, r13, #76	; 0x4c
8f60e3dc:	01a03002 	moveq	r3, r2
8f60e3e0:	e3032760 	movw	r2, #14176	; 0x3760
8f60e3e4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60e3e8:	eb0096d4 	bl	8f633f40 <snprintf>
	while(*str != 0) {
8f60e3ec:	e5dd004c 	ldrb	r0, [r13, #76]	; 0x4c
	display_fbcon_menu_message(msg, FBCON_RED_MSG, common_factor);
8f60e3f0:	e5947000 	ldr	r7, [r4]
	while(*str != 0) {
8f60e3f4:	e3500000 	cmp	r0, #0
8f60e3f8:	128d404c 	addne	r4, r13, #76	; 0x4c
8f60e3fc:	0a000005 	beq	8f60e418 <display_fastboot_menu_renew+0x428>
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e400:	e1a02007 	mov	r2, r7
8f60e404:	e3a01006 	mov	r1, #6
8f60e408:	eb00872c 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e40c:	e5f40001 	ldrb	r0, [r4, #1]!
8f60e410:	e3500000 	cmp	r0, #0
8f60e414:	1afffff9 	bne	8f60e400 <display_fastboot_menu_renew+0x410>

end:
	fastboot_msg_info->info.msg_type = DISPLAY_MENU_FASTBOOT;
	fastboot_msg_info->info.option_num = len;
8f60e418:	e3a03006 	mov	r3, #6
8f60e41c:	e585303c 	str	r3, [r5, #60]	; 0x3c
	fastboot_msg_info->info.option_index = option_index;
}
8f60e420:	e59f3050 	ldr	r3, [pc, #80]	; 8f60e478 <display_fastboot_menu_renew+0x488>
	fastboot_msg_info->info.msg_type = DISPLAY_MENU_FASTBOOT;
8f60e424:	e3a02005 	mov	r2, #5
	fastboot_msg_info->info.option_index = option_index;
8f60e428:	e5856040 	str	r6, [r5, #64]	; 0x40
	fastboot_msg_info->info.msg_type = DISPLAY_MENU_FASTBOOT;
8f60e42c:	e5852044 	str	r2, [r5, #68]	; 0x44
}
8f60e430:	e5932000 	ldr	r2, [r3]
8f60e434:	e59d30cc 	ldr	r3, [r13, #204]	; 0xcc
8f60e438:	e0332002 	eors	r2, r3, r2
8f60e43c:	e3a03000 	mov	r3, #0
8f60e440:	1a00000b 	bne	8f60e474 <display_fastboot_menu_renew+0x484>
8f60e444:	e28dd0d4 	add	r13, r13, #212	; 0xd4
8f60e448:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
	switch(option_index) {
8f60e44c:	e3560005 	cmp	r6, #5
8f60e450:	1a000001 	bne	8f60e45c <display_fastboot_menu_renew+0x46c>
			fbcon_flush();
8f60e454:	eb0085c7 	bl	8f62fb78 <fbcon_flush>
			goto end;
8f60e458:	eaffffee 	b	8f60e418 <display_fastboot_menu_renew+0x428>
	switch(option_index) {
8f60e45c:	e3a09000 	mov	r9, #0
	int msg_type = FBCON_COMMON_MSG;
8f60e460:	e1a07009 	mov	r7, r9
8f60e464:	eafffef4 	b	8f60e03c <display_fastboot_menu_renew+0x4c>
	switch(option_index) {
8f60e468:	e3a09006 	mov	r9, #6
8f60e46c:	e1a07009 	mov	r7, r9
8f60e470:	eafffef1 	b	8f60e03c <display_fastboot_menu_renew+0x4c>
}
8f60e474:	eb0091d1 	bl	8f632bc0 <__stack_chk_fail>
8f60e478:	8f74221c 	.word	0x8f74221c

8f60e47c <msg_lock_init>:

void msg_lock_init()
{
8f60e47c:	e92d4010 	push	{r4, r14}
	static bool is_msg_lock_init = false;
	struct select_msg_info *msg_lock_info;
	msg_lock_info = &msg_info;

	if (!is_msg_lock_init) {
8f60e480:	e30c4cc4 	movw	r4, #52420	; 0xccc4
{
8f60e484:	e59f3054 	ldr	r3, [pc, #84]	; 8f60e4e0 <msg_lock_init+0x64>
	if (!is_msg_lock_init) {
8f60e488:	e3484f72 	movt	r4, #36722	; 0x8f72
{
8f60e48c:	e24dd008 	sub	r13, r13, #8
8f60e490:	e5933000 	ldr	r3, [r3]
8f60e494:	e58d3004 	str	r3, [r13, #4]
8f60e498:	e3a03000 	mov	r3, #0
	if (!is_msg_lock_init) {
8f60e49c:	e5943000 	ldr	r3, [r4]
8f60e4a0:	e3530000 	cmp	r3, #0
8f60e4a4:	0a000007 	beq	8f60e4c8 <msg_lock_init+0x4c>
		mutex_init(&msg_lock_info->msg_lock);
		is_msg_lock_init = true;
	}
}
8f60e4a8:	e59f3030 	ldr	r3, [pc, #48]	; 8f60e4e0 <msg_lock_init+0x64>
8f60e4ac:	e5932000 	ldr	r2, [r3]
8f60e4b0:	e59d3004 	ldr	r3, [r13, #4]
8f60e4b4:	e0332002 	eors	r2, r3, r2
8f60e4b8:	e3a03000 	mov	r3, #0
8f60e4bc:	1a000006 	bne	8f60e4dc <msg_lock_init+0x60>
8f60e4c0:	e28dd008 	add	r13, r13, #8
8f60e4c4:	e8bd8010 	pop	{r4, r15}
		mutex_init(&msg_lock_info->msg_lock);
8f60e4c8:	e59f0014 	ldr	r0, [pc, #20]	; 8f60e4e4 <msg_lock_init+0x68>
8f60e4cc:	eb0052a7 	bl	8f622f70 <mutex_init>
		is_msg_lock_init = true;
8f60e4d0:	e3a03001 	mov	r3, #1
8f60e4d4:	e5843000 	str	r3, [r4]
}
8f60e4d8:	eafffff2 	b	8f60e4a8 <msg_lock_init+0x2c>
8f60e4dc:	eb0091b7 	bl	8f632bc0 <__stack_chk_fail>
8f60e4e0:	8f74221c 	.word	0x8f74221c
8f60e4e4:	8f72cd24 	.word	0x8f72cd24

8f60e4e8 <display_unlock_menu>:

/* The fuction be called after device in fastboot mode,
 * so it's no need to initialize the msg_lock again
 */
void display_unlock_menu(int type, bool status)
{
8f60e4e8:	e59f3318 	ldr	r3, [pc, #792]	; 8f60e808 <display_unlock_menu+0x320>
8f60e4ec:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
8f60e4f0:	e24dd010 	sub	r13, r13, #16
8f60e4f4:	e5933000 	ldr	r3, [r3]
8f60e4f8:	e58d300c 	str	r3, [r13, #12]
8f60e4fc:	e3a03000 	mov	r3, #0
8f60e500:	e1a07000 	mov	r7, r0
8f60e504:	e1a06001 	mov	r6, r1
	struct select_msg_info *unlock_menu_msg_info;
	unlock_menu_msg_info = &msg_info;

	if (is_display_disabled())
8f60e508:	eb004f34 	bl	8f6221e0 <is_display_disabled>
8f60e50c:	e3500000 	cmp	r0, #0
8f60e510:	0a000007 	beq	8f60e534 <display_unlock_menu+0x4c>
	mutex_release(&unlock_menu_msg_info->msg_lock);

	dprintf(INFO, "creating %s keys detect thread\n",
		status ? "unlock":"lock");
	display_menu_thread_start(unlock_menu_msg_info);
}
8f60e514:	e59f32ec 	ldr	r3, [pc, #748]	; 8f60e808 <display_unlock_menu+0x320>
8f60e518:	e5932000 	ldr	r2, [r3]
8f60e51c:	e59d300c 	ldr	r3, [r13, #12]
8f60e520:	e0332002 	eors	r2, r3, r2
8f60e524:	e3a03000 	mov	r3, #0
8f60e528:	1a0000b5 	bne	8f60e804 <display_unlock_menu+0x31c>
8f60e52c:	e28dd010 	add	r13, r13, #16
8f60e530:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
	if (!is_msg_lock_init) {
8f60e534:	e30c4cc4 	movw	r4, #52420	; 0xccc4
8f60e538:	e3484f72 	movt	r4, #36722	; 0x8f72
	set_message_factor();
8f60e53c:	ebfffde4 	bl	8f60dcd4 <set_message_factor>
	if (!is_msg_lock_init) {
8f60e540:	e5943000 	ldr	r3, [r4]
8f60e544:	e3530000 	cmp	r3, #0
8f60e548:	0a00009d 	beq	8f60e7c4 <display_unlock_menu+0x2dc>
	mutex_acquire(&unlock_menu_msg_info->msg_lock);
8f60e54c:	e30c5ccc 	movw	r5, #52428	; 0xcccc
8f60e550:	e3485f72 	movt	r5, #36722	; 0x8f72
8f60e554:	e2850058 	add	r0, r5, #88	; 0x58
	display_fbcon_menu_message("<!>\n\n",
8f60e558:	e3034774 	movw	r4, #14196	; 0x3774
	mutex_acquire(&unlock_menu_msg_info->msg_lock);
8f60e55c:	eb00529a 	bl	8f622fcc <mutex_acquire>
	unlock_menu_msg_info->last_msg_type =
8f60e560:	e5953044 	ldr	r3, [r5, #68]	; 0x44
	display_fbcon_menu_message("<!>\n\n",
8f60e564:	e3484f70 	movt	r4, #36720	; 0x8f70
	unlock_menu_msg_info->last_msg_type =
8f60e568:	e5853054 	str	r3, [r5, #84]	; 0x54
	fbcon_clear();
8f60e56c:	eb00869d 	bl	8f62ffe8 <fbcon_clear>
	memset(&unlock_msg_info->info, 0, sizeof(struct menu_info));
8f60e570:	e3a02054 	mov	r2, #84	; 0x54
8f60e574:	e3a01000 	mov	r1, #0
8f60e578:	e1a00005 	mov	r0, r5
8f60e57c:	eb009750 	bl	8f6342c4 <memset>
	display_fbcon_menu_message("<!>\n\n",
8f60e580:	e3013308 	movw	r3, #4872	; 0x1308
8f60e584:	e3483f71 	movt	r3, #36721	; 0x8f71
	while(*str != 0) {
8f60e588:	e3a0003c 	mov	r0, #60	; 0x3c
	display_fbcon_menu_message("<!>\n\n",
8f60e58c:	e5938000 	ldr	r8, [r3]
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e590:	e1a02008 	mov	r2, r8
8f60e594:	e3a01001 	mov	r1, #1
8f60e598:	eb0086c8 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e59c:	e5f40001 	ldrb	r0, [r4, #1]!
8f60e5a0:	e3500000 	cmp	r0, #0
8f60e5a4:	1afffff9 	bne	8f60e590 <display_unlock_menu+0xa8>
		display_fbcon_menu_message((char*)unlock_menu_common_msg,
8f60e5a8:	e301830c 	movw	r8, #4876	; 0x130c
	if (status) {
8f60e5ac:	e3560000 	cmp	r6, #0
		display_fbcon_menu_message((char*)unlock_menu_common_msg,
8f60e5b0:	e3488f71 	movt	r8, #36721	; 0x8f71
8f60e5b4:	e5989000 	ldr	r9, [r8]
	if (status) {
8f60e5b8:	0a000044 	beq	8f60e6d0 <display_unlock_menu+0x1e8>
		display_fbcon_menu_message((char*)unlock_menu_common_msg,
8f60e5bc:	e303477c 	movw	r4, #14204	; 0x377c
8f60e5c0:	e3484f70 	movt	r4, #36720	; 0x8f70
	while(*str != 0) {
8f60e5c4:	e3a00042 	mov	r0, #66	; 0x42
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e5c8:	e1a02009 	mov	r2, r9
8f60e5cc:	e3a01000 	mov	r1, #0
8f60e5d0:	eb0086ba 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e5d4:	e5f40001 	ldrb	r0, [r4, #1]!
8f60e5d8:	e3500000 	cmp	r0, #0
8f60e5dc:	1afffff9 	bne	8f60e5c8 <display_unlock_menu+0xe0>
	fbcon_draw_line(FBCON_COMMON_MSG);
8f60e5e0:	e3a00000 	mov	r0, #0
	display_fbcon_menu_message((char *)munlock_option_msg[status].ignore_msg,
8f60e5e4:	e301a310 	movw	r10, #4880	; 0x1310
	fbcon_draw_line(FBCON_COMMON_MSG);
8f60e5e8:	eb00862a 	bl	8f62fe98 <fbcon_draw_line>
	display_fbcon_menu_message((char *)munlock_option_msg[status].ignore_msg,
8f60e5ec:	e348af71 	movt	r10, #36721	; 0x8f71
	unlock_msg_info->info.option_start[0] = fbcon_get_current_line();
8f60e5f0:	eb00877d 	bl	8f6303ec <fbcon_get_current_line>
	display_fbcon_menu_message((char *)munlock_option_msg[status].ignore_msg,
8f60e5f4:	e5989000 	ldr	r9, [r8]
8f60e5f8:	e79a4186 	ldr	r4, [r10, r6, lsl #3]
	unlock_msg_info->info.option_start[0] = fbcon_get_current_line();
8f60e5fc:	e5850000 	str	r0, [r5]
	while(*str != 0) {
8f60e600:	e5d40000 	ldrb	r0, [r4]
8f60e604:	e3500000 	cmp	r0, #0
8f60e608:	0a000005 	beq	8f60e624 <display_unlock_menu+0x13c>
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e60c:	e1a02009 	mov	r2, r9
8f60e610:	e3a01000 	mov	r1, #0
8f60e614:	eb0086a9 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e618:	e5f40001 	ldrb	r0, [r4, #1]!
8f60e61c:	e3500000 	cmp	r0, #0
8f60e620:	1afffff9 	bne	8f60e60c <display_unlock_menu+0x124>
	unlock_msg_info->info.option_bg[0] = fbcon_get_current_bg();
8f60e624:	eb0087c0 	bl	8f63052c <fbcon_get_current_bg>
	display_fbcon_menu_message((char *)munlock_option_msg[status].comfirm_msg,
8f60e628:	e08aa186 	add	r10, r10, r6, lsl #3
	unlock_msg_info->info.option_bg[0] = fbcon_get_current_bg();
8f60e62c:	e5850028 	str	r0, [r5, #40]	; 0x28
	unlock_msg_info->info.option_end[0] = fbcon_get_current_line();
8f60e630:	eb00876d 	bl	8f6303ec <fbcon_get_current_line>
8f60e634:	e5850014 	str	r0, [r5, #20]
	fbcon_draw_line(FBCON_COMMON_MSG);
8f60e638:	e3a00000 	mov	r0, #0
8f60e63c:	eb008615 	bl	8f62fe98 <fbcon_draw_line>
	unlock_msg_info->info.option_start[1] = fbcon_get_current_line();
8f60e640:	eb008769 	bl	8f6303ec <fbcon_get_current_line>
	display_fbcon_menu_message((char *)munlock_option_msg[status].comfirm_msg,
8f60e644:	e59a4004 	ldr	r4, [r10, #4]
8f60e648:	e5988000 	ldr	r8, [r8]
	unlock_msg_info->info.option_start[1] = fbcon_get_current_line();
8f60e64c:	e5850004 	str	r0, [r5, #4]
	while(*str != 0) {
8f60e650:	e5d40000 	ldrb	r0, [r4]
8f60e654:	e3500000 	cmp	r0, #0
8f60e658:	0a000005 	beq	8f60e674 <display_unlock_menu+0x18c>
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e65c:	e1a02008 	mov	r2, r8
8f60e660:	e3a01000 	mov	r1, #0
8f60e664:	eb008695 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e668:	e5f40001 	ldrb	r0, [r4, #1]!
8f60e66c:	e3500000 	cmp	r0, #0
8f60e670:	1afffff9 	bne	8f60e65c <display_unlock_menu+0x174>
	unlock_msg_info->info.option_bg[1] = fbcon_get_current_bg();
8f60e674:	eb0087ac 	bl	8f63052c <fbcon_get_current_bg>
8f60e678:	e585002c 	str	r0, [r5, #44]	; 0x2c
	unlock_msg_info->info.option_end[1] = fbcon_get_current_line();
8f60e67c:	eb00875a 	bl	8f6303ec <fbcon_get_current_line>
8f60e680:	e1a03000 	mov	r3, r0
	fbcon_draw_line(FBCON_COMMON_MSG);
8f60e684:	e3a00000 	mov	r0, #0
	unlock_msg_info->info.option_end[1] = fbcon_get_current_line();
8f60e688:	e5853018 	str	r3, [r5, #24]
	fbcon_draw_line(FBCON_COMMON_MSG);
8f60e68c:	eb008601 	bl	8f62fe98 <fbcon_draw_line>
	if (type == UNLOCK) {
8f60e690:	e3570000 	cmp	r7, #0
8f60e694:	1a000017 	bne	8f60e6f8 <display_unlock_menu+0x210>
		if (!status)
8f60e698:	e3560000 	cmp	r6, #0
			unlock_msg_info->info.msg_type = DISPLAY_MENU_LOCK;
8f60e69c:	03a03009 	moveq	r3, #9
8f60e6a0:	05853044 	streq	r3, [r5, #68]	; 0x44
		if (!status)
8f60e6a4:	0a00003e 	beq	8f60e7a4 <display_unlock_menu+0x2bc>
		unlock_msg_info->info.msg_type = DISPLAY_MENU_UNLOCK;
8f60e6a8:	e3a03004 	mov	r3, #4
8f60e6ac:	e5853044 	str	r3, [r5, #68]	; 0x44
	mutex_release(&unlock_menu_msg_info->msg_lock);
8f60e6b0:	e59f0154 	ldr	r0, [pc, #340]	; 8f60e80c <display_unlock_menu+0x324>
	unlock_msg_info->info.option_num = 2;
8f60e6b4:	e3a03002 	mov	r3, #2
8f60e6b8:	e585303c 	str	r3, [r5, #60]	; 0x3c
	unlock_msg_info->info.option_index= 2;
8f60e6bc:	e5853040 	str	r3, [r5, #64]	; 0x40
	mutex_release(&unlock_menu_msg_info->msg_lock);
8f60e6c0:	eb00528f 	bl	8f623104 <mutex_release>
	dprintf(INFO, "creating %s keys detect thread\n",
8f60e6c4:	e30811b8 	movw	r1, #33208	; 0x81b8
8f60e6c8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60e6cc:	ea000016 	b	8f60e72c <display_unlock_menu+0x244>
		display_fbcon_menu_message((char*)lock_menu_common_msg,
8f60e6d0:	e30349ec 	movw	r4, #14828	; 0x39ec
8f60e6d4:	e3484f70 	movt	r4, #36720	; 0x8f70
	while(*str != 0) {
8f60e6d8:	e3a00049 	mov	r0, #73	; 0x49
		fbcon_putc_factor(*str++, type, scale_factor);
8f60e6dc:	e1a02009 	mov	r2, r9
8f60e6e0:	e3a01000 	mov	r1, #0
8f60e6e4:	eb008675 	bl	8f6300c0 <fbcon_putc_factor>
	while(*str != 0) {
8f60e6e8:	e5f40001 	ldrb	r0, [r4, #1]!
8f60e6ec:	e3500000 	cmp	r0, #0
8f60e6f0:	1afffff9 	bne	8f60e6dc <display_unlock_menu+0x1f4>
8f60e6f4:	eaffffb9 	b	8f60e5e0 <display_unlock_menu+0xf8>
	} else if (type == UNLOCK_CRITICAL) {
8f60e6f8:	e3570001 	cmp	r7, #1
8f60e6fc:	0a000022 	beq	8f60e78c <display_unlock_menu+0x2a4>
	mutex_release(&unlock_menu_msg_info->msg_lock);
8f60e700:	e59f0104 	ldr	r0, [pc, #260]	; 8f60e80c <display_unlock_menu+0x324>
	unlock_msg_info->info.option_num = 2;
8f60e704:	e3a03002 	mov	r3, #2
8f60e708:	e585303c 	str	r3, [r5, #60]	; 0x3c
	unlock_msg_info->info.option_index= 2;
8f60e70c:	e5853040 	str	r3, [r5, #64]	; 0x40
	mutex_release(&unlock_menu_msg_info->msg_lock);
8f60e710:	eb00527b 	bl	8f623104 <mutex_release>
	dprintf(INFO, "creating %s keys detect thread\n",
8f60e714:	e3560000 	cmp	r6, #0
8f60e718:	e30831d4 	movw	r3, #33236	; 0x81d4
8f60e71c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f60e720:	e30811b8 	movw	r1, #33208	; 0x81b8
8f60e724:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60e728:	01a01003 	moveq	r1, r3
	if (!is_thread_start) {
8f60e72c:	e30c4cc8 	movw	r4, #52424	; 0xccc8
8f60e730:	e3484f72 	movt	r4, #36722	; 0x8f72
	dprintf(INFO, "creating %s keys detect thread\n",
8f60e734:	e3030b38 	movw	r0, #15160	; 0x3b38
8f60e738:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60e73c:	eb00908c 	bl	8f632974 <_dprintf>
	if (!is_thread_start) {
8f60e740:	e5943000 	ldr	r3, [r4]
8f60e744:	e3530000 	cmp	r3, #0
8f60e748:	1affff71 	bne	8f60e514 <display_unlock_menu+0x2c>
		thr = thread_create("selectkeydetect", &select_msg_keys_detect,
8f60e74c:	e3a00a03 	mov	r0, #12288	; 0x3000
8f60e750:	e3a03010 	mov	r3, #16
8f60e754:	e58d0000 	str	r0, [r13]
8f60e758:	e30c2ccc 	movw	r2, #52428	; 0xcccc
8f60e75c:	e30d1a3c 	movw	r1, #55868	; 0xda3c
8f60e760:	e3482f72 	movt	r2, #36722	; 0x8f72
8f60e764:	e3481f60 	movt	r1, #36704	; 0x8f60
8f60e768:	e3030b58 	movw	r0, #15192	; 0x3b58
8f60e76c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60e770:	eb0054c1 	bl	8f623a7c <thread_create>
		if (!thr) {
8f60e774:	e3500000 	cmp	r0, #0
8f60e778:	0a000016 	beq	8f60e7d8 <display_unlock_menu+0x2f0>
		thread_resume(thr);
8f60e77c:	eb0055af 	bl	8f623e40 <thread_resume>
		is_thread_start = true;
8f60e780:	e3a03001 	mov	r3, #1
8f60e784:	e5843000 	str	r3, [r4]
8f60e788:	eaffff61 	b	8f60e514 <display_unlock_menu+0x2c>
		if (!status)
8f60e78c:	e3560000 	cmp	r6, #0
		unlock_msg_info->info.msg_type = DISPLAY_MENU_UNLOCK_CRITICAL;
8f60e790:	13a03006 	movne	r3, #6
			unlock_msg_info->info.msg_type = DISPLAY_MENU_LOCK_CRITICAL;
8f60e794:	03a0300a 	moveq	r3, #10
		unlock_msg_info->info.msg_type = DISPLAY_MENU_UNLOCK_CRITICAL;
8f60e798:	15853044 	strne	r3, [r5, #68]	; 0x44
			unlock_msg_info->info.msg_type = DISPLAY_MENU_LOCK_CRITICAL;
8f60e79c:	05853044 	streq	r3, [r5, #68]	; 0x44
		if (!status)
8f60e7a0:	1affffc2 	bne	8f60e6b0 <display_unlock_menu+0x1c8>
	mutex_release(&unlock_menu_msg_info->msg_lock);
8f60e7a4:	e59f0060 	ldr	r0, [pc, #96]	; 8f60e80c <display_unlock_menu+0x324>
	unlock_msg_info->info.option_num = 2;
8f60e7a8:	e3a03002 	mov	r3, #2
8f60e7ac:	e585303c 	str	r3, [r5, #60]	; 0x3c
	unlock_msg_info->info.option_index= 2;
8f60e7b0:	e5853040 	str	r3, [r5, #64]	; 0x40
	mutex_release(&unlock_menu_msg_info->msg_lock);
8f60e7b4:	eb005252 	bl	8f623104 <mutex_release>
	dprintf(INFO, "creating %s keys detect thread\n",
8f60e7b8:	e30811d4 	movw	r1, #33236	; 0x81d4
8f60e7bc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60e7c0:	eaffffd9 	b	8f60e72c <display_unlock_menu+0x244>
		mutex_init(&msg_lock_info->msg_lock);
8f60e7c4:	e59f0040 	ldr	r0, [pc, #64]	; 8f60e80c <display_unlock_menu+0x324>
8f60e7c8:	eb0051e8 	bl	8f622f70 <mutex_init>
		is_msg_lock_init = true;
8f60e7cc:	e3a03001 	mov	r3, #1
8f60e7d0:	e5843000 	str	r3, [r4]
}
8f60e7d4:	eaffff5c 	b	8f60e54c <display_unlock_menu+0x64>
			dprintf(CRITICAL, "ERROR: creat device status detect thread failed!!\n");
8f60e7d8:	e59f3028 	ldr	r3, [pc, #40]	; 8f60e808 <display_unlock_menu+0x320>
8f60e7dc:	e5932000 	ldr	r2, [r3]
8f60e7e0:	e59d300c 	ldr	r3, [r13, #12]
8f60e7e4:	e0332002 	eors	r2, r3, r2
8f60e7e8:	e3a03000 	mov	r3, #0
8f60e7ec:	1a000004 	bne	8f60e804 <display_unlock_menu+0x31c>
8f60e7f0:	e3030b68 	movw	r0, #15208	; 0x3b68
8f60e7f4:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f60e7f8:	e28dd010 	add	r13, r13, #16
8f60e7fc:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r14}
			dprintf(CRITICAL, "ERROR: creat device status detect thread failed!!\n");
8f60e800:	ea00905b 	b	8f632974 <_dprintf>
}
8f60e804:	eb0090ed 	bl	8f632bc0 <__stack_chk_fail>
8f60e808:	8f74221c 	.word	0x8f74221c
8f60e80c:	8f72cd24 	.word	0x8f72cd24

8f60e810 <display_fastboot_menu>:

void display_fastboot_menu()
{
8f60e810:	e59f3138 	ldr	r3, [pc, #312]	; 8f60e950 <display_fastboot_menu+0x140>
8f60e814:	e92d4030 	push	{r4, r5, r14}
8f60e818:	e24dd014 	sub	r13, r13, #20
8f60e81c:	e5933000 	ldr	r3, [r3]
8f60e820:	e58d300c 	str	r3, [r13, #12]
8f60e824:	e3a03000 	mov	r3, #0
	struct select_msg_info *fastboot_menu_msg_info;
	fastboot_menu_msg_info = &msg_info;

	if (is_display_disabled())
8f60e828:	eb004e6c 	bl	8f6221e0 <is_display_disabled>
8f60e82c:	e3500000 	cmp	r0, #0
8f60e830:	0a000007 	beq	8f60e854 <display_fastboot_menu+0x44>
	display_fastboot_menu_renew(fastboot_menu_msg_info);
	mutex_release(&fastboot_menu_msg_info->msg_lock);

	dprintf(INFO, "creating fastboot menu keys detect thread\n");
	display_menu_thread_start(fastboot_menu_msg_info);
}
8f60e834:	e59f3114 	ldr	r3, [pc, #276]	; 8f60e950 <display_fastboot_menu+0x140>
8f60e838:	e5932000 	ldr	r2, [r3]
8f60e83c:	e59d300c 	ldr	r3, [r13, #12]
8f60e840:	e0332002 	eors	r2, r3, r2
8f60e844:	e3a03000 	mov	r3, #0
8f60e848:	1a00003f 	bne	8f60e94c <display_fastboot_menu+0x13c>
8f60e84c:	e28dd014 	add	r13, r13, #20
8f60e850:	e8bd8030 	pop	{r4, r5, r15}
	if (!is_msg_lock_init) {
8f60e854:	e30c4cc4 	movw	r4, #52420	; 0xccc4
8f60e858:	e3484f72 	movt	r4, #36722	; 0x8f72
	set_message_factor();
8f60e85c:	ebfffd1c 	bl	8f60dcd4 <set_message_factor>
	if (!is_msg_lock_init) {
8f60e860:	e5943000 	ldr	r3, [r4]
8f60e864:	e3530000 	cmp	r3, #0
8f60e868:	0a000027 	beq	8f60e90c <display_fastboot_menu+0xfc>
	mutex_acquire(&fastboot_menu_msg_info->msg_lock);
8f60e86c:	e59f00e0 	ldr	r0, [pc, #224]	; 8f60e954 <display_fastboot_menu+0x144>
	fastboot_menu_msg_info->info.option_index = (lk2nd_dev.dev_mode) ? 5 : 0;
8f60e870:	e30c4ccc 	movw	r4, #52428	; 0xcccc
	mutex_acquire(&fastboot_menu_msg_info->msg_lock);
8f60e874:	eb0051d4 	bl	8f622fcc <mutex_acquire>
	fastboot_menu_msg_info->info.option_index = (lk2nd_dev.dev_mode) ? 5 : 0;
8f60e878:	e301313c 	movw	r3, #4412	; 0x113c
8f60e87c:	e3483f74 	movt	r3, #36724	; 0x8f74
8f60e880:	e3484f72 	movt	r4, #36722	; 0x8f72
	if (!is_thread_start) {
8f60e884:	e30c5cc8 	movw	r5, #52424	; 0xccc8
8f60e888:	e3485f72 	movt	r5, #36722	; 0x8f72
	fastboot_menu_msg_info->info.option_index = (lk2nd_dev.dev_mode) ? 5 : 0;
8f60e88c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
	display_fastboot_menu_renew(fastboot_menu_msg_info);
8f60e890:	e1a00004 	mov	r0, r4
	fastboot_menu_msg_info->last_msg_type =
8f60e894:	e5942044 	ldr	r2, [r4, #68]	; 0x44
	fastboot_menu_msg_info->info.option_index = (lk2nd_dev.dev_mode) ? 5 : 0;
8f60e898:	e3530000 	cmp	r3, #0
	fastboot_menu_msg_info->last_msg_type =
8f60e89c:	e5842054 	str	r2, [r4, #84]	; 0x54
	fastboot_menu_msg_info->info.option_index = (lk2nd_dev.dev_mode) ? 5 : 0;
8f60e8a0:	13a03005 	movne	r3, #5
8f60e8a4:	03a03000 	moveq	r3, #0
8f60e8a8:	e5843040 	str	r3, [r4, #64]	; 0x40
	display_fastboot_menu_renew(fastboot_menu_msg_info);
8f60e8ac:	ebfffdcf 	bl	8f60dff0 <display_fastboot_menu_renew>
	mutex_release(&fastboot_menu_msg_info->msg_lock);
8f60e8b0:	e2840058 	add	r0, r4, #88	; 0x58
8f60e8b4:	eb005212 	bl	8f623104 <mutex_release>
	dprintf(INFO, "creating fastboot menu keys detect thread\n");
8f60e8b8:	e3030b9c 	movw	r0, #15260	; 0x3b9c
8f60e8bc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60e8c0:	eb00902b 	bl	8f632974 <_dprintf>
	if (!is_thread_start) {
8f60e8c4:	e5953000 	ldr	r3, [r5]
8f60e8c8:	e3530000 	cmp	r3, #0
8f60e8cc:	1affffd8 	bne	8f60e834 <display_fastboot_menu+0x24>
		thr = thread_create("selectkeydetect", &select_msg_keys_detect,
8f60e8d0:	e3a00a03 	mov	r0, #12288	; 0x3000
8f60e8d4:	e3a03010 	mov	r3, #16
8f60e8d8:	e58d0000 	str	r0, [r13]
8f60e8dc:	e1a02004 	mov	r2, r4
8f60e8e0:	e30d1a3c 	movw	r1, #55868	; 0xda3c
8f60e8e4:	e3030b58 	movw	r0, #15192	; 0x3b58
8f60e8e8:	e3481f60 	movt	r1, #36704	; 0x8f60
8f60e8ec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60e8f0:	eb005461 	bl	8f623a7c <thread_create>
		if (!thr) {
8f60e8f4:	e3500000 	cmp	r0, #0
8f60e8f8:	0a000008 	beq	8f60e920 <display_fastboot_menu+0x110>
		thread_resume(thr);
8f60e8fc:	eb00554f 	bl	8f623e40 <thread_resume>
		is_thread_start = true;
8f60e900:	e3a03001 	mov	r3, #1
8f60e904:	e5853000 	str	r3, [r5]
8f60e908:	eaffffc9 	b	8f60e834 <display_fastboot_menu+0x24>
		mutex_init(&msg_lock_info->msg_lock);
8f60e90c:	e59f0040 	ldr	r0, [pc, #64]	; 8f60e954 <display_fastboot_menu+0x144>
8f60e910:	eb005196 	bl	8f622f70 <mutex_init>
		is_msg_lock_init = true;
8f60e914:	e3a03001 	mov	r3, #1
8f60e918:	e5843000 	str	r3, [r4]
}
8f60e91c:	eaffffd2 	b	8f60e86c <display_fastboot_menu+0x5c>
			dprintf(CRITICAL, "ERROR: creat device status detect thread failed!!\n");
8f60e920:	e59f3028 	ldr	r3, [pc, #40]	; 8f60e950 <display_fastboot_menu+0x140>
8f60e924:	e5932000 	ldr	r2, [r3]
8f60e928:	e59d300c 	ldr	r3, [r13, #12]
8f60e92c:	e0332002 	eors	r2, r3, r2
8f60e930:	e3a03000 	mov	r3, #0
8f60e934:	1a000004 	bne	8f60e94c <display_fastboot_menu+0x13c>
8f60e938:	e3030b68 	movw	r0, #15208	; 0x3b68
8f60e93c:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f60e940:	e28dd014 	add	r13, r13, #20
8f60e944:	e8bd4030 	pop	{r4, r5, r14}
			dprintf(CRITICAL, "ERROR: creat device status detect thread failed!!\n");
8f60e948:	ea009009 	b	8f632974 <_dprintf>
}
8f60e94c:	eb00909b 	bl	8f632bc0 <__stack_chk_fail>
8f60e950:	8f74221c 	.word	0x8f74221c
8f60e954:	8f72cd24 	.word	0x8f72cd24

8f60e958 <qgic_dist_init>:
	return mask;
}

/* Intialize distributor */
void qgic_dist_init(void)
{
8f60e958:	e59f30c4 	ldr	r3, [pc, #196]	; 8f60ea24 <qgic_dist_init+0xcc>
8f60e95c:	e3a02b02 	mov	r2, #2048	; 0x800
8f60e960:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60e964:	e24dd00c 	sub	r13, r13, #12
	for (i=0; i < 32; i += 4) {
8f60e968:	e3a01e82 	mov	r1, #2080	; 0x820
{
8f60e96c:	e3402b00 	movt	r2, #2816	; 0xb00
	for (i=0; i < 32; i += 4) {
8f60e970:	e3401b00 	movt	r1, #2816	; 0xb00
{
8f60e974:	e5933000 	ldr	r3, [r3]
8f60e978:	e58d3004 	str	r3, [r13, #4]
8f60e97c:	e3a03000 	mov	r3, #0
		mask = readl(GIC_DIST_TARGET + i);
8f60e980:	e5923000 	ldr	r3, [r2]
		mask |= mask >> 16;
8f60e984:	e1833823 	orr	r3, r3, r3, lsr #16
		if (mask)
8f60e988:	e1933423 	orrs	r3, r3, r3, lsr #8
8f60e98c:	1a00001d 	bne	8f60ea08 <qgic_dist_init+0xb0>
	for (i=0; i < 32; i += 4) {
8f60e990:	e2822004 	add	r2, r2, #4
8f60e994:	e1520001 	cmp	r2, r1
8f60e998:	1afffff8 	bne	8f60e980 <qgic_dist_init+0x28>

	cpumask |= cpumask << 8;
	cpumask |= cpumask << 16;

	/* Disabling GIC */
	writel(0, GIC_DIST_CTRL);
8f60e99c:	e3a0240b 	mov	r2, #184549376	; 0xb000000
8f60e9a0:	e3a01000 	mov	r1, #0
8f60e9a4:	e5821000 	str	r1, [r2]

	/*
	 * Find out how many interrupts are supported.
	 */
	num_irq = readl(GIC_DIST_CTR) & 0x1f;
8f60e9a8:	e5920004 	ldr	r0, [r2, #4]
8f60e9ac:	e200001f 	and	r0, r0, #31
	num_irq = (num_irq + 1) * 32;
8f60e9b0:	e2800001 	add	r0, r0, #1

	/* Set up interrupts for this CPU */
	for (i = 32; i < num_irq; i += 4)
8f60e9b4:	e3500001 	cmp	r0, #1
	num_irq = (num_irq + 1) * 32;
8f60e9b8:	e1a00280 	lsl	r0, r0, #5
	for (i = 32; i < num_irq; i += 4)
8f60e9bc:	13a02020 	movne	r2, #32
8f60e9c0:	0a000004 	beq	8f60e9d8 <qgic_dist_init+0x80>
		writel(cpumask, GIC_DIST_TARGET + i * 4 / 4);
8f60e9c4:	e282140b 	add	r1, r2, #184549376	; 0xb000000
	for (i = 32; i < num_irq; i += 4)
8f60e9c8:	e2822004 	add	r2, r2, #4
8f60e9cc:	e1500002 	cmp	r0, r2
		writel(cpumask, GIC_DIST_TARGET + i * 4 / 4);
8f60e9d0:	e5813800 	str	r3, [r1, #2048]	; 0x800
	for (i = 32; i < num_irq; i += 4)
8f60e9d4:	8afffffa 	bhi	8f60e9c4 <qgic_dist_init+0x6c>

	qgic_dist_config(num_irq);
8f60e9d8:	ebffe218 	bl	8f607240 <qgic_dist_config>

	/*Enabling GIC */
	writel(1, GIC_DIST_CTRL);
8f60e9dc:	e3a0340b 	mov	r3, #184549376	; 0xb000000
8f60e9e0:	e3a02001 	mov	r2, #1
8f60e9e4:	e5832000 	str	r2, [r3]
}
8f60e9e8:	e59f3034 	ldr	r3, [pc, #52]	; 8f60ea24 <qgic_dist_init+0xcc>
8f60e9ec:	e5932000 	ldr	r2, [r3]
8f60e9f0:	e59d3004 	ldr	r3, [r13, #4]
8f60e9f4:	e0332002 	eors	r2, r3, r2
8f60e9f8:	e3a03000 	mov	r3, #0
8f60e9fc:	1a000007 	bne	8f60ea20 <qgic_dist_init+0xc8>
8f60ea00:	e28dd00c 	add	r13, r13, #12
8f60ea04:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	cpumask |= cpumask << 8;
8f60ea08:	e1a02403 	lsl	r2, r3, #8
8f60ea0c:	e6ef3073 	uxtb	r3, r3
8f60ea10:	e6ff2072 	uxth	r2, r2
8f60ea14:	e1823003 	orr	r3, r2, r3
	cpumask |= cpumask << 16;
8f60ea18:	e1833803 	orr	r3, r3, r3, lsl #16
8f60ea1c:	eaffffde 	b	8f60e99c <qgic_dist_init+0x44>
}
8f60ea20:	eb009066 	bl	8f632bc0 <__stack_chk_fail>
8f60ea24:	8f74221c 	.word	0x8f74221c

8f60ea28 <qgic_cpu_init>:

/* Intialize cpu specific controller */
void qgic_cpu_init(void)
{
8f60ea28:	e59f204c 	ldr	r2, [pc, #76]	; 8f60ea7c <qgic_cpu_init+0x54>
	writel(0xf0, GIC_CPU_PRIMASK);
8f60ea2c:	e3a03a02 	mov	r3, #8192	; 0x2000
8f60ea30:	e3403b00 	movt	r3, #2816	; 0xb00
8f60ea34:	e3a010f0 	mov	r1, #240	; 0xf0
{
8f60ea38:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60ea3c:	e24dd00c 	sub	r13, r13, #12
8f60ea40:	e5922000 	ldr	r2, [r2]
8f60ea44:	e58d2004 	str	r2, [r13, #4]
8f60ea48:	e3a02000 	mov	r2, #0
	writel(0xf0, GIC_CPU_PRIMASK);
8f60ea4c:	e5831004 	str	r1, [r3, #4]
	writel(1, GIC_CPU_CTRL);
8f60ea50:	e3a02001 	mov	r2, #1
8f60ea54:	e5832000 	str	r2, [r3]
}
8f60ea58:	e59f301c 	ldr	r3, [pc, #28]	; 8f60ea7c <qgic_cpu_init+0x54>
8f60ea5c:	e5932000 	ldr	r2, [r3]
8f60ea60:	e59d3004 	ldr	r3, [r13, #4]
8f60ea64:	e0332002 	eors	r2, r3, r2
8f60ea68:	e3a03000 	mov	r3, #0
8f60ea6c:	1a000001 	bne	8f60ea78 <qgic_cpu_init+0x50>
8f60ea70:	e28dd00c 	add	r13, r13, #12
8f60ea74:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60ea78:	eb009050 	bl	8f632bc0 <__stack_chk_fail>
8f60ea7c:	8f74221c 	.word	0x8f74221c

8f60ea80 <qgic_read_iar>:

uint32_t qgic_read_iar()
{
8f60ea80:	e59f2040 	ldr	r2, [pc, #64]	; 8f60eac8 <qgic_read_iar+0x48>
	return readl(GIC_CPU_INTACK);
8f60ea84:	e3a03a02 	mov	r3, #8192	; 0x2000
{
8f60ea88:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60ea8c:	e24dd00c 	sub	r13, r13, #12
	return readl(GIC_CPU_INTACK);
8f60ea90:	e3403b00 	movt	r3, #2816	; 0xb00
{
8f60ea94:	e5922000 	ldr	r2, [r2]
8f60ea98:	e58d2004 	str	r2, [r13, #4]
8f60ea9c:	e3a02000 	mov	r2, #0
	return readl(GIC_CPU_INTACK);
8f60eaa0:	e593000c 	ldr	r0, [r3, #12]
}
8f60eaa4:	e59f301c 	ldr	r3, [pc, #28]	; 8f60eac8 <qgic_read_iar+0x48>
8f60eaa8:	e5932000 	ldr	r2, [r3]
8f60eaac:	e59d3004 	ldr	r3, [r13, #4]
8f60eab0:	e0332002 	eors	r2, r3, r2
8f60eab4:	e3a03000 	mov	r3, #0
8f60eab8:	1a000001 	bne	8f60eac4 <qgic_read_iar+0x44>
8f60eabc:	e28dd00c 	add	r13, r13, #12
8f60eac0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60eac4:	eb00903d 	bl	8f632bc0 <__stack_chk_fail>
8f60eac8:	8f74221c 	.word	0x8f74221c

8f60eacc <qgic_write_eoi>:

void qgic_write_eoi(uint32_t num)
{
8f60eacc:	e59f2040 	ldr	r2, [pc, #64]	; 8f60eb14 <qgic_write_eoi+0x48>
	writel(num, GIC_CPU_EOI);
8f60ead0:	e3a03a02 	mov	r3, #8192	; 0x2000
8f60ead4:	e3403b00 	movt	r3, #2816	; 0xb00
{
8f60ead8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60eadc:	e24dd00c 	sub	r13, r13, #12
8f60eae0:	e5922000 	ldr	r2, [r2]
8f60eae4:	e58d2004 	str	r2, [r13, #4]
8f60eae8:	e3a02000 	mov	r2, #0
	writel(num, GIC_CPU_EOI);
8f60eaec:	e5830010 	str	r0, [r3, #16]
}
8f60eaf0:	e59f301c 	ldr	r3, [pc, #28]	; 8f60eb14 <qgic_write_eoi+0x48>
8f60eaf4:	e5932000 	ldr	r2, [r3]
8f60eaf8:	e59d3004 	ldr	r3, [r13, #4]
8f60eafc:	e0332002 	eors	r2, r3, r2
8f60eb00:	e3a03000 	mov	r3, #0
8f60eb04:	1a000001 	bne	8f60eb10 <qgic_write_eoi+0x44>
8f60eb08:	e28dd00c 	add	r13, r13, #12
8f60eb0c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60eb10:	eb00902a 	bl	8f632bc0 <__stack_chk_fail>
8f60eb14:	8f74221c 	.word	0x8f74221c

8f60eb18 <delay>:
/* Blocking function to wait until the specified ticks of the timer.
 * Note: ticks to wait for cannot be more than 56 bit.
 *          Should be sufficient for all practical purposes.
 */
static void delay(uint64_t ticks)
{
8f60eb18:	e59f30b0 	ldr	r3, [pc, #176]	; 8f60ebd0 <delay+0xb8>
8f60eb1c:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f60eb20:	e24dd014 	sub	r13, r13, #20
8f60eb24:	e5933000 	ldr	r3, [r3]
8f60eb28:	e58d300c 	str	r3, [r13, #12]
8f60eb2c:	e3a03000 	mov	r3, #0
8f60eb30:	e1a05000 	mov	r5, r0
8f60eb34:	e1a04001 	mov	r4, r1
	volatile uint64_t cnt;
	uint64_t init_cnt;
	uint64_t timeout = 0;

	cnt = qtimer_get_phy_timer_cnt();
8f60eb38:	eb000165 	bl	8f60f0d4 <qtimer_get_phy_timer_cnt>
8f60eb3c:	e1cd00f0 	strd	r0, [r13]
	init_cnt = cnt;
8f60eb40:	e1cd60d0 	ldrd	r6, [r13]

	/* Calculate timeout = cnt + ticks (mod 2^56)
	 * to account for timer counter wrapping
	 */
	timeout = (cnt + ticks) & (uint64_t)(QTMR_PHY_CNT_MAX_VALUE);
8f60eb44:	e1cd20d0 	ldrd	r2, [r13]
8f60eb48:	e0925005 	adds	r5, r2, r5
8f60eb4c:	e0a44003 	adc	r4, r4, r3

	/* Wait out till the counter wrapping occurs
	 * in cases where there is a wrapping.
	 */
	while(timeout < cnt && init_cnt <= cnt)
8f60eb50:	e1cd20d0 	ldrd	r2, [r13]
	timeout = (cnt + ticks) & (uint64_t)(QTMR_PHY_CNT_MAX_VALUE);
8f60eb54:	e3c444ff 	bic	r4, r4, #-16777216	; 0xff000000
	while(timeout < cnt && init_cnt <= cnt)
8f60eb58:	e1550002 	cmp	r5, r2
8f60eb5c:	e0d43003 	sbcs	r3, r4, r3
8f60eb60:	3a000006 	bcc	8f60eb80 <delay+0x68>
8f60eb64:	ea00000c 	b	8f60eb9c <delay+0x84>
		/* read global counter */
		cnt = qtimer_get_phy_timer_cnt();
8f60eb68:	eb000159 	bl	8f60f0d4 <qtimer_get_phy_timer_cnt>
8f60eb6c:	e1cd00f0 	strd	r0, [r13]
	while(timeout < cnt && init_cnt <= cnt)
8f60eb70:	e1cd20d0 	ldrd	r2, [r13]
8f60eb74:	e1550002 	cmp	r5, r2
8f60eb78:	e0d43003 	sbcs	r3, r4, r3
8f60eb7c:	2a000006 	bcs	8f60eb9c <delay+0x84>
8f60eb80:	e1cd20d0 	ldrd	r2, [r13]
8f60eb84:	e1520006 	cmp	r2, r6
8f60eb88:	e0d33007 	sbcs	r3, r3, r7
8f60eb8c:	2afffff5 	bcs	8f60eb68 <delay+0x50>
8f60eb90:	ea000001 	b	8f60eb9c <delay+0x84>

	/* Wait till the number of ticks is reached*/
	while(timeout > cnt)
		/* read global counter */
		cnt = qtimer_get_phy_timer_cnt();
8f60eb94:	eb00014e 	bl	8f60f0d4 <qtimer_get_phy_timer_cnt>
8f60eb98:	e1cd00f0 	strd	r0, [r13]
	while(timeout > cnt)
8f60eb9c:	e1cd20d0 	ldrd	r2, [r13]
8f60eba0:	e1520005 	cmp	r2, r5
8f60eba4:	e0d33004 	sbcs	r3, r3, r4
8f60eba8:	3afffff9 	bcc	8f60eb94 <delay+0x7c>

}
8f60ebac:	e59f301c 	ldr	r3, [pc, #28]	; 8f60ebd0 <delay+0xb8>
8f60ebb0:	e5932000 	ldr	r2, [r3]
8f60ebb4:	e59d300c 	ldr	r3, [r13, #12]
8f60ebb8:	e0332002 	eors	r2, r3, r2
8f60ebbc:	e3a03000 	mov	r3, #0
8f60ebc0:	1a000001 	bne	8f60ebcc <delay+0xb4>
8f60ebc4:	e28dd014 	add	r13, r13, #20
8f60ebc8:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
8f60ebcc:	eb008ffb 	bl	8f632bc0 <__stack_chk_fail>
8f60ebd0:	8f74221c 	.word	0x8f74221c

8f60ebd4 <platform_set_periodic_timer>:
{
8f60ebd4:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	critical_section_count++;
8f60ebd8:	e3014acc 	movw	r4, #6860	; 0x1acc
8f60ebdc:	e3484f71 	movt	r4, #36721	; 0x8f71
8f60ebe0:	e1a05002 	mov	r5, r2
8f60ebe4:	e59f2084 	ldr	r2, [pc, #132]	; 8f60ec70 <platform_set_periodic_timer+0x9c>
8f60ebe8:	e24dd00c 	sub	r13, r13, #12
8f60ebec:	e5943000 	ldr	r3, [r4]
8f60ebf0:	e1a06000 	mov	r6, r0
8f60ebf4:	e5922000 	ldr	r2, [r2]
8f60ebf8:	e58d2004 	str	r2, [r13, #4]
8f60ebfc:	e3a02000 	mov	r2, #0
8f60ec00:	e1a07001 	mov	r7, r1
8f60ec04:	e2833001 	add	r3, r3, #1
8f60ec08:	e5843000 	str	r3, [r4]
	if (critical_section_count == 1)
8f60ec0c:	e3530001 	cmp	r3, #1
8f60ec10:	0a000013 	beq	8f60ec64 <platform_set_periodic_timer+0x90>
	qtimer_set_physical_timer(interval, callback, arg);
8f60ec14:	e1a02007 	mov	r2, r7
8f60ec18:	e1a01006 	mov	r1, r6
8f60ec1c:	e1a00005 	mov	r0, r5
8f60ec20:	eb0000c8 	bl	8f60ef48 <qtimer_set_physical_timer>
	critical_section_count--;
8f60ec24:	e5943000 	ldr	r3, [r4]
8f60ec28:	e2433001 	sub	r3, r3, #1
8f60ec2c:	e5843000 	str	r3, [r4]
	if (critical_section_count == 0)
8f60ec30:	e3530000 	cmp	r3, #0
8f60ec34:	0a000008 	beq	8f60ec5c <platform_set_periodic_timer+0x88>
}
8f60ec38:	e59f3030 	ldr	r3, [pc, #48]	; 8f60ec70 <platform_set_periodic_timer+0x9c>
8f60ec3c:	e5932000 	ldr	r2, [r3]
8f60ec40:	e59d3004 	ldr	r3, [r13, #4]
8f60ec44:	e0332002 	eors	r2, r3, r2
8f60ec48:	e3a03000 	mov	r3, #0
8f60ec4c:	1a000006 	bne	8f60ec6c <platform_set_periodic_timer+0x98>
8f60ec50:	e3a00000 	mov	r0, #0
8f60ec54:	e28dd00c 	add	r13, r13, #12
8f60ec58:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		arch_enable_ints();
8f60ec5c:	eb0048e9 	bl	8f621008 <arch_enable_ints>
8f60ec60:	eafffff4 	b	8f60ec38 <platform_set_periodic_timer+0x64>
		arch_disable_ints();
8f60ec64:	eb0048eb 	bl	8f621018 <arch_disable_ints>
8f60ec68:	eaffffe9 	b	8f60ec14 <platform_set_periodic_timer+0x40>
8f60ec6c:	eb008fd3 	bl	8f632bc0 <__stack_chk_fail>
8f60ec70:	8f74221c 	.word	0x8f74221c

8f60ec74 <current_time>:
{
8f60ec74:	e59f3038 	ldr	r3, [pc, #56]	; 8f60ecb4 <current_time+0x40>
8f60ec78:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60ec7c:	e24dd00c 	sub	r13, r13, #12
8f60ec80:	e5933000 	ldr	r3, [r3]
8f60ec84:	e58d3004 	str	r3, [r13, #4]
8f60ec88:	e3a03000 	mov	r3, #0
	return qtimer_current_time();
8f60ec8c:	e59f3020 	ldr	r3, [pc, #32]	; 8f60ecb4 <current_time+0x40>
8f60ec90:	e5932000 	ldr	r2, [r3]
8f60ec94:	e59d3004 	ldr	r3, [r13, #4]
8f60ec98:	e0332002 	eors	r2, r3, r2
8f60ec9c:	e3a03000 	mov	r3, #0
8f60eca0:	1a000002 	bne	8f60ecb0 <current_time+0x3c>
}
8f60eca4:	e28dd00c 	add	r13, r13, #12
8f60eca8:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return qtimer_current_time();
8f60ecac:	ea00011f 	b	8f60f130 <qtimer_current_time>
8f60ecb0:	eb008fc2 	bl	8f632bc0 <__stack_chk_fail>
8f60ecb4:	8f74221c 	.word	0x8f74221c

8f60ecb8 <qtimer_uninit>:
{
8f60ecb8:	e59f3038 	ldr	r3, [pc, #56]	; 8f60ecf8 <qtimer_uninit+0x40>
8f60ecbc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60ecc0:	e24dd00c 	sub	r13, r13, #12
8f60ecc4:	e5933000 	ldr	r3, [r3]
8f60ecc8:	e58d3004 	str	r3, [r13, #4]
8f60eccc:	e3a03000 	mov	r3, #0
	qtimer_disable();
8f60ecd0:	e59f3020 	ldr	r3, [pc, #32]	; 8f60ecf8 <qtimer_uninit+0x40>
8f60ecd4:	e5932000 	ldr	r2, [r3]
8f60ecd8:	e59d3004 	ldr	r3, [r13, #4]
8f60ecdc:	e0332002 	eors	r2, r3, r2
8f60ece0:	e3a03000 	mov	r3, #0
8f60ece4:	1a000002 	bne	8f60ecf4 <qtimer_uninit+0x3c>
}
8f60ece8:	e28dd00c 	add	r13, r13, #12
8f60ecec:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	qtimer_disable();
8f60ecf0:	ea0000e0 	b	8f60f078 <qtimer_disable>
8f60ecf4:	eb008fb1 	bl	8f632bc0 <__stack_chk_fail>
8f60ecf8:	8f74221c 	.word	0x8f74221c

8f60ecfc <mdelay>:


void mdelay(unsigned msecs)
{
8f60ecfc:	e59f3054 	ldr	r3, [pc, #84]	; 8f60ed58 <mdelay+0x5c>
8f60ed00:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60ed04:	e24dd00c 	sub	r13, r13, #12
8f60ed08:	e5933000 	ldr	r3, [r3]
8f60ed0c:	e58d3004 	str	r3, [r13, #4]
8f60ed10:	e3a03000 	mov	r3, #0
	uint64_t ticks;

	ticks = ((uint64_t) msecs * ticks_per_sec) / 1000;

	delay(ticks);
8f60ed14:	e59f303c 	ldr	r3, [pc, #60]	; 8f60ed58 <mdelay+0x5c>
8f60ed18:	e5932000 	ldr	r2, [r3]
8f60ed1c:	e59d3004 	ldr	r3, [r13, #4]
8f60ed20:	e0332002 	eors	r2, r3, r2
8f60ed24:	e3a03000 	mov	r3, #0
8f60ed28:	1a000009 	bne	8f60ed54 <mdelay+0x58>
	ticks = ((uint64_t) msecs * ticks_per_sec) / 1000;
8f60ed2c:	e30c1d40 	movw	r1, #52544	; 0xcd40
8f60ed30:	e3481f72 	movt	r1, #36722	; 0x8f72
8f60ed34:	e3a02ffa 	mov	r2, #1000	; 0x3e8
8f60ed38:	e3a03000 	mov	r3, #0
8f60ed3c:	e5911000 	ldr	r1, [r1]
8f60ed40:	e0810190 	umull	r0, r1, r0, r1
8f60ed44:	fa00b916 	blx	8f63d1a4 <__aeabi_uldivmod>
}
8f60ed48:	e28dd00c 	add	r13, r13, #12
8f60ed4c:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	delay(ticks);
8f60ed50:	eaffff70 	b	8f60eb18 <delay>
8f60ed54:	eb008f99 	bl	8f632bc0 <__stack_chk_fail>
8f60ed58:	8f74221c 	.word	0x8f74221c

8f60ed5c <udelay>:

void udelay(unsigned usecs)
{
8f60ed5c:	e59f3058 	ldr	r3, [pc, #88]	; 8f60edbc <udelay+0x60>
8f60ed60:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60ed64:	e24dd00c 	sub	r13, r13, #12
8f60ed68:	e5933000 	ldr	r3, [r3]
8f60ed6c:	e58d3004 	str	r3, [r13, #4]
8f60ed70:	e3a03000 	mov	r3, #0
	uint64_t ticks;

	ticks = ((uint64_t) usecs * ticks_per_sec) / 1000000;

	delay(ticks);
8f60ed74:	e59f3040 	ldr	r3, [pc, #64]	; 8f60edbc <udelay+0x60>
8f60ed78:	e5932000 	ldr	r2, [r3]
8f60ed7c:	e59d3004 	ldr	r3, [r13, #4]
8f60ed80:	e0332002 	eors	r2, r3, r2
8f60ed84:	e3a03000 	mov	r3, #0
8f60ed88:	1a00000a 	bne	8f60edb8 <udelay+0x5c>
	ticks = ((uint64_t) usecs * ticks_per_sec) / 1000000;
8f60ed8c:	e30c1d40 	movw	r1, #52544	; 0xcd40
8f60ed90:	e3481f72 	movt	r1, #36722	; 0x8f72
8f60ed94:	e3a03000 	mov	r3, #0
8f60ed98:	e3042240 	movw	r2, #16960	; 0x4240
8f60ed9c:	e5911000 	ldr	r1, [r1]
8f60eda0:	e340200f 	movt	r2, #15
8f60eda4:	e0810190 	umull	r0, r1, r0, r1
8f60eda8:	fa00b8fd 	blx	8f63d1a4 <__aeabi_uldivmod>
}
8f60edac:	e28dd00c 	add	r13, r13, #12
8f60edb0:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	delay(ticks);
8f60edb4:	eaffff57 	b	8f60eb18 <delay>
8f60edb8:	eb008f80 	bl	8f632bc0 <__stack_chk_fail>
8f60edbc:	8f74221c 	.word	0x8f74221c

8f60edc0 <current_time_hires>:

/* Return current time in micro seconds */
bigtime_t current_time_hires(void)
{
8f60edc0:	e59f3044 	ldr	r3, [pc, #68]	; 8f60ee0c <current_time_hires+0x4c>
8f60edc4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60edc8:	e24dd00c 	sub	r13, r13, #12
8f60edcc:	e5933000 	ldr	r3, [r3]
8f60edd0:	e58d3004 	str	r3, [r13, #4]
8f60edd4:	e3a03000 	mov	r3, #0
	return qtimer_current_time() * 1000000ULL;
8f60edd8:	eb0000d4 	bl	8f60f130 <qtimer_current_time>
}
8f60eddc:	e59f3028 	ldr	r3, [pc, #40]	; 8f60ee0c <current_time_hires+0x4c>
	return qtimer_current_time() * 1000000ULL;
8f60ede0:	e3041240 	movw	r1, #16960	; 0x4240
8f60ede4:	e340100f 	movt	r1, #15
}
8f60ede8:	e5932000 	ldr	r2, [r3]
8f60edec:	e59d3004 	ldr	r3, [r13, #4]
8f60edf0:	e0332002 	eors	r2, r3, r2
8f60edf4:	e3a03000 	mov	r3, #0
	return qtimer_current_time() * 1000000ULL;
8f60edf8:	e0810190 	umull	r0, r1, r0, r1
}
8f60edfc:	1a000001 	bne	8f60ee08 <current_time_hires+0x48>
8f60ee00:	e28dd00c 	add	r13, r13, #12
8f60ee04:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60ee08:	eb008f6c 	bl	8f632bc0 <__stack_chk_fail>
8f60ee0c:	8f74221c 	.word	0x8f74221c

8f60ee10 <qtimer_init>:

void qtimer_init()
{
8f60ee10:	e59f3044 	ldr	r3, [pc, #68]	; 8f60ee5c <qtimer_init+0x4c>
8f60ee14:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60ee18:	e24dd00c 	sub	r13, r13, #12
8f60ee1c:	e5933000 	ldr	r3, [r3]
8f60ee20:	e58d3004 	str	r3, [r13, #4]
8f60ee24:	e3a03000 	mov	r3, #0
	ticks_per_sec = qtimer_get_frequency();
8f60ee28:	eb000080 	bl	8f60f030 <qtimer_get_frequency>
8f60ee2c:	e30c3d40 	movw	r3, #52544	; 0xcd40
8f60ee30:	e3483f72 	movt	r3, #36722	; 0x8f72
8f60ee34:	e5830000 	str	r0, [r3]
}
8f60ee38:	e59f301c 	ldr	r3, [pc, #28]	; 8f60ee5c <qtimer_init+0x4c>
8f60ee3c:	e5932000 	ldr	r2, [r3]
8f60ee40:	e59d3004 	ldr	r3, [r13, #4]
8f60ee44:	e0332002 	eors	r2, r3, r2
8f60ee48:	e3a03000 	mov	r3, #0
8f60ee4c:	1a000001 	bne	8f60ee58 <qtimer_init+0x48>
8f60ee50:	e28dd00c 	add	r13, r13, #12
8f60ee54:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60ee58:	eb008f58 	bl	8f632bc0 <__stack_chk_fail>
8f60ee5c:	8f74221c 	.word	0x8f74221c

8f60ee60 <qtimer_tick_rate>:

uint32_t qtimer_tick_rate()
{
	return ticks_per_sec;
8f60ee60:	e30c3d40 	movw	r3, #52544	; 0xcd40
8f60ee64:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f60ee68:	e59f2038 	ldr	r2, [pc, #56]	; 8f60eea8 <qtimer_tick_rate+0x48>
8f60ee6c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60ee70:	e24dd00c 	sub	r13, r13, #12
	return ticks_per_sec;
8f60ee74:	e5930000 	ldr	r0, [r3]
{
8f60ee78:	e5922000 	ldr	r2, [r2]
8f60ee7c:	e58d2004 	str	r2, [r13, #4]
8f60ee80:	e3a02000 	mov	r2, #0
}
8f60ee84:	e59f301c 	ldr	r3, [pc, #28]	; 8f60eea8 <qtimer_tick_rate+0x48>
8f60ee88:	e5932000 	ldr	r2, [r3]
8f60ee8c:	e59d3004 	ldr	r3, [r13, #4]
8f60ee90:	e0332002 	eors	r2, r3, r2
8f60ee94:	e3a03000 	mov	r3, #0
8f60ee98:	1a000001 	bne	8f60eea4 <qtimer_tick_rate+0x44>
8f60ee9c:	e28dd00c 	add	r13, r13, #12
8f60eea0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60eea4:	eb008f45 	bl	8f632bc0 <__stack_chk_fail>
8f60eea8:	8f74221c 	.word	0x8f74221c

8f60eeac <qtimer_irq>:
	current_time += timer_interval;

	/* Program the down counter again to get
	 * an interrupt after timer_interval msecs
	 */
	writel(tick_count, QTMR_V1_CNTP_TVAL);
8f60eeac:	e30c1d48 	movw	r1, #52552	; 0xcd48
8f60eeb0:	e3481f72 	movt	r1, #36722	; 0x8f72
{
8f60eeb4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60eeb8:	e24dd00c 	sub	r13, r13, #12
	writel(tick_count, QTMR_V1_CNTP_TVAL);
8f60eebc:	e5910000 	ldr	r0, [r1]
	current_time += timer_interval;
8f60eec0:	e30c3d44 	movw	r3, #52548	; 0xcd44
{
8f60eec4:	e59f1078 	ldr	r1, [pc, #120]	; 8f60ef44 <qtimer_irq+0x98>
	current_time += timer_interval;
8f60eec8:	e3483f72 	movt	r3, #36722	; 0x8f72
8f60eecc:	e30c2d54 	movw	r2, #52564	; 0xcd54
8f60eed0:	e3482f72 	movt	r2, #36722	; 0x8f72
{
8f60eed4:	e5911000 	ldr	r1, [r1]
8f60eed8:	e58d1004 	str	r1, [r13, #4]
8f60eedc:	e3a01000 	mov	r1, #0
	current_time += timer_interval;
8f60eee0:	e5921000 	ldr	r1, [r2]
8f60eee4:	e5932000 	ldr	r2, [r3]
8f60eee8:	e0822001 	add	r2, r2, r1
	writel(tick_count, QTMR_V1_CNTP_TVAL);
8f60eeec:	e3a01a01 	mov	r1, #4096	; 0x1000
8f60eef0:	e3401b02 	movt	r1, #2818	; 0xb02
	current_time += timer_interval;
8f60eef4:	e5832000 	str	r2, [r3]
	writel(tick_count, QTMR_V1_CNTP_TVAL);
8f60eef8:	e5810028 	str	r0, [r1, #40]	; 0x28
	dsb();
8f60eefc:	f57ff04f 	dsb	sy

	return timer_callback(timer_arg, current_time);
8f60ef00:	e5931000 	ldr	r1, [r3]
8f60ef04:	e59f3038 	ldr	r3, [pc, #56]	; 8f60ef44 <qtimer_irq+0x98>
8f60ef08:	e5932000 	ldr	r2, [r3]
8f60ef0c:	e59d3004 	ldr	r3, [r13, #4]
8f60ef10:	e0332002 	eors	r2, r3, r2
8f60ef14:	e3a03000 	mov	r3, #0
8f60ef18:	1a000008 	bne	8f60ef40 <qtimer_irq+0x94>
8f60ef1c:	e30c3d4c 	movw	r3, #52556	; 0xcd4c
8f60ef20:	e30c2d50 	movw	r2, #52560	; 0xcd50
8f60ef24:	e3483f72 	movt	r3, #36722	; 0x8f72
8f60ef28:	e3482f72 	movt	r2, #36722	; 0x8f72
8f60ef2c:	e5930000 	ldr	r0, [r3]
8f60ef30:	e5922000 	ldr	r2, [r2]
}
8f60ef34:	e28dd00c 	add	r13, r13, #12
8f60ef38:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return timer_callback(timer_arg, current_time);
8f60ef3c:	e12fff12 	bx	r2
8f60ef40:	eb008f1e 	bl	8f632bc0 <__stack_chk_fail>
8f60ef44:	8f74221c 	.word	0x8f74221c

8f60ef48 <qtimer_set_physical_timer>:
 * interval : Counter ticks till expiry interrupt is fired.
 */
void qtimer_set_physical_timer(time_t msecs_interval,
							   platform_timer_callback tmr_callback,
							   void *tmr_arg)
{
8f60ef48:	e59f30dc 	ldr	r3, [pc, #220]	; 8f60f02c <qtimer_set_physical_timer+0xe4>
8f60ef4c:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f60ef50:	e24dd00c 	sub	r13, r13, #12
8f60ef54:	e5933000 	ldr	r3, [r3]
8f60ef58:	e58d3004 	str	r3, [r13, #4]
8f60ef5c:	e3a03000 	mov	r3, #0

void qtimer_disable()
{
	uint32_t ctrl;

	ctrl = readl(QTMR_V1_CNTP_CTL);
8f60ef60:	e3a04a01 	mov	r4, #4096	; 0x1000
8f60ef64:	e3404b02 	movt	r4, #2818	; 0xb02
{
8f60ef68:	e1a05000 	mov	r5, r0
8f60ef6c:	e1a06001 	mov	r6, r1
8f60ef70:	e1a07002 	mov	r7, r2
	ctrl = readl(QTMR_V1_CNTP_CTL);
8f60ef74:	e594302c 	ldr	r3, [r4, #44]	; 0x2c

	/* program cntrl register */
	ctrl &= ~QTMR_TIMER_CTRL_ENABLE;
8f60ef78:	e3c33001 	bic	r3, r3, #1
	ctrl |= QTMR_TIMER_CTRL_INT_MASK;
8f60ef7c:	e3833002 	orr	r3, r3, #2

	writel(ctrl, QTMR_V1_CNTP_CTL);
8f60ef80:	e584302c 	str	r3, [r4, #44]	; 0x2c
	dsb();
8f60ef84:	f57ff04f 	dsb	sy
	tick_count = msecs_interval * qtimer_tick_rate() / 1000;;
8f60ef88:	ebffffb4 	bl	8f60ee60 <qtimer_tick_rate>
	timer_arg = tmr_arg;
8f60ef8c:	e30c1d4c 	movw	r1, #52556	; 0xcd4c
8f60ef90:	e3481f72 	movt	r1, #36722	; 0x8f72
8f60ef94:	e5817000 	str	r7, [r1]
	tick_count = msecs_interval * qtimer_tick_rate() / 1000;;
8f60ef98:	e0030095 	mul	r3, r5, r0
8f60ef9c:	e3040dd3 	movw	r0, #19923	; 0x4dd3
8f60efa0:	e3410062 	movt	r0, #4194	; 0x1062
8f60efa4:	e0832390 	umull	r2, r3, r0, r3
8f60efa8:	e30c2d48 	movw	r2, #52552	; 0xcd48
8f60efac:	e3482f72 	movt	r2, #36722	; 0x8f72
8f60efb0:	e1a03323 	lsr	r3, r3, #6
8f60efb4:	e5823000 	str	r3, [r2]
	timer_interval = msecs_interval;
8f60efb8:	e30c2d54 	movw	r2, #52564	; 0xcd54
8f60efbc:	e3482f72 	movt	r2, #36722	; 0x8f72
8f60efc0:	e5825000 	str	r5, [r2]
	timer_callback = tmr_callback;
8f60efc4:	e30c2d50 	movw	r2, #52560	; 0xcd50
8f60efc8:	e3482f72 	movt	r2, #36722	; 0x8f72
8f60efcc:	e5826000 	str	r6, [r2]
	writel(tick_count, QTMR_V1_CNTP_TVAL);
8f60efd0:	e5843028 	str	r3, [r4, #40]	; 0x28
	dsb();
8f60efd4:	f57ff04f 	dsb	sy
	register_int_handler(INT_QTMR_FRM_0_PHYSICAL_TIMER_EXP, qtimer_irq, 0);
8f60efd8:	e3a02000 	mov	r2, #0
8f60efdc:	e3000121 	movw	r0, #289	; 0x121
8f60efe0:	e30e1eac 	movw	r1, #61100	; 0xeeac
8f60efe4:	e3481f60 	movt	r1, #36704	; 0x8f60
8f60efe8:	eb0000a7 	bl	8f60f28c <register_int_handler>
	unmask_interrupt(INT_QTMR_FRM_0_PHYSICAL_TIMER_EXP);
8f60efec:	e3000121 	movw	r0, #289	; 0x121
8f60eff0:	eb000094 	bl	8f60f248 <unmask_interrupt>
	ctrl = readl(QTMR_V1_CNTP_CTL);
8f60eff4:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
	ctrl &= ~QTMR_TIMER_CTRL_INT_MASK;
8f60eff8:	e3c33002 	bic	r3, r3, #2
8f60effc:	e3833001 	orr	r3, r3, #1
	writel(ctrl, QTMR_V1_CNTP_CTL);
8f60f000:	e584302c 	str	r3, [r4, #44]	; 0x2c
	dsb();
8f60f004:	f57ff04f 	dsb	sy
}
8f60f008:	e59f301c 	ldr	r3, [pc, #28]	; 8f60f02c <qtimer_set_physical_timer+0xe4>
8f60f00c:	e5932000 	ldr	r2, [r3]
8f60f010:	e59d3004 	ldr	r3, [r13, #4]
8f60f014:	e0332002 	eors	r2, r3, r2
8f60f018:	e3a03000 	mov	r3, #0
8f60f01c:	1a000001 	bne	8f60f028 <qtimer_set_physical_timer+0xe0>
8f60f020:	e28dd00c 	add	r13, r13, #12
8f60f024:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
8f60f028:	eb008ee4 	bl	8f632bc0 <__stack_chk_fail>
8f60f02c:	8f74221c 	.word	0x8f74221c

8f60f030 <qtimer_get_frequency>:
{
8f60f030:	e59f303c 	ldr	r3, [pc, #60]	; 8f60f074 <qtimer_get_frequency+0x44>
8f60f034:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f038:	e24dd00c 	sub	r13, r13, #12
8f60f03c:	e5933000 	ldr	r3, [r3]
8f60f040:	e58d3004 	str	r3, [r13, #4]
8f60f044:	e3a03000 	mov	r3, #0
}
8f60f048:	e59f3024 	ldr	r3, [pc, #36]	; 8f60f074 <qtimer_get_frequency+0x44>
8f60f04c:	e5932000 	ldr	r2, [r3]
8f60f050:	e59d3004 	ldr	r3, [r13, #4]
8f60f054:	e0332002 	eors	r2, r3, r2
8f60f058:	e3a03000 	mov	r3, #0
8f60f05c:	1a000003 	bne	8f60f070 <qtimer_get_frequency+0x40>
8f60f060:	e3a00b3e 	mov	r0, #63488	; 0xf800
8f60f064:	e3400124 	movt	r0, #292	; 0x124
8f60f068:	e28dd00c 	add	r13, r13, #12
8f60f06c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60f070:	eb008ed2 	bl	8f632bc0 <__stack_chk_fail>
8f60f074:	8f74221c 	.word	0x8f74221c

8f60f078 <qtimer_disable>:
{
8f60f078:	e59f3050 	ldr	r3, [pc, #80]	; 8f60f0d0 <qtimer_disable+0x58>
	ctrl = readl(QTMR_V1_CNTP_CTL);
8f60f07c:	e3a02a01 	mov	r2, #4096	; 0x1000
{
8f60f080:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f084:	e24dd00c 	sub	r13, r13, #12
	ctrl = readl(QTMR_V1_CNTP_CTL);
8f60f088:	e3402b02 	movt	r2, #2818	; 0xb02
{
8f60f08c:	e5933000 	ldr	r3, [r3]
8f60f090:	e58d3004 	str	r3, [r13, #4]
8f60f094:	e3a03000 	mov	r3, #0
	ctrl = readl(QTMR_V1_CNTP_CTL);
8f60f098:	e592302c 	ldr	r3, [r2, #44]	; 0x2c
	ctrl &= ~QTMR_TIMER_CTRL_ENABLE;
8f60f09c:	e3c33001 	bic	r3, r3, #1
	ctrl |= QTMR_TIMER_CTRL_INT_MASK;
8f60f0a0:	e3833002 	orr	r3, r3, #2
	writel(ctrl, QTMR_V1_CNTP_CTL);
8f60f0a4:	e582302c 	str	r3, [r2, #44]	; 0x2c
	dsb();
8f60f0a8:	f57ff04f 	dsb	sy
}
8f60f0ac:	e59f301c 	ldr	r3, [pc, #28]	; 8f60f0d0 <qtimer_disable+0x58>
8f60f0b0:	e5932000 	ldr	r2, [r3]
8f60f0b4:	e59d3004 	ldr	r3, [r13, #4]
8f60f0b8:	e0332002 	eors	r2, r3, r2
8f60f0bc:	e3a03000 	mov	r3, #0
8f60f0c0:	1a000001 	bne	8f60f0cc <qtimer_disable+0x54>
8f60f0c4:	e28dd00c 	add	r13, r13, #12
8f60f0c8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60f0cc:	eb008ebb 	bl	8f632bc0 <__stack_chk_fail>
8f60f0d0:	8f74221c 	.word	0x8f74221c

8f60f0d4 <qtimer_get_phy_timer_cnt>:

inline __ALWAYS_INLINE uint64_t qtimer_get_phy_timer_cnt()
{
8f60f0d4:	e59f2050 	ldr	r2, [pc, #80]	; 8f60f12c <qtimer_get_phy_timer_cnt+0x58>
	uint32_t phy_cnt_lo;
	uint32_t phy_cnt_hi_1;
	uint32_t phy_cnt_hi_2;

	do {
		phy_cnt_hi_1 = readl(QTMR_V1_CNTPCT_HI);
8f60f0d8:	e3a03a01 	mov	r3, #4096	; 0x1000
{
8f60f0dc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f0e0:	e24dd00c 	sub	r13, r13, #12
		phy_cnt_hi_1 = readl(QTMR_V1_CNTPCT_HI);
8f60f0e4:	e3403b02 	movt	r3, #2818	; 0xb02
{
8f60f0e8:	e5922000 	ldr	r2, [r2]
8f60f0ec:	e58d2004 	str	r2, [r13, #4]
8f60f0f0:	e3a02000 	mov	r2, #0
		phy_cnt_hi_1 = readl(QTMR_V1_CNTPCT_HI);
8f60f0f4:	e5931004 	ldr	r1, [r3, #4]
		phy_cnt_lo = readl(QTMR_V1_CNTPCT_LO);
8f60f0f8:	e5930000 	ldr	r0, [r3]
		phy_cnt_hi_2 = readl(QTMR_V1_CNTPCT_HI);
8f60f0fc:	e5932004 	ldr	r2, [r3, #4]
    } while (phy_cnt_hi_1 != phy_cnt_hi_2);
8f60f100:	e1510002 	cmp	r1, r2
8f60f104:	1afffffa 	bne	8f60f0f4 <qtimer_get_phy_timer_cnt+0x20>

	return ((uint64_t)phy_cnt_hi_1 << 32) | phy_cnt_lo;
}
8f60f108:	e59f301c 	ldr	r3, [pc, #28]	; 8f60f12c <qtimer_get_phy_timer_cnt+0x58>
8f60f10c:	e5932000 	ldr	r2, [r3]
8f60f110:	e59d3004 	ldr	r3, [r13, #4]
8f60f114:	e0332002 	eors	r2, r3, r2
8f60f118:	e3a03000 	mov	r3, #0
8f60f11c:	1a000001 	bne	8f60f128 <qtimer_get_phy_timer_cnt+0x54>
8f60f120:	e28dd00c 	add	r13, r13, #12
8f60f124:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60f128:	eb008ea4 	bl	8f632bc0 <__stack_chk_fail>
8f60f12c:	8f74221c 	.word	0x8f74221c

8f60f130 <qtimer_current_time>:

uint32_t qtimer_current_time()
{
8f60f130:	e59f2040 	ldr	r2, [pc, #64]	; 8f60f178 <qtimer_current_time+0x48>
	return current_time;
8f60f134:	e30c3d44 	movw	r3, #52548	; 0xcd44
{
8f60f138:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f13c:	e24dd00c 	sub	r13, r13, #12
	return current_time;
8f60f140:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f60f144:	e5922000 	ldr	r2, [r2]
8f60f148:	e58d2004 	str	r2, [r13, #4]
8f60f14c:	e3a02000 	mov	r2, #0
	return current_time;
8f60f150:	e5930000 	ldr	r0, [r3]
}
8f60f154:	e59f301c 	ldr	r3, [pc, #28]	; 8f60f178 <qtimer_current_time+0x48>
8f60f158:	e5932000 	ldr	r2, [r3]
8f60f15c:	e59d3004 	ldr	r3, [r13, #4]
8f60f160:	e0332002 	eors	r2, r3, r2
8f60f164:	e3a03000 	mov	r3, #0
8f60f168:	1a000001 	bne	8f60f174 <qtimer_current_time+0x44>
8f60f16c:	e28dd00c 	add	r13, r13, #12
8f60f170:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60f174:	eb008e91 	bl	8f632bc0 <__stack_chk_fail>
8f60f178:	8f74221c 	.word	0x8f74221c

8f60f17c <platform_irq>:
#include <qgic.h>

extern int target_supports_qgic();

enum handler_return platform_irq(struct arm_iframe *frame)
{
8f60f17c:	e59f3038 	ldr	r3, [pc, #56]	; 8f60f1bc <platform_irq+0x40>
8f60f180:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f184:	e24dd00c 	sub	r13, r13, #12
8f60f188:	e5933000 	ldr	r3, [r3]
8f60f18c:	e58d3004 	str	r3, [r13, #4]
8f60f190:	e3a03000 	mov	r3, #0
	if(target_supports_qgic())
		return gic_platform_irq(frame);
	else
		return vic_platform_irq(frame);
#else
	return gic_platform_irq(frame);
8f60f194:	e59f3020 	ldr	r3, [pc, #32]	; 8f60f1bc <platform_irq+0x40>
8f60f198:	e5932000 	ldr	r2, [r3]
8f60f19c:	e59d3004 	ldr	r3, [r13, #4]
8f60f1a0:	e0332002 	eors	r2, r3, r2
8f60f1a4:	e3a03000 	mov	r3, #0
8f60f1a8:	1a000002 	bne	8f60f1b8 <platform_irq+0x3c>
#endif
}
8f60f1ac:	e28dd00c 	add	r13, r13, #12
8f60f1b0:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return gic_platform_irq(frame);
8f60f1b4:	eaffe069 	b	8f607360 <gic_platform_irq>
8f60f1b8:	eb008e80 	bl	8f632bc0 <__stack_chk_fail>
8f60f1bc:	8f74221c 	.word	0x8f74221c

8f60f1c0 <platform_fiq>:

void platform_fiq(struct arm_iframe *frame)
{
8f60f1c0:	e59f3038 	ldr	r3, [pc, #56]	; 8f60f200 <platform_fiq+0x40>
8f60f1c4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f1c8:	e24dd00c 	sub	r13, r13, #12
8f60f1cc:	e5933000 	ldr	r3, [r3]
8f60f1d0:	e58d3004 	str	r3, [r13, #4]
8f60f1d4:	e3a03000 	mov	r3, #0
	if(target_supports_qgic())
		gic_platform_fiq(frame);
	else
		vic_platform_fiq(frame);
#else
	gic_platform_fiq(frame);
8f60f1d8:	e59f3020 	ldr	r3, [pc, #32]	; 8f60f200 <platform_fiq+0x40>
8f60f1dc:	e5932000 	ldr	r2, [r3]
8f60f1e0:	e59d3004 	ldr	r3, [r13, #4]
8f60f1e4:	e0332002 	eors	r2, r3, r2
8f60f1e8:	e3a03000 	mov	r3, #0
8f60f1ec:	1a000002 	bne	8f60f1fc <platform_fiq+0x3c>
#endif
}
8f60f1f0:	e28dd00c 	add	r13, r13, #12
8f60f1f4:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	gic_platform_fiq(frame);
8f60f1f8:	eaffe078 	b	8f6073e0 <gic_platform_fiq>
8f60f1fc:	eb008e6f 	bl	8f632bc0 <__stack_chk_fail>
8f60f200:	8f74221c 	.word	0x8f74221c

8f60f204 <mask_interrupt>:

status_t mask_interrupt(unsigned int vector)
{
8f60f204:	e59f3038 	ldr	r3, [pc, #56]	; 8f60f244 <mask_interrupt+0x40>
8f60f208:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f20c:	e24dd00c 	sub	r13, r13, #12
8f60f210:	e5933000 	ldr	r3, [r3]
8f60f214:	e58d3004 	str	r3, [r13, #4]
8f60f218:	e3a03000 	mov	r3, #0
	if(target_supports_qgic())
		return gic_mask_interrupt(vector);
	else
		return vic_mask_interrupt(vector);
#else
	return gic_mask_interrupt(vector);
8f60f21c:	e59f3020 	ldr	r3, [pc, #32]	; 8f60f244 <mask_interrupt+0x40>
8f60f220:	e5932000 	ldr	r2, [r3]
8f60f224:	e59d3004 	ldr	r3, [r13, #4]
8f60f228:	e0332002 	eors	r2, r3, r2
8f60f22c:	e3a03000 	mov	r3, #0
8f60f230:	1a000002 	bne	8f60f240 <mask_interrupt+0x3c>
#endif
}
8f60f234:	e28dd00c 	add	r13, r13, #12
8f60f238:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return gic_mask_interrupt(vector);
8f60f23c:	eaffe07d 	b	8f607438 <gic_mask_interrupt>
8f60f240:	eb008e5e 	bl	8f632bc0 <__stack_chk_fail>
8f60f244:	8f74221c 	.word	0x8f74221c

8f60f248 <unmask_interrupt>:

status_t unmask_interrupt(unsigned int vector)
{
8f60f248:	e59f3038 	ldr	r3, [pc, #56]	; 8f60f288 <unmask_interrupt+0x40>
8f60f24c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f250:	e24dd00c 	sub	r13, r13, #12
8f60f254:	e5933000 	ldr	r3, [r3]
8f60f258:	e58d3004 	str	r3, [r13, #4]
8f60f25c:	e3a03000 	mov	r3, #0
	if(target_supports_qgic())
		return gic_unmask_interrupt(vector);
	else
		return vic_unmask_interrupt(vector);
#else
	return gic_unmask_interrupt(vector);
8f60f260:	e59f3020 	ldr	r3, [pc, #32]	; 8f60f288 <unmask_interrupt+0x40>
8f60f264:	e5932000 	ldr	r2, [r3]
8f60f268:	e59d3004 	ldr	r3, [r13, #4]
8f60f26c:	e0332002 	eors	r2, r3, r2
8f60f270:	e3a03000 	mov	r3, #0
8f60f274:	1a000002 	bne	8f60f284 <unmask_interrupt+0x3c>
#endif
}
8f60f278:	e28dd00c 	add	r13, r13, #12
8f60f27c:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return gic_unmask_interrupt(vector);
8f60f280:	eaffe085 	b	8f60749c <gic_unmask_interrupt>
8f60f284:	eb008e4d 	bl	8f632bc0 <__stack_chk_fail>
8f60f288:	8f74221c 	.word	0x8f74221c

8f60f28c <register_int_handler>:

void register_int_handler(unsigned int vector, int_handler func, void *arg)
{
8f60f28c:	e59f3038 	ldr	r3, [pc, #56]	; 8f60f2cc <register_int_handler+0x40>
8f60f290:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f294:	e24dd00c 	sub	r13, r13, #12
8f60f298:	e5933000 	ldr	r3, [r3]
8f60f29c:	e58d3004 	str	r3, [r13, #4]
8f60f2a0:	e3a03000 	mov	r3, #0
	if(target_supports_qgic())
		gic_register_int_handler(vector, func, arg);
	else
		vic_register_int_handler(vector, func, arg);
#else
		gic_register_int_handler(vector, func, arg);
8f60f2a4:	e59f3020 	ldr	r3, [pc, #32]	; 8f60f2cc <register_int_handler+0x40>
8f60f2a8:	e593c000 	ldr	r12, [r3]
8f60f2ac:	e59d3004 	ldr	r3, [r13, #4]
8f60f2b0:	e033c00c 	eors	r12, r3, r12
8f60f2b4:	e3a03000 	mov	r3, #0
8f60f2b8:	1a000002 	bne	8f60f2c8 <register_int_handler+0x3c>
#endif
}
8f60f2bc:	e28dd00c 	add	r13, r13, #12
8f60f2c0:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		gic_register_int_handler(vector, func, arg);
8f60f2c4:	eaffe08d 	b	8f607500 <gic_register_int_handler>
8f60f2c8:	eb008e3c 	bl	8f632bc0 <__stack_chk_fail>
8f60f2cc:	8f74221c 	.word	0x8f74221c

8f60f2d0 <clk_reset>:

	return clk->ops->get_parent(clk);
}

int clk_reset(struct clk *clk, enum clk_reset_action action)
{
8f60f2d0:	e59f2074 	ldr	r2, [pc, #116]	; 8f60f34c <clk_reset+0x7c>
	if (!clk)
8f60f2d4:	e2503000 	subs	r3, r0, #0
{
8f60f2d8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f2dc:	e24dd00c 	sub	r13, r13, #12
8f60f2e0:	e5922000 	ldr	r2, [r2]
8f60f2e4:	e58d2004 	str	r2, [r13, #4]
8f60f2e8:	e3a02000 	mov	r2, #0
	if (!clk)
8f60f2ec:	0a00000c 	beq	8f60f324 <clk_reset+0x54>
		return 0;

	if (!clk->ops->reset)
8f60f2f0:	e5933008 	ldr	r3, [r3, #8]
8f60f2f4:	e593300c 	ldr	r3, [r3, #12]
8f60f2f8:	e3530000 	cmp	r3, #0
8f60f2fc:	0a000008 	beq	8f60f324 <clk_reset+0x54>
		return 0;

	return clk->ops->reset(clk, action);
8f60f300:	e59f2044 	ldr	r2, [pc, #68]	; 8f60f34c <clk_reset+0x7c>
8f60f304:	e592c000 	ldr	r12, [r2]
8f60f308:	e59d2004 	ldr	r2, [r13, #4]
8f60f30c:	e032c00c 	eors	r12, r2, r12
8f60f310:	e3a02000 	mov	r2, #0
8f60f314:	1a00000b 	bne	8f60f348 <clk_reset+0x78>
}
8f60f318:	e28dd00c 	add	r13, r13, #12
8f60f31c:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return clk->ops->reset(clk, action);
8f60f320:	e12fff13 	bx	r3
}
8f60f324:	e59f3020 	ldr	r3, [pc, #32]	; 8f60f34c <clk_reset+0x7c>
8f60f328:	e5932000 	ldr	r2, [r3]
8f60f32c:	e59d3004 	ldr	r3, [r13, #4]
8f60f330:	e0332002 	eors	r2, r3, r2
8f60f334:	e3a03000 	mov	r3, #0
8f60f338:	1a000002 	bne	8f60f348 <clk_reset+0x78>
8f60f33c:	e3a00000 	mov	r0, #0
8f60f340:	e28dd00c 	add	r13, r13, #12
8f60f344:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60f348:	eb008e1c 	bl	8f632bc0 <__stack_chk_fail>
8f60f34c:	8f74221c 	.word	0x8f74221c

8f60f350 <clk_disable>:
out:
	return ret;
}

void clk_disable(struct clk *clk)
{
8f60f350:	e92d4010 	push	{r4, r14}
	struct clk *parent;

	if (!clk)
8f60f354:	e2504000 	subs	r4, r0, #0
{
8f60f358:	e59f3090 	ldr	r3, [pc, #144]	; 8f60f3f0 <clk_disable+0xa0>
8f60f35c:	e24dd008 	sub	r13, r13, #8
8f60f360:	e5933000 	ldr	r3, [r3]
8f60f364:	e58d3004 	str	r3, [r13, #4]
8f60f368:	e3a03000 	mov	r3, #0
	if (!clk)
8f60f36c:	0a000006 	beq	8f60f38c <clk_disable+0x3c>
		return;

	if (clk->count == 0)
8f60f370:	e5943010 	ldr	r3, [r4, #16]
8f60f374:	e3530000 	cmp	r3, #0
8f60f378:	0a000003 	beq	8f60f38c <clk_disable+0x3c>
		goto out;
	if (clk->count == 1) {
8f60f37c:	e3530001 	cmp	r3, #1
8f60f380:	0a000009 	beq	8f60f3ac <clk_disable+0x5c>
		if (clk->ops->disable)
			clk->ops->disable(clk);
		parent = clk_get_parent(clk);
		clk_disable(parent);
	}
	clk->count--;
8f60f384:	e2433001 	sub	r3, r3, #1
8f60f388:	e5843010 	str	r3, [r4, #16]
out:
	return;
}
8f60f38c:	e59f305c 	ldr	r3, [pc, #92]	; 8f60f3f0 <clk_disable+0xa0>
8f60f390:	e5932000 	ldr	r2, [r3]
8f60f394:	e59d3004 	ldr	r3, [r13, #4]
8f60f398:	e0332002 	eors	r2, r3, r2
8f60f39c:	e3a03000 	mov	r3, #0
8f60f3a0:	1a000011 	bne	8f60f3ec <clk_disable+0x9c>
8f60f3a4:	e28dd008 	add	r13, r13, #8
8f60f3a8:	e8bd8010 	pop	{r4, r15}
		if (clk->ops->disable)
8f60f3ac:	e5943008 	ldr	r3, [r4, #8]
8f60f3b0:	e5932004 	ldr	r2, [r3, #4]
8f60f3b4:	e3520000 	cmp	r2, #0
8f60f3b8:	0a000001 	beq	8f60f3c4 <clk_disable+0x74>
			clk->ops->disable(clk);
8f60f3bc:	e12fff32 	blx	r2
	if (!clk->ops->get_parent)
8f60f3c0:	e5943008 	ldr	r3, [r4, #8]
8f60f3c4:	e5933034 	ldr	r3, [r3, #52]	; 0x34
8f60f3c8:	e3530000 	cmp	r3, #0
8f60f3cc:	0a000004 	beq	8f60f3e4 <clk_disable+0x94>
	return clk->ops->get_parent(clk);
8f60f3d0:	e1a00004 	mov	r0, r4
8f60f3d4:	e12fff33 	blx	r3
		clk_disable(parent);
8f60f3d8:	ebffffdc 	bl	8f60f350 <clk_disable>
	clk->count--;
8f60f3dc:	e5943010 	ldr	r3, [r4, #16]
8f60f3e0:	eaffffe7 	b	8f60f384 <clk_disable+0x34>
		return NULL;
8f60f3e4:	e1a00003 	mov	r0, r3
8f60f3e8:	eafffffa 	b	8f60f3d8 <clk_disable+0x88>
}
8f60f3ec:	eb008df3 	bl	8f632bc0 <__stack_chk_fail>
8f60f3f0:	8f74221c 	.word	0x8f74221c

8f60f3f4 <clk_enable>:
{
8f60f3f4:	e92d4070 	push	{r4, r5, r6, r14}
	if (!clk)
8f60f3f8:	e2504000 	subs	r4, r0, #0
{
8f60f3fc:	e59f30b4 	ldr	r3, [pc, #180]	; 8f60f4b8 <clk_enable+0xc4>
8f60f400:	e24dd008 	sub	r13, r13, #8
		return 0;
8f60f404:	01a05004 	moveq	r5, r4
{
8f60f408:	e5933000 	ldr	r3, [r3]
8f60f40c:	e58d3004 	str	r3, [r13, #4]
8f60f410:	e3a03000 	mov	r3, #0
	if (!clk)
8f60f414:	0a00001b 	beq	8f60f488 <clk_enable+0x94>
	if (clk->count == 0) {
8f60f418:	e5943010 	ldr	r3, [r4, #16]
8f60f41c:	e3530000 	cmp	r3, #0
8f60f420:	1a000015 	bne	8f60f47c <clk_enable+0x88>
	if (!clk->ops->get_parent)
8f60f424:	e5943008 	ldr	r3, [r4, #8]
8f60f428:	e5933034 	ldr	r3, [r3, #52]	; 0x34
8f60f42c:	e3530000 	cmp	r3, #0
8f60f430:	0a00001d 	beq	8f60f4ac <clk_enable+0xb8>
	return clk->ops->get_parent(clk);
8f60f434:	e12fff33 	blx	r3
8f60f438:	e1a06000 	mov	r6, r0
		ret = clk_enable(parent);
8f60f43c:	e1a00006 	mov	r0, r6
8f60f440:	ebffffeb 	bl	8f60f3f4 <clk_enable>
		if (ret)
8f60f444:	e2505000 	subs	r5, r0, #0
8f60f448:	1a00000e 	bne	8f60f488 <clk_enable+0x94>
		if (clk->ops->enable)
8f60f44c:	e5943008 	ldr	r3, [r4, #8]
8f60f450:	e5933000 	ldr	r3, [r3]
8f60f454:	e3530000 	cmp	r3, #0
8f60f458:	0a000006 	beq	8f60f478 <clk_enable+0x84>
			ret = clk->ops->enable(clk);
8f60f45c:	e1a00004 	mov	r0, r4
8f60f460:	e12fff33 	blx	r3
		if (ret) {
8f60f464:	e2505000 	subs	r5, r0, #0
8f60f468:	0a000002 	beq	8f60f478 <clk_enable+0x84>
			clk_disable(parent);
8f60f46c:	e1a00006 	mov	r0, r6
8f60f470:	ebffffb6 	bl	8f60f350 <clk_disable>
			goto out;
8f60f474:	ea000003 	b	8f60f488 <clk_enable+0x94>
	clk->count++;
8f60f478:	e5943010 	ldr	r3, [r4, #16]
8f60f47c:	e3a05000 	mov	r5, #0
8f60f480:	e2833001 	add	r3, r3, #1
8f60f484:	e5843010 	str	r3, [r4, #16]
}
8f60f488:	e59f3028 	ldr	r3, [pc, #40]	; 8f60f4b8 <clk_enable+0xc4>
8f60f48c:	e5932000 	ldr	r2, [r3]
8f60f490:	e59d3004 	ldr	r3, [r13, #4]
8f60f494:	e0332002 	eors	r2, r3, r2
8f60f498:	e3a03000 	mov	r3, #0
8f60f49c:	1a000004 	bne	8f60f4b4 <clk_enable+0xc0>
8f60f4a0:	e1a00005 	mov	r0, r5
8f60f4a4:	e28dd008 	add	r13, r13, #8
8f60f4a8:	e8bd8070 	pop	{r4, r5, r6, r15}
		return NULL;
8f60f4ac:	e1a06003 	mov	r6, r3
8f60f4b0:	eaffffe1 	b	8f60f43c <clk_enable+0x48>
}
8f60f4b4:	eb008dc1 	bl	8f632bc0 <__stack_chk_fail>
8f60f4b8:	8f74221c 	.word	0x8f74221c

8f60f4bc <clk_set_rate>:

	return clk->ops->get_rate(clk);
}

int clk_set_rate(struct clk *clk, unsigned long rate)
{
8f60f4bc:	e59f306c 	ldr	r3, [pc, #108]	; 8f60f530 <clk_set_rate+0x74>
8f60f4c0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f4c4:	e24dd00c 	sub	r13, r13, #12
8f60f4c8:	e5933000 	ldr	r3, [r3]
8f60f4cc:	e58d3004 	str	r3, [r13, #4]
8f60f4d0:	e3a03000 	mov	r3, #0
	if (!clk->ops->set_rate)
8f60f4d4:	e5903008 	ldr	r3, [r0, #8]
8f60f4d8:	e5933010 	ldr	r3, [r3, #16]
8f60f4dc:	e3530000 	cmp	r3, #0
8f60f4e0:	0a000008 	beq	8f60f508 <clk_set_rate+0x4c>
		return ERR_NOT_VALID;

	return clk->ops->set_rate(clk, rate);
8f60f4e4:	e59f2044 	ldr	r2, [pc, #68]	; 8f60f530 <clk_set_rate+0x74>
8f60f4e8:	e592c000 	ldr	r12, [r2]
8f60f4ec:	e59d2004 	ldr	r2, [r13, #4]
8f60f4f0:	e032c00c 	eors	r12, r2, r12
8f60f4f4:	e3a02000 	mov	r2, #0
8f60f4f8:	1a00000b 	bne	8f60f52c <clk_set_rate+0x70>
}
8f60f4fc:	e28dd00c 	add	r13, r13, #12
8f60f500:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return clk->ops->set_rate(clk, rate);
8f60f504:	e12fff13 	bx	r3
}
8f60f508:	e59f3020 	ldr	r3, [pc, #32]	; 8f60f530 <clk_set_rate+0x74>
8f60f50c:	e5932000 	ldr	r2, [r3]
8f60f510:	e59d3004 	ldr	r3, [r13, #4]
8f60f514:	e0332002 	eors	r2, r3, r2
8f60f518:	e3a03000 	mov	r3, #0
8f60f51c:	1a000002 	bne	8f60f52c <clk_set_rate+0x70>
8f60f520:	e3e00006 	mvn	r0, #6
8f60f524:	e28dd00c 	add	r13, r13, #12
8f60f528:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60f52c:	eb008da3 	bl	8f632bc0 <__stack_chk_fail>
8f60f530:	8f74221c 	.word	0x8f74221c

8f60f534 <clk_init>:

void clk_init(struct clk_lookup *clist, unsigned num)
{
8f60f534:	e59f3048 	ldr	r3, [pc, #72]	; 8f60f584 <clk_init+0x50>
	if(clist && num)
8f60f538:	e3500000 	cmp	r0, #0
8f60f53c:	13510000 	cmpne	r1, #0
{
8f60f540:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f544:	e24dd00c 	sub	r13, r13, #12
8f60f548:	e5933000 	ldr	r3, [r3]
8f60f54c:	e58d3004 	str	r3, [r13, #4]
8f60f550:	e3a03000 	mov	r3, #0
	{
		msm_clk_list.clist = (struct clk_lookup *)clist;
8f60f554:	130c3d58 	movwne	r3, #52568	; 0xcd58
8f60f558:	13483f72 	movtne	r3, #36722	; 0x8f72
		msm_clk_list.num = num;
8f60f55c:	11c300f0 	strdne	r0, [r3]
	}
}
8f60f560:	e59f301c 	ldr	r3, [pc, #28]	; 8f60f584 <clk_init+0x50>
8f60f564:	e5932000 	ldr	r2, [r3]
8f60f568:	e59d3004 	ldr	r3, [r13, #4]
8f60f56c:	e0332002 	eors	r2, r3, r2
8f60f570:	e3a03000 	mov	r3, #0
8f60f574:	1a000001 	bne	8f60f580 <clk_init+0x4c>
8f60f578:	e28dd00c 	add	r13, r13, #12
8f60f57c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60f580:	eb008d8e 	bl	8f632bc0 <__stack_chk_fail>
8f60f584:	8f74221c 	.word	0x8f74221c

8f60f588 <clk_get>:

struct clk *clk_get (const char * cid)
{
	unsigned i;
	struct clk_lookup *cl= msm_clk_list.clist;
8f60f588:	e30c3d58 	movw	r3, #52568	; 0xcd58
8f60f58c:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f60f590:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f60f594:	e24dd00c 	sub	r13, r13, #12
	unsigned num = msm_clk_list.num;
8f60f598:	e8930090 	ldm	r3, {r4, r7}
{
8f60f59c:	e59f2098 	ldr	r2, [pc, #152]	; 8f60f63c <clk_get+0xb4>

	if(!cl || !num)
8f60f5a0:	e3570000 	cmp	r7, #0
8f60f5a4:	13540000 	cmpne	r4, #0
{
8f60f5a8:	e5922000 	ldr	r2, [r2]
8f60f5ac:	e58d2004 	str	r2, [r13, #4]
8f60f5b0:	e3a02000 	mov	r2, #0
	if(!cl || !num)
8f60f5b4:	03a05001 	moveq	r5, #1
8f60f5b8:	13a05000 	movne	r5, #0
8f60f5bc:	11a06000 	movne	r6, r0
8f60f5c0:	0a000017 	beq	8f60f624 <clk_get+0x9c>
		dprintf (CRITICAL, "Alert!! clock list not defined!\n");
		return NULL;
	}
	for(i=0; i < num; i++, cl++)
	{
		if(!strcmp(cl->con_id, cid))
8f60f5c4:	e5940000 	ldr	r0, [r4]
8f60f5c8:	e1a01006 	mov	r1, r6
8f60f5cc:	eb0093d4 	bl	8f634524 <strcmp>
8f60f5d0:	e3500000 	cmp	r0, #0
8f60f5d4:	0a000010 	beq	8f60f61c <clk_get+0x94>
	for(i=0; i < num; i++, cl++)
8f60f5d8:	e2855001 	add	r5, r5, #1
8f60f5dc:	e2844008 	add	r4, r4, #8
8f60f5e0:	e1570005 	cmp	r7, r5
8f60f5e4:	8afffff6 	bhi	8f60f5c4 <clk_get+0x3c>
		{
			return cl->clk;
		}
	}

	dprintf(CRITICAL, "Alert!! Requested clock \"%s\" is not supported!\n", cid);
8f60f5e8:	e1a01006 	mov	r1, r6
8f60f5ec:	e3030d6c 	movw	r0, #15724	; 0x3d6c
8f60f5f0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60f5f4:	eb008cde 	bl	8f632974 <_dprintf>
	return NULL;
8f60f5f8:	e3a00000 	mov	r0, #0
}
8f60f5fc:	e59f3038 	ldr	r3, [pc, #56]	; 8f60f63c <clk_get+0xb4>
8f60f600:	e5932000 	ldr	r2, [r3]
8f60f604:	e59d3004 	ldr	r3, [r13, #4]
8f60f608:	e0332002 	eors	r2, r3, r2
8f60f60c:	e3a03000 	mov	r3, #0
8f60f610:	1a000008 	bne	8f60f638 <clk_get+0xb0>
8f60f614:	e28dd00c 	add	r13, r13, #12
8f60f618:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
			return cl->clk;
8f60f61c:	e5940004 	ldr	r0, [r4, #4]
8f60f620:	eafffff5 	b	8f60f5fc <clk_get+0x74>
		dprintf (CRITICAL, "Alert!! clock list not defined!\n");
8f60f624:	e3030d48 	movw	r0, #15688	; 0x3d48
8f60f628:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60f62c:	eb008cd0 	bl	8f632974 <_dprintf>
		return NULL;
8f60f630:	e3a00000 	mov	r0, #0
8f60f634:	eafffff0 	b	8f60f5fc <clk_get+0x74>
}
8f60f638:	eb008d60 	bl	8f632bc0 <__stack_chk_fail>
8f60f63c:	8f74221c 	.word	0x8f74221c

8f60f640 <clk_get_set_enable>:

int clk_get_set_enable(char *id, unsigned long rate, bool enable)
{
8f60f640:	e59f30d4 	ldr	r3, [pc, #212]	; 8f60f71c <clk_get_set_enable+0xdc>
8f60f644:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f60f648:	e24dd00c 	sub	r13, r13, #12
8f60f64c:	e5933000 	ldr	r3, [r3]
8f60f650:	e58d3004 	str	r3, [r13, #4]
8f60f654:	e3a03000 	mov	r3, #0
8f60f658:	e1a07000 	mov	r7, r0
8f60f65c:	e1a06001 	mov	r6, r1
8f60f660:	e1a04002 	mov	r4, r2
	int ret = NO_ERROR;
	struct clk *cp;

	/* Get clk */
	cp = clk_get(id);
8f60f664:	ebffffc7 	bl	8f60f588 <clk_get>
	if(!cp)
8f60f668:	e2505000 	subs	r5, r0, #0
8f60f66c:	0a000021 	beq	8f60f6f8 <clk_get_set_enable+0xb8>
		ret = ERR_NOT_VALID;
		goto get_set_enable_error;
	}

	/* Set rate */
	if(rate)
8f60f670:	e3560000 	cmp	r6, #0
8f60f674:	1a00000a 	bne	8f60f6a4 <clk_get_set_enable+0x64>
			goto get_set_enable_error;
		}
	}

	/* Enable clock */
	if(enable)
8f60f678:	e3540000 	cmp	r4, #0
8f60f67c:	1a000015 	bne	8f60f6d8 <clk_get_set_enable+0x98>
		}
	}

get_set_enable_error:
	return ret;
}
8f60f680:	e59f3094 	ldr	r3, [pc, #148]	; 8f60f71c <clk_get_set_enable+0xdc>
8f60f684:	e5932000 	ldr	r2, [r3]
8f60f688:	e59d3004 	ldr	r3, [r13, #4]
8f60f68c:	e0332002 	eors	r2, r3, r2
8f60f690:	e3a03000 	mov	r3, #0
8f60f694:	1a00001f 	bne	8f60f718 <clk_get_set_enable+0xd8>
8f60f698:	e1a00004 	mov	r0, r4
8f60f69c:	e28dd00c 	add	r13, r13, #12
8f60f6a0:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
	if (!clk->ops->set_rate)
8f60f6a4:	e5953008 	ldr	r3, [r5, #8]
8f60f6a8:	e5933010 	ldr	r3, [r3, #16]
8f60f6ac:	e3530000 	cmp	r3, #0
8f60f6b0:	0a000016 	beq	8f60f710 <clk_get_set_enable+0xd0>
	return clk->ops->set_rate(clk, rate);
8f60f6b4:	e1a01006 	mov	r1, r6
8f60f6b8:	e12fff33 	blx	r3
		if(ret)
8f60f6bc:	e2506000 	subs	r6, r0, #0
8f60f6c0:	0affffec 	beq	8f60f678 <clk_get_set_enable+0x38>
			dprintf(CRITICAL, "Clock set rate failed.\n");
8f60f6c4:	e3030dbc 	movw	r0, #15804	; 0x3dbc
8f60f6c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60f6cc:	eb008ca8 	bl	8f632974 <_dprintf>
			goto get_set_enable_error;
8f60f6d0:	e1a04006 	mov	r4, r6
8f60f6d4:	eaffffe9 	b	8f60f680 <clk_get_set_enable+0x40>
		ret = clk_enable(cp);
8f60f6d8:	e1a00005 	mov	r0, r5
8f60f6dc:	ebffff44 	bl	8f60f3f4 <clk_enable>
		if(ret)
8f60f6e0:	e2504000 	subs	r4, r0, #0
8f60f6e4:	0affffe5 	beq	8f60f680 <clk_get_set_enable+0x40>
			dprintf(CRITICAL, "Clock enable failed.\n");
8f60f6e8:	e3030dd4 	movw	r0, #15828	; 0x3dd4
8f60f6ec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f60f6f0:	eb008c9f 	bl	8f632974 <_dprintf>
8f60f6f4:	eaffffe1 	b	8f60f680 <clk_get_set_enable+0x40>
		dprintf(CRITICAL, "Can't find clock with id: %s\n", id);
8f60f6f8:	e1a01007 	mov	r1, r7
8f60f6fc:	e3030d9c 	movw	r0, #15772	; 0x3d9c
8f60f700:	e3480f70 	movt	r0, #36720	; 0x8f70
		ret = ERR_NOT_VALID;
8f60f704:	e3e04006 	mvn	r4, #6
		dprintf(CRITICAL, "Can't find clock with id: %s\n", id);
8f60f708:	eb008c99 	bl	8f632974 <_dprintf>
		goto get_set_enable_error;
8f60f70c:	eaffffdb 	b	8f60f680 <clk_get_set_enable+0x40>
		return ERR_NOT_VALID;
8f60f710:	e3e06006 	mvn	r6, #6
8f60f714:	eaffffea 	b	8f60f6c4 <clk_get_set_enable+0x84>
}
8f60f718:	eb008d28 	bl	8f632bc0 <__stack_chk_fail>
8f60f71c:	8f74221c 	.word	0x8f74221c

8f60f720 <pll_vote_clk_enable>:

/*
 * pll_vote_clk functions
 */
int pll_vote_clk_enable(struct clk *clk)
{
8f60f720:	e59f3060 	ldr	r3, [pc, #96]	; 8f60f788 <pll_vote_clk_enable+0x68>
	uint32_t ena;
	struct pll_vote_clk *pll = to_pll_vote_clk(clk);

	ena = readl_relaxed(pll->en_reg);
8f60f724:	e5102014 	ldr	r2, [r0, #-20]	; 0xffffffec
{
8f60f728:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f72c:	e24dd00c 	sub	r13, r13, #12
8f60f730:	e5933000 	ldr	r3, [r3]
8f60f734:	e58d3004 	str	r3, [r13, #4]
8f60f738:	e3a03000 	mov	r3, #0
	ena |= pll->en_mask;
8f60f73c:	e510c010 	ldr	r12, [r0, #-16]
	writel_relaxed(ena, pll->en_reg);

	/* Wait until PLL is enabled */
	while ((readl_relaxed(pll->status_reg) & pll->status_mask) == 0);
8f60f740:	e510100c 	ldr	r1, [r0, #-12]
	ena = readl_relaxed(pll->en_reg);
8f60f744:	e5923000 	ldr	r3, [r2]
	ena |= pll->en_mask;
8f60f748:	e183300c 	orr	r3, r3, r12
	writel_relaxed(ena, pll->en_reg);
8f60f74c:	e5823000 	str	r3, [r2]
	while ((readl_relaxed(pll->status_reg) & pll->status_mask) == 0);
8f60f750:	e5102008 	ldr	r2, [r0, #-8]
8f60f754:	e5913000 	ldr	r3, [r1]
8f60f758:	e1130002 	tst	r3, r2
8f60f75c:	0afffffc 	beq	8f60f754 <pll_vote_clk_enable+0x34>

	return 0;
}
8f60f760:	e59f3020 	ldr	r3, [pc, #32]	; 8f60f788 <pll_vote_clk_enable+0x68>
8f60f764:	e5932000 	ldr	r2, [r3]
8f60f768:	e59d3004 	ldr	r3, [r13, #4]
8f60f76c:	e0332002 	eors	r2, r3, r2
8f60f770:	e3a03000 	mov	r3, #0
8f60f774:	1a000002 	bne	8f60f784 <pll_vote_clk_enable+0x64>
8f60f778:	e3a00000 	mov	r0, #0
8f60f77c:	e28dd00c 	add	r13, r13, #12
8f60f780:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60f784:	eb008d0d 	bl	8f632bc0 <__stack_chk_fail>
8f60f788:	8f74221c 	.word	0x8f74221c

8f60f78c <pll_vote_clk_disable>:

void pll_vote_clk_disable(struct clk *clk)
{
8f60f78c:	e59f3048 	ldr	r3, [pc, #72]	; 8f60f7dc <pll_vote_clk_disable+0x50>
8f60f790:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f794:	e24dd00c 	sub	r13, r13, #12
	uint32_t ena;
	struct pll_vote_clk *pll = to_pll_vote_clk(clk);

	ena = readl_relaxed(pll->en_reg);
8f60f798:	e5102014 	ldr	r2, [r0, #-20]	; 0xffffffec
{
8f60f79c:	e5933000 	ldr	r3, [r3]
8f60f7a0:	e58d3004 	str	r3, [r13, #4]
8f60f7a4:	e3a03000 	mov	r3, #0
	ena &= ~(pll->en_mask);
8f60f7a8:	e5101010 	ldr	r1, [r0, #-16]
	ena = readl_relaxed(pll->en_reg);
8f60f7ac:	e5923000 	ldr	r3, [r2]
	ena &= ~(pll->en_mask);
8f60f7b0:	e1c33001 	bic	r3, r3, r1
	writel_relaxed(ena, pll->en_reg);
8f60f7b4:	e5823000 	str	r3, [r2]
}
8f60f7b8:	e59f301c 	ldr	r3, [pc, #28]	; 8f60f7dc <pll_vote_clk_disable+0x50>
8f60f7bc:	e5932000 	ldr	r2, [r3]
8f60f7c0:	e59d3004 	ldr	r3, [r13, #4]
8f60f7c4:	e0332002 	eors	r2, r3, r2
8f60f7c8:	e3a03000 	mov	r3, #0
8f60f7cc:	1a000001 	bne	8f60f7d8 <pll_vote_clk_disable+0x4c>
8f60f7d0:	e28dd00c 	add	r13, r13, #12
8f60f7d4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60f7d8:	eb008cf8 	bl	8f632bc0 <__stack_chk_fail>
8f60f7dc:	8f74221c 	.word	0x8f74221c

8f60f7e0 <pll_vote_clk_is_enabled>:
	struct pll_vote_clk *pll = to_pll_vote_clk(clk);
	return pll->parent;
}

int pll_vote_clk_is_enabled(struct clk *clk)
{
8f60f7e0:	e59f3048 	ldr	r3, [pc, #72]	; 8f60f830 <pll_vote_clk_is_enabled+0x50>
8f60f7e4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f7e8:	e24dd00c 	sub	r13, r13, #12
8f60f7ec:	e5933000 	ldr	r3, [r3]
8f60f7f0:	e58d3004 	str	r3, [r13, #4]
8f60f7f4:	e3a03000 	mov	r3, #0
	struct pll_vote_clk *pll = to_pll_vote_clk(clk);
	return !!(readl_relaxed(pll->status_reg) & pll->status_mask);
8f60f7f8:	e14020dc 	ldrd	r2, [r0, #-12]
8f60f7fc:	e5922000 	ldr	r2, [r2]
8f60f800:	e1120003 	tst	r2, r3
}
8f60f804:	e59f3024 	ldr	r3, [pc, #36]	; 8f60f830 <pll_vote_clk_is_enabled+0x50>
	return !!(readl_relaxed(pll->status_reg) & pll->status_mask);
8f60f808:	13a00001 	movne	r0, #1
8f60f80c:	03a00000 	moveq	r0, #0
}
8f60f810:	e5932000 	ldr	r2, [r3]
8f60f814:	e59d3004 	ldr	r3, [r13, #4]
8f60f818:	e0332002 	eors	r2, r3, r2
8f60f81c:	e3a03000 	mov	r3, #0
8f60f820:	1a000001 	bne	8f60f82c <pll_vote_clk_is_enabled+0x4c>
8f60f824:	e28dd00c 	add	r13, r13, #12
8f60f828:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60f82c:	eb008ce3 	bl	8f632bc0 <__stack_chk_fail>
8f60f830:	8f74221c 	.word	0x8f74221c

8f60f834 <cxo_clk_enable>:
8f60f834:	e59f3038 	ldr	r3, [pc, #56]	; 8f60f874 <cxo_clk_enable+0x40>
8f60f838:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f83c:	e24dd00c 	sub	r13, r13, #12
8f60f840:	e5933000 	ldr	r3, [r3]
8f60f844:	e58d3004 	str	r3, [r13, #4]
8f60f848:	e3a03000 	mov	r3, #0
8f60f84c:	e59f3020 	ldr	r3, [pc, #32]	; 8f60f874 <cxo_clk_enable+0x40>
8f60f850:	e5932000 	ldr	r2, [r3]
8f60f854:	e59d3004 	ldr	r3, [r13, #4]
8f60f858:	e0332002 	eors	r2, r3, r2
8f60f85c:	e3a03000 	mov	r3, #0
8f60f860:	1a000002 	bne	8f60f870 <cxo_clk_enable+0x3c>
8f60f864:	e3a00000 	mov	r0, #0
8f60f868:	e28dd00c 	add	r13, r13, #12
8f60f86c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60f870:	eb008cd2 	bl	8f632bc0 <__stack_chk_fail>
8f60f874:	8f74221c 	.word	0x8f74221c

8f60f878 <cxo_clk_disable>:
	/* Nothing to do. */
	return 0;
}

void cxo_clk_disable(struct clk *clk)
{
8f60f878:	e59f3034 	ldr	r3, [pc, #52]	; 8f60f8b4 <cxo_clk_disable+0x3c>
8f60f87c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f880:	e24dd00c 	sub	r13, r13, #12
8f60f884:	e5933000 	ldr	r3, [r3]
8f60f888:	e58d3004 	str	r3, [r13, #4]
8f60f88c:	e3a03000 	mov	r3, #0
	/* Nothing to do. */
	return;
}
8f60f890:	e59f301c 	ldr	r3, [pc, #28]	; 8f60f8b4 <cxo_clk_disable+0x3c>
8f60f894:	e5932000 	ldr	r2, [r3]
8f60f898:	e59d3004 	ldr	r3, [r13, #4]
8f60f89c:	e0332002 	eors	r2, r3, r2
8f60f8a0:	e3a03000 	mov	r3, #0
8f60f8a4:	1a000001 	bne	8f60f8b0 <cxo_clk_disable+0x38>
8f60f8a8:	e28dd00c 	add	r13, r13, #12
8f60f8ac:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60f8b0:	eb008cc2 	bl	8f632bc0 <__stack_chk_fail>
8f60f8b4:	8f74221c 	.word	0x8f74221c

8f60f8b8 <clock_lib2_branch_clk_enable>:

/*=============== Branch clock ops =============*/

/* Branch clock enable */
int clock_lib2_branch_clk_enable(struct clk *clk)
{
8f60f8b8:	e59f3094 	ldr	r3, [pc, #148]	; 8f60f954 <clock_lib2_branch_clk_enable+0x9c>
8f60f8bc:	e92d4030 	push	{r4, r5, r14}
8f60f8c0:	e24dd00c 	sub	r13, r13, #12
	int rc = 0;
	uint32_t cbcr_val;
	int retry = 100;
	struct branch_clk *bclk = to_branch_clk(clk);

	cbcr_val  = readl(bclk->cbcr_reg);
8f60f8c4:	e510200c 	ldr	r2, [r0, #-12]
{
8f60f8c8:	e5933000 	ldr	r3, [r3]
8f60f8cc:	e58d3004 	str	r3, [r13, #4]
8f60f8d0:	e3a03000 	mov	r3, #0
	return container_of(clk, struct rcg_clk, c);
}

static inline struct branch_clk *to_branch_clk(struct clk *clk)
{
	return container_of(clk, struct branch_clk, c);
8f60f8d4:	e2405010 	sub	r5, r0, #16
	cbcr_val  = readl(bclk->cbcr_reg);
8f60f8d8:	e5923000 	ldr	r3, [r2]
	cbcr_val |= CBCR_BRANCH_ENABLE_BIT;
8f60f8dc:	e3833001 	orr	r3, r3, #1
	writel(cbcr_val, bclk->cbcr_reg);
8f60f8e0:	e5823000 	str	r3, [r2]

	/* Some clocks do not need to check the enable status, return
	 * if the halt_check is not set
	 */
	if (!bclk->halt_check)
8f60f8e4:	e5953030 	ldr	r3, [r5, #48]	; 0x30
8f60f8e8:	e3530000 	cmp	r3, #0
8f60f8ec:	0a00000c 	beq	8f60f924 <clock_lib2_branch_clk_enable+0x6c>
		return rc;

	/* wait until status shows it is enabled */
	while(readl(bclk->cbcr_reg) & CBCR_BRANCH_OFF_BIT)
8f60f8f0:	e5923000 	ldr	r3, [r2]
8f60f8f4:	e3530000 	cmp	r3, #0
8f60f8f8:	b3a04064 	movlt	r4, #100	; 0x64
8f60f8fc:	ba000002 	blt	8f60f90c <clock_lib2_branch_clk_enable+0x54>
8f60f900:	ea000007 	b	8f60f924 <clock_lib2_branch_clk_enable+0x6c>
	{
		/* Add 100 ms of time out, bail out if the clock is not enable
		 * within 100 ms */
		if (!retry)
8f60f904:	e2544001 	subs	r4, r4, #1
8f60f908:	0a00000e 	beq	8f60f948 <clock_lib2_branch_clk_enable+0x90>
		{
			rc = 1;
			break;
		}
		retry--;
		mdelay(1);
8f60f90c:	e3a00001 	mov	r0, #1
8f60f910:	ebfffcf9 	bl	8f60ecfc <mdelay>
	while(readl(bclk->cbcr_reg) & CBCR_BRANCH_OFF_BIT)
8f60f914:	e5953004 	ldr	r3, [r5, #4]
8f60f918:	e5933000 	ldr	r3, [r3]
8f60f91c:	e3530000 	cmp	r3, #0
8f60f920:	bafffff7 	blt	8f60f904 <clock_lib2_branch_clk_enable+0x4c>
		return rc;
8f60f924:	e3a00000 	mov	r0, #0
	}

	return rc;
}
8f60f928:	e59f3024 	ldr	r3, [pc, #36]	; 8f60f954 <clock_lib2_branch_clk_enable+0x9c>
8f60f92c:	e5932000 	ldr	r2, [r3]
8f60f930:	e59d3004 	ldr	r3, [r13, #4]
8f60f934:	e0332002 	eors	r2, r3, r2
8f60f938:	e3a03000 	mov	r3, #0
8f60f93c:	1a000003 	bne	8f60f950 <clock_lib2_branch_clk_enable+0x98>
8f60f940:	e28dd00c 	add	r13, r13, #12
8f60f944:	e8bd8030 	pop	{r4, r5, r15}
			rc = 1;
8f60f948:	e3a00001 	mov	r0, #1
8f60f94c:	eafffff5 	b	8f60f928 <clock_lib2_branch_clk_enable+0x70>
}
8f60f950:	eb008c9a 	bl	8f632bc0 <__stack_chk_fail>
8f60f954:	8f74221c 	.word	0x8f74221c

8f60f958 <clock_lib2_branch_clk_disable>:

/* Branch clock disable */
void clock_lib2_branch_clk_disable(struct clk *clk)
{
8f60f958:	e59f306c 	ldr	r3, [pc, #108]	; 8f60f9cc <clock_lib2_branch_clk_disable+0x74>
8f60f95c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f960:	e24dd00c 	sub	r13, r13, #12
	uint32_t cbcr_val;
	struct branch_clk *bclk = to_branch_clk(clk);

	cbcr_val  = readl(bclk->cbcr_reg);
8f60f964:	e510200c 	ldr	r2, [r0, #-12]
{
8f60f968:	e5933000 	ldr	r3, [r3]
8f60f96c:	e58d3004 	str	r3, [r13, #4]
8f60f970:	e3a03000 	mov	r3, #0
	cbcr_val  = readl(bclk->cbcr_reg);
8f60f974:	e5923000 	ldr	r3, [r2]
	cbcr_val &= ~CBCR_BRANCH_ENABLE_BIT;
8f60f978:	e3c33001 	bic	r3, r3, #1
	writel(cbcr_val, bclk->cbcr_reg);
8f60f97c:	e5823000 	str	r3, [r2]

	if (!bclk->no_halt_check_on_disable)
8f60f980:	e5903024 	ldr	r3, [r0, #36]	; 0x24
8f60f984:	e3530000 	cmp	r3, #0
8f60f988:	0a000007 	beq	8f60f9ac <clock_lib2_branch_clk_disable+0x54>
		/* wait until status shows it is disabled */
		while(!(readl(bclk->cbcr_reg) & CBCR_BRANCH_OFF_BIT));
}
8f60f98c:	e59f3038 	ldr	r3, [pc, #56]	; 8f60f9cc <clock_lib2_branch_clk_disable+0x74>
8f60f990:	e5932000 	ldr	r2, [r3]
8f60f994:	e59d3004 	ldr	r3, [r13, #4]
8f60f998:	e0332002 	eors	r2, r3, r2
8f60f99c:	e3a03000 	mov	r3, #0
8f60f9a0:	1a000008 	bne	8f60f9c8 <clock_lib2_branch_clk_disable+0x70>
8f60f9a4:	e28dd00c 	add	r13, r13, #12
8f60f9a8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		while(!(readl(bclk->cbcr_reg) & CBCR_BRANCH_OFF_BIT));
8f60f9ac:	e5923000 	ldr	r3, [r2]
8f60f9b0:	e3530000 	cmp	r3, #0
8f60f9b4:	bafffff4 	blt	8f60f98c <clock_lib2_branch_clk_disable+0x34>
8f60f9b8:	e5923000 	ldr	r3, [r2]
8f60f9bc:	e3530000 	cmp	r3, #0
8f60f9c0:	aafffff9 	bge	8f60f9ac <clock_lib2_branch_clk_disable+0x54>
8f60f9c4:	eafffff0 	b	8f60f98c <clock_lib2_branch_clk_disable+0x34>
}
8f60f9c8:	eb008c7c 	bl	8f632bc0 <__stack_chk_fail>
8f60f9cc:	8f74221c 	.word	0x8f74221c

8f60f9d0 <clock_lib2_branch_set_rate>:

/* Branch clock set rate */
int clock_lib2_branch_set_rate(struct clk *c, unsigned rate)
{
8f60f9d0:	e59f306c 	ldr	r3, [pc, #108]	; 8f60fa44 <clock_lib2_branch_set_rate+0x74>
8f60f9d4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60f9d8:	e24dd00c 	sub	r13, r13, #12
8f60f9dc:	e5933000 	ldr	r3, [r3]
8f60f9e0:	e58d3004 	str	r3, [r13, #4]
8f60f9e4:	e3a03000 	mov	r3, #0
	struct branch_clk *branch = to_branch_clk(c);

	if (!branch->has_sibling)
8f60f9e8:	e5903014 	ldr	r3, [r0, #20]
8f60f9ec:	e3530000 	cmp	r3, #0
		return clk_set_rate(branch->parent, rate);
8f60f9f0:	e59f304c 	ldr	r3, [pc, #76]	; 8f60fa44 <clock_lib2_branch_set_rate+0x74>
	if (!branch->has_sibling)
8f60f9f4:	1a000009 	bne	8f60fa20 <clock_lib2_branch_set_rate+0x50>
		return clk_set_rate(branch->parent, rate);
8f60f9f8:	e5932000 	ldr	r2, [r3]
8f60f9fc:	e59d3004 	ldr	r3, [r13, #4]
8f60fa00:	e0332002 	eors	r2, r3, r2
8f60fa04:	e3a03000 	mov	r3, #0
8f60fa08:	1a00000c 	bne	8f60fa40 <clock_lib2_branch_set_rate+0x70>
8f60fa0c:	e2400010 	sub	r0, r0, #16
8f60fa10:	e590000c 	ldr	r0, [r0, #12]

	return -1;
}
8f60fa14:	e28dd00c 	add	r13, r13, #12
8f60fa18:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		return clk_set_rate(branch->parent, rate);
8f60fa1c:	eafffea6 	b	8f60f4bc <clk_set_rate>
}
8f60fa20:	e5932000 	ldr	r2, [r3]
8f60fa24:	e59d3004 	ldr	r3, [r13, #4]
8f60fa28:	e0332002 	eors	r2, r3, r2
8f60fa2c:	e3a03000 	mov	r3, #0
8f60fa30:	1a000002 	bne	8f60fa40 <clock_lib2_branch_set_rate+0x70>
8f60fa34:	e3e00000 	mvn	r0, #0
8f60fa38:	e28dd00c 	add	r13, r13, #12
8f60fa3c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60fa40:	eb008c5e 	bl	8f632bc0 <__stack_chk_fail>
8f60fa44:	8f74221c 	.word	0x8f74221c

8f60fa48 <clock_lib2_rcg_enable>:

/*=============== Root clock ops =============*/

/* Root enable */
int clock_lib2_rcg_enable(struct clk *c)
{
8f60fa48:	e59f3038 	ldr	r3, [pc, #56]	; 8f60fa88 <clock_lib2_rcg_enable+0x40>
8f60fa4c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60fa50:	e24dd00c 	sub	r13, r13, #12
8f60fa54:	e5933000 	ldr	r3, [r3]
8f60fa58:	e58d3004 	str	r3, [r13, #4]
8f60fa5c:	e3a03000 	mov	r3, #0
	/* Hardware feedback from branch enable results in root being enabled.
	 * Nothing to do here.
	 */

	return 0;
}
8f60fa60:	e59f3020 	ldr	r3, [pc, #32]	; 8f60fa88 <clock_lib2_rcg_enable+0x40>
8f60fa64:	e5932000 	ldr	r2, [r3]
8f60fa68:	e59d3004 	ldr	r3, [r13, #4]
8f60fa6c:	e0332002 	eors	r2, r3, r2
8f60fa70:	e3a03000 	mov	r3, #0
8f60fa74:	1a000002 	bne	8f60fa84 <clock_lib2_rcg_enable+0x3c>
8f60fa78:	e3a00000 	mov	r0, #0
8f60fa7c:	e28dd00c 	add	r13, r13, #12
8f60fa80:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60fa84:	eb008c4d 	bl	8f632bc0 <__stack_chk_fail>
8f60fa88:	8f74221c 	.word	0x8f74221c

8f60fa8c <clock_lib2_rcg_set_rate>:
 * Find the entry in the frequecy table corresponding to the requested rate.
 * Enable the source clock required for the new frequency.
 * Call the set_rate function defined for this particular root clock.
 */
int clock_lib2_rcg_set_rate(struct clk *c, unsigned rate)
{
8f60fa8c:	e92d4070 	push	{r4, r5, r6, r14}
8f60fa90:	e24dd010 	sub	r13, r13, #16
	struct rcg_clk *rclk = to_rcg_clk(c);
	struct clk_freq_tbl *nf; /* new freq */
	int rc = 0;

	/* ck if new freq is in table */
	for (nf = rclk->freq_tbl; nf->freq_hz != FREQ_END
8f60fa94:	e5104008 	ldr	r4, [r0, #-8]
{
8f60fa98:	e59f30cc 	ldr	r3, [pc, #204]	; 8f60fb6c <clock_lib2_rcg_set_rate+0xe0>
8f60fa9c:	e5933000 	ldr	r3, [r3]
8f60faa0:	e58d300c 	str	r3, [r13, #12]
8f60faa4:	e3a03000 	mov	r3, #0
	for (nf = rclk->freq_tbl; nf->freq_hz != FREQ_END
8f60faa8:	e5943000 	ldr	r3, [r4]
8f60faac:	e3730002 	cmn	r3, #2
8f60fab0:	0a00001c 	beq	8f60fb28 <clock_lib2_rcg_set_rate+0x9c>
8f60fab4:	e2405020 	sub	r5, r0, #32
8f60fab8:	e1a0600e 	mov	r6, r14
8f60fabc:	ea000002 	b	8f60facc <clock_lib2_rcg_set_rate+0x40>
8f60fac0:	e5b43018 	ldr	r3, [r4, #24]!
8f60fac4:	e3730002 	cmn	r3, #2
8f60fac8:	0a000016 	beq	8f60fb28 <clock_lib2_rcg_set_rate+0x9c>
			&& nf->freq_hz != rate; nf++)
8f60facc:	e1510003 	cmp	r1, r3
8f60fad0:	1afffffa 	bne	8f60fac0 <clock_lib2_rcg_set_rate+0x34>
	/* Frequency not found in the table */
	if (nf->freq_hz == FREQ_END)
		return ERR_INVALID_ARGS;

	/* Check if frequency is actually changed. */
	if (nf == rclk->current_freq)
8f60fad4:	e595301c 	ldr	r3, [r5, #28]
8f60fad8:	e1530004 	cmp	r3, r4
8f60fadc:	0a000013 	beq	8f60fb30 <clock_lib2_rcg_set_rate+0xa4>
		return rc;

	/* First enable the source clock for this freq. */
	clk_enable(nf->src_clk);
8f60fae0:	e5940004 	ldr	r0, [r4, #4]
8f60fae4:	ebfffe42 	bl	8f60f3f4 <clk_enable>

	/* Perform clock-specific frequency switch operations. */
	ASSERT(rclk->set_rate);
8f60fae8:	e5953014 	ldr	r3, [r5, #20]
8f60faec:	e3530000 	cmp	r3, #0
8f60faf0:	0a000010 	beq	8f60fb38 <clock_lib2_rcg_set_rate+0xac>
	rclk->set_rate(rclk, nf);
8f60faf4:	e1a00005 	mov	r0, r5
8f60faf8:	e1a01004 	mov	r1, r4
8f60fafc:	e12fff33 	blx	r3

	/* update current freq */
	rclk->current_freq = nf;

	return rc;
8f60fb00:	e3a00000 	mov	r0, #0
	rclk->current_freq = nf;
8f60fb04:	e585401c 	str	r4, [r5, #28]
}
8f60fb08:	e59f305c 	ldr	r3, [pc, #92]	; 8f60fb6c <clock_lib2_rcg_set_rate+0xe0>
8f60fb0c:	e5932000 	ldr	r2, [r3]
8f60fb10:	e59d300c 	ldr	r3, [r13, #12]
8f60fb14:	e0332002 	eors	r2, r3, r2
8f60fb18:	e3a03000 	mov	r3, #0
8f60fb1c:	1a000011 	bne	8f60fb68 <clock_lib2_rcg_set_rate+0xdc>
8f60fb20:	e28dd010 	add	r13, r13, #16
8f60fb24:	e8bd8070 	pop	{r4, r5, r6, r15}
		return ERR_INVALID_ARGS;
8f60fb28:	e3e00007 	mvn	r0, #7
8f60fb2c:	eafffff5 	b	8f60fb08 <clock_lib2_rcg_set_rate+0x7c>
		return rc;
8f60fb30:	e3a00000 	mov	r0, #0
8f60fb34:	eafffff3 	b	8f60fb08 <clock_lib2_rcg_set_rate+0x7c>
	ASSERT(rclk->set_rate);
8f60fb38:	e3a0309b 	mov	r3, #155	; 0x9b
8f60fb3c:	e3032e10 	movw	r2, #15888	; 0x3e10
8f60fb40:	e1a00006 	mov	r0, r6
8f60fb44:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60fb48:	e3001130 	movw	r1, #304	; 0x130
8f60fb4c:	e58d2000 	str	r2, [r13]
8f60fb50:	e3481f70 	movt	r1, #36720	; 0x8f70
8f60fb54:	e3032dec 	movw	r2, #15852	; 0x3dec
8f60fb58:	e3482f70 	movt	r2, #36720	; 0x8f70
8f60fb5c:	eb008bd6 	bl	8f632abc <_panic>
	rclk->set_rate(rclk, nf);
8f60fb60:	e5953014 	ldr	r3, [r5, #20]
8f60fb64:	eaffffe2 	b	8f60faf4 <clock_lib2_rcg_set_rate+0x68>
}
8f60fb68:	eb008c14 	bl	8f632bc0 <__stack_chk_fail>
8f60fb6c:	8f74221c 	.word	0x8f74221c

8f60fb70 <clock_lib2_rcg_set_rate_mnd>:
void clock_lib2_rcg_set_rate_mnd(struct rcg_clk *rclk, struct clk_freq_tbl *freq)
{
	uint32_t cfg;

	/* Program MND values */
	writel(freq->m_val, rclk->m_reg);
8f60fb70:	e591c00c 	ldr	r12, [r1, #12]
8f60fb74:	e5903008 	ldr	r3, [r0, #8]
{
8f60fb78:	e59f2094 	ldr	r2, [pc, #148]	; 8f60fc14 <clock_lib2_rcg_set_rate_mnd+0xa4>
8f60fb7c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60fb80:	e24dd00c 	sub	r13, r13, #12
8f60fb84:	e5922000 	ldr	r2, [r2]
8f60fb88:	e58d2004 	str	r2, [r13, #4]
8f60fb8c:	e3a02000 	mov	r2, #0
	writel(freq->n_val, rclk->n_reg);
8f60fb90:	e590200c 	ldr	r2, [r0, #12]
	writel(freq->m_val, rclk->m_reg);
8f60fb94:	e583c000 	str	r12, [r3]
	writel(freq->n_val, rclk->n_reg);
8f60fb98:	e591c010 	ldr	r12, [r1, #16]
	writel(freq->d_val, rclk->d_reg);
8f60fb9c:	e5903010 	ldr	r3, [r0, #16]
	writel(freq->n_val, rclk->n_reg);
8f60fba0:	e582c000 	str	r12, [r2]

	/* setup src select and divider */
	cfg  = readl(rclk->cfg_reg);
8f60fba4:	e590c004 	ldr	r12, [r0, #4]
	writel(freq->d_val, rclk->d_reg);
8f60fba8:	e5912014 	ldr	r2, [r1, #20]
8f60fbac:	e5832000 	str	r2, [r3]
	cfg  = readl(rclk->cfg_reg);
8f60fbb0:	e59c3000 	ldr	r3, [r12]
	cfg &= ~(CFG_SRC_SEL_MASK | CFG_SRC_DIV_MASK | CFG_MODE_MASK);
	cfg |= freq->div_src_val;
8f60fbb4:	e5912008 	ldr	r2, [r1, #8]
	cfg &= ~(CFG_SRC_SEL_MASK | CFG_SRC_DIV_MASK | CFG_MODE_MASK);
8f60fbb8:	e3c33c37 	bic	r3, r3, #14080	; 0x3700
	if(freq->n_val !=0)
8f60fbbc:	e5911010 	ldr	r1, [r1, #16]
	cfg &= ~(CFG_SRC_SEL_MASK | CFG_SRC_DIV_MASK | CFG_MODE_MASK);
8f60fbc0:	e3c3301f 	bic	r3, r3, #31
	cfg |= freq->div_src_val;
8f60fbc4:	e1833002 	orr	r3, r3, r2
	cmd  = readl(rclk->cmd_reg);
8f60fbc8:	e5902000 	ldr	r2, [r0]
	if(freq->n_val !=0)
8f60fbcc:	e3510000 	cmp	r1, #0
	{
		cfg |= (CFG_MODE_DUAL_EDGE << CFG_MODE_OFFSET);
8f60fbd0:	13833a02 	orrne	r3, r3, #8192	; 0x2000
	}
	writel(cfg, rclk->cfg_reg);
8f60fbd4:	e58c3000 	str	r3, [r12]
	cmd  = readl(rclk->cmd_reg);
8f60fbd8:	e5923000 	ldr	r3, [r2]
	cmd |= CMD_UPDATE_BIT;
8f60fbdc:	e3833001 	orr	r3, r3, #1
	writel(cmd, rclk->cmd_reg);
8f60fbe0:	e5823000 	str	r3, [r2]
	while(readl(rclk->cmd_reg) & CMD_UPDATE_MASK);
8f60fbe4:	e5923000 	ldr	r3, [r2]
8f60fbe8:	e3130001 	tst	r3, #1
8f60fbec:	1afffffc 	bne	8f60fbe4 <clock_lib2_rcg_set_rate_mnd+0x74>

	/* Inform h/w to start using the new config. */
	clock_lib2_rcg_update_config(rclk);
}
8f60fbf0:	e59f301c 	ldr	r3, [pc, #28]	; 8f60fc14 <clock_lib2_rcg_set_rate_mnd+0xa4>
8f60fbf4:	e5932000 	ldr	r2, [r3]
8f60fbf8:	e59d3004 	ldr	r3, [r13, #4]
8f60fbfc:	e0332002 	eors	r2, r3, r2
8f60fc00:	e3a03000 	mov	r3, #0
8f60fc04:	1a000001 	bne	8f60fc10 <clock_lib2_rcg_set_rate_mnd+0xa0>
8f60fc08:	e28dd00c 	add	r13, r13, #12
8f60fc0c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60fc10:	eb008bea 	bl	8f632bc0 <__stack_chk_fail>
8f60fc14:	8f74221c 	.word	0x8f74221c

8f60fc18 <clock_lib2_rcg_set_rate_hid>:

/* root set rate for clocks with half integer divider */
void clock_lib2_rcg_set_rate_hid(struct rcg_clk *rclk, struct clk_freq_tbl *freq)
{
8f60fc18:	e59f3068 	ldr	r3, [pc, #104]	; 8f60fc88 <clock_lib2_rcg_set_rate_hid+0x70>
	cmd  = readl(rclk->cmd_reg);
8f60fc1c:	e8901004 	ldm	r0, {r2, r12}
{
8f60fc20:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60fc24:	e24dd00c 	sub	r13, r13, #12
8f60fc28:	e5933000 	ldr	r3, [r3]
8f60fc2c:	e58d3004 	str	r3, [r13, #4]
8f60fc30:	e3a03000 	mov	r3, #0
	uint32_t cfg;

	/* setup src select and divider */
	cfg  = readl(rclk->cfg_reg);
	cfg &= ~(CFG_SRC_SEL_MASK | CFG_SRC_DIV_MASK);
	cfg |= freq->div_src_val;
8f60fc34:	e5911008 	ldr	r1, [r1, #8]
	cfg  = readl(rclk->cfg_reg);
8f60fc38:	e59c3000 	ldr	r3, [r12]
	cfg &= ~(CFG_SRC_SEL_MASK | CFG_SRC_DIV_MASK);
8f60fc3c:	e3c33e71 	bic	r3, r3, #1808	; 0x710
8f60fc40:	e3c3300f 	bic	r3, r3, #15
	cfg |= freq->div_src_val;
8f60fc44:	e1833001 	orr	r3, r3, r1
	writel(cfg, rclk->cfg_reg);
8f60fc48:	e58c3000 	str	r3, [r12]
	cmd  = readl(rclk->cmd_reg);
8f60fc4c:	e5923000 	ldr	r3, [r2]
	cmd |= CMD_UPDATE_BIT;
8f60fc50:	e3833001 	orr	r3, r3, #1
	writel(cmd, rclk->cmd_reg);
8f60fc54:	e5823000 	str	r3, [r2]
	while(readl(rclk->cmd_reg) & CMD_UPDATE_MASK);
8f60fc58:	e5923000 	ldr	r3, [r2]
8f60fc5c:	e3130001 	tst	r3, #1
8f60fc60:	1afffffc 	bne	8f60fc58 <clock_lib2_rcg_set_rate_hid+0x40>

	clock_lib2_rcg_update_config(rclk);
}
8f60fc64:	e59f301c 	ldr	r3, [pc, #28]	; 8f60fc88 <clock_lib2_rcg_set_rate_hid+0x70>
8f60fc68:	e5932000 	ldr	r2, [r3]
8f60fc6c:	e59d3004 	ldr	r3, [r13, #4]
8f60fc70:	e0332002 	eors	r2, r3, r2
8f60fc74:	e3a03000 	mov	r3, #0
8f60fc78:	1a000001 	bne	8f60fc84 <clock_lib2_rcg_set_rate_hid+0x6c>
8f60fc7c:	e28dd00c 	add	r13, r13, #12
8f60fc80:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60fc84:	eb008bcd 	bl	8f632bc0 <__stack_chk_fail>
8f60fc88:	8f74221c 	.word	0x8f74221c

8f60fc8c <clock_lib2_vote_clk_enable>:

/*=============== Vote clock ops =============*/

/* Vote clock enable */
int clock_lib2_vote_clk_enable(struct clk *c)
{
8f60fc8c:	e59f3058 	ldr	r3, [pc, #88]	; 8f60fcec <clock_lib2_vote_clk_enable+0x60>
	uint32_t vote_regval;
	uint32_t val;
	struct vote_clk *vclk = to_local_vote_clk(c);

	vote_regval = readl(vclk->vote_reg);
8f60fc90:	e5101008 	ldr	r1, [r0, #-8]
{
8f60fc94:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60fc98:	e24dd00c 	sub	r13, r13, #12
8f60fc9c:	e5933000 	ldr	r3, [r3]
8f60fca0:	e58d3004 	str	r3, [r13, #4]
8f60fca4:	e3a03000 	mov	r3, #0
	vote_regval |= vclk->en_mask;
	writel_relaxed(vote_regval, vclk->vote_reg);
	do {
		val = readl(vclk->cbcr_reg);
8f60fca8:	e510300c 	ldr	r3, [r0, #-12]
	vote_regval |= vclk->en_mask;
8f60fcac:	e5100004 	ldr	r0, [r0, #-4]
	vote_regval = readl(vclk->vote_reg);
8f60fcb0:	e5912000 	ldr	r2, [r1]
	vote_regval |= vclk->en_mask;
8f60fcb4:	e1822000 	orr	r2, r2, r0
	writel_relaxed(vote_regval, vclk->vote_reg);
8f60fcb8:	e5812000 	str	r2, [r1]
		val = readl(vclk->cbcr_reg);
8f60fcbc:	e5930000 	ldr	r0, [r3]
		val &= BRANCH_CHECK_MASK;
	}
	/*  wait until status shows it is enabled */
	while((val != BRANCH_ON_VAL) && (val != BRANCH_NOC_FSM_ON_VAL));
8f60fcc0:	e210020d 	ands	r0, r0, #-805306368	; 0xd0000000
8f60fcc4:	1afffffc 	bne	8f60fcbc <clock_lib2_vote_clk_enable+0x30>

	return 0;
}
8f60fcc8:	e59f301c 	ldr	r3, [pc, #28]	; 8f60fcec <clock_lib2_vote_clk_enable+0x60>
8f60fccc:	e5932000 	ldr	r2, [r3]
8f60fcd0:	e59d3004 	ldr	r3, [r13, #4]
8f60fcd4:	e0332002 	eors	r2, r3, r2
8f60fcd8:	e3a03000 	mov	r3, #0
8f60fcdc:	1a000001 	bne	8f60fce8 <clock_lib2_vote_clk_enable+0x5c>
8f60fce0:	e28dd00c 	add	r13, r13, #12
8f60fce4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60fce8:	eb008bb4 	bl	8f632bc0 <__stack_chk_fail>
8f60fcec:	8f74221c 	.word	0x8f74221c

8f60fcf0 <clock_lib2_vote_clk_disable>:

/* Vote clock disable */
void clock_lib2_vote_clk_disable(struct clk *c)
{
8f60fcf0:	e59f3048 	ldr	r3, [pc, #72]	; 8f60fd40 <clock_lib2_vote_clk_disable+0x50>
8f60fcf4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60fcf8:	e24dd00c 	sub	r13, r13, #12
	uint32_t vote_regval;
	struct vote_clk *vclk = to_local_vote_clk(c);

	vote_regval = readl(vclk->vote_reg);
8f60fcfc:	e5102008 	ldr	r2, [r0, #-8]
{
8f60fd00:	e5933000 	ldr	r3, [r3]
8f60fd04:	e58d3004 	str	r3, [r13, #4]
8f60fd08:	e3a03000 	mov	r3, #0
	vote_regval &= ~vclk->en_mask;
8f60fd0c:	e5101004 	ldr	r1, [r0, #-4]
	vote_regval = readl(vclk->vote_reg);
8f60fd10:	e5923000 	ldr	r3, [r2]
	vote_regval &= ~vclk->en_mask;
8f60fd14:	e1c33001 	bic	r3, r3, r1
    writel_relaxed(vote_regval, vclk->vote_reg);
8f60fd18:	e5823000 	str	r3, [r2]
}
8f60fd1c:	e59f301c 	ldr	r3, [pc, #28]	; 8f60fd40 <clock_lib2_vote_clk_disable+0x50>
8f60fd20:	e5932000 	ldr	r2, [r3]
8f60fd24:	e59d3004 	ldr	r3, [r13, #4]
8f60fd28:	e0332002 	eors	r2, r3, r2
8f60fd2c:	e3a03000 	mov	r3, #0
8f60fd30:	1a000001 	bne	8f60fd3c <clock_lib2_vote_clk_disable+0x4c>
8f60fd34:	e28dd00c 	add	r13, r13, #12
8f60fd38:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f60fd3c:	eb008b9f 	bl	8f632bc0 <__stack_chk_fail>
8f60fd40:	8f74221c 	.word	0x8f74221c

8f60fd44 <clock_lib2_reset_clk_reset>:

	return ret;
}

int clock_lib2_reset_clk_reset(struct clk *c, enum clk_reset_action action)
{
8f60fd44:	e59f307c 	ldr	r3, [pc, #124]	; 8f60fdc8 <clock_lib2_reset_clk_reset+0x84>
	struct reset_clk *rst = to_reset_clk(c);

	if (!rst)
8f60fd48:	e3500004 	cmp	r0, #4
{
8f60fd4c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f60fd50:	e24dd00c 	sub	r13, r13, #12
8f60fd54:	e5933000 	ldr	r3, [r3]
8f60fd58:	e58d3004 	str	r3, [r13, #4]
8f60fd5c:	e3a03000 	mov	r3, #0
		return 0;
8f60fd60:	03a00000 	moveq	r0, #0
	if (!rst)
8f60fd64:	0a000009 	beq	8f60fd90 <clock_lib2_reset_clk_reset+0x4c>
	reg = readl(bcr_reg);
8f60fd68:	e5102004 	ldr	r2, [r0, #-4]
	switch (action) {
8f60fd6c:	e3510000 	cmp	r1, #0
	reg = readl(bcr_reg);
8f60fd70:	e5923000 	ldr	r3, [r2]
	switch (action) {
8f60fd74:	0a00000f 	beq	8f60fdb8 <clock_lib2_reset_clk_reset+0x74>
8f60fd78:	e3510001 	cmp	r1, #1
		reg |= BIT(0);
8f60fd7c:	03833001 	orreq	r3, r3, #1
	int ret = 0;
8f60fd80:	03a00000 	moveq	r0, #0
	switch (action) {
8f60fd84:	1a000009 	bne	8f60fdb0 <clock_lib2_reset_clk_reset+0x6c>
	writel(reg, bcr_reg);
8f60fd88:	e5823000 	str	r3, [r2]
	dmb();
8f60fd8c:	f57ff05f 	dmb	sy

	return __clock_lib2_branch_clk_reset(rst->bcr_reg, action);
}
8f60fd90:	e59f3030 	ldr	r3, [pc, #48]	; 8f60fdc8 <clock_lib2_reset_clk_reset+0x84>
8f60fd94:	e5932000 	ldr	r2, [r3]
8f60fd98:	e59d3004 	ldr	r3, [r13, #4]
8f60fd9c:	e0332002 	eors	r2, r3, r2
8f60fda0:	e3a03000 	mov	r3, #0
8f60fda4:	1a000006 	bne	8f60fdc4 <clock_lib2_reset_clk_reset+0x80>
8f60fda8:	e28dd00c 	add	r13, r13, #12
8f60fdac:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	switch (action) {
8f60fdb0:	e3a00001 	mov	r0, #1
8f60fdb4:	eafffff3 	b	8f60fd88 <clock_lib2_reset_clk_reset+0x44>
		reg &= ~BIT(0);
8f60fdb8:	e3c33001 	bic	r3, r3, #1
	int ret = 0;
8f60fdbc:	e1a00001 	mov	r0, r1
		break;
8f60fdc0:	eafffff0 	b	8f60fd88 <clock_lib2_reset_clk_reset+0x44>
}
8f60fdc4:	eb008b7d 	bl	8f632bc0 <__stack_chk_fail>
8f60fdc8:	8f74221c 	.word	0x8f74221c

8f60fdcc <msm_boot_uart_dm_write.isra.0>:

/*
 * UART transmit operation
 */
static unsigned int
msm_boot_uart_dm_write(uint32_t base, char *data, unsigned int num_of_chars)
8f60fdcc:	e59f31f4 	ldr	r3, [pc, #500]	; 8f60ffc8 <msm_boot_uart_dm_write.isra.0+0x1fc>
	unsigned int tx_word = 0;
	int i = 0;
	char *tx_data = NULL;
	uint8_t num_chars_written;

	if ((data == NULL) || (num_of_chars <= 0)) {
8f60fdd0:	e3520000 	cmp	r2, #0
msm_boot_uart_dm_write(uint32_t base, char *data, unsigned int num_of_chars)
8f60fdd4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f60fdd8:	e24dd01c 	sub	r13, r13, #28
8f60fddc:	e5933000 	ldr	r3, [r3]
8f60fde0:	e58d3014 	str	r3, [r13, #20]
8f60fde4:	e3a03000 	mov	r3, #0
	if ((data == NULL) || (num_of_chars <= 0)) {
8f60fde8:	0a000065 	beq	8f60ff84 <msm_boot_uart_dm_write.isra.0+0x1b8>
8f60fdec:	e2422001 	sub	r2, r2, #1
8f60fdf0:	e2413001 	sub	r3, r1, #1
8f60fdf4:	e0812002 	add	r2, r1, r2
8f60fdf8:	e1a07000 	mov	r7, r0
8f60fdfc:	e1a06001 	mov	r6, r1
	for (i = 0, j = 0; i < *num_of_chars; i++, j++) {
8f60fe00:	e3a05000 	mov	r5, #0
		if (data_in[i] == '\n') {
8f60fe04:	e5f31001 	ldrb	r1, [r3, #1]!
8f60fe08:	e351000a 	cmp	r1, #10
			j++;
8f60fe0c:	02855001 	addeq	r5, r5, #1
	for (i = 0, j = 0; i < *num_of_chars; i++, j++) {
8f60fe10:	e1520003 	cmp	r2, r3
8f60fe14:	e2855001 	add	r5, r5, #1
8f60fe18:	1afffff9 	bne	8f60fe04 <msm_boot_uart_dm_write.isra.0+0x38>
	 * be empty as indicated by TX_READY interrupt in IMR register
	 */

	/* Check if transmit FIFO is empty.
	 * If not we'll wait for TX_READY interrupt. */
	if (!(readl(MSM_BOOT_UART_DM_SR(base)) & MSM_BOOT_UART_DM_SR_TXEMT)) {
8f60fe1c:	e59730a4 	ldr	r3, [r7, #164]	; 0xa4
8f60fe20:	e28740a4 	add	r4, r7, #164	; 0xa4
8f60fe24:	e3130008 	tst	r3, #8
8f60fe28:	1a000008 	bne	8f60fe50 <msm_boot_uart_dm_write.isra.0+0x84>
		while (!(readl(MSM_BOOT_UART_DM_ISR(base)) & MSM_BOOT_UART_DM_TX_READY)) {
8f60fe2c:	e59730b4 	ldr	r3, [r7, #180]	; 0xb4
8f60fe30:	e28780b4 	add	r8, r7, #180	; 0xb4
8f60fe34:	e3130080 	tst	r3, #128	; 0x80
8f60fe38:	1a000004 	bne	8f60fe50 <msm_boot_uart_dm_write.isra.0+0x84>
			udelay(1);
8f60fe3c:	e3a00001 	mov	r0, #1
8f60fe40:	ebfffbc5 	bl	8f60ed5c <udelay>
		while (!(readl(MSM_BOOT_UART_DM_ISR(base)) & MSM_BOOT_UART_DM_TX_READY)) {
8f60fe44:	e5983000 	ldr	r3, [r8]
8f60fe48:	e3130080 	tst	r3, #128	; 0x80
8f60fe4c:	0afffffa 	beq	8f60fe3c <msm_boot_uart_dm_write.isra.0+0x70>
	critical_section_count++;
8f60fe50:	e3012acc 	movw	r2, #6860	; 0x1acc
8f60fe54:	e3482f71 	movt	r2, #36721	; 0x8f71
8f60fe58:	e58d200c 	str	r2, [r13, #12]
8f60fe5c:	e5923000 	ldr	r3, [r2]
8f60fe60:	e2833001 	add	r3, r3, #1
8f60fe64:	e5823000 	str	r3, [r2]
	if (critical_section_count == 1)
8f60fe68:	e3530001 	cmp	r3, #1
8f60fe6c:	0a000052 	beq	8f60ffbc <msm_boot_uart_dm_write.isra.0+0x1f0>
	/* Clear TX_READY interrupt */
	writel(MSM_BOOT_UART_DM_GCMD_RES_TX_RDY_INT, MSM_BOOT_UART_DM_CR(base));

	/* We use four-character word FIFO. So we need to divide data into
	 * four characters and write in UART_DM_TF register */
	tx_word_count = (num_of_chars % 4) ? ((num_of_chars / 4) + 1) :
8f60fe70:	e3150003 	tst	r5, #3
	writel(MSM_BOOT_UART_DM_GCMD_RES_TX_RDY_INT, MSM_BOOT_UART_DM_CR(base));
8f60fe74:	e3a03c03 	mov	r3, #768	; 0x300
	writel(num_of_chars, MSM_BOOT_UART_DM_NO_CHARS_FOR_TX(base));
8f60fe78:	e5875040 	str	r5, [r7, #64]	; 0x40
	writel(MSM_BOOT_UART_DM_GCMD_RES_TX_RDY_INT, MSM_BOOT_UART_DM_CR(base));
8f60fe7c:	e58730a8 	str	r3, [r7, #168]	; 0xa8
	tx_word_count = (num_of_chars % 4) ? ((num_of_chars / 4) + 1) :
8f60fe80:	1a000047 	bne	8f60ffa4 <msm_boot_uart_dm_write.isra.0+0x1d8>
	    (num_of_chars / 4);
	tx_char_left = num_of_chars;

	for (i = 0; i < (int)tx_word_count; i++) {
8f60fe84:	e1b03125 	lsrs	r3, r5, #2
8f60fe88:	e58d3004 	str	r3, [r13, #4]
8f60fe8c:	0a00002d 	beq	8f60ff48 <msm_boot_uart_dm_write.isra.0+0x17c>
		while (!(readl(MSM_BOOT_UART_DM_SR(base)) & MSM_BOOT_UART_DM_SR_TXRDY)) {
			udelay(1);
		}

		/* TX FIFO has space. Write the chars */
		writel(tx_word, MSM_BOOT_UART_DM_TF(base, 0));
8f60fe90:	e2873c01 	add	r3, r7, #256	; 0x100
				buffer[num_chars_writtten] = '\n';
8f60fe94:	e3a0800a 	mov	r8, #10
		writel(tx_word, MSM_BOOT_UART_DM_TF(base, 0));
8f60fe98:	e3a07000 	mov	r7, #0
8f60fe9c:	e58d3008 	str	r3, [r13, #8]
		tx_char = (tx_char_left < 4) ? tx_char_left : 4;
8f60fea0:	e3550004 	cmp	r5, #4
8f60fea4:	31a0e005 	movcc	r14, r5
8f60fea8:	23a0e004 	movcs	r14, #4
	 for(int j=0; j < cnt; j++)
8f60feac:	e3550000 	cmp	r5, #0
8f60feb0:	0a00003f 	beq	8f60ffb4 <msm_boot_uart_dm_write.isra.0+0x1e8>
8f60feb4:	e3a01000 	mov	r1, #0
8f60feb8:	e1a03006 	mov	r3, r6
	*word = 0;
8f60febc:	e1a09001 	mov	r9, r1
	 for(int j=0; j < cnt; j++)
8f60fec0:	e1a00001 	mov	r0, r1
	uint8_t num_chars_writtten = 0;
8f60fec4:	e1a0c001 	mov	r12, r1
			*word |= ('\r' & 0xff) << (j * 8);
8f60fec8:	e3a0b00d 	mov	r11, #13
			buffer[num_chars_writtten] = NON_PRINTABLE_ASCII_CHAR;
8f60fecc:	e3e0a07f 	mvn	r10, #127	; 0x7f
		 if (buffer[num_chars_writtten] == '\n')
8f60fed0:	e5d32000 	ldrb	r2, [r3]
8f60fed4:	e352000a 	cmp	r2, #10
			buffer[num_chars_writtten] = NON_PRINTABLE_ASCII_CHAR;
8f60fed8:	05c3a000 	strbeq	r10, [r3]
			*word |= ('\r' & 0xff) << (j * 8);
8f60fedc:	0189911b 	orreq	r9, r9, r11, lsl r1
		 if (buffer[num_chars_writtten] == '\n')
8f60fee0:	0a000006 	beq	8f60ff00 <msm_boot_uart_dm_write.isra.0+0x134>
			if (buffer[num_chars_writtten] == NON_PRINTABLE_ASCII_CHAR)
8f60fee4:	e3520080 	cmp	r2, #128	; 0x80
				buffer[num_chars_writtten] = '\n';
8f60fee8:	05c38000 	strbeq	r8, [r3]
			 num_chars_writtten++;
8f60feec:	e28c3001 	add	r3, r12, #1
				buffer[num_chars_writtten] = '\n';
8f60fef0:	03a0200a 	moveq	r2, #10
			 num_chars_writtten++;
8f60fef4:	e6efc073 	uxtb	r12, r3
			 *word |= (buffer[num_chars_writtten] & 0xff) << (j * 8);
8f60fef8:	e1899112 	orr	r9, r9, r2, lsl r1
		tx_char_left = num_of_chars - (i + 1) * 4;
		tx_data = tx_data + num_chars_written;
8f60fefc:	e6e63073 	uxtab	r3, r6, r3
	 for(int j=0; j < cnt; j++)
8f60ff00:	e2800001 	add	r0, r0, #1
8f60ff04:	e2811008 	add	r1, r1, #8
8f60ff08:	e15e0000 	cmp	r14, r0
8f60ff0c:	1affffef 	bne	8f60fed0 <msm_boot_uart_dm_write.isra.0+0x104>
8f60ff10:	e1a06003 	mov	r6, r3
8f60ff14:	ea000001 	b	8f60ff20 <msm_boot_uart_dm_write.isra.0+0x154>
			udelay(1);
8f60ff18:	e3a00001 	mov	r0, #1
8f60ff1c:	ebfffb8e 	bl	8f60ed5c <udelay>
		while (!(readl(MSM_BOOT_UART_DM_SR(base)) & MSM_BOOT_UART_DM_SR_TXRDY)) {
8f60ff20:	e5943000 	ldr	r3, [r4]
8f60ff24:	e3130004 	tst	r3, #4
8f60ff28:	0afffffa 	beq	8f60ff18 <msm_boot_uart_dm_write.isra.0+0x14c>
	for (i = 0; i < (int)tx_word_count; i++) {
8f60ff2c:	e59d3004 	ldr	r3, [r13, #4]
		tx_char_left = num_of_chars - (i + 1) * 4;
8f60ff30:	e2877001 	add	r7, r7, #1
8f60ff34:	e2455004 	sub	r5, r5, #4
	for (i = 0; i < (int)tx_word_count; i++) {
8f60ff38:	e1570003 	cmp	r7, r3
		writel(tx_word, MSM_BOOT_UART_DM_TF(base, 0));
8f60ff3c:	e59d3008 	ldr	r3, [r13, #8]
8f60ff40:	e5839000 	str	r9, [r3]
	for (i = 0; i < (int)tx_word_count; i++) {
8f60ff44:	baffffd5 	blt	8f60fea0 <msm_boot_uart_dm_write.isra.0+0xd4>
	critical_section_count--;
8f60ff48:	e59d200c 	ldr	r2, [r13, #12]
8f60ff4c:	e5923000 	ldr	r3, [r2]
8f60ff50:	e2433001 	sub	r3, r3, #1
8f60ff54:	e5823000 	str	r3, [r2]
	if (critical_section_count == 0)
8f60ff58:	e3530000 	cmp	r3, #0
8f60ff5c:	1a000008 	bne	8f60ff84 <msm_boot_uart_dm_write.isra.0+0x1b8>
		arch_enable_ints();
8f60ff60:	e59f3060 	ldr	r3, [pc, #96]	; 8f60ffc8 <msm_boot_uart_dm_write.isra.0+0x1fc>
8f60ff64:	e5932000 	ldr	r2, [r3]
8f60ff68:	e59d3014 	ldr	r3, [r13, #20]
8f60ff6c:	e0332002 	eors	r2, r3, r2
8f60ff70:	e3a03000 	mov	r3, #0
8f60ff74:	1a000012 	bne	8f60ffc4 <msm_boot_uart_dm_write.isra.0+0x1f8>
	}
	exit_critical_section();

	return MSM_BOOT_UART_DM_E_SUCCESS;
}
8f60ff78:	e28dd01c 	add	r13, r13, #28
8f60ff7c:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f60ff80:	ea004420 	b	8f621008 <arch_enable_ints>
8f60ff84:	e59f303c 	ldr	r3, [pc, #60]	; 8f60ffc8 <msm_boot_uart_dm_write.isra.0+0x1fc>
8f60ff88:	e5932000 	ldr	r2, [r3]
8f60ff8c:	e59d3014 	ldr	r3, [r13, #20]
8f60ff90:	e0332002 	eors	r2, r3, r2
8f60ff94:	e3a03000 	mov	r3, #0
8f60ff98:	1a000009 	bne	8f60ffc4 <msm_boot_uart_dm_write.isra.0+0x1f8>
8f60ff9c:	e28dd01c 	add	r13, r13, #28
8f60ffa0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	tx_word_count = (num_of_chars % 4) ? ((num_of_chars / 4) + 1) :
8f60ffa4:	e1a03125 	lsr	r3, r5, #2
8f60ffa8:	e2833001 	add	r3, r3, #1
8f60ffac:	e58d3004 	str	r3, [r13, #4]
8f60ffb0:	eaffffb6 	b	8f60fe90 <msm_boot_uart_dm_write.isra.0+0xc4>
	*word = 0;
8f60ffb4:	e1a09005 	mov	r9, r5
8f60ffb8:	eaffffd8 	b	8f60ff20 <msm_boot_uart_dm_write.isra.0+0x154>
		arch_disable_ints();
8f60ffbc:	eb004415 	bl	8f621018 <arch_disable_ints>
8f60ffc0:	eaffffaa 	b	8f60fe70 <msm_boot_uart_dm_write.isra.0+0xa4>
}
8f60ffc4:	eb008afd 	bl	8f632bc0 <__stack_chk_fail>
8f60ffc8:	8f74221c 	.word	0x8f74221c

8f60ffcc <uart_dm_init>:
/* Defining functions that's exposed to outside world and in coformance to
 * existing uart implemention. These functions are being called to initialize
 * UART and print debug messages in bootloader.
 */
void uart_dm_init(uint8_t id, uint32_t gsbi_base, uint32_t uart_dm_base)
{
8f60ffcc:	e59f3178 	ldr	r3, [pc, #376]	; 8f61014c <uart_dm_init+0x180>
8f60ffd0:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f60ffd4:	e24dd014 	sub	r13, r13, #20
8f60ffd8:	e5933000 	ldr	r3, [r3]
8f60ffdc:	e58d300c 	str	r3, [r13, #12]
8f60ffe0:	e3a03000 	mov	r3, #0
	static uint8_t port = 0;
	char *data = "Android Bootloader - UART_DM Initialized!!!\n";

	/* Configure the uart clock */
	clock_config_uart_dm(id);
8f60ffe4:	e1a0700e 	mov	r7, r14
{
8f60ffe8:	e1a06000 	mov	r6, r0
8f60ffec:	e1a05001 	mov	r5, r1
8f60fff0:	e1a04002 	mov	r4, r2
	clock_config_uart_dm(id);
8f60fff4:	ebffc7c0 	bl	8f601efc <clock_config_uart_dm>
	dsb();
8f60fff8:	f57ff04f 	dsb	sy

	/* Configure GPIO to provide connectivity between UART block
	   product ports and chip pads */
	gpio_config_uart_dm(id);
8f60fffc:	e1a00006 	mov	r0, r6
8f610000:	ebffc993 	bl	8f602654 <gpio_config_uart_dm>
	dsb();
8f610004:	f57ff04f 	dsb	sy

	/* Configure GSBI for UART_DM protocol.
	 * I2C on 2 ports, UART (without HS flow control) on the other 2.
	 * This is only on chips that have GSBI block
	 */
	 if(gsbi_base)
8f610008:	e3550000 	cmp	r5, #0
		writel(GSBI_PROTOCOL_CODE_I2C_UART <<
8f61000c:	13a03060 	movne	r3, #96	; 0x60
8f610010:	15853000 	strne	r3, [r5]
			GSBI_CTRL_REG_PROTOCOL_CODE_S,
			GSBI_CTRL_REG(gsbi_base));
	dsb();
8f610014:	f57ff04f 	dsb	sy

	/* Configure clock selection register for tx and rx rates.
	 * Selecting 115.2k for both RX and TX.
	 */
	writel(UART_DM_CLK_RX_TX_BIT_RATE, MSM_BOOT_UART_DM_CSR(uart_dm_base));
8f610018:	e3a030cc 	mov	r3, #204	; 0xcc
8f61001c:	e58430a0 	str	r3, [r4, #160]	; 0xa0
	dsb();
8f610020:	f57ff04f 	dsb	sy
	/* Intialize UART_DM */
	msm_boot_uart_dm_init(uart_dm_base);

	msm_boot_uart_dm_write(uart_dm_base, data, 44);

	ASSERT(port < ARRAY_SIZE(port_lookup));
8f610024:	e30c5d60 	movw	r5, #52576	; 0xcd60
8f610028:	e3485f72 	movt	r5, #36722	; 0x8f72
	writel(0x0, MSM_BOOT_UART_DM_MR1(uart_dm_base));
8f61002c:	e3a03000 	mov	r3, #0
	writel(MSM_BOOT_UART_DM_CMD_RES_STALE_INT, MSM_BOOT_UART_DM_CR(base));
8f610030:	e3a02080 	mov	r2, #128	; 0x80
	writel(0x0, MSM_BOOT_UART_DM_MR1(uart_dm_base));
8f610034:	e5843000 	str	r3, [r4]
	writel(MSM_BOOT_UART_DM_8_N_1_MODE, MSM_BOOT_UART_DM_MR2(uart_dm_base));
8f610038:	e3a01034 	mov	r1, #52	; 0x34
	msm_boot_uart_dm_write(uart_dm_base, data, 44);
8f61003c:	e1a00004 	mov	r0, r4
	writel(MSM_BOOT_UART_DM_8_N_1_MODE, MSM_BOOT_UART_DM_MR2(uart_dm_base));
8f610040:	e5841004 	str	r1, [r4, #4]
	writel(MSM_BOOT_UART_DM_IMR_ENABLED, MSM_BOOT_UART_DM_IMR(uart_dm_base));
8f610044:	e3a01099 	mov	r1, #153	; 0x99
8f610048:	e58410b0 	str	r1, [r4, #176]	; 0xb0
	writel(MSM_BOOT_UART_DM_TFW_VALUE, MSM_BOOT_UART_DM_TFWR(uart_dm_base));
8f61004c:	e584301c 	str	r3, [r4, #28]
	writel(MSM_BOOT_UART_DM_STALE_TIMEOUT_LSB, MSM_BOOT_UART_DM_IPR(uart_dm_base));
8f610050:	e3a0100f 	mov	r1, #15
	writel(MSM_BOOT_UART_DM_RFW_VALUE, MSM_BOOT_UART_DM_RFWR(uart_dm_base));
8f610054:	e5843020 	str	r3, [r4, #32]
	writel(MSM_BOOT_UART_DM_STALE_TIMEOUT_LSB, MSM_BOOT_UART_DM_IPR(uart_dm_base));
8f610058:	e5841018 	str	r1, [r4, #24]
	writel(MSM_BOOT_UART_DM_CMD_RESET_RX, MSM_BOOT_UART_DM_CR(base));
8f61005c:	e3a01010 	mov	r1, #16
	writel(0x0, MSM_BOOT_UART_DM_IRDA(uart_dm_base));
8f610060:	e58430b8 	str	r3, [r4, #184]	; 0xb8
	writel(0x0, MSM_BOOT_UART_DM_HCR(uart_dm_base));
8f610064:	e5843024 	str	r3, [r4, #36]	; 0x24
	writel(MSM_BOOT_UART_DM_CMD_RESET_RX, MSM_BOOT_UART_DM_CR(base));
8f610068:	e58410a8 	str	r1, [r4, #168]	; 0xa8
	writel(MSM_BOOT_UART_DM_CMD_RESET_TX, MSM_BOOT_UART_DM_CR(base));
8f61006c:	e3a01020 	mov	r1, #32
8f610070:	e58410a8 	str	r1, [r4, #168]	; 0xa8
	writel(MSM_BOOT_UART_DM_CMD_RESET_ERR_STAT, MSM_BOOT_UART_DM_CR(base));
8f610074:	e3a01030 	mov	r1, #48	; 0x30
8f610078:	e58410a8 	str	r1, [r4, #168]	; 0xa8
	writel(MSM_BOOT_UART_DM_CMD_RES_TX_ERR, MSM_BOOT_UART_DM_CR(base));
8f61007c:	e3a010a0 	mov	r1, #160	; 0xa0
8f610080:	e58410a8 	str	r1, [r4, #168]	; 0xa8
	writel(MSM_BOOT_UART_DM_CR_RX_ENABLE, MSM_BOOT_UART_DM_CR(uart_dm_base));
8f610084:	e3a01001 	mov	r1, #1
	writel(MSM_BOOT_UART_DM_CMD_RES_STALE_INT, MSM_BOOT_UART_DM_CR(base));
8f610088:	e58420a8 	str	r2, [r4, #168]	; 0xa8
	writel(0x0, MSM_BOOT_UART_DM_DMEN(uart_dm_base));
8f61008c:	e584303c 	str	r3, [r4, #60]	; 0x3c
	writel(MSM_BOOT_UART_DM_GCMD_DIS_STALE_EVT, MSM_BOOT_UART_DM_CR(uart_dm_base));
8f610090:	e3a03c06 	mov	r3, #1536	; 0x600
	writel(MSM_BOOT_UART_DM_CR_RX_ENABLE, MSM_BOOT_UART_DM_CR(uart_dm_base));
8f610094:	e58410a8 	str	r1, [r4, #168]	; 0xa8
	writel(MSM_BOOT_UART_DM_CR_TX_ENABLE, MSM_BOOT_UART_DM_CR(uart_dm_base));
8f610098:	e3a01004 	mov	r1, #4
8f61009c:	e58410a8 	str	r1, [r4, #168]	; 0xa8
	writel(MSM_BOOT_UART_DM_DMRX_DEF_VALUE, MSM_BOOT_UART_DM_DMRX(uart_dm_base));
8f6100a0:	e3a01e22 	mov	r1, #544	; 0x220
	writel(MSM_BOOT_UART_DM_GCMD_DIS_STALE_EVT, MSM_BOOT_UART_DM_CR(uart_dm_base));
8f6100a4:	e58430a8 	str	r3, [r4, #168]	; 0xa8
	writel(MSM_BOOT_UART_DM_GCMD_ENA_STALE_EVT, MSM_BOOT_UART_DM_CR(uart_dm_base));
8f6100a8:	e3a03c05 	mov	r3, #1280	; 0x500
	writel(MSM_BOOT_UART_DM_CMD_RES_STALE_INT, MSM_BOOT_UART_DM_CR(uart_dm_base));
8f6100ac:	e58420a8 	str	r2, [r4, #168]	; 0xa8
	msm_boot_uart_dm_write(uart_dm_base, data, 44);
8f6100b0:	e3a0202c 	mov	r2, #44	; 0x2c
	writel(MSM_BOOT_UART_DM_DMRX_DEF_VALUE, MSM_BOOT_UART_DM_DMRX(uart_dm_base));
8f6100b4:	e5841034 	str	r1, [r4, #52]	; 0x34
	msm_boot_uart_dm_write(uart_dm_base, data, 44);
8f6100b8:	e3031e20 	movw	r1, #15904	; 0x3e20
	writel(MSM_BOOT_UART_DM_GCMD_ENA_STALE_EVT, MSM_BOOT_UART_DM_CR(uart_dm_base));
8f6100bc:	e58430a8 	str	r3, [r4, #168]	; 0xa8
	msm_boot_uart_dm_write(uart_dm_base, data, 44);
8f6100c0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6100c4:	ebffff40 	bl	8f60fdcc <msm_boot_uart_dm_write.isra.0>
	ASSERT(port < ARRAY_SIZE(port_lookup));
8f6100c8:	e5d53000 	ldrb	r3, [r5]
8f6100cc:	e3530003 	cmp	r3, #3
8f6100d0:	8a000010 	bhi	8f610118 <uart_dm_init+0x14c>
	port_lookup[port++] = uart_dm_base;
8f6100d4:	e30c1d64 	movw	r1, #52580	; 0xcd64
8f6100d8:	e3481f72 	movt	r1, #36722	; 0x8f72
8f6100dc:	e2830001 	add	r0, r3, #1

	/* Set UART init flag */
	uart_init_flag = 1;
8f6100e0:	e30c2d74 	movw	r2, #52596	; 0xcd74
	port_lookup[port++] = uart_dm_base;
8f6100e4:	e7814103 	str	r4, [r1, r3, lsl #2]
	uart_init_flag = 1;
8f6100e8:	e3482f72 	movt	r2, #36722	; 0x8f72
}
8f6100ec:	e59f3058 	ldr	r3, [pc, #88]	; 8f61014c <uart_dm_init+0x180>
	port_lookup[port++] = uart_dm_base;
8f6100f0:	e5c50000 	strb	r0, [r5]
	uart_init_flag = 1;
8f6100f4:	e3a00001 	mov	r0, #1
8f6100f8:	e5820000 	str	r0, [r2]
}
8f6100fc:	e5932000 	ldr	r2, [r3]
8f610100:	e59d300c 	ldr	r3, [r13, #12]
8f610104:	e0332002 	eors	r2, r3, r2
8f610108:	e3a03000 	mov	r3, #0
8f61010c:	1a00000d 	bne	8f610148 <uart_dm_init+0x17c>
8f610110:	e28dd014 	add	r13, r13, #20
8f610114:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
	ASSERT(port < ARRAY_SIZE(port_lookup));
8f610118:	e3a03e1a 	mov	r3, #416	; 0x1a0
8f61011c:	e3032e70 	movw	r2, #15984	; 0x3e70
8f610120:	e1a00007 	mov	r0, r7
8f610124:	e3482f70 	movt	r2, #36720	; 0x8f70
8f610128:	e3001130 	movw	r1, #304	; 0x130
8f61012c:	e58d2000 	str	r2, [r13]
8f610130:	e3481f70 	movt	r1, #36720	; 0x8f70
8f610134:	e3032e50 	movw	r2, #15952	; 0x3e50
8f610138:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61013c:	eb008a5e 	bl	8f632abc <_panic>
	port_lookup[port++] = uart_dm_base;
8f610140:	e5d53000 	ldrb	r3, [r5]
8f610144:	eaffffe2 	b	8f6100d4 <uart_dm_init+0x108>
}
8f610148:	eb008a9c 	bl	8f632bc0 <__stack_chk_fail>
8f61014c:	8f74221c 	.word	0x8f74221c

8f610150 <uart_putc>:
int uart_putc(int port, char c)
{
	uint32_t uart_base = port_lookup[port];

	/* Don't do anything if UART is not initialized */
	if (!uart_init_flag)
8f610150:	e30c2d74 	movw	r2, #52596	; 0xcd74
8f610154:	e3482f72 	movt	r2, #36722	; 0x8f72
	uint32_t uart_base = port_lookup[port];
8f610158:	e30c3d64 	movw	r3, #52580	; 0xcd64
8f61015c:	e3483f72 	movt	r3, #36722	; 0x8f72
	if (!uart_init_flag)
8f610160:	e5922000 	ldr	r2, [r2]
{
8f610164:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	if (!uart_init_flag)
8f610168:	e3520000 	cmp	r2, #0
{
8f61016c:	e24dd014 	sub	r13, r13, #20
	uint32_t uart_base = port_lookup[port];
8f610170:	e7930100 	ldr	r0, [r3, r0, lsl #2]
{
8f610174:	e59f304c 	ldr	r3, [pc, #76]	; 8f6101c8 <uart_putc+0x78>
8f610178:	e5cd1007 	strb	r1, [r13, #7]
8f61017c:	e5933000 	ldr	r3, [r3]
8f610180:	e58d300c 	str	r3, [r13, #12]
8f610184:	e3a03000 	mov	r3, #0
	if (!uart_init_flag)
8f610188:	0a00000b 	beq	8f6101bc <uart_putc+0x6c>
		return -1;

	msm_boot_uart_dm_write(uart_base, &c, 1);
8f61018c:	e28d1007 	add	r1, r13, #7
8f610190:	e3a02001 	mov	r2, #1
8f610194:	ebffff0c 	bl	8f60fdcc <msm_boot_uart_dm_write.isra.0>

	return 0;
8f610198:	e3a00000 	mov	r0, #0
}
8f61019c:	e59f3024 	ldr	r3, [pc, #36]	; 8f6101c8 <uart_putc+0x78>
8f6101a0:	e5932000 	ldr	r2, [r3]
8f6101a4:	e59d300c 	ldr	r3, [r13, #12]
8f6101a8:	e0332002 	eors	r2, r3, r2
8f6101ac:	e3a03000 	mov	r3, #0
8f6101b0:	1a000003 	bne	8f6101c4 <uart_putc+0x74>
8f6101b4:	e28dd014 	add	r13, r13, #20
8f6101b8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		return -1;
8f6101bc:	e3e00000 	mvn	r0, #0
8f6101c0:	eafffff5 	b	8f61019c <uart_putc+0x4c>
}
8f6101c4:	eb008a7d 	bl	8f632bc0 <__stack_chk_fail>
8f6101c8:	8f74221c 	.word	0x8f74221c

8f6101cc <board_platform_id>:
	target_baseband_detect(&board);
}

uint32_t board_platform_id(void)
{
	return board.platform;
8f6101cc:	e3013320 	movw	r3, #4896	; 0x1320
8f6101d0:	e3483f71 	movt	r3, #36721	; 0x8f71
{
8f6101d4:	e59f2038 	ldr	r2, [pc, #56]	; 8f610214 <board_platform_id+0x48>
8f6101d8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6101dc:	e24dd00c 	sub	r13, r13, #12
	return board.platform;
8f6101e0:	e5930000 	ldr	r0, [r3]
{
8f6101e4:	e5922000 	ldr	r2, [r2]
8f6101e8:	e58d2004 	str	r2, [r13, #4]
8f6101ec:	e3a02000 	mov	r2, #0
}
8f6101f0:	e59f301c 	ldr	r3, [pc, #28]	; 8f610214 <board_platform_id+0x48>
8f6101f4:	e5932000 	ldr	r2, [r3]
8f6101f8:	e59d3004 	ldr	r3, [r13, #4]
8f6101fc:	e0332002 	eors	r2, r3, r2
8f610200:	e3a03000 	mov	r3, #0
8f610204:	1a000001 	bne	8f610210 <board_platform_id+0x44>
8f610208:	e28dd00c 	add	r13, r13, #12
8f61020c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f610210:	eb008a6a 	bl	8f632bc0 <__stack_chk_fail>
8f610214:	8f74221c 	.word	0x8f74221c

8f610218 <board_target_id>:

uint32_t board_target_id()
{
	return board.target;
8f610218:	e3013320 	movw	r3, #4896	; 0x1320
8f61021c:	e3483f71 	movt	r3, #36721	; 0x8f71
{
8f610220:	e59f2038 	ldr	r2, [pc, #56]	; 8f610260 <board_target_id+0x48>
8f610224:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f610228:	e24dd00c 	sub	r13, r13, #12
	return board.target;
8f61022c:	e5930018 	ldr	r0, [r3, #24]
{
8f610230:	e5922000 	ldr	r2, [r2]
8f610234:	e58d2004 	str	r2, [r13, #4]
8f610238:	e3a02000 	mov	r2, #0
}
8f61023c:	e59f301c 	ldr	r3, [pc, #28]	; 8f610260 <board_target_id+0x48>
8f610240:	e5932000 	ldr	r2, [r3]
8f610244:	e59d3004 	ldr	r3, [r13, #4]
8f610248:	e0332002 	eors	r2, r3, r2
8f61024c:	e3a03000 	mov	r3, #0
8f610250:	1a000001 	bne	8f61025c <board_target_id+0x44>
8f610254:	e28dd00c 	add	r13, r13, #12
8f610258:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61025c:	eb008a57 	bl	8f632bc0 <__stack_chk_fail>
8f610260:	8f74221c 	.word	0x8f74221c

8f610264 <board_hardware_id>:
	return board.baseband;
}

uint32_t board_hardware_id()
{
	return board.platform_hw;
8f610264:	e3013320 	movw	r3, #4896	; 0x1320
8f610268:	e3483f71 	movt	r3, #36721	; 0x8f71
{
8f61026c:	e59f2038 	ldr	r2, [pc, #56]	; 8f6102ac <board_hardware_id+0x48>
8f610270:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f610274:	e24dd00c 	sub	r13, r13, #12
	return board.platform_hw;
8f610278:	e5930010 	ldr	r0, [r3, #16]
{
8f61027c:	e5922000 	ldr	r2, [r2]
8f610280:	e58d2004 	str	r2, [r13, #4]
8f610284:	e3a02000 	mov	r2, #0
}
8f610288:	e59f301c 	ldr	r3, [pc, #28]	; 8f6102ac <board_hardware_id+0x48>
8f61028c:	e5932000 	ldr	r2, [r3]
8f610290:	e59d3004 	ldr	r3, [r13, #4]
8f610294:	e0332002 	eors	r2, r3, r2
8f610298:	e3a03000 	mov	r3, #0
8f61029c:	1a000001 	bne	8f6102a8 <board_hardware_id+0x44>
8f6102a0:	e28dd00c 	add	r13, r13, #12
8f6102a4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6102a8:	eb008a44 	bl	8f632bc0 <__stack_chk_fail>
8f6102ac:	8f74221c 	.word	0x8f74221c

8f6102b0 <board_hardware_subtype>:

uint32_t board_hardware_subtype(void)
{
	return board.platform_subtype;
8f6102b0:	e3013320 	movw	r3, #4896	; 0x1320
8f6102b4:	e3483f71 	movt	r3, #36721	; 0x8f71
{
8f6102b8:	e59f2038 	ldr	r2, [pc, #56]	; 8f6102f8 <board_hardware_subtype+0x48>
8f6102bc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6102c0:	e24dd00c 	sub	r13, r13, #12
	return board.platform_subtype;
8f6102c4:	e5930014 	ldr	r0, [r3, #20]
{
8f6102c8:	e5922000 	ldr	r2, [r2]
8f6102cc:	e58d2004 	str	r2, [r13, #4]
8f6102d0:	e3a02000 	mov	r2, #0
}
8f6102d4:	e59f301c 	ldr	r3, [pc, #28]	; 8f6102f8 <board_hardware_subtype+0x48>
8f6102d8:	e5932000 	ldr	r2, [r3]
8f6102dc:	e59d3004 	ldr	r3, [r13, #4]
8f6102e0:	e0332002 	eors	r2, r3, r2
8f6102e4:	e3a03000 	mov	r3, #0
8f6102e8:	1a000001 	bne	8f6102f4 <board_hardware_subtype+0x44>
8f6102ec:	e28dd00c 	add	r13, r13, #12
8f6102f0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6102f4:	eb008a31 	bl	8f632bc0 <__stack_chk_fail>
8f6102f8:	8f74221c 	.word	0x8f74221c

8f6102fc <board_foundry_id>:

uint32_t board_foundry_id(void)
{
	return board.foundry_id;
8f6102fc:	e3013320 	movw	r3, #4896	; 0x1320
8f610300:	e3483f71 	movt	r3, #36721	; 0x8f71
{
8f610304:	e59f2038 	ldr	r2, [pc, #56]	; 8f610344 <board_foundry_id+0x48>
8f610308:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61030c:	e24dd00c 	sub	r13, r13, #12
	return board.foundry_id;
8f610310:	e5930004 	ldr	r0, [r3, #4]
{
8f610314:	e5922000 	ldr	r2, [r2]
8f610318:	e58d2004 	str	r2, [r13, #4]
8f61031c:	e3a02000 	mov	r2, #0
}
8f610320:	e59f301c 	ldr	r3, [pc, #28]	; 8f610344 <board_foundry_id+0x48>
8f610324:	e5932000 	ldr	r2, [r3]
8f610328:	e59d3004 	ldr	r3, [r13, #4]
8f61032c:	e0332002 	eors	r2, r3, r2
8f610330:	e3a03000 	mov	r3, #0
8f610334:	1a000001 	bne	8f610340 <board_foundry_id+0x44>
8f610338:	e28dd00c 	add	r13, r13, #12
8f61033c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f610340:	eb008a1e 	bl	8f632bc0 <__stack_chk_fail>
8f610344:	8f74221c 	.word	0x8f74221c

8f610348 <board_pmic_target>:
	}
}

uint32_t board_pmic_target(uint8_t num_ent)
{
	if (format_major == 0x0 && num_ent < SMEM_MAX_PMIC_DEVICES)
8f610348:	e30c3d78 	movw	r3, #52600	; 0xcd78
8f61034c:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f610350:	e59f20b8 	ldr	r2, [pc, #184]	; 8f610410 <board_pmic_target+0xc8>
	if (format_major == 0x0 && num_ent < SMEM_MAX_PMIC_DEVICES)
8f610354:	e1d330b0 	ldrh	r3, [r3]
{
8f610358:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	if (format_major == 0x0 && num_ent < SMEM_MAX_PMIC_DEVICES)
8f61035c:	e3500003 	cmp	r0, #3
8f610360:	93530000 	cmpls	r3, #0
{
8f610364:	e24dd00c 	sub	r13, r13, #12
8f610368:	e5922000 	ldr	r2, [r2]
8f61036c:	e58d2004 	str	r2, [r13, #4]
8f610370:	e3a02000 	mov	r2, #0
8f610374:	e1a02000 	mov	r2, r0
	if (format_major == 0x0 && num_ent < SMEM_MAX_PMIC_DEVICES)
8f610378:	03a00001 	moveq	r0, #1
8f61037c:	13a00000 	movne	r0, #0
8f610380:	0a000007 	beq	8f6103a4 <board_pmic_target+0x5c>
			if (num_ent < board.num_pmics)
				return  board.pmic_info_array[num_ent].pmic_target;
		}
	}
	return 0;
}
8f610384:	e59f3084 	ldr	r3, [pc, #132]	; 8f610410 <board_pmic_target+0xc8>
8f610388:	e5932000 	ldr	r2, [r3]
8f61038c:	e59d3004 	ldr	r3, [r13, #4]
8f610390:	e0332002 	eors	r2, r3, r2
8f610394:	e3a03000 	mov	r3, #0
8f610398:	1a00001b 	bne	8f61040c <board_pmic_target+0xc4>
8f61039c:	e28dd00c 	add	r13, r13, #12
8f6103a0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		if (format_minor < 0xB && num_ent < SMEM_V8_SMEM_MAX_PMIC_DEVICES)
8f6103a4:	e30c3d7a 	movw	r3, #52602	; 0xcd7a
8f6103a8:	e3483f72 	movt	r3, #36722	; 0x8f72
8f6103ac:	e1d330b0 	ldrh	r3, [r3]
8f6103b0:	e353000a 	cmp	r3, #10
8f6103b4:	83a03000 	movhi	r3, #0
8f6103b8:	93a03001 	movls	r3, #1
8f6103bc:	e3520003 	cmp	r2, #3
8f6103c0:	03a03000 	moveq	r3, #0
8f6103c4:	e3530000 	cmp	r3, #0
8f6103c8:	1a000009 	bne	8f6103f4 <board_pmic_target+0xac>
			if (num_ent < board.num_pmics)
8f6103cc:	e3011320 	movw	r1, #4896	; 0x1320
8f6103d0:	e3481f71 	movt	r1, #36721	; 0x8f71
8f6103d4:	e5910054 	ldr	r0, [r1, #84]	; 0x54
8f6103d8:	e1520000 	cmp	r2, r0
				return  board.pmic_info_array[num_ent].pmic_target;
8f6103dc:	30822082 	addcc	r2, r2, r2, lsl #1
8f6103e0:	3591305c 	ldrcc	r3, [r1, #92]	; 0x5c
	return 0;
8f6103e4:	21a00003 	movcs	r0, r3
				return  board.pmic_info_array[num_ent].pmic_target;
8f6103e8:	30832102 	addcc	r2, r3, r2, lsl #2
8f6103ec:	35920008 	ldrcc	r0, [r2, #8]
8f6103f0:	eaffffe3 	b	8f610384 <board_pmic_target+0x3c>
			return board.pmic_info[num_ent].pmic_target;
8f6103f4:	e3013320 	movw	r3, #4896	; 0x1320
8f6103f8:	e3483f71 	movt	r3, #36721	; 0x8f71
8f6103fc:	e3a0100c 	mov	r1, #12
8f610400:	e0233291 	mla	r3, r1, r2, r3
8f610404:	e5930028 	ldr	r0, [r3, #40]	; 0x28
8f610408:	eaffffdd 	b	8f610384 <board_pmic_target+0x3c>
}
8f61040c:	eb0089eb 	bl	8f632bc0 <__stack_chk_fail>
8f610410:	8f74221c 	.word	0x8f74221c

8f610414 <board_soc_version>:

uint32_t board_soc_version()
{
	return board.platform_version;
8f610414:	e3013320 	movw	r3, #4896	; 0x1320
8f610418:	e3483f71 	movt	r3, #36721	; 0x8f71
{
8f61041c:	e59f2038 	ldr	r2, [pc, #56]	; 8f61045c <board_soc_version+0x48>
8f610420:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f610424:	e24dd00c 	sub	r13, r13, #12
	return board.platform_version;
8f610428:	e593000c 	ldr	r0, [r3, #12]
{
8f61042c:	e5922000 	ldr	r2, [r2]
8f610430:	e58d2004 	str	r2, [r13, #4]
8f610434:	e3a02000 	mov	r2, #0
}
8f610438:	e59f301c 	ldr	r3, [pc, #28]	; 8f61045c <board_soc_version+0x48>
8f61043c:	e5932000 	ldr	r2, [r3]
8f610440:	e59d3004 	ldr	r3, [r13, #4]
8f610444:	e0332002 	eors	r2, r3, r2
8f610448:	e3a03000 	mov	r3, #0
8f61044c:	1a000001 	bne	8f610458 <board_soc_version+0x44>
8f610450:	e28dd00c 	add	r13, r13, #12
8f610454:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f610458:	eb0089d8 	bl	8f632bc0 <__stack_chk_fail>
8f61045c:	8f74221c 	.word	0x8f74221c

8f610460 <board_get_ddr_subtype>:

uint32_t board_get_ddr_subtype(void)
{
8f610460:	e59f30c8 	ldr	r3, [pc, #200]	; 8f610530 <board_get_ddr_subtype+0xd0>
8f610464:	e92d4070 	push	{r4, r5, r6, r14}
8f610468:	e24dd058 	sub	r13, r13, #88	; 0x58
8f61046c:	e5933000 	ldr	r3, [r3]
8f610470:	e58d3054 	str	r3, [r13, #84]	; 0x54
8f610474:	e3a03000 	mov	r3, #0
	uint32_t ret = 0;
	uint32_t len = 0;
	unsigned ddr_size = 0;

	/* Make sure RAM partition table is initialized */
	ASSERT(smem_ram_ptable_init_v1());
8f610478:	e1a0400e 	mov	r4, r14
8f61047c:	ebffca69 	bl	8f602e28 <smem_ram_ptable_init_v1>
8f610480:	e3500000 	cmp	r0, #0
8f610484:	0a00001d 	beq	8f610500 <board_get_ddr_subtype+0xa0>

	len = smem_get_ram_ptable_len();
8f610488:	ebffcac8 	bl	8f602fb0 <smem_get_ram_ptable_len>

	/* Calculating the size of the mem_info_ptr */
	for (index = 0 ; index < len; index++)
8f61048c:	e2505000 	subs	r5, r0, #0
8f610490:	0a000011 	beq	8f6104dc <board_get_ddr_subtype+0x7c>
	unsigned ddr_size = 0;
8f610494:	e3a06000 	mov	r6, #0
	for (index = 0 ; index < len; index++)
8f610498:	e1a04006 	mov	r4, r6
	{
		smem_get_ram_ptable_entry(&ptn_entry, index);
8f61049c:	e28d000c 	add	r0, r13, #12
8f6104a0:	e1a01004 	mov	r1, r4
8f6104a4:	ebffcaab 	bl	8f602f58 <smem_get_ram_ptable_entry>

		if((ptn_entry.category == SDRAM) &&
8f6104a8:	e59d3030 	ldr	r3, [r13, #48]	; 0x30
8f6104ac:	e353000e 	cmp	r3, #14
8f6104b0:	1a000003 	bne	8f6104c4 <board_get_ddr_subtype+0x64>
8f6104b4:	e59d3038 	ldr	r3, [r13, #56]	; 0x38
8f6104b8:	e3530001 	cmp	r3, #1
			(ptn_entry.type == SYS_MEMORY))
		{
			ddr_size += ptn_entry.size;
8f6104bc:	059d3024 	ldreq	r3, [r13, #36]	; 0x24
8f6104c0:	00866003 	addeq	r6, r6, r3
	for (index = 0 ; index < len; index++)
8f6104c4:	e2844001 	add	r4, r4, #1
8f6104c8:	e1550004 	cmp	r5, r4
8f6104cc:	1afffff2 	bne	8f61049c <board_get_ddr_subtype+0x3c>
		}
	}

	switch(ddr_size)
8f6104d0:	e2465202 	sub	r5, r6, #536870912	; 0x20000000
8f6104d4:	e16f5f15 	clz	r5, r5
8f6104d8:	e1a052a5 	lsr	r5, r5, #5
		ret = 0;
	break;
	};

	return ret;
}
8f6104dc:	e59f304c 	ldr	r3, [pc, #76]	; 8f610530 <board_get_ddr_subtype+0xd0>
8f6104e0:	e5932000 	ldr	r2, [r3]
8f6104e4:	e59d3054 	ldr	r3, [r13, #84]	; 0x54
8f6104e8:	e0332002 	eors	r2, r3, r2
8f6104ec:	e3a03000 	mov	r3, #0
8f6104f0:	1a00000d 	bne	8f61052c <board_get_ddr_subtype+0xcc>
8f6104f4:	e1a00005 	mov	r0, r5
8f6104f8:	e28dd058 	add	r13, r13, #88	; 0x58
8f6104fc:	e8bd8070 	pop	{r4, r5, r6, r15}
	ASSERT(smem_ram_ptable_init_v1());
8f610500:	e300c290 	movw	r12, #656	; 0x290
8f610504:	e3032ebc 	movw	r2, #16060	; 0x3ebc
8f610508:	e348cf70 	movt	r12, #36720	; 0x8f70
8f61050c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f610510:	e3001130 	movw	r1, #304	; 0x130
8f610514:	e3a03e1d 	mov	r3, #464	; 0x1d0
8f610518:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61051c:	e1a00004 	mov	r0, r4
8f610520:	e58dc000 	str	r12, [r13]
8f610524:	eb008964 	bl	8f632abc <_panic>
8f610528:	eaffffd6 	b	8f610488 <board_get_ddr_subtype+0x28>
}
8f61052c:	eb0089a3 	bl	8f632bc0 <__stack_chk_fail>
8f610530:	8f74221c 	.word	0x8f74221c

8f610534 <platform_detect>:
{
8f610534:	e59f0468 	ldr	r0, [pc, #1128]	; 8f6109a4 <platform_detect+0x470>
	unsigned format = 0;
8f610538:	e3a03000 	mov	r3, #0
{
8f61053c:	e92d4070 	push	{r4, r5, r6, r14}
8f610540:	e24ddf8e 	sub	r13, r13, #568	; 0x238
8f610544:	e5900000 	ldr	r0, [r0]
8f610548:	e58d0234 	str	r0, [r13, #564]	; 0x234
8f61054c:	e3a00000 	mov	r0, #0
	ret = smem_read_alloc_entry_offset(SMEM_BOARD_INFO_LOCATION,
8f610550:	e28d100c 	add	r1, r13, #12
8f610554:	e3a02004 	mov	r2, #4
8f610558:	e3a00089 	mov	r0, #137	; 0x89
8f61055c:	e1a0400e 	mov	r4, r14
	unsigned format = 0;
8f610560:	e58d300c 	str	r3, [r13, #12]
	ret = smem_read_alloc_entry_offset(SMEM_BOARD_INFO_LOCATION,
8f610564:	ebffc90a 	bl	8f602994 <smem_read_alloc_entry_offset>
	if (ret)
8f610568:	e3500000 	cmp	r0, #0
8f61056c:	1a00001f 	bne	8f6105f0 <platform_detect+0xbc>
	format_major = (format & 0xffff0000) >> 16;
8f610570:	e59d200c 	ldr	r2, [r13, #12]
8f610574:	e30c3d78 	movw	r3, #52600	; 0xcd78
	format_minor = format & 0x0000ffff;
8f610578:	e30ccd7a 	movw	r12, #52602	; 0xcd7a
	format_major = (format & 0xffff0000) >> 16;
8f61057c:	e3483f72 	movt	r3, #36722	; 0x8f72
	format_minor = format & 0x0000ffff;
8f610580:	e348cf72 	movt	r12, #36722	; 0x8f72
	format_major = (format & 0xffff0000) >> 16;
8f610584:	e1a01822 	lsr	r1, r2, #16
8f610588:	e1c310b0 	strh	r1, [r3]
	if (format_major == 0x0)
8f61058c:	e3510000 	cmp	r1, #0
	format_minor = format & 0x0000ffff;
8f610590:	e6ff3072 	uxth	r3, r2
8f610594:	e1cc30b0 	strh	r3, [r12]
	if (format_major == 0x0)
8f610598:	1a00001c 	bne	8f610610 <platform_detect+0xdc>
		if (format_minor == 6)
8f61059c:	e3530006 	cmp	r3, #6
8f6105a0:	0a000029 	beq	8f61064c <platform_detect+0x118>
		else if (format_minor == 7)
8f6105a4:	e3530007 	cmp	r3, #7
8f6105a8:	0a000036 	beq	8f610688 <platform_detect+0x154>
		else if (format_minor == 8)
8f6105ac:	e3530008 	cmp	r3, #8
8f6105b0:	0a000047 	beq	8f6106d4 <platform_detect+0x1a0>
		else if (format_minor == 0x9)
8f6105b4:	e3530009 	cmp	r3, #9
8f6105b8:	0a000074 	beq	8f610790 <platform_detect+0x25c>
		else if (format_minor == 0xA)
8f6105bc:	e353000a 	cmp	r3, #10
8f6105c0:	0a0000c4 	beq	8f6108d8 <platform_detect+0x3a4>
		else if (format_minor >= 0xB)
8f6105c4:	8a0000a2 	bhi	8f610854 <platform_detect+0x320>
8f6105c8:	e3015320 	movw	r5, #4896	; 0x1320
8f6105cc:	e3485f71 	movt	r5, #36721	; 0x8f71
		board.platform_hlos_subtype = (board_get_ddr_subtype() << 8) | (platform_get_boot_dev() << 16) | (platform_detect_panel() << 11);
8f6105d0:	ebffffa2 	bl	8f610460 <board_get_ddr_subtype>
8f6105d4:	e1a06000 	mov	r6, r0
8f6105d8:	eb0044d3 	bl	8f62192c <platform_get_boot_dev>
8f6105dc:	e1a04800 	lsl	r4, r0, #16
8f6105e0:	eb0044e2 	bl	8f621970 <platform_detect_panel>
8f6105e4:	e1844406 	orr	r4, r4, r6, lsl #8
8f6105e8:	e1844580 	orr	r4, r4, r0, lsl #11
8f6105ec:	e5854050 	str	r4, [r5, #80]	; 0x50
}
8f6105f0:	e59f33ac 	ldr	r3, [pc, #940]	; 8f6109a4 <platform_detect+0x470>
8f6105f4:	e5932000 	ldr	r2, [r3]
8f6105f8:	e59d3234 	ldr	r3, [r13, #564]	; 0x234
8f6105fc:	e0332002 	eors	r2, r3, r2
8f610600:	e3a03000 	mov	r3, #0
8f610604:	1a0000e5 	bne	8f6109a0 <platform_detect+0x46c>
8f610608:	e28ddf8e 	add	r13, r13, #568	; 0x238
8f61060c:	e8bd8070 	pop	{r4, r5, r6, r15}
		dprintf(CRITICAL, "Unsupported board info format %u.%u\n", format_major, format_minor);
8f610610:	e6ff2072 	uxth	r2, r2
8f610614:	e3030f24 	movw	r0, #16164	; 0x3f24
8f610618:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61061c:	eb0088d4 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f610620:	e307cf64 	movw	r12, #32612	; 0x7f64
8f610624:	e3032ebc 	movw	r2, #16060	; 0x3ebc
8f610628:	e348cf70 	movt	r12, #36720	; 0x8f70
8f61062c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f610630:	e3001130 	movw	r1, #304	; 0x130
8f610634:	e300311e 	movw	r3, #286	; 0x11e
8f610638:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61063c:	e1a00004 	mov	r0, r4
8f610640:	e58dc000 	str	r12, [r13]
8f610644:	eb00891c 	bl	8f632abc <_panic>
8f610648:	eaffffe8 	b	8f6105f0 <platform_detect+0xbc>
			ret = smem_read_alloc_entry(SMEM_BOARD_INFO_LOCATION,
8f61064c:	e28d1010 	add	r1, r13, #16
8f610650:	e3a02048 	mov	r2, #72	; 0x48
8f610654:	e3a00089 	mov	r0, #137	; 0x89
8f610658:	ebffc870 	bl	8f602820 <smem_read_alloc_entry>
			if (ret)
8f61065c:	e3500000 	cmp	r0, #0
8f610660:	1affffe2 	bne	8f6105f0 <platform_detect+0xbc>
			board.platform_version = board_info_v6.board_info_v3.msm_version;
8f610664:	e1cd01d4 	ldrd	r0, [r13, #20]
			board.platform = board_info_v6.board_info_v3.msm_id;
8f610668:	e3015320 	movw	r5, #4896	; 0x1320
			board.platform_hw = board_info_v6.board_info_v3.hw_platform;
8f61066c:	e59d2044 	ldr	r2, [r13, #68]	; 0x44
			board.platform = board_info_v6.board_info_v3.msm_id;
8f610670:	e3485f71 	movt	r5, #36721	; 0x8f71
			board.platform_subtype = board_info_v6.platform_subtype;
8f610674:	e59d3050 	ldr	r3, [r13, #80]	; 0x50
			board.platform = board_info_v6.board_info_v3.msm_id;
8f610678:	e5850000 	str	r0, [r5]
			board.platform_version = board_info_v6.board_info_v3.msm_version;
8f61067c:	e585100c 	str	r1, [r5, #12]
			board.platform_subtype = board_info_v6.platform_subtype;
8f610680:	e1c521f0 	strd	r2, [r5, #16]
8f610684:	eaffffd1 	b	8f6105d0 <platform_detect+0x9c>
			ret = smem_read_alloc_entry(SMEM_BOARD_INFO_LOCATION,
8f610688:	e28d1058 	add	r1, r13, #88	; 0x58
8f61068c:	e3a02050 	mov	r2, #80	; 0x50
8f610690:	e3a00089 	mov	r0, #137	; 0x89
8f610694:	ebffc861 	bl	8f602820 <smem_read_alloc_entry>
			if (ret)
8f610698:	e3500000 	cmp	r0, #0
8f61069c:	1affffd3 	bne	8f6105f0 <platform_detect+0xbc>
			board.platform_version = board_info_v7.board_info_v3.msm_version;
8f6106a0:	e59d3060 	ldr	r3, [r13, #96]	; 0x60
			board.platform = board_info_v7.board_info_v3.msm_id;
8f6106a4:	e3015320 	movw	r5, #4896	; 0x1320
8f6106a8:	e3485f71 	movt	r5, #36721	; 0x8f71
8f6106ac:	e59dc05c 	ldr	r12, [r13, #92]	; 0x5c
			board.platform_hw = board_info_v7.board_info_v3.hw_platform;
8f6106b0:	e59d008c 	ldr	r0, [r13, #140]	; 0x8c
			board.platform_subtype = board_info_v7.platform_subtype;
8f6106b4:	e59d1098 	ldr	r1, [r13, #152]	; 0x98
			board.pmic_info[0].pmic_type = board_info_v7.pmic_type;
8f6106b8:	e59d209c 	ldr	r2, [r13, #156]	; 0x9c
			board.platform_version = board_info_v7.board_info_v3.msm_version;
8f6106bc:	e585300c 	str	r3, [r5, #12]
			board.pmic_info[0].pmic_version = board_info_v7.pmic_version;
8f6106c0:	e59d30a0 	ldr	r3, [r13, #160]	; 0xa0
			board.platform = board_info_v7.board_info_v3.msm_id;
8f6106c4:	e585c000 	str	r12, [r5]
			board.platform_subtype = board_info_v7.platform_subtype;
8f6106c8:	e1c501f0 	strd	r0, [r5, #16]
			board.pmic_info[0].pmic_version = board_info_v7.pmic_version;
8f6106cc:	e1c522f0 	strd	r2, [r5, #32]
8f6106d0:	eaffffbe 	b	8f6105d0 <platform_detect+0x9c>
			ret = smem_read_alloc_entry(SMEM_BOARD_INFO_LOCATION,
8f6106d4:	e28d10a8 	add	r1, r13, #168	; 0xa8
8f6106d8:	e3a0205c 	mov	r2, #92	; 0x5c
8f6106dc:	e3a00089 	mov	r0, #137	; 0x89
8f6106e0:	ebffc84e 	bl	8f602820 <smem_read_alloc_entry>
			if (ret)
8f6106e4:	e3500000 	cmp	r0, #0
8f6106e8:	1affffc0 	bne	8f6105f0 <platform_detect+0xbc>
			board.platform_hw = board_info_v8.board_info_v3.hw_platform;
8f6106ec:	e59d20dc 	ldr	r2, [r13, #220]	; 0xdc
			board.platform = board_info_v8.board_info_v3.msm_id;
8f6106f0:	e3013320 	movw	r3, #4896	; 0x1320
8f6106f4:	e3483f71 	movt	r3, #36721	; 0x8f71
						   (((board_info_v8.platform_version >> 16) & 0xff) << 16) |
8f6106f8:	e59d10e0 	ldr	r1, [r13, #224]	; 0xe0
			board.platform_subtype = board_info_v8.platform_subtype;
8f6106fc:	e59de0e8 	ldr	r14, [r13, #232]	; 0xe8
8f610700:	e28d00a8 	add	r0, r13, #168	; 0xa8
						   (board_info_v8.board_info_v3.hw_platform & 0xff));
8f610704:	e6efc072 	uxtb	r12, r2
			board.platform_hw = board_info_v8.board_info_v3.hw_platform;
8f610708:	e5832010 	str	r2, [r3, #16]
			board.platform = board_info_v8.board_info_v3.msm_id;
8f61070c:	e59d20ac 	ldr	r2, [r13, #172]	; 0xac
8f610710:	e1a05003 	mov	r5, r3
			board.platform_subtype = board_info_v8.platform_subtype;
8f610714:	e583e014 	str	r14, [r3, #20]
			board.platform = board_info_v8.board_info_v3.msm_id;
8f610718:	e5832000 	str	r2, [r3]
			board.platform_version = board_info_v8.board_info_v3.msm_version;
8f61071c:	e59d20b0 	ldr	r2, [r13, #176]	; 0xb0
8f610720:	e583200c 	str	r2, [r3, #12]
						   (((board_info_v8.platform_version >> 16) & 0xff) << 16) |
8f610724:	e20128ff 	and	r2, r1, #16711680	; 0xff0000
						   ((board_info_v8.platform_version & 0xff) << 8) |
8f610728:	e1a01401 	lsl	r1, r1, #8
8f61072c:	e1822c0e 	orr	r2, r2, r14, lsl #24
8f610730:	e182200c 	orr	r2, r2, r12
8f610734:	e283e024 	add	r14, r3, #36	; 0x24
8f610738:	e6ff1071 	uxth	r1, r1
8f61073c:	e1822001 	orr	r2, r2, r1
			board.target = (((board_info_v8.platform_subtype & 0xff) << 24) |
8f610740:	e5832018 	str	r2, [r3, #24]
			for (i = 0; i < SMEM_V8_SMEM_MAX_PMIC_DEVICES; i++) {
8f610744:	e1a02003 	mov	r2, r3
				board.pmic_info[i].pmic_type = board_info_v8.pmic_info[i].pmic_type;
8f610748:	e5903044 	ldr	r3, [r0, #68]	; 0x44
			for (i = 0; i < SMEM_V8_SMEM_MAX_PMIC_DEVICES; i++) {
8f61074c:	e282200c 	add	r2, r2, #12
				board.pmic_info[i].pmic_version = board_info_v8.pmic_info[i].pmic_version;
8f610750:	e5901048 	ldr	r1, [r0, #72]	; 0x48
			for (i = 0; i < SMEM_V8_SMEM_MAX_PMIC_DEVICES; i++) {
8f610754:	e2800008 	add	r0, r0, #8
				pmic_type = board_info_v8.pmic_info[i].pmic_type == PMIC_IS_INVALID? 0 : board_info_v8.pmic_info[i].pmic_type;
8f610758:	e3730106 	cmn	r3, #-2147483647	; 0x80000001
					   ((board_info_v8.pmic_info[i].pmic_version & 0xff) << 8) | (pmic_type & 0xff);
8f61075c:	16efc073 	uxtbne	r12, r3
				board.pmic_info[i].pmic_type = board_info_v8.pmic_info[i].pmic_type;
8f610760:	e5823014 	str	r3, [r2, #20]
					   ((board_info_v8.pmic_info[i].pmic_version & 0xff) << 8) | (pmic_type & 0xff);
8f610764:	e1a03401 	lsl	r3, r1, #8
				board.pmic_info[i].pmic_version = board_info_v8.pmic_info[i].pmic_version;
8f610768:	e5821018 	str	r1, [r2, #24]
				board.pmic_info[i].pmic_target = (((board_info_v8.pmic_info[i].pmic_version >> 16) & 0xff) << 16) |
8f61076c:	e20118ff 	and	r1, r1, #16711680	; 0xff0000
8f610770:	03a0c000 	moveq	r12, #0
					   ((board_info_v8.pmic_info[i].pmic_version & 0xff) << 8) | (pmic_type & 0xff);
8f610774:	e6ff3073 	uxth	r3, r3
				board.pmic_info[i].pmic_target = (((board_info_v8.pmic_info[i].pmic_version >> 16) & 0xff) << 16) |
8f610778:	e1833001 	orr	r3, r3, r1
					   ((board_info_v8.pmic_info[i].pmic_version & 0xff) << 8) | (pmic_type & 0xff);
8f61077c:	e183300c 	orr	r3, r3, r12
				board.pmic_info[i].pmic_target = (((board_info_v8.pmic_info[i].pmic_version >> 16) & 0xff) << 16) |
8f610780:	e582301c 	str	r3, [r2, #28]
			for (i = 0; i < SMEM_V8_SMEM_MAX_PMIC_DEVICES; i++) {
8f610784:	e15e0002 	cmp	r14, r2
8f610788:	1affffee 	bne	8f610748 <platform_detect+0x214>
8f61078c:	eaffff8f 	b	8f6105d0 <platform_detect+0x9c>
			ret = smem_read_alloc_entry(SMEM_BOARD_INFO_LOCATION,
8f610790:	e28d1f41 	add	r1, r13, #260	; 0x104
8f610794:	e3a02060 	mov	r2, #96	; 0x60
8f610798:	e3a00089 	mov	r0, #137	; 0x89
8f61079c:	ebffc81f 	bl	8f602820 <smem_read_alloc_entry>
			if (ret)
8f6107a0:	e3500000 	cmp	r0, #0
8f6107a4:	1affff91 	bne	8f6105f0 <platform_detect+0xbc>
			board.platform_hw = board_info_v9.board_info_v3.hw_platform;
8f6107a8:	e59d2138 	ldr	r2, [r13, #312]	; 0x138
			board.platform = board_info_v9.board_info_v3.msm_id;
8f6107ac:	e3013320 	movw	r3, #4896	; 0x1320
8f6107b0:	e3483f71 	movt	r3, #36721	; 0x8f71
						   (((board_info_v9.platform_version >> 16) & 0xff) << 16) |
8f6107b4:	e59d113c 	ldr	r1, [r13, #316]	; 0x13c
			board.platform_subtype = board_info_v9.platform_subtype;
8f6107b8:	e59de144 	ldr	r14, [r13, #324]	; 0x144
8f6107bc:	e28d0f41 	add	r0, r13, #260	; 0x104
						   (board_info_v9.board_info_v3.hw_platform & 0xff));
8f6107c0:	e6efc072 	uxtb	r12, r2
			board.platform_hw = board_info_v9.board_info_v3.hw_platform;
8f6107c4:	e5832010 	str	r2, [r3, #16]
			board.platform = board_info_v9.board_info_v3.msm_id;
8f6107c8:	e59d2108 	ldr	r2, [r13, #264]	; 0x108
8f6107cc:	e1a05003 	mov	r5, r3
			board.platform_subtype = board_info_v9.platform_subtype;
8f6107d0:	e583e014 	str	r14, [r3, #20]
			board.platform = board_info_v9.board_info_v3.msm_id;
8f6107d4:	e5832000 	str	r2, [r3]
			board.platform_version = board_info_v9.board_info_v3.msm_version;
8f6107d8:	e59d210c 	ldr	r2, [r13, #268]	; 0x10c
8f6107dc:	e583200c 	str	r2, [r3, #12]
						   (((board_info_v9.platform_version >> 16) & 0xff) << 16) |
8f6107e0:	e20128ff 	and	r2, r1, #16711680	; 0xff0000
						   ((board_info_v9.platform_version & 0xff) << 8) |
8f6107e4:	e1a01401 	lsl	r1, r1, #8
8f6107e8:	e1822c0e 	orr	r2, r2, r14, lsl #24
8f6107ec:	e182200c 	orr	r2, r2, r12
8f6107f0:	e283e024 	add	r14, r3, #36	; 0x24
8f6107f4:	e6ff1071 	uxth	r1, r1
8f6107f8:	e1822001 	orr	r2, r2, r1
			board.target = (((board_info_v9.platform_subtype & 0xff) << 24) |
8f6107fc:	e5832018 	str	r2, [r3, #24]
			for (i = 0; i < SMEM_V8_SMEM_MAX_PMIC_DEVICES; i++) {
8f610800:	e1a02003 	mov	r2, r3
				board.pmic_info[i].pmic_type = board_info_v9.pmic_info[i].pmic_type;
8f610804:	e5903044 	ldr	r3, [r0, #68]	; 0x44
			for (i = 0; i < SMEM_V8_SMEM_MAX_PMIC_DEVICES; i++) {
8f610808:	e282200c 	add	r2, r2, #12
				board.pmic_info[i].pmic_version = board_info_v9.pmic_info[i].pmic_version;
8f61080c:	e5901048 	ldr	r1, [r0, #72]	; 0x48
			for (i = 0; i < SMEM_V8_SMEM_MAX_PMIC_DEVICES; i++) {
8f610810:	e2800008 	add	r0, r0, #8
				pmic_type = board_info_v9.pmic_info[i].pmic_type == PMIC_IS_INVALID? 0 : board_info_v9.pmic_info[i].pmic_type;
8f610814:	e3730106 	cmn	r3, #-2147483647	; 0x80000001
					   ((board_info_v9.pmic_info[i].pmic_version & 0xff) << 8) | (pmic_type & 0xff);
8f610818:	16efc073 	uxtbne	r12, r3
				board.pmic_info[i].pmic_type = board_info_v9.pmic_info[i].pmic_type;
8f61081c:	e5823014 	str	r3, [r2, #20]
					   ((board_info_v9.pmic_info[i].pmic_version & 0xff) << 8) | (pmic_type & 0xff);
8f610820:	e1a03401 	lsl	r3, r1, #8
				board.pmic_info[i].pmic_version = board_info_v9.pmic_info[i].pmic_version;
8f610824:	e5821018 	str	r1, [r2, #24]
				board.pmic_info[i].pmic_target = (((board_info_v9.pmic_info[i].pmic_version >> 16) & 0xff) << 16) |
8f610828:	e20118ff 	and	r1, r1, #16711680	; 0xff0000
8f61082c:	03a0c000 	moveq	r12, #0
					   ((board_info_v9.pmic_info[i].pmic_version & 0xff) << 8) | (pmic_type & 0xff);
8f610830:	e6ff3073 	uxth	r3, r3
				board.pmic_info[i].pmic_target = (((board_info_v9.pmic_info[i].pmic_version >> 16) & 0xff) << 16) |
8f610834:	e1833001 	orr	r3, r3, r1
					   ((board_info_v9.pmic_info[i].pmic_version & 0xff) << 8) | (pmic_type & 0xff);
8f610838:	e183300c 	orr	r3, r3, r12
				board.pmic_info[i].pmic_target = (((board_info_v9.pmic_info[i].pmic_version >> 16) & 0xff) << 16) |
8f61083c:	e582301c 	str	r3, [r2, #28]
			for (i = 0; i < SMEM_V8_SMEM_MAX_PMIC_DEVICES; i++) {
8f610840:	e15e0002 	cmp	r14, r2
8f610844:	1affffee 	bne	8f610804 <platform_detect+0x2d0>
			board.foundry_id = board_info_v9.foundry_id;
8f610848:	e59d3160 	ldr	r3, [r13, #352]	; 0x160
8f61084c:	e5853004 	str	r3, [r5, #4]
8f610850:	eaffff5e 	b	8f6105d0 <platform_detect+0x9c>
			ret = smem_read_alloc_entry(SMEM_BOARD_INFO_LOCATION,
8f610854:	e28d1f72 	add	r1, r13, #456	; 0x1c8
8f610858:	e3a0206c 	mov	r2, #108	; 0x6c
8f61085c:	e3a00089 	mov	r0, #137	; 0x89
8f610860:	ebffc7ee 	bl	8f602820 <smem_read_alloc_entry>
			if (ret)
8f610864:	e3500000 	cmp	r0, #0
8f610868:	1affff60 	bne	8f6105f0 <platform_detect+0xbc>
						   (((board_info_v11.platform_version >> 16) & 0xff) << 16) |
8f61086c:	e59d2200 	ldr	r2, [r13, #512]	; 0x200
			board.platform = board_info_v11.board_info_v3.msm_id;
8f610870:	e3015320 	movw	r5, #4896	; 0x1320
			board.platform_version = board_info_v11.board_info_v3.msm_version;
8f610874:	e59d31d0 	ldr	r3, [r13, #464]	; 0x1d0
			board.platform = board_info_v11.board_info_v3.msm_id;
8f610878:	e3485f71 	movt	r5, #36721	; 0x8f71
			board.platform_hw = board_info_v11.board_info_v3.hw_platform;
8f61087c:	e59d11fc 	ldr	r1, [r13, #508]	; 0x1fc
			board.platform_subtype = board_info_v11.platform_subtype;
8f610880:	e59d0208 	ldr	r0, [r13, #520]	; 0x208
			board.platform = board_info_v11.board_info_v3.msm_id;
8f610884:	e59dc1cc 	ldr	r12, [r13, #460]	; 0x1cc
			board.platform_version = board_info_v11.board_info_v3.msm_version;
8f610888:	e585300c 	str	r3, [r5, #12]
						   (((board_info_v11.platform_version >> 16) & 0xff) << 16) |
8f61088c:	e20238ff 	and	r3, r2, #16711680	; 0xff0000
						   ((board_info_v11.platform_version & 0xff) << 8) |
8f610890:	e1a02402 	lsl	r2, r2, #8
8f610894:	e1833c00 	orr	r3, r3, r0, lsl #24
			board.platform_hw = board_info_v11.board_info_v3.hw_platform;
8f610898:	e5851010 	str	r1, [r5, #16]
						   (board_info_v11.board_info_v3.hw_platform & 0xff));
8f61089c:	e6ef1071 	uxtb	r1, r1
						   ((board_info_v11.platform_version & 0xff) << 8) |
8f6108a0:	e1833001 	orr	r3, r3, r1
8f6108a4:	e6ff2072 	uxth	r2, r2
8f6108a8:	e1833002 	orr	r3, r3, r2
			board.chip_serial = board_info_v11.chip_serial;
8f6108ac:	e59d1228 	ldr	r1, [r13, #552]	; 0x228
			board.num_pmics = board_info_v11.num_pmics;
8f6108b0:	e59d222c 	ldr	r2, [r13, #556]	; 0x22c
			board.platform = board_info_v11.board_info_v3.msm_id;
8f6108b4:	e585c000 	str	r12, [r5]
			board.target = (((board_info_v11.platform_subtype & 0xff) << 24) |
8f6108b8:	e5853018 	str	r3, [r5, #24]
			board.foundry_id = board_info_v11.foundry_id;
8f6108bc:	e59dc224 	ldr	r12, [r13, #548]	; 0x224
			board.pmic_array_offset = board_info_v11.pmic_array_offset;
8f6108c0:	e59d3230 	ldr	r3, [r13, #560]	; 0x230
			board.platform_subtype = board_info_v11.platform_subtype;
8f6108c4:	e5850014 	str	r0, [r5, #20]
			board.foundry_id = board_info_v11.foundry_id;
8f6108c8:	e585c004 	str	r12, [r5, #4]
			board.chip_serial = board_info_v11.chip_serial;
8f6108cc:	e5851008 	str	r1, [r5, #8]
			board.pmic_array_offset = board_info_v11.pmic_array_offset;
8f6108d0:	e1c525f4 	strd	r2, [r5, #84]	; 0x54
8f6108d4:	eaffff3d 	b	8f6105d0 <platform_detect+0x9c>
			ret = smem_read_alloc_entry(SMEM_BOARD_INFO_LOCATION,
8f6108d8:	e28d1f59 	add	r1, r13, #356	; 0x164
8f6108dc:	e3a02064 	mov	r2, #100	; 0x64
8f6108e0:	e3a00089 	mov	r0, #137	; 0x89
8f6108e4:	ebffc7cd 	bl	8f602820 <smem_read_alloc_entry>
			if (ret)
8f6108e8:	e3500000 	cmp	r0, #0
8f6108ec:	1affff3f 	bne	8f6105f0 <platform_detect+0xbc>
			board.platform_hw = board_info_v10.board_info_v3.hw_platform;
8f6108f0:	e59d2198 	ldr	r2, [r13, #408]	; 0x198
			board.platform = board_info_v10.board_info_v3.msm_id;
8f6108f4:	e3013320 	movw	r3, #4896	; 0x1320
8f6108f8:	e3483f71 	movt	r3, #36721	; 0x8f71
						   (((board_info_v10.platform_version >> 16) & 0xff) << 16) |
8f6108fc:	e59d119c 	ldr	r1, [r13, #412]	; 0x19c
			board.platform_subtype = board_info_v10.platform_subtype;
8f610900:	e59de1a4 	ldr	r14, [r13, #420]	; 0x1a4
8f610904:	e28d0f59 	add	r0, r13, #356	; 0x164
						   (board_info_v10.board_info_v3.hw_platform & 0xff));
8f610908:	e6efc072 	uxtb	r12, r2
			board.platform_hw = board_info_v10.board_info_v3.hw_platform;
8f61090c:	e5832010 	str	r2, [r3, #16]
			board.platform = board_info_v10.board_info_v3.msm_id;
8f610910:	e59d2168 	ldr	r2, [r13, #360]	; 0x168
8f610914:	e1a05003 	mov	r5, r3
			board.platform_subtype = board_info_v10.platform_subtype;
8f610918:	e583e014 	str	r14, [r3, #20]
			board.platform = board_info_v10.board_info_v3.msm_id;
8f61091c:	e5832000 	str	r2, [r3]
			board.platform_version = board_info_v10.board_info_v3.msm_version;
8f610920:	e59d216c 	ldr	r2, [r13, #364]	; 0x16c
8f610924:	e583200c 	str	r2, [r3, #12]
						   (((board_info_v10.platform_version >> 16) & 0xff) << 16) |
8f610928:	e20128ff 	and	r2, r1, #16711680	; 0xff0000
						   ((board_info_v10.platform_version & 0xff) << 8) |
8f61092c:	e1a01401 	lsl	r1, r1, #8
8f610930:	e1822c0e 	orr	r2, r2, r14, lsl #24
8f610934:	e182200c 	orr	r2, r2, r12
8f610938:	e283e024 	add	r14, r3, #36	; 0x24
8f61093c:	e6ff1071 	uxth	r1, r1
8f610940:	e1822001 	orr	r2, r2, r1
			board.target = (((board_info_v10.platform_subtype & 0xff) << 24) |
8f610944:	e5832018 	str	r2, [r3, #24]
			for (i = 0; i < SMEM_V8_SMEM_MAX_PMIC_DEVICES; i++) {
8f610948:	e1a02003 	mov	r2, r3
				board.pmic_info[i].pmic_type = board_info_v10.pmic_info[i].pmic_type;
8f61094c:	e5903044 	ldr	r3, [r0, #68]	; 0x44
			for (i = 0; i < SMEM_V8_SMEM_MAX_PMIC_DEVICES; i++) {
8f610950:	e282200c 	add	r2, r2, #12
				board.pmic_info[i].pmic_version = board_info_v10.pmic_info[i].pmic_version;
8f610954:	e5901048 	ldr	r1, [r0, #72]	; 0x48
			for (i = 0; i < SMEM_V8_SMEM_MAX_PMIC_DEVICES; i++) {
8f610958:	e2800008 	add	r0, r0, #8
				pmic_type = board_info_v10.pmic_info[i].pmic_type == PMIC_IS_INVALID? 0 : board_info_v10.pmic_info[i].pmic_type;
8f61095c:	e3730106 	cmn	r3, #-2147483647	; 0x80000001
					   ((board_info_v10.pmic_info[i].pmic_version & 0xff) << 8) | (pmic_type & 0xff);
8f610960:	16efc073 	uxtbne	r12, r3
				board.pmic_info[i].pmic_type = board_info_v10.pmic_info[i].pmic_type;
8f610964:	e5823014 	str	r3, [r2, #20]
					   ((board_info_v10.pmic_info[i].pmic_version & 0xff) << 8) | (pmic_type & 0xff);
8f610968:	e1a03401 	lsl	r3, r1, #8
				board.pmic_info[i].pmic_version = board_info_v10.pmic_info[i].pmic_version;
8f61096c:	e5821018 	str	r1, [r2, #24]
				board.pmic_info[i].pmic_target = (((board_info_v10.pmic_info[i].pmic_version >> 16) & 0xff) << 16) |
8f610970:	e20118ff 	and	r1, r1, #16711680	; 0xff0000
8f610974:	03a0c000 	moveq	r12, #0
					   ((board_info_v10.pmic_info[i].pmic_version & 0xff) << 8) | (pmic_type & 0xff);
8f610978:	e6ff3073 	uxth	r3, r3
				board.pmic_info[i].pmic_target = (((board_info_v10.pmic_info[i].pmic_version >> 16) & 0xff) << 16) |
8f61097c:	e1833001 	orr	r3, r3, r1
					   ((board_info_v10.pmic_info[i].pmic_version & 0xff) << 8) | (pmic_type & 0xff);
8f610980:	e183300c 	orr	r3, r3, r12
				board.pmic_info[i].pmic_target = (((board_info_v10.pmic_info[i].pmic_version >> 16) & 0xff) << 16) |
8f610984:	e582301c 	str	r3, [r2, #28]
			for (i = 0; i < SMEM_V8_SMEM_MAX_PMIC_DEVICES; i++) {
8f610988:	e152000e 	cmp	r2, r14
8f61098c:	1affffee 	bne	8f61094c <platform_detect+0x418>
			board.foundry_id = board_info_v10.foundry_id;
8f610990:	e59d21c0 	ldr	r2, [r13, #448]	; 0x1c0
			board.chip_serial = board_info_v10.chip_serial;
8f610994:	e59d31c4 	ldr	r3, [r13, #452]	; 0x1c4
8f610998:	e1c520f4 	strd	r2, [r5, #4]
8f61099c:	eaffff0b 	b	8f6105d0 <platform_detect+0x9c>
}
8f6109a0:	eb008886 	bl	8f632bc0 <__stack_chk_fail>
8f6109a4:	8f74221c 	.word	0x8f74221c

8f6109a8 <board_init>:
{
8f6109a8:	e59f3050 	ldr	r3, [pc, #80]	; 8f610a00 <board_init+0x58>
8f6109ac:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6109b0:	e24dd00c 	sub	r13, r13, #12
8f6109b4:	e5933000 	ldr	r3, [r3]
8f6109b8:	e58d3004 	str	r3, [r13, #4]
8f6109bc:	e3a03000 	mov	r3, #0
	platform_detect();
8f6109c0:	ebfffedb 	bl	8f610534 <platform_detect>
	target_detect(&board);
8f6109c4:	e3010320 	movw	r0, #4896	; 0x1320
8f6109c8:	e3480f71 	movt	r0, #36721	; 0x8f71
8f6109cc:	ebffc073 	bl	8f600ba0 <target_detect>
	target_baseband_detect(&board);
8f6109d0:	e59f3028 	ldr	r3, [pc, #40]	; 8f610a00 <board_init+0x58>
8f6109d4:	e5932000 	ldr	r2, [r3]
8f6109d8:	e59d3004 	ldr	r3, [r13, #4]
8f6109dc:	e0332002 	eors	r2, r3, r2
8f6109e0:	e3a03000 	mov	r3, #0
8f6109e4:	1a000004 	bne	8f6109fc <board_init+0x54>
8f6109e8:	e3010320 	movw	r0, #4896	; 0x1320
8f6109ec:	e3480f71 	movt	r0, #36721	; 0x8f71
}
8f6109f0:	e28dd00c 	add	r13, r13, #12
8f6109f4:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	target_baseband_detect(&board);
8f6109f8:	eaffc078 	b	8f600be0 <target_baseband_detect>
8f6109fc:	eb00886f 	bl	8f632bc0 <__stack_chk_fail>
8f610a00:	8f74221c 	.word	0x8f74221c

8f610a04 <write_wdata_from_array>:

static void write_wdata_from_array(uint8_t *array,
	                               uint8_t reg_num,
	                               uint8_t array_size,
	                               uint8_t* bytes_written)
{
8f610a04:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f610a08:	e1a08003 	mov	r8, r3
	uint32_t shift_value[] = {0, 8, 16, 24};
	int i;
	uint32_t val = 0;

	/* Write to WDATA */
	for (i = 0; (*bytes_written < array_size) && (i < 4); i++)
8f610a0c:	e5d8c000 	ldrb	r12, [r8]
	uint32_t shift_value[] = {0, 8, 16, 24};
8f610a10:	e3044010 	movw	r4, #16400	; 0x4010
{
8f610a14:	e59f30a4 	ldr	r3, [pc, #164]	; 8f610ac0 <write_wdata_from_array+0xbc>
	uint32_t shift_value[] = {0, 8, 16, 24};
8f610a18:	e3484f70 	movt	r4, #36720	; 0x8f70
{
8f610a1c:	e24dd01c 	sub	r13, r13, #28
	for (i = 0; (*bytes_written < array_size) && (i < 4); i++)
8f610a20:	e152000c 	cmp	r2, r12
{
8f610a24:	e5933000 	ldr	r3, [r3]
8f610a28:	e58d3014 	str	r3, [r13, #20]
8f610a2c:	e3a03000 	mov	r3, #0
8f610a30:	e1a06002 	mov	r6, r2
8f610a34:	e1a09000 	mov	r9, r0
8f610a38:	e1a07001 	mov	r7, r1
	uint32_t shift_value[] = {0, 8, 16, 24};
8f610a3c:	e894000f 	ldm	r4, {r0, r1, r2, r3}
8f610a40:	e28de004 	add	r14, r13, #4
	uint32_t val = 0;
8f610a44:	e3a05000 	mov	r5, #0
	uint32_t shift_value[] = {0, 8, 16, 24};
8f610a48:	e88e000f 	stm	r14, {r0, r1, r2, r3}
	for (i = 0; (*bytes_written < array_size) && (i < 4); i++)
8f610a4c:	9a00000a 	bls	8f610a7c <write_wdata_from_array+0x78>
8f610a50:	e1a04005 	mov	r4, r5
	{
		val |= (uint32_t)(array[*bytes_written]) << shift_value[i];
		(*bytes_written)++;
8f610a54:	e28c1001 	add	r1, r12, #1
		val |= (uint32_t)(array[*bytes_written]) << shift_value[i];
8f610a58:	e7d9200c 	ldrb	r2, [r9, r12]
	for (i = 0; (*bytes_written < array_size) && (i < 4); i++)
8f610a5c:	e2844001 	add	r4, r4, #1
		val |= (uint32_t)(array[*bytes_written]) << shift_value[i];
8f610a60:	e49e3004 	ldr	r3, [r14], #4
		(*bytes_written)++;
8f610a64:	e6efc071 	uxtb	r12, r1
8f610a68:	e5c8c000 	strb	r12, [r8]
	for (i = 0; (*bytes_written < array_size) && (i < 4); i++)
8f610a6c:	e3540004 	cmp	r4, #4
8f610a70:	115c0006 	cmpne	r12, r6
		val |= (uint32_t)(array[*bytes_written]) << shift_value[i];
8f610a74:	e1855312 	orr	r5, r5, r2, lsl r3
	for (i = 0; (*bytes_written < array_size) && (i < 4); i++)
8f610a78:	3afffff5 	bcc	8f610a54 <write_wdata_from_array+0x50>
	}

	writel(val, PMIC_ARB_CHNLn_WDATA(pmic_arb_chnl_num, reg_num));
8f610a7c:	e30c3d84 	movw	r3, #52612	; 0xcd84
8f610a80:	e3483f72 	movt	r3, #36722	; 0x8f72
8f610a84:	e5933000 	ldr	r3, [r3]
8f610a88:	e1a03783 	lsl	r3, r3, #15
8f610a8c:	e2833509 	add	r3, r3, #37748736	; 0x2400000
8f610a90:	e2833010 	add	r3, r3, #16
8f610a94:	e0833107 	add	r3, r3, r7, lsl #2
8f610a98:	e5835000 	str	r5, [r3]
}
8f610a9c:	e59f301c 	ldr	r3, [pc, #28]	; 8f610ac0 <write_wdata_from_array+0xbc>
8f610aa0:	e5932000 	ldr	r2, [r3]
8f610aa4:	e59d3014 	ldr	r3, [r13, #20]
8f610aa8:	e0332002 	eors	r2, r3, r2
8f610aac:	e3a03000 	mov	r3, #0
8f610ab0:	1a000001 	bne	8f610abc <write_wdata_from_array+0xb8>
8f610ab4:	e28dd01c 	add	r13, r13, #28
8f610ab8:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
8f610abc:	eb00883f 	bl	8f632bc0 <__stack_chk_fail>
8f610ac0:	8f74221c 	.word	0x8f74221c

8f610ac4 <read_rdata_into_array>:

static void read_rdata_into_array(uint8_t *array,
                                  uint8_t reg_num,
                                  uint8_t array_size,
                                  uint8_t* bytes_read)
{
8f610ac4:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
8f610ac8:	e1a04003 	mov	r4, r3
8f610acc:	e59f30b8 	ldr	r3, [pc, #184]	; 8f610b8c <read_rdata_into_array+0xc8>
8f610ad0:	e24dd018 	sub	r13, r13, #24
8f610ad4:	e1a07000 	mov	r7, r0
8f610ad8:	e1a06002 	mov	r6, r2
8f610adc:	e5933000 	ldr	r3, [r3]
8f610ae0:	e58d3014 	str	r3, [r13, #20]
8f610ae4:	e3a03000 	mov	r3, #0
	uint32_t mask_value[] = {0xFF, 0xFF00, 0xFF0000, 0xFF000000};
	uint8_t shift_value[] = {0, 8, 16, 24};
	int i;

#if SPMI_CORE_V2
		val = readl(PMIC_ARB_OBS_CHNLn_RDATA(pmic_arb_chnl_num, reg_num));
8f610ae8:	e30c3d84 	movw	r3, #52612	; 0xcd84
8f610aec:	e3483f72 	movt	r3, #36722	; 0x8f72
	uint8_t shift_value[] = {0, 8, 16, 24};
8f610af0:	e3a02b02 	mov	r2, #2048	; 0x800
8f610af4:	e3412810 	movt	r2, #6160	; 0x1810
8f610af8:	e58d2010 	str	r2, [r13, #16]
		val = readl(PMIC_ARB_OBS_CHNLn_RDATA(pmic_arb_chnl_num, reg_num));
8f610afc:	e5933000 	ldr	r3, [r3]
8f610b00:	e28d5010 	add	r5, r13, #16
#else
		val = readl(PMIC_ARB_CHNLn_RDATA(pmic_arb_chnl_num, reg_num));
#endif
	/* Read at most 4 bytes */
	for (i = 0; (i < 4) && (*bytes_read < array_size); i++)
8f610b04:	e5d4c000 	ldrb	r12, [r4]
	uint32_t mask_value[] = {0xFF, 0xFF00, 0xFF0000, 0xFF000000};
8f610b08:	e1a0a00d 	mov	r10, r13
8f610b0c:	e1a0e00a 	mov	r14, r10
8f610b10:	e1a08005 	mov	r8, r5
		val = readl(PMIC_ARB_OBS_CHNLn_RDATA(pmic_arb_chnl_num, reg_num));
8f610b14:	e1a03783 	lsl	r3, r3, #15
8f610b18:	e283350b 	add	r3, r3, #46137344	; 0x2c00000
8f610b1c:	e2833018 	add	r3, r3, #24
8f610b20:	e0833101 	add	r3, r3, r1, lsl #2
8f610b24:	e5939000 	ldr	r9, [r3]
	uint32_t mask_value[] = {0xFF, 0xFF00, 0xFF0000, 0xFF000000};
8f610b28:	e59f3060 	ldr	r3, [pc, #96]	; 8f610b90 <read_rdata_into_array+0xcc>
8f610b2c:	e893000f 	ldm	r3, {r0, r1, r2, r3}
8f610b30:	e88a000f 	stm	r10, {r0, r1, r2, r3}
	for (i = 0; (i < 4) && (*bytes_read < array_size); i++)
8f610b34:	e15c0006 	cmp	r12, r6
8f610b38:	2a00000a 	bcs	8f610b68 <read_rdata_into_array+0xa4>
	{
		array[*bytes_read] = (val & mask_value[i]) >> shift_value[i];
8f610b3c:	e49e1004 	ldr	r1, [r14], #4
8f610b40:	e4d53001 	ldrb	r3, [r5], #1
8f610b44:	e0011009 	and	r1, r1, r9
	for (i = 0; (i < 4) && (*bytes_read < array_size); i++)
8f610b48:	e15e0008 	cmp	r14, r8
		array[*bytes_read] = (val & mask_value[i]) >> shift_value[i];
8f610b4c:	e1a01331 	lsr	r1, r1, r3
8f610b50:	e7c7100c 	strb	r1, [r7, r12]
		(*bytes_read)++;
8f610b54:	e5d4c000 	ldrb	r12, [r4]
8f610b58:	e28cc001 	add	r12, r12, #1
8f610b5c:	e6efc07c 	uxtb	r12, r12
8f610b60:	e5c4c000 	strb	r12, [r4]
	for (i = 0; (i < 4) && (*bytes_read < array_size); i++)
8f610b64:	1afffff2 	bne	8f610b34 <read_rdata_into_array+0x70>
	}
}
8f610b68:	e59f301c 	ldr	r3, [pc, #28]	; 8f610b8c <read_rdata_into_array+0xc8>
8f610b6c:	e5932000 	ldr	r2, [r3]
8f610b70:	e59d3014 	ldr	r3, [r13, #20]
8f610b74:	e0332002 	eors	r2, r3, r2
8f610b78:	e3a03000 	mov	r3, #0
8f610b7c:	1a000001 	bne	8f610b88 <read_rdata_into_array+0xc4>
8f610b80:	e28dd018 	add	r13, r13, #24
8f610b84:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
8f610b88:	eb00880c 	bl	8f632bc0 <__stack_chk_fail>
8f610b8c:	8f74221c 	.word	0x8f74221c
8f610b90:	8f704020 	.word	0x8f704020

8f610b94 <spmi_init>:
{
8f610b94:	e59f2130 	ldr	r2, [pc, #304]	; 8f610ccc <spmi_init+0x138>
	pmic_arb_ver = readl(PMIC_ARB_SPMI_HW_VERSION);
8f610b98:	e3a03a0f 	mov	r3, #61440	; 0xf000
{
8f610b9c:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f610ba0:	e24dd014 	sub	r13, r13, #20
8f610ba4:	e5922000 	ldr	r2, [r2]
8f610ba8:	e58d200c 	str	r2, [r13, #12]
8f610bac:	e3a02000 	mov	r2, #0
	pmic_arb_ver = readl(PMIC_ARB_SPMI_HW_VERSION);
8f610bb0:	e3403200 	movt	r3, #512	; 0x200
8f610bb4:	e30c4d8c 	movw	r4, #52620	; 0xcd8c
8f610bb8:	e3484f72 	movt	r4, #36722	; 0x8f72
8f610bbc:	e5933000 	ldr	r3, [r3]
8f610bc0:	e1a0700e 	mov	r7, r14
{
8f610bc4:	e1a06000 	mov	r6, r0
8f610bc8:	e1a05001 	mov	r5, r1
	pmic_arb_ver = readl(PMIC_ARB_SPMI_HW_VERSION);
8f610bcc:	e5843000 	str	r3, [r4]
	max_peripherals = platform_get_max_periph();
8f610bd0:	ebffc2ff 	bl	8f6017d4 <platform_get_max_periph>
	if (pmic_arb_ver < PMIC_ARB_V2)
8f610bd4:	e5942000 	ldr	r2, [r4]
8f610bd8:	e30f3fff 	movw	r3, #65535	; 0xffff
8f610bdc:	e3423000 	movt	r3, #8192	; 0x2000
	max_peripherals = platform_get_max_periph();
8f610be0:	e30c4d80 	movw	r4, #52608	; 0xcd80
	if (pmic_arb_ver < PMIC_ARB_V2)
8f610be4:	e1520003 	cmp	r2, r3
	max_peripherals = platform_get_max_periph();
8f610be8:	e3484f72 	movt	r4, #36722	; 0x8f72
8f610bec:	e5840000 	str	r0, [r4]
	if (pmic_arb_ver < PMIC_ARB_V2)
8f610bf0:	8a000011 	bhi	8f610c3c <spmi_init+0xa8>
		pmic_arb_chnl_num = chnl_num;
8f610bf4:	e30c2d84 	movw	r2, #52612	; 0xcd84
		pmic_arb_owner_id = owner_id;
8f610bf8:	e30c3d88 	movw	r3, #52616	; 0xcd88
		pmic_arb_chnl_num = chnl_num;
8f610bfc:	e3482f72 	movt	r2, #36722	; 0x8f72
		pmic_arb_owner_id = owner_id;
8f610c00:	e3483f72 	movt	r3, #36722	; 0x8f72
		pmic_arb_chnl_num = chnl_num;
8f610c04:	e5826000 	str	r6, [r2]
		pmic_arb_owner_id = owner_id;
8f610c08:	e5835000 	str	r5, [r3]
	spmi_init_done = true;
8f610c0c:	e30c3d90 	movw	r3, #52624	; 0xcd90
8f610c10:	e3483f72 	movt	r3, #36722	; 0x8f72
8f610c14:	e3a02001 	mov	r2, #1
8f610c18:	e5832000 	str	r2, [r3]
}
8f610c1c:	e59f30a8 	ldr	r3, [pc, #168]	; 8f610ccc <spmi_init+0x138>
8f610c20:	e5932000 	ldr	r2, [r3]
8f610c24:	e59d300c 	ldr	r3, [r13, #12]
8f610c28:	e0332002 	eors	r2, r3, r2
8f610c2c:	e3a03000 	mov	r3, #0
8f610c30:	1a000024 	bne	8f610cc8 <spmi_init+0x134>
8f610c34:	e28dd014 	add	r13, r13, #20
8f610c38:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
	chnl_tbl = (uint8_t *) malloc(chnl_tbl_sz);
8f610c3c:	e3a00a01 	mov	r0, #4096	; 0x1000
8f610c40:	e30c5d7c 	movw	r5, #52604	; 0xcd7c
8f610c44:	eb008cec 	bl	8f633ffc <malloc>
8f610c48:	e3485f72 	movt	r5, #36722	; 0x8f72
	ASSERT(chnl_tbl);
8f610c4c:	e3500000 	cmp	r0, #0
	chnl_tbl = (uint8_t *) malloc(chnl_tbl_sz);
8f610c50:	e5850000 	str	r0, [r5]
	ASSERT(chnl_tbl);
8f610c54:	0a000010 	beq	8f610c9c <spmi_init+0x108>
	for(i = 0; i < max_peripherals; i++)
8f610c58:	e594c000 	ldr	r12, [r4]
8f610c5c:	e35c0000 	cmp	r12, #0
8f610c60:	0affffe9 	beq	8f610c0c <spmi_init+0x78>
		chnl_tbl[CHNL_IDX(slave_id, ppid_address)] = i;
8f610c64:	e595e000 	ldr	r14, [r5]
8f610c68:	e3a00b3e 	mov	r0, #63488	; 0xf800
8f610c6c:	e3400200 	movt	r0, #512	; 0x200
8f610c70:	e3a02000 	mov	r2, #0
		slave_id = (readl(PMIC_ARB_REG_CHLN(i)) & 0xf0000) >> 16;
8f610c74:	e5901000 	ldr	r1, [r0]
		ppid_address = (readl(PMIC_ARB_REG_CHLN(i)) & 0xff00) >> 8;
8f610c78:	e4903004 	ldr	r3, [r0], #4
		chnl_tbl[CHNL_IDX(slave_id, ppid_address)] = i;
8f610c7c:	e7e31851 	ubfx	r1, r1, #16, #4
8f610c80:	e7e73453 	ubfx	r3, r3, #8, #8
8f610c84:	e1833401 	orr	r3, r3, r1, lsl #8
8f610c88:	e7ce2003 	strb	r2, [r14, r3]
	for(i = 0; i < max_peripherals; i++)
8f610c8c:	e2822001 	add	r2, r2, #1
8f610c90:	e152000c 	cmp	r2, r12
8f610c94:	1afffff6 	bne	8f610c74 <spmi_init+0xe0>
8f610c98:	eaffffdb 	b	8f610c0c <spmi_init+0x78>
	ASSERT(chnl_tbl);
8f610c9c:	e3031f68 	movw	r1, #16232	; 0x3f68
8f610ca0:	e3032f4c 	movw	r2, #16204	; 0x3f4c
8f610ca4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f610ca8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f610cac:	e58d1000 	str	r1, [r13]
8f610cb0:	e3a0303d 	mov	r3, #61	; 0x3d
8f610cb4:	e1a00007 	mov	r0, r7
8f610cb8:	e3001130 	movw	r1, #304	; 0x130
8f610cbc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f610cc0:	eb00877d 	bl	8f632abc <_panic>
8f610cc4:	eaffffe3 	b	8f610c58 <spmi_init+0xc4>
}
8f610cc8:	eb0087bc 	bl	8f632bc0 <__stack_chk_fail>
8f610ccc:	8f74221c 	.word	0x8f74221c

8f610cd0 <pmic_arb_write_cmd>:
	if (pmic_arb_ver >= PMIC_ARB_V2)
8f610cd0:	e30c3d8c 	movw	r3, #52620	; 0xcd8c
8f610cd4:	e3483f72 	movt	r3, #36722	; 0x8f72
8f610cd8:	e30f2fff 	movw	r2, #65535	; 0xffff
8f610cdc:	e3422000 	movt	r2, #8192	; 0x2000
8f610ce0:	e5933000 	ldr	r3, [r3]
	uint32_t bytes_written = 0;
8f610ce4:	e3a0c000 	mov	r12, #0
{
8f610ce8:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	if (pmic_arb_ver >= PMIC_ARB_V2)
8f610cec:	e1530002 	cmp	r3, r2
{
8f610cf0:	e24dd00c 	sub	r13, r13, #12
8f610cf4:	e59f3150 	ldr	r3, [pc, #336]	; 8f610e4c <pmic_arb_write_cmd+0x17c>
8f610cf8:	e1a05000 	mov	r5, r0
8f610cfc:	e1a06001 	mov	r6, r1
8f610d00:	e5933000 	ldr	r3, [r3]
8f610d04:	e58d3004 	str	r3, [r13, #4]
8f610d08:	e3a03000 	mov	r3, #0
	uint32_t bytes_written = 0;
8f610d0c:	e58dc000 	str	r12, [r13]
	if (pmic_arb_ver >= PMIC_ARB_V2)
8f610d10:	9a000039 	bls	8f610dfc <pmic_arb_write_cmd+0x12c>
		pmic_arb_chnl_num = chnl_tbl[CHNL_IDX(cmd->slave_id, cmd->address)];
8f610d14:	e1d030b2 	ldrh	r3, [r0, #2]
8f610d18:	e30c2d7c 	movw	r2, #52604	; 0xcd7c
8f610d1c:	e3482f72 	movt	r2, #36722	; 0x8f72
8f610d20:	e6bf3fb3 	rev16	r3, r3
8f610d24:	e5922000 	ldr	r2, [r2]
8f610d28:	e6ff3073 	uxth	r3, r3
8f610d2c:	e7d27003 	ldrb	r7, [r2, r3]
8f610d30:	e30c3d84 	movw	r3, #52612	; 0xcd84
8f610d34:	e3483f72 	movt	r3, #36722	; 0x8f72
8f610d38:	e5837000 	str	r7, [r3]
	writel(0x0, PMIC_ARB_CHNLn_CONFIG(pmic_arb_chnl_num));
8f610d3c:	e1a03787 	lsl	r3, r7, #15
8f610d40:	e2834509 	add	r4, r3, #37748736	; 0x2400000
8f610d44:	e584c004 	str	r12, [r4, #4]
	write_wdata_from_array(param->buffer, 0, param->size,(uint8_t *)&bytes_written);
8f610d48:	e5d62004 	ldrb	r2, [r6, #4]
8f610d4c:	e1a0300d 	mov	r3, r13
8f610d50:	e5960000 	ldr	r0, [r6]
8f610d54:	e3a01000 	mov	r1, #0
8f610d58:	ebffff29 	bl	8f610a04 <write_wdata_from_array>
	if (bytes_written < param->size)
8f610d5c:	e5d62004 	ldrb	r2, [r6, #4]
8f610d60:	e59d3000 	ldr	r3, [r13]
8f610d64:	e1520003 	cmp	r2, r3
8f610d68:	8a000030 	bhi	8f610e30 <pmic_arb_write_cmd+0x160>
	cmd->opcode = SPMI_CMD_EXT_REG_WRTIE_LONG;
8f610d6c:	e3a00000 	mov	r0, #0
8f610d70:	e5c50000 	strb	r0, [r5]
	val |= ((uint32_t)(cmd->offset) << PMIC_ARB_CMD_ADDR_OFFSET_SHIFT);
8f610d74:	e5d50004 	ldrb	r0, [r5, #4]
	writel(val, PMIC_ARB_CHNLn_CMD0(pmic_arb_chnl_num));
8f610d78:	e2871d12 	add	r1, r7, #1152	; 0x480
	val |= ((uint32_t)(cmd->priority) << PMIC_ARB_CMD_PRIORITY_SHIFT);
8f610d7c:	e5d5c001 	ldrb	r12, [r5, #1]
	cmd->byte_cnt = param->size - 1;
8f610d80:	e2422001 	sub	r2, r2, #1
	writel(val, PMIC_ARB_CHNLn_CMD0(pmic_arb_chnl_num));
8f610d84:	e1a01781 	lsl	r1, r1, #15
	while (!(val = readl(PMIC_ARB_CHNLn_STATUS(pmic_arb_chnl_num))));
8f610d88:	e2843008 	add	r3, r4, #8
	val |= ((uint32_t)(cmd->offset) << PMIC_ARB_CMD_ADDR_OFFSET_SHIFT);
8f610d8c:	e1a00200 	lsl	r0, r0, #4
	cmd->byte_cnt = param->size - 1;
8f610d90:	e6ef2072 	uxtb	r2, r2
	val |= ((uint32_t)(cmd->offset) << PMIC_ARB_CMD_ADDR_OFFSET_SHIFT);
8f610d94:	e1800d0c 	orr	r0, r0, r12, lsl #26
	cmd->byte_cnt = param->size - 1;
8f610d98:	e5c52005 	strb	r2, [r5, #5]
	val |= ((uint32_t)(cmd->byte_cnt));
8f610d9c:	e1822000 	orr	r2, r2, r0
	writel(val, PMIC_ARB_CHNLn_CMD0(pmic_arb_chnl_num));
8f610da0:	e5812000 	str	r2, [r1]
	while (!(val = readl(PMIC_ARB_CHNLn_STATUS(pmic_arb_chnl_num))));
8f610da4:	e5932000 	ldr	r2, [r3]
8f610da8:	e3520000 	cmp	r2, #0
8f610dac:	0afffffc 	beq	8f610da4 <pmic_arb_write_cmd+0xd4>
	if (error)
8f610db0:	e3520001 	cmp	r2, #1
		return 0;
8f610db4:	03a04000 	moveq	r4, #0
	if (error)
8f610db8:	1a000008 	bne	8f610de0 <pmic_arb_write_cmd+0x110>
}
8f610dbc:	e59f3088 	ldr	r3, [pc, #136]	; 8f610e4c <pmic_arb_write_cmd+0x17c>
8f610dc0:	e5932000 	ldr	r2, [r3]
8f610dc4:	e59d3004 	ldr	r3, [r13, #4]
8f610dc8:	e0332002 	eors	r2, r3, r2
8f610dcc:	e3a03000 	mov	r3, #0
8f610dd0:	1a00001c 	bne	8f610e48 <pmic_arb_write_cmd+0x178>
8f610dd4:	e1a00004 	mov	r0, r4
8f610dd8:	e28dd00c 	add	r13, r13, #12
8f610ddc:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
	error = val ^ (1 << PMIC_ARB_CMD_DONE);
8f610de0:	e2224001 	eor	r4, r2, #1
		dprintf(CRITICAL, "SPMI write command failure: \
8f610de4:	e3a01000 	mov	r1, #0
8f610de8:	e3030fa0 	movw	r0, #16288	; 0x3fa0
8f610dec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f610df0:	e1a02004 	mov	r2, r4
8f610df4:	eb0086de 	bl	8f632974 <_dprintf>
		return error;
8f610df8:	eaffffef 	b	8f610dbc <pmic_arb_write_cmd+0xec>
	writel(0x0, PMIC_ARB_CHNLn_CONFIG(pmic_arb_chnl_num));
8f610dfc:	e30c3d84 	movw	r3, #52612	; 0xcd84
8f610e00:	e3483f72 	movt	r3, #36722	; 0x8f72
	if (cmd == NULL)
8f610e04:	e3500000 	cmp	r0, #0
	writel(0x0, PMIC_ARB_CHNLn_CONFIG(pmic_arb_chnl_num));
8f610e08:	e5937000 	ldr	r7, [r3]
8f610e0c:	e1a03787 	lsl	r3, r7, #15
8f610e10:	e2834509 	add	r4, r3, #37748736	; 0x2400000
8f610e14:	e584c004 	str	r12, [r4, #4]
	if (cmd == NULL)
8f610e18:	1affffca 	bne	8f610d48 <pmic_arb_write_cmd+0x78>
		dprintf(CRITICAL,"PMIC arbiter error, no command provided\n");
8f610e1c:	e3030f74 	movw	r0, #16244	; 0x3f74
8f610e20:	e3480f70 	movt	r0, #36720	; 0x8f70
8f610e24:	eb0086d2 	bl	8f632974 <_dprintf>
		return 1;
8f610e28:	e3a04001 	mov	r4, #1
8f610e2c:	eaffffe2 	b	8f610dbc <pmic_arb_write_cmd+0xec>
		write_wdata_from_array(param->buffer, 1, param->size, (uint8_t *)&bytes_written);
8f610e30:	e5960000 	ldr	r0, [r6]
8f610e34:	e1a0300d 	mov	r3, r13
8f610e38:	e3a01001 	mov	r1, #1
8f610e3c:	ebfffef0 	bl	8f610a04 <write_wdata_from_array>
	cmd->byte_cnt = param->size - 1;
8f610e40:	e5d62004 	ldrb	r2, [r6, #4]
8f610e44:	eaffffc8 	b	8f610d6c <pmic_arb_write_cmd+0x9c>
}
8f610e48:	eb00875c 	bl	8f632bc0 <__stack_chk_fail>
8f610e4c:	8f74221c 	.word	0x8f74221c

8f610e50 <pmic_arb_read_cmd>:

	/* Look up for pmic channel only for V2 hardware
	 * For V1-HW we dont care for channel number & always
	 * use '0'
	 */
	if (pmic_arb_ver >= PMIC_ARB_V2)
8f610e50:	e30c3d8c 	movw	r3, #52620	; 0xcd8c
8f610e54:	e3483f72 	movt	r3, #36722	; 0x8f72
8f610e58:	e30f2fff 	movw	r2, #65535	; 0xffff
8f610e5c:	e3422000 	movt	r2, #8192	; 0x2000
8f610e60:	e593c000 	ldr	r12, [r3]
	uint8_t bytes_read = 0;
8f610e64:	e3a03000 	mov	r3, #0
{
8f610e68:	e92d4030 	push	{r4, r5, r14}
	if (pmic_arb_ver >= PMIC_ARB_V2)
8f610e6c:	e15c0002 	cmp	r12, r2
{
8f610e70:	e24dd00c 	sub	r13, r13, #12
8f610e74:	e59f2144 	ldr	r2, [pc, #324]	; 8f610fc0 <pmic_arb_read_cmd+0x170>
8f610e78:	e1a05001 	mov	r5, r1
8f610e7c:	e5922000 	ldr	r2, [r2]
8f610e80:	e58d2004 	str	r2, [r13, #4]
8f610e84:	e3a02000 	mov	r2, #0
	uint8_t bytes_read = 0;
8f610e88:	e5cd3003 	strb	r3, [r13, #3]
	if (pmic_arb_ver >= PMIC_ARB_V2)
8f610e8c:	8a000027 	bhi	8f610f30 <pmic_arb_read_cmd+0xe0>
	}


	/* Disable IRQ mode for the current channel*/
#if SPMI_CORE_V2
		writel(0x0, PMIC_ARB_OBS_CHNLn_CONFIG(pmic_arb_chnl_num));
8f610e90:	e30c3d84 	movw	r3, #52612	; 0xcd84
8f610e94:	e3483f72 	movt	r3, #36722	; 0x8f72
8f610e98:	e5933000 	ldr	r3, [r3]
8f610e9c:	e1a03783 	lsl	r3, r3, #15
8f610ea0:	e3a02000 	mov	r2, #0
8f610ea4:	e283350b 	add	r3, r3, #46137344	; 0x2c00000
8f610ea8:	e5832004 	str	r2, [r3, #4]
#endif

	/* Fill in the byte count for the command
	 * Note: Byte count is one less than the number of bytes transferred.
	 */
	cmd->byte_cnt = param->size - 1;
8f610eac:	e5d52004 	ldrb	r2, [r5, #4]
	/* Fill in the Write cmd opcode. */
	cmd->opcode = SPMI_CMD_EXT_REG_READ_LONG;

	val |= ((uint32_t)(cmd->opcode) << PMIC_ARB_CMD_OPCODE_SHIFT);
	val |= ((uint32_t)(cmd->priority) << PMIC_ARB_CMD_PRIORITY_SHIFT);
8f610eb0:	e5d0e001 	ldrb	r14, [r0, #1]
	cmd->byte_cnt = param->size - 1;
8f610eb4:	e242c001 	sub	r12, r2, #1
8f610eb8:	e6ef107c 	uxtb	r1, r12
#ifndef SPMI_CORE_V2
	val |= ((uint32_t)(cmd->slave_id) << PMIC_ARB_CMD_SLAVE_ID_SHIFT);
	val |= ((uint32_t)(cmd->address) << PMIC_ARB_CMD_ADDR_SHIFT);
#endif
	val |= ((uint32_t)(cmd->offset) << PMIC_ARB_CMD_ADDR_OFFSET_SHIFT);
8f610ebc:	e5d0c004 	ldrb	r12, [r0, #4]
	cmd->byte_cnt = param->size - 1;
8f610ec0:	e5c01005 	strb	r1, [r0, #5]
	val |= ((uint32_t)(cmd->offset) << PMIC_ARB_CMD_ADDR_OFFSET_SHIFT);
8f610ec4:	e1a0c20c 	lsl	r12, r12, #4
	val |= ((uint32_t)(cmd->byte_cnt));
8f610ec8:	e18ccd0e 	orr	r12, r12, r14, lsl #26
8f610ecc:	e18cc001 	orr	r12, r12, r1
	cmd->opcode = SPMI_CMD_EXT_REG_READ_LONG;
8f610ed0:	e3a01001 	mov	r1, #1
	val |= ((uint32_t)(cmd->byte_cnt));
8f610ed4:	e38cc302 	orr	r12, r12, #134217728	; 0x8000000
	cmd->opcode = SPMI_CMD_EXT_REG_READ_LONG;
8f610ed8:	e5c01000 	strb	r1, [r0]

#if SPMI_CORE_V2
		writel(val, PMIC_ARB_OBS_CHNLn_CMD0(pmic_arb_chnl_num));
8f610edc:	e483c008 	str	r12, [r3], #8
		writel(val, PMIC_ARB_CHNLn_CMD0(pmic_arb_chnl_num));
#endif

	/* Wait till CMD DONE status */
#if SPMI_CORE_V2
		while (!(val = readl(PMIC_ARB_OBS_CHNLn_STATUS(pmic_arb_chnl_num))));
8f610ee0:	e5934000 	ldr	r4, [r3]
8f610ee4:	e3540000 	cmp	r4, #0
8f610ee8:	0afffffc 	beq	8f610ee0 <pmic_arb_read_cmd+0x90>
#endif

	/* Check for errors */
	error = val ^ (1 << PMIC_ARB_CMD_DONE);

	if (error)
8f610eec:	e3540001 	cmp	r4, #1
8f610ef0:	0a000019 	beq	8f610f5c <pmic_arb_read_cmd+0x10c>
	error = val ^ (1 << PMIC_ARB_CMD_DONE);
8f610ef4:	e2244001 	eor	r4, r4, #1
	{
		dprintf(CRITICAL, "SPMI read command failure: \
8f610ef8:	e3030fd8 	movw	r0, #16344	; 0x3fd8
8f610efc:	e3a01001 	mov	r1, #1
8f610f00:	e3480f70 	movt	r0, #36720	; 0x8f70
8f610f04:	e1a02004 	mov	r2, r4
8f610f08:	eb008699 	bl	8f632974 <_dprintf>
		read_rdata_into_array(param->buffer, 2, param->size , &bytes_read);

	}

	return 0;
}
8f610f0c:	e59f30ac 	ldr	r3, [pc, #172]	; 8f610fc0 <pmic_arb_read_cmd+0x170>
8f610f10:	e5932000 	ldr	r2, [r3]
8f610f14:	e59d3004 	ldr	r3, [r13, #4]
8f610f18:	e0332002 	eors	r2, r3, r2
8f610f1c:	e3a03000 	mov	r3, #0
8f610f20:	1a000025 	bne	8f610fbc <pmic_arb_read_cmd+0x16c>
8f610f24:	e1a00004 	mov	r0, r4
8f610f28:	e28dd00c 	add	r13, r13, #12
8f610f2c:	e8bd8030 	pop	{r4, r5, r15}
		pmic_arb_chnl_num = chnl_tbl[CHNL_IDX(cmd->slave_id, cmd->address)];
8f610f30:	e1d030b2 	ldrh	r3, [r0, #2]
8f610f34:	e30c1d7c 	movw	r1, #52604	; 0xcd7c
8f610f38:	e3481f72 	movt	r1, #36722	; 0x8f72
8f610f3c:	e30c2d84 	movw	r2, #52612	; 0xcd84
8f610f40:	e6bf3fb3 	rev16	r3, r3
8f610f44:	e3482f72 	movt	r2, #36722	; 0x8f72
8f610f48:	e5911000 	ldr	r1, [r1]
8f610f4c:	e6ff3073 	uxth	r3, r3
8f610f50:	e7d13003 	ldrb	r3, [r1, r3]
8f610f54:	e5823000 	str	r3, [r2]
8f610f58:	eaffffcf 	b	8f610e9c <pmic_arb_read_cmd+0x4c>
	read_rdata_into_array(param->buffer, 0, param->size , &bytes_read);
8f610f5c:	e28d3003 	add	r3, r13, #3
8f610f60:	e5950000 	ldr	r0, [r5]
8f610f64:	e3a01000 	mov	r1, #0
8f610f68:	ebfffed5 	bl	8f610ac4 <read_rdata_into_array>
	if (bytes_read < param->size)
8f610f6c:	e5d52004 	ldrb	r2, [r5, #4]
8f610f70:	e5dd3003 	ldrb	r3, [r13, #3]
8f610f74:	e1530002 	cmp	r3, r2
8f610f78:	3a000001 	bcc	8f610f84 <pmic_arb_read_cmd+0x134>
	return 0;
8f610f7c:	e3a04000 	mov	r4, #0
8f610f80:	eaffffe1 	b	8f610f0c <pmic_arb_read_cmd+0xbc>
		read_rdata_into_array(param->buffer, 1, param->size , &bytes_read);
8f610f84:	e28d3003 	add	r3, r13, #3
8f610f88:	e5950000 	ldr	r0, [r5]
8f610f8c:	e1a01004 	mov	r1, r4
8f610f90:	ebfffecb 	bl	8f610ac4 <read_rdata_into_array>
	if (bytes_read < param->size)
8f610f94:	e5d52004 	ldrb	r2, [r5, #4]
8f610f98:	e5dd3003 	ldrb	r3, [r13, #3]
8f610f9c:	e1530002 	cmp	r3, r2
8f610fa0:	2afffff5 	bcs	8f610f7c <pmic_arb_read_cmd+0x12c>
		read_rdata_into_array(param->buffer, 2, param->size , &bytes_read);
8f610fa4:	e5950000 	ldr	r0, [r5]
8f610fa8:	e28d3003 	add	r3, r13, #3
8f610fac:	e3a01002 	mov	r1, #2
	return 0;
8f610fb0:	e3a04000 	mov	r4, #0
		read_rdata_into_array(param->buffer, 2, param->size , &bytes_read);
8f610fb4:	ebfffec2 	bl	8f610ac4 <read_rdata_into_array>
8f610fb8:	eaffffd3 	b	8f610f0c <pmic_arb_read_cmd+0xbc>
}
8f610fbc:	eb0086ff 	bl	8f632bc0 <__stack_chk_fail>
8f610fc0:	8f74221c 	.word	0x8f74221c

8f610fc4 <pmic_spmi_reg_read>:

}

/* SPMI helper functions */
uint8_t pmic_spmi_reg_read(uint32_t addr)
{
8f610fc4:	e92d4010 	push	{r4, r14}
8f610fc8:	e24dd018 	sub	r13, r13, #24
8f610fcc:	e1a03000 	mov	r3, r0
	cmd.priority = 0;

	param.buffer = &val;
	param.size   = 1;

	pmic_arb_read_cmd(&cmd, &param);
8f610fd0:	e28d100c 	add	r1, r13, #12
	cmd.address  = SPMI_PERIPH_ID(addr);
8f610fd4:	e1a0c423 	lsr	r12, r3, #8
8f610fd8:	e5cdc007 	strb	r12, [r13, #7]
{
8f610fdc:	e59fc060 	ldr	r12, [pc, #96]	; 8f611044 <pmic_spmi_reg_read+0x80>
	pmic_arb_read_cmd(&cmd, &param);
8f610fe0:	e28d0004 	add	r0, r13, #4
	uint8_t val = 0;
8f610fe4:	e3a02000 	mov	r2, #0
	cmd.slave_id = SPMI_SLAVE_ID(addr);
8f610fe8:	e1a0e823 	lsr	r14, r3, #16
{
8f610fec:	e59cc000 	ldr	r12, [r12]
8f610ff0:	e58dc014 	str	r12, [r13, #20]
8f610ff4:	e3a0c000 	mov	r12, #0
	param.buffer = &val;
8f610ff8:	e28dc003 	add	r12, r13, #3
	uint8_t val = 0;
8f610ffc:	e5cd2003 	strb	r2, [r13, #3]
	cmd.offset   = SPMI_REG_OFFSET(addr);
8f611000:	e5cd3008 	strb	r3, [r13, #8]
	param.size   = 1;
8f611004:	e3a03001 	mov	r3, #1
	cmd.priority = 0;
8f611008:	e5cd2005 	strb	r2, [r13, #5]
	param.size   = 1;
8f61100c:	e5cd3010 	strb	r3, [r13, #16]
	cmd.slave_id = SPMI_SLAVE_ID(addr);
8f611010:	e5cde006 	strb	r14, [r13, #6]
	param.buffer = &val;
8f611014:	e58dc00c 	str	r12, [r13, #12]
	pmic_arb_read_cmd(&cmd, &param);
8f611018:	ebffff8c 	bl	8f610e50 <pmic_arb_read_cmd>

	return val;
}
8f61101c:	e59f3020 	ldr	r3, [pc, #32]	; 8f611044 <pmic_spmi_reg_read+0x80>
	return val;
8f611020:	e5dd0003 	ldrb	r0, [r13, #3]
}
8f611024:	e5932000 	ldr	r2, [r3]
8f611028:	e59d3014 	ldr	r3, [r13, #20]
8f61102c:	e0332002 	eors	r2, r3, r2
8f611030:	e3a03000 	mov	r3, #0
8f611034:	1a000001 	bne	8f611040 <pmic_spmi_reg_read+0x7c>
8f611038:	e28dd018 	add	r13, r13, #24
8f61103c:	e8bd8010 	pop	{r4, r15}
8f611040:	eb0086de 	bl	8f632bc0 <__stack_chk_fail>
8f611044:	8f74221c 	.word	0x8f74221c

8f611048 <pmic_spmi_reg_mask_write>:

	pmic_arb_write_cmd(&cmd, &param);
}

void pmic_spmi_reg_mask_write(uint32_t addr, uint8_t mask, uint8_t val)
{
8f611048:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f61104c:	e24dd01c 	sub	r13, r13, #28
8f611050:	e59f30ac 	ldr	r3, [pc, #172]	; 8f611104 <pmic_spmi_reg_mask_write+0xbc>
	cmd.address  = SPMI_PERIPH_ID(addr);
8f611054:	e7e7b450 	ubfx	r11, r0, #8, #8
	cmd.offset   = SPMI_REG_OFFSET(addr);
8f611058:	e6efa070 	uxtb	r10, r0
	cmd.slave_id = SPMI_SLAVE_ID(addr);
8f61105c:	e7e74850 	ubfx	r4, r0, #16, #8
{
8f611060:	e1a06001 	mov	r6, r1
	pmic_arb_read_cmd(&cmd, &param);
8f611064:	e28d0004 	add	r0, r13, #4
8f611068:	e28d100c 	add	r1, r13, #12
{
8f61106c:	e5933000 	ldr	r3, [r3]
8f611070:	e58d3014 	str	r3, [r13, #20]
8f611074:	e3a03000 	mov	r3, #0
	uint8_t val = 0;
8f611078:	e3a07000 	mov	r7, #0
{
8f61107c:	e1a05002 	mov	r5, r2
	param.buffer = &val;
8f611080:	e28d9003 	add	r9, r13, #3
	param.size   = 1;
8f611084:	e3a08001 	mov	r8, #1
	uint8_t val = 0;
8f611088:	e5cd7003 	strb	r7, [r13, #3]
	uint8_t reg;

	reg = pmic_spmi_reg_read(addr);

	reg &= ~mask;
	reg |= val & mask;
8f61108c:	e0055006 	and	r5, r5, r6
	cmd.address  = SPMI_PERIPH_ID(addr);
8f611090:	e5cdb007 	strb	r11, [r13, #7]
	cmd.offset   = SPMI_REG_OFFSET(addr);
8f611094:	e5cda008 	strb	r10, [r13, #8]
	cmd.slave_id = SPMI_SLAVE_ID(addr);
8f611098:	e5cd4006 	strb	r4, [r13, #6]
	cmd.priority = 0;
8f61109c:	e5cd7005 	strb	r7, [r13, #5]
	param.buffer = &val;
8f6110a0:	e58d900c 	str	r9, [r13, #12]
	param.size   = 1;
8f6110a4:	e5cd8010 	strb	r8, [r13, #16]
	pmic_arb_read_cmd(&cmd, &param);
8f6110a8:	ebffff68 	bl	8f610e50 <pmic_arb_read_cmd>
	return val;
8f6110ac:	e5dd2003 	ldrb	r2, [r13, #3]
	pmic_arb_write_cmd(&cmd, &param);
8f6110b0:	e28d100c 	add	r1, r13, #12
8f6110b4:	e28d0004 	add	r0, r13, #4
	cmd.address  = SPMI_PERIPH_ID(addr);
8f6110b8:	e5cdb007 	strb	r11, [r13, #7]
	reg &= ~mask;
8f6110bc:	e1c22006 	bic	r2, r2, r6
	cmd.offset   = SPMI_REG_OFFSET(addr);
8f6110c0:	e5cda008 	strb	r10, [r13, #8]
	reg |= val & mask;
8f6110c4:	e1822005 	orr	r2, r2, r5
	cmd.slave_id = SPMI_SLAVE_ID(addr);
8f6110c8:	e5cd4006 	strb	r4, [r13, #6]
8f6110cc:	e5cd2003 	strb	r2, [r13, #3]
	cmd.priority = 0;
8f6110d0:	e5cd7005 	strb	r7, [r13, #5]
	param.buffer = &val;
8f6110d4:	e58d900c 	str	r9, [r13, #12]
	param.size   = 1;
8f6110d8:	e5cd8010 	strb	r8, [r13, #16]
	pmic_arb_write_cmd(&cmd, &param);
8f6110dc:	ebfffefb 	bl	8f610cd0 <pmic_arb_write_cmd>
	pmic_spmi_reg_write(addr, reg);
}
8f6110e0:	e59f301c 	ldr	r3, [pc, #28]	; 8f611104 <pmic_spmi_reg_mask_write+0xbc>
8f6110e4:	e5932000 	ldr	r2, [r3]
8f6110e8:	e59d3014 	ldr	r3, [r13, #20]
8f6110ec:	e0332002 	eors	r2, r3, r2
8f6110f0:	e3a03000 	mov	r3, #0
8f6110f4:	1a000001 	bne	8f611100 <pmic_spmi_reg_mask_write+0xb8>
8f6110f8:	e28dd01c 	add	r13, r13, #28
8f6110fc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
8f611100:	eb0086ae 	bl	8f632bc0 <__stack_chk_fail>
8f611104:	8f74221c 	.word	0x8f74221c

8f611108 <spmi_initialized>:
	mask_interrupt(EE0_KRAIT_HLOS_SPMI_PERIPH_IRQ);
}

bool spmi_initialized()
{
	return spmi_init_done;
8f611108:	e30c3d90 	movw	r3, #52624	; 0xcd90
8f61110c:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f611110:	e59f2038 	ldr	r2, [pc, #56]	; 8f611150 <spmi_initialized+0x48>
8f611114:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f611118:	e24dd00c 	sub	r13, r13, #12
	return spmi_init_done;
8f61111c:	e5930000 	ldr	r0, [r3]
{
8f611120:	e5922000 	ldr	r2, [r2]
8f611124:	e58d2004 	str	r2, [r13, #4]
8f611128:	e3a02000 	mov	r2, #0
}
8f61112c:	e59f301c 	ldr	r3, [pc, #28]	; 8f611150 <spmi_initialized+0x48>
8f611130:	e5932000 	ldr	r2, [r3]
8f611134:	e59d3004 	ldr	r3, [r13, #4]
8f611138:	e0332002 	eors	r2, r3, r2
8f61113c:	e3a03000 	mov	r3, #0
8f611140:	1a000001 	bne	8f61114c <spmi_initialized+0x44>
8f611144:	e28dd00c 	add	r13, r13, #12
8f611148:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61114c:	eb00869b 	bl	8f632bc0 <__stack_chk_fail>
8f611150:	8f74221c 	.word	0x8f74221c

8f611154 <bam_wait_for_interrupt>:
 * interrupt: interrupt to wait for.
 */
int bam_wait_for_interrupt(struct bam_instance *bam,
                           uint8_t pipe_num,
                           enum p_int_type interrupt)
{
8f611154:	e92d4030 	push	{r4, r5, r14}
8f611158:	e24dd00c 	sub	r13, r13, #12
8f61115c:	e59fe0a4 	ldr	r14, [pc, #164]	; 8f611208 <bam_wait_for_interrupt+0xb4>
	while (1)
	{
		/* Wait for a interrupt on the right pipe */
		do{
			/* Determine the pipe causing the interrupt */
			val = readl(BAM_IRQ_SRCS(bam->base, bam->ee));
8f611160:	e5903000 	ldr	r3, [r0]
{
8f611164:	e59ee000 	ldr	r14, [r14]
8f611168:	e58de004 	str	r14, [r13, #4]
8f61116c:	e3a0e000 	mov	r14, #0
			/* Flush out the right most global interrupt bit */
		} while (!((val & 0x7FFF) & (1 << bam->pipe[pipe_num].pipe_num)));
8f611170:	e3a0e018 	mov	r14, #24
8f611174:	e02eee91 	mla	r14, r1, r14, r14
			val = readl(BAM_IRQ_SRCS(bam->base, bam->ee));
8f611178:	e590c054 	ldr	r12, [r0, #84]	; 0x54
8f61117c:	e28cc003 	add	r12, r12, #3
		} while (!((val & 0x7FFF) & (1 << bam->pipe[pipe_num].pipe_num)));
8f611180:	e080000e 	add	r0, r0, r14
8f611184:	e3a0e001 	mov	r14, #1
			val = readl(BAM_IRQ_SRCS(bam->base, bam->ee));
8f611188:	e083c60c 	add	r12, r3, r12, lsl #12
		} while (!((val & 0x7FFF) & (1 << bam->pipe[pipe_num].pipe_num)));
8f61118c:	e5d05002 	ldrb	r5, [r0, #2]
8f611190:	e1a0e51e 	lsl	r14, r14, r5

		/* Check the interrupt type */
		/* Read interrupt status register */
		val = readl(BAM_P_IRQ_STTSn(bam->pipe[pipe_num].pipe_num, bam->base));
8f611194:	e0833605 	add	r3, r3, r5, lsl #12
8f611198:	e2835a13 	add	r5, r3, #77824	; 0x13000
8f61119c:	e2854010 	add	r4, r5, #16
			val = readl(BAM_IRQ_SRCS(bam->base, bam->ee));
8f6111a0:	e59c3000 	ldr	r3, [r12]
		} while (!((val & 0x7FFF) & (1 << bam->pipe[pipe_num].pipe_num)));
8f6111a4:	e003300e 	and	r3, r3, r14
8f6111a8:	e7ee3053 	ubfx	r3, r3, #0, #15
8f6111ac:	e3530000 	cmp	r3, #0
8f6111b0:	0afffffa 	beq	8f6111a0 <bam_wait_for_interrupt+0x4c>
		val = readl(BAM_P_IRQ_STTSn(bam->pipe[pipe_num].pipe_num, bam->base));
8f6111b4:	e5941000 	ldr	r1, [r4]

		/* Check for error */
		if (val & P_ERR_EN_MASK)
8f6111b8:	e2110010 	ands	r0, r1, #16
8f6111bc:	1a000004 	bne	8f6111d4 <bam_wait_for_interrupt+0x80>
			goto bam_wait_int_error;

		if (val & interrupt)
8f6111c0:	e1120001 	tst	r2, r1
8f6111c4:	0afffff5 	beq	8f6111a0 <bam_wait_for_interrupt+0x4c>
		{
			/* Correct interrupt was fired. */
			 /* Clear the other interrupts */
			val = P_OUT_OF_DESC_EN_MASK | P_PRCSD_DESC_EN_MASK | P_TRNSFR_END_EN_MASK;
			writel (val, BAM_P_IRQ_CLRn(bam->pipe[pipe_num].pipe_num, bam->base));
8f6111c8:	e3a03029 	mov	r3, #41	; 0x29
8f6111cc:	e5853014 	str	r3, [r5, #20]
			return BAM_RESULT_SUCCESS;
8f6111d0:	ea000003 	b	8f6111e4 <bam_wait_for_interrupt+0x90>
		}
	}

bam_wait_int_error:

	dprintf(CRITICAL, "Unexpected interrupt : val %u\n", val);
8f6111d4:	e3040030 	movw	r0, #16432	; 0x4030
8f6111d8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6111dc:	eb0085e4 	bl	8f632974 <_dprintf>
	return BAM_RESULT_FAILURE;
8f6111e0:	e3a00001 	mov	r0, #1
}
8f6111e4:	e59f301c 	ldr	r3, [pc, #28]	; 8f611208 <bam_wait_for_interrupt+0xb4>
8f6111e8:	e5932000 	ldr	r2, [r3]
8f6111ec:	e59d3004 	ldr	r3, [r13, #4]
8f6111f0:	e0332002 	eors	r2, r3, r2
8f6111f4:	e3a03000 	mov	r3, #0
8f6111f8:	1a000001 	bne	8f611204 <bam_wait_for_interrupt+0xb0>
8f6111fc:	e28dd00c 	add	r13, r13, #12
8f611200:	e8bd8030 	pop	{r4, r5, r15}
8f611204:	eb00866d 	bl	8f632bc0 <__stack_chk_fail>
8f611208:	8f74221c 	.word	0x8f74221c

8f61120c <bam_sys_gen_event>:
                       uint8_t pipe_num,
                       unsigned int num_desc)
{
	uint32_t val = 0;

	if (num_desc >= bam->pipe[pipe_num].fifo.size) {
8f61120c:	e3a0c018 	mov	r12, #24
8f611210:	e023019c 	mla	r3, r12, r1, r0
{
8f611214:	e92d4010 	push	{r4, r14}
8f611218:	e24dd008 	sub	r13, r13, #8
8f61121c:	e59fe094 	ldr	r14, [pc, #148]	; 8f6112b8 <bam_sys_gen_event+0xac>
	if (num_desc >= bam->pipe[pipe_num].fifo.size) {
8f611220:	e1d331b4 	ldrh	r3, [r3, #20]
{
8f611224:	e59ee000 	ldr	r14, [r14]
8f611228:	e58de004 	str	r14, [r13, #4]
8f61122c:	e3a0e000 	mov	r14, #0
	if (num_desc >= bam->pipe[pipe_num].fifo.size) {
8f611230:	e1530002 	cmp	r3, r2
8f611234:	9a000013 	bls	8f611288 <bam_sys_gen_event+0x7c>
	}

	/* bits 0:15 of BAM_P_EVNT_REGn denotes the offset. We read the offset,
	 * and update the offset to notify BAM HW that new descriptors have been written
	 */
	val = readl(BAM_P_EVNT_REGn(bam->pipe[pipe_num].pipe_num, bam->base));
8f611238:	e02ccc91 	mla	r12, r1, r12, r12
8f61123c:	e5901000 	ldr	r1, [r0]

	/* Update the fifo peer offset */
	val += (num_desc) * BAM_DESC_SIZE;
	val &= (bam->pipe[pipe_num].fifo.size * BAM_DESC_SIZE - 1);
8f611240:	e1a03183 	lsl	r3, r3, #3
	val = readl(BAM_P_EVNT_REGn(bam->pipe[pipe_num].pipe_num, bam->base));
8f611244:	e2811b4e 	add	r1, r1, #79872	; 0x13800
	val &= (bam->pipe[pipe_num].fifo.size * BAM_DESC_SIZE - 1);
8f611248:	e2433001 	sub	r3, r3, #1
	val = readl(BAM_P_EVNT_REGn(bam->pipe[pipe_num].pipe_num, bam->base));
8f61124c:	e080000c 	add	r0, r0, r12
8f611250:	e2811018 	add	r1, r1, #24
8f611254:	e5d0c002 	ldrb	r12, [r0, #2]
8f611258:	e791060c 	ldr	r0, [r1, r12, lsl #12]
	val += (num_desc) * BAM_DESC_SIZE;
8f61125c:	e0802182 	add	r2, r0, r2, lsl #3
	val &= (bam->pipe[pipe_num].fifo.size * BAM_DESC_SIZE - 1);
8f611260:	e0033002 	and	r3, r3, r2

	writel(val, BAM_P_EVNT_REGn(bam->pipe[pipe_num].pipe_num, bam->base));
8f611264:	e781360c 	str	r3, [r1, r12, lsl #12]
}
8f611268:	e59f3048 	ldr	r3, [pc, #72]	; 8f6112b8 <bam_sys_gen_event+0xac>
8f61126c:	e5932000 	ldr	r2, [r3]
8f611270:	e59d3004 	ldr	r3, [r13, #4]
8f611274:	e0332002 	eors	r2, r3, r2
8f611278:	e3a03000 	mov	r3, #0
8f61127c:	1a00000c 	bne	8f6112b4 <bam_sys_gen_event+0xa8>
8f611280:	e28dd008 	add	r13, r13, #8
8f611284:	e8bd8010 	pop	{r4, r15}
		dprintf(CRITICAL,
8f611288:	e59f3028 	ldr	r3, [pc, #40]	; 8f6112b8 <bam_sys_gen_event+0xac>
8f61128c:	e5932000 	ldr	r2, [r3]
8f611290:	e59d3004 	ldr	r3, [r13, #4]
8f611294:	e0332002 	eors	r2, r3, r2
8f611298:	e3a03000 	mov	r3, #0
8f61129c:	1a000004 	bne	8f6112b4 <bam_sys_gen_event+0xa8>
8f6112a0:	e3040050 	movw	r0, #16464	; 0x4050
8f6112a4:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f6112a8:	e28dd008 	add	r13, r13, #8
8f6112ac:	e8bd4010 	pop	{r4, r14}
		dprintf(CRITICAL,
8f6112b0:	ea0085af 	b	8f632974 <_dprintf>
}
8f6112b4:	eb008641 	bl	8f632bc0 <__stack_chk_fail>
8f6112b8:	8f74221c 	.word	0x8f74221c

8f6112bc <bam_read_offset_update>:
 */
void bam_read_offset_update(struct bam_instance *bam, unsigned int pipe_num)
{
	uint32_t offset;

	offset = readl(BAM_P_SW_OFSTSn(bam->pipe[pipe_num].pipe_num, bam->base));
8f6112bc:	e3a03018 	mov	r3, #24
{
8f6112c0:	e59f205c 	ldr	r2, [pc, #92]	; 8f611324 <bam_read_offset_update+0x68>
	offset = readl(BAM_P_SW_OFSTSn(bam->pipe[pipe_num].pipe_num, bam->base));
8f6112c4:	e0233391 	mla	r3, r1, r3, r3
{
8f6112c8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6112cc:	e24dd00c 	sub	r13, r13, #12
8f6112d0:	e5922000 	ldr	r2, [r2]
8f6112d4:	e58d2004 	str	r2, [r13, #4]
8f6112d8:	e3a02000 	mov	r2, #0
	offset = readl(BAM_P_SW_OFSTSn(bam->pipe[pipe_num].pipe_num, bam->base));
8f6112dc:	e5902000 	ldr	r2, [r0]
8f6112e0:	e0800003 	add	r0, r0, r3
8f6112e4:	e2823b4e 	add	r3, r2, #79872	; 0x13800
8f6112e8:	e5d02002 	ldrb	r2, [r0, #2]
8f6112ec:	e7931602 	ldr	r1, [r3, r2, lsl #12]
	offset &= 0xFFFF;

	dprintf(SPEW, "Offset value is %d \n", offset);
8f6112f0:	e59f302c 	ldr	r3, [pc, #44]	; 8f611324 <bam_read_offset_update+0x68>
8f6112f4:	e5932000 	ldr	r2, [r3]
8f6112f8:	e59d3004 	ldr	r3, [r13, #4]
8f6112fc:	e0332002 	eors	r2, r3, r2
8f611300:	e3a03000 	mov	r3, #0
8f611304:	1a000005 	bne	8f611320 <bam_read_offset_update+0x64>
8f611308:	e6ff1071 	uxth	r1, r1
8f61130c:	e3040084 	movw	r0, #16516	; 0x4084
8f611310:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f611314:	e28dd00c 	add	r13, r13, #12
8f611318:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	dprintf(SPEW, "Offset value is %d \n", offset);
8f61131c:	ea008594 	b	8f632974 <_dprintf>
8f611320:	eb008626 	bl	8f632bc0 <__stack_chk_fail>
8f611324:	8f74221c 	.word	0x8f74221c

8f611328 <bam_add_one_desc>:
int bam_add_one_desc(struct bam_instance *bam,
                     unsigned int pipe_num,
                     unsigned char* data_ptr,
                     uint32_t len,
                     uint8_t flags)
{
8f611328:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}

	struct bam_desc *desc = bam->pipe[pipe_num].fifo.current;
	int bam_ret = BAM_RESULT_SUCCESS;

	if (data_ptr == NULL || len == 0)
8f61132c:	e3530000 	cmp	r3, #0
8f611330:	13520000 	cmpne	r2, #0
{
8f611334:	e24dd008 	sub	r13, r13, #8
8f611338:	e1a07001 	mov	r7, r1
8f61133c:	e59f1148 	ldr	r1, [pc, #328]	; 8f61148c <bam_add_one_desc+0x164>
8f611340:	e5ddc020 	ldrb	r12, [r13, #32]
8f611344:	e5911000 	ldr	r1, [r1]
8f611348:	e58d1004 	str	r1, [r13, #4]
8f61134c:	e3a01000 	mov	r1, #0
	if (data_ptr == NULL || len == 0)
8f611350:	03a01001 	moveq	r1, #1
8f611354:	13a01000 	movne	r1, #0
8f611358:	0a00002e 	beq	8f611418 <bam_add_one_desc+0xf0>
		bam_ret = BAM_RESULT_FAILURE;
		goto bam_add_one_desc_error;
	}

	/* Check if the FIFO is allocated for the pipe */
	if (!bam->pipe[pipe_num].initialized)
8f61135c:	e3a04018 	mov	r4, #24
8f611360:	e1a05003 	mov	r5, r3
8f611364:	e0240794 	mla	r4, r4, r7, r0
8f611368:	e1a06000 	mov	r6, r0
8f61136c:	e5d4301d 	ldrb	r3, [r4, #29]
8f611370:	e3530000 	cmp	r3, #0
8f611374:	0a000038 	beq	8f61145c <bam_add_one_desc+0x134>
				bam->pipe[pipe_num].pipe_num);
		bam_ret = BAM_RESULT_FAILURE;
		goto bam_add_one_desc_error;
	}

	if ((flags & BAM_DESC_LOCK_FLAG) && (flags & BAM_DESC_UNLOCK_FLAG))
8f611378:	e20c3006 	and	r3, r12, #6
8f61137c:	e3530006 	cmp	r3, #6
8f611380:	0a00003b 	beq	8f611474 <bam_add_one_desc+0x14c>
		bam_ret = BAM_RESULT_FAILURE;
		goto bam_add_one_desc_error;
	}

	/* Setting EOT flag on a CMD desc is not valid */
	if ((flags & BAM_DESC_EOT_FLAG) && (flags & BAM_DESC_CMD_FLAG))
8f611384:	e20c3048 	and	r3, r12, #72	; 0x48
8f611388:	e3530048 	cmp	r3, #72	; 0x48
8f61138c:	0a000026 	beq	8f61142c <bam_add_one_desc+0x104>
		bam_ret = BAM_RESULT_FAILURE;
		goto bam_add_one_desc_error;
	}

	/* Check for the length of the desc. */
	if (len > bam->max_desc_len)
8f611390:	e1d035b8 	ldrh	r3, [r0, #88]	; 0x58
8f611394:	e1530005 	cmp	r3, r5
8f611398:	3a000028 	bcc	8f611440 <bam_add_one_desc+0x118>
	struct bam_desc *desc = bam->pipe[pipe_num].fifo.current;
8f61139c:	e5948010 	ldr	r8, [r4, #16]
	desc->flags    = flags;
	desc->addr     = (uint32_t)data_ptr;
	desc->size     = (uint16_t)len;
	desc->reserved = 0;

	arch_clean_invalidate_cache_range((addr_t) VA((addr_t)data_ptr), len);
8f6113a0:	e1a00002 	mov	r0, r2
	desc->flags    = flags;
8f6113a4:	e5c8c007 	strb	r12, [r8, #7]
	desc->addr     = (uint32_t)data_ptr;
8f6113a8:	e5882000 	str	r2, [r8]
	desc->reserved = 0;
8f6113ac:	e5c81006 	strb	r1, [r8, #6]
	desc->size     = (uint16_t)len;
8f6113b0:	e1c850b4 	strh	r5, [r8, #4]
	arch_clean_invalidate_cache_range((addr_t) VA((addr_t)data_ptr), len);
8f6113b4:	ebffc0f6 	bl	8f601794 <platform_get_phys_to_virt_mapping>
8f6113b8:	e1a01005 	mov	r1, r5
8f6113bc:	eb003ef7 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	arch_clean_invalidate_cache_range((addr_t) desc, BAM_DESC_SIZE);
8f6113c0:	e3a01008 	mov	r1, #8
8f6113c4:	e1a00008 	mov	r0, r8
8f6113c8:	eb003ef4 	bl	8f620fa0 <arch_clean_invalidate_cache_range>

	/* Update the FIFO to point to the head */
	bam->pipe[pipe_num].fifo.current = fifo_getnext(&bam->pipe[pipe_num].fifo, desc);
8f6113cc:	e3a01018 	mov	r1, #24
8f6113d0:	e0266791 	mla	r6, r1, r7, r6
	offset = desc - fifo->head;
8f6113d4:	e594c00c 	ldr	r12, [r4, #12]
	if (offset == (fifo->size - 1))
8f6113d8:	e1d431b4 	ldrh	r3, [r4, #20]
	int bam_ret = BAM_RESULT_SUCCESS;
8f6113dc:	e3a00000 	mov	r0, #0
	offset = desc - fifo->head;
8f6113e0:	e048200c 	sub	r2, r8, r12
	if (offset == (fifo->size - 1))
8f6113e4:	e2433001 	sub	r3, r3, #1
8f6113e8:	e7ef21d2 	ubfx	r2, r2, #3, #16
8f6113ec:	e1520003 	cmp	r2, r3
		return desc + 1;
8f6113f0:	1288c008 	addne	r12, r8, #8
	bam->pipe[pipe_num].fifo.current = fifo_getnext(&bam->pipe[pipe_num].fifo, desc);
8f6113f4:	e586c010 	str	r12, [r6, #16]

bam_add_one_desc_error:
	return bam_ret;
}
8f6113f8:	e59f308c 	ldr	r3, [pc, #140]	; 8f61148c <bam_add_one_desc+0x164>
8f6113fc:	e5932000 	ldr	r2, [r3]
8f611400:	e59d3004 	ldr	r3, [r13, #4]
8f611404:	e0332002 	eors	r2, r3, r2
8f611408:	e3a03000 	mov	r3, #0
8f61140c:	1a00001d 	bne	8f611488 <bam_add_one_desc+0x160>
8f611410:	e28dd008 	add	r13, r13, #8
8f611414:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
		dprintf(CRITICAL, "Wrong params for BAM transfer \n");
8f611418:	e304009c 	movw	r0, #16540	; 0x409c
8f61141c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f611420:	eb008553 	bl	8f632974 <_dprintf>
		bam_ret = BAM_RESULT_FAILURE;
8f611424:	e3a00001 	mov	r0, #1
		goto bam_add_one_desc_error;
8f611428:	eafffff2 	b	8f6113f8 <bam_add_one_desc+0xd0>
		dprintf(CRITICAL, "EOT flag set on the CMD desc\n");
8f61142c:	e3040114 	movw	r0, #16660	; 0x4114
8f611430:	e3480f70 	movt	r0, #36720	; 0x8f70
8f611434:	eb00854e 	bl	8f632974 <_dprintf>
		bam_ret = BAM_RESULT_FAILURE;
8f611438:	e3a00001 	mov	r0, #1
		goto bam_add_one_desc_error;
8f61143c:	eaffffed 	b	8f6113f8 <bam_add_one_desc+0xd0>
		dprintf(CRITICAL, "len of the desc exceeds max length"
8f611440:	e1a02003 	mov	r2, r3
8f611444:	e1a01005 	mov	r1, r5
8f611448:	e3040134 	movw	r0, #16692	; 0x4134
8f61144c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f611450:	eb008547 	bl	8f632974 <_dprintf>
		bam_ret = BAM_RESULT_FAILURE;
8f611454:	e3a00001 	mov	r0, #1
		goto bam_add_one_desc_error;
8f611458:	eaffffe6 	b	8f6113f8 <bam_add_one_desc+0xd0>
		dprintf(CRITICAL, "Please allocate the FIFO for the BAM pipe %d\n",
8f61145c:	e5d4101a 	ldrb	r1, [r4, #26]
8f611460:	e30400bc 	movw	r0, #16572	; 0x40bc
8f611464:	e3480f70 	movt	r0, #36720	; 0x8f70
8f611468:	eb008541 	bl	8f632974 <_dprintf>
		bam_ret = BAM_RESULT_FAILURE;
8f61146c:	e3a00001 	mov	r0, #1
		goto bam_add_one_desc_error;
8f611470:	eaffffe0 	b	8f6113f8 <bam_add_one_desc+0xd0>
		dprintf(CRITICAL, "Can't lock and unlock in the same desc\n");
8f611474:	e30400ec 	movw	r0, #16620	; 0x40ec
8f611478:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61147c:	eb00853c 	bl	8f632974 <_dprintf>
		bam_ret = BAM_RESULT_FAILURE;
8f611480:	e3a00001 	mov	r0, #1
		goto bam_add_one_desc_error;
8f611484:	eaffffdb 	b	8f6113f8 <bam_add_one_desc+0xd0>
}
8f611488:	eb0085cc 	bl	8f632bc0 <__stack_chk_fail>
8f61148c:	8f74221c 	.word	0x8f74221c

8f611490 <bam_add_desc>:
{
8f611490:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
8f611494:	e1a04003 	mov	r4, r3
8f611498:	e24dd010 	sub	r13, r13, #16
8f61149c:	e59f3160 	ldr	r3, [pc, #352]	; 8f611604 <bam_add_desc+0x174>
8f6114a0:	e1a06000 	mov	r6, r0
8f6114a4:	e1a08001 	mov	r8, r1
	dprintf(SPEW, "Data length for BAM transfer is %u\n", data_len);
8f6114a8:	e3040160 	movw	r0, #16736	; 0x4160
8f6114ac:	e1a01004 	mov	r1, r4
8f6114b0:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f6114b4:	e1a05002 	mov	r5, r2
8f6114b8:	e59da030 	ldr	r10, [r13, #48]	; 0x30
8f6114bc:	e5933000 	ldr	r3, [r3]
8f6114c0:	e58d300c 	str	r3, [r13, #12]
8f6114c4:	e3a03000 	mov	r3, #0
	dprintf(SPEW, "Data length for BAM transfer is %u\n", data_len);
8f6114c8:	eb008529 	bl	8f632974 <_dprintf>
	if (data_ptr == NULL || len == 0)
8f6114cc:	e3540000 	cmp	r4, #0
8f6114d0:	13550000 	cmpne	r5, #0
8f6114d4:	03a07001 	moveq	r7, #1
8f6114d8:	13a07000 	movne	r7, #0
8f6114dc:	0a000038 	beq	8f6115c4 <bam_add_desc+0x134>
	if (len > (unsigned)bam->pipe[pipe_num].fifo.size * bam->max_desc_len)
8f6114e0:	e3a03018 	mov	r3, #24
8f6114e4:	e0236893 	mla	r3, r3, r8, r6
8f6114e8:	e1d321b4 	ldrh	r2, [r3, #20]
8f6114ec:	e1d635b8 	ldrh	r3, [r6, #88]	; 0x58
8f6114f0:	e0020293 	mul	r2, r3, r2
8f6114f4:	e1520004 	cmp	r2, r4
		bam_add_one_desc(bam, pipe_num, data_ptr, desc_len, desc_flags);
8f6114f8:	21a09007 	movcs	r9, r7
	if (len > (unsigned)bam->pipe[pipe_num].fifo.size * bam->max_desc_len)
8f6114fc:	3a000035 	bcc	8f6115d8 <bam_add_desc+0x148>
		if (len > bam->max_desc_len)
8f611500:	e1530004 	cmp	r3, r4
8f611504:	3a000022 	bcc	8f611594 <bam_add_desc+0x104>
		bam_add_one_desc(bam, pipe_num, data_ptr, desc_len, desc_flags);
8f611508:	e6efa07a 	uxtb	r10, r10
8f61150c:	e1a03004 	mov	r3, r4
8f611510:	e1a02005 	mov	r2, r5
8f611514:	e1a01008 	mov	r1, r8
8f611518:	e1a00006 	mov	r0, r6
8f61151c:	e58da000 	str	r10, [r13]
		n++;
8f611520:	e2877001 	add	r7, r7, #1
		bam_add_one_desc(bam, pipe_num, data_ptr, desc_len, desc_flags);
8f611524:	ebffff7f 	bl	8f611328 <bam_add_one_desc>
	if (num_desc >= bam->pipe[pipe_num].fifo.size) {
8f611528:	e6ef8078 	uxtb	r8, r8
8f61152c:	e3a02018 	mov	r2, #24
8f611530:	e0236892 	mla	r3, r2, r8, r6
8f611534:	e1d331b4 	ldrh	r3, [r3, #20]
8f611538:	e1530007 	cmp	r3, r7
8f61153c:	9a00002a 	bls	8f6115ec <bam_add_desc+0x15c>
	val = readl(BAM_P_EVNT_REGn(bam->pipe[pipe_num].pipe_num, bam->base));
8f611540:	e0222298 	mla	r2, r8, r2, r2
8f611544:	e5961000 	ldr	r1, [r6]
	val &= (bam->pipe[pipe_num].fifo.size * BAM_DESC_SIZE - 1);
8f611548:	e1a03183 	lsl	r3, r3, #3
	int bam_ret = BAM_RESULT_SUCCESS;
8f61154c:	e3a00000 	mov	r0, #0
	val = readl(BAM_P_EVNT_REGn(bam->pipe[pipe_num].pipe_num, bam->base));
8f611550:	e2811b4e 	add	r1, r1, #79872	; 0x13800
	val &= (bam->pipe[pipe_num].fifo.size * BAM_DESC_SIZE - 1);
8f611554:	e2433001 	sub	r3, r3, #1
	val = readl(BAM_P_EVNT_REGn(bam->pipe[pipe_num].pipe_num, bam->base));
8f611558:	e0866002 	add	r6, r6, r2
8f61155c:	e2811018 	add	r1, r1, #24
8f611560:	e5d6c002 	ldrb	r12, [r6, #2]
8f611564:	e791260c 	ldr	r2, [r1, r12, lsl #12]
	val += (num_desc) * BAM_DESC_SIZE;
8f611568:	e0827187 	add	r7, r2, r7, lsl #3
	val &= (bam->pipe[pipe_num].fifo.size * BAM_DESC_SIZE - 1);
8f61156c:	e0077003 	and	r7, r7, r3
	writel(val, BAM_P_EVNT_REGn(bam->pipe[pipe_num].pipe_num, bam->base));
8f611570:	e781760c 	str	r7, [r1, r12, lsl #12]
}
8f611574:	e59f3088 	ldr	r3, [pc, #136]	; 8f611604 <bam_add_desc+0x174>
8f611578:	e5932000 	ldr	r2, [r3]
8f61157c:	e59d300c 	ldr	r3, [r13, #12]
8f611580:	e0332002 	eors	r2, r3, r2
8f611584:	e3a03000 	mov	r3, #0
8f611588:	1a00001c 	bne	8f611600 <bam_add_desc+0x170>
8f61158c:	e28dd010 	add	r13, r13, #16
8f611590:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
			len -= bam->max_desc_len;
8f611594:	e0444003 	sub	r4, r4, r3
		bam_add_one_desc(bam, pipe_num, data_ptr, desc_len, desc_flags);
8f611598:	e1a02005 	mov	r2, r5
8f61159c:	e1a01008 	mov	r1, r8
8f6115a0:	e1a00006 	mov	r0, r6
8f6115a4:	e58d9000 	str	r9, [r13]
		n++;
8f6115a8:	e2877001 	add	r7, r7, #1
		bam_add_one_desc(bam, pipe_num, data_ptr, desc_len, desc_flags);
8f6115ac:	ebffff5d 	bl	8f611328 <bam_add_one_desc>
		data_ptr += bam->max_desc_len;
8f6115b0:	e1d635b8 	ldrh	r3, [r6, #88]	; 0x58
	while (len)
8f6115b4:	e3540000 	cmp	r4, #0
		data_ptr += bam->max_desc_len;
8f6115b8:	e0855003 	add	r5, r5, r3
	while (len)
8f6115bc:	1affffcf 	bne	8f611500 <bam_add_desc+0x70>
8f6115c0:	eaffffd8 	b	8f611528 <bam_add_desc+0x98>
		dprintf(CRITICAL, "Wrong params for BAM transfer \n");
8f6115c4:	e304009c 	movw	r0, #16540	; 0x409c
8f6115c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6115cc:	eb0084e8 	bl	8f632974 <_dprintf>
		bam_ret = BAM_RESULT_FAILURE;
8f6115d0:	e3a00001 	mov	r0, #1
		goto bam_add_desc_error;
8f6115d4:	eaffffe6 	b	8f611574 <bam_add_desc+0xe4>
		dprintf(CRITICAL, "Data transfer exceeds desc fifo length.\n");
8f6115d8:	e3040184 	movw	r0, #16772	; 0x4184
8f6115dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6115e0:	eb0084e3 	bl	8f632974 <_dprintf>
		bam_ret = BAM_RESULT_FAILURE;
8f6115e4:	e3a00001 	mov	r0, #1
		goto bam_add_desc_error;
8f6115e8:	eaffffe1 	b	8f611574 <bam_add_desc+0xe4>
		dprintf(CRITICAL,
8f6115ec:	e3040050 	movw	r0, #16464	; 0x4050
8f6115f0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6115f4:	eb0084de 	bl	8f632974 <_dprintf>
	int bam_ret = BAM_RESULT_SUCCESS;
8f6115f8:	e3a00000 	mov	r0, #0
		return;
8f6115fc:	eaffffdc 	b	8f611574 <bam_add_desc+0xe4>
}
8f611600:	eb00856e 	bl	8f632bc0 <__stack_chk_fail>
8f611604:	8f74221c 	.word	0x8f74221c

8f611608 <bam_add_cmd_element>:
                                        enum bam_ce_cmd_t cmd_type)
{
	/* Write cmd type.
	 * Also, write the register address.
	 */
	 ptr->addr_n_cmd = (reg_addr & ~(0xFF000000)) | (cmd_type << 24);
8f611608:	e3c114ff 	bic	r1, r1, #-16777216	; 0xff000000
8f61160c:	e1811c03 	orr	r1, r1, r3, lsl #24
{
8f611610:	e59f3054 	ldr	r3, [pc, #84]	; 8f61166c <bam_add_cmd_element+0x64>
8f611614:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f611618:	e24dd00c 	sub	r13, r13, #12
8f61161c:	e5933000 	ldr	r3, [r3]
8f611620:	e58d3004 	str	r3, [r13, #4]
8f611624:	e3a03000 	mov	r3, #0
	/* Write the value to be written */
	ptr->reg_data = value;

	/* Return the address to add the next element to */
	return ptr + 1;
}
8f611628:	e59f303c 	ldr	r3, [pc, #60]	; 8f61166c <bam_add_cmd_element+0x64>
	ptr->reg_mask = 0xFFFFFFFF;
8f61162c:	e3e0e000 	mvn	r14, #0
	 ptr->addr_n_cmd = (reg_addr & ~(0xFF000000)) | (cmd_type << 24);
8f611630:	e5801000 	str	r1, [r0]
	ptr->reg_mask = 0xFFFFFFFF;
8f611634:	e5c0e008 	strb	r14, [r0, #8]
8f611638:	e5c0e009 	strb	r14, [r0, #9]
8f61163c:	e5c0e00a 	strb	r14, [r0, #10]
8f611640:	e5c0e00b 	strb	r14, [r0, #11]
	ptr->reg_data = value;
8f611644:	e5802004 	str	r2, [r0, #4]
}
8f611648:	e5932000 	ldr	r2, [r3]
8f61164c:	e59d3004 	ldr	r3, [r13, #4]
8f611650:	e0332002 	eors	r2, r3, r2
8f611654:	e3a03000 	mov	r3, #0
8f611658:	1a000002 	bne	8f611668 <bam_add_cmd_element+0x60>
8f61165c:	e2800010 	add	r0, r0, #16
8f611660:	e28dd00c 	add	r13, r13, #12
8f611664:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f611668:	eb008554 	bl	8f632bc0 <__stack_chk_fail>
8f61166c:	8f74221c 	.word	0x8f74221c

8f611670 <qpic_nand_add_addr_n_cfg_ce>:
 * Returns the address where the next cmd element can be added.
 */
static struct cmd_element*
qpic_nand_add_addr_n_cfg_ce(struct cfg_params *cfg,
							struct cmd_element *start)
{
8f611670:	e92d4070 	push	{r4, r5, r6, r14}
	struct cmd_element *cmd_list_ptr = start;

	bam_add_cmd_element(cmd_list_ptr, NAND_ADDR0, (uint32_t)cfg->addr0, CE_WRITE_TYPE);
8f611674:	e30c6e6c 	movw	r6, #52844	; 0xce6c
8f611678:	e3486f72 	movt	r6, #36722	; 0x8f72
{
8f61167c:	e1a04001 	mov	r4, r1
8f611680:	e24dd008 	sub	r13, r13, #8
8f611684:	e1a05000 	mov	r5, r0
	bam_add_cmd_element(cmd_list_ptr, NAND_ADDR0, (uint32_t)cfg->addr0, CE_WRITE_TYPE);
8f611688:	e5962000 	ldr	r2, [r6]
8f61168c:	e3a03000 	mov	r3, #0
8f611690:	e2821004 	add	r1, r2, #4
{
8f611694:	e59f2084 	ldr	r2, [pc, #132]	; 8f611720 <qpic_nand_add_addr_n_cfg_ce+0xb0>
8f611698:	e5922000 	ldr	r2, [r2]
8f61169c:	e58d2004 	str	r2, [r13, #4]
8f6116a0:	e3a02000 	mov	r2, #0
	bam_add_cmd_element(cmd_list_ptr, NAND_ADDR0, (uint32_t)cfg->addr0, CE_WRITE_TYPE);
8f6116a4:	e5902000 	ldr	r2, [r0]
8f6116a8:	e1a00004 	mov	r0, r4
8f6116ac:	ebffffd5 	bl	8f611608 <bam_add_cmd_element>
	cmd_list_ptr++;
	bam_add_cmd_element(cmd_list_ptr, NAND_ADDR1, (uint32_t)cfg->addr1, CE_WRITE_TYPE);
8f6116b0:	e5961000 	ldr	r1, [r6]
8f6116b4:	e5952004 	ldr	r2, [r5, #4]
8f6116b8:	e3a03000 	mov	r3, #0
8f6116bc:	e2811008 	add	r1, r1, #8
8f6116c0:	e2840010 	add	r0, r4, #16
8f6116c4:	ebffffcf 	bl	8f611608 <bam_add_cmd_element>
	cmd_list_ptr++;
	bam_add_cmd_element(cmd_list_ptr, NAND_DEV0_CFG0, (uint32_t)cfg->cfg0, CE_WRITE_TYPE);
8f6116c8:	e5961000 	ldr	r1, [r6]
8f6116cc:	e5952008 	ldr	r2, [r5, #8]
8f6116d0:	e3a03000 	mov	r3, #0
8f6116d4:	e2811020 	add	r1, r1, #32
8f6116d8:	e2840020 	add	r0, r4, #32
8f6116dc:	ebffffc9 	bl	8f611608 <bam_add_cmd_element>
	cmd_list_ptr++;
	bam_add_cmd_element(cmd_list_ptr, NAND_DEV0_CFG1, (uint32_t)cfg->cfg1, CE_WRITE_TYPE);
8f6116e0:	e5961000 	ldr	r1, [r6]
8f6116e4:	e595200c 	ldr	r2, [r5, #12]
8f6116e8:	e3a03000 	mov	r3, #0
8f6116ec:	e2840030 	add	r0, r4, #48	; 0x30
8f6116f0:	e2811024 	add	r1, r1, #36	; 0x24
8f6116f4:	ebffffc3 	bl	8f611608 <bam_add_cmd_element>
	cmd_list_ptr++;

	return cmd_list_ptr;
}
8f6116f8:	e59f3020 	ldr	r3, [pc, #32]	; 8f611720 <qpic_nand_add_addr_n_cfg_ce+0xb0>
8f6116fc:	e5932000 	ldr	r2, [r3]
8f611700:	e59d3004 	ldr	r3, [r13, #4]
8f611704:	e0332002 	eors	r2, r3, r2
8f611708:	e3a03000 	mov	r3, #0
8f61170c:	1a000002 	bne	8f61171c <qpic_nand_add_addr_n_cfg_ce+0xac>
8f611710:	e2840040 	add	r0, r4, #64	; 0x40
8f611714:	e28dd008 	add	r13, r13, #8
8f611718:	e8bd8070 	pop	{r4, r5, r6, r15}
8f61171c:	eb008527 	bl	8f632bc0 <__stack_chk_fail>
8f611720:	8f74221c 	.word	0x8f74221c

8f611724 <qpic_nand_read_reg>:
{
8f611724:	e92d4070 	push	{r4, r5, r6, r14}
	val = 0;
8f611728:	e30c4e74 	movw	r4, #52852	; 0xce74
8f61172c:	e3484f72 	movt	r4, #36722	; 0x8f72
{
8f611730:	e59f20e0 	ldr	r2, [pc, #224]	; 8f611818 <qpic_nand_read_reg+0xf4>
8f611734:	e24dd010 	sub	r13, r13, #16
8f611738:	e1a06000 	mov	r6, r0
	bam_add_cmd_element(cmd_list_read_ptr, reg_addr, (uint32_t)PA((addr_t)&val), CE_READ_TYPE);
8f61173c:	e1a00004 	mov	r0, r4
{
8f611740:	e5922000 	ldr	r2, [r2]
8f611744:	e58d200c 	str	r2, [r13, #12]
8f611748:	e3a02000 	mov	r2, #0
8f61174c:	e1a05001 	mov	r5, r1
	val = 0;
8f611750:	e3a03000 	mov	r3, #0
8f611754:	e5843000 	str	r3, [r4]
	bam_add_cmd_element(cmd_list_read_ptr, reg_addr, (uint32_t)PA((addr_t)&val), CE_READ_TYPE);
8f611758:	ebffbffd 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f61175c:	e3a03001 	mov	r3, #1
8f611760:	e1a01006 	mov	r1, r6
	bam_add_one_desc(&bam,
8f611764:	e3855088 	orr	r5, r5, #136	; 0x88
	bam_add_cmd_element(cmd_list_read_ptr, reg_addr, (uint32_t)PA((addr_t)&val), CE_READ_TYPE);
8f611768:	e1a02000 	mov	r2, r0
8f61176c:	e30208f0 	movw	r0, #10480	; 0x28f0
8f611770:	e3480f74 	movt	r0, #36724	; 0x8f74
8f611774:	ebffffa3 	bl	8f611608 <bam_add_cmd_element>
					 (unsigned char*)PA((addr_t)cmd_list_read_ptr),
8f611778:	e30208f0 	movw	r0, #10480	; 0x28f0
8f61177c:	e3480f74 	movt	r0, #36724	; 0x8f74
8f611780:	ebffbff3 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	bam_add_one_desc(&bam,
8f611784:	e3a03010 	mov	r3, #16
8f611788:	e3a01002 	mov	r1, #2
8f61178c:	e58d5000 	str	r5, [r13]
					 (unsigned char*)PA((addr_t)cmd_list_read_ptr),
8f611790:	e1a02000 	mov	r2, r0
	bam_add_one_desc(&bam,
8f611794:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f611798:	e3480f72 	movt	r0, #36722	; 0x8f72
8f61179c:	ebfffee1 	bl	8f611328 <bam_add_one_desc>
	arch_clean_invalidate_cache_range((addr_t)&val, sizeof(uint32_t));
8f6117a0:	e3a01004 	mov	r1, #4
8f6117a4:	e1a00004 	mov	r0, r4
8f6117a8:	eb003dfc 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	bam_sys_gen_event(&bam, CMD_PIPE_INDEX, num_desc);
8f6117ac:	e3a02001 	mov	r2, #1
8f6117b0:	e3a01002 	mov	r1, #2
8f6117b4:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f6117b8:	e3480f72 	movt	r0, #36722	; 0x8f72
8f6117bc:	ebfffe92 	bl	8f61120c <bam_sys_gen_event>
	bam_wait_for_interrupt(&bam, CMD_PIPE_INDEX, P_PRCSD_DESC_EN_MASK);
8f6117c0:	e3a02001 	mov	r2, #1
8f6117c4:	e3a01002 	mov	r1, #2
8f6117c8:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f6117cc:	e3480f72 	movt	r0, #36722	; 0x8f72
8f6117d0:	ebfffe5f 	bl	8f611154 <bam_wait_for_interrupt>
	bam_read_offset_update(&bam, CMD_PIPE_INDEX);
8f6117d4:	e3a01002 	mov	r1, #2
8f6117d8:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f6117dc:	e3480f72 	movt	r0, #36722	; 0x8f72
8f6117e0:	ebfffeb5 	bl	8f6112bc <bam_read_offset_update>
	arch_clean_invalidate_cache_range((addr_t)&val, sizeof(uint32_t));
8f6117e4:	e1a00004 	mov	r0, r4
8f6117e8:	e3a01004 	mov	r1, #4
8f6117ec:	eb003deb 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
}
8f6117f0:	e59f3020 	ldr	r3, [pc, #32]	; 8f611818 <qpic_nand_read_reg+0xf4>
	return val;
8f6117f4:	e5940000 	ldr	r0, [r4]
}
8f6117f8:	e5932000 	ldr	r2, [r3]
8f6117fc:	e59d300c 	ldr	r3, [r13, #12]
8f611800:	e0332002 	eors	r2, r3, r2
8f611804:	e3a03000 	mov	r3, #0
8f611808:	1a000001 	bne	8f611814 <qpic_nand_read_reg+0xf0>
8f61180c:	e28dd010 	add	r13, r13, #16
8f611810:	e8bd8070 	pop	{r4, r5, r6, r15}
8f611814:	eb0084e9 	bl	8f632bc0 <__stack_chk_fail>
8f611818:	8f74221c 	.word	0x8f74221c

8f61181c <qpic_nand_erased_status_reset>:
{
8f61181c:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
	bam_add_cmd_element(cmd_list_ptr, NAND_ERASED_CW_DETECT_CFG, val, CE_WRITE_TYPE);
8f611820:	e30c8e6c 	movw	r8, #52844	; 0xce6c
8f611824:	e3488f72 	movt	r8, #36722	; 0x8f72
{
8f611828:	e59f313c 	ldr	r3, [pc, #316]	; 8f61196c <qpic_nand_erased_status_reset+0x150>
8f61182c:	e1a05001 	mov	r5, r1
8f611830:	e24dd010 	sub	r13, r13, #16
	bam_add_cmd_element(cmd_list_ptr, NAND_ERASED_CW_DETECT_CFG, val, CE_WRITE_TYPE);
8f611834:	e5981000 	ldr	r1, [r8]
	val = NAND_ERASED_CW_DETECT_CFG_RESET_CTRL;
8f611838:	e3a04001 	mov	r4, #1
8f61183c:	e30c7e74 	movw	r7, #52852	; 0xce74
8f611840:	e3487f72 	movt	r7, #36722	; 0x8f72
{
8f611844:	e1a06000 	mov	r6, r0
8f611848:	e5933000 	ldr	r3, [r3]
8f61184c:	e58d300c 	str	r3, [r13, #12]
8f611850:	e3a03000 	mov	r3, #0
	bam_add_cmd_element(cmd_list_ptr, NAND_ERASED_CW_DETECT_CFG, val, CE_WRITE_TYPE);
8f611854:	e28110e8 	add	r1, r1, #232	; 0xe8
8f611858:	e3a03000 	mov	r3, #0
8f61185c:	e1a02004 	mov	r2, r4
	val = NAND_ERASED_CW_DETECT_CFG_RESET_CTRL;
8f611860:	e5874000 	str	r4, [r7]
	bam_add_cmd_element(cmd_list_ptr, NAND_ERASED_CW_DETECT_CFG, val, CE_WRITE_TYPE);
8f611864:	ebffff67 	bl	8f611608 <bam_add_cmd_element>
					 (unsigned char*)PA((addr_t)cmd_list_ptr),
8f611868:	e1a00006 	mov	r0, r6
8f61186c:	ebffbfb8 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	bam_add_one_desc(&bam,
8f611870:	e3855088 	orr	r5, r5, #136	; 0x88
8f611874:	e3a03010 	mov	r3, #16
8f611878:	e3a01002 	mov	r1, #2
8f61187c:	e58d5000 	str	r5, [r13]
	val = NAND_ERASED_CW_DETECT_CFG_ACTIVATE_CTRL | NAND_ERASED_CW_DETECT_ERASED_CW_ECC_MASK;
8f611880:	e3a05002 	mov	r5, #2
					 (unsigned char*)PA((addr_t)cmd_list_ptr),
8f611884:	e1a02000 	mov	r2, r0
	bam_add_one_desc(&bam,
8f611888:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f61188c:	e3480f72 	movt	r0, #36722	; 0x8f72
8f611890:	ebfffea4 	bl	8f611328 <bam_add_one_desc>
	bam_sys_gen_event(&bam, CMD_PIPE_INDEX, num_desc);
8f611894:	e1a02004 	mov	r2, r4
8f611898:	e3a01002 	mov	r1, #2
8f61189c:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f6118a0:	e3480f72 	movt	r0, #36722	; 0x8f72
8f6118a4:	ebfffe58 	bl	8f61120c <bam_sys_gen_event>
	bam_wait_for_interrupt(&bam, CMD_PIPE_INDEX, P_PRCSD_DESC_EN_MASK);
8f6118a8:	e1a02004 	mov	r2, r4
8f6118ac:	e3a01002 	mov	r1, #2
8f6118b0:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f6118b4:	e3480f72 	movt	r0, #36722	; 0x8f72
8f6118b8:	ebfffe25 	bl	8f611154 <bam_wait_for_interrupt>
	bam_read_offset_update(&bam, CMD_PIPE_INDEX);
8f6118bc:	e3a01002 	mov	r1, #2
8f6118c0:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f6118c4:	e3480f72 	movt	r0, #36722	; 0x8f72
8f6118c8:	ebfffe7b 	bl	8f6112bc <bam_read_offset_update>
	bam_add_cmd_element(cmd_list_ptr, NAND_ERASED_CW_DETECT_CFG, val, CE_WRITE_TYPE);
8f6118cc:	e5981000 	ldr	r1, [r8]
8f6118d0:	e3a03000 	mov	r3, #0
8f6118d4:	e1a02005 	mov	r2, r5
8f6118d8:	e28110e8 	add	r1, r1, #232	; 0xe8
8f6118dc:	e1a00006 	mov	r0, r6
	val = NAND_ERASED_CW_DETECT_CFG_ACTIVATE_CTRL | NAND_ERASED_CW_DETECT_ERASED_CW_ECC_MASK;
8f6118e0:	e5875000 	str	r5, [r7]
	bam_add_cmd_element(cmd_list_ptr, NAND_ERASED_CW_DETECT_CFG, val, CE_WRITE_TYPE);
8f6118e4:	ebffff47 	bl	8f611608 <bam_add_cmd_element>
					 (unsigned char*)PA((addr_t)cmd_list_ptr),
8f6118e8:	e1a00006 	mov	r0, r6
8f6118ec:	ebffbf98 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	bam_add_one_desc(&bam,
8f6118f0:	e3a03010 	mov	r3, #16
8f6118f4:	e3a01088 	mov	r1, #136	; 0x88
8f6118f8:	e58d1000 	str	r1, [r13]
8f6118fc:	e1a01005 	mov	r1, r5
					 (unsigned char*)PA((addr_t)cmd_list_ptr),
8f611900:	e1a02000 	mov	r2, r0
	bam_add_one_desc(&bam,
8f611904:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f611908:	e3480f72 	movt	r0, #36722	; 0x8f72
8f61190c:	ebfffe85 	bl	8f611328 <bam_add_one_desc>
	bam_sys_gen_event(&bam, CMD_PIPE_INDEX, num_desc);
8f611910:	e1a02004 	mov	r2, r4
8f611914:	e1a01005 	mov	r1, r5
8f611918:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f61191c:	e3480f72 	movt	r0, #36722	; 0x8f72
8f611920:	ebfffe39 	bl	8f61120c <bam_sys_gen_event>
	bam_wait_for_interrupt(&bam, CMD_PIPE_INDEX, P_PRCSD_DESC_EN_MASK);
8f611924:	e1a02004 	mov	r2, r4
8f611928:	e1a01005 	mov	r1, r5
8f61192c:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f611930:	e3480f72 	movt	r0, #36722	; 0x8f72
8f611934:	ebfffe06 	bl	8f611154 <bam_wait_for_interrupt>
	bam_read_offset_update(&bam, CMD_PIPE_INDEX);
8f611938:	e59f302c 	ldr	r3, [pc, #44]	; 8f61196c <qpic_nand_erased_status_reset+0x150>
8f61193c:	e5932000 	ldr	r2, [r3]
8f611940:	e59d300c 	ldr	r3, [r13, #12]
8f611944:	e0332002 	eors	r2, r3, r2
8f611948:	e3a03000 	mov	r3, #0
8f61194c:	1a000005 	bne	8f611968 <qpic_nand_erased_status_reset+0x14c>
8f611950:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f611954:	e1a01005 	mov	r1, r5
8f611958:	e3480f72 	movt	r0, #36722	; 0x8f72
}
8f61195c:	e28dd010 	add	r13, r13, #16
8f611960:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, r14}
	bam_read_offset_update(&bam, CMD_PIPE_INDEX);
8f611964:	eafffe54 	b	8f6112bc <bam_read_offset_update>
8f611968:	eb008494 	bl	8f632bc0 <__stack_chk_fail>
8f61196c:	8f74221c 	.word	0x8f74221c

8f611970 <qpic_nand_check_status.part.0>:
qpic_nand_check_status(uint32_t status)
8f611970:	e59f309c 	ldr	r3, [pc, #156]	; 8f611a14 <qpic_nand_check_status.part.0+0xa4>
		if (status & NAND_FLASH_OP_ERR)
8f611974:	e3100010 	tst	r0, #16
qpic_nand_check_status(uint32_t status)
8f611978:	e92d4010 	push	{r4, r14}
8f61197c:	e24dd008 	sub	r13, r13, #8
8f611980:	e5933000 	ldr	r3, [r3]
8f611984:	e58d3004 	str	r3, [r13, #4]
8f611988:	e3a03000 	mov	r3, #0
8f61198c:	e1a04000 	mov	r4, r0
		if (status & NAND_FLASH_OP_ERR)
8f611990:	1a000010 	bne	8f6119d8 <qpic_nand_check_status.part.0+0x68>
		if (!(status & NAND_FLASH_ERR))
8f611994:	e2140e15 	ands	r0, r4, #336	; 0x150
8f611998:	0a000006 	beq	8f6119b8 <qpic_nand_check_status.part.0+0x48>
		dprintf(CRITICAL, "Nand Flash error. Status = %d\n", status);
8f61199c:	e1a01004 	mov	r1, r4
8f6119a0:	e30401b0 	movw	r0, #16816	; 0x41b0
8f6119a4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6119a8:	eb0083f1 	bl	8f632974 <_dprintf>
			return NANDC_RESULT_FAILURE;
8f6119ac:	e3140040 	tst	r4, #64	; 0x40
8f6119b0:	13a00002 	movne	r0, #2
8f6119b4:	03a00001 	moveq	r0, #1
}
8f6119b8:	e59f3054 	ldr	r3, [pc, #84]	; 8f611a14 <qpic_nand_check_status.part.0+0xa4>
8f6119bc:	e5932000 	ldr	r2, [r3]
8f6119c0:	e59d3004 	ldr	r3, [r13, #4]
8f6119c4:	e0332002 	eors	r2, r3, r2
8f6119c8:	e3a03000 	mov	r3, #0
8f6119cc:	1a00000f 	bne	8f611a10 <qpic_nand_check_status.part.0+0xa0>
8f6119d0:	e28dd008 	add	r13, r13, #8
8f6119d4:	e8bd8010 	pop	{r4, r15}
			erase_sts = qpic_nand_read_reg(NAND_ERASED_CW_DETECT_STATUS, 0);
8f6119d8:	e30c3e6c 	movw	r3, #52844	; 0xce6c
8f6119dc:	e3483f72 	movt	r3, #36722	; 0x8f72
8f6119e0:	e3a01000 	mov	r1, #0
8f6119e4:	e5930000 	ldr	r0, [r3]
8f6119e8:	e28000ec 	add	r0, r0, #236	; 0xec
8f6119ec:	ebffff4c 	bl	8f611724 <qpic_nand_read_reg>
			if ((erase_sts & (1 << NAND_ERASED_CW_DETECT_STATUS_PAGE_ALL_ERASED)))
8f6119f0:	e3100080 	tst	r0, #128	; 0x80
8f6119f4:	0affffe6 	beq	8f611994 <qpic_nand_check_status.part.0+0x24>
				qpic_nand_erased_status_reset(ce_array, 0);
8f6119f8:	e30202b0 	movw	r0, #8880	; 0x22b0
8f6119fc:	e3a01000 	mov	r1, #0
8f611a00:	e3480f74 	movt	r0, #36724	; 0x8f74
				status &= ~NAND_FLASH_OP_ERR;
8f611a04:	e3c44010 	bic	r4, r4, #16
				qpic_nand_erased_status_reset(ce_array, 0);
8f611a08:	ebffff83 	bl	8f61181c <qpic_nand_erased_status_reset>
8f611a0c:	eaffffe0 	b	8f611994 <qpic_nand_check_status.part.0+0x24>
}
8f611a10:	eb00846a 	bl	8f632bc0 <__stack_chk_fail>
8f611a14:	8f74221c 	.word	0x8f74221c

8f611a18 <qpic_nand_add_cmd_ce>:
 * Returns the address where the next cmd element can be added.
 */
struct cmd_element*
qpic_nand_add_cmd_ce(struct cfg_params *cfg,
                                 struct cmd_element *start)
{
8f611a18:	e59f3074 	ldr	r3, [pc, #116]	; 8f611a94 <qpic_nand_add_cmd_ce+0x7c>
8f611a1c:	e92d4070 	push	{r4, r5, r6, r14}
8f611a20:	e24dd008 	sub	r13, r13, #8
8f611a24:	e1a05000 	mov	r5, r0
8f611a28:	e5933000 	ldr	r3, [r3]
8f611a2c:	e58d3004 	str	r3, [r13, #4]
8f611a30:	e3a03000 	mov	r3, #0
	struct cmd_element *cmd_list_ptr;

	cmd_list_ptr = qpic_nand_add_addr_n_cfg_ce(cfg, start);
8f611a34:	ebffff0d 	bl	8f611670 <qpic_nand_add_addr_n_cfg_ce>

	bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_CMD, (uint32_t)cfg->cmd, CE_WRITE_TYPE);
8f611a38:	e30c6e6c 	movw	r6, #52844	; 0xce6c
8f611a3c:	e3486f72 	movt	r6, #36722	; 0x8f72
8f611a40:	e5952010 	ldr	r2, [r5, #16]
8f611a44:	e3a03000 	mov	r3, #0
8f611a48:	e5961000 	ldr	r1, [r6]
	cmd_list_ptr = qpic_nand_add_addr_n_cfg_ce(cfg, start);
8f611a4c:	e1a04000 	mov	r4, r0
	bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_CMD, (uint32_t)cfg->cmd, CE_WRITE_TYPE);
8f611a50:	ebfffeec 	bl	8f611608 <bam_add_cmd_element>
	cmd_list_ptr++;

	bam_add_cmd_element(cmd_list_ptr, NAND_EXEC_CMD, (uint32_t)cfg->exec, CE_WRITE_TYPE);
8f611a54:	e5961000 	ldr	r1, [r6]
8f611a58:	e3a03000 	mov	r3, #0
8f611a5c:	e595201c 	ldr	r2, [r5, #28]
8f611a60:	e2840010 	add	r0, r4, #16
8f611a64:	e2811010 	add	r1, r1, #16
8f611a68:	ebfffee6 	bl	8f611608 <bam_add_cmd_element>
	cmd_list_ptr++;

	return cmd_list_ptr;
}
8f611a6c:	e59f3020 	ldr	r3, [pc, #32]	; 8f611a94 <qpic_nand_add_cmd_ce+0x7c>
8f611a70:	e5932000 	ldr	r2, [r3]
8f611a74:	e59d3004 	ldr	r3, [r13, #4]
8f611a78:	e0332002 	eors	r2, r3, r2
8f611a7c:	e3a03000 	mov	r3, #0
8f611a80:	1a000002 	bne	8f611a90 <qpic_nand_add_cmd_ce+0x78>
8f611a84:	e2840020 	add	r0, r4, #32
8f611a88:	e28dd008 	add	r13, r13, #8
8f611a8c:	e8bd8070 	pop	{r4, r5, r6, r15}
8f611a90:	eb00844a 	bl	8f632bc0 <__stack_chk_fail>
8f611a94:	8f74221c 	.word	0x8f74221c

8f611a98 <qpic_nand_add_isbad_cmd_ce>:
}

struct cmd_element*
qpic_nand_add_isbad_cmd_ce(struct cfg_params *cfg,
                                 struct cmd_element *start)
{
8f611a98:	e92d4070 	push	{r4, r5, r6, r14}
	struct cmd_element *cmd_list_ptr = start;

	bam_add_cmd_element(cmd_list_ptr, NAND_DEV0_ECC_CFG, (uint32_t)cfg->ecc_cfg, CE_WRITE_TYPE);
8f611a9c:	e30c6e6c 	movw	r6, #52844	; 0xce6c
8f611aa0:	e3486f72 	movt	r6, #36722	; 0x8f72
{
8f611aa4:	e1a04001 	mov	r4, r1
8f611aa8:	e24dd008 	sub	r13, r13, #8
8f611aac:	e1a05000 	mov	r5, r0
	bam_add_cmd_element(cmd_list_ptr, NAND_DEV0_ECC_CFG, (uint32_t)cfg->ecc_cfg, CE_WRITE_TYPE);
8f611ab0:	e5962000 	ldr	r2, [r6]
8f611ab4:	e3a03000 	mov	r3, #0
8f611ab8:	e2821028 	add	r1, r2, #40	; 0x28
{
8f611abc:	e59f205c 	ldr	r2, [pc, #92]	; 8f611b20 <qpic_nand_add_isbad_cmd_ce+0x88>
8f611ac0:	e5922000 	ldr	r2, [r2]
8f611ac4:	e58d2004 	str	r2, [r13, #4]
8f611ac8:	e3a02000 	mov	r2, #0
	bam_add_cmd_element(cmd_list_ptr, NAND_DEV0_ECC_CFG, (uint32_t)cfg->ecc_cfg, CE_WRITE_TYPE);
8f611acc:	e5902014 	ldr	r2, [r0, #20]
8f611ad0:	e1a00004 	mov	r0, r4
8f611ad4:	ebfffecb 	bl	8f611608 <bam_add_cmd_element>
	cmd_list_ptr++;

	bam_add_cmd_element(cmd_list_ptr, NAND_READ_LOCATION_n(0), (uint32_t)cfg->addr_loc_0, CE_WRITE_TYPE);
8f611ad8:	e5961000 	ldr	r1, [r6]
8f611adc:	e5952018 	ldr	r2, [r5, #24]
8f611ae0:	e3a03000 	mov	r3, #0
8f611ae4:	e2840010 	add	r0, r4, #16
8f611ae8:	e2811ef2 	add	r1, r1, #3872	; 0xf20
8f611aec:	ebfffec5 	bl	8f611608 <bam_add_cmd_element>
	cmd_list_ptr++;

	cmd_list_ptr = qpic_nand_add_cmd_ce(cfg, cmd_list_ptr);
8f611af0:	e59f3028 	ldr	r3, [pc, #40]	; 8f611b20 <qpic_nand_add_isbad_cmd_ce+0x88>
8f611af4:	e5932000 	ldr	r2, [r3]
8f611af8:	e59d3004 	ldr	r3, [r13, #4]
8f611afc:	e0332002 	eors	r2, r3, r2
8f611b00:	e3a03000 	mov	r3, #0
8f611b04:	1a000004 	bne	8f611b1c <qpic_nand_add_isbad_cmd_ce+0x84>
8f611b08:	e2841020 	add	r1, r4, #32
8f611b0c:	e1a00005 	mov	r0, r5

	return cmd_list_ptr;
}
8f611b10:	e28dd008 	add	r13, r13, #8
8f611b14:	e8bd4070 	pop	{r4, r5, r6, r14}
	cmd_list_ptr = qpic_nand_add_cmd_ce(cfg, cmd_list_ptr);
8f611b18:	eaffffbe 	b	8f611a18 <qpic_nand_add_cmd_ce>
8f611b1c:	eb008427 	bl	8f632bc0 <__stack_chk_fail>
8f611b20:	8f74221c 	.word	0x8f74221c

8f611b24 <qpic_nand_block_isbad>:
 * @page - number of page the block starts at
 *
 * Returns nand_result_t
 */
nand_result_t qpic_nand_block_isbad(unsigned page)
{
8f611b24:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
	unsigned cwperpage;
	struct cfg_params params;
	static uint8_t bad_block[4];
	unsigned nand_ret = NANDC_RESULT_SUCCESS;
	uint32_t blk = page / flash.num_pages_per_blk;
8f611b28:	e30c5e18 	movw	r5, #52760	; 0xce18
8f611b2c:	e3485f72 	movt	r5, #36722	; 0x8f72
{
8f611b30:	e59f32a8 	ldr	r3, [pc, #680]	; 8f611de0 <qpic_nand_block_isbad+0x2bc>
8f611b34:	e24dd034 	sub	r13, r13, #52	; 0x34
8f611b38:	e1a04000 	mov	r4, r0
	uint32_t blk = page / flash.num_pages_per_blk;
8f611b3c:	e5951028 	ldr	r1, [r5, #40]	; 0x28
{
8f611b40:	e5933000 	ldr	r3, [r3]
8f611b44:	e58d302c 	str	r3, [r13, #44]	; 0x2c
8f611b48:	e3a03000 	mov	r3, #0
	uint32_t blk = page / flash.num_pages_per_blk;
8f611b4c:	fa00ac21 	blx	8f63cbd8 <__udivsi3>

	if (bbtbl[blk] == NAND_BAD_BLK_VALUE_IS_GOOD)
8f611b50:	e30c7df8 	movw	r7, #52728	; 0xcdf8
8f611b54:	e3487f72 	movt	r7, #36722	; 0x8f72
8f611b58:	e5973000 	ldr	r3, [r7]
8f611b5c:	e7d33000 	ldrb	r3, [r3, r0]
8f611b60:	e3530002 	cmp	r3, #2
8f611b64:	0a00008e 	beq	8f611da4 <qpic_nand_block_isbad+0x280>
		return NANDC_RESULT_SUCCESS;
	else if (bbtbl[blk] == NAND_BAD_BLK_VALUE_IS_BAD)
8f611b68:	e3530001 	cmp	r3, #1
8f611b6c:	0a000098 	beq	8f611dd4 <qpic_nand_block_isbad+0x2b0>
		/* Read the bad block value from the flash.
		 * Bad block value is stored in the first page of the block.
		 */
		/* Read the first page in the block. */
		/* Ensure we always read first page of block */
		if (page & flash.num_pages_per_blk_mask)
8f611b70:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
	cmd_list_ptr = qpic_nand_add_isbad_cmd_ce(params, cmd_list_ptr);
8f611b74:	e30282b0 	movw	r8, #8880	; 0x22b0
8f611b78:	e3488f74 	movt	r8, #36724	; 0x8f74
8f611b7c:	e1a06000 	mov	r6, r0
		if (page & flash.num_pages_per_blk_mask)
8f611b80:	e1130004 	tst	r3, r4
	cmd_list_ptr = qpic_nand_add_isbad_cmd_ce(params, cmd_list_ptr);
8f611b84:	e28d000c 	add	r0, r13, #12
			page = page - (page & flash.num_pages_per_blk_mask);
8f611b88:	11c44003 	bicne	r4, r4, r3

		cwperpage = flash.cws_per_page;
8f611b8c:	e595303c 	ldr	r3, [r5, #60]	; 0x3c
	cmd_list_ptr = qpic_nand_add_isbad_cmd_ce(params, cmd_list_ptr);
8f611b90:	e1a01008 	mov	r1, r8
		 * This will be all 0s.
		 */
		params.addr1 = (page >> 16) & 0xff;
		params.addr_loc_0 = NAND_RD_LOC_OFFSET(0);
		params.addr_loc_0 |= NAND_RD_LOC_LAST_BIT(1);
		params.addr_loc_0 |= NAND_RD_LOC_SIZE(4); /* Read 4 bytes */
8f611b94:	e3a02000 	mov	r2, #0
8f611b98:	e3482004 	movt	r2, #32772	; 0x8004
8f611b9c:	e58d2024 	str	r2, [r13, #36]	; 0x24
		params.addr0 = (page << 16) | (USER_DATA_BYTES_PER_CW * cwperpage);
8f611ba0:	e1a03483 	lsl	r3, r3, #9
8f611ba4:	e1833804 	orr	r3, r3, r4, lsl #16
8f611ba8:	e58d300c 	str	r3, [r13, #12]
		params.ecc_cfg = ecc_bch_cfg | 0x1; /* Disable ECC */
8f611bac:	e30c3e0c 	movw	r3, #52748	; 0xce0c
8f611bb0:	e3483f72 	movt	r3, #36722	; 0x8f72
		params.addr1 = (page >> 16) & 0xff;
8f611bb4:	e7e74854 	ubfx	r4, r4, #16, #8
8f611bb8:	e58d4010 	str	r4, [r13, #16]
		params.ecc_cfg = ecc_bch_cfg | 0x1; /* Disable ECC */
8f611bbc:	e5933000 	ldr	r3, [r3]
		params.exec = 1;
8f611bc0:	e3a04001 	mov	r4, #1
8f611bc4:	e58d4028 	str	r4, [r13, #40]	; 0x28
		params.ecc_cfg = ecc_bch_cfg | 0x1; /* Disable ECC */
8f611bc8:	e3833001 	orr	r3, r3, #1
8f611bcc:	e58d3020 	str	r3, [r13, #32]
		params.cfg1 = cfg1_raw;
8f611bd0:	e30c3e08 	movw	r3, #52744	; 0xce08
8f611bd4:	e3483f72 	movt	r3, #36722	; 0x8f72
8f611bd8:	e5933000 	ldr	r3, [r3]
8f611bdc:	e58d3018 	str	r3, [r13, #24]
		params.cfg0 = cfg0_raw & ~(7U << NAND_DEV0_CFG0_CW_PER_PAGE_SHIFT);
8f611be0:	e30c3e00 	movw	r3, #52736	; 0xce00
8f611be4:	e3483f72 	movt	r3, #36722	; 0x8f72
8f611be8:	e5933000 	ldr	r3, [r3]
8f611bec:	e3c33d07 	bic	r3, r3, #448	; 0x1c0
8f611bf0:	e58d3014 	str	r3, [r13, #20]
		params.cmd =  NAND_CMD_PAGE_READ_ECC;
8f611bf4:	e3a03033 	mov	r3, #51	; 0x33
8f611bf8:	e58d301c 	str	r3, [r13, #28]
	cmd_list_ptr = qpic_nand_add_isbad_cmd_ce(params, cmd_list_ptr);
8f611bfc:	ebffffa5 	bl	8f611a98 <qpic_nand_add_isbad_cmd_ce>
8f611c00:	e1a09000 	mov	r9, r0
					 (unsigned char*)PA((addr_t)cmd_list_ptr_start),
8f611c04:	e1a00008 	mov	r0, r8
8f611c08:	ebffbed1 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f611c0c:	e1a02000 	mov	r2, r0
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f611c10:	e0490008 	sub	r0, r9, r8
					 (unsigned char*)PA((addr_t)cmd_list_ptr_start),
8f611c14:	e1a08002 	mov	r8, r2
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f611c18:	ebffbecd 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	bam_add_one_desc(&bam,
8f611c1c:	e1a02008 	mov	r2, r8
8f611c20:	e3a01002 	mov	r1, #2
	status = qpic_nand_read_reg(NAND_FLASH_STATUS, 0);
8f611c24:	e30c8e6c 	movw	r8, #52844	; 0xce6c
8f611c28:	e3488f72 	movt	r8, #36722	; 0x8f72
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f611c2c:	e1a03000 	mov	r3, r0
	bam_add_one_desc(&bam,
8f611c30:	e3a0009c 	mov	r0, #156	; 0x9c
8f611c34:	e58d0000 	str	r0, [r13]
8f611c38:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f611c3c:	e3480f72 	movt	r0, #36722	; 0x8f72
8f611c40:	ebfffdb8 	bl	8f611328 <bam_add_one_desc>
				 (unsigned char *)PA((addr_t)bad_block),
8f611c44:	e30c0d94 	movw	r0, #52628	; 0xcd94
8f611c48:	e3480f72 	movt	r0, #36722	; 0x8f72
8f611c4c:	ebffbec0 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	bam_add_desc(&bam,
8f611c50:	e3a03004 	mov	r3, #4
8f611c54:	e1a01004 	mov	r1, r4
				 (unsigned char *)PA((addr_t)bad_block),
8f611c58:	e1a02000 	mov	r2, r0
	bam_add_desc(&bam,
8f611c5c:	e3a00080 	mov	r0, #128	; 0x80
8f611c60:	e58d0000 	str	r0, [r13]
8f611c64:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f611c68:	e3480f72 	movt	r0, #36722	; 0x8f72
8f611c6c:	ebfffe07 	bl	8f611490 <bam_add_desc>
	arch_clean_invalidate_cache_range((addr_t)bad_block, sizeof(uint32_t));
8f611c70:	e3a01004 	mov	r1, #4
8f611c74:	e30c0d94 	movw	r0, #52628	; 0xcd94
8f611c78:	e3480f72 	movt	r0, #36722	; 0x8f72
8f611c7c:	eb003cc7 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	bam_sys_gen_event(&bam, CMD_PIPE_INDEX, num_desc);
8f611c80:	e1a02004 	mov	r2, r4
8f611c84:	e3a01002 	mov	r1, #2
8f611c88:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f611c8c:	e3480f72 	movt	r0, #36722	; 0x8f72
8f611c90:	ebfffd5d 	bl	8f61120c <bam_sys_gen_event>
	bam_wait_for_interrupt(&bam, CMD_PIPE_INDEX, P_PRCSD_DESC_EN_MASK);
8f611c94:	e1a02004 	mov	r2, r4
8f611c98:	e3a01002 	mov	r1, #2
8f611c9c:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f611ca0:	e3480f72 	movt	r0, #36722	; 0x8f72
8f611ca4:	ebfffd2a 	bl	8f611154 <bam_wait_for_interrupt>
	bam_read_offset_update(&bam, CMD_PIPE_INDEX);
8f611ca8:	e3a01002 	mov	r1, #2
8f611cac:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f611cb0:	e3480f72 	movt	r0, #36722	; 0x8f72
8f611cb4:	ebfffd80 	bl	8f6112bc <bam_read_offset_update>
	arch_clean_invalidate_cache_range((addr_t)bad_block, sizeof(uint32_t));
8f611cb8:	e3a01004 	mov	r1, #4
8f611cbc:	e30c0d94 	movw	r0, #52628	; 0xcd94
8f611cc0:	e3480f72 	movt	r0, #36722	; 0x8f72
8f611cc4:	eb003cb5 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	status = qpic_nand_read_reg(NAND_FLASH_STATUS, 0);
8f611cc8:	e5980000 	ldr	r0, [r8]
8f611ccc:	e3a01000 	mov	r1, #0
8f611cd0:	e2800014 	add	r0, r0, #20
8f611cd4:	ebfffe92 	bl	8f611724 <qpic_nand_read_reg>
	if (status & NAND_FLASH_ERR)
8f611cd8:	e3100e15 	tst	r0, #336	; 0x150
8f611cdc:	0a000013 	beq	8f611d30 <qpic_nand_block_isbad+0x20c>
8f611ce0:	ebffff22 	bl	8f611970 <qpic_nand_check_status.part.0>
	status = qpic_nand_read_reg(NAND_FLASH_STATUS, BAM_DESC_UNLOCK_FLAG);
8f611ce4:	e5983000 	ldr	r3, [r8]
8f611ce8:	e3a01002 	mov	r1, #2
8f611cec:	e1a08000 	mov	r8, r0
8f611cf0:	e2830014 	add	r0, r3, #20
8f611cf4:	ebfffe8a 	bl	8f611724 <qpic_nand_read_reg>
	if (nand_ret)
8f611cf8:	e3580000 	cmp	r8, #0
8f611cfc:	0a00000f 	beq	8f611d40 <qpic_nand_block_isbad+0x21c>

		if (qpic_nand_block_isbad_exec(&params, bad_block))
		{
			dprintf(CRITICAL,
8f611d00:	e30401d0 	movw	r0, #16848	; 0x41d0
8f611d04:	e3480f70 	movt	r0, #36720	; 0x8f70
8f611d08:	eb008319 	bl	8f632974 <_dprintf>
					"Could not read bad block value\n");
			return NANDC_RESULT_FAILURE;
8f611d0c:	e1a00004 	mov	r0, r4
			bbtbl[blk] = NAND_BAD_BLK_VALUE_IS_GOOD;


		return nand_ret;
	}
}
8f611d10:	e59f30c8 	ldr	r3, [pc, #200]	; 8f611de0 <qpic_nand_block_isbad+0x2bc>
8f611d14:	e5932000 	ldr	r2, [r3]
8f611d18:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
8f611d1c:	e0332002 	eors	r2, r3, r2
8f611d20:	e3a03000 	mov	r3, #0
8f611d24:	1a00002c 	bne	8f611ddc <qpic_nand_block_isbad+0x2b8>
8f611d28:	e28dd034 	add	r13, r13, #52	; 0x34
8f611d2c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
	status = qpic_nand_read_reg(NAND_FLASH_STATUS, BAM_DESC_UNLOCK_FLAG);
8f611d30:	e5980000 	ldr	r0, [r8]
8f611d34:	e3a01002 	mov	r1, #2
8f611d38:	e2800014 	add	r0, r0, #20
8f611d3c:	ebfffe78 	bl	8f611724 <qpic_nand_read_reg>
	bam_wait_for_interrupt(&bam, pipe_num, P_PRCSD_DESC_EN_MASK);
8f611d40:	e3a02001 	mov	r2, #1
8f611d44:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f611d48:	e1a01002 	mov	r1, r2
8f611d4c:	e3480f72 	movt	r0, #36722	; 0x8f72
8f611d50:	ebfffcff 	bl	8f611154 <bam_wait_for_interrupt>
	bam_read_offset_update(&bam, pipe_num);
8f611d54:	e3a01001 	mov	r1, #1
8f611d58:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f611d5c:	e3480f72 	movt	r0, #36722	; 0x8f72
8f611d60:	ebfffd55 	bl	8f6112bc <bam_read_offset_update>
		if (flash.widebus)
8f611d64:	e5953030 	ldr	r3, [r5, #48]	; 0x30
8f611d68:	e3530000 	cmp	r3, #0
8f611d6c:	0a00000e 	beq	8f611dac <qpic_nand_block_isbad+0x288>
			if (bad_block[0] != 0xFF && bad_block[1] != 0xFF)
8f611d70:	e30c3d94 	movw	r3, #52628	; 0xcd94
8f611d74:	e3483f72 	movt	r3, #36722	; 0x8f72
8f611d78:	e5d32000 	ldrb	r2, [r3]
8f611d7c:	e35200ff 	cmp	r2, #255	; 0xff
8f611d80:	0a000007 	beq	8f611da4 <qpic_nand_block_isbad+0x280>
8f611d84:	e5d33001 	ldrb	r3, [r3, #1]
8f611d88:	e35300ff 	cmp	r3, #255	; 0xff
8f611d8c:	0a000004 	beq	8f611da4 <qpic_nand_block_isbad+0x280>
			bbtbl[blk] = NAND_BAD_BLK_VALUE_IS_BAD;
8f611d90:	e5973000 	ldr	r3, [r7]
8f611d94:	e3a02001 	mov	r2, #1
8f611d98:	e3a00006 	mov	r0, #6
8f611d9c:	e7c32006 	strb	r2, [r3, r6]
			nand_ret = NANDC_RESULT_BAD_BLOCK;
8f611da0:	eaffffda 	b	8f611d10 <qpic_nand_block_isbad+0x1ec>
		return NANDC_RESULT_SUCCESS;
8f611da4:	e3a00000 	mov	r0, #0
8f611da8:	eaffffd8 	b	8f611d10 <qpic_nand_block_isbad+0x1ec>
		else if (bad_block[0] != 0xFF)
8f611dac:	e30c2d94 	movw	r2, #52628	; 0xcd94
8f611db0:	e3482f72 	movt	r2, #36722	; 0x8f72
8f611db4:	e5d22000 	ldrb	r2, [r2]
8f611db8:	e35200ff 	cmp	r2, #255	; 0xff
8f611dbc:	1afffff3 	bne	8f611d90 <qpic_nand_block_isbad+0x26c>
			bbtbl[blk] = NAND_BAD_BLK_VALUE_IS_GOOD;
8f611dc0:	e5972000 	ldr	r2, [r7]
8f611dc4:	e3a01002 	mov	r1, #2
8f611dc8:	e1a00003 	mov	r0, r3
8f611dcc:	e7c21006 	strb	r1, [r2, r6]
8f611dd0:	eaffffce 	b	8f611d10 <qpic_nand_block_isbad+0x1ec>
		return NANDC_RESULT_BAD_BLOCK;
8f611dd4:	e3a00006 	mov	r0, #6
8f611dd8:	eaffffcc 	b	8f611d10 <qpic_nand_block_isbad+0x1ec>
}
8f611ddc:	eb008377 	bl	8f632bc0 <__stack_chk_fail>
8f611de0:	8f74221c 	.word	0x8f74221c

8f611de4 <qpic_nand_read_page>:
}

/* Note: No support for raw reads. */
static int
qpic_nand_read_page(uint32_t page, unsigned char* buffer, unsigned char* spareaddr)
{
8f611de4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f611de8:	e24ddf53 	sub	r13, r13, #332	; 0x14c
8f611dec:	e59f3814 	ldr	r3, [pc, #2068]	; 8f612608 <qpic_nand_read_page+0x824>
8f611df0:	e1a04000 	mov	r4, r0
8f611df4:	e58d2014 	str	r2, [r13, #20]
	struct cfg_params params;
	uint32_t ecc;
	uint32_t flash_sts[QPIC_NAND_MAX_CWS_IN_PAGE] = {0};
8f611df8:	e28d007c 	add	r0, r13, #124	; 0x7c
8f611dfc:	e3a02028 	mov	r2, #40	; 0x28
{
8f611e00:	e1a0b001 	mov	r11, r1
	uint32_t flash_sts[QPIC_NAND_MAX_CWS_IN_PAGE] = {0};
8f611e04:	e3a01000 	mov	r1, #0
8f611e08:	e58de034 	str	r14, [r13, #52]	; 0x34
{
8f611e0c:	e5933000 	ldr	r3, [r3]
8f611e10:	e58d3144 	str	r3, [r13, #324]	; 0x144
8f611e14:	e3a03000 	mov	r3, #0
	uint32_t flash_sts[QPIC_NAND_MAX_CWS_IN_PAGE] = {0};
8f611e18:	eb008929 	bl	8f6342c4 <memset>
	uint32_t buffer_sts[QPIC_NAND_MAX_CWS_IN_PAGE] = {0};
8f611e1c:	e3a02028 	mov	r2, #40	; 0x28
8f611e20:	e3a01000 	mov	r1, #0
8f611e24:	e28d00a4 	add	r0, r13, #164	; 0xa4
#endif

	/* UD bytes in last CW is 512 - cws_per_page *4.
	 * Since each of the CW read earlier reads 4 spare bytes.
	 */
	uint16_t ud_bytes_in_last_cw = USER_DATA_BYTES_PER_CW - ((flash.cws_per_page - 1) << 2);
8f611e28:	e30c9e18 	movw	r9, #52760	; 0xce18
	uint32_t buffer_sts[QPIC_NAND_MAX_CWS_IN_PAGE] = {0};
8f611e2c:	eb008924 	bl	8f6342c4 <memset>
	uint32_t erased_cw_sts[QPIC_NAND_MAX_CWS_IN_PAGE] = {0};
8f611e30:	e3a02028 	mov	r2, #40	; 0x28
8f611e34:	e3a01000 	mov	r1, #0
8f611e38:	e28d00cc 	add	r0, r13, #204	; 0xcc
8f611e3c:	eb008920 	bl	8f6342c4 <memset>
	uint16_t oob_bytes = DATA_BYTES_IN_IMG_PER_CW - ud_bytes_in_last_cw;

	params.addr0 = page << 16;
	params.addr1 = (page >> 16) & 0xff;
	params.cfg0 = cfg0;
8f611e40:	e30c3dfc 	movw	r3, #52732	; 0xcdfc
8f611e44:	e3483f72 	movt	r3, #36722	; 0x8f72
	uint16_t ud_bytes_in_last_cw = USER_DATA_BYTES_PER_CW - ((flash.cws_per_page - 1) << 2);
8f611e48:	e3489f72 	movt	r9, #36722	; 0x8f72

	addr_loc_1 = NAND_RD_LOC_OFFSET(ud_bytes_in_last_cw);
	addr_loc_1 |= NAND_RD_LOC_SIZE(oob_bytes);
	addr_loc_1 |= NAND_RD_LOC_LAST_BIT(1);

	status = qpic_nand_block_isbad(page);
8f611e4c:	e1a00004 	mov	r0, r4
	params.addr1 = (page >> 16) & 0xff;
8f611e50:	e7e72854 	ubfx	r2, r4, #16, #8
	params.cfg0 = cfg0;
8f611e54:	e5933000 	ldr	r3, [r3]
	uint16_t ud_bytes_in_last_cw = USER_DATA_BYTES_PER_CW - ((flash.cws_per_page - 1) << 2);
8f611e58:	e599503c 	ldr	r5, [r9, #60]	; 0x3c
	params.addr1 = (page >> 16) & 0xff;
8f611e5c:	e58d2030 	str	r2, [r13, #48]	; 0x30
	params.cfg0 = cfg0;
8f611e60:	e58d3044 	str	r3, [r13, #68]	; 0x44
	params.cfg1 = cfg1;
8f611e64:	e30c3e04 	movw	r3, #52740	; 0xce04
8f611e68:	e3483f72 	movt	r3, #36722	; 0x8f72
	params.addr1 = (page >> 16) & 0xff;
8f611e6c:	e58d2040 	str	r2, [r13, #64]	; 0x40
	params.cfg1 = cfg1;
8f611e70:	e5933000 	ldr	r3, [r3]
8f611e74:	e58d3048 	str	r3, [r13, #72]	; 0x48
	ecc = ecc_bch_cfg;
8f611e78:	e30c3e0c 	movw	r3, #52748	; 0xce0c
8f611e7c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f611e80:	e5933000 	ldr	r3, [r3]
8f611e84:	e58d3018 	str	r3, [r13, #24]
	params.addr0 = page << 16;
8f611e88:	e1a03804 	lsl	r3, r4, #16
8f611e8c:	e58d302c 	str	r3, [r13, #44]	; 0x2c
8f611e90:	e58d303c 	str	r3, [r13, #60]	; 0x3c
	params.cmd = NAND_CMD_PAGE_READ_ECC;
8f611e94:	e3a03033 	mov	r3, #51	; 0x33
8f611e98:	e58d304c 	str	r3, [r13, #76]	; 0x4c
	params.exec = 1;
8f611e9c:	e3a03001 	mov	r3, #1
8f611ea0:	e58d3058 	str	r3, [r13, #88]	; 0x58
	status = qpic_nand_block_isbad(page);
8f611ea4:	ebffff1e 	bl	8f611b24 <qpic_nand_block_isbad>

	if (status)
8f611ea8:	e2504000 	subs	r4, r0, #0
8f611eac:	0a000008 	beq	8f611ed4 <qpic_nand_read_page+0xf0>
		}
	}

qpic_nand_read_page_error:
	return nand_ret;
}
8f611eb0:	e59f3750 	ldr	r3, [pc, #1872]	; 8f612608 <qpic_nand_read_page+0x824>
8f611eb4:	e5932000 	ldr	r2, [r3]
8f611eb8:	e59d3144 	ldr	r3, [r13, #324]	; 0x144
8f611ebc:	e0332002 	eors	r2, r3, r2
8f611ec0:	e3a03000 	mov	r3, #0
8f611ec4:	1a0001ce 	bne	8f612604 <qpic_nand_read_page+0x820>
8f611ec8:	e1a00004 	mov	r0, r4
8f611ecc:	e28ddf53 	add	r13, r13, #332	; 0x14c
8f611ed0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	qpic_nand_erased_status_reset(ce_array, BAM_DESC_LOCK_FLAG);
8f611ed4:	e3a01004 	mov	r1, #4
8f611ed8:	e30202b0 	movw	r0, #8880	; 0x22b0
8f611edc:	e3480f74 	movt	r0, #36724	; 0x8f74
8f611ee0:	ebfffe4d 	bl	8f61181c <qpic_nand_erased_status_reset>
	for (i = 0; i < flash.cws_per_page; i++)
8f611ee4:	e599303c 	ldr	r3, [r9, #60]	; 0x3c
8f611ee8:	e3530000 	cmp	r3, #0
8f611eec:	0a0000b3 	beq	8f6121c0 <qpic_nand_read_page+0x3dc>
	uint16_t ud_bytes_in_last_cw = USER_DATA_BYTES_PER_CW - ((flash.cws_per_page - 1) << 2);
8f611ef0:	e2453001 	sub	r3, r5, #1
	struct cmd_element *cmd_list_ptr_start = ce_array;
8f611ef4:	e30272b0 	movw	r7, #8880	; 0x22b0
8f611ef8:	e30c5e6c 	movw	r5, #52844	; 0xce6c
8f611efc:	e3487f74 	movt	r7, #36724	; 0x8f74
	uint16_t ud_bytes_in_last_cw = USER_DATA_BYTES_PER_CW - ((flash.cws_per_page - 1) << 2);
8f611f00:	e1a03103 	lsl	r3, r3, #2
			bam_add_one_desc(&bam,
8f611f04:	e30c8d98 	movw	r8, #52632	; 0xcd98
8f611f08:	e3485f72 	movt	r5, #36722	; 0x8f72
8f611f0c:	e3488f72 	movt	r8, #36722	; 0x8f72
	uint16_t ud_bytes_in_last_cw = USER_DATA_BYTES_PER_CW - ((flash.cws_per_page - 1) << 2);
8f611f10:	e6ff3073 	uxth	r3, r3
	struct cmd_element *cmd_list_ptr_start = ce_array;
8f611f14:	e58d7008 	str	r7, [r13, #8]
	uint16_t ud_bytes_in_last_cw = USER_DATA_BYTES_PER_CW - ((flash.cws_per_page - 1) << 2);
8f611f18:	e2632c02 	rsb	r2, r3, #512	; 0x200
	uint16_t oob_bytes = DATA_BYTES_IN_IMG_PER_CW - ud_bytes_in_last_cw;
8f611f1c:	e2833004 	add	r3, r3, #4
	uint16_t ud_bytes_in_last_cw = USER_DATA_BYTES_PER_CW - ((flash.cws_per_page - 1) << 2);
8f611f20:	e6ff1072 	uxth	r1, r2
	addr_loc_0 |= NAND_RD_LOC_LAST_BIT(1);
8f611f24:	e3a02000 	mov	r2, #0
8f611f28:	e3482204 	movt	r2, #33284	; 0x8204
8f611f2c:	e58d2010 	str	r2, [r13, #16]
	addr_loc_1 |= NAND_RD_LOC_SIZE(oob_bytes);
8f611f30:	e1812803 	orr	r2, r1, r3, lsl #16
	uint16_t ud_bytes_in_last_cw = USER_DATA_BYTES_PER_CW - ((flash.cws_per_page - 1) << 2);
8f611f34:	e58d1020 	str	r1, [r13, #32]
	uint16_t oob_bytes = DATA_BYTES_IN_IMG_PER_CW - ud_bytes_in_last_cw;
8f611f38:	e6ff3073 	uxth	r3, r3
8f611f3c:	e58d3024 	str	r3, [r13, #36]	; 0x24
	addr_loc_1 |= NAND_RD_LOC_LAST_BIT(1);
8f611f40:	e3823102 	orr	r3, r2, #-2147483648	; 0x80000000
8f611f44:	e58d3028 	str	r3, [r13, #40]	; 0x28
			addr_loc_0 |= NAND_RD_LOC_SIZE(ud_bytes_in_last_cw);
8f611f48:	e1a03801 	lsl	r3, r1, #16
8f611f4c:	e58d301c 	str	r3, [r13, #28]
8f611f50:	ea000062 	b	8f6120e0 <qpic_nand_read_page+0x2fc>
							 (unsigned char *)PA((addr_t)buffer),
8f611f54:	e1a0000b 	mov	r0, r11
8f611f58:	ebffbdfd 	bl	8f601754 <platform_get_virt_to_phys_mapping>
			bam_add_one_desc(&bam,
8f611f5c:	e3a03000 	mov	r3, #0
8f611f60:	e3a01001 	mov	r1, #1
8f611f64:	e58d3000 	str	r3, [r13]
8f611f68:	e3a03f81 	mov	r3, #516	; 0x204
							 (unsigned char *)PA((addr_t)buffer),
8f611f6c:	e1a02000 	mov	r2, r0
			bam_add_one_desc(&bam,
8f611f70:	e1a00008 	mov	r0, r8
8f611f74:	ebfffceb 	bl	8f611328 <bam_add_one_desc>
			bam_sys_gen_event(&bam, DATA_PRODUCER_PIPE_INDEX, num_data_desc);
8f611f78:	e3a02001 	mov	r2, #1
8f611f7c:	e1a01002 	mov	r1, r2
8f611f80:	e1a00008 	mov	r0, r8
8f611f84:	ebfffca0 	bl	8f61120c <bam_sys_gen_event>
		bam_add_cmd_element(cmd_list_ptr,
8f611f88:	e5951000 	ldr	r1, [r5]
8f611f8c:	e3a03000 	mov	r3, #0
8f611f90:	e59d2010 	ldr	r2, [r13, #16]
8f611f94:	e1a00006 	mov	r0, r6
8f611f98:	e2811ef2 	add	r1, r1, #3872	; 0xf20
		cmd_list_ptr++;
8f611f9c:	e286a020 	add	r10, r6, #32
		bam_add_cmd_element(cmd_list_ptr,
8f611fa0:	ebfffd98 	bl	8f611608 <bam_add_cmd_element>
		bam_add_cmd_element(cmd_list_ptr,
8f611fa4:	e5951000 	ldr	r1, [r5]
8f611fa8:	e59d2058 	ldr	r2, [r13, #88]	; 0x58
8f611fac:	e3a03000 	mov	r3, #0
8f611fb0:	e2811010 	add	r1, r1, #16
8f611fb4:	e2860010 	add	r0, r6, #16
8f611fb8:	ebfffd92 	bl	8f611608 <bam_add_cmd_element>
					 (unsigned char*)PA((addr_t)cmd_list_ptr_start),
8f611fbc:	e59d0008 	ldr	r0, [r13, #8]
8f611fc0:	ebffbde3 	bl	8f601754 <platform_get_virt_to_phys_mapping>
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f611fc4:	e59d3008 	ldr	r3, [r13, #8]
		buffer += DATA_BYTES_IN_IMG_PER_CW;
8f611fc8:	e28bbf81 	add	r11, r11, #516	; 0x204
					 (unsigned char*)PA((addr_t)cmd_list_ptr_start),
8f611fcc:	e1a07000 	mov	r7, r0
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f611fd0:	e04a0003 	sub	r0, r10, r3
8f611fd4:	ebffbdde 	bl	8f601754 <platform_get_virt_to_phys_mapping>
		bam_add_one_desc(&bam,
8f611fd8:	e1a02007 	mov	r2, r7
8f611fdc:	e3a01002 	mov	r1, #2
8f611fe0:	e1a07104 	lsl	r7, r4, #2
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f611fe4:	e1a03000 	mov	r3, r0
		bam_add_one_desc(&bam,
8f611fe8:	e3a00018 	mov	r0, #24
8f611fec:	e58d0000 	str	r0, [r13]
8f611ff0:	e1a00008 	mov	r0, r8
8f611ff4:	ebfffccb 	bl	8f611328 <bam_add_one_desc>
		bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_STATUS, (uint32_t)PA((addr_t)&(flash_sts[i])), CE_READ_TYPE);
8f611ff8:	e28d307c 	add	r3, r13, #124	; 0x7c
8f611ffc:	e5951000 	ldr	r1, [r5]
8f612000:	e0830007 	add	r0, r3, r7
8f612004:	e2811014 	add	r1, r1, #20
8f612008:	e58d100c 	str	r1, [r13, #12]
8f61200c:	ebffbdd0 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f612010:	e59d100c 	ldr	r1, [r13, #12]
8f612014:	e3a03001 	mov	r3, #1
8f612018:	e1a02000 	mov	r2, r0
8f61201c:	e1a0000a 	mov	r0, r10
8f612020:	ebfffd78 	bl	8f611608 <bam_add_cmd_element>
		bam_add_cmd_element(cmd_list_ptr, NAND_BUFFER_STATUS, (uint32_t)PA((addr_t)&(buffer_sts[i])), CE_READ_TYPE);
8f612024:	e28d30a4 	add	r3, r13, #164	; 0xa4
8f612028:	e5951000 	ldr	r1, [r5]
8f61202c:	e0830007 	add	r0, r3, r7
8f612030:	e2811018 	add	r1, r1, #24
8f612034:	e58d100c 	str	r1, [r13, #12]
8f612038:	ebffbdc5 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f61203c:	e59d100c 	ldr	r1, [r13, #12]
8f612040:	e3a03001 	mov	r3, #1
8f612044:	e1a02000 	mov	r2, r0
8f612048:	e2860030 	add	r0, r6, #48	; 0x30
8f61204c:	ebfffd6d 	bl	8f611608 <bam_add_cmd_element>
		bam_add_cmd_element(cmd_list_ptr, NAND_ERASED_CW_DETECT_STATUS, (uint32_t)PA((addr_t)&erased_cw_sts[i]), CE_READ_TYPE);
8f612050:	e28d30cc 	add	r3, r13, #204	; 0xcc
8f612054:	e0830007 	add	r0, r3, r7
8f612058:	e5957000 	ldr	r7, [r5]
8f61205c:	ebffbdbc 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f612060:	e3a03001 	mov	r3, #1
8f612064:	e28770ec 	add	r7, r7, #236	; 0xec
8f612068:	e1a01007 	mov	r1, r7
		cmd_list_ptr++;
8f61206c:	e2867050 	add	r7, r6, #80	; 0x50
		bam_add_cmd_element(cmd_list_ptr, NAND_ERASED_CW_DETECT_STATUS, (uint32_t)PA((addr_t)&erased_cw_sts[i]), CE_READ_TYPE);
8f612070:	e1a02000 	mov	r2, r0
8f612074:	e2860040 	add	r0, r6, #64	; 0x40
8f612078:	ebfffd62 	bl	8f611608 <bam_add_cmd_element>
		if (i == flash.cws_per_page - 1)
8f61207c:	e599603c 	ldr	r6, [r9, #60]	; 0x3c
					(unsigned char*)PA((addr_t)cmd_list_temp),
8f612080:	e1a0000a 	mov	r0, r10
		if (i == flash.cws_per_page - 1)
8f612084:	e2466001 	sub	r6, r6, #1
			flags = BAM_DESC_CMD_FLAG;
8f612088:	e1560004 	cmp	r6, r4
	for (i = 0; i < flash.cws_per_page; i++)
8f61208c:	e2844001 	add	r4, r4, #1
			flags = BAM_DESC_CMD_FLAG;
8f612090:	03a0600a 	moveq	r6, #10
8f612094:	13a06008 	movne	r6, #8
					(unsigned char*)PA((addr_t)cmd_list_temp),
8f612098:	ebffbdad 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f61209c:	e1a02000 	mov	r2, r0
					PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_temp),
8f6120a0:	e047000a 	sub	r0, r7, r10
					(unsigned char*)PA((addr_t)cmd_list_temp),
8f6120a4:	e1a0a002 	mov	r10, r2
					PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_temp),
8f6120a8:	ebffbda9 	bl	8f601754 <platform_get_virt_to_phys_mapping>
		bam_add_one_desc(&bam,
8f6120ac:	e1a0200a 	mov	r2, r10
8f6120b0:	e3a01002 	mov	r1, #2
8f6120b4:	e58d6000 	str	r6, [r13]
					PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_temp),
8f6120b8:	e1a03000 	mov	r3, r0
		bam_add_one_desc(&bam,
8f6120bc:	e1a00008 	mov	r0, r8
8f6120c0:	ebfffc98 	bl	8f611328 <bam_add_one_desc>
		bam_sys_gen_event(&bam, CMD_PIPE_INDEX, num_cmd_desc);
8f6120c4:	e3a02002 	mov	r2, #2
8f6120c8:	e1a01002 	mov	r1, r2
8f6120cc:	e1a00008 	mov	r0, r8
8f6120d0:	ebfffc4d 	bl	8f61120c <bam_sys_gen_event>
	for (i = 0; i < flash.cws_per_page; i++)
8f6120d4:	e599303c 	ldr	r3, [r9, #60]	; 0x3c
8f6120d8:	e1530004 	cmp	r3, r4
8f6120dc:	9a000037 	bls	8f6121c0 <qpic_nand_read_page+0x3dc>
		if (i == 0)
8f6120e0:	e3540000 	cmp	r4, #0
8f6120e4:	158d7008 	strne	r7, [r13, #8]
8f6120e8:	0a00002a 	beq	8f612198 <qpic_nand_read_page+0x3b4>
		bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_CMD, (uint32_t)params.cmd, CE_WRITE_TYPE);
8f6120ec:	e3a03000 	mov	r3, #0
8f6120f0:	e59d204c 	ldr	r2, [r13, #76]	; 0x4c
8f6120f4:	e5951000 	ldr	r1, [r5]
8f6120f8:	e1a00007 	mov	r0, r7
8f6120fc:	ebfffd41 	bl	8f611608 <bam_add_cmd_element>
		if (i == flash.cws_per_page - 1)
8f612100:	e599303c 	ldr	r3, [r9, #60]	; 0x3c
		cmd_list_ptr++;
8f612104:	e2876010 	add	r6, r7, #16
		if (i == flash.cws_per_page - 1)
8f612108:	e2433001 	sub	r3, r3, #1
8f61210c:	e1530004 	cmp	r3, r4
8f612110:	1affff8f 	bne	8f611f54 <qpic_nand_read_page+0x170>
			bam_add_cmd_element(cmd_list_ptr, NAND_READ_LOCATION_n(1), (uint32_t)addr_loc_1, CE_WRITE_TYPE);
8f612114:	e5951000 	ldr	r1, [r5]
8f612118:	e3a03000 	mov	r3, #0
8f61211c:	e59d2028 	ldr	r2, [r13, #40]	; 0x28
8f612120:	e1a00006 	mov	r0, r6
8f612124:	e2811ef2 	add	r1, r1, #3872	; 0xf20
			cmd_list_ptr++;
8f612128:	e2876020 	add	r6, r7, #32
			bam_add_cmd_element(cmd_list_ptr, NAND_READ_LOCATION_n(1), (uint32_t)addr_loc_1, CE_WRITE_TYPE);
8f61212c:	e2811004 	add	r1, r1, #4
8f612130:	ebfffd34 	bl	8f611608 <bam_add_cmd_element>
							 (unsigned char *)PA((addr_t)buffer),
8f612134:	e1a0000b 	mov	r0, r11
8f612138:	ebffbd85 	bl	8f601754 <platform_get_virt_to_phys_mapping>
			bam_add_one_desc(&bam,
8f61213c:	e3a01001 	mov	r1, #1
8f612140:	e3a03000 	mov	r3, #0
8f612144:	e58d3000 	str	r3, [r13]
8f612148:	e59d3020 	ldr	r3, [r13, #32]
							 (unsigned char *)PA((addr_t)buffer),
8f61214c:	e1a02000 	mov	r2, r0
			bam_add_one_desc(&bam,
8f612150:	e1a00008 	mov	r0, r8
8f612154:	ebfffc73 	bl	8f611328 <bam_add_one_desc>
							 (unsigned char *)PA((addr_t)spareaddr),
8f612158:	e59d0014 	ldr	r0, [r13, #20]
8f61215c:	ebffbd7c 	bl	8f601754 <platform_get_virt_to_phys_mapping>
			bam_add_one_desc(&bam,
8f612160:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f612164:	e3a01001 	mov	r1, #1
							 (unsigned char *)PA((addr_t)spareaddr),
8f612168:	e1a02000 	mov	r2, r0
			bam_add_one_desc(&bam,
8f61216c:	e3a00080 	mov	r0, #128	; 0x80
8f612170:	e58d0000 	str	r0, [r13]
8f612174:	e1a00008 	mov	r0, r8
8f612178:	ebfffc6a 	bl	8f611328 <bam_add_one_desc>
			bam_sys_gen_event(&bam, DATA_PRODUCER_PIPE_INDEX, num_data_desc);
8f61217c:	e3a02002 	mov	r2, #2
8f612180:	e3a01001 	mov	r1, #1
8f612184:	e1a00008 	mov	r0, r8
8f612188:	ebfffc1f 	bl	8f61120c <bam_sys_gen_event>
			addr_loc_0 |= NAND_RD_LOC_LAST_BIT(0);
8f61218c:	e59d301c 	ldr	r3, [r13, #28]
8f612190:	e58d3010 	str	r3, [r13, #16]
8f612194:	eaffff7b 	b	8f611f88 <qpic_nand_read_page+0x1a4>
			cmd_list_ptr = qpic_nand_add_addr_n_cfg_ce(&params, cmd_list_ptr);
8f612198:	e1a01007 	mov	r1, r7
8f61219c:	e28d003c 	add	r0, r13, #60	; 0x3c
8f6121a0:	ebfffd32 	bl	8f611670 <qpic_nand_add_addr_n_cfg_ce>
			bam_add_cmd_element(cmd_list_ptr, NAND_DEV0_ECC_CFG,(uint32_t)ecc, CE_WRITE_TYPE);
8f6121a4:	e5951000 	ldr	r1, [r5]
8f6121a8:	e59d2018 	ldr	r2, [r13, #24]
8f6121ac:	e1a03004 	mov	r3, r4
8f6121b0:	e2811028 	add	r1, r1, #40	; 0x28
			cmd_list_ptr++;
8f6121b4:	e2807010 	add	r7, r0, #16
			bam_add_cmd_element(cmd_list_ptr, NAND_DEV0_ECC_CFG,(uint32_t)ecc, CE_WRITE_TYPE);
8f6121b8:	ebfffd12 	bl	8f611608 <bam_add_cmd_element>
			cmd_list_ptr++;
8f6121bc:	eaffffca 	b	8f6120ec <qpic_nand_read_page+0x308>
	bam_wait_for_interrupt(&bam, pipe_num, P_PRCSD_DESC_EN_MASK);
8f6121c0:	e3a02001 	mov	r2, #1
8f6121c4:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f6121c8:	e1a01002 	mov	r1, r2
8f6121cc:	e3480f72 	movt	r0, #36722	; 0x8f72
8f6121d0:	ebfffbdf 	bl	8f611154 <bam_wait_for_interrupt>
	bam_read_offset_update(&bam, pipe_num);
8f6121d4:	e3a01001 	mov	r1, #1
8f6121d8:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f6121dc:	e3480f72 	movt	r0, #36722	; 0x8f72
8f6121e0:	ebfffc35 	bl	8f6112bc <bam_read_offset_update>
	for (i = 0; i < flash.cws_per_page ; i ++)
8f6121e4:	e599c03c 	ldr	r12, [r9, #60]	; 0x3c
8f6121e8:	e35c0000 	cmp	r12, #0
8f6121ec:	128d207c 	addne	r2, r13, #124	; 0x7c
8f6121f0:	128d30cc 	addne	r3, r13, #204	; 0xcc
8f6121f4:	13a01000 	movne	r1, #0
8f6121f8:	0a00000a 	beq	8f612228 <qpic_nand_read_page+0x444>
		if (flash_sts[i] & (NAND_FLASH_OP_ERR | NAND_FLASH_MPU_ERR))
8f6121fc:	e4920004 	ldr	r0, [r2], #4
8f612200:	e3100e11 	tst	r0, #272	; 0x110
8f612204:	0a000003 	beq	8f612218 <qpic_nand_read_page+0x434>
			if ((erased_cw_sts[i] & NAND_ERASED_CW) != NAND_ERASED_CW)
8f612208:	e5930000 	ldr	r0, [r3]
8f61220c:	e2000050 	and	r0, r0, #80	; 0x50
8f612210:	e3500050 	cmp	r0, #80	; 0x50
8f612214:	1a000005 	bne	8f612230 <qpic_nand_read_page+0x44c>
	for (i = 0; i < flash.cws_per_page ; i ++)
8f612218:	e2811001 	add	r1, r1, #1
8f61221c:	e2833004 	add	r3, r3, #4
8f612220:	e151000c 	cmp	r1, r12
8f612224:	1afffff4 	bne	8f6121fc <qpic_nand_read_page+0x418>
	int nand_ret = NANDC_RESULT_SUCCESS;
8f612228:	e3a04000 	mov	r4, #0
8f61222c:	eaffff1f 	b	8f611eb0 <qpic_nand_read_page+0xcc>
	total_ecc_bytes = (ecc_parity_bytes * flash.cws_per_page);
8f612230:	e30c3e14 	movw	r3, #52756	; 0xce14
8f612234:	e3483f72 	movt	r3, #36722	; 0x8f72
	ecc_buf = memalign(16, total_ecc_bytes);
8f612238:	e3a00010 	mov	r0, #16
	total_ecc_bytes = (ecc_parity_bytes * flash.cws_per_page);
8f61223c:	e58d3010 	str	r3, [r13, #16]
8f612240:	e5934000 	ldr	r4, [r3]
8f612244:	e0040c94 	mul	r4, r4, r12
	ecc_buf = memalign(16, total_ecc_bytes);
8f612248:	e1a01004 	mov	r1, r4
8f61224c:	eb00877c 	bl	8f634044 <memalign>
	ASSERT(ecc_buf);
8f612250:	e2503000 	subs	r3, r0, #0
8f612254:	e58d3018 	str	r3, [r13, #24]
8f612258:	0a0000de 	beq	8f6125d8 <qpic_nand_read_page+0x7f4>
	memset(ecc_buf, 0, total_ecc_bytes);
8f61225c:	e1a02004 	mov	r2, r4
8f612260:	e3a01000 	mov	r1, #0
8f612264:	e59d0018 	ldr	r0, [r13, #24]
8f612268:	eb008815 	bl	8f6342c4 <memset>
	params.addr0 = page << 16;
8f61226c:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
	params.addr1 = (page >> 16) & 0xff;
8f612270:	e59d2030 	ldr	r2, [r13, #48]	; 0x30
	params.cmd = NAND_CMD_PAGE_READ;
8f612274:	e3a00032 	mov	r0, #50	; 0x32
8f612278:	e58d006c 	str	r0, [r13, #108]	; 0x6c
	params.addr0 = page << 16;
8f61227c:	e58d305c 	str	r3, [r13, #92]	; 0x5c
	params.cfg0 = cfg0_raw;
8f612280:	e30c3e00 	movw	r3, #52736	; 0xce00
8f612284:	e3483f72 	movt	r3, #36722	; 0x8f72
	params.addr1 = (page >> 16) & 0xff;
8f612288:	e58d2060 	str	r2, [r13, #96]	; 0x60
	params.cfg1 = cfg1_raw;
8f61228c:	e30c2e08 	movw	r2, #52744	; 0xce08
8f612290:	e3482f72 	movt	r2, #36722	; 0x8f72
	params.cfg0 = cfg0_raw;
8f612294:	e5933000 	ldr	r3, [r3]
	params.cfg1 = cfg1_raw;
8f612298:	e5922000 	ldr	r2, [r2]
	params.cfg0 = cfg0_raw;
8f61229c:	e58d3064 	str	r3, [r13, #100]	; 0x64
	addr_loc_0 |= NAND_RD_LOC_SIZE(ecc_parity_bytes);
8f6122a0:	e59d3010 	ldr	r3, [r13, #16]
	params.cfg1 = cfg1_raw;
8f6122a4:	e58d2068 	str	r2, [r13, #104]	; 0x68
	addr_loc_0 |= NAND_RD_LOC_SIZE(ecc_parity_bytes);
8f6122a8:	e5931000 	ldr	r1, [r3]
	ecc = ecc_cfg_raw;
8f6122ac:	e30c3e10 	movw	r3, #52752	; 0xce10
8f6122b0:	e3483f72 	movt	r3, #36722	; 0x8f72
8f6122b4:	e5933000 	ldr	r3, [r3]
8f6122b8:	e58d301c 	str	r3, [r13, #28]
	for (i = 0; i < flash.cws_per_page; i++)
8f6122bc:	e599303c 	ldr	r3, [r9, #60]	; 0x3c
8f6122c0:	e3530000 	cmp	r3, #0
	addr_loc_0 |= NAND_RD_LOC_LAST_BIT(1);
8f6122c4:	e3003205 	movw	r3, #517	; 0x205
8f6122c8:	e3483000 	movt	r3, #32768	; 0x8000
8f6122cc:	e1833801 	orr	r3, r3, r1, lsl #16
8f6122d0:	e58d3020 	str	r3, [r13, #32]
	params.exec = 1;
8f6122d4:	e3a03001 	mov	r3, #1
8f6122d8:	e58d3078 	str	r3, [r13, #120]	; 0x78
	for (i = 0; i < flash.cws_per_page; i++)
8f6122dc:	0a00008f 	beq	8f612520 <qpic_nand_read_page+0x73c>
	ecc_buf = memalign(16, total_ecc_bytes);
8f6122e0:	e59d3018 	ldr	r3, [r13, #24]
	struct cmd_element *cmd_list_ptr_start = ce_array;
8f6122e4:	e30242b0 	movw	r4, #8880	; 0x22b0
8f6122e8:	e30c5e6c 	movw	r5, #52844	; 0xce6c
8f6122ec:	e3484f74 	movt	r4, #36724	; 0x8f74
		bam_add_one_desc(&bam,
8f6122f0:	e30c7d98 	movw	r7, #52632	; 0xcd98
8f6122f4:	e3485f72 	movt	r5, #36722	; 0x8f72
8f6122f8:	e3487f72 	movt	r7, #36722	; 0x8f72
8f6122fc:	e28d80f4 	add	r8, r13, #244	; 0xf4
	for (i = 0; i < flash.cws_per_page; i++)
8f612300:	e3a06000 	mov	r6, #0
	struct cmd_element *cmd_list_ptr_start = ce_array;
8f612304:	e58d400c 	str	r4, [r13, #12]
	ecc_buf = memalign(16, total_ecc_bytes);
8f612308:	e58d3008 	str	r3, [r13, #8]
8f61230c:	ea000068 	b	8f6124b4 <qpic_nand_read_page+0x6d0>
		if (i == flash.cws_per_page - 1)
8f612310:	e599303c 	ldr	r3, [r9, #60]	; 0x3c
						 (unsigned char *)PA((addr_t)ecc_temp),
8f612314:	e59d0008 	ldr	r0, [r13, #8]
		if (i == flash.cws_per_page - 1)
8f612318:	e2433001 	sub	r3, r3, #1
8f61231c:	e1530006 	cmp	r3, r6
		bam_add_one_desc(&bam,
8f612320:	138ab018 	orrne	r11, r10, #24
8f612324:	03a0b098 	moveq	r11, #152	; 0x98
			flags = BAM_DESC_INT_FLAG;
8f612328:	03a0a080 	moveq	r10, #128	; 0x80
						 (unsigned char *)PA((addr_t)ecc_temp),
8f61232c:	ebffbd08 	bl	8f601754 <platform_get_virt_to_phys_mapping>
		bam_add_one_desc(&bam,
8f612330:	e59d3010 	ldr	r3, [r13, #16]
8f612334:	e58da000 	str	r10, [r13]
8f612338:	e3a01001 	mov	r1, #1
		cmd_list_ptr++;
8f61233c:	e284a010 	add	r10, r4, #16
		bam_add_one_desc(&bam,
8f612340:	e5933000 	ldr	r3, [r3]
						 (unsigned char *)PA((addr_t)ecc_temp),
8f612344:	e1a02000 	mov	r2, r0
		bam_add_one_desc(&bam,
8f612348:	e1a00007 	mov	r0, r7
8f61234c:	ebfffbf5 	bl	8f611328 <bam_add_one_desc>
		bam_sys_gen_event(&bam, DATA_PRODUCER_PIPE_INDEX, num_data_desc);
8f612350:	e3a02001 	mov	r2, #1
8f612354:	e1a01002 	mov	r1, r2
8f612358:	e1a00007 	mov	r0, r7
8f61235c:	ebfffbaa 	bl	8f61120c <bam_sys_gen_event>
		bam_add_cmd_element(cmd_list_ptr,
8f612360:	e5951000 	ldr	r1, [r5]
8f612364:	e3a03000 	mov	r3, #0
8f612368:	e59d2078 	ldr	r2, [r13, #120]	; 0x78
8f61236c:	e2811010 	add	r1, r1, #16
8f612370:	e1a00004 	mov	r0, r4
8f612374:	ebfffca3 	bl	8f611608 <bam_add_cmd_element>
					 (unsigned char*)PA((addr_t)cmd_list_ptr_start),
8f612378:	e59d000c 	ldr	r0, [r13, #12]
8f61237c:	ebffbcf4 	bl	8f601754 <platform_get_virt_to_phys_mapping>
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f612380:	e59d200c 	ldr	r2, [r13, #12]
					 (unsigned char*)PA((addr_t)cmd_list_ptr_start),
8f612384:	e58d0014 	str	r0, [r13, #20]
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f612388:	e04a0002 	sub	r0, r10, r2
8f61238c:	ebffbcf0 	bl	8f601754 <platform_get_virt_to_phys_mapping>
		bam_add_one_desc(&bam,
8f612390:	e59d2014 	ldr	r2, [r13, #20]
8f612394:	e3a01002 	mov	r1, #2
8f612398:	e58db000 	str	r11, [r13]
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f61239c:	e1a03000 	mov	r3, r0
		bam_add_one_desc(&bam,
8f6123a0:	e1a00007 	mov	r0, r7
8f6123a4:	ebfffbdf 	bl	8f611328 <bam_add_one_desc>
		bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_STATUS, (uint32_t)PA((addr_t)&(flash_sts[i])), CE_READ_TYPE);
8f6123a8:	e1a00008 	mov	r0, r8
8f6123ac:	e595b000 	ldr	r11, [r5]
8f6123b0:	ebffbce7 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f6123b4:	e3a03001 	mov	r3, #1
8f6123b8:	e28bb014 	add	r11, r11, #20
8f6123bc:	e1a0100b 	mov	r1, r11
8f6123c0:	e1a02000 	mov	r2, r0
8f6123c4:	e1a0000a 	mov	r0, r10
8f6123c8:	ebfffc8e 	bl	8f611608 <bam_add_cmd_element>
		arch_clean_invalidate_cache_range((addr_t)&(flash_sts[i]), sizeof(uint32_t));
8f6123cc:	e1a00008 	mov	r0, r8
8f6123d0:	e3a01004 	mov	r1, #4
8f6123d4:	eb003af1 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
		bam_add_cmd_element(cmd_list_ptr, NAND_BUFFER_STATUS, (uint32_t)PA((addr_t)&(buffer_sts[i])), CE_READ_TYPE);
8f6123d8:	e28d2f47 	add	r2, r13, #284	; 0x11c
8f6123dc:	e082b106 	add	r11, r2, r6, lsl #2
8f6123e0:	e5951000 	ldr	r1, [r5]
8f6123e4:	e1a0000b 	mov	r0, r11
8f6123e8:	e2811018 	add	r1, r1, #24
8f6123ec:	e58d1014 	str	r1, [r13, #20]
8f6123f0:	ebffbcd7 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f6123f4:	e3a03001 	mov	r3, #1
8f6123f8:	e59d1014 	ldr	r1, [r13, #20]
8f6123fc:	e1a02000 	mov	r2, r0
8f612400:	e2840020 	add	r0, r4, #32
8f612404:	ebfffc7f 	bl	8f611608 <bam_add_cmd_element>
		arch_clean_invalidate_cache_range((addr_t)&(buffer_sts[i]), sizeof(uint32_t));
8f612408:	e3a01004 	mov	r1, #4
8f61240c:	e1a0000b 	mov	r0, r11
		cmd_list_ptr++;
8f612410:	e2844030 	add	r4, r4, #48	; 0x30
		arch_clean_invalidate_cache_range((addr_t)&(buffer_sts[i]), sizeof(uint32_t));
8f612414:	eb003ae1 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
		if (i == flash.cws_per_page - 1)
8f612418:	e599103c 	ldr	r1, [r9, #60]	; 0x3c
					(unsigned char*)PA((addr_t)cmd_list_temp),
8f61241c:	e1a0000a 	mov	r0, r10
		if (i == flash.cws_per_page - 1)
8f612420:	e2411001 	sub	r1, r1, #1
			flags = BAM_DESC_CMD_FLAG;
8f612424:	e1510006 	cmp	r1, r6
	for (i = 0; i < flash.cws_per_page; i++)
8f612428:	e2866001 	add	r6, r6, #1
			flags = BAM_DESC_CMD_FLAG;
8f61242c:	03a0100a 	moveq	r1, #10
8f612430:	13a01008 	movne	r1, #8
8f612434:	e58d1014 	str	r1, [r13, #20]
					(unsigned char*)PA((addr_t)cmd_list_temp),
8f612438:	ebffbcc5 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f61243c:	e1a02000 	mov	r2, r0
					PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_temp),
8f612440:	e044000a 	sub	r0, r4, r10
					(unsigned char*)PA((addr_t)cmd_list_temp),
8f612444:	e1a0a002 	mov	r10, r2
					PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_temp),
8f612448:	ebffbcc1 	bl	8f601754 <platform_get_virt_to_phys_mapping>
		bam_add_one_desc(&bam,
8f61244c:	e59d1014 	ldr	r1, [r13, #20]
8f612450:	e1a0200a 	mov	r2, r10
8f612454:	e58d1000 	str	r1, [r13]
8f612458:	e3a01002 	mov	r1, #2
					PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_temp),
8f61245c:	e1a03000 	mov	r3, r0
		bam_add_one_desc(&bam,
8f612460:	e1a00007 	mov	r0, r7
8f612464:	ebfffbaf 	bl	8f611328 <bam_add_one_desc>
		ecc_temp += ecc_parity_bytes;
8f612468:	e59d3010 	ldr	r3, [r13, #16]
8f61246c:	e59d1008 	ldr	r1, [r13, #8]
		bam_sys_gen_event(&bam, CMD_PIPE_INDEX, num_cmd_desc);
8f612470:	e3a02002 	mov	r2, #2
8f612474:	e1a00007 	mov	r0, r7
		ecc_temp += ecc_parity_bytes;
8f612478:	e5933000 	ldr	r3, [r3]
8f61247c:	e0813003 	add	r3, r1, r3
		bam_sys_gen_event(&bam, CMD_PIPE_INDEX, num_cmd_desc);
8f612480:	e1a01002 	mov	r1, r2
		ecc_temp += ecc_parity_bytes;
8f612484:	e58d3008 	str	r3, [r13, #8]
		bam_sys_gen_event(&bam, CMD_PIPE_INDEX, num_cmd_desc);
8f612488:	ebfffb5f 	bl	8f61120c <bam_sys_gen_event>
		arch_clean_invalidate_cache_range((addr_t)&(flash_sts[i]), sizeof(uint32_t));
8f61248c:	e1a00008 	mov	r0, r8
8f612490:	e3a01004 	mov	r1, #4
8f612494:	eb003ac1 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
		arch_clean_invalidate_cache_range((addr_t)&(buffer_sts[i]), sizeof(uint32_t));
8f612498:	e1a0000b 	mov	r0, r11
8f61249c:	e3a01004 	mov	r1, #4
	for (i = 0; i < flash.cws_per_page; i++)
8f6124a0:	e2888004 	add	r8, r8, #4
		arch_clean_invalidate_cache_range((addr_t)&(buffer_sts[i]), sizeof(uint32_t));
8f6124a4:	eb003abd 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	for (i = 0; i < flash.cws_per_page; i++)
8f6124a8:	e599303c 	ldr	r3, [r9, #60]	; 0x3c
8f6124ac:	e1560003 	cmp	r6, r3
8f6124b0:	2a00001a 	bcs	8f612520 <qpic_nand_read_page+0x73c>
		if (i == 0)
8f6124b4:	e3560000 	cmp	r6, #0
8f6124b8:	158d400c 	strne	r4, [r13, #12]
		flags = 0;
8f6124bc:	13a0a000 	movne	r10, #0
		if (i == 0)
8f6124c0:	1affff92 	bne	8f612310 <qpic_nand_read_page+0x52c>
			cmd_list_ptr = qpic_nand_add_addr_n_cfg_ce(&params, cmd_list_ptr);
8f6124c4:	e1a01004 	mov	r1, r4
8f6124c8:	e28d005c 	add	r0, r13, #92	; 0x5c
8f6124cc:	ebfffc67 	bl	8f611670 <qpic_nand_add_addr_n_cfg_ce>
			bam_add_cmd_element(cmd_list_ptr, NAND_DEV0_ECC_CFG,(uint32_t)ecc, CE_WRITE_TYPE);
8f6124d0:	e5951000 	ldr	r1, [r5]
8f6124d4:	e59d201c 	ldr	r2, [r13, #28]
8f6124d8:	e1a03006 	mov	r3, r6
8f6124dc:	e2811028 	add	r1, r1, #40	; 0x28
			flags = BAM_DESC_LOCK_FLAG;
8f6124e0:	e3a0a004 	mov	r10, #4
			cmd_list_ptr = qpic_nand_add_addr_n_cfg_ce(&params, cmd_list_ptr);
8f6124e4:	e1a04000 	mov	r4, r0
			bam_add_cmd_element(cmd_list_ptr, NAND_DEV0_ECC_CFG,(uint32_t)ecc, CE_WRITE_TYPE);
8f6124e8:	ebfffc46 	bl	8f611608 <bam_add_cmd_element>
			bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_CMD, (uint32_t)params.cmd, CE_WRITE_TYPE);
8f6124ec:	e59d206c 	ldr	r2, [r13, #108]	; 0x6c
8f6124f0:	e2840010 	add	r0, r4, #16
8f6124f4:	e5951000 	ldr	r1, [r5]
8f6124f8:	e1a03006 	mov	r3, r6
8f6124fc:	ebfffc41 	bl	8f611608 <bam_add_cmd_element>
			bam_add_cmd_element(cmd_list_ptr,
8f612500:	e5951000 	ldr	r1, [r5]
8f612504:	e2840020 	add	r0, r4, #32
8f612508:	e59d2020 	ldr	r2, [r13, #32]
8f61250c:	e2811ef2 	add	r1, r1, #3872	; 0xf20
8f612510:	e1a03006 	mov	r3, r6
8f612514:	ebfffc3b 	bl	8f611608 <bam_add_cmd_element>
			cmd_list_ptr++;
8f612518:	e2844030 	add	r4, r4, #48	; 0x30
8f61251c:	eaffff7b 	b	8f612310 <qpic_nand_read_page+0x52c>
	bam_wait_for_interrupt(&bam, pipe_num, P_PRCSD_DESC_EN_MASK);
8f612520:	e3a02001 	mov	r2, #1
8f612524:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f612528:	e1a01002 	mov	r1, r2
8f61252c:	e3480f72 	movt	r0, #36722	; 0x8f72
8f612530:	ebfffb07 	bl	8f611154 <bam_wait_for_interrupt>
	bam_read_offset_update(&bam, pipe_num);
8f612534:	e3a01001 	mov	r1, #1
8f612538:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f61253c:	e3480f72 	movt	r0, #36722	; 0x8f72
8f612540:	ebfffb5d 	bl	8f6112bc <bam_read_offset_update>
	for (i = 0; i < flash.cws_per_page; i++)
8f612544:	e599c03c 	ldr	r12, [r9, #60]	; 0x3c
8f612548:	e35c0000 	cmp	r12, #0
8f61254c:	0a00001f 	beq	8f6125d0 <qpic_nand_read_page+0x7ec>
		num_zeros = find_num_zeros_per_cw(ecc_temp, ecc_parity_bytes);
8f612550:	e59d3010 	ldr	r3, [r13, #16]
	for (i = 0; i < flash.cws_per_page; i++)
8f612554:	e3a0e000 	mov	r14, #0
	ecc_buf = memalign(16, total_ecc_bytes);
8f612558:	e59d0018 	ldr	r0, [r13, #24]
		num_zeros = find_num_zeros_per_cw(ecc_temp, ecc_parity_bytes);
8f61255c:	e5934000 	ldr	r4, [r3]
	for (i = 0; i < ecc_bytes; i++)
8f612560:	e2446001 	sub	r6, r4, #1
8f612564:	e3540000 	cmp	r4, #0
8f612568:	0a000014 	beq	8f6125c0 <qpic_nand_read_page+0x7dc>
8f61256c:	e2401001 	sub	r1, r0, #1
8f612570:	e0805006 	add	r5, r0, r6
	int num_zeros = 0;
8f612574:	e3a02000 	mov	r2, #0
		val = ecc_buf[i];
8f612578:	e5f13001 	ldrb	r3, [r1, #1]!
		while (val)
8f61257c:	e3530000 	cmp	r3, #0
8f612580:	1a000002 	bne	8f612590 <qpic_nand_read_page+0x7ac>
8f612584:	ea000009 	b	8f6125b0 <qpic_nand_read_page+0x7cc>
8f612588:	e1b030a3 	lsrs	r3, r3, #1
8f61258c:	0a000007 	beq	8f6125b0 <qpic_nand_read_page+0x7cc>
			if ((val & 1) == 0)
8f612590:	e3130001 	tst	r3, #1
				num_zeros++;
8f612594:	02822001 	addeq	r2, r2, #1
			if (num_zeros > THRESHOLD_BIT_FLIPS)
8f612598:	e3520004 	cmp	r2, #4
8f61259c:	dafffff9 	ble	8f612588 <qpic_nand_read_page+0x7a4>
			nand_ret = NANDC_RESULT_BAD_PAGE;
8f6125a0:	e3a04005 	mov	r4, #5
	free(ecc_buf);
8f6125a4:	e59d0018 	ldr	r0, [r13, #24]
8f6125a8:	eb0086d7 	bl	8f63410c <free>
				goto qpic_nand_read_page_error;
8f6125ac:	eafffe3f 	b	8f611eb0 <qpic_nand_read_page+0xcc>
	for (i = 0; i < ecc_bytes; i++)
8f6125b0:	e1550001 	cmp	r5, r1
8f6125b4:	1affffef 	bne	8f612578 <qpic_nand_read_page+0x794>
		if (num_zeros > THRESHOLD_BIT_FLIPS)
8f6125b8:	e3520004 	cmp	r2, #4
8f6125bc:	cafffff7 	bgt	8f6125a0 <qpic_nand_read_page+0x7bc>
	for (i = 0; i < flash.cws_per_page; i++)
8f6125c0:	e28ee001 	add	r14, r14, #1
		ecc_temp += ecc_parity_bytes;
8f6125c4:	e0800004 	add	r0, r0, r4
	for (i = 0; i < flash.cws_per_page; i++)
8f6125c8:	e15c000e 	cmp	r12, r14
8f6125cc:	1affffe4 	bne	8f612564 <qpic_nand_read_page+0x780>
	int nand_ret = NANDC_RESULT_SUCCESS;
8f6125d0:	e3a04000 	mov	r4, #0
qpic_nand_read_page_error:
8f6125d4:	eafffff2 	b	8f6125a4 <qpic_nand_read_page+0x7c0>
	ASSERT(ecc_buf);
8f6125d8:	e59d0034 	ldr	r0, [r13, #52]	; 0x34
8f6125dc:	e3043210 	movw	r3, #16912	; 0x4210
8f6125e0:	e30421f0 	movw	r2, #16880	; 0x41f0
8f6125e4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6125e8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6125ec:	e58d3000 	str	r3, [r13]
8f6125f0:	e3001130 	movw	r1, #304	; 0x130
8f6125f4:	e30035c4 	movw	r3, #1476	; 0x5c4
8f6125f8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6125fc:	eb00812e 	bl	8f632abc <_panic>
8f612600:	eaffff15 	b	8f61225c <qpic_nand_read_page+0x478>
}
8f612604:	eb00816d 	bl	8f632bc0 <__stack_chk_fail>
8f612608:	8f74221c 	.word	0x8f74221c

8f61260c <qpic_add_wr_page_cws_data_desc>:
{
8f61260c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	for( unsigned i = 0; i < flash.cws_per_page; i++)
8f612610:	e30c7e18 	movw	r7, #52760	; 0xce18
8f612614:	e3487f72 	movt	r7, #36722	; 0x8f72
{
8f612618:	e24dd01c 	sub	r13, r13, #28
8f61261c:	e59f317c 	ldr	r3, [pc, #380]	; 8f6127a0 <qpic_add_wr_page_cws_data_desc+0x194>
	for( unsigned i = 0; i < flash.cws_per_page; i++)
8f612620:	e597a03c 	ldr	r10, [r7, #60]	; 0x3c
{
8f612624:	e58d200c 	str	r2, [r13, #12]
8f612628:	e5933000 	ldr	r3, [r3]
8f61262c:	e58d3014 	str	r3, [r13, #20]
8f612630:	e3a03000 	mov	r3, #0
	for( unsigned i = 0; i < flash.cws_per_page; i++)
8f612634:	e35a0000 	cmp	r10, #0
8f612638:	0a000055 	beq	8f612794 <qpic_add_wr_page_cws_data_desc+0x188>
8f61263c:	e3a04000 	mov	r4, #0
		bam_add_one_desc(&bam, DATA_CONSUMER_PIPE_INDEX, (unsigned char*)PA(start), len, flags);
8f612640:	e30c9d98 	movw	r9, #52632	; 0xcd98
8f612644:	e1a0b000 	mov	r11, r0
8f612648:	e3489f72 	movt	r9, #36722	; 0x8f72
8f61264c:	e1a08001 	mov	r8, r1
	for( unsigned i = 0; i < flash.cws_per_page; i++)
8f612650:	e1a05000 	mov	r5, r0
	unsigned num_desc = 0;
8f612654:	e1a06004 	mov	r6, r4
8f612658:	ea000019 	b	8f6126c4 <qpic_add_wr_page_cws_data_desc+0xb8>
		if (cfg_mode != NAND_CFG_RAW)
8f61265c:	e3580000 	cmp	r8, #0
8f612660:	0a000021 	beq	8f6126ec <qpic_add_wr_page_cws_data_desc+0xe0>
				if (i < (flash.cws_per_page - 1))
8f612664:	e15a0004 	cmp	r10, r4
8f612668:	83a0a040 	movhi	r10, #64	; 0x40
8f61266c:	83a03f81 	movhi	r3, #516	; 0x204
8f612670:	9a000019 	bls	8f6126dc <qpic_add_wr_page_cws_data_desc+0xd0>
		bam_add_one_desc(&bam, DATA_CONSUMER_PIPE_INDEX, (unsigned char*)PA(start), len, flags);
8f612674:	e1a00005 	mov	r0, r5
8f612678:	e58d3008 	str	r3, [r13, #8]
8f61267c:	ebffbc34 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f612680:	e59d3008 	ldr	r3, [r13, #8]
8f612684:	e58da000 	str	r10, [r13]
8f612688:	e3a01000 	mov	r1, #0
8f61268c:	e1a02000 	mov	r2, r0
8f612690:	e1a00009 	mov	r0, r9
8f612694:	ebfffb23 	bl	8f611328 <bam_add_one_desc>
		if ((i == (flash.cws_per_page - 1)) && (cfg_mode == NAND_CFG))
8f612698:	e597a03c 	ldr	r10, [r7, #60]	; 0x3c
		num_desc++;
8f61269c:	e2862001 	add	r2, r6, #1
		if ((i == (flash.cws_per_page - 1)) && (cfg_mode == NAND_CFG))
8f6126a0:	e24a3001 	sub	r3, r10, #1
8f6126a4:	e1530004 	cmp	r3, r4
8f6126a8:	03580001 	cmpeq	r8, #1
		num_desc++;
8f6126ac:	11a06002 	movne	r6, r2
		if ((i == (flash.cws_per_page - 1)) && (cfg_mode == NAND_CFG))
8f6126b0:	0a00002b 	beq	8f612764 <qpic_add_wr_page_cws_data_desc+0x158>
	for( unsigned i = 0; i < flash.cws_per_page; i++)
8f6126b4:	e2844001 	add	r4, r4, #1
8f6126b8:	e2855f81 	add	r5, r5, #516	; 0x204
8f6126bc:	e154000a 	cmp	r4, r10
8f6126c0:	2a00001a 	bcs	8f612730 <qpic_add_wr_page_cws_data_desc+0x124>
		if( i == flash.cws_per_page - 1)
8f6126c4:	e24aa001 	sub	r10, r10, #1
8f6126c8:	e15a0004 	cmp	r10, r4
8f6126cc:	1affffe2 	bne	8f61265c <qpic_add_wr_page_cws_data_desc+0x50>
		if (cfg_mode != NAND_CFG_RAW)
8f6126d0:	e3580000 	cmp	r8, #0
8f6126d4:	03a0a0c0 	moveq	r10, #192	; 0xc0
8f6126d8:	0a000004 	beq	8f6126f0 <qpic_add_wr_page_cws_data_desc+0xe4>
					len = USER_DATA_BYTES_PER_CW - ((flash.cws_per_page -  1) << 2);
8f6126dc:	e1a0a10a 	lsl	r10, r10, #2
8f6126e0:	e26a3c02 	rsb	r3, r10, #512	; 0x200
8f6126e4:	e3a0a000 	mov	r10, #0
8f6126e8:	eaffffe1 	b	8f612674 <qpic_add_wr_page_cws_data_desc+0x68>
8f6126ec:	e3a0a040 	mov	r10, #64	; 0x40
			len = flash.cw_size;
8f6126f0:	e5973038 	ldr	r3, [r7, #56]	; 0x38
		bam_add_one_desc(&bam, DATA_CONSUMER_PIPE_INDEX, (unsigned char*)PA(start), len, flags);
8f6126f4:	e1a0000b 	mov	r0, r11
	for( unsigned i = 0; i < flash.cws_per_page; i++)
8f6126f8:	e2844001 	add	r4, r4, #1
		num_desc++;
8f6126fc:	e2866001 	add	r6, r6, #1
	for( unsigned i = 0; i < flash.cws_per_page; i++)
8f612700:	e2855f81 	add	r5, r5, #516	; 0x204
			len = flash.cw_size;
8f612704:	e58d3008 	str	r3, [r13, #8]
		bam_add_one_desc(&bam, DATA_CONSUMER_PIPE_INDEX, (unsigned char*)PA(start), len, flags);
8f612708:	ebffbc11 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f61270c:	e58da000 	str	r10, [r13]
8f612710:	e3a01000 	mov	r1, #0
8f612714:	e59d3008 	ldr	r3, [r13, #8]
8f612718:	e1a02000 	mov	r2, r0
8f61271c:	e1a00009 	mov	r0, r9
8f612720:	ebfffb00 	bl	8f611328 <bam_add_one_desc>
	for( unsigned i = 0; i < flash.cws_per_page; i++)
8f612724:	e597a03c 	ldr	r10, [r7, #60]	; 0x3c
8f612728:	e154000a 	cmp	r4, r10
8f61272c:	3affffe4 	bcc	8f6126c4 <qpic_add_wr_page_cws_data_desc+0xb8>
	bam_sys_gen_event(&bam, DATA_CONSUMER_PIPE_INDEX, num_desc);
8f612730:	e59f3068 	ldr	r3, [pc, #104]	; 8f6127a0 <qpic_add_wr_page_cws_data_desc+0x194>
8f612734:	e5932000 	ldr	r2, [r3]
8f612738:	e59d3014 	ldr	r3, [r13, #20]
8f61273c:	e0332002 	eors	r2, r3, r2
8f612740:	e3a03000 	mov	r3, #0
8f612744:	1a000014 	bne	8f61279c <qpic_add_wr_page_cws_data_desc+0x190>
8f612748:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f61274c:	e1a02006 	mov	r2, r6
8f612750:	e3480f72 	movt	r0, #36722	; 0x8f72
8f612754:	e3a01000 	mov	r1, #0
}
8f612758:	e28dd01c 	add	r13, r13, #28
8f61275c:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	bam_sys_gen_event(&bam, DATA_CONSUMER_PIPE_INDEX, num_desc);
8f612760:	eafffaa9 	b	8f61120c <bam_sys_gen_event>
			bam_add_one_desc(&bam, DATA_CONSUMER_PIPE_INDEX, (unsigned char*)PA(start), len, flags);
8f612764:	e59d000c 	ldr	r0, [r13, #12]
			num_desc++;
8f612768:	e2866002 	add	r6, r6, #2
			bam_add_one_desc(&bam, DATA_CONSUMER_PIPE_INDEX, (unsigned char*)PA(start), len, flags);
8f61276c:	ebffbbf8 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f612770:	e1a0310a 	lsl	r3, r10, #2
8f612774:	e3a010c0 	mov	r1, #192	; 0xc0
8f612778:	e58d1000 	str	r1, [r13]
8f61277c:	e3a01000 	mov	r1, #0
8f612780:	e1a02000 	mov	r2, r0
8f612784:	e1a00009 	mov	r0, r9
8f612788:	ebfffae6 	bl	8f611328 <bam_add_one_desc>
	for( unsigned i = 0; i < flash.cws_per_page; i++)
8f61278c:	e597a03c 	ldr	r10, [r7, #60]	; 0x3c
8f612790:	eaffffc7 	b	8f6126b4 <qpic_add_wr_page_cws_data_desc+0xa8>
	unsigned num_desc = 0;
8f612794:	e1a0600a 	mov	r6, r10
8f612798:	eaffffe4 	b	8f612730 <qpic_add_wr_page_cws_data_desc+0x124>
	bam_sys_gen_event(&bam, DATA_CONSUMER_PIPE_INDEX, num_desc);
8f61279c:	eb008107 	bl	8f632bc0 <__stack_chk_fail>
8f6127a0:	8f74221c 	.word	0x8f74221c

8f6127a4 <qpic_nand_write_page>:
{
8f6127a4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f6127a8:	e24dd06c 	sub	r13, r13, #108	; 0x6c
8f6127ac:	e1a0c000 	mov	r12, r0
	if (cfg_mode == NAND_CFG_RAW)
8f6127b0:	e3510000 	cmp	r1, #0
{
8f6127b4:	e58d0010 	str	r0, [r13, #16]
8f6127b8:	e1a00002 	mov	r0, r2
8f6127bc:	e1a02003 	mov	r2, r3
8f6127c0:	e59f33d0 	ldr	r3, [pc, #976]	; 8f612b98 <qpic_nand_write_page+0x3f4>
8f6127c4:	e5933000 	ldr	r3, [r3]
8f6127c8:	e58d3064 	str	r3, [r13, #100]	; 0x64
8f6127cc:	e3a03000 	mov	r3, #0
	if (cfg_mode == NAND_CFG_RAW)
8f6127d0:	0a0000c6 	beq	8f612af0 <qpic_nand_write_page+0x34c>
		cfg.cfg0 = cfg0;
8f6127d4:	e30c1dfc 	movw	r1, #52732	; 0xcdfc
8f6127d8:	e3481f72 	movt	r1, #36722	; 0x8f72
		cfg.cfg1 = cfg1;
8f6127dc:	e30c3e04 	movw	r3, #52740	; 0xce04
8f6127e0:	e3483f72 	movt	r3, #36722	; 0x8f72
		cfg.cfg0 = cfg0;
8f6127e4:	e5911000 	ldr	r1, [r1]
		cfg.cfg1 = cfg1;
8f6127e8:	e5933000 	ldr	r3, [r3]
	cfg.addr0 = pg_addr << 16;
8f6127ec:	e59de010 	ldr	r14, [r13, #16]
		cfg.cfg0 = cfg0;
8f6127f0:	e58d1024 	str	r1, [r13, #36]	; 0x24
	cfg.exec = 1;
8f6127f4:	e3a01001 	mov	r1, #1
		cfg.cfg1 = cfg1;
8f6127f8:	e58d3028 	str	r3, [r13, #40]	; 0x28
	cfg.cmd = NAND_CMD_PRG_PAGE;
8f6127fc:	e3a03036 	mov	r3, #54	; 0x36
	cfg.addr0 = pg_addr << 16;
8f612800:	e1a0c80e 	lsl	r12, r14, #16
	cfg.cmd = NAND_CMD_PRG_PAGE;
8f612804:	e58d302c 	str	r3, [r13, #44]	; 0x2c
	cfg.addr0 = pg_addr << 16;
8f612808:	e58dc01c 	str	r12, [r13, #28]
	cfg.addr1 = (pg_addr >> 16) & 0xff;
8f61280c:	e7e7385e 	ubfx	r3, r14, #16, #8
	cfg.exec = 1;
8f612810:	e58d1038 	str	r1, [r13, #56]	; 0x38
	cfg.addr1 = (pg_addr >> 16) & 0xff;
8f612814:	e58d3020 	str	r3, [r13, #32]
	qpic_add_wr_page_cws_data_desc(buffer, cfg_mode, spareaddr);
8f612818:	ebffff7b 	bl	8f61260c <qpic_add_wr_page_cws_data_desc>
		ecc = ecc_bch_cfg;
8f61281c:	e30c3e0c 	movw	r3, #52748	; 0xce0c
8f612820:	e3483f72 	movt	r3, #36722	; 0x8f72
8f612824:	e5932000 	ldr	r2, [r3]
	bam_add_cmd_element(cmd_list_ptr, NAND_DEV0_ECC_CFG,
8f612828:	e30cae6c 	movw	r10, #52844	; 0xce6c
8f61282c:	e348af72 	movt	r10, #36722	; 0x8f72
8f612830:	e30252b0 	movw	r5, #8880	; 0x22b0
8f612834:	e3485f74 	movt	r5, #36724	; 0x8f74
8f612838:	e59a1000 	ldr	r1, [r10]
8f61283c:	e3a03000 	mov	r3, #0
8f612840:	e1a00005 	mov	r0, r5
	for (unsigned i = 0; i < flash.cws_per_page; i++)
8f612844:	e30cbe18 	movw	r11, #52760	; 0xce18
	bam_add_cmd_element(cmd_list_ptr, NAND_DEV0_ECC_CFG,
8f612848:	e2811028 	add	r1, r1, #40	; 0x28
	for (unsigned i = 0; i < flash.cws_per_page; i++)
8f61284c:	e348bf72 	movt	r11, #36722	; 0x8f72
	bam_add_cmd_element(cmd_list_ptr, NAND_DEV0_ECC_CFG,
8f612850:	ebfffb6c 	bl	8f611608 <bam_add_cmd_element>
	cmd_list_ptr = qpic_nand_add_addr_n_cfg_ce(cfg, cmd_list_ptr);
8f612854:	e2851010 	add	r1, r5, #16
8f612858:	e28d001c 	add	r0, r13, #28
8f61285c:	ebfffb83 	bl	8f611670 <qpic_nand_add_addr_n_cfg_ce>
	bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_CMD,
8f612860:	e59a1000 	ldr	r1, [r10]
8f612864:	e3a03000 	mov	r3, #0
8f612868:	e59d202c 	ldr	r2, [r13, #44]	; 0x2c
	cmd_list_ptr++;
8f61286c:	e2804010 	add	r4, r0, #16
	bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_CMD,
8f612870:	ebfffb64 	bl	8f611608 <bam_add_cmd_element>
					 (unsigned char*)PA((addr_t)cmd_list_ptr_start),
8f612874:	e1a00005 	mov	r0, r5
8f612878:	ebffbbb5 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f61287c:	e1a02000 	mov	r2, r0
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f612880:	e0440005 	sub	r0, r4, r5
					 (unsigned char*)PA((addr_t)cmd_list_ptr_start),
8f612884:	e1a05002 	mov	r5, r2
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f612888:	ebffbbb1 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	bam_add_one_desc(&bam,
8f61288c:	e3a0100c 	mov	r1, #12
8f612890:	e1a02005 	mov	r2, r5
8f612894:	e58d1000 	str	r1, [r13]
8f612898:	e3a01002 	mov	r1, #2
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f61289c:	e1a03000 	mov	r3, r0
	bam_add_one_desc(&bam,
8f6128a0:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f6128a4:	e3480f72 	movt	r0, #36722	; 0x8f72
8f6128a8:	ebfffa9e 	bl	8f611328 <bam_add_one_desc>
	for (unsigned i = 0; i < flash.cws_per_page; i++)
8f6128ac:	e59b303c 	ldr	r3, [r11, #60]	; 0x3c
8f6128b0:	e3530000 	cmp	r3, #0
8f6128b4:	0a0000a3 	beq	8f612b48 <qpic_nand_write_page+0x3a4>
8f6128b8:	e28d603c 	add	r6, r13, #60	; 0x3c
8f6128bc:	e30278f0 	movw	r7, #10480	; 0x28f0
		bam_add_one_desc(&bam,
8f6128c0:	e30c5d98 	movw	r5, #52632	; 0xcd98
	num_desc++;
8f6128c4:	e3a03001 	mov	r3, #1
8f6128c8:	e3487f74 	movt	r7, #36724	; 0x8f74
		bam_add_one_desc(&bam,
8f6128cc:	e3485f72 	movt	r5, #36722	; 0x8f72
	for (unsigned i = 0; i < flash.cws_per_page; i++)
8f6128d0:	e3a08000 	mov	r8, #0
8f6128d4:	e58d6014 	str	r6, [r13, #20]
	num_desc++;
8f6128d8:	e58d3008 	str	r3, [r13, #8]
8f6128dc:	ea000031 	b	8f6129a8 <qpic_nand_write_page+0x204>
	bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_STATUS, (uint32_t)flash_status_reset, CE_WRITE_TYPE);
8f6128e0:	e2811014 	add	r1, r1, #20
8f6128e4:	e3a03000 	mov	r3, #0
8f6128e8:	e3a02020 	mov	r2, #32
8f6128ec:	e1a00009 	mov	r0, r9
	cmd_list_ptr++;
8f6128f0:	e2844020 	add	r4, r4, #32
	bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_STATUS, (uint32_t)flash_status_reset, CE_WRITE_TYPE);
8f6128f4:	ebfffb43 	bl	8f611608 <bam_add_cmd_element>
						 (unsigned char*)PA((addr_t)cmd_list_ptr_start),
8f6128f8:	e1a00009 	mov	r0, r9
8f6128fc:	ebffbb94 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f612900:	e1a02000 	mov	r2, r0
						 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f612904:	e0440009 	sub	r0, r4, r9
						 (unsigned char*)PA((addr_t)cmd_list_ptr_start),
8f612908:	e1a09002 	mov	r9, r2
						 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f61290c:	ebffbb90 	bl	8f601754 <platform_get_virt_to_phys_mapping>
		bam_add_one_desc(&bam,
8f612910:	e1a02009 	mov	r2, r9
8f612914:	e3a01002 	mov	r1, #2
						 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f612918:	e1a03000 	mov	r3, r0
		bam_add_one_desc(&bam,
8f61291c:	e3a00088 	mov	r0, #136	; 0x88
8f612920:	e58d0000 	str	r0, [r13]
8f612924:	e1a00005 	mov	r0, r5
8f612928:	ebfffa7e 	bl	8f611328 <bam_add_one_desc>
		arch_clean_invalidate_cache_range((addr_t)&status[i], sizeof(uint32_t));
8f61292c:	e3a01004 	mov	r1, #4
8f612930:	e1a00006 	mov	r0, r6
8f612934:	eb003999 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	bam_sys_gen_event(&bam, CMD_PIPE_INDEX, num_desc);
8f612938:	e59d3008 	ldr	r3, [r13, #8]
8f61293c:	e3a01002 	mov	r1, #2
8f612940:	e1a00005 	mov	r0, r5
8f612944:	e2832003 	add	r2, r3, #3
8f612948:	ebfffa2f 	bl	8f61120c <bam_sys_gen_event>
	bam_wait_for_interrupt(&bam, CMD_PIPE_INDEX, P_PRCSD_DESC_EN_MASK);
8f61294c:	e3a02001 	mov	r2, #1
8f612950:	e3a01002 	mov	r1, #2
8f612954:	e1a00005 	mov	r0, r5
8f612958:	ebfff9fd 	bl	8f611154 <bam_wait_for_interrupt>
	bam_read_offset_update(&bam, CMD_PIPE_INDEX);
8f61295c:	e3a01002 	mov	r1, #2
8f612960:	e1a00005 	mov	r0, r5
8f612964:	ebfffa54 	bl	8f6112bc <bam_read_offset_update>
		arch_clean_invalidate_cache_range((addr_t)&status[i], sizeof(uint32_t));
8f612968:	e1a00006 	mov	r0, r6
8f61296c:	e3a01004 	mov	r1, #4
8f612970:	eb00398a 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
		status[i] = qpic_nand_check_status(status[i]);
8f612974:	e5960000 	ldr	r0, [r6]
	if (status & NAND_FLASH_ERR)
8f612978:	e2103e15 	ands	r3, r0, #336	; 0x150
8f61297c:	0a000001 	beq	8f612988 <qpic_nand_write_page+0x1e4>
8f612980:	ebfffbfa 	bl	8f611970 <qpic_nand_check_status.part.0>
8f612984:	e1a03000 	mov	r3, r0
	for (unsigned i = 0; i < flash.cws_per_page; i++)
8f612988:	e59b203c 	ldr	r2, [r11, #60]	; 0x3c
8f61298c:	e2888001 	add	r8, r8, #1
		num_desc = 0;
8f612990:	e3a01000 	mov	r1, #0
	for (unsigned i = 0; i < flash.cws_per_page; i++)
8f612994:	e2877010 	add	r7, r7, #16
8f612998:	e1580002 	cmp	r8, r2
		num_desc = 0;
8f61299c:	e58d1008 	str	r1, [r13, #8]
		status[i] = qpic_nand_check_status(status[i]);
8f6129a0:	e4863004 	str	r3, [r6], #4
	for (unsigned i = 0; i < flash.cws_per_page; i++)
8f6129a4:	2a00003b 	bcs	8f612a98 <qpic_nand_write_page+0x2f4>
		bam_add_cmd_element(cmd_list_ptr, NAND_EXEC_CMD, (uint32_t)cfg->exec, CE_WRITE_TYPE);
8f6129a8:	e59a1000 	ldr	r1, [r10]
8f6129ac:	e3a03000 	mov	r3, #0
8f6129b0:	e59d2038 	ldr	r2, [r13, #56]	; 0x38
8f6129b4:	e1a00004 	mov	r0, r4
8f6129b8:	e2811010 	add	r1, r1, #16
8f6129bc:	ebfffb11 	bl	8f611608 <bam_add_cmd_element>
						 (unsigned char*)PA((addr_t)cmd_list_ptr_start),
8f6129c0:	e1a00004 	mov	r0, r4
8f6129c4:	ebffbb62 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f6129c8:	e1a09000 	mov	r9, r0
						 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f6129cc:	e3a00010 	mov	r0, #16
8f6129d0:	ebffbb5f 	bl	8f601754 <platform_get_virt_to_phys_mapping>
		bam_add_one_desc(&bam,
8f6129d4:	e1a02009 	mov	r2, r9
8f6129d8:	e3a01018 	mov	r1, #24
8f6129dc:	e58d1000 	str	r1, [r13]
8f6129e0:	e3a01002 	mov	r1, #2
		cmd_list_ptr++;
8f6129e4:	e2849010 	add	r9, r4, #16
						 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f6129e8:	e1a03000 	mov	r3, r0
		bam_add_one_desc(&bam,
8f6129ec:	e1a00005 	mov	r0, r5
8f6129f0:	ebfffa4c 	bl	8f611328 <bam_add_one_desc>
	bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_STATUS, (uint32_t)PA((addr_t)flash_status_read), CE_READ_TYPE);
8f6129f4:	e59a1000 	ldr	r1, [r10]
8f6129f8:	e1a00006 	mov	r0, r6
8f6129fc:	e2811014 	add	r1, r1, #20
8f612a00:	e58d100c 	str	r1, [r13, #12]
8f612a04:	ebffbb52 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f612a08:	e59d100c 	ldr	r1, [r13, #12]
8f612a0c:	e3a03001 	mov	r3, #1
8f612a10:	e1a02000 	mov	r2, r0
8f612a14:	e1a00007 	mov	r0, r7
8f612a18:	ebfffafa 	bl	8f611608 <bam_add_cmd_element>
						 (unsigned char*)PA((addr_t)cmd_list_read_ptr_start),
8f612a1c:	e1a00007 	mov	r0, r7
8f612a20:	ebffbb4b 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f612a24:	e1a02000 	mov	r2, r0
						 PA((uint32_t)cmd_list_read_ptr - (uint32_t)cmd_list_read_ptr_start),
8f612a28:	e3a00010 	mov	r0, #16
						 (unsigned char*)PA((addr_t)cmd_list_read_ptr_start),
8f612a2c:	e58d200c 	str	r2, [r13, #12]
						 PA((uint32_t)cmd_list_read_ptr - (uint32_t)cmd_list_read_ptr_start),
8f612a30:	ebffbb47 	bl	8f601754 <platform_get_virt_to_phys_mapping>
		bam_add_one_desc(&bam,
8f612a34:	e3a01008 	mov	r1, #8
8f612a38:	e59d200c 	ldr	r2, [r13, #12]
8f612a3c:	e58d1000 	str	r1, [r13]
8f612a40:	e3a01002 	mov	r1, #2
						 PA((uint32_t)cmd_list_read_ptr - (uint32_t)cmd_list_read_ptr_start),
8f612a44:	e1a03000 	mov	r3, r0
		bam_add_one_desc(&bam,
8f612a48:	e1a00005 	mov	r0, r5
8f612a4c:	ebfffa35 	bl	8f611328 <bam_add_one_desc>
		if (i == flash.cws_per_page - 1)
8f612a50:	e59b303c 	ldr	r3, [r11, #60]	; 0x3c
	bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_STATUS, (uint32_t)flash_status_reset, CE_WRITE_TYPE);
8f612a54:	e59a1000 	ldr	r1, [r10]
		if (i == flash.cws_per_page - 1)
8f612a58:	e2433001 	sub	r3, r3, #1
8f612a5c:	e1580003 	cmp	r8, r3
8f612a60:	1affff9e 	bne	8f6128e0 <qpic_nand_write_page+0x13c>
	bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_STATUS, (uint32_t)flash_status_reset, CE_WRITE_TYPE);
8f612a64:	e2811014 	add	r1, r1, #20
8f612a68:	e3a03000 	mov	r3, #0
8f612a6c:	e3a02020 	mov	r2, #32
8f612a70:	e1a00009 	mov	r0, r9
8f612a74:	ebfffae3 	bl	8f611608 <bam_add_cmd_element>
		bam_add_cmd_element(cmd_list_ptr, NAND_READ_STATUS, (uint32_t)read_status_reset, CE_WRITE_TYPE);
8f612a78:	e59a1000 	ldr	r1, [r10]
8f612a7c:	e2840020 	add	r0, r4, #32
8f612a80:	e3a03000 	mov	r3, #0
8f612a84:	e2811044 	add	r1, r1, #68	; 0x44
8f612a88:	e3a020c0 	mov	r2, #192	; 0xc0
		cmd_list_ptr++;
8f612a8c:	e2844030 	add	r4, r4, #48	; 0x30
		bam_add_cmd_element(cmd_list_ptr, NAND_READ_STATUS, (uint32_t)read_status_reset, CE_WRITE_TYPE);
8f612a90:	ebfffadc 	bl	8f611608 <bam_add_cmd_element>
	return cmd_list_ptr;
8f612a94:	eaffff97 	b	8f6128f8 <qpic_nand_write_page+0x154>
	for(unsigned i = 0; i < flash.cws_per_page; i++)
8f612a98:	e1520001 	cmp	r2, r1
8f612a9c:	0a000029 	beq	8f612b48 <qpic_nand_write_page+0x3a4>
8f612aa0:	e59d6014 	ldr	r6, [r13, #20]
8f612aa4:	e1a04001 	mov	r4, r1
8f612aa8:	ea000003 	b	8f612abc <qpic_nand_write_page+0x318>
8f612aac:	e59b303c 	ldr	r3, [r11, #60]	; 0x3c
8f612ab0:	e2844001 	add	r4, r4, #1
8f612ab4:	e1530004 	cmp	r3, r4
8f612ab8:	9a000022 	bls	8f612b48 <qpic_nand_write_page+0x3a4>
		nand_ret = qpic_nand_check_status(status[i]);
8f612abc:	e4960004 	ldr	r0, [r6], #4
	if (status & NAND_FLASH_ERR)
8f612ac0:	e3100e15 	tst	r0, #336	; 0x150
8f612ac4:	0afffff8 	beq	8f612aac <qpic_nand_write_page+0x308>
8f612ac8:	ebfffba8 	bl	8f611970 <qpic_nand_check_status.part.0>
		if (nand_ret)
8f612acc:	e3500000 	cmp	r0, #0
8f612ad0:	0afffff5 	beq	8f612aac <qpic_nand_write_page+0x308>
			dprintf(CRITICAL,
8f612ad4:	e1a05000 	mov	r5, r0
8f612ad8:	e59d2010 	ldr	r2, [r13, #16]
8f612adc:	e1a01004 	mov	r1, r4
8f612ae0:	e3040218 	movw	r0, #16920	; 0x4218
8f612ae4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f612ae8:	eb007fa1 	bl	8f632974 <_dprintf>
			break;
8f612aec:	ea000016 	b	8f612b4c <qpic_nand_write_page+0x3a8>
		cfg.cfg0 = cfg0_raw;
8f612af0:	e30c3e00 	movw	r3, #52736	; 0xce00
8f612af4:	e3483f72 	movt	r3, #36722	; 0x8f72
8f612af8:	e5933000 	ldr	r3, [r3]
8f612afc:	e58d3024 	str	r3, [r13, #36]	; 0x24
		cfg.cfg1 = cfg1_raw;
8f612b00:	e30c3e08 	movw	r3, #52744	; 0xce08
8f612b04:	e3483f72 	movt	r3, #36722	; 0x8f72
8f612b08:	e5933000 	ldr	r3, [r3]
8f612b0c:	e58d3028 	str	r3, [r13, #40]	; 0x28
	cfg.cmd = NAND_CMD_PRG_PAGE;
8f612b10:	e3a03036 	mov	r3, #54	; 0x36
8f612b14:	e58d302c 	str	r3, [r13, #44]	; 0x2c
	cfg.exec = 1;
8f612b18:	e3a03001 	mov	r3, #1
8f612b1c:	e58d3038 	str	r3, [r13, #56]	; 0x38
	cfg.addr0 = pg_addr << 16;
8f612b20:	e1a0380c 	lsl	r3, r12, #16
8f612b24:	e58d301c 	str	r3, [r13, #28]
	cfg.addr1 = (pg_addr >> 16) & 0xff;
8f612b28:	e7e7385c 	ubfx	r3, r12, #16, #8
8f612b2c:	e58d3020 	str	r3, [r13, #32]
	qpic_add_wr_page_cws_data_desc(buffer, cfg_mode, spareaddr);
8f612b30:	ebfffeb5 	bl	8f61260c <qpic_add_wr_page_cws_data_desc>
		ecc = ecc_bch_cfg | 0x1; /* Disable ECC */
8f612b34:	e30c3e0c 	movw	r3, #52748	; 0xce0c
8f612b38:	e3483f72 	movt	r3, #36722	; 0x8f72
8f612b3c:	e5932000 	ldr	r2, [r3]
8f612b40:	e3822001 	orr	r2, r2, #1
8f612b44:	eaffff37 	b	8f612828 <qpic_nand_write_page+0x84>
	for(unsigned i = 0; i < flash.cws_per_page; i++)
8f612b48:	e3a05000 	mov	r5, #0
	bam_wait_for_interrupt(&bam, pipe_num, P_PRCSD_DESC_EN_MASK);
8f612b4c:	e3a02001 	mov	r2, #1
8f612b50:	e3a01000 	mov	r1, #0
8f612b54:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f612b58:	e3480f72 	movt	r0, #36722	; 0x8f72
8f612b5c:	ebfff97c 	bl	8f611154 <bam_wait_for_interrupt>
	bam_read_offset_update(&bam, pipe_num);
8f612b60:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f612b64:	e3a01000 	mov	r1, #0
8f612b68:	e3480f72 	movt	r0, #36722	; 0x8f72
8f612b6c:	ebfff9d2 	bl	8f6112bc <bam_read_offset_update>
}
8f612b70:	e59f3020 	ldr	r3, [pc, #32]	; 8f612b98 <qpic_nand_write_page+0x3f4>
8f612b74:	e5932000 	ldr	r2, [r3]
8f612b78:	e59d3064 	ldr	r3, [r13, #100]	; 0x64
8f612b7c:	e0332002 	eors	r2, r3, r2
8f612b80:	e3a03000 	mov	r3, #0
8f612b84:	1a000002 	bne	8f612b94 <qpic_nand_write_page+0x3f0>
8f612b88:	e1a00005 	mov	r0, r5
8f612b8c:	e28dd06c 	add	r13, r13, #108	; 0x6c
8f612b90:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
8f612b94:	eb008009 	bl	8f632bc0 <__stack_chk_fail>
8f612b98:	8f74221c 	.word	0x8f74221c

8f612b9c <qpic_nand_mark_badblock.isra.0>:
qpic_nand_mark_badblock(uint32_t page)
8f612b9c:	e92d4010 	push	{r4, r14}
8f612ba0:	e24ddf86 	sub	r13, r13, #536	; 0x218
8f612ba4:	e59f3068 	ldr	r3, [pc, #104]	; 8f612c14 <qpic_nand_mark_badblock.isra.0+0x78>
8f612ba8:	e1a04000 	mov	r4, r0
	memset(empty_buf, 0, NAND_CW_SIZE_8_BIT_ECC);
8f612bac:	e3a02f85 	mov	r2, #532	; 0x214
8f612bb0:	e3a01000 	mov	r1, #0
8f612bb4:	e1a0000d 	mov	r0, r13
qpic_nand_mark_badblock(uint32_t page)
8f612bb8:	e5933000 	ldr	r3, [r3]
8f612bbc:	e58d3214 	str	r3, [r13, #532]	; 0x214
8f612bc0:	e3a03000 	mov	r3, #0
	memset(empty_buf, 0, NAND_CW_SIZE_8_BIT_ECC);
8f612bc4:	eb0085be 	bl	8f6342c4 <memset>
	if (page & flash.num_pages_per_blk_mask)
8f612bc8:	e30c3e18 	movw	r3, #52760	; 0xce18
8f612bcc:	e3483f72 	movt	r3, #36722	; 0x8f72
	return qpic_nand_write_page(page, NAND_CFG_RAW, empty_buf, 0);
8f612bd0:	e1a0200d 	mov	r2, r13
	if (page & flash.num_pages_per_blk_mask)
8f612bd4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
8f612bd8:	e1130004 	tst	r3, r4
		page = page - (page & flash.num_pages_per_blk_mask);
8f612bdc:	11c44003 	bicne	r4, r4, r3
	return qpic_nand_write_page(page, NAND_CFG_RAW, empty_buf, 0);
8f612be0:	e3a03000 	mov	r3, #0
8f612be4:	e1a01003 	mov	r1, r3
8f612be8:	e1a00004 	mov	r0, r4
8f612bec:	ebfffeec 	bl	8f6127a4 <qpic_nand_write_page>
}
8f612bf0:	e59f301c 	ldr	r3, [pc, #28]	; 8f612c14 <qpic_nand_mark_badblock.isra.0+0x78>
8f612bf4:	e5932000 	ldr	r2, [r3]
8f612bf8:	e59d3214 	ldr	r3, [r13, #532]	; 0x214
8f612bfc:	e0332002 	eors	r2, r3, r2
8f612c00:	e3a03000 	mov	r3, #0
8f612c04:	1a000001 	bne	8f612c10 <qpic_nand_mark_badblock.isra.0+0x74>
8f612c08:	e28ddf86 	add	r13, r13, #536	; 0x218
8f612c0c:	e8bd8010 	pop	{r4, r15}
8f612c10:	eb007fea 	bl	8f632bc0 <__stack_chk_fail>
8f612c14:	8f74221c 	.word	0x8f74221c

8f612c18 <qpic_nand_blk_erase>:
	uint32_t blk_addr = page / flash.num_pages_per_blk;
8f612c18:	e30c3e18 	movw	r3, #52760	; 0xce18
8f612c1c:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f612c20:	e59f22b8 	ldr	r2, [pc, #696]	; 8f612ee0 <qpic_nand_blk_erase+0x2c8>
8f612c24:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
8f612c28:	e24dd030 	sub	r13, r13, #48	; 0x30
	uint32_t blk_addr = page / flash.num_pages_per_blk;
8f612c2c:	e5931028 	ldr	r1, [r3, #40]	; 0x28
{
8f612c30:	e5922000 	ldr	r2, [r2]
8f612c34:	e58d202c 	str	r2, [r13, #44]	; 0x2c
8f612c38:	e3a02000 	mov	r2, #0
8f612c3c:	e1a07000 	mov	r7, r0
	uint32_t blk_addr = page / flash.num_pages_per_blk;
8f612c40:	fa00a7e4 	blx	8f63cbd8 <__udivsi3>
8f612c44:	e1a09000 	mov	r9, r0
	if (qpic_nand_block_isbad(page))
8f612c48:	e1a00007 	mov	r0, r7
8f612c4c:	ebfffbb4 	bl	8f611b24 <qpic_nand_block_isbad>
8f612c50:	e2504000 	subs	r4, r0, #0
8f612c54:	1a00009a 	bne	8f612ec4 <qpic_nand_blk_erase+0x2ac>
	cfg.cfg1 = cfg1;
8f612c58:	e30c2e04 	movw	r2, #52740	; 0xce04
8f612c5c:	e3482f72 	movt	r2, #36722	; 0x8f72
	cfg.cfg0 = cfg0 & ~(7U << NAND_DEV0_CFG0_CW_PER_PAGE_SHIFT);
8f612c60:	e30c3dfc 	movw	r3, #52732	; 0xcdfc
8f612c64:	e3483f72 	movt	r3, #36722	; 0x8f72
	cfg.cfg1 = cfg1;
8f612c68:	e5922000 	ldr	r2, [r2]
	cmd_list_ptr = qpic_nand_add_cmd_ce(&cfg, cmd_list_ptr);
8f612c6c:	e30252b0 	movw	r5, #8880	; 0x22b0
8f612c70:	e3485f74 	movt	r5, #36724	; 0x8f74
	cfg.cfg0 = cfg0 & ~(7U << NAND_DEV0_CFG0_CW_PER_PAGE_SHIFT);
8f612c74:	e5933000 	ldr	r3, [r3]
	cmd_list_ptr = qpic_nand_add_cmd_ce(&cfg, cmd_list_ptr);
8f612c78:	e28d000c 	add	r0, r13, #12
	cfg.exec = 1;
8f612c7c:	e3a08001 	mov	r8, #1
	cmd_list_ptr = qpic_nand_add_cmd_ce(&cfg, cmd_list_ptr);
8f612c80:	e1a01005 	mov	r1, r5
	cfg.cfg0 = cfg0 & ~(7U << NAND_DEV0_CFG0_CW_PER_PAGE_SHIFT);
8f612c84:	e3c33d07 	bic	r3, r3, #448	; 0x1c0
	cfg.cfg1 = cfg1;
8f612c88:	e58d2018 	str	r2, [r13, #24]
	cfg.cmd = NAND_CMD_BLOCK_ERASE;
8f612c8c:	e3a0203a 	mov	r2, #58	; 0x3a
	cfg.cfg0 = cfg0 & ~(7U << NAND_DEV0_CFG0_CW_PER_PAGE_SHIFT);
8f612c90:	e58d3014 	str	r3, [r13, #20]
	cfg.cmd = NAND_CMD_BLOCK_ERASE;
8f612c94:	e58d201c 	str	r2, [r13, #28]
	cfg.addr0 = page;
8f612c98:	e58d700c 	str	r7, [r13, #12]
	cfg.addr1 = 0;
8f612c9c:	e58d4010 	str	r4, [r13, #16]
	cfg.exec = 1;
8f612ca0:	e58d8028 	str	r8, [r13, #40]	; 0x28
	cmd_list_ptr = qpic_nand_add_cmd_ce(&cfg, cmd_list_ptr);
8f612ca4:	ebfffb5b 	bl	8f611a18 <qpic_nand_add_cmd_ce>
8f612ca8:	e1a06000 	mov	r6, r0
					 (unsigned char*)PA((addr_t)cmd_list_ptr_start),
8f612cac:	e1a00005 	mov	r0, r5
8f612cb0:	ebffbaa7 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f612cb4:	e1a02000 	mov	r2, r0
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f612cb8:	e0460005 	sub	r0, r6, r5
					 (unsigned char*)PA((addr_t)cmd_list_ptr_start),
8f612cbc:	e1a05002 	mov	r5, r2
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f612cc0:	ebffbaa3 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	bam_add_one_desc(&bam,
8f612cc4:	e1a02005 	mov	r2, r5
8f612cc8:	e3a01002 	mov	r1, #2
	status = qpic_nand_read_reg(NAND_FLASH_STATUS, 0);
8f612ccc:	e30c5e6c 	movw	r5, #52844	; 0xce6c
8f612cd0:	e3485f72 	movt	r5, #36722	; 0x8f72
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f612cd4:	e1a03000 	mov	r3, r0
	bam_add_one_desc(&bam,
8f612cd8:	e3a0009c 	mov	r0, #156	; 0x9c
8f612cdc:	e58d0000 	str	r0, [r13]
8f612ce0:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f612ce4:	e3480f72 	movt	r0, #36722	; 0x8f72
8f612ce8:	ebfff98e 	bl	8f611328 <bam_add_one_desc>
	bam_sys_gen_event(&bam, CMD_PIPE_INDEX, num_desc);
8f612cec:	e1a02008 	mov	r2, r8
8f612cf0:	e3a01002 	mov	r1, #2
8f612cf4:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f612cf8:	e3480f72 	movt	r0, #36722	; 0x8f72
8f612cfc:	ebfff942 	bl	8f61120c <bam_sys_gen_event>
	bam_wait_for_interrupt(&bam, CMD_PIPE_INDEX, P_PRCSD_DESC_EN_MASK);
8f612d00:	e1a02008 	mov	r2, r8
8f612d04:	e3a01002 	mov	r1, #2
8f612d08:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f612d0c:	e3480f72 	movt	r0, #36722	; 0x8f72
8f612d10:	ebfff90f 	bl	8f611154 <bam_wait_for_interrupt>
	bam_read_offset_update(&bam, CMD_PIPE_INDEX);
8f612d14:	e3a01002 	mov	r1, #2
8f612d18:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f612d1c:	e3480f72 	movt	r0, #36722	; 0x8f72
8f612d20:	ebfff965 	bl	8f6112bc <bam_read_offset_update>
	status = qpic_nand_read_reg(NAND_FLASH_STATUS, 0);
8f612d24:	e5950000 	ldr	r0, [r5]
8f612d28:	e1a01004 	mov	r1, r4
8f612d2c:	e2800014 	add	r0, r0, #20
8f612d30:	ebfffa7b 	bl	8f611724 <qpic_nand_read_reg>
	bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_STATUS, (uint32_t)PA((addr_t)flash_status_read), CE_READ_TYPE);
8f612d34:	e595a000 	ldr	r10, [r5]
8f612d38:	e28aa014 	add	r10, r10, #20
	status = qpic_nand_read_reg(NAND_FLASH_STATUS, 0);
8f612d3c:	e58d0008 	str	r0, [r13, #8]
	bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_STATUS, (uint32_t)PA((addr_t)flash_status_read), CE_READ_TYPE);
8f612d40:	e28d0008 	add	r0, r13, #8
8f612d44:	ebffba82 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f612d48:	e1a0100a 	mov	r1, r10
8f612d4c:	e1a03008 	mov	r3, r8
8f612d50:	e1a02000 	mov	r2, r0
8f612d54:	e30208f0 	movw	r0, #10480	; 0x28f0
8f612d58:	e3480f74 	movt	r0, #36724	; 0x8f74
8f612d5c:	ebfffa29 	bl	8f611608 <bam_add_cmd_element>
					 (unsigned char*)PA((addr_t)cmd_list_read_ptr_start),
8f612d60:	e30208f0 	movw	r0, #10480	; 0x28f0
8f612d64:	e3480f74 	movt	r0, #36724	; 0x8f74
8f612d68:	ebffba79 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f612d6c:	e1a0a000 	mov	r10, r0
					 PA((uint32_t)cmd_list_read_ptr - (uint32_t)cmd_list_read_ptr_start),
8f612d70:	e3a00010 	mov	r0, #16
8f612d74:	ebffba76 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	bam_add_one_desc(&bam,
8f612d78:	e1a0200a 	mov	r2, r10
8f612d7c:	e3a01002 	mov	r1, #2
					 PA((uint32_t)cmd_list_read_ptr - (uint32_t)cmd_list_read_ptr_start),
8f612d80:	e1a03000 	mov	r3, r0
	bam_add_one_desc(&bam,
8f612d84:	e3a00008 	mov	r0, #8
8f612d88:	e58d0000 	str	r0, [r13]
8f612d8c:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f612d90:	e3480f72 	movt	r0, #36722	; 0x8f72
8f612d94:	ebfff963 	bl	8f611328 <bam_add_one_desc>
	bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_STATUS, (uint32_t)flash_status_reset, CE_WRITE_TYPE);
8f612d98:	e5951000 	ldr	r1, [r5]
8f612d9c:	e1a03004 	mov	r3, r4
8f612da0:	e3a02020 	mov	r2, #32
8f612da4:	e2811014 	add	r1, r1, #20
8f612da8:	e1a00006 	mov	r0, r6
8f612dac:	ebfffa15 	bl	8f611608 <bam_add_cmd_element>
		bam_add_cmd_element(cmd_list_ptr, NAND_READ_STATUS, (uint32_t)read_status_reset, CE_WRITE_TYPE);
8f612db0:	e5951000 	ldr	r1, [r5]
8f612db4:	e1a03004 	mov	r3, r4
8f612db8:	e3a020c0 	mov	r2, #192	; 0xc0
8f612dbc:	e2811044 	add	r1, r1, #68	; 0x44
8f612dc0:	e2860010 	add	r0, r6, #16
8f612dc4:	ebfffa0f 	bl	8f611608 <bam_add_cmd_element>
					 (unsigned char*)PA((addr_t)cmd_list_ptr_start),
8f612dc8:	e1a00006 	mov	r0, r6
8f612dcc:	ebffba60 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f612dd0:	e1a06000 	mov	r6, r0
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f612dd4:	e3a00020 	mov	r0, #32
8f612dd8:	ebffba5d 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	bam_add_one_desc(&bam,
8f612ddc:	e1a02006 	mov	r2, r6
8f612de0:	e3a01002 	mov	r1, #2
					 PA((uint32_t)cmd_list_ptr - (uint32_t)cmd_list_ptr_start),
8f612de4:	e1a03000 	mov	r3, r0
	bam_add_one_desc(&bam,
8f612de8:	e3a00088 	mov	r0, #136	; 0x88
8f612dec:	e58d0000 	str	r0, [r13]
8f612df0:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f612df4:	e3480f72 	movt	r0, #36722	; 0x8f72
8f612df8:	ebfff94a 	bl	8f611328 <bam_add_one_desc>
	arch_clean_invalidate_cache_range((addr_t)&status, sizeof(uint32_t));
8f612dfc:	e28d0008 	add	r0, r13, #8
8f612e00:	e3a01004 	mov	r1, #4
8f612e04:	eb003865 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	bam_sys_gen_event(&bam, CMD_PIPE_INDEX, num_desc);
8f612e08:	e3a02002 	mov	r2, #2
8f612e0c:	e1a01002 	mov	r1, r2
8f612e10:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f612e14:	e3480f72 	movt	r0, #36722	; 0x8f72
8f612e18:	ebfff8fb 	bl	8f61120c <bam_sys_gen_event>
	bam_wait_for_interrupt(&bam, CMD_PIPE_INDEX, P_PRCSD_DESC_EN_MASK);
8f612e1c:	e1a02008 	mov	r2, r8
8f612e20:	e3a01002 	mov	r1, #2
8f612e24:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f612e28:	e3480f72 	movt	r0, #36722	; 0x8f72
8f612e2c:	ebfff8c8 	bl	8f611154 <bam_wait_for_interrupt>
	bam_read_offset_update(&bam, CMD_PIPE_INDEX);
8f612e30:	e3a01002 	mov	r1, #2
8f612e34:	e30c0d98 	movw	r0, #52632	; 0xcd98
8f612e38:	e3480f72 	movt	r0, #36722	; 0x8f72
8f612e3c:	ebfff91e 	bl	8f6112bc <bam_read_offset_update>
	arch_clean_invalidate_cache_range((addr_t)&status, sizeof(uint32_t));
8f612e40:	e28d0008 	add	r0, r13, #8
8f612e44:	e3a01004 	mov	r1, #4
8f612e48:	eb003854 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	status = qpic_nand_check_status(status);
8f612e4c:	e59d0008 	ldr	r0, [r13, #8]
	if (status & NAND_FLASH_ERR)
8f612e50:	e2103e15 	ands	r3, r0, #336	; 0x150
8f612e54:	0a000001 	beq	8f612e60 <qpic_nand_blk_erase+0x248>
8f612e58:	ebfffac4 	bl	8f611970 <qpic_nand_check_status.part.0>
8f612e5c:	e1a03000 	mov	r3, r0
	qpic_nand_read_reg(NAND_FLASH_STATUS, BAM_DESC_UNLOCK_FLAG);
8f612e60:	e5950000 	ldr	r0, [r5]
8f612e64:	e3a01002 	mov	r1, #2
	status = qpic_nand_check_status(status);
8f612e68:	e58d3008 	str	r3, [r13, #8]
	qpic_nand_read_reg(NAND_FLASH_STATUS, BAM_DESC_UNLOCK_FLAG);
8f612e6c:	e2800014 	add	r0, r0, #20
8f612e70:	ebfffa2b 	bl	8f611724 <qpic_nand_read_reg>
	if (status)
8f612e74:	e59d3008 	ldr	r3, [r13, #8]
8f612e78:	e3530000 	cmp	r3, #0
8f612e7c:	1a000008 	bne	8f612ea4 <qpic_nand_blk_erase+0x28c>
}
8f612e80:	e59f3058 	ldr	r3, [pc, #88]	; 8f612ee0 <qpic_nand_blk_erase+0x2c8>
8f612e84:	e5932000 	ldr	r2, [r3]
8f612e88:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
8f612e8c:	e0332002 	eors	r2, r3, r2
8f612e90:	e3a03000 	mov	r3, #0
8f612e94:	1a000010 	bne	8f612edc <qpic_nand_blk_erase+0x2c4>
8f612e98:	e1a00004 	mov	r0, r4
8f612e9c:	e28dd030 	add	r13, r13, #48	; 0x30
8f612ea0:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
		dprintf(CRITICAL,
8f612ea4:	e1a01009 	mov	r1, r9
8f612ea8:	e304023c 	movw	r0, #16956	; 0x423c
8f612eac:	e3480f70 	movt	r0, #36720	; 0x8f70
		return NANDC_RESULT_FAILURE;
8f612eb0:	e3a04001 	mov	r4, #1
		dprintf(CRITICAL,
8f612eb4:	eb007eae 	bl	8f632974 <_dprintf>
		qpic_nand_mark_badblock(page);
8f612eb8:	e1a00007 	mov	r0, r7
8f612ebc:	ebffff36 	bl	8f612b9c <qpic_nand_mark_badblock.isra.0>
		return NANDC_RESULT_FAILURE;
8f612ec0:	eaffffee 	b	8f612e80 <qpic_nand_blk_erase+0x268>
		dprintf(CRITICAL,
8f612ec4:	e1a01009 	mov	r1, r9
8f612ec8:	e304023c 	movw	r0, #16956	; 0x423c
8f612ecc:	e3480f70 	movt	r0, #36720	; 0x8f70
		return NANDC_RESULT_FAILURE;
8f612ed0:	e3a04001 	mov	r4, #1
		dprintf(CRITICAL,
8f612ed4:	eb007ea6 	bl	8f632974 <_dprintf>
		return NANDC_RESULT_FAILURE;
8f612ed8:	eaffffe8 	b	8f612e80 <qpic_nand_blk_erase+0x268>
}
8f612edc:	eb007f37 	bl	8f632bc0 <__stack_chk_fail>
8f612ee0:	8f74221c 	.word	0x8f74221c

8f612ee4 <flash_page_size>:
	return flash.page_size;
8f612ee4:	e30c3e18 	movw	r3, #52760	; 0xce18
8f612ee8:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f612eec:	e59f2038 	ldr	r2, [pc, #56]	; 8f612f2c <flash_page_size+0x48>
8f612ef0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f612ef4:	e24dd00c 	sub	r13, r13, #12
	return flash.page_size;
8f612ef8:	e5930014 	ldr	r0, [r3, #20]
{
8f612efc:	e5922000 	ldr	r2, [r2]
8f612f00:	e58d2004 	str	r2, [r13, #4]
8f612f04:	e3a02000 	mov	r2, #0
}
8f612f08:	e59f301c 	ldr	r3, [pc, #28]	; 8f612f2c <flash_page_size+0x48>
8f612f0c:	e5932000 	ldr	r2, [r3]
8f612f10:	e59d3004 	ldr	r3, [r13, #4]
8f612f14:	e0332002 	eors	r2, r3, r2
8f612f18:	e3a03000 	mov	r3, #0
8f612f1c:	1a000001 	bne	8f612f28 <flash_page_size+0x44>
8f612f20:	e28dd00c 	add	r13, r13, #12
8f612f24:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f612f28:	eb007f24 	bl	8f632bc0 <__stack_chk_fail>
8f612f2c:	8f74221c 	.word	0x8f74221c

8f612f30 <flash_block_size>:
    return flash.block_size;
8f612f30:	e30c3e18 	movw	r3, #52760	; 0xce18
8f612f34:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f612f38:	e59f2038 	ldr	r2, [pc, #56]	; 8f612f78 <flash_block_size+0x48>
8f612f3c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f612f40:	e24dd00c 	sub	r13, r13, #12
    return flash.block_size;
8f612f44:	e5930018 	ldr	r0, [r3, #24]
{
8f612f48:	e5922000 	ldr	r2, [r2]
8f612f4c:	e58d2004 	str	r2, [r13, #4]
8f612f50:	e3a02000 	mov	r2, #0
}
8f612f54:	e59f301c 	ldr	r3, [pc, #28]	; 8f612f78 <flash_block_size+0x48>
8f612f58:	e5932000 	ldr	r2, [r3]
8f612f5c:	e59d3004 	ldr	r3, [r13, #4]
8f612f60:	e0332002 	eors	r2, r3, r2
8f612f64:	e3a03000 	mov	r3, #0
8f612f68:	1a000001 	bne	8f612f74 <flash_block_size+0x44>
8f612f6c:	e28dd00c 	add	r13, r13, #12
8f612f70:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f612f74:	eb007f11 	bl	8f632bc0 <__stack_chk_fail>
8f612f78:	8f74221c 	.word	0x8f74221c

8f612f7c <flash_num_pages_per_blk>:
	return flash.num_pages_per_blk;
8f612f7c:	e30c3e18 	movw	r3, #52760	; 0xce18
8f612f80:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f612f84:	e59f2038 	ldr	r2, [pc, #56]	; 8f612fc4 <flash_num_pages_per_blk+0x48>
8f612f88:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f612f8c:	e24dd00c 	sub	r13, r13, #12
	return flash.num_pages_per_blk;
8f612f90:	e5930028 	ldr	r0, [r3, #40]	; 0x28
{
8f612f94:	e5922000 	ldr	r2, [r2]
8f612f98:	e58d2004 	str	r2, [r13, #4]
8f612f9c:	e3a02000 	mov	r2, #0
}
8f612fa0:	e59f301c 	ldr	r3, [pc, #28]	; 8f612fc4 <flash_num_pages_per_blk+0x48>
8f612fa4:	e5932000 	ldr	r2, [r3]
8f612fa8:	e59d3004 	ldr	r3, [r13, #4]
8f612fac:	e0332002 	eors	r2, r3, r2
8f612fb0:	e3a03000 	mov	r3, #0
8f612fb4:	1a000001 	bne	8f612fc0 <flash_num_pages_per_blk+0x44>
8f612fb8:	e28dd00c 	add	r13, r13, #12
8f612fbc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f612fc0:	eb007efe 	bl	8f632bc0 <__stack_chk_fail>
8f612fc4:	8f74221c 	.word	0x8f74221c

8f612fc8 <flash_get_ptable>:
	return flash_ptable;
8f612fc8:	e30c3e64 	movw	r3, #52836	; 0xce64
8f612fcc:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f612fd0:	e59f2038 	ldr	r2, [pc, #56]	; 8f613010 <flash_get_ptable+0x48>
8f612fd4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f612fd8:	e24dd00c 	sub	r13, r13, #12
	return flash_ptable;
8f612fdc:	e5930000 	ldr	r0, [r3]
{
8f612fe0:	e5922000 	ldr	r2, [r2]
8f612fe4:	e58d2004 	str	r2, [r13, #4]
8f612fe8:	e3a02000 	mov	r2, #0
}
8f612fec:	e59f301c 	ldr	r3, [pc, #28]	; 8f613010 <flash_get_ptable+0x48>
8f612ff0:	e5932000 	ldr	r2, [r3]
8f612ff4:	e59d3004 	ldr	r3, [r13, #4]
8f612ff8:	e0332002 	eors	r2, r3, r2
8f612ffc:	e3a03000 	mov	r3, #0
8f613000:	1a000001 	bne	8f61300c <flash_get_ptable+0x44>
8f613004:	e28dd00c 	add	r13, r13, #12
8f613008:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61300c:	eb007eeb 	bl	8f632bc0 <__stack_chk_fail>
8f613010:	8f74221c 	.word	0x8f74221c

8f613014 <flash_read_ext>:
flash_read_ext(struct ptentry *ptn,
			   unsigned extra_per_page,
			   unsigned offset,
			   void *data,
			   unsigned bytes)
{
8f613014:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f613018:	e1a05003 	mov	r5, r3
8f61301c:	e24dd02c 	sub	r13, r13, #44	; 0x2c
8f613020:	e59f3274 	ldr	r3, [pc, #628]	; 8f61329c <flash_read_ext+0x288>
	uint32_t page =
		(ptn->start * flash.num_pages_per_blk) + (offset / flash.page_size);
8f613024:	e30c4e18 	movw	r4, #52760	; 0xce18
8f613028:	e3484f72 	movt	r4, #36722	; 0x8f72
{
8f61302c:	e5933000 	ldr	r3, [r3]
8f613030:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f613034:	e3a03000 	mov	r3, #0
8f613038:	e59d3050 	ldr	r3, [r13, #80]	; 0x50
8f61303c:	e1a06000 	mov	r6, r0
8f613040:	e1a08002 	mov	r8, r2
8f613044:	e1a09001 	mov	r9, r1
		(ptn->start * flash.num_pages_per_blk) + (offset / flash.page_size);
8f613048:	e5901010 	ldr	r1, [r0, #16]
{
8f61304c:	e58d3018 	str	r3, [r13, #24]
		(ptn->start * flash.num_pages_per_blk) + (offset / flash.page_size);
8f613050:	e1a00002 	mov	r0, r2
8f613054:	e5943028 	ldr	r3, [r4, #40]	; 0x28
8f613058:	e5942014 	ldr	r2, [r4, #20]
8f61305c:	e58d1004 	str	r1, [r13, #4]
8f613060:	e0070193 	mul	r7, r3, r1
8f613064:	e1a01002 	mov	r1, r2
8f613068:	e242c001 	sub	r12, r2, #1
8f61306c:	e58d3008 	str	r3, [r13, #8]
8f613070:	e58dc00c 	str	r12, [r13, #12]
8f613074:	e58d2014 	str	r2, [r13, #20]
8f613078:	fa00a6d6 	blx	8f63cbd8 <__udivsi3>
	uint32_t lastpage = (ptn->start + ptn->length) * flash.num_pages_per_blk;
	uint32_t count =
		(bytes + flash.page_size - 1 + extra_per_page) / (flash.page_size +
									 extra_per_page);
	uint32_t *spare = (unsigned *)flash_spare_bytes;
8f61307c:	e30c1e68 	movw	r1, #52840	; 0xce68
8f613080:	e3481f72 	movt	r1, #36722	; 0x8f72
8f613084:	e591a000 	ldr	r10, [r1]
	uint32_t errors = 0;
	unsigned char *image = data;
	int result = 0;
	uint32_t current_block =
8f613088:	e59d1008 	ldr	r1, [r13, #8]
	uint32_t page =
8f61308c:	e080b007 	add	r11, r0, r7
	    (page - (page & flash.num_pages_per_blk_mask)) / flash.num_pages_per_blk;
8f613090:	e594002c 	ldr	r0, [r4, #44]	; 0x2c
	uint32_t current_block =
8f613094:	e1cb0000 	bic	r0, r11, r0
8f613098:	fa00a6ce 	blx	8f63cbd8 <__udivsi3>
	uint32_t start_block_count = 0;
	uint32_t isbad = 0;
	uint32_t current_page;

	/* Verify first byte is at page boundary. */
	if (offset & (flash.page_size - 1))
8f61309c:	e59dc00c 	ldr	r12, [r13, #12]
8f6130a0:	e01c3008 	ands	r3, r12, r8
8f6130a4:	e58d3000 	str	r3, [r13]
	uint32_t lastpage = (ptn->start + ptn->length) * flash.num_pages_per_blk;
8f6130a8:	e5963014 	ldr	r3, [r6, #20]
8f6130ac:	e58d3010 	str	r3, [r13, #16]
	if (offset & (flash.page_size - 1))
8f6130b0:	1a000072 	bne	8f613280 <flash_read_ext+0x26c>
		return NANDC_RESULT_PARAM_INVALID;
	}

	current_page = start_block * flash.num_pages_per_blk;
	/* Adjust page offset based on number of bad blocks from start to current page */
	if (start_block < current_block)
8f6130b4:	e59d3004 	ldr	r3, [r13, #4]
8f6130b8:	e1530000 	cmp	r3, r0
8f6130bc:	3a00004b 	bcc	8f6131f0 <flash_read_ext+0x1dc>
	uint32_t lastpage = (ptn->start + ptn->length) * flash.num_pages_per_blk;
8f6130c0:	e59d3004 	ldr	r3, [r13, #4]
8f6130c4:	e59d2010 	ldr	r2, [r13, #16]
8f6130c8:	e0837002 	add	r7, r3, r2
8f6130cc:	e59d3008 	ldr	r3, [r13, #8]
8f6130d0:	e0070793 	mul	r7, r3, r7
			start_block++;
			current_page += flash.num_pages_per_blk;
		}
	}

	while ((page < lastpage) && !start_block_count)
8f6130d4:	e15b0007 	cmp	r11, r7
8f6130d8:	2a00002c 	bcs	8f613190 <flash_read_ext+0x17c>
		(bytes + flash.page_size - 1 + extra_per_page) / (flash.page_size +
8f6130dc:	e59d300c 	ldr	r3, [r13, #12]
8f6130e0:	e0830009 	add	r0, r3, r9
8f6130e4:	e59d3018 	ldr	r3, [r13, #24]
8f6130e8:	e0800003 	add	r0, r0, r3
8f6130ec:	e59d3014 	ldr	r3, [r13, #20]
8f6130f0:	e0831009 	add	r1, r3, r9
	{
		if (count == 0)
8f6130f4:	e1500001 	cmp	r0, r1
8f6130f8:	3a00005a 	bcc	8f613268 <flash_read_ext+0x254>
	uint32_t count =
8f6130fc:	fa00a6b5 	blx	8f63cbd8 <__udivsi3>
8f613100:	e1a03009 	mov	r3, r9
8f613104:	e30c8e70 	movw	r8, #52848	; 0xce70
8f613108:	e1a0900b 	mov	r9, r11
8f61310c:	e3488f72 	movt	r8, #36722	; 0x8f72
8f613110:	e1a0b003 	mov	r11, r3
8f613114:	e1a06000 	mov	r6, r0
8f613118:	ea00000d 	b	8f613154 <flash_read_ext+0x140>
			continue;
		}

#ifndef CONTIGUOUS_MEMORY
		/* Copy the read page into correct location. */
		memcpy(image, rdwr_buf, flash.page_size);
8f61311c:	e5942014 	ldr	r2, [r4, #20]
8f613120:	e1a00005 	mov	r0, r5
8f613124:	e5981000 	ldr	r1, [r8]
#endif
		page++;
8f613128:	e2899001 	add	r9, r9, #1
		memcpy(image, rdwr_buf, flash.page_size);
8f61312c:	eb008421 	bl	8f6341b8 <memcpy>
		image += flash.page_size;
8f613130:	e5942014 	ldr	r2, [r4, #20]
		/* Copy spare bytes to image */
		if(extra_per_page)
8f613134:	e35b0000 	cmp	r11, #0
		image += flash.page_size;
8f613138:	e0855002 	add	r5, r5, r2
		if(extra_per_page)
8f61313c:	1a000025 	bne	8f6131d8 <flash_read_ext+0x1c4>
		{
			memcpy(image, spare, extra_per_page);
			image += extra_per_page;
		}

		count -= 1;
8f613140:	e2466001 	sub	r6, r6, #1
	while ((page < lastpage) && !start_block_count)
8f613144:	e1570009 	cmp	r7, r9
8f613148:	9a000010 	bls	8f613190 <flash_read_ext+0x17c>
		if (count == 0)
8f61314c:	e3560000 	cmp	r6, #0
8f613150:	0a000044 	beq	8f613268 <flash_read_ext+0x254>
		result = qpic_nand_read_page(page, rdwr_buf, (unsigned char *) spare);
8f613154:	e5981000 	ldr	r1, [r8]
8f613158:	e1a0200a 	mov	r2, r10
8f61315c:	e1a00009 	mov	r0, r9
8f613160:	ebfffb1f 	bl	8f611de4 <qpic_nand_read_page>
		if (result == NANDC_RESULT_BAD_PAGE)
8f613164:	e3500005 	cmp	r0, #5
8f613168:	0a000015 	beq	8f6131c4 <flash_read_ext+0x1b0>
		else if (result == NANDC_RESULT_BAD_BLOCK)
8f61316c:	e3500006 	cmp	r0, #6
8f613170:	1affffe9 	bne	8f61311c <flash_read_ext+0x108>
			page += flash.num_pages_per_blk;
8f613174:	e5942028 	ldr	r2, [r4, #40]	; 0x28
			errors++;
8f613178:	e59d3000 	ldr	r3, [r13]
			page += flash.num_pages_per_blk;
8f61317c:	e0899002 	add	r9, r9, r2
	while ((page < lastpage) && !start_block_count)
8f613180:	e1570009 	cmp	r7, r9
			errors++;
8f613184:	e2833001 	add	r3, r3, #1
8f613188:	e58d3000 	str	r3, [r13]
	while ((page < lastpage) && !start_block_count)
8f61318c:	8affffee 	bhi	8f61314c <flash_read_ext+0x138>
	}

	/* could not find enough valid pages before we hit the end */
	dprintf(CRITICAL, "flash_read_image: failed (%d errors)\n", errors);
8f613190:	e59d1000 	ldr	r1, [r13]
8f613194:	e30402d0 	movw	r0, #17104	; 0x42d0
8f613198:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61319c:	eb007df4 	bl	8f632974 <_dprintf>
	return NANDC_RESULT_FAILURE;
8f6131a0:	e3a00001 	mov	r0, #1
}
8f6131a4:	e59f30f0 	ldr	r3, [pc, #240]	; 8f61329c <flash_read_ext+0x288>
8f6131a8:	e5932000 	ldr	r2, [r3]
8f6131ac:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f6131b0:	e0332002 	eors	r2, r3, r2
8f6131b4:	e3a03000 	mov	r3, #0
8f6131b8:	1a000036 	bne	8f613298 <flash_read_ext+0x284>
8f6131bc:	e28dd02c 	add	r13, r13, #44	; 0x2c
8f6131c0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
			errors++;
8f6131c4:	e59d3000 	ldr	r3, [r13]
			page++;
8f6131c8:	e2899001 	add	r9, r9, #1
			errors++;
8f6131cc:	e2833001 	add	r3, r3, #1
8f6131d0:	e58d3000 	str	r3, [r13]
			continue;
8f6131d4:	eaffffda 	b	8f613144 <flash_read_ext+0x130>
			memcpy(image, spare, extra_per_page);
8f6131d8:	e1a00005 	mov	r0, r5
8f6131dc:	e1a0200b 	mov	r2, r11
8f6131e0:	e1a0100a 	mov	r1, r10
			image += extra_per_page;
8f6131e4:	e085500b 	add	r5, r5, r11
			memcpy(image, spare, extra_per_page);
8f6131e8:	eb0083f2 	bl	8f6341b8 <memcpy>
			image += extra_per_page;
8f6131ec:	eaffffd3 	b	8f613140 <flash_read_ext+0x12c>
		start_block_count = (current_block - start_block);
8f6131f0:	e59d8004 	ldr	r8, [r13, #4]
8f6131f4:	e58d501c 	str	r5, [r13, #28]
8f6131f8:	e1a05004 	mov	r5, r4
8f6131fc:	e0402008 	sub	r2, r0, r8
		while (start_block_count
8f613200:	e1a04006 	mov	r4, r6
		start_block_count = (current_block - start_block);
8f613204:	e59dc010 	ldr	r12, [r13, #16]
8f613208:	e1a00008 	mov	r0, r8
8f61320c:	e1a06002 	mov	r6, r2
8f613210:	ea000005 	b	8f61322c <flash_read_ext+0x218>
				page += flash.num_pages_per_blk;
8f613214:	e5952028 	ldr	r2, [r5, #40]	; 0x28
			start_block++;
8f613218:	e2888001 	add	r8, r8, #1
				page += flash.num_pages_per_blk;
8f61321c:	e08bb002 	add	r11, r11, r2
			current_page += flash.num_pages_per_blk;
8f613220:	e0877002 	add	r7, r7, r2
			   && (start_block < (ptn->start + ptn->length)))
8f613224:	e5940010 	ldr	r0, [r4, #16]
8f613228:	e594c014 	ldr	r12, [r4, #20]
8f61322c:	e080000c 	add	r0, r0, r12
8f613230:	e1500008 	cmp	r0, r8
8f613234:	9affffd5 	bls	8f613190 <flash_read_ext+0x17c>
			isbad = qpic_nand_block_isbad(current_page);
8f613238:	e1a00007 	mov	r0, r7
8f61323c:	ebfffa38 	bl	8f611b24 <qpic_nand_block_isbad>
			if (isbad)
8f613240:	e3500000 	cmp	r0, #0
8f613244:	1afffff2 	bne	8f613214 <flash_read_ext+0x200>
			current_page += flash.num_pages_per_blk;
8f613248:	e5952028 	ldr	r2, [r5, #40]	; 0x28
		while (start_block_count
8f61324c:	e2566001 	subs	r6, r6, #1
			start_block++;
8f613250:	e2888001 	add	r8, r8, #1
			current_page += flash.num_pages_per_blk;
8f613254:	e0877002 	add	r7, r7, r2
		while (start_block_count
8f613258:	1afffff1 	bne	8f613224 <flash_read_ext+0x210>
8f61325c:	e1a04005 	mov	r4, r5
8f613260:	e59d501c 	ldr	r5, [r13, #28]
8f613264:	eaffff95 	b	8f6130c0 <flash_read_ext+0xac>
			dprintf(SPEW, "flash_read_image: success (%d errors)\n",
8f613268:	e59d1000 	ldr	r1, [r13]
8f61326c:	e30402a8 	movw	r0, #17064	; 0x42a8
8f613270:	e3480f70 	movt	r0, #36720	; 0x8f70
8f613274:	eb007dbe 	bl	8f632974 <_dprintf>
			return NANDC_RESULT_SUCCESS;
8f613278:	e3a00000 	mov	r0, #0
8f61327c:	eaffffc8 	b	8f6131a4 <flash_read_ext+0x190>
		dprintf(CRITICAL, "Read request start not at page boundary: %d\n",
8f613280:	e1a01008 	mov	r1, r8
8f613284:	e3040278 	movw	r0, #17016	; 0x4278
8f613288:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61328c:	eb007db8 	bl	8f632974 <_dprintf>
		return NANDC_RESULT_PARAM_INVALID;
8f613290:	e3a00003 	mov	r0, #3
8f613294:	eaffffc2 	b	8f6131a4 <flash_read_ext+0x190>
}
8f613298:	eb007e48 	bl	8f632bc0 <__stack_chk_fail>
8f61329c:	8f74221c 	.word	0x8f74221c

8f6132a0 <flash_erase>:

int
flash_erase(struct ptentry *ptn)
{
8f6132a0:	e59f30ac 	ldr	r3, [pc, #172]	; 8f613354 <flash_erase+0xb4>
8f6132a4:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f6132a8:	e24dd00c 	sub	r13, r13, #12
8f6132ac:	e5933000 	ldr	r3, [r3]
8f6132b0:	e58d3004 	str	r3, [r13, #4]
8f6132b4:	e3a03000 	mov	r3, #0
	int ret = 0, i;

	for (i = 0; i < (int)ptn->length; i++) {
8f6132b8:	e5903014 	ldr	r3, [r0, #20]
8f6132bc:	e3530000 	cmp	r3, #0
8f6132c0:	da000019 	ble	8f61332c <flash_erase+0x8c>
8f6132c4:	e30c6e18 	movw	r6, #52760	; 0xce18
		ret = qpic_nand_blk_erase((ptn->start + i) * flash.num_pages_per_blk);
		if (ret)
			dprintf(CRITICAL, "Erase operation failed @ page #%d\n",
8f6132c8:	e30472f8 	movw	r7, #17144	; 0x42f8
8f6132cc:	e3486f72 	movt	r6, #36722	; 0x8f72
8f6132d0:	e3487f70 	movt	r7, #36720	; 0x8f70
8f6132d4:	e1a05000 	mov	r5, r0
	for (i = 0; i < (int)ptn->length; i++) {
8f6132d8:	e3a04000 	mov	r4, #0
8f6132dc:	ea000003 	b	8f6132f0 <flash_erase+0x50>
8f6132e0:	e5953014 	ldr	r3, [r5, #20]
8f6132e4:	e2844001 	add	r4, r4, #1
8f6132e8:	e1530004 	cmp	r3, r4
8f6132ec:	da00000e 	ble	8f61332c <flash_erase+0x8c>
		ret = qpic_nand_blk_erase((ptn->start + i) * flash.num_pages_per_blk);
8f6132f0:	e5953010 	ldr	r3, [r5, #16]
8f6132f4:	e5960028 	ldr	r0, [r6, #40]	; 0x28
8f6132f8:	e0843003 	add	r3, r4, r3
8f6132fc:	e0000390 	mul	r0, r0, r3
8f613300:	ebfffe44 	bl	8f612c18 <qpic_nand_blk_erase>
		if (ret)
8f613304:	e3500000 	cmp	r0, #0
8f613308:	0afffff4 	beq	8f6132e0 <flash_erase+0x40>
			dprintf(CRITICAL, "Erase operation failed @ page #%d\n",
8f61330c:	e5951010 	ldr	r1, [r5, #16]
8f613310:	e1a00007 	mov	r0, r7
8f613314:	e0841001 	add	r1, r4, r1
	for (i = 0; i < (int)ptn->length; i++) {
8f613318:	e2844001 	add	r4, r4, #1
			dprintf(CRITICAL, "Erase operation failed @ page #%d\n",
8f61331c:	eb007d94 	bl	8f632974 <_dprintf>
	for (i = 0; i < (int)ptn->length; i++) {
8f613320:	e5953014 	ldr	r3, [r5, #20]
8f613324:	e1530004 	cmp	r3, r4
8f613328:	cafffff0 	bgt	8f6132f0 <flash_erase+0x50>
					ptn->start + i);
	}
	return NANDC_RESULT_SUCCESS;
}
8f61332c:	e59f3020 	ldr	r3, [pc, #32]	; 8f613354 <flash_erase+0xb4>
8f613330:	e5932000 	ldr	r2, [r3]
8f613334:	e59d3004 	ldr	r3, [r13, #4]
8f613338:	e0332002 	eors	r2, r3, r2
8f61333c:	e3a03000 	mov	r3, #0
8f613340:	1a000002 	bne	8f613350 <flash_erase+0xb0>
8f613344:	e3a00000 	mov	r0, #0
8f613348:	e28dd00c 	add	r13, r13, #12
8f61334c:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
8f613350:	eb007e1a 	bl	8f632bc0 <__stack_chk_fail>
8f613354:	8f74221c 	.word	0x8f74221c

8f613358 <flash_write>:
int
flash_write(struct ptentry *ptn,
			unsigned write_extra_bytes,
			const void *data,
			unsigned bytes)
{
8f613358:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	uint32_t page = ptn->start * flash.num_pages_per_blk;
8f61335c:	e30c5e18 	movw	r5, #52760	; 0xce18
{
8f613360:	e24dd024 	sub	r13, r13, #36	; 0x24
	uint32_t page = ptn->start * flash.num_pages_per_blk;
8f613364:	e3485f72 	movt	r5, #36722	; 0x8f72
	spare_byte_count = ((flash.cw_size * flash.cws_per_page)- flash.page_size);

	if(write_extra_bytes)
		wsize = flash.page_size + spare_byte_count;
	else
		wsize = flash.page_size;
8f613368:	e3510000 	cmp	r1, #0
{
8f61336c:	e1a06003 	mov	r6, r3
		wsize = flash.page_size;
8f613370:	e58d1004 	str	r1, [r13, #4]
{
8f613374:	e1a07002 	mov	r7, r2
	spare_byte_count = ((flash.cw_size * flash.cws_per_page)- flash.page_size);
8f613378:	e595103c 	ldr	r1, [r5, #60]	; 0x3c
8f61337c:	e5958038 	ldr	r8, [r5, #56]	; 0x38
{
8f613380:	e59f32b4 	ldr	r3, [pc, #692]	; 8f61363c <flash_write+0x2e4>
	uint32_t page = ptn->start * flash.num_pages_per_blk;
8f613384:	e5904010 	ldr	r4, [r0, #16]
{
8f613388:	e5933000 	ldr	r3, [r3]
8f61338c:	e58d301c 	str	r3, [r13, #28]
8f613390:	e3a03000 	mov	r3, #0
	uint32_t *spare = (unsigned *)flash_spare_bytes;
8f613394:	e30c3e68 	movw	r3, #52840	; 0xce68
	spare_byte_count = ((flash.cw_size * flash.cws_per_page)- flash.page_size);
8f613398:	e0080198 	mul	r8, r8, r1
	uint32_t *spare = (unsigned *)flash_spare_bytes;
8f61339c:	e3483f72 	movt	r3, #36722	; 0x8f72
	uint32_t lastpage = (ptn->start + ptn->length) * flash.num_pages_per_blk;
8f6133a0:	e590a014 	ldr	r10, [r0, #20]
	uint32_t *spare = (unsigned *)flash_spare_bytes;
8f6133a4:	e5939000 	ldr	r9, [r3]
	spare_byte_count = ((flash.cw_size * flash.cws_per_page)- flash.page_size);
8f6133a8:	e5953014 	ldr	r3, [r5, #20]
	uint32_t lastpage = (ptn->start + ptn->length) * flash.num_pages_per_blk;
8f6133ac:	e084a00a 	add	r10, r4, r10
{
8f6133b0:	e58d200c 	str	r2, [r13, #12]
	spare_byte_count = ((flash.cw_size * flash.cws_per_page)- flash.page_size);
8f6133b4:	e048b003 	sub	r11, r8, r3
	uint32_t page = ptn->start * flash.num_pages_per_blk;
8f6133b8:	e5952028 	ldr	r2, [r5, #40]	; 0x28
		wsize = flash.page_size;
8f6133bc:	01a08003 	moveq	r8, r3
	uint32_t *spare = (unsigned *)flash_spare_bytes;
8f6133c0:	e58d9008 	str	r9, [r13, #8]

	memset(spare, 0xff, (spare_byte_count / flash.cws_per_page));
8f6133c4:	e1a0000b 	mov	r0, r11
	uint32_t page = ptn->start * flash.num_pages_per_blk;
8f6133c8:	e0040492 	mul	r4, r2, r4
	uint32_t lastpage = (ptn->start + ptn->length) * flash.num_pages_per_blk;
8f6133cc:	e00a0a92 	mul	r10, r2, r10
	memset(spare, 0xff, (spare_byte_count / flash.cws_per_page));
8f6133d0:	fa00a600 	blx	8f63cbd8 <__udivsi3>
8f6133d4:	e3a010ff 	mov	r1, #255	; 0xff
8f6133d8:	e1a02000 	mov	r2, r0
8f6133dc:	e1a00009 	mov	r0, r9
8f6133e0:	eb0083b7 	bl	8f6342c4 <memset>

	while (bytes > 0)
8f6133e4:	e3560000 	cmp	r6, #0
8f6133e8:	0a000051 	beq	8f613534 <flash_write+0x1dc>
	{
		if (bytes < wsize)
8f6133ec:	e1580006 	cmp	r8, r6
8f6133f0:	8a000084 	bhi	8f613608 <flash_write+0x2b0>
					bytes,
					wsize);
			return -1;
		}

		if (page >= lastpage)
8f6133f4:	e154000a 	cmp	r4, r10
8f6133f8:	2a000089 	bcs	8f613624 <flash_write+0x2cc>
				page += flash.num_pages_per_blk;
				continue;
			}
		}

		memcpy(rdwr_buf, image, flash.page_size);
8f6133fc:	e30c9e70 	movw	r9, #52848	; 0xce70
			r = qpic_nand_write_page(page, NAND_CFG, rdwr_buf, spare);
		}

		if (r)
		{
			dprintf(INFO,
8f613400:	e3043394 	movw	r3, #17300	; 0x4394
		memcpy(rdwr_buf, image, flash.page_size);
8f613404:	e3489f72 	movt	r9, #36722	; 0x8f72
			dprintf(INFO,
8f613408:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61340c:	e58d3010 	str	r3, [r13, #16]
						page);
			}

			qpic_nand_mark_badblock(page);

			dprintf(INFO,
8f613410:	e30433f8 	movw	r3, #17400	; 0x43f8
8f613414:	e3483f70 	movt	r3, #36720	; 0x8f70
8f613418:	e58d3014 	str	r3, [r13, #20]
8f61341c:	ea000016 	b	8f61347c <flash_write+0x124>
			memcpy(rdwr_buf + flash.page_size, image + flash.page_size, spare_byte_count);
8f613420:	e5951014 	ldr	r1, [r5, #20]
8f613424:	e1a0200b 	mov	r2, r11
8f613428:	e5990000 	ldr	r0, [r9]
8f61342c:	e0800001 	add	r0, r0, r1
8f613430:	e0871001 	add	r1, r7, r1
8f613434:	eb00835f 	bl	8f6341b8 <memcpy>
			r = qpic_nand_write_page(page,
8f613438:	e5992000 	ldr	r2, [r9]
									 rdwr_buf + flash.page_size);
8f61343c:	e5953014 	ldr	r3, [r5, #20]
			r = qpic_nand_write_page(page,
8f613440:	e3a01001 	mov	r1, #1
8f613444:	e1a00004 	mov	r0, r4
8f613448:	e0823003 	add	r3, r2, r3
8f61344c:	ebfffcd4 	bl	8f6127a4 <qpic_nand_write_page>
		if (r)
8f613450:	e3500000 	cmp	r0, #0
					page, image - (const unsigned char *)data);

			page += flash.num_pages_per_blk;
			continue;
		}
		page++;
8f613454:	02844001 	addeq	r4, r4, #1
		image += wsize;
8f613458:	00877008 	addeq	r7, r7, r8
		bytes -= wsize;
8f61345c:	00466008 	subeq	r6, r6, r8
		if (r)
8f613460:	1a000019 	bne	8f6134cc <flash_write+0x174>
	while (bytes > 0)
8f613464:	e3560000 	cmp	r6, #0
8f613468:	0a000031 	beq	8f613534 <flash_write+0x1dc>
		if (bytes < wsize)
8f61346c:	e1560008 	cmp	r6, r8
8f613470:	3a000064 	bcc	8f613608 <flash_write+0x2b0>
		if (page >= lastpage)
8f613474:	e15a0004 	cmp	r10, r4
8f613478:	9a000069 	bls	8f613624 <flash_write+0x2cc>
		if ((page & flash.num_pages_per_blk_mask) == 0)
8f61347c:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
8f613480:	e1140003 	tst	r4, r3
8f613484:	1a000003 	bne	8f613498 <flash_write+0x140>
			if (qpic_nand_blk_erase(page))
8f613488:	e1a00004 	mov	r0, r4
8f61348c:	ebfffde1 	bl	8f612c18 <qpic_nand_blk_erase>
8f613490:	e3500000 	cmp	r0, #0
8f613494:	1a00004c 	bne	8f6135cc <flash_write+0x274>
		memcpy(rdwr_buf, image, flash.page_size);
8f613498:	e5952014 	ldr	r2, [r5, #20]
8f61349c:	e1a01007 	mov	r1, r7
8f6134a0:	e5990000 	ldr	r0, [r9]
8f6134a4:	eb008343 	bl	8f6341b8 <memcpy>
		if (write_extra_bytes)
8f6134a8:	e59d3004 	ldr	r3, [r13, #4]
8f6134ac:	e3530000 	cmp	r3, #0
8f6134b0:	1affffda 	bne	8f613420 <flash_write+0xc8>
			r = qpic_nand_write_page(page, NAND_CFG, rdwr_buf, spare);
8f6134b4:	e5992000 	ldr	r2, [r9]
8f6134b8:	e3a01001 	mov	r1, #1
8f6134bc:	e59d3008 	ldr	r3, [r13, #8]
8f6134c0:	e1a00004 	mov	r0, r4
8f6134c4:	ebfffcb6 	bl	8f6127a4 <qpic_nand_write_page>
8f6134c8:	eaffffe0 	b	8f613450 <flash_write+0xf8>
			dprintf(INFO,
8f6134cc:	e59d300c 	ldr	r3, [r13, #12]
8f6134d0:	e1a01004 	mov	r1, r4
8f6134d4:	e59d0010 	ldr	r0, [r13, #16]
8f6134d8:	e0472003 	sub	r2, r7, r3
8f6134dc:	eb007d24 	bl	8f632974 <_dprintf>
			image -= (page & flash.num_pages_per_blk_mask) * wsize;
8f6134e0:	e595102c 	ldr	r1, [r5, #44]	; 0x2c
8f6134e4:	e0013004 	and	r3, r1, r4
			page &= ~flash.num_pages_per_blk_mask;
8f6134e8:	e1c44001 	bic	r4, r4, r1
			image -= (page & flash.num_pages_per_blk_mask) * wsize;
8f6134ec:	e0030398 	mul	r3, r8, r3
			if (qpic_nand_blk_erase(page))
8f6134f0:	e1a00004 	mov	r0, r4
			image -= (page & flash.num_pages_per_blk_mask) * wsize;
8f6134f4:	e0477003 	sub	r7, r7, r3
			bytes += (page & flash.num_pages_per_blk_mask) * wsize;
8f6134f8:	e0866003 	add	r6, r6, r3
			if (qpic_nand_blk_erase(page))
8f6134fc:	ebfffdc5 	bl	8f612c18 <qpic_nand_blk_erase>
8f613500:	e3500000 	cmp	r0, #0
8f613504:	1a00003a 	bne	8f6135f4 <flash_write+0x29c>
			qpic_nand_mark_badblock(page);
8f613508:	e1a00004 	mov	r0, r4
8f61350c:	ebfffda2 	bl	8f612b9c <qpic_nand_mark_badblock.isra.0>
			dprintf(INFO,
8f613510:	e59d300c 	ldr	r3, [r13, #12]
8f613514:	e1a01004 	mov	r1, r4
8f613518:	e59d0014 	ldr	r0, [r13, #20]
8f61351c:	e0472003 	sub	r2, r7, r3
8f613520:	eb007d13 	bl	8f632974 <_dprintf>
			page += flash.num_pages_per_blk;
8f613524:	e5951028 	ldr	r1, [r5, #40]	; 0x28
	while (bytes > 0)
8f613528:	e3560000 	cmp	r6, #0
			page += flash.num_pages_per_blk;
8f61352c:	e0844001 	add	r4, r4, r1
	while (bytes > 0)
8f613530:	1affffcd 	bne	8f61346c <flash_write+0x114>
	}

	/* erase any remaining pages in the partition */
	page = (page + flash.num_pages_per_blk_mask) & (~flash.num_pages_per_blk_mask);
8f613534:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
8f613538:	e0834004 	add	r4, r3, r4
8f61353c:	e1c44003 	bic	r4, r4, r3

	while (page < lastpage)
8f613540:	e15a0004 	cmp	r10, r4
8f613544:	9a000014 	bls	8f61359c <flash_write+0x244>
	{
		if (qpic_nand_blk_erase(page))
		{
			dprintf(INFO, "flash_write_image: bad block @ %d\n",
8f613548:	e3046370 	movw	r6, #17264	; 0x4370
8f61354c:	e3486f70 	movt	r6, #36720	; 0x8f70
8f613550:	ea000003 	b	8f613564 <flash_write+0x20c>
					page / flash.num_pages_per_blk);
		}
		page += flash.num_pages_per_blk;
8f613554:	e5953028 	ldr	r3, [r5, #40]	; 0x28
8f613558:	e0844003 	add	r4, r4, r3
	while (page < lastpage)
8f61355c:	e15a0004 	cmp	r10, r4
8f613560:	9a00000d 	bls	8f61359c <flash_write+0x244>
		if (qpic_nand_blk_erase(page))
8f613564:	e1a00004 	mov	r0, r4
8f613568:	ebfffdaa 	bl	8f612c18 <qpic_nand_blk_erase>
8f61356c:	e3500000 	cmp	r0, #0
8f613570:	0afffff7 	beq	8f613554 <flash_write+0x1fc>
			dprintf(INFO, "flash_write_image: bad block @ %d\n",
8f613574:	e5951028 	ldr	r1, [r5, #40]	; 0x28
8f613578:	e1a00004 	mov	r0, r4
8f61357c:	fa00a595 	blx	8f63cbd8 <__udivsi3>
8f613580:	e1a01000 	mov	r1, r0
8f613584:	e1a00006 	mov	r0, r6
8f613588:	eb007cf9 	bl	8f632974 <_dprintf>
		page += flash.num_pages_per_blk;
8f61358c:	e5953028 	ldr	r3, [r5, #40]	; 0x28
8f613590:	e0844003 	add	r4, r4, r3
	while (page < lastpage)
8f613594:	e15a0004 	cmp	r10, r4
8f613598:	8afffff1 	bhi	8f613564 <flash_write+0x20c>
	}

	dprintf(INFO, "flash_write_image: success\n");
8f61359c:	e3040430 	movw	r0, #17456	; 0x4430
8f6135a0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6135a4:	eb007cf2 	bl	8f632974 <_dprintf>
	return 0;
8f6135a8:	e3a00000 	mov	r0, #0
}
8f6135ac:	e59f3088 	ldr	r3, [pc, #136]	; 8f61363c <flash_write+0x2e4>
8f6135b0:	e5932000 	ldr	r2, [r3]
8f6135b4:	e59d301c 	ldr	r3, [r13, #28]
8f6135b8:	e0332002 	eors	r2, r3, r2
8f6135bc:	e3a03000 	mov	r3, #0
8f6135c0:	1a00001c 	bne	8f613638 <flash_write+0x2e0>
8f6135c4:	e28dd024 	add	r13, r13, #36	; 0x24
8f6135c8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
				dprintf(INFO,
8f6135cc:	e5951028 	ldr	r1, [r5, #40]	; 0x28
8f6135d0:	e1a00004 	mov	r0, r4
8f6135d4:	fa00a57f 	blx	8f63cbd8 <__udivsi3>
8f6135d8:	e1a01000 	mov	r1, r0
8f6135dc:	e3040370 	movw	r0, #17264	; 0x4370
8f6135e0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6135e4:	eb007ce2 	bl	8f632974 <_dprintf>
				page += flash.num_pages_per_blk;
8f6135e8:	e5953028 	ldr	r3, [r5, #40]	; 0x28
8f6135ec:	e0844003 	add	r4, r4, r3
				continue;
8f6135f0:	eaffff9b 	b	8f613464 <flash_write+0x10c>
				dprintf(INFO,
8f6135f4:	e30403cc 	movw	r0, #17356	; 0x43cc
8f6135f8:	e1a01004 	mov	r1, r4
8f6135fc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f613600:	eb007cdb 	bl	8f632974 <_dprintf>
8f613604:	eaffffbf 	b	8f613508 <flash_write+0x1b0>
			dprintf(CRITICAL,
8f613608:	e1a02008 	mov	r2, r8
8f61360c:	e1a01006 	mov	r1, r6
8f613610:	e304031c 	movw	r0, #17180	; 0x431c
8f613614:	e3480f70 	movt	r0, #36720	; 0x8f70
8f613618:	eb007cd5 	bl	8f632974 <_dprintf>
			return -1;
8f61361c:	e3e00000 	mvn	r0, #0
8f613620:	eaffffe1 	b	8f6135ac <flash_write+0x254>
			dprintf(CRITICAL, "flash_write_image: out of space\n");
8f613624:	e304034c 	movw	r0, #17228	; 0x434c
8f613628:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61362c:	eb007cd0 	bl	8f632974 <_dprintf>
			return -1;
8f613630:	e3e00000 	mvn	r0, #0
8f613634:	eaffffdc 	b	8f6135ac <flash_write+0x254>
}
8f613638:	eb007d60 	bl	8f632bc0 <__stack_chk_fail>
8f61363c:	8f74221c 	.word	0x8f74221c

8f613640 <is_scm_armv8_support>:
/* SCM interface as per ARM spec present? */
bool scm_arm_support;
static bool scm_initialized;

bool is_scm_armv8_support()
{
8f613640:	e92d4800 	push	{r11, r14}
8f613644:	e28db004 	add	r11, r13, #4
8f613648:	e24dd008 	sub	r13, r13, #8
8f61364c:	e59f3054 	ldr	r3, [pc, #84]	; 8f6136a8 <is_scm_armv8_support+0x68>
8f613650:	e5933000 	ldr	r3, [r3]
8f613654:	e50b3008 	str	r3, [r11, #-8]
8f613658:	e3a03000 	mov	r3, #0
	if (!scm_initialized)
8f61365c:	e30d30c4 	movw	r3, #53444	; 0xd0c4
8f613660:	e3483f72 	movt	r3, #36722	; 0x8f72
8f613664:	e5933000 	ldr	r3, [r3]
8f613668:	e3530000 	cmp	r3, #0
8f61366c:	1a000000 	bne	8f613674 <is_scm_armv8_support+0x34>
	{
		scm_init();
8f613670:	eb000064 	bl	8f613808 <scm_init>
	}

	return scm_arm_support;
8f613674:	e3023a30 	movw	r3, #10800	; 0x2a30
8f613678:	e3483f74 	movt	r3, #36724	; 0x8f74
8f61367c:	e5933000 	ldr	r3, [r3]
}
8f613680:	e59f2020 	ldr	r2, [pc, #32]	; 8f6136a8 <is_scm_armv8_support+0x68>
8f613684:	e5921000 	ldr	r1, [r2]
8f613688:	e51b2008 	ldr	r2, [r11, #-8]
8f61368c:	e0321001 	eors	r1, r2, r1
8f613690:	e3a02000 	mov	r2, #0
8f613694:	0a000000 	beq	8f61369c <is_scm_armv8_support+0x5c>
8f613698:	eb007d48 	bl	8f632bc0 <__stack_chk_fail>
8f61369c:	e1a00003 	mov	r0, r3
8f6136a0:	e24bd004 	sub	r13, r11, #4
8f6136a4:	e8bd8800 	pop	{r11, r15}
8f6136a8:	8f74221c 	.word	0x8f74221c

8f6136ac <is_scm_call_available>:

int is_scm_call_available(uint32_t svc_id, uint32_t cmd_id)
{
8f6136ac:	e92d4800 	push	{r11, r14}
8f6136b0:	e28db004 	add	r11, r13, #4
8f6136b4:	e24dd060 	sub	r13, r13, #96	; 0x60
8f6136b8:	e50b0060 	str	r0, [r11, #-96]	; 0xffffffa0
8f6136bc:	e50b1064 	str	r1, [r11, #-100]	; 0xffffff9c
8f6136c0:	e59f30bc 	ldr	r3, [pc, #188]	; 8f613784 <is_scm_call_available+0xd8>
8f6136c4:	e5933000 	ldr	r3, [r3]
8f6136c8:	e50b3008 	str	r3, [r11, #-8]
8f6136cc:	e3a03000 	mov	r3, #0
	int ret;
	scmcall_arg scm_arg = {0};
8f6136d0:	e24b3048 	sub	r3, r11, #72	; 0x48
8f6136d4:	e3a02040 	mov	r2, #64	; 0x40
8f6136d8:	e3a01000 	mov	r1, #0
8f6136dc:	e1a00003 	mov	r0, r3
8f6136e0:	eb0082f7 	bl	8f6342c4 <memset>
	scmcall_ret scm_ret = {0};
8f6136e4:	e24b3054 	sub	r3, r11, #84	; 0x54
8f6136e8:	e3a02000 	mov	r2, #0
8f6136ec:	e5832000 	str	r2, [r3]
8f6136f0:	e5832004 	str	r2, [r3, #4]
8f6136f4:	e5832008 	str	r2, [r3, #8]

	scm_arg.x0 = MAKE_SIP_SCM_CMD(SCM_SVC_INFO, IS_CALL_AVAIL_CMD);
8f6136f8:	e3003601 	movw	r3, #1537	; 0x601
8f6136fc:	e3403200 	movt	r3, #512	; 0x200
8f613700:	e50b3048 	str	r3, [r11, #-72]	; 0xffffffb8
	scm_arg.x1 = MAKE_SCM_ARGS(0x1);
8f613704:	e3a03001 	mov	r3, #1
8f613708:	e50b3044 	str	r3, [r11, #-68]	; 0xffffffbc
	scm_arg.x2 = MAKE_SIP_SCM_CMD(svc_id, cmd_id);
8f61370c:	e51b3060 	ldr	r3, [r11, #-96]	; 0xffffffa0
8f613710:	e1a02403 	lsl	r2, r3, #8
8f613714:	e51b3064 	ldr	r3, [r11, #-100]	; 0xffffff9c
8f613718:	e1823003 	orr	r3, r2, r3
8f61371c:	e6ff3073 	uxth	r3, r3
8f613720:	e3833402 	orr	r3, r3, #33554432	; 0x2000000
8f613724:	e50b3040 	str	r3, [r11, #-64]	; 0xffffffc0

	ret = scm_call2(&scm_arg, &scm_ret);
8f613728:	e24b2054 	sub	r2, r11, #84	; 0x54
8f61372c:	e24b3048 	sub	r3, r11, #72	; 0x48
8f613730:	e1a01002 	mov	r1, r2
8f613734:	e1a00003 	mov	r0, r3
8f613738:	eb0005a4 	bl	8f614dd0 <scm_call2>
8f61373c:	e1a03000 	mov	r3, r0
8f613740:	e50b3058 	str	r3, [r11, #-88]	; 0xffffffa8

	if (!ret)
8f613744:	e51b3058 	ldr	r3, [r11, #-88]	; 0xffffffa8
8f613748:	e3530000 	cmp	r3, #0
8f61374c:	1a000001 	bne	8f613758 <is_scm_call_available+0xac>
		return scm_ret.x1;
8f613750:	e51b3054 	ldr	r3, [r11, #-84]	; 0xffffffac
8f613754:	ea000000 	b	8f61375c <is_scm_call_available+0xb0>

	return ret;
8f613758:	e51b3058 	ldr	r3, [r11, #-88]	; 0xffffffa8
}
8f61375c:	e59f2020 	ldr	r2, [pc, #32]	; 8f613784 <is_scm_call_available+0xd8>
8f613760:	e5921000 	ldr	r1, [r2]
8f613764:	e51b2008 	ldr	r2, [r11, #-8]
8f613768:	e0321001 	eors	r1, r2, r1
8f61376c:	e3a02000 	mov	r2, #0
8f613770:	0a000000 	beq	8f613778 <is_scm_call_available+0xcc>
8f613774:	eb007d11 	bl	8f632bc0 <__stack_chk_fail>
8f613778:	e1a00003 	mov	r0, r3
8f61377c:	e24bd004 	sub	r13, r11, #4
8f613780:	e8bd8800 	pop	{r11, r15}
8f613784:	8f74221c 	.word	0x8f74221c

8f613788 <scm_arm_support_available>:

static int scm_arm_support_available(uint32_t svc_id, uint32_t cmd_id)
{
8f613788:	e92d4800 	push	{r11, r14}
8f61378c:	e28db004 	add	r11, r13, #4
8f613790:	e24dd010 	sub	r13, r13, #16
8f613794:	e50b0010 	str	r0, [r11, #-16]
8f613798:	e50b1014 	str	r1, [r11, #-20]	; 0xffffffec
8f61379c:	e59f3060 	ldr	r3, [pc, #96]	; 8f613804 <scm_arm_support_available+0x7c>
8f6137a0:	e5933000 	ldr	r3, [r3]
8f6137a4:	e50b3008 	str	r3, [r11, #-8]
8f6137a8:	e3a03000 	mov	r3, #0
	int ret;

	ret = is_scm_call_available(SCM_SVC_INFO, IS_CALL_AVAIL_CMD);
8f6137ac:	e3a01001 	mov	r1, #1
8f6137b0:	e3a00006 	mov	r0, #6
8f6137b4:	ebffffbc 	bl	8f6136ac <is_scm_call_available>
8f6137b8:	e50b000c 	str	r0, [r11, #-12]

	if (ret > 0)
8f6137bc:	e51b300c 	ldr	r3, [r11, #-12]
8f6137c0:	e3530000 	cmp	r3, #0
8f6137c4:	da000003 	ble	8f6137d8 <scm_arm_support_available+0x50>
		scm_arm_support = true;
8f6137c8:	e3023a30 	movw	r3, #10800	; 0x2a30
8f6137cc:	e3483f74 	movt	r3, #36724	; 0x8f74
8f6137d0:	e3a02001 	mov	r2, #1
8f6137d4:	e5832000 	str	r2, [r3]

	return ret;
8f6137d8:	e51b300c 	ldr	r3, [r11, #-12]
}
8f6137dc:	e59f2020 	ldr	r2, [pc, #32]	; 8f613804 <scm_arm_support_available+0x7c>
8f6137e0:	e5921000 	ldr	r1, [r2]
8f6137e4:	e51b2008 	ldr	r2, [r11, #-8]
8f6137e8:	e0321001 	eors	r1, r2, r1
8f6137ec:	e3a02000 	mov	r2, #0
8f6137f0:	0a000000 	beq	8f6137f8 <scm_arm_support_available+0x70>
8f6137f4:	eb007cf1 	bl	8f632bc0 <__stack_chk_fail>
8f6137f8:	e1a00003 	mov	r0, r3
8f6137fc:	e24bd004 	sub	r13, r11, #4
8f613800:	e8bd8800 	pop	{r11, r15}
8f613804:	8f74221c 	.word	0x8f74221c

8f613808 <scm_init>:

void scm_init()
{
8f613808:	e92d4800 	push	{r11, r14}
8f61380c:	e28db004 	add	r11, r13, #4
8f613810:	e24dd008 	sub	r13, r13, #8
8f613814:	e59f3080 	ldr	r3, [pc, #128]	; 8f61389c <scm_init+0x94>
8f613818:	e5933000 	ldr	r3, [r3]
8f61381c:	e50b3008 	str	r3, [r11, #-8]
8f613820:	e3a03000 	mov	r3, #0
	int ret;

	if (scm_initialized)
8f613824:	e30d30c4 	movw	r3, #53444	; 0xd0c4
8f613828:	e3483f72 	movt	r3, #36722	; 0x8f72
8f61382c:	e5933000 	ldr	r3, [r3]
8f613830:	e3530000 	cmp	r3, #0
8f613834:	1a00000e 	bne	8f613874 <scm_init+0x6c>
		return;

	ret = scm_arm_support_available(SCM_SVC_INFO, IS_CALL_AVAIL_CMD);
8f613838:	e3a01001 	mov	r1, #1
8f61383c:	e3a00006 	mov	r0, #6
8f613840:	ebffffd0 	bl	8f613788 <scm_arm_support_available>
8f613844:	e50b000c 	str	r0, [r11, #-12]

	if (ret < 0)
8f613848:	e51b300c 	ldr	r3, [r11, #-12]
8f61384c:	e3530000 	cmp	r3, #0
8f613850:	aa000002 	bge	8f613860 <scm_init+0x58>
		dprintf(CRITICAL, "Failed to initialize SCM\n");
8f613854:	e304044c 	movw	r0, #17484	; 0x444c
8f613858:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61385c:	eb007c44 	bl	8f632974 <_dprintf>

	scm_initialized = true;
8f613860:	e30d30c4 	movw	r3, #53444	; 0xd0c4
8f613864:	e3483f72 	movt	r3, #36722	; 0x8f72
8f613868:	e3a02001 	mov	r2, #1
8f61386c:	e5832000 	str	r2, [r3]
8f613870:	ea000000 	b	8f613878 <scm_init+0x70>
		return;
8f613874:	e320f000 	nop	{0}

#if DISABLE_DLOAD_MODE
	scm_disable_sdi();
#endif
}
8f613878:	e59f301c 	ldr	r3, [pc, #28]	; 8f61389c <scm_init+0x94>
8f61387c:	e5932000 	ldr	r2, [r3]
8f613880:	e51b3008 	ldr	r3, [r11, #-8]
8f613884:	e0332002 	eors	r2, r3, r2
8f613888:	e3a03000 	mov	r3, #0
8f61388c:	0a000000 	beq	8f613894 <scm_init+0x8c>
8f613890:	eb007cca 	bl	8f632bc0 <__stack_chk_fail>
8f613894:	e24bd004 	sub	r13, r11, #4
8f613898:	e8bd8800 	pop	{r11, r15}
8f61389c:	8f74221c 	.word	0x8f74221c

8f6138a0 <alloc_scm_command>:
 * and response headers as well as the command and response buffers.
 *
 * Returns a valid &scm_command on success or %NULL if the allocation fails.
 */
static struct scm_command *alloc_scm_command(size_t cmd_size, size_t resp_size)
{
8f6138a0:	e92d4800 	push	{r11, r14}
8f6138a4:	e28db004 	add	r11, r13, #4
8f6138a8:	e24dd018 	sub	r13, r13, #24
8f6138ac:	e50b0018 	str	r0, [r11, #-24]	; 0xffffffe8
8f6138b0:	e50b101c 	str	r1, [r11, #-28]	; 0xffffffe4
8f6138b4:	e59f30b4 	ldr	r3, [pc, #180]	; 8f613970 <alloc_scm_command+0xd0>
8f6138b8:	e5933000 	ldr	r3, [r3]
8f6138bc:	e50b3008 	str	r3, [r11, #-8]
8f6138c0:	e3a03000 	mov	r3, #0
	struct scm_command *cmd;
	size_t len = sizeof(*cmd) + sizeof(struct scm_response) + cmd_size +
8f6138c4:	e51b2018 	ldr	r2, [r11, #-24]	; 0xffffffe8
8f6138c8:	e51b301c 	ldr	r3, [r11, #-28]	; 0xffffffe4
8f6138cc:	e0823003 	add	r3, r2, r3
8f6138d0:	e283301c 	add	r3, r3, #28
8f6138d4:	e50b3010 	str	r3, [r11, #-16]
	    resp_size;

	cmd = memalign(CACHE_LINE, ROUNDUP(len, CACHE_LINE));
8f6138d8:	e51b3010 	ldr	r3, [r11, #-16]
8f6138dc:	e283303f 	add	r3, r3, #63	; 0x3f
8f6138e0:	e3c3303f 	bic	r3, r3, #63	; 0x3f
8f6138e4:	e1a01003 	mov	r1, r3
8f6138e8:	e3a00040 	mov	r0, #64	; 0x40
8f6138ec:	eb0081d4 	bl	8f634044 <memalign>
8f6138f0:	e1a03000 	mov	r3, r0
8f6138f4:	e50b300c 	str	r3, [r11, #-12]
	if (cmd) {
8f6138f8:	e51b300c 	ldr	r3, [r11, #-12]
8f6138fc:	e3530000 	cmp	r3, #0
8f613900:	0a00000f 	beq	8f613944 <alloc_scm_command+0xa4>
		memset(cmd, 0, len);
8f613904:	e51b2010 	ldr	r2, [r11, #-16]
8f613908:	e3a01000 	mov	r1, #0
8f61390c:	e51b000c 	ldr	r0, [r11, #-12]
8f613910:	eb00826b 	bl	8f6342c4 <memset>
		cmd->len = len;
8f613914:	e51b300c 	ldr	r3, [r11, #-12]
8f613918:	e51b2010 	ldr	r2, [r11, #-16]
8f61391c:	e5832000 	str	r2, [r3]
		cmd->buf_offset = offsetof(struct scm_command, buf);
8f613920:	e51b300c 	ldr	r3, [r11, #-12]
8f613924:	e3a02010 	mov	r2, #16
8f613928:	e5832004 	str	r2, [r3, #4]
		cmd->resp_hdr_offset = cmd->buf_offset + cmd_size;
8f61392c:	e51b300c 	ldr	r3, [r11, #-12]
8f613930:	e5932004 	ldr	r2, [r3, #4]
8f613934:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f613938:	e0822003 	add	r2, r2, r3
8f61393c:	e51b300c 	ldr	r3, [r11, #-12]
8f613940:	e5832008 	str	r2, [r3, #8]
	}
	return cmd;
8f613944:	e51b300c 	ldr	r3, [r11, #-12]
}
8f613948:	e59f2020 	ldr	r2, [pc, #32]	; 8f613970 <alloc_scm_command+0xd0>
8f61394c:	e5921000 	ldr	r1, [r2]
8f613950:	e51b2008 	ldr	r2, [r11, #-8]
8f613954:	e0321001 	eors	r1, r2, r1
8f613958:	e3a02000 	mov	r2, #0
8f61395c:	0a000000 	beq	8f613964 <alloc_scm_command+0xc4>
8f613960:	eb007c96 	bl	8f632bc0 <__stack_chk_fail>
8f613964:	e1a00003 	mov	r0, r3
8f613968:	e24bd004 	sub	r13, r11, #4
8f61396c:	e8bd8800 	pop	{r11, r15}
8f613970:	8f74221c 	.word	0x8f74221c

8f613974 <free_scm_command>:
 * @cmd: command to free
 *
 * Free an SCM command.
 */
static inline void free_scm_command(struct scm_command *cmd)
{
8f613974:	e92d4800 	push	{r11, r14}
8f613978:	e28db004 	add	r11, r13, #4
8f61397c:	e24dd010 	sub	r13, r13, #16
8f613980:	e50b0010 	str	r0, [r11, #-16]
8f613984:	e59f3038 	ldr	r3, [pc, #56]	; 8f6139c4 <free_scm_command+0x50>
8f613988:	e5933000 	ldr	r3, [r3]
8f61398c:	e50b3008 	str	r3, [r11, #-8]
8f613990:	e3a03000 	mov	r3, #0
	free(cmd);
8f613994:	e51b0010 	ldr	r0, [r11, #-16]
8f613998:	eb0081db 	bl	8f63410c <free>
}
8f61399c:	e320f000 	nop	{0}
8f6139a0:	e59f301c 	ldr	r3, [pc, #28]	; 8f6139c4 <free_scm_command+0x50>
8f6139a4:	e5932000 	ldr	r2, [r3]
8f6139a8:	e51b3008 	ldr	r3, [r11, #-8]
8f6139ac:	e0332002 	eors	r2, r3, r2
8f6139b0:	e3a03000 	mov	r3, #0
8f6139b4:	0a000000 	beq	8f6139bc <free_scm_command+0x48>
8f6139b8:	eb007c80 	bl	8f632bc0 <__stack_chk_fail>
8f6139bc:	e24bd004 	sub	r13, r11, #4
8f6139c0:	e8bd8800 	pop	{r11, r15}
8f6139c4:	8f74221c 	.word	0x8f74221c

8f6139c8 <scm_command_to_response>:
 *
 * Returns a pointer to a response for a command.
 */
static inline struct scm_response *scm_command_to_response(const struct
							   scm_command *cmd)
{
8f6139c8:	e92d4800 	push	{r11, r14}
8f6139cc:	e28db004 	add	r11, r13, #4
8f6139d0:	e24dd010 	sub	r13, r13, #16
8f6139d4:	e50b0010 	str	r0, [r11, #-16]
8f6139d8:	e59f3040 	ldr	r3, [pc, #64]	; 8f613a20 <scm_command_to_response+0x58>
8f6139dc:	e5933000 	ldr	r3, [r3]
8f6139e0:	e50b3008 	str	r3, [r11, #-8]
8f6139e4:	e3a03000 	mov	r3, #0
	return (void *)cmd + cmd->resp_hdr_offset;
8f6139e8:	e51b3010 	ldr	r3, [r11, #-16]
8f6139ec:	e5933008 	ldr	r3, [r3, #8]
8f6139f0:	e51b2010 	ldr	r2, [r11, #-16]
8f6139f4:	e0823003 	add	r3, r2, r3
}
8f6139f8:	e59f2020 	ldr	r2, [pc, #32]	; 8f613a20 <scm_command_to_response+0x58>
8f6139fc:	e5921000 	ldr	r1, [r2]
8f613a00:	e51b2008 	ldr	r2, [r11, #-8]
8f613a04:	e0321001 	eors	r1, r2, r1
8f613a08:	e3a02000 	mov	r2, #0
8f613a0c:	0a000000 	beq	8f613a14 <scm_command_to_response+0x4c>
8f613a10:	eb007c6a 	bl	8f632bc0 <__stack_chk_fail>
8f613a14:	e1a00003 	mov	r0, r3
8f613a18:	e24bd004 	sub	r13, r11, #4
8f613a1c:	e8bd8800 	pop	{r11, r15}
8f613a20:	8f74221c 	.word	0x8f74221c

8f613a24 <scm_get_command_buffer>:
 * @cmd: command
 *
 * Returns a pointer to the command buffer of a command.
 */
static inline void *scm_get_command_buffer(const struct scm_command *cmd)
{
8f613a24:	e92d4800 	push	{r11, r14}
8f613a28:	e28db004 	add	r11, r13, #4
8f613a2c:	e24dd010 	sub	r13, r13, #16
8f613a30:	e50b0010 	str	r0, [r11, #-16]
8f613a34:	e59f3038 	ldr	r3, [pc, #56]	; 8f613a74 <scm_get_command_buffer+0x50>
8f613a38:	e5933000 	ldr	r3, [r3]
8f613a3c:	e50b3008 	str	r3, [r11, #-8]
8f613a40:	e3a03000 	mov	r3, #0
	return (void *)cmd->buf;
8f613a44:	e51b3010 	ldr	r3, [r11, #-16]
8f613a48:	e2833010 	add	r3, r3, #16
}
8f613a4c:	e59f2020 	ldr	r2, [pc, #32]	; 8f613a74 <scm_get_command_buffer+0x50>
8f613a50:	e5921000 	ldr	r1, [r2]
8f613a54:	e51b2008 	ldr	r2, [r11, #-8]
8f613a58:	e0321001 	eors	r1, r2, r1
8f613a5c:	e3a02000 	mov	r2, #0
8f613a60:	0a000000 	beq	8f613a68 <scm_get_command_buffer+0x44>
8f613a64:	eb007c55 	bl	8f632bc0 <__stack_chk_fail>
8f613a68:	e1a00003 	mov	r0, r3
8f613a6c:	e24bd004 	sub	r13, r11, #4
8f613a70:	e8bd8800 	pop	{r11, r15}
8f613a74:	8f74221c 	.word	0x8f74221c

8f613a78 <scm_get_response_buffer>:
 * @rsp: response
 *
 * Returns a pointer to a response buffer of a response.
 */
static inline void *scm_get_response_buffer(const struct scm_response *rsp)
{
8f613a78:	e92d4800 	push	{r11, r14}
8f613a7c:	e28db004 	add	r11, r13, #4
8f613a80:	e24dd010 	sub	r13, r13, #16
8f613a84:	e50b0010 	str	r0, [r11, #-16]
8f613a88:	e59f3040 	ldr	r3, [pc, #64]	; 8f613ad0 <scm_get_response_buffer+0x58>
8f613a8c:	e5933000 	ldr	r3, [r3]
8f613a90:	e50b3008 	str	r3, [r11, #-8]
8f613a94:	e3a03000 	mov	r3, #0
	return (void *)rsp + rsp->buf_offset;
8f613a98:	e51b3010 	ldr	r3, [r11, #-16]
8f613a9c:	e5933004 	ldr	r3, [r3, #4]
8f613aa0:	e51b2010 	ldr	r2, [r11, #-16]
8f613aa4:	e0823003 	add	r3, r2, r3
}
8f613aa8:	e59f2020 	ldr	r2, [pc, #32]	; 8f613ad0 <scm_get_response_buffer+0x58>
8f613aac:	e5921000 	ldr	r1, [r2]
8f613ab0:	e51b2008 	ldr	r2, [r11, #-8]
8f613ab4:	e0321001 	eors	r1, r2, r1
8f613ab8:	e3a02000 	mov	r2, #0
8f613abc:	0a000000 	beq	8f613ac4 <scm_get_response_buffer+0x4c>
8f613ac0:	eb007c3e 	bl	8f632bc0 <__stack_chk_fail>
8f613ac4:	e1a00003 	mov	r0, r3
8f613ac8:	e24bd004 	sub	r13, r11, #4
8f613acc:	e8bd8800 	pop	{r11, r15}
8f613ad0:	8f74221c 	.word	0x8f74221c

8f613ad4 <smc>:

static uint32_t smc(uint32_t cmd_addr)
{
8f613ad4:	e92d4800 	push	{r11, r14}
8f613ad8:	e28db004 	add	r11, r13, #4
8f613adc:	e24dd010 	sub	r13, r13, #16
8f613ae0:	e50b0010 	str	r0, [r11, #-16]
8f613ae4:	e59f3050 	ldr	r3, [pc, #80]	; 8f613b3c <smc+0x68>
8f613ae8:	e5933000 	ldr	r3, [r3]
8f613aec:	e50b3008 	str	r3, [r11, #-8]
8f613af0:	e3a03000 	mov	r3, #0
	uint32_t context_id;
	register uint32_t r0 __asm__("r0") = 1;
8f613af4:	e3a00001 	mov	r0, #1
	register uint32_t r1 __asm__("r1") = (uint32_t) & context_id;
8f613af8:	e24b300c 	sub	r3, r11, #12
8f613afc:	e1a01003 	mov	r1, r3
	register uint32_t r2 __asm__("r2") = cmd_addr;
8f613b00:	e51b2010 	ldr	r2, [r11, #-16]
 __asm__("1:smc	#0	@ switch to secure world\n" "cmp	r0, #1				\n" "beq	1b				\n": "=r"(r0): "r"(r0), "r"(r1), "r"(r2):"r3", "cc");
8f613b04:	e1600070 	smc	0
8f613b08:	e3500001 	cmp	r0, #1
8f613b0c:	0afffffc 	beq	8f613b04 <smc+0x30>
	return r0;
8f613b10:	e1a03000 	mov	r3, r0
}
8f613b14:	e59f2020 	ldr	r2, [pc, #32]	; 8f613b3c <smc+0x68>
8f613b18:	e5921000 	ldr	r1, [r2]
8f613b1c:	e51b2008 	ldr	r2, [r11, #-8]
8f613b20:	e0321001 	eors	r1, r2, r1
8f613b24:	e3a02000 	mov	r2, #0
8f613b28:	0a000000 	beq	8f613b30 <smc+0x5c>
8f613b2c:	eb007c23 	bl	8f632bc0 <__stack_chk_fail>
8f613b30:	e1a00003 	mov	r0, r3
8f613b34:	e24bd004 	sub	r13, r11, #4
8f613b38:	e8bd8800 	pop	{r11, r15}
8f613b3c:	8f74221c 	.word	0x8f74221c

8f613b40 <scm_call_atomic>:
* @cmd: command id
* @ arg1: argument
*/

static int scm_call_atomic(uint32_t svc, uint32_t cmd, uint32_t arg1)
{
8f613b40:	e92d4800 	push	{r11, r14}
8f613b44:	e28db004 	add	r11, r13, #4
8f613b48:	e24dd018 	sub	r13, r13, #24
8f613b4c:	e50b0010 	str	r0, [r11, #-16]
8f613b50:	e50b1014 	str	r1, [r11, #-20]	; 0xffffffec
8f613b54:	e50b2018 	str	r2, [r11, #-24]	; 0xffffffe8
8f613b58:	e59f306c 	ldr	r3, [pc, #108]	; 8f613bcc <scm_call_atomic+0x8c>
8f613b5c:	e5933000 	ldr	r3, [r3]
8f613b60:	e50b3008 	str	r3, [r11, #-8]
8f613b64:	e3a03000 	mov	r3, #0
	uint32_t context_id;
	register uint32_t r0 __asm__("r0") = SCM_ATOMIC(svc, cmd, 1);
8f613b68:	e51b3010 	ldr	r3, [r11, #-16]
8f613b6c:	e1a03503 	lsl	r3, r3, #10
8f613b70:	e6ff2073 	uxth	r2, r3
8f613b74:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
8f613b78:	e7e93053 	ubfx	r3, r3, #0, #10
8f613b7c:	e1823003 	orr	r3, r2, r3
8f613b80:	e1a03603 	lsl	r3, r3, #12
8f613b84:	e3833e22 	orr	r3, r3, #544	; 0x220
8f613b88:	e3833001 	orr	r3, r3, #1
8f613b8c:	e1a00003 	mov	r0, r3
	register uint32_t r1 __asm__("r1") = (uint32_t)&context_id;
8f613b90:	e24b300c 	sub	r3, r11, #12
8f613b94:	e1a01003 	mov	r1, r3
	register uint32_t r2 __asm__("r2") = arg1;
8f613b98:	e51b2018 	ldr	r2, [r11, #-24]	; 0xffffffe8

	__asm__ volatile(
8f613b9c:	e1600070 	smc	0
		__asmeq("%3", "r2")
		"smc    #0  @ switch to secure world\n"
		: "=r" (r0)
		: "r" (r0), "r" (r1), "r" (r2)
		: "r3");
	return r0;
8f613ba0:	e1a03000 	mov	r3, r0
}
8f613ba4:	e59f2020 	ldr	r2, [pc, #32]	; 8f613bcc <scm_call_atomic+0x8c>
8f613ba8:	e5921000 	ldr	r1, [r2]
8f613bac:	e51b2008 	ldr	r2, [r11, #-8]
8f613bb0:	e0321001 	eors	r1, r2, r1
8f613bb4:	e3a02000 	mov	r2, #0
8f613bb8:	0a000000 	beq	8f613bc0 <scm_call_atomic+0x80>
8f613bbc:	eb007bff 	bl	8f632bc0 <__stack_chk_fail>
8f613bc0:	e1a00003 	mov	r0, r3
8f613bc4:	e24bd004 	sub	r13, r11, #4
8f613bc8:	e8bd8800 	pop	{r11, r15}
8f613bcc:	8f74221c 	.word	0x8f74221c

8f613bd0 <scm_call_atomic2>:
 *
 * This shall only be used with commands that are guaranteed to be
 * uninterruptable, atomic and SMP safe.
 */
int scm_call_atomic2(uint32_t svc, uint32_t cmd, uint32_t arg1, uint32_t arg2)
{
8f613bd0:	e92d4800 	push	{r11, r14}
8f613bd4:	e28db004 	add	r11, r13, #4
8f613bd8:	e24dd018 	sub	r13, r13, #24
8f613bdc:	e50b0010 	str	r0, [r11, #-16]
8f613be0:	e50b1014 	str	r1, [r11, #-20]	; 0xffffffec
8f613be4:	e50b2018 	str	r2, [r11, #-24]	; 0xffffffe8
8f613be8:	e50b301c 	str	r3, [r11, #-28]	; 0xffffffe4
8f613bec:	e59f3070 	ldr	r3, [pc, #112]	; 8f613c64 <scm_call_atomic2+0x94>
8f613bf0:	e5933000 	ldr	r3, [r3]
8f613bf4:	e50b3008 	str	r3, [r11, #-8]
8f613bf8:	e3a03000 	mov	r3, #0
	int context_id;
	register uint32_t r0 __asm__("r0") = SCM_ATOMIC(svc, cmd, 2);
8f613bfc:	e51b3010 	ldr	r3, [r11, #-16]
8f613c00:	e1a03503 	lsl	r3, r3, #10
8f613c04:	e6ff2073 	uxth	r2, r3
8f613c08:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
8f613c0c:	e7e93053 	ubfx	r3, r3, #0, #10
8f613c10:	e1823003 	orr	r3, r2, r3
8f613c14:	e1a03603 	lsl	r3, r3, #12
8f613c18:	e3833e22 	orr	r3, r3, #544	; 0x220
8f613c1c:	e3833002 	orr	r3, r3, #2
8f613c20:	e1a00003 	mov	r0, r3
	register uint32_t r1 __asm__("r1") = (uint32_t)&context_id;
8f613c24:	e24b300c 	sub	r3, r11, #12
8f613c28:	e1a01003 	mov	r1, r3
	register uint32_t r2 __asm__("r2") = arg1;
8f613c2c:	e51b2018 	ldr	r2, [r11, #-24]	; 0xffffffe8
	register uint32_t r3 __asm__("r3") = arg2;
8f613c30:	e51b301c 	ldr	r3, [r11, #-28]	; 0xffffffe4

	__asm__ volatile(
8f613c34:	e1600070 	smc	0
		__asmeq("%3", "r2")
		__asmeq("%4", "r3")
		"smc	#0	@ switch to secure world\n"
		: "=r" (r0)
		: "r" (r0), "r" (r1), "r" (r2), "r" (r3));
	return r0;
8f613c38:	e1a03000 	mov	r3, r0
}
8f613c3c:	e59f2020 	ldr	r2, [pc, #32]	; 8f613c64 <scm_call_atomic2+0x94>
8f613c40:	e5921000 	ldr	r1, [r2]
8f613c44:	e51b2008 	ldr	r2, [r11, #-8]
8f613c48:	e0321001 	eors	r1, r2, r1
8f613c4c:	e3a02000 	mov	r2, #0
8f613c50:	0a000000 	beq	8f613c58 <scm_call_atomic2+0x88>
8f613c54:	eb007bd9 	bl	8f632bc0 <__stack_chk_fail>
8f613c58:	e1a00003 	mov	r0, r3
8f613c5c:	e24bd004 	sub	r13, r11, #4
8f613c60:	e8bd8800 	pop	{r11, r15}
8f613c64:	8f74221c 	.word	0x8f74221c

8f613c68 <scm_call>:
 * Sends a command to the SCM and waits for the command to finish processing.
 */
int
scm_call(uint32_t svc_id, uint32_t cmd_id, const void *cmd_buf,
	 size_t cmd_len, void *resp_buf, size_t resp_len)
{
8f613c68:	e92d4800 	push	{r11, r14}
8f613c6c:	e28db004 	add	r11, r13, #4
8f613c70:	e24dd030 	sub	r13, r13, #48	; 0x30
8f613c74:	e50b0020 	str	r0, [r11, #-32]	; 0xffffffe0
8f613c78:	e50b1024 	str	r1, [r11, #-36]	; 0xffffffdc
8f613c7c:	e50b2028 	str	r2, [r11, #-40]	; 0xffffffd8
8f613c80:	e50b302c 	str	r3, [r11, #-44]	; 0xffffffd4
8f613c84:	e59b3004 	ldr	r3, [r11, #4]
8f613c88:	e50b3030 	str	r3, [r11, #-48]	; 0xffffffd0
8f613c8c:	e59b3008 	ldr	r3, [r11, #8]
8f613c90:	e50b3034 	str	r3, [r11, #-52]	; 0xffffffcc
8f613c94:	e59f3158 	ldr	r3, [pc, #344]	; 8f613df4 <scm_call+0x18c>
8f613c98:	e5933000 	ldr	r3, [r3]
8f613c9c:	e50b3008 	str	r3, [r11, #-8]
8f613ca0:	e3a03000 	mov	r3, #0
	int ret;
	struct scm_command *cmd;
	struct scm_response *rsp;
	uint8_t *resp_ptr;

	cmd = alloc_scm_command(cmd_len, resp_len);
8f613ca4:	e51b1034 	ldr	r1, [r11, #-52]	; 0xffffffcc
8f613ca8:	e51b002c 	ldr	r0, [r11, #-44]	; 0xffffffd4
8f613cac:	ebfffefb 	bl	8f6138a0 <alloc_scm_command>
8f613cb0:	e50b0018 	str	r0, [r11, #-24]	; 0xffffffe8
	if (!cmd)
8f613cb4:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f613cb8:	e3530000 	cmp	r3, #0
8f613cbc:	1a000001 	bne	8f613cc8 <scm_call+0x60>
		return ERR_NO_MEMORY;
8f613cc0:	e3e03004 	mvn	r3, #4
8f613cc4:	ea000040 	b	8f613dcc <scm_call+0x164>

	cmd->id = (svc_id << 10) | cmd_id;
8f613cc8:	e51b3020 	ldr	r3, [r11, #-32]	; 0xffffffe0
8f613ccc:	e1a02503 	lsl	r2, r3, #10
8f613cd0:	e51b3024 	ldr	r3, [r11, #-36]	; 0xffffffdc
8f613cd4:	e1822003 	orr	r2, r2, r3
8f613cd8:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f613cdc:	e583200c 	str	r2, [r3, #12]
	if (cmd_buf)
8f613ce0:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f613ce4:	e3530000 	cmp	r3, #0
8f613ce8:	0a000006 	beq	8f613d08 <scm_call+0xa0>
		memcpy(scm_get_command_buffer(cmd), cmd_buf, cmd_len);
8f613cec:	e51b0018 	ldr	r0, [r11, #-24]	; 0xffffffe8
8f613cf0:	ebffff4b 	bl	8f613a24 <scm_get_command_buffer>
8f613cf4:	e1a03000 	mov	r3, r0
8f613cf8:	e51b202c 	ldr	r2, [r11, #-44]	; 0xffffffd4
8f613cfc:	e51b1028 	ldr	r1, [r11, #-40]	; 0xffffffd8
8f613d00:	e1a00003 	mov	r0, r3
8f613d04:	eb00812b 	bl	8f6341b8 <memcpy>

	/* Flush command to main memory for TZ */
	arch_clean_invalidate_cache_range((addr_t) cmd, cmd->len);
8f613d08:	e51b2018 	ldr	r2, [r11, #-24]	; 0xffffffe8
8f613d0c:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f613d10:	e5933000 	ldr	r3, [r3]
8f613d14:	e1a01003 	mov	r1, r3
8f613d18:	e1a00002 	mov	r0, r2
8f613d1c:	eb00349f 	bl	8f620fa0 <arch_clean_invalidate_cache_range>

	ret = smc((uint32_t) cmd);
8f613d20:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f613d24:	e1a00003 	mov	r0, r3
8f613d28:	ebffff69 	bl	8f613ad4 <smc>
8f613d2c:	e1a03000 	mov	r3, r0
8f613d30:	e50b3014 	str	r3, [r11, #-20]	; 0xffffffec
	if (ret)
8f613d34:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
8f613d38:	e3530000 	cmp	r3, #0
8f613d3c:	1a00001c 	bne	8f613db4 <scm_call+0x14c>
		goto out;

	if (resp_len) {
8f613d40:	e51b3034 	ldr	r3, [r11, #-52]	; 0xffffffcc
8f613d44:	e3530000 	cmp	r3, #0
8f613d48:	0a00001b 	beq	8f613dbc <scm_call+0x154>
		rsp = scm_command_to_response(cmd);
8f613d4c:	e51b0018 	ldr	r0, [r11, #-24]	; 0xffffffe8
8f613d50:	ebffff1c 	bl	8f6139c8 <scm_command_to_response>
8f613d54:	e50b0010 	str	r0, [r11, #-16]
		do
		{
			/* Need to invalidate before each check since TZ will update
			 * the response complete flag in main memory.
			 */
			arch_invalidate_cache_range((addr_t) rsp, sizeof(*rsp));
8f613d58:	e51b3010 	ldr	r3, [r11, #-16]
8f613d5c:	e3a0100c 	mov	r1, #12
8f613d60:	e1a00003 	mov	r0, r3
8f613d64:	eb003497 	bl	8f620fc8 <arch_invalidate_cache_range>
		} while (!rsp->is_complete);
8f613d68:	e51b3010 	ldr	r3, [r11, #-16]
8f613d6c:	e5933008 	ldr	r3, [r3, #8]
8f613d70:	e3530000 	cmp	r3, #0
8f613d74:	0afffff7 	beq	8f613d58 <scm_call+0xf0>


		resp_ptr = scm_get_response_buffer(rsp);
8f613d78:	e51b0010 	ldr	r0, [r11, #-16]
8f613d7c:	ebffff3d 	bl	8f613a78 <scm_get_response_buffer>
8f613d80:	e50b000c 	str	r0, [r11, #-12]

		/* Invalidate any cached response data */
		arch_invalidate_cache_range((addr_t) resp_ptr, resp_len);
8f613d84:	e51b300c 	ldr	r3, [r11, #-12]
8f613d88:	e51b1034 	ldr	r1, [r11, #-52]	; 0xffffffcc
8f613d8c:	e1a00003 	mov	r0, r3
8f613d90:	eb00348c 	bl	8f620fc8 <arch_invalidate_cache_range>

		if (resp_buf)
8f613d94:	e51b3030 	ldr	r3, [r11, #-48]	; 0xffffffd0
8f613d98:	e3530000 	cmp	r3, #0
8f613d9c:	0a000006 	beq	8f613dbc <scm_call+0x154>
			memcpy(resp_buf, resp_ptr, resp_len);
8f613da0:	e51b2034 	ldr	r2, [r11, #-52]	; 0xffffffcc
8f613da4:	e51b100c 	ldr	r1, [r11, #-12]
8f613da8:	e51b0030 	ldr	r0, [r11, #-48]	; 0xffffffd0
8f613dac:	eb008101 	bl	8f6341b8 <memcpy>
8f613db0:	ea000002 	b	8f613dc0 <scm_call+0x158>
		goto out;
8f613db4:	e320f000 	nop	{0}
8f613db8:	ea000000 	b	8f613dc0 <scm_call+0x158>
	}
 out:
8f613dbc:	e320f000 	nop	{0}
	free_scm_command(cmd);
8f613dc0:	e51b0018 	ldr	r0, [r11, #-24]	; 0xffffffe8
8f613dc4:	ebfffeea 	bl	8f613974 <free_scm_command>
	return ret;
8f613dc8:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
}
8f613dcc:	e59f2020 	ldr	r2, [pc, #32]	; 8f613df4 <scm_call+0x18c>
8f613dd0:	e5921000 	ldr	r1, [r2]
8f613dd4:	e51b2008 	ldr	r2, [r11, #-8]
8f613dd8:	e0321001 	eors	r1, r2, r1
8f613ddc:	e3a02000 	mov	r2, #0
8f613de0:	0a000000 	beq	8f613de8 <scm_call+0x180>
8f613de4:	eb007b75 	bl	8f632bc0 <__stack_chk_fail>
8f613de8:	e1a00003 	mov	r0, r3
8f613dec:	e24bd004 	sub	r13, r11, #4
8f613df0:	e8bd8800 	pop	{r11, r15}
8f613df4:	8f74221c 	.word	0x8f74221c

8f613df8 <encrypt_scm>:
	return ret;
}

/* SCM Encrypt Command */
int encrypt_scm(uint32_t ** img_ptr, uint32_t * img_len_ptr)
{
8f613df8:	e92d4800 	push	{r11, r14}
8f613dfc:	e28db004 	add	r11, r13, #4
8f613e00:	e24dd060 	sub	r13, r13, #96	; 0x60
8f613e04:	e50b0058 	str	r0, [r11, #-88]	; 0xffffffa8
8f613e08:	e50b105c 	str	r1, [r11, #-92]	; 0xffffffa4
8f613e0c:	e59f3130 	ldr	r3, [pc, #304]	; 8f613f44 <encrypt_scm+0x14c>
8f613e10:	e5933000 	ldr	r3, [r3]
8f613e14:	e50b3008 	str	r3, [r11, #-8]
8f613e18:	e3a03000 	mov	r3, #0
	int ret;
	img_req cmd;
	scmcall_arg scm_arg = {0};
8f613e1c:	e24b3048 	sub	r3, r11, #72	; 0x48
8f613e20:	e3a02040 	mov	r2, #64	; 0x40
8f613e24:	e3a01000 	mov	r1, #0
8f613e28:	e1a00003 	mov	r0, r3
8f613e2c:	eb008124 	bl	8f6342c4 <memset>


	cmd.img_ptr     = (uint32*) img_ptr;
8f613e30:	e51b3058 	ldr	r3, [r11, #-88]	; 0xffffffa8
8f613e34:	e50b3050 	str	r3, [r11, #-80]	; 0xffffffb0
	cmd.img_len_ptr = img_len_ptr;
8f613e38:	e51b305c 	ldr	r3, [r11, #-92]	; 0xffffffa4
8f613e3c:	e50b304c 	str	r3, [r11, #-76]	; 0xffffffb4

	/* Image data is operated upon by TZ, which accesses only the main memory.
	 * It must be flushed/invalidated before and after TZ call.
	 */
	arch_clean_invalidate_cache_range((addr_t) *img_ptr, *img_len_ptr);
8f613e40:	e51b3058 	ldr	r3, [r11, #-88]	; 0xffffffa8
8f613e44:	e5933000 	ldr	r3, [r3]
8f613e48:	e1a02003 	mov	r2, r3
8f613e4c:	e51b305c 	ldr	r3, [r11, #-92]	; 0xffffffa4
8f613e50:	e5933000 	ldr	r3, [r3]
8f613e54:	e1a01003 	mov	r1, r3
8f613e58:	e1a00002 	mov	r0, r2
8f613e5c:	eb00344f 	bl	8f620fa0 <arch_clean_invalidate_cache_range>

	if (!is_scm_armv8_support())
8f613e60:	ebfffdf6 	bl	8f613640 <is_scm_armv8_support>
8f613e64:	e1a03000 	mov	r3, r0
8f613e68:	e3530000 	cmp	r3, #0
8f613e6c:	1a00000a 	bne	8f613e9c <encrypt_scm+0xa4>
	{
		ret = scm_call(SCM_SVC_SSD, SSD_ENCRYPT_ID, &cmd, sizeof(cmd), NULL, 0);
8f613e70:	e24b2050 	sub	r2, r11, #80	; 0x50
8f613e74:	e3a03000 	mov	r3, #0
8f613e78:	e58d3004 	str	r3, [r13, #4]
8f613e7c:	e3a03000 	mov	r3, #0
8f613e80:	e58d3000 	str	r3, [r13]
8f613e84:	e3a03008 	mov	r3, #8
8f613e88:	e3a01002 	mov	r1, #2
8f613e8c:	e3a00007 	mov	r0, #7
8f613e90:	ebffff74 	bl	8f613c68 <scm_call>
8f613e94:	e50b0054 	str	r0, [r11, #-84]	; 0xffffffac
8f613e98:	ea00000e 	b	8f613ed8 <encrypt_scm+0xe0>
	}
	else
	{
		scm_arg.x0 = MAKE_SIP_SCM_CMD(SCM_SVC_SSD,SSD_ENCRYPT_ID);
8f613e9c:	e3003702 	movw	r3, #1794	; 0x702
8f613ea0:	e3403200 	movt	r3, #512	; 0x200
8f613ea4:	e50b3048 	str	r3, [r11, #-72]	; 0xffffffb8
		scm_arg.x1 = MAKE_SCM_ARGS(0x2,SMC_PARAM_TYPE_BUFFER_READWRITE,SMC_PARAM_TYPE_BUFFER_READWRITE);
8f613ea8:	e3a030a2 	mov	r3, #162	; 0xa2
8f613eac:	e50b3044 	str	r3, [r11, #-68]	; 0xffffffbc
		scm_arg.x2 = (uint32_t) cmd.img_ptr;
8f613eb0:	e51b3050 	ldr	r3, [r11, #-80]	; 0xffffffb0
8f613eb4:	e50b3040 	str	r3, [r11, #-64]	; 0xffffffc0
		scm_arg.x3 = (uint32_t) cmd.img_len_ptr;
8f613eb8:	e51b304c 	ldr	r3, [r11, #-76]	; 0xffffffb4
8f613ebc:	e50b303c 	str	r3, [r11, #-60]	; 0xffffffc4

		ret = scm_call2(&scm_arg, NULL);
8f613ec0:	e24b3048 	sub	r3, r11, #72	; 0x48
8f613ec4:	e3a01000 	mov	r1, #0
8f613ec8:	e1a00003 	mov	r0, r3
8f613ecc:	eb0003bf 	bl	8f614dd0 <scm_call2>
8f613ed0:	e1a03000 	mov	r3, r0
8f613ed4:	e50b3054 	str	r3, [r11, #-84]	; 0xffffffac
	}

	/* Values at img_ptr and img_len_ptr are updated by TZ. Must be invalidated
	 * before we use them.
	 */
	arch_clean_invalidate_cache_range((addr_t) img_ptr, sizeof(img_ptr));
8f613ed8:	e51b3058 	ldr	r3, [r11, #-88]	; 0xffffffa8
8f613edc:	e3a01004 	mov	r1, #4
8f613ee0:	e1a00003 	mov	r0, r3
8f613ee4:	eb00342d 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	arch_clean_invalidate_cache_range((addr_t) img_len_ptr, sizeof(img_len_ptr));
8f613ee8:	e51b305c 	ldr	r3, [r11, #-92]	; 0xffffffa4
8f613eec:	e3a01004 	mov	r1, #4
8f613ef0:	e1a00003 	mov	r0, r3
8f613ef4:	eb003429 	bl	8f620fa0 <arch_clean_invalidate_cache_range>

	/* Invalidate the updated image data */
	arch_clean_invalidate_cache_range((addr_t) *img_ptr, *img_len_ptr);
8f613ef8:	e51b3058 	ldr	r3, [r11, #-88]	; 0xffffffa8
8f613efc:	e5933000 	ldr	r3, [r3]
8f613f00:	e1a02003 	mov	r2, r3
8f613f04:	e51b305c 	ldr	r3, [r11, #-92]	; 0xffffffa4
8f613f08:	e5933000 	ldr	r3, [r3]
8f613f0c:	e1a01003 	mov	r1, r3
8f613f10:	e1a00002 	mov	r0, r2
8f613f14:	eb003421 	bl	8f620fa0 <arch_clean_invalidate_cache_range>

	return ret;
8f613f18:	e51b3054 	ldr	r3, [r11, #-84]	; 0xffffffac
}
8f613f1c:	e59f2020 	ldr	r2, [pc, #32]	; 8f613f44 <encrypt_scm+0x14c>
8f613f20:	e5921000 	ldr	r1, [r2]
8f613f24:	e51b2008 	ldr	r2, [r11, #-8]
8f613f28:	e0321001 	eors	r1, r2, r1
8f613f2c:	e3a02000 	mov	r2, #0
8f613f30:	0a000000 	beq	8f613f38 <encrypt_scm+0x140>
8f613f34:	eb007b21 	bl	8f632bc0 <__stack_chk_fail>
8f613f38:	e1a00003 	mov	r0, r3
8f613f3c:	e24bd004 	sub	r13, r11, #4
8f613f40:	e8bd8800 	pop	{r11, r15}
8f613f44:	8f74221c 	.word	0x8f74221c

8f613f48 <decrypt_scm>:

/* SCM Decrypt Command */
int decrypt_scm(uint32_t ** img_ptr, uint32_t * img_len_ptr)
{
8f613f48:	e92d4800 	push	{r11, r14}
8f613f4c:	e28db004 	add	r11, r13, #4
8f613f50:	e24dd020 	sub	r13, r13, #32
8f613f54:	e50b0018 	str	r0, [r11, #-24]	; 0xffffffe8
8f613f58:	e50b101c 	str	r1, [r11, #-28]	; 0xffffffe4
8f613f5c:	e59f30f8 	ldr	r3, [pc, #248]	; 8f61405c <decrypt_scm+0x114>
8f613f60:	e5933000 	ldr	r3, [r3]
8f613f64:	e50b3008 	str	r3, [r11, #-8]
8f613f68:	e3a03000 	mov	r3, #0
	int ret;
	img_req cmd;

	if (is_scm_armv8_support())
8f613f6c:	ebfffdb3 	bl	8f613640 <is_scm_armv8_support>
8f613f70:	e1a03000 	mov	r3, r0
8f613f74:	e3530000 	cmp	r3, #0
8f613f78:	0a000006 	beq	8f613f98 <decrypt_scm+0x50>
	{
		dprintf(INFO, "%s:SCM call is not supported\n",__func__);
8f613f7c:	e3041884 	movw	r1, #18564	; 0x4884
8f613f80:	e3481f70 	movt	r1, #36720	; 0x8f70
8f613f84:	e3040480 	movw	r0, #17536	; 0x4480
8f613f88:	e3480f70 	movt	r0, #36720	; 0x8f70
8f613f8c:	eb007a78 	bl	8f632974 <_dprintf>
		return -1;
8f613f90:	e3e03000 	mvn	r3, #0
8f613f94:	ea000026 	b	8f614034 <decrypt_scm+0xec>
	}

	cmd.img_ptr     = (uint32*) img_ptr;
8f613f98:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f613f9c:	e50b3010 	str	r3, [r11, #-16]
	cmd.img_len_ptr = img_len_ptr;
8f613fa0:	e51b301c 	ldr	r3, [r11, #-28]	; 0xffffffe4
8f613fa4:	e50b300c 	str	r3, [r11, #-12]

	/* Image data is operated upon by TZ, which accesses only the main memory.
	 * It must be flushed/invalidated before and after TZ call.
	 */
	arch_clean_invalidate_cache_range((addr_t) *img_ptr, *img_len_ptr);
8f613fa8:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f613fac:	e5933000 	ldr	r3, [r3]
8f613fb0:	e1a02003 	mov	r2, r3
8f613fb4:	e51b301c 	ldr	r3, [r11, #-28]	; 0xffffffe4
8f613fb8:	e5933000 	ldr	r3, [r3]
8f613fbc:	e1a01003 	mov	r1, r3
8f613fc0:	e1a00002 	mov	r0, r2
8f613fc4:	eb0033f5 	bl	8f620fa0 <arch_clean_invalidate_cache_range>

	ret = scm_call(SCM_SVC_SSD, SSD_DECRYPT_ID, &cmd, sizeof(cmd), NULL, 0);
8f613fc8:	e24b2010 	sub	r2, r11, #16
8f613fcc:	e3a03000 	mov	r3, #0
8f613fd0:	e58d3004 	str	r3, [r13, #4]
8f613fd4:	e3a03000 	mov	r3, #0
8f613fd8:	e58d3000 	str	r3, [r13]
8f613fdc:	e3a03008 	mov	r3, #8
8f613fe0:	e3a01001 	mov	r1, #1
8f613fe4:	e3a00007 	mov	r0, #7
8f613fe8:	ebffff1e 	bl	8f613c68 <scm_call>
8f613fec:	e50b0014 	str	r0, [r11, #-20]	; 0xffffffec

	/* Values at img_ptr and img_len_ptr are updated by TZ. Must be invalidated
	 * before we use them.
	 */
	arch_clean_invalidate_cache_range((addr_t) img_ptr, sizeof(img_ptr));
8f613ff0:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f613ff4:	e3a01004 	mov	r1, #4
8f613ff8:	e1a00003 	mov	r0, r3
8f613ffc:	eb0033e7 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	arch_clean_invalidate_cache_range((addr_t) img_len_ptr, sizeof(img_len_ptr));
8f614000:	e51b301c 	ldr	r3, [r11, #-28]	; 0xffffffe4
8f614004:	e3a01004 	mov	r1, #4
8f614008:	e1a00003 	mov	r0, r3
8f61400c:	eb0033e3 	bl	8f620fa0 <arch_clean_invalidate_cache_range>

	/* Invalidate the updated image data */
	arch_clean_invalidate_cache_range((addr_t) *img_ptr, *img_len_ptr);
8f614010:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f614014:	e5933000 	ldr	r3, [r3]
8f614018:	e1a02003 	mov	r2, r3
8f61401c:	e51b301c 	ldr	r3, [r11, #-28]	; 0xffffffe4
8f614020:	e5933000 	ldr	r3, [r3]
8f614024:	e1a01003 	mov	r1, r3
8f614028:	e1a00002 	mov	r0, r2
8f61402c:	eb0033db 	bl	8f620fa0 <arch_clean_invalidate_cache_range>

	return ret;
8f614030:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
}
8f614034:	e59f2020 	ldr	r2, [pc, #32]	; 8f61405c <decrypt_scm+0x114>
8f614038:	e5921000 	ldr	r1, [r2]
8f61403c:	e51b2008 	ldr	r2, [r11, #-8]
8f614040:	e0321001 	eors	r1, r2, r1
8f614044:	e3a02000 	mov	r2, #0
8f614048:	0a000000 	beq	8f614050 <decrypt_scm+0x108>
8f61404c:	eb007adb 	bl	8f632bc0 <__stack_chk_fail>
8f614050:	e1a00003 	mov	r0, r3
8f614054:	e24bd004 	sub	r13, r11, #4
8f614058:	e8bd8800 	pop	{r11, r15}
8f61405c:	8f74221c 	.word	0x8f74221c

8f614060 <ssd_image_is_encrypted>:


static int ssd_image_is_encrypted(uint32_t ** img_ptr, uint32_t * img_len_ptr, uint32 * ctx_id)
{
8f614060:	e92d4810 	push	{r4, r11, r14}
8f614064:	e28db008 	add	r11, r13, #8
8f614068:	e24dd08c 	sub	r13, r13, #140	; 0x8c
8f61406c:	e1a0400e 	mov	r4, r14
8f614070:	e50b0080 	str	r0, [r11, #-128]	; 0xffffff80
8f614074:	e50b1084 	str	r1, [r11, #-132]	; 0xffffff7c
8f614078:	e50b2088 	str	r2, [r11, #-136]	; 0xffffff78
8f61407c:	e59f3268 	ldr	r3, [pc, #616]	; 8f6142ec <ssd_image_is_encrypted+0x28c>
8f614080:	e5933000 	ldr	r3, [r3]
8f614084:	e50b3010 	str	r3, [r11, #-16]
8f614088:	e3a03000 	mov	r3, #0
	int              ret     = 0;
8f61408c:	e3a03000 	mov	r3, #0
8f614090:	e50b3078 	str	r3, [r11, #-120]	; 0xffffff88
	ssd_parse_md_req parse_req = {0};
8f614094:	e24b3070 	sub	r3, r11, #112	; 0x70
8f614098:	e3a02000 	mov	r2, #0
8f61409c:	e5832000 	str	r2, [r3]
8f6140a0:	e5832004 	str	r2, [r3, #4]
	ssd_parse_md_rsp parse_rsp = {0};
8f6140a4:	e24b3068 	sub	r3, r11, #104	; 0x68
8f6140a8:	e3a02000 	mov	r2, #0
8f6140ac:	e5832000 	str	r2, [r3]
8f6140b0:	e5832004 	str	r2, [r3, #4]
8f6140b4:	e5832008 	str	r2, [r3, #8]
	int              prev_len = 0;
8f6140b8:	e3a03000 	mov	r3, #0
8f6140bc:	e50b3074 	str	r3, [r11, #-116]	; 0xffffff8c
	scmcall_arg scm_arg = {0};
8f6140c0:	e24b3050 	sub	r3, r11, #80	; 0x50
8f6140c4:	e3a02040 	mov	r2, #64	; 0x40
8f6140c8:	e3a01000 	mov	r1, #0
8f6140cc:	e1a00003 	mov	r0, r3
8f6140d0:	eb00807b 	bl	8f6342c4 <memset>
	scmcall_ret scm_ret = {0};
8f6140d4:	e24b305c 	sub	r3, r11, #92	; 0x5c
8f6140d8:	e3a02000 	mov	r2, #0
8f6140dc:	e5832000 	str	r2, [r3]
8f6140e0:	e5832004 	str	r2, [r3, #4]
8f6140e4:	e5832008 	str	r2, [r3, #8]
	 * min(img_len_ptr,SSD_HEADER_MIN_SIZE) say 128 bytes for example.
	 * If parse_rsp.status = PARSING_INCOMPLETE we send md_len = 256.
	 * If subsequent status = PARSING_INCOMPLETE we send md_len = 512,
	 * 1024bytes and so on until we get an valid response(rsp.status) from TZ*/

	parse_req.md     = (uint32*)*img_ptr;
8f6140e8:	e51b3080 	ldr	r3, [r11, #-128]	; 0xffffff80
8f6140ec:	e5933000 	ldr	r3, [r3]
8f6140f0:	e50b306c 	str	r3, [r11, #-108]	; 0xffffff94
	parse_req.md_len = ((*img_len_ptr) >= SSD_HEADER_MIN_SIZE) ? SSD_HEADER_MIN_SIZE : (*img_len_ptr);
8f6140f4:	e51b3084 	ldr	r3, [r11, #-132]	; 0xffffff7c
8f6140f8:	e5933000 	ldr	r3, [r3]
8f6140fc:	e3530080 	cmp	r3, #128	; 0x80
8f614100:	31a03003 	movcc	r3, r3
8f614104:	23a03080 	movcs	r3, #128	; 0x80
8f614108:	e50b3070 	str	r3, [r11, #-112]	; 0xffffff90

	arch_clean_invalidate_cache_range((addr_t) *img_ptr, parse_req.md_len);
8f61410c:	e51b3080 	ldr	r3, [r11, #-128]	; 0xffffff80
8f614110:	e5933000 	ldr	r3, [r3]
8f614114:	e1a02003 	mov	r2, r3
8f614118:	e51b3070 	ldr	r3, [r11, #-112]	; 0xffffff90
8f61411c:	e1a01003 	mov	r1, r3
8f614120:	e1a00002 	mov	r0, r2
8f614124:	eb00339d 	bl	8f620fa0 <arch_clean_invalidate_cache_range>

	do
	{
		if (!is_scm_armv8_support())
8f614128:	ebfffd44 	bl	8f613640 <is_scm_armv8_support>
8f61412c:	e1a03000 	mov	r3, r0
8f614130:	e3530000 	cmp	r3, #0
8f614134:	1a00000a 	bne	8f614164 <ssd_image_is_encrypted+0x104>
		{
			ret = scm_call(SCM_SVC_SSD,
8f614138:	e24b2070 	sub	r2, r11, #112	; 0x70
8f61413c:	e3a0300c 	mov	r3, #12
8f614140:	e58d3004 	str	r3, [r13, #4]
8f614144:	e24b3068 	sub	r3, r11, #104	; 0x68
8f614148:	e58d3000 	str	r3, [r13]
8f61414c:	e3a03008 	mov	r3, #8
8f614150:	e3a01006 	mov	r1, #6
8f614154:	e3a00007 	mov	r0, #7
8f614158:	ebfffec2 	bl	8f613c68 <scm_call>
8f61415c:	e50b0078 	str	r0, [r11, #-120]	; 0xffffff88
8f614160:	ea000013 	b	8f6141b4 <ssd_image_is_encrypted+0x154>
					&parse_rsp,
					sizeof(parse_rsp));
		}
		else
		{
			scm_arg.x0 = MAKE_SIP_SCM_CMD(SCM_SVC_SSD, SSD_PARSE_MD_ID);
8f614164:	e3003706 	movw	r3, #1798	; 0x706
8f614168:	e3403200 	movt	r3, #512	; 0x200
8f61416c:	e50b3050 	str	r3, [r11, #-80]	; 0xffffffb0
			scm_arg.x1 = MAKE_SCM_ARGS(0x2,SMC_PARAM_TYPE_VALUE,SMC_PARAM_TYPE_BUFFER_READWRITE);
8f614170:	e3a03082 	mov	r3, #130	; 0x82
8f614174:	e50b304c 	str	r3, [r11, #-76]	; 0xffffffb4
			scm_arg.x2 = parse_req.md_len;
8f614178:	e51b3070 	ldr	r3, [r11, #-112]	; 0xffffff90
8f61417c:	e50b3048 	str	r3, [r11, #-72]	; 0xffffffb8
			scm_arg.x3 = (uint32_t) parse_req.md;
8f614180:	e51b306c 	ldr	r3, [r11, #-108]	; 0xffffff94
8f614184:	e50b3044 	str	r3, [r11, #-68]	; 0xffffffbc
			scm_arg.atomic = true;
8f614188:	e3a03001 	mov	r3, #1
8f61418c:	e50b3014 	str	r3, [r11, #-20]	; 0xffffffec

			ret = scm_call2(&scm_arg, &scm_ret);
8f614190:	e24b205c 	sub	r2, r11, #92	; 0x5c
8f614194:	e24b3050 	sub	r3, r11, #80	; 0x50
8f614198:	e1a01002 	mov	r1, r2
8f61419c:	e1a00003 	mov	r0, r3
8f6141a0:	eb00030a 	bl	8f614dd0 <scm_call2>
8f6141a4:	e1a03000 	mov	r3, r0
8f6141a8:	e50b3078 	str	r3, [r11, #-120]	; 0xffffff88
			parse_rsp.status = scm_ret.x1;
8f6141ac:	e51b305c 	ldr	r3, [r11, #-92]	; 0xffffffa4
8f6141b0:	e50b3068 	str	r3, [r11, #-104]	; 0xffffff98
		}
		if(!ret && (parse_rsp.status == SSD_PMD_PARSING_INCOMPLETE))
8f6141b4:	e51b3078 	ldr	r3, [r11, #-120]	; 0xffffff88
8f6141b8:	e3530000 	cmp	r3, #0
8f6141bc:	1a000013 	bne	8f614210 <ssd_image_is_encrypted+0x1b0>
8f6141c0:	e51b3068 	ldr	r3, [r11, #-104]	; 0xffffff98
8f6141c4:	e3530006 	cmp	r3, #6
8f6141c8:	1a000010 	bne	8f614210 <ssd_image_is_encrypted+0x1b0>
		{
			prev_len          = parse_req.md_len;
8f6141cc:	e51b3070 	ldr	r3, [r11, #-112]	; 0xffffff90
8f6141d0:	e50b3074 	str	r3, [r11, #-116]	; 0xffffff8c

			parse_req.md_len *= MULTIPLICATION_FACTOR;
8f6141d4:	e51b3070 	ldr	r3, [r11, #-112]	; 0xffffff90
8f6141d8:	e1a03083 	lsl	r3, r3, #1
8f6141dc:	e50b3070 	str	r3, [r11, #-112]	; 0xffffff90

			arch_clean_invalidate_cache_range((addr_t) (*img_ptr + prev_len),
8f6141e0:	e51b3080 	ldr	r3, [r11, #-128]	; 0xffffff80
8f6141e4:	e5932000 	ldr	r2, [r3]
8f6141e8:	e51b3074 	ldr	r3, [r11, #-116]	; 0xffffff8c
8f6141ec:	e1a03103 	lsl	r3, r3, #2
8f6141f0:	e0823003 	add	r3, r2, r3
8f6141f4:	e1a00003 	mov	r0, r3
		                                         (parse_req.md_len - prev_len) );
8f6141f8:	e51b2070 	ldr	r2, [r11, #-112]	; 0xffffff90
			arch_clean_invalidate_cache_range((addr_t) (*img_ptr + prev_len),
8f6141fc:	e51b3074 	ldr	r3, [r11, #-116]	; 0xffffff8c
8f614200:	e0423003 	sub	r3, r2, r3
8f614204:	e1a01003 	mov	r1, r3
8f614208:	eb003364 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
		if (!is_scm_armv8_support())
8f61420c:	eaffffc5 	b	8f614128 <ssd_image_is_encrypted+0xc8>
		else
			break;

	} while(true);

	if(!ret)
8f614210:	e51b3078 	ldr	r3, [r11, #-120]	; 0xffffff88
8f614214:	e3530000 	cmp	r3, #0
8f614218:	1a000014 	bne	8f614270 <ssd_image_is_encrypted+0x210>
	{
		if(parse_rsp.status == SSD_PMD_ENCRYPTED)
8f61421c:	e51b3068 	ldr	r3, [r11, #-104]	; 0xffffff98
8f614220:	e3530000 	cmp	r3, #0
8f614224:	1a00000e 	bne	8f614264 <ssd_image_is_encrypted+0x204>
		{
			*ctx_id      = parse_rsp.md_ctx_id;
8f614228:	e51b2064 	ldr	r2, [r11, #-100]	; 0xffffff9c
8f61422c:	e51b3088 	ldr	r3, [r11, #-136]	; 0xffffff78
8f614230:	e5832000 	str	r2, [r3]
			*img_len_ptr = *img_len_ptr - ((uint8_t*)parse_rsp.md_end_ptr - (uint8_t*)*img_ptr);
8f614234:	e51b3084 	ldr	r3, [r11, #-132]	; 0xffffff7c
8f614238:	e5933000 	ldr	r3, [r3]
8f61423c:	e51b1060 	ldr	r1, [r11, #-96]	; 0xffffffa0
8f614240:	e51b2080 	ldr	r2, [r11, #-128]	; 0xffffff80
8f614244:	e5922000 	ldr	r2, [r2]
8f614248:	e0412002 	sub	r2, r1, r2
8f61424c:	e0432002 	sub	r2, r3, r2
8f614250:	e51b3084 	ldr	r3, [r11, #-132]	; 0xffffff7c
8f614254:	e5832000 	str	r2, [r3]
			*img_ptr     = (uint32_t*)parse_rsp.md_end_ptr;
8f614258:	e51b2060 	ldr	r2, [r11, #-96]	; 0xffffffa0
8f61425c:	e51b3080 	ldr	r3, [r11, #-128]	; 0xffffff80
8f614260:	e5832000 	str	r2, [r3]
		}

		ret = parse_rsp.status;
8f614264:	e51b3068 	ldr	r3, [r11, #-104]	; 0xffffff98
8f614268:	e50b3078 	str	r3, [r11, #-120]	; 0xffffff88
8f61426c:	ea000013 	b	8f6142c0 <ssd_image_is_encrypted+0x260>
	}
	else
	{
		dprintf(CRITICAL,"ssd_image_is_encrypted call failed");
8f614270:	e30404a0 	movw	r0, #17568	; 0x44a0
8f614274:	e3480f70 	movt	r0, #36720	; 0x8f70
8f614278:	eb0079bd 	bl	8f632974 <_dprintf>

		ASSERT(ret == 0);
8f61427c:	e51b3078 	ldr	r3, [r11, #-120]	; 0xffffff88
8f614280:	e3530000 	cmp	r3, #0
8f614284:	13a03001 	movne	r3, #1
8f614288:	03a03000 	moveq	r3, #0
8f61428c:	e6ef3073 	uxtb	r3, r3
8f614290:	e3530000 	cmp	r3, #0
8f614294:	0a000009 	beq	8f6142c0 <ssd_image_is_encrypted+0x260>
8f614298:	e1a00004 	mov	r0, r4
8f61429c:	e3043500 	movw	r3, #17664	; 0x4500
8f6142a0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6142a4:	e58d3000 	str	r3, [r13]
8f6142a8:	e3003201 	movw	r3, #513	; 0x201
8f6142ac:	e30424c4 	movw	r2, #17604	; 0x44c4
8f6142b0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6142b4:	e30414e0 	movw	r1, #17632	; 0x44e0
8f6142b8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6142bc:	eb0079fe 	bl	8f632abc <_panic>
	}

	return ret;
8f6142c0:	e51b3078 	ldr	r3, [r11, #-120]	; 0xffffff88
}
8f6142c4:	e59f2020 	ldr	r2, [pc, #32]	; 8f6142ec <ssd_image_is_encrypted+0x28c>
8f6142c8:	e5921000 	ldr	r1, [r2]
8f6142cc:	e51b2010 	ldr	r2, [r11, #-16]
8f6142d0:	e0321001 	eors	r1, r2, r1
8f6142d4:	e3a02000 	mov	r2, #0
8f6142d8:	0a000000 	beq	8f6142e0 <ssd_image_is_encrypted+0x280>
8f6142dc:	eb007a37 	bl	8f632bc0 <__stack_chk_fail>
8f6142e0:	e1a00003 	mov	r0, r3
8f6142e4:	e24bd008 	sub	r13, r11, #8
8f6142e8:	e8bd8810 	pop	{r4, r11, r15}
8f6142ec:	8f74221c 	.word	0x8f74221c

8f6142f0 <decrypt_scm_v2>:

int decrypt_scm_v2(uint32_t ** img_ptr, uint32_t * img_len_ptr)
{
8f6142f0:	e92d4800 	push	{r11, r14}
8f6142f4:	e28db004 	add	r11, r13, #4
8f6142f8:	e24dd080 	sub	r13, r13, #128	; 0x80
8f6142fc:	e50b0078 	str	r0, [r11, #-120]	; 0xffffff88
8f614300:	e50b107c 	str	r1, [r11, #-124]	; 0xffffff84
8f614304:	e59f3220 	ldr	r3, [pc, #544]	; 8f61452c <decrypt_scm_v2+0x23c>
8f614308:	e5933000 	ldr	r3, [r3]
8f61430c:	e50b3008 	str	r3, [r11, #-8]
8f614310:	e3a03000 	mov	r3, #0
	int                      ret    = 0;
8f614314:	e3a03000 	mov	r3, #0
8f614318:	e50b3068 	str	r3, [r11, #-104]	; 0xffffff98
	uint32                   ctx_id = 0;
8f61431c:	e3a03000 	mov	r3, #0
8f614320:	e50b3070 	str	r3, [r11, #-112]	; 0xffffff90
	ssd_decrypt_img_frag_req decrypt_req;
	ssd_decrypt_img_frag_rsp decrypt_rsp;
	scmcall_arg scm_arg = {0};
8f614324:	e24b3048 	sub	r3, r11, #72	; 0x48
8f614328:	e3a02040 	mov	r2, #64	; 0x40
8f61432c:	e3a01000 	mov	r1, #0
8f614330:	e1a00003 	mov	r0, r3
8f614334:	eb007fe2 	bl	8f6342c4 <memset>
	scmcall_ret scm_ret = {0};
8f614338:	e24b3064 	sub	r3, r11, #100	; 0x64
8f61433c:	e3a02000 	mov	r2, #0
8f614340:	e5832000 	str	r2, [r3]
8f614344:	e5832004 	str	r2, [r3, #4]
8f614348:	e5832008 	str	r2, [r3, #8]


	ret = ssd_image_is_encrypted(img_ptr,img_len_ptr,&ctx_id);
8f61434c:	e24b3070 	sub	r3, r11, #112	; 0x70
8f614350:	e1a02003 	mov	r2, r3
8f614354:	e51b107c 	ldr	r1, [r11, #-124]	; 0xffffff84
8f614358:	e51b0078 	ldr	r0, [r11, #-120]	; 0xffffff88
8f61435c:	ebffff3f 	bl	8f614060 <ssd_image_is_encrypted>
8f614360:	e50b0068 	str	r0, [r11, #-104]	; 0xffffff98
	switch(ret)
8f614364:	e51b3068 	ldr	r3, [r11, #-104]	; 0xffffff98
8f614368:	e3530008 	cmp	r3, #8
8f61436c:	979ff103 	ldrls	r15, [r15, r3, lsl #2]
8f614370:	ea00005d 	b	8f6144ec <decrypt_scm_v2+0x1fc>
8f614374:	8f614398 	.word	0x8f614398
8f614378:	8f6144cc 	.word	0x8f6144cc
8f61437c:	8f6144ec 	.word	0x8f6144ec
8f614380:	8f6144cc 	.word	0x8f6144cc
8f614384:	8f6144d8 	.word	0x8f6144d8
8f614388:	8f6144d8 	.word	0x8f6144d8
8f61438c:	8f6144d8 	.word	0x8f6144d8
8f614390:	8f6144d8 	.word	0x8f6144d8
8f614394:	8f6144d8 	.word	0x8f6144d8
		case SSD_PMD_ENCRYPTED:
			/* Image data is operated upon by TZ, which accesses only the main memory.
			* It must be flushed/invalidated before and after TZ call.
			*/

			arch_clean_invalidate_cache_range((addr_t) *img_ptr, *img_len_ptr);
8f614398:	e51b3078 	ldr	r3, [r11, #-120]	; 0xffffff88
8f61439c:	e5933000 	ldr	r3, [r3]
8f6143a0:	e1a02003 	mov	r2, r3
8f6143a4:	e51b307c 	ldr	r3, [r11, #-124]	; 0xffffff84
8f6143a8:	e5933000 	ldr	r3, [r3]
8f6143ac:	e1a01003 	mov	r1, r3
8f6143b0:	e1a00002 	mov	r0, r2
8f6143b4:	eb0032f9 	bl	8f620fa0 <arch_clean_invalidate_cache_range>

			/*decrypt the image here*/

			decrypt_req.md_ctx_id = ctx_id;
8f6143b8:	e51b3070 	ldr	r3, [r11, #-112]	; 0xffffff90
8f6143bc:	e50b3058 	str	r3, [r11, #-88]	; 0xffffffa8
			decrypt_req.last_frag = 1;
8f6143c0:	e3a03001 	mov	r3, #1
8f6143c4:	e50b3054 	str	r3, [r11, #-84]	; 0xffffffac
			decrypt_req.frag_len  = *img_len_ptr;
8f6143c8:	e51b307c 	ldr	r3, [r11, #-124]	; 0xffffff84
8f6143cc:	e5933000 	ldr	r3, [r3]
8f6143d0:	e50b3050 	str	r3, [r11, #-80]	; 0xffffffb0
			decrypt_req.frag      = *img_ptr;
8f6143d4:	e51b3078 	ldr	r3, [r11, #-120]	; 0xffffff88
8f6143d8:	e5933000 	ldr	r3, [r3]
8f6143dc:	e50b304c 	str	r3, [r11, #-76]	; 0xffffffb4

			if (!is_scm_armv8_support())
8f6143e0:	ebfffc96 	bl	8f613640 <is_scm_armv8_support>
8f6143e4:	e1a03000 	mov	r3, r0
8f6143e8:	e3530000 	cmp	r3, #0
8f6143ec:	1a00000a 	bne	8f61441c <decrypt_scm_v2+0x12c>
			{
				ret = scm_call(SCM_SVC_SSD,
8f6143f0:	e24b2058 	sub	r2, r11, #88	; 0x58
8f6143f4:	e3a03004 	mov	r3, #4
8f6143f8:	e58d3004 	str	r3, [r13, #4]
8f6143fc:	e24b306c 	sub	r3, r11, #108	; 0x6c
8f614400:	e58d3000 	str	r3, [r13]
8f614404:	e3a03010 	mov	r3, #16
8f614408:	e3a01007 	mov	r1, #7
8f61440c:	e3a00007 	mov	r0, #7
8f614410:	ebfffe14 	bl	8f613c68 <scm_call>
8f614414:	e50b0068 	str	r0, [r11, #-104]	; 0xffffff98
8f614418:	ea000015 	b	8f614474 <decrypt_scm_v2+0x184>
						&decrypt_rsp,
						sizeof(decrypt_rsp));
			}
			else
			{
				scm_arg.x0 = MAKE_SIP_SCM_CMD(SCM_SVC_SSD, SSD_DECRYPT_IMG_FRAG_ID);
8f61441c:	e3003707 	movw	r3, #1799	; 0x707
8f614420:	e3403200 	movt	r3, #512	; 0x200
8f614424:	e50b3048 	str	r3, [r11, #-72]	; 0xffffffb8
				scm_arg.x1 = MAKE_SCM_ARGS(0x4,SMC_PARAM_TYPE_VALUE,SMC_PARAM_TYPE_VALUE,SMC_PARAM_TYPE_VALUE,SMC_PARAM_TYPE_BUFFER_READWRITE);
8f614428:	e3003804 	movw	r3, #2052	; 0x804
8f61442c:	e50b3044 	str	r3, [r11, #-68]	; 0xffffffbc
				scm_arg.x2 = decrypt_req.md_ctx_id;
8f614430:	e51b3058 	ldr	r3, [r11, #-88]	; 0xffffffa8
8f614434:	e50b3040 	str	r3, [r11, #-64]	; 0xffffffc0
				scm_arg.x3 = decrypt_req.last_frag;
8f614438:	e51b3054 	ldr	r3, [r11, #-84]	; 0xffffffac
8f61443c:	e50b303c 	str	r3, [r11, #-60]	; 0xffffffc4
				scm_arg.x4 = decrypt_req.frag_len;
8f614440:	e51b3050 	ldr	r3, [r11, #-80]	; 0xffffffb0
8f614444:	e50b3038 	str	r3, [r11, #-56]	; 0xffffffc8
				scm_arg.x5[0] = (uint32_t) decrypt_req.frag;
8f614448:	e51b304c 	ldr	r3, [r11, #-76]	; 0xffffffb4
8f61444c:	e50b3034 	str	r3, [r11, #-52]	; 0xffffffcc

				ret = scm_call2(&scm_arg, &scm_ret);
8f614450:	e24b2064 	sub	r2, r11, #100	; 0x64
8f614454:	e24b3048 	sub	r3, r11, #72	; 0x48
8f614458:	e1a01002 	mov	r1, r2
8f61445c:	e1a00003 	mov	r0, r3
8f614460:	eb00025a 	bl	8f614dd0 <scm_call2>
8f614464:	e1a03000 	mov	r3, r0
8f614468:	e50b3068 	str	r3, [r11, #-104]	; 0xffffff98
				decrypt_rsp.status = scm_ret.x1;
8f61446c:	e51b3064 	ldr	r3, [r11, #-100]	; 0xffffff9c
8f614470:	e50b306c 	str	r3, [r11, #-108]	; 0xffffff94
			}
			if(!ret){
8f614474:	e51b3068 	ldr	r3, [r11, #-104]	; 0xffffff98
8f614478:	e3530000 	cmp	r3, #0
8f61447c:	1a000001 	bne	8f614488 <decrypt_scm_v2+0x198>
				ret = decrypt_rsp.status;
8f614480:	e51b306c 	ldr	r3, [r11, #-108]	; 0xffffff94
8f614484:	e50b3068 	str	r3, [r11, #-104]	; 0xffffff98
			}

			/* Values at img_ptr and img_len_ptr are updated by TZ. Must be invalidated
			* before we use them.
			*/
			arch_invalidate_cache_range((addr_t) img_ptr, sizeof(img_ptr));
8f614488:	e51b3078 	ldr	r3, [r11, #-120]	; 0xffffff88
8f61448c:	e3a01004 	mov	r1, #4
8f614490:	e1a00003 	mov	r0, r3
8f614494:	eb0032cb 	bl	8f620fc8 <arch_invalidate_cache_range>
			arch_invalidate_cache_range((addr_t) img_len_ptr, sizeof(img_len_ptr));
8f614498:	e51b307c 	ldr	r3, [r11, #-124]	; 0xffffff84
8f61449c:	e3a01004 	mov	r1, #4
8f6144a0:	e1a00003 	mov	r0, r3
8f6144a4:	eb0032c7 	bl	8f620fc8 <arch_invalidate_cache_range>

			/* Invalidate the updated image data */
			arch_invalidate_cache_range((addr_t) *img_ptr, *img_len_ptr);
8f6144a8:	e51b3078 	ldr	r3, [r11, #-120]	; 0xffffff88
8f6144ac:	e5933000 	ldr	r3, [r3]
8f6144b0:	e1a02003 	mov	r2, r3
8f6144b4:	e51b307c 	ldr	r3, [r11, #-124]	; 0xffffff84
8f6144b8:	e5933000 	ldr	r3, [r3]
8f6144bc:	e1a01003 	mov	r1, r3
8f6144c0:	e1a00002 	mov	r0, r2
8f6144c4:	eb0032bf 	bl	8f620fc8 <arch_invalidate_cache_range>

			break;
8f6144c8:	ea00000c 	b	8f614500 <decrypt_scm_v2+0x210>

		case SSD_PMD_NOT_ENCRYPTED:
		case SSD_PMD_NO_MD_FOUND:
			ret = 0;
8f6144cc:	e3a03000 	mov	r3, #0
8f6144d0:	e50b3068 	str	r3, [r11, #-104]	; 0xffffff98
			break;
8f6144d4:	ea000009 	b	8f614500 <decrypt_scm_v2+0x210>
		case SSD_PMD_BUSY:
		case SSD_PMD_BAD_MD_PTR_OR_LEN:
		case SSD_PMD_PARSING_INCOMPLETE:
		case SSD_PMD_PARSING_FAILED:
		case SSD_PMD_SETUP_CIPHER_FAILED:
			dprintf(CRITICAL,"decrypt_scm_v2: failed status %d\n",ret);
8f6144d8:	e51b1068 	ldr	r1, [r11, #-104]	; 0xffffff98
8f6144dc:	e304050c 	movw	r0, #17676	; 0x450c
8f6144e0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6144e4:	eb007922 	bl	8f632974 <_dprintf>
			break;
8f6144e8:	ea000004 	b	8f614500 <decrypt_scm_v2+0x210>

		default:
			dprintf(CRITICAL,"decrypt_scm_v2: case default: failed status %d\n",ret);
8f6144ec:	e51b1068 	ldr	r1, [r11, #-104]	; 0xffffff98
8f6144f0:	e3040530 	movw	r0, #17712	; 0x4530
8f6144f4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6144f8:	eb00791d 	bl	8f632974 <_dprintf>
			break;
8f6144fc:	e320f000 	nop	{0}
	}
	return ret;
8f614500:	e51b3068 	ldr	r3, [r11, #-104]	; 0xffffff98
}
8f614504:	e59f2020 	ldr	r2, [pc, #32]	; 8f61452c <decrypt_scm_v2+0x23c>
8f614508:	e5921000 	ldr	r1, [r2]
8f61450c:	e51b2008 	ldr	r2, [r11, #-8]
8f614510:	e0321001 	eors	r1, r2, r1
8f614514:	e3a02000 	mov	r2, #0
8f614518:	0a000000 	beq	8f614520 <decrypt_scm_v2+0x230>
8f61451c:	eb0079a7 	bl	8f632bc0 <__stack_chk_fail>
8f614520:	e1a00003 	mov	r0, r3
8f614524:	e24bd004 	sub	r13, r11, #4
8f614528:	e8bd8800 	pop	{r11, r15}
8f61452c:	8f74221c 	.word	0x8f74221c

8f614530 <scm_svc_version>:

int scm_svc_version(uint32 * major, uint32 * minor)
{
8f614530:	e92d4800 	push	{r11, r14}
8f614534:	e28db004 	add	r11, r13, #4
8f614538:	e24dd070 	sub	r13, r13, #112	; 0x70
8f61453c:	e50b0068 	str	r0, [r11, #-104]	; 0xffffff98
8f614540:	e50b106c 	str	r1, [r11, #-108]	; 0xffffff94
8f614544:	e59f3104 	ldr	r3, [pc, #260]	; 8f614650 <scm_svc_version+0x120>
8f614548:	e5933000 	ldr	r3, [r3]
8f61454c:	e50b3008 	str	r3, [r11, #-8]
8f614550:	e3a03000 	mov	r3, #0
	feature_version_req feature_req;
	feature_version_rsp feature_rsp;
	int                 ret = 0;
8f614554:	e3a03000 	mov	r3, #0
8f614558:	e50b3058 	str	r3, [r11, #-88]	; 0xffffffa8
	scmcall_arg scm_arg = {0};
8f61455c:	e24b3048 	sub	r3, r11, #72	; 0x48
8f614560:	e3a02040 	mov	r2, #64	; 0x40
8f614564:	e3a01000 	mov	r1, #0
8f614568:	e1a00003 	mov	r0, r3
8f61456c:	eb007f54 	bl	8f6342c4 <memset>
	scmcall_ret scm_ret = {0};
8f614570:	e24b3054 	sub	r3, r11, #84	; 0x54
8f614574:	e3a02000 	mov	r2, #0
8f614578:	e5832000 	str	r2, [r3]
8f61457c:	e5832004 	str	r2, [r3, #4]
8f614580:	e5832008 	str	r2, [r3, #8]

	feature_req.feature_id = TZBSP_FVER_SSD;
8f614584:	e3a03005 	mov	r3, #5
8f614588:	e50b3060 	str	r3, [r11, #-96]	; 0xffffffa0

	if (!is_scm_armv8_support())
8f61458c:	ebfffc2b 	bl	8f613640 <is_scm_armv8_support>
8f614590:	e1a03000 	mov	r3, r0
8f614594:	e3530000 	cmp	r3, #0
8f614598:	1a00000a 	bne	8f6145c8 <scm_svc_version+0x98>
	{
		ret = scm_call(TZBSP_SVC_INFO,
8f61459c:	e24b2060 	sub	r2, r11, #96	; 0x60
8f6145a0:	e3a03004 	mov	r3, #4
8f6145a4:	e58d3004 	str	r3, [r13, #4]
8f6145a8:	e24b305c 	sub	r3, r11, #92	; 0x5c
8f6145ac:	e58d3000 	str	r3, [r13]
8f6145b0:	e3a03004 	mov	r3, #4
8f6145b4:	e3a01003 	mov	r1, #3
8f6145b8:	e3a00006 	mov	r0, #6
8f6145bc:	ebfffda9 	bl	8f613c68 <scm_call>
8f6145c0:	e50b0058 	str	r0, [r11, #-88]	; 0xffffffa8
8f6145c4:	ea00000f 	b	8f614608 <scm_svc_version+0xd8>
					   &feature_rsp,
					   sizeof(feature_rsp));
	}
	else
	{
		scm_arg.x0 = MAKE_SIP_SCM_CMD(TZBSP_SVC_INFO, TZ_INFO_GET_FEATURE_ID);
8f6145c8:	e3003603 	movw	r3, #1539	; 0x603
8f6145cc:	e3403200 	movt	r3, #512	; 0x200
8f6145d0:	e50b3048 	str	r3, [r11, #-72]	; 0xffffffb8
		scm_arg.x1 = MAKE_SCM_ARGS(0x1,SMC_PARAM_TYPE_VALUE);
8f6145d4:	e3a03001 	mov	r3, #1
8f6145d8:	e50b3044 	str	r3, [r11, #-68]	; 0xffffffbc
		scm_arg.x2 = feature_req.feature_id;
8f6145dc:	e51b3060 	ldr	r3, [r11, #-96]	; 0xffffffa0
8f6145e0:	e50b3040 	str	r3, [r11, #-64]	; 0xffffffc0

		ret = scm_call2(&scm_arg, &scm_ret);
8f6145e4:	e24b2054 	sub	r2, r11, #84	; 0x54
8f6145e8:	e24b3048 	sub	r3, r11, #72	; 0x48
8f6145ec:	e1a01002 	mov	r1, r2
8f6145f0:	e1a00003 	mov	r0, r3
8f6145f4:	eb0001f5 	bl	8f614dd0 <scm_call2>
8f6145f8:	e1a03000 	mov	r3, r0
8f6145fc:	e50b3058 	str	r3, [r11, #-88]	; 0xffffffa8
		feature_rsp.version = scm_ret.x1;
8f614600:	e51b3054 	ldr	r3, [r11, #-84]	; 0xffffffac
8f614604:	e50b305c 	str	r3, [r11, #-92]	; 0xffffffa4
	}

	if(!ret)
8f614608:	e51b3058 	ldr	r3, [r11, #-88]	; 0xffffffa8
8f61460c:	e3530000 	cmp	r3, #0
8f614610:	1a000003 	bne	8f614624 <scm_svc_version+0xf4>
		*major = TZBSP_GET_FEATURE_VERSION(feature_rsp.version);
8f614614:	e51b305c 	ldr	r3, [r11, #-92]	; 0xffffffa4
8f614618:	e1a02b23 	lsr	r2, r3, #22
8f61461c:	e51b3068 	ldr	r3, [r11, #-104]	; 0xffffff98
8f614620:	e5832000 	str	r2, [r3]

	return ret;
8f614624:	e51b3058 	ldr	r3, [r11, #-88]	; 0xffffffa8
}
8f614628:	e59f2020 	ldr	r2, [pc, #32]	; 8f614650 <scm_svc_version+0x120>
8f61462c:	e5921000 	ldr	r1, [r2]
8f614630:	e51b2008 	ldr	r2, [r11, #-8]
8f614634:	e0321001 	eors	r1, r2, r1
8f614638:	e3a02000 	mov	r2, #0
8f61463c:	0a000000 	beq	8f614644 <scm_svc_version+0x114>
8f614640:	eb00795e 	bl	8f632bc0 <__stack_chk_fail>
8f614644:	e1a00003 	mov	r0, r3
8f614648:	e24bd004 	sub	r13, r11, #4
8f61464c:	e8bd8800 	pop	{r11, r15}
8f614650:	8f74221c 	.word	0x8f74221c

8f614654 <scm_protect_keystore>:

	return ret;
}

int scm_protect_keystore(uint32_t * img_ptr, uint32_t  img_len)
{
8f614654:	e92d4800 	push	{r11, r14}
8f614658:	e28db004 	add	r11, r13, #4
8f61465c:	e24dd070 	sub	r13, r13, #112	; 0x70
8f614660:	e50b0068 	str	r0, [r11, #-104]	; 0xffffff98
8f614664:	e50b106c 	str	r1, [r11, #-108]	; 0xffffff94
8f614668:	e59f315c 	ldr	r3, [pc, #348]	; 8f6147cc <scm_protect_keystore+0x178>
8f61466c:	e5933000 	ldr	r3, [r3]
8f614670:	e50b3008 	str	r3, [r11, #-8]
8f614674:	e3a03000 	mov	r3, #0
	int                      ret=0;
8f614678:	e3a03000 	mov	r3, #0
8f61467c:	e50b3060 	str	r3, [r11, #-96]	; 0xffffffa0
	ssd_protect_keystore_req protect_req;
	ssd_protect_keystore_rsp protect_rsp;
	scmcall_arg scm_arg = {0};
8f614680:	e24b3048 	sub	r3, r11, #72	; 0x48
8f614684:	e3a02040 	mov	r2, #64	; 0x40
8f614688:	e3a01000 	mov	r1, #0
8f61468c:	e1a00003 	mov	r0, r3
8f614690:	eb007f0b 	bl	8f6342c4 <memset>
	scmcall_ret scm_ret = {0};
8f614694:	e24b3054 	sub	r3, r11, #84	; 0x54
8f614698:	e3a02000 	mov	r2, #0
8f61469c:	e5832000 	str	r2, [r3]
8f6146a0:	e5832004 	str	r2, [r3, #4]
8f6146a4:	e5832008 	str	r2, [r3, #8]

	protect_req.keystore_ptr = img_ptr;
8f6146a8:	e51b3068 	ldr	r3, [r11, #-104]	; 0xffffff98
8f6146ac:	e50b305c 	str	r3, [r11, #-92]	; 0xffffffa4
	protect_req.keystore_len = img_len;
8f6146b0:	e51b306c 	ldr	r3, [r11, #-108]	; 0xffffff94
8f6146b4:	e50b3058 	str	r3, [r11, #-88]	; 0xffffffa8

	arch_clean_invalidate_cache_range((addr_t) img_ptr, img_len);
8f6146b8:	e51b3068 	ldr	r3, [r11, #-104]	; 0xffffff98
8f6146bc:	e51b106c 	ldr	r1, [r11, #-108]	; 0xffffff94
8f6146c0:	e1a00003 	mov	r0, r3
8f6146c4:	eb003235 	bl	8f620fa0 <arch_clean_invalidate_cache_range>

	if (!is_scm_armv8_support())
8f6146c8:	ebfffbdc 	bl	8f613640 <is_scm_armv8_support>
8f6146cc:	e1a03000 	mov	r3, r0
8f6146d0:	e3530000 	cmp	r3, #0
8f6146d4:	1a00000a 	bne	8f614704 <scm_protect_keystore+0xb0>
	{
		ret = scm_call(SCM_SVC_SSD,
8f6146d8:	e24b205c 	sub	r2, r11, #92	; 0x5c
8f6146dc:	e3a03004 	mov	r3, #4
8f6146e0:	e58d3004 	str	r3, [r13, #4]
8f6146e4:	e24b3064 	sub	r3, r11, #100	; 0x64
8f6146e8:	e58d3000 	str	r3, [r13]
8f6146ec:	e3a03008 	mov	r3, #8
8f6146f0:	e3a01005 	mov	r1, #5
8f6146f4:	e3a00007 	mov	r0, #7
8f6146f8:	ebfffd5a 	bl	8f613c68 <scm_call>
8f6146fc:	e50b0060 	str	r0, [r11, #-96]	; 0xffffffa0
8f614700:	ea000011 	b	8f61474c <scm_protect_keystore+0xf8>
				&protect_rsp,
				sizeof(protect_rsp));
	}
	else
	{
		scm_arg.x0 = MAKE_SIP_SCM_CMD(SCM_SVC_SSD, SSD_PROTECT_KEYSTORE_ID);
8f614704:	e3003705 	movw	r3, #1797	; 0x705
8f614708:	e3403200 	movt	r3, #512	; 0x200
8f61470c:	e50b3048 	str	r3, [r11, #-72]	; 0xffffffb8
		scm_arg.x1 = MAKE_SCM_ARGS(0x2,SMC_PARAM_TYPE_BUFFER_READWRITE,SMC_PARAM_TYPE_VALUE);
8f614710:	e3a03022 	mov	r3, #34	; 0x22
8f614714:	e50b3044 	str	r3, [r11, #-68]	; 0xffffffbc
		scm_arg.x2 = (uint32_t) protect_req.keystore_ptr;
8f614718:	e51b305c 	ldr	r3, [r11, #-92]	; 0xffffffa4
8f61471c:	e50b3040 	str	r3, [r11, #-64]	; 0xffffffc0
		scm_arg.x3 = protect_req.keystore_len;
8f614720:	e51b3058 	ldr	r3, [r11, #-88]	; 0xffffffa8
8f614724:	e50b303c 	str	r3, [r11, #-60]	; 0xffffffc4

		ret = scm_call2(&scm_arg, &scm_ret);
8f614728:	e24b2054 	sub	r2, r11, #84	; 0x54
8f61472c:	e24b3048 	sub	r3, r11, #72	; 0x48
8f614730:	e1a01002 	mov	r1, r2
8f614734:	e1a00003 	mov	r0, r3
8f614738:	eb0001a4 	bl	8f614dd0 <scm_call2>
8f61473c:	e1a03000 	mov	r3, r0
8f614740:	e50b3060 	str	r3, [r11, #-96]	; 0xffffffa0
		protect_rsp.status = scm_ret.x1;
8f614744:	e51b3054 	ldr	r3, [r11, #-84]	; 0xffffffac
8f614748:	e50b3064 	str	r3, [r11, #-100]	; 0xffffff9c
	}
	if(!ret)
8f61474c:	e51b3060 	ldr	r3, [r11, #-96]	; 0xffffffa0
8f614750:	e3530000 	cmp	r3, #0
8f614754:	1a00000e 	bne	8f614794 <scm_protect_keystore+0x140>
	{
		if(protect_rsp.status == TZBSP_SSD_PKS_SUCCESS)
8f614758:	e51b3064 	ldr	r3, [r11, #-100]	; 0xffffff9c
8f61475c:	e3530000 	cmp	r3, #0
8f614760:	1a000003 	bne	8f614774 <scm_protect_keystore+0x120>
			dprintf(INFO,"Successfully loaded the keystore ");
8f614764:	e3040560 	movw	r0, #17760	; 0x4560
8f614768:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61476c:	eb007880 	bl	8f632974 <_dprintf>
8f614770:	ea00000a 	b	8f6147a0 <scm_protect_keystore+0x14c>
		else
		{
			dprintf(INFO,"Loading keystore failed status %d ",protect_rsp.status);
8f614774:	e51b3064 	ldr	r3, [r11, #-100]	; 0xffffff9c
8f614778:	e1a01003 	mov	r1, r3
8f61477c:	e3040584 	movw	r0, #17796	; 0x4584
8f614780:	e3480f70 	movt	r0, #36720	; 0x8f70
8f614784:	eb00787a 	bl	8f632974 <_dprintf>
			ret = protect_rsp.status;
8f614788:	e51b3064 	ldr	r3, [r11, #-100]	; 0xffffff9c
8f61478c:	e50b3060 	str	r3, [r11, #-96]	; 0xffffffa0
8f614790:	ea000002 	b	8f6147a0 <scm_protect_keystore+0x14c>
		}
	}
	else
	  dprintf(INFO,"scm_call failed ");
8f614794:	e30405a8 	movw	r0, #17832	; 0x45a8
8f614798:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61479c:	eb007874 	bl	8f632974 <_dprintf>

	return ret;
8f6147a0:	e51b3060 	ldr	r3, [r11, #-96]	; 0xffffffa0
}
8f6147a4:	e59f2020 	ldr	r2, [pc, #32]	; 8f6147cc <scm_protect_keystore+0x178>
8f6147a8:	e5921000 	ldr	r1, [r2]
8f6147ac:	e51b2008 	ldr	r2, [r11, #-8]
8f6147b0:	e0321001 	eors	r1, r2, r1
8f6147b4:	e3a02000 	mov	r2, #0
8f6147b8:	0a000000 	beq	8f6147c0 <scm_protect_keystore+0x16c>
8f6147bc:	eb0078ff 	bl	8f632bc0 <__stack_chk_fail>
8f6147c0:	e1a00003 	mov	r0, r3
8f6147c4:	e24bd004 	sub	r13, r11, #4
8f6147c8:	e8bd8800 	pop	{r11, r15}
8f6147cc:	8f74221c 	.word	0x8f74221c

8f6147d0 <set_tamper_fuse_cmd>:

uint32_t set_tamper_fuse_cmd(uint32_t fuse_id)
{
8f6147d0:	e92d4800 	push	{r11, r14}
8f6147d4:	e28db004 	add	r11, r13, #4
8f6147d8:	e24dd010 	sub	r13, r13, #16
8f6147dc:	e50b0010 	str	r0, [r11, #-16]
8f6147e0:	e59f3040 	ldr	r3, [pc, #64]	; 8f614828 <set_tamper_fuse_cmd+0x58>
8f6147e4:	e5933000 	ldr	r3, [r3]
8f6147e8:	e50b3008 	str	r3, [r11, #-8]
8f6147ec:	e3a03000 	mov	r3, #0
#ifdef SAFE_MODE
	dprintf(INFO,"Tried to set tamper fuse");
8f6147f0:	e30405bc 	movw	r0, #17852	; 0x45bc
8f6147f4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6147f8:	eb00785d 	bl	8f632974 <_dprintf>
	return 0;
8f6147fc:	e3a03000 	mov	r3, #0
		ret=scm_call2(&scm_arg, NULL);
	}

	return ret;
#endif
}
8f614800:	e59f2020 	ldr	r2, [pc, #32]	; 8f614828 <set_tamper_fuse_cmd+0x58>
8f614804:	e5921000 	ldr	r1, [r2]
8f614808:	e51b2008 	ldr	r2, [r11, #-8]
8f61480c:	e0321001 	eors	r1, r2, r1
8f614810:	e3a02000 	mov	r2, #0
8f614814:	0a000000 	beq	8f61481c <set_tamper_fuse_cmd+0x4c>
8f614818:	eb0078e8 	bl	8f632bc0 <__stack_chk_fail>
8f61481c:	e1a00003 	mov	r0, r3
8f614820:	e24bd004 	sub	r13, r11, #4
8f614824:	e8bd8800 	pop	{r11, r15}
8f614828:	8f74221c 	.word	0x8f74221c

8f61482c <scm_halt_pmic_arbiter>:
	scm_call(svc_id, cmd_id, cmd_buf, cmd_len, &resp_buf, resp_len);
	return resp_buf;
}

int scm_halt_pmic_arbiter()
{
8f61482c:	e92d4800 	push	{r11, r14}
8f614830:	e28db004 	add	r11, r13, #4
8f614834:	e24dd048 	sub	r13, r13, #72	; 0x48
8f614838:	e59f3124 	ldr	r3, [pc, #292]	; 8f614964 <scm_halt_pmic_arbiter+0x138>
8f61483c:	e5933000 	ldr	r3, [r3]
8f614840:	e50b3008 	str	r3, [r11, #-8]
8f614844:	e3a03000 	mov	r3, #0
	int ret = 0;
8f614848:	e3a03000 	mov	r3, #0
8f61484c:	e50b304c 	str	r3, [r11, #-76]	; 0xffffffb4
	scmcall_arg scm_arg = {0};
8f614850:	e24b3048 	sub	r3, r11, #72	; 0x48
8f614854:	e3a02040 	mov	r2, #64	; 0x40
8f614858:	e3a01000 	mov	r1, #0
8f61485c:	e1a00003 	mov	r0, r3
8f614860:	eb007e97 	bl	8f6342c4 <memset>

	if (is_scm_armv8_support()) {
8f614864:	ebfffb75 	bl	8f613640 <is_scm_armv8_support>
8f614868:	e1a03000 	mov	r3, r0
8f61486c:	e3530000 	cmp	r3, #0
8f614870:	0a00000f 	beq	8f6148b4 <scm_halt_pmic_arbiter+0x88>
		scm_arg.x0 = MAKE_SIP_SCM_CMD(SCM_SVC_PWR, SCM_IO_DISABLE_PMIC_ARBITER);
8f614874:	e3003901 	movw	r3, #2305	; 0x901
8f614878:	e3403200 	movt	r3, #512	; 0x200
8f61487c:	e50b3048 	str	r3, [r11, #-72]	; 0xffffffb8
		scm_arg.x1 = MAKE_SCM_ARGS(0x1);
8f614880:	e3a03001 	mov	r3, #1
8f614884:	e50b3044 	str	r3, [r11, #-68]	; 0xffffffbc
		scm_arg.x2 = 0;
8f614888:	e3a03000 	mov	r3, #0
8f61488c:	e50b3040 	str	r3, [r11, #-64]	; 0xffffffc0
		scm_arg.atomic = true;
8f614890:	e3a03001 	mov	r3, #1
8f614894:	e50b300c 	str	r3, [r11, #-12]
		ret = scm_call2(&scm_arg, NULL);
8f614898:	e24b3048 	sub	r3, r11, #72	; 0x48
8f61489c:	e3a01000 	mov	r1, #0
8f6148a0:	e1a00003 	mov	r0, r3
8f6148a4:	eb000149 	bl	8f614dd0 <scm_call2>
8f6148a8:	e1a03000 	mov	r3, r0
8f6148ac:	e50b304c 	str	r3, [r11, #-76]	; 0xffffffb4
8f6148b0:	ea000004 	b	8f6148c8 <scm_halt_pmic_arbiter+0x9c>
	} else {
		ret = scm_call_atomic(SCM_SVC_PWR, SCM_IO_DISABLE_PMIC_ARBITER, 0);
8f6148b4:	e3a02000 	mov	r2, #0
8f6148b8:	e3a01001 	mov	r1, #1
8f6148bc:	e3a00009 	mov	r0, #9
8f6148c0:	ebfffc9e 	bl	8f613b40 <scm_call_atomic>
8f6148c4:	e50b004c 	str	r0, [r11, #-76]	; 0xffffffb4
	}

	/* Retry with the SCM_IO_DISABLE_PMIC_ARBITER1 func ID if the above Func ID fails*/
	if(ret) {
8f6148c8:	e51b304c 	ldr	r3, [r11, #-76]	; 0xffffffb4
8f6148cc:	e3530000 	cmp	r3, #0
8f6148d0:	0a000018 	beq	8f614938 <scm_halt_pmic_arbiter+0x10c>
		if (is_scm_armv8_support()) {
8f6148d4:	ebfffb59 	bl	8f613640 <is_scm_armv8_support>
8f6148d8:	e1a03000 	mov	r3, r0
8f6148dc:	e3530000 	cmp	r3, #0
8f6148e0:	0a00000f 	beq	8f614924 <scm_halt_pmic_arbiter+0xf8>
			scm_arg.x0 = MAKE_SIP_SCM_CMD(SCM_SVC_PWR, SCM_IO_DISABLE_PMIC_ARBITER1);
8f6148e4:	e3003902 	movw	r3, #2306	; 0x902
8f6148e8:	e3403200 	movt	r3, #512	; 0x200
8f6148ec:	e50b3048 	str	r3, [r11, #-72]	; 0xffffffb8
			scm_arg.x1 = MAKE_SCM_ARGS(0x1);
8f6148f0:	e3a03001 	mov	r3, #1
8f6148f4:	e50b3044 	str	r3, [r11, #-68]	; 0xffffffbc
			scm_arg.x2 = 0;
8f6148f8:	e3a03000 	mov	r3, #0
8f6148fc:	e50b3040 	str	r3, [r11, #-64]	; 0xffffffc0
			scm_arg.atomic = true;
8f614900:	e3a03001 	mov	r3, #1
8f614904:	e50b300c 	str	r3, [r11, #-12]
			ret = scm_call2(&scm_arg, NULL);
8f614908:	e24b3048 	sub	r3, r11, #72	; 0x48
8f61490c:	e3a01000 	mov	r1, #0
8f614910:	e1a00003 	mov	r0, r3
8f614914:	eb00012d 	bl	8f614dd0 <scm_call2>
8f614918:	e1a03000 	mov	r3, r0
8f61491c:	e50b304c 	str	r3, [r11, #-76]	; 0xffffffb4
8f614920:	ea000004 	b	8f614938 <scm_halt_pmic_arbiter+0x10c>
		} else
			ret = scm_call_atomic(SCM_SVC_PWR, SCM_IO_DISABLE_PMIC_ARBITER1, 0);
8f614924:	e3a02000 	mov	r2, #0
8f614928:	e3a01002 	mov	r1, #2
8f61492c:	e3a00009 	mov	r0, #9
8f614930:	ebfffc82 	bl	8f613b40 <scm_call_atomic>
8f614934:	e50b004c 	str	r0, [r11, #-76]	; 0xffffffb4
	}

	return ret;
8f614938:	e51b304c 	ldr	r3, [r11, #-76]	; 0xffffffb4
}
8f61493c:	e59f2020 	ldr	r2, [pc, #32]	; 8f614964 <scm_halt_pmic_arbiter+0x138>
8f614940:	e5921000 	ldr	r1, [r2]
8f614944:	e51b2008 	ldr	r2, [r11, #-8]
8f614948:	e0321001 	eors	r1, r2, r1
8f61494c:	e3a02000 	mov	r2, #0
8f614950:	0a000000 	beq	8f614958 <scm_halt_pmic_arbiter+0x12c>
8f614954:	eb007899 	bl	8f632bc0 <__stack_chk_fail>
8f614958:	e1a00003 	mov	r0, r3
8f61495c:	e24bd004 	sub	r13, r11, #4
8f614960:	e8bd8800 	pop	{r11, r15}
8f614964:	8f74221c 	.word	0x8f74221c

8f614968 <scm_elexec_call>:
 *
 * Assumes all sanity checks have been performed on arguments.
 */

void scm_elexec_call(paddr_t kernel_entry, paddr_t dtb_offset)
{
8f614968:	e92d49f0 	push	{r4, r5, r6, r7, r8, r11, r14}
8f61496c:	e28db018 	add	r11, r13, #24
8f614970:	e24dd06c 	sub	r13, r13, #108	; 0x6c
8f614974:	e1a0800e 	mov	r8, r14
8f614978:	e50b0078 	str	r0, [r11, #-120]	; 0xffffff88
8f61497c:	e50b107c 	str	r1, [r11, #-124]	; 0xffffff84
8f614980:	e59f3158 	ldr	r3, [pc, #344]	; 8f614ae0 <scm_elexec_call+0x178>
8f614984:	e5933000 	ldr	r3, [r3]
8f614988:	e50b3020 	str	r3, [r11, #-32]	; 0xffffffe0
8f61498c:	e3a03000 	mov	r3, #0
	uint32_t svc_id = SCM_SVC_MILESTONE_32_64_ID;
8f614990:	e3a03001 	mov	r3, #1
8f614994:	e50b3070 	str	r3, [r11, #-112]	; 0xffffff90
	uint32_t cmd_id = SCM_SVC_MILESTONE_CMD_ID;
8f614998:	e3a0300f 	mov	r3, #15
8f61499c:	e50b306c 	str	r3, [r11, #-108]	; 0xffffff94
	void *cmd_buf;
	size_t cmd_len;
	static el1_system_param param __attribute__((aligned(0x1000)));
	scmcall_arg scm_arg = {0};
8f6149a0:	e24b3060 	sub	r3, r11, #96	; 0x60
8f6149a4:	e3a02040 	mov	r2, #64	; 0x40
8f6149a8:	e3a01000 	mov	r1, #0
8f6149ac:	e1a00003 	mov	r0, r3
8f6149b0:	eb007e43 	bl	8f6342c4 <memset>

	param.el1_x0 = dtb_offset;
8f6149b4:	e51b307c 	ldr	r3, [r11, #-124]	; 0xffffff84
8f6149b8:	e3a02000 	mov	r2, #0
8f6149bc:	e1a06003 	mov	r6, r3
8f6149c0:	e1a07002 	mov	r7, r2
8f6149c4:	e30d3000 	movw	r3, #53248	; 0xd000
8f6149c8:	e3483f72 	movt	r3, #36722	; 0x8f72
8f6149cc:	e1c360f0 	strd	r6, [r3]
	param.el1_elr = kernel_entry;
8f6149d0:	e51b3078 	ldr	r3, [r11, #-120]	; 0xffffff88
8f6149d4:	e3a02000 	mov	r2, #0
8f6149d8:	e1a04003 	mov	r4, r3
8f6149dc:	e1a05002 	mov	r5, r2
8f6149e0:	e30d3000 	movw	r3, #53248	; 0xd000
8f6149e4:	e3483f72 	movt	r3, #36722	; 0x8f72
8f6149e8:	e1c344f8 	strd	r4, [r3, #72]	; 0x48

	/* Response Buffer = Null as no response expected */
	dprintf(INFO, "Jumping to kernel via monitor\n");
8f6149ec:	e304068c 	movw	r0, #18060	; 0x468c
8f6149f0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6149f4:	eb0077de 	bl	8f632974 <_dprintf>
	pmic_reset_configure(0x1);
8f6149f8:	e3a00001 	mov	r0, #1
8f6149fc:	ebffb1c3 	bl	8f601110 <pmic_reset_configure>

	if (!is_scm_armv8_support())
8f614a00:	ebfffb0e 	bl	8f613640 <is_scm_armv8_support>
8f614a04:	e1a03000 	mov	r3, r0
8f614a08:	e3530000 	cmp	r3, #0
8f614a0c:	1a00000e 	bne	8f614a4c <scm_elexec_call+0xe4>
	{
		/* Command Buffer */
		cmd_buf = (void *)&param;
8f614a10:	e30d3000 	movw	r3, #53248	; 0xd000
8f614a14:	e3483f72 	movt	r3, #36722	; 0x8f72
8f614a18:	e50b3068 	str	r3, [r11, #-104]	; 0xffffff98
		cmd_len = sizeof(el1_system_param);
8f614a1c:	e3a03050 	mov	r3, #80	; 0x50
8f614a20:	e50b3064 	str	r3, [r11, #-100]	; 0xffffff9c

		scm_call(svc_id, cmd_id, cmd_buf, cmd_len, NULL, 0);
8f614a24:	e3a03000 	mov	r3, #0
8f614a28:	e58d3004 	str	r3, [r13, #4]
8f614a2c:	e3a03000 	mov	r3, #0
8f614a30:	e58d3000 	str	r3, [r13]
8f614a34:	e51b3064 	ldr	r3, [r11, #-100]	; 0xffffff9c
8f614a38:	e51b2068 	ldr	r2, [r11, #-104]	; 0xffffff98
8f614a3c:	e51b106c 	ldr	r1, [r11, #-108]	; 0xffffff94
8f614a40:	e51b0070 	ldr	r0, [r11, #-112]	; 0xffffff90
8f614a44:	ebfffc87 	bl	8f613c68 <scm_call>
8f614a48:	ea00000d 	b	8f614a84 <scm_elexec_call+0x11c>
	}
	else
	{
		scm_arg.x0 = MAKE_SIP_SCM_CMD(SCM_SVC_MILESTONE_32_64_ID, SCM_SVC_MILESTONE_CMD_ID);
8f614a4c:	e300310f 	movw	r3, #271	; 0x10f
8f614a50:	e3403200 	movt	r3, #512	; 0x200
8f614a54:	e50b3060 	str	r3, [r11, #-96]	; 0xffffffa0
		scm_arg.x1 = MAKE_SCM_ARGS(0x2, SMC_PARAM_TYPE_BUFFER_READ);
8f614a58:	e3a03012 	mov	r3, #18
8f614a5c:	e50b305c 	str	r3, [r11, #-92]	; 0xffffffa4
		scm_arg.x2 = (uint32_t ) &param;
8f614a60:	e30d3000 	movw	r3, #53248	; 0xd000
8f614a64:	e3483f72 	movt	r3, #36722	; 0x8f72
8f614a68:	e50b3058 	str	r3, [r11, #-88]	; 0xffffffa8
		scm_arg.x3 = sizeof(el1_system_param);
8f614a6c:	e3a03050 	mov	r3, #80	; 0x50
8f614a70:	e50b3054 	str	r3, [r11, #-84]	; 0xffffffac

		scm_call2(&scm_arg, NULL);
8f614a74:	e24b3060 	sub	r3, r11, #96	; 0x60
8f614a78:	e3a01000 	mov	r1, #0
8f614a7c:	e1a00003 	mov	r0, r3
8f614a80:	eb0000d2 	bl	8f614dd0 <scm_call2>
	}

	/* Assert if execution ever reaches here */
	dprintf(CRITICAL, "Failed to jump to kernel\n");
8f614a84:	e30406ac 	movw	r0, #18092	; 0x46ac
8f614a88:	e3480f70 	movt	r0, #36720	; 0x8f70
8f614a8c:	eb0077b8 	bl	8f632974 <_dprintf>
	ASSERT(0);
8f614a90:	e1a00008 	mov	r0, r8
8f614a94:	e30436c8 	movw	r3, #18120	; 0x46c8
8f614a98:	e3483f70 	movt	r3, #36720	; 0x8f70
8f614a9c:	e58d3000 	str	r3, [r13]
8f614aa0:	e3003443 	movw	r3, #1091	; 0x443
8f614aa4:	e30424c4 	movw	r2, #17604	; 0x44c4
8f614aa8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f614aac:	e30414e0 	movw	r1, #17632	; 0x44e0
8f614ab0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f614ab4:	eb007800 	bl	8f632abc <_panic>
}
8f614ab8:	e320f000 	nop	{0}
8f614abc:	e59f301c 	ldr	r3, [pc, #28]	; 8f614ae0 <scm_elexec_call+0x178>
8f614ac0:	e5932000 	ldr	r2, [r3]
8f614ac4:	e51b3020 	ldr	r3, [r11, #-32]	; 0xffffffe0
8f614ac8:	e0332002 	eors	r2, r3, r2
8f614acc:	e3a03000 	mov	r3, #0
8f614ad0:	0a000000 	beq	8f614ad8 <scm_elexec_call+0x170>
8f614ad4:	eb007839 	bl	8f632bc0 <__stack_chk_fail>
8f614ad8:	e24bd018 	sub	r13, r11, #24
8f614adc:	e8bd89f0 	pop	{r4, r5, r6, r7, r8, r11, r15}
8f614ae0:	8f74221c 	.word	0x8f74221c

8f614ae4 <scm_random>:

/* SCM Random Command */
int scm_random(uintptr_t * rbuf, uint32_t  r_len)
{
8f614ae4:	e92d4800 	push	{r11, r14}
8f614ae8:	e28db004 	add	r11, r13, #4
8f614aec:	e24dd060 	sub	r13, r13, #96	; 0x60
8f614af0:	e50b0058 	str	r0, [r11, #-88]	; 0xffffffa8
8f614af4:	e50b105c 	str	r1, [r11, #-92]	; 0xffffffa4
8f614af8:	e59f3180 	ldr	r3, [pc, #384]	; 8f614c80 <scm_random+0x19c>
8f614afc:	e5933000 	ldr	r3, [r3]
8f614b00:	e50b3008 	str	r3, [r11, #-8]
8f614b04:	e3a03000 	mov	r3, #0
	int ret;
	struct tz_prng_data data;
	scmcall_arg scm_arg = {0};
8f614b08:	e24b3048 	sub	r3, r11, #72	; 0x48
8f614b0c:	e3a02040 	mov	r2, #64	; 0x40
8f614b10:	e3a01000 	mov	r1, #0
8f614b14:	e1a00003 	mov	r0, r3
8f614b18:	eb007de9 	bl	8f6342c4 <memset>
	// Memory passed to TZ should be algined to cache line
	BUF_DMA_ALIGN(rand_buf, sizeof(uintptr_t));

	// r_len must be less than or equal to sizeof(rand_buf) to avoid memory corruption.
	if (r_len > sizeof(rand_buf))
8f614b1c:	e51b305c 	ldr	r3, [r11, #-92]	; 0xffffffa4
8f614b20:	e3530040 	cmp	r3, #64	; 0x40
8f614b24:	9a000004 	bls	8f614b3c <scm_random+0x58>
	{
		dprintf(CRITICAL, "r_len is larger than sizeof(randbuf).");
8f614b28:	e30406cc 	movw	r0, #18124	; 0x46cc
8f614b2c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f614b30:	eb00778f 	bl	8f632974 <_dprintf>
		return -1;
8f614b34:	e3e03000 	mvn	r3, #0
8f614b38:	ea000046 	b	8f614c58 <scm_random+0x174>
	}

	if (!is_scm_armv8_support())
8f614b3c:	ebfffabf 	bl	8f613640 <is_scm_armv8_support>
8f614b40:	e1a03000 	mov	r3, r0
8f614b44:	e3530000 	cmp	r3, #0
8f614b48:	1a000019 	bne	8f614bb4 <scm_random+0xd0>
	{
		data.out_buf     = (uint8_t*) rand_buf;
8f614b4c:	e30d3080 	movw	r3, #53376	; 0xd080
8f614b50:	e3483f72 	movt	r3, #36722	; 0x8f72
8f614b54:	e50b3050 	str	r3, [r11, #-80]	; 0xffffffb0
		data.out_buf_size = r_len;
8f614b58:	e51b305c 	ldr	r3, [r11, #-92]	; 0xffffffa4
8f614b5c:	e50b304c 	str	r3, [r11, #-76]	; 0xffffffb4

		/*
		 * random buffer must be flushed/invalidated before and after TZ call.
		 */
		arch_clean_invalidate_cache_range((addr_t) rand_buf, r_len);
8f614b60:	e30d3080 	movw	r3, #53376	; 0xd080
8f614b64:	e3483f72 	movt	r3, #36722	; 0x8f72
8f614b68:	e51b105c 	ldr	r1, [r11, #-92]	; 0xffffffa4
8f614b6c:	e1a00003 	mov	r0, r3
8f614b70:	eb00310a 	bl	8f620fa0 <arch_clean_invalidate_cache_range>

		ret = scm_call(TZ_SVC_CRYPTO, PRNG_CMD_ID, &data, sizeof(data), NULL, 0);
8f614b74:	e24b2050 	sub	r2, r11, #80	; 0x50
8f614b78:	e3a03000 	mov	r3, #0
8f614b7c:	e58d3004 	str	r3, [r13, #4]
8f614b80:	e3a03000 	mov	r3, #0
8f614b84:	e58d3000 	str	r3, [r13]
8f614b88:	e3a03008 	mov	r3, #8
8f614b8c:	e3a01001 	mov	r1, #1
8f614b90:	e3a0000a 	mov	r0, #10
8f614b94:	ebfffc33 	bl	8f613c68 <scm_call>
8f614b98:	e50b0054 	str	r0, [r11, #-84]	; 0xffffffac

		/* Invalidate the updated random buffer */
		arch_clean_invalidate_cache_range((addr_t) rand_buf, r_len);
8f614b9c:	e30d3080 	movw	r3, #53376	; 0xd080
8f614ba0:	e3483f72 	movt	r3, #36722	; 0x8f72
8f614ba4:	e51b105c 	ldr	r1, [r11, #-92]	; 0xffffffa4
8f614ba8:	e1a00003 	mov	r0, r3
8f614bac:	eb0030fb 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
8f614bb0:	ea000021 	b	8f614c3c <scm_random+0x158>
	}
	else
	{
		scm_arg.x0 = MAKE_SIP_SCM_CMD(TZ_SVC_CRYPTO, PRNG_CMD_ID);
8f614bb4:	e3003a01 	movw	r3, #2561	; 0xa01
8f614bb8:	e3403200 	movt	r3, #512	; 0x200
8f614bbc:	e50b3048 	str	r3, [r11, #-72]	; 0xffffffb8
		scm_arg.x1 = MAKE_SCM_ARGS(0x2,SMC_PARAM_TYPE_BUFFER_READWRITE);
8f614bc0:	e3a03022 	mov	r3, #34	; 0x22
8f614bc4:	e50b3044 	str	r3, [r11, #-68]	; 0xffffffbc
		scm_arg.x2 = (uint32_t) rand_buf;
8f614bc8:	e30d3080 	movw	r3, #53376	; 0xd080
8f614bcc:	e3483f72 	movt	r3, #36722	; 0x8f72
8f614bd0:	e50b3040 	str	r3, [r11, #-64]	; 0xffffffc0
		scm_arg.x3 = r_len;
8f614bd4:	e51b305c 	ldr	r3, [r11, #-92]	; 0xffffffa4
8f614bd8:	e50b303c 	str	r3, [r11, #-60]	; 0xffffffc4

		arch_clean_invalidate_cache_range((addr_t) rand_buf, r_len);
8f614bdc:	e30d3080 	movw	r3, #53376	; 0xd080
8f614be0:	e3483f72 	movt	r3, #36722	; 0x8f72
8f614be4:	e51b105c 	ldr	r1, [r11, #-92]	; 0xffffffa4
8f614be8:	e1a00003 	mov	r0, r3
8f614bec:	eb0030eb 	bl	8f620fa0 <arch_clean_invalidate_cache_range>

		ret = scm_call2(&scm_arg, NULL);
8f614bf0:	e24b3048 	sub	r3, r11, #72	; 0x48
8f614bf4:	e3a01000 	mov	r1, #0
8f614bf8:	e1a00003 	mov	r0, r3
8f614bfc:	eb000073 	bl	8f614dd0 <scm_call2>
8f614c00:	e1a03000 	mov	r3, r0
8f614c04:	e50b3054 	str	r3, [r11, #-84]	; 0xffffffac
		if (!ret)
8f614c08:	e51b3054 	ldr	r3, [r11, #-84]	; 0xffffffac
8f614c0c:	e3530000 	cmp	r3, #0
8f614c10:	1a000005 	bne	8f614c2c <scm_random+0x148>
			arch_clean_invalidate_cache_range((addr_t) rand_buf, r_len);
8f614c14:	e30d3080 	movw	r3, #53376	; 0xd080
8f614c18:	e3483f72 	movt	r3, #36722	; 0x8f72
8f614c1c:	e51b105c 	ldr	r1, [r11, #-92]	; 0xffffffa4
8f614c20:	e1a00003 	mov	r0, r3
8f614c24:	eb0030dd 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
8f614c28:	ea000003 	b	8f614c3c <scm_random+0x158>
		else
			dprintf(CRITICAL, "Secure canary SCM failed: %x\n", ret);
8f614c2c:	e51b1054 	ldr	r1, [r11, #-84]	; 0xffffffac
8f614c30:	e30406f4 	movw	r0, #18164	; 0x46f4
8f614c34:	e3480f70 	movt	r0, #36720	; 0x8f70
8f614c38:	eb00774d 	bl	8f632974 <_dprintf>
	}

	//Copy back into the return buffer
	memscpy(rbuf, r_len, rand_buf, sizeof(rand_buf));
8f614c3c:	e3a03040 	mov	r3, #64	; 0x40
8f614c40:	e30d2080 	movw	r2, #53376	; 0xd080
8f614c44:	e3482f72 	movt	r2, #36722	; 0x8f72
8f614c48:	e51b105c 	ldr	r1, [r11, #-92]	; 0xffffffa4
8f614c4c:	e51b0058 	ldr	r0, [r11, #-88]	; 0xffffffa8
8f614c50:	eb007e01 	bl	8f63445c <memscpy>
	return ret;
8f614c54:	e51b3054 	ldr	r3, [r11, #-84]	; 0xffffffac
}
8f614c58:	e59f2020 	ldr	r2, [pc, #32]	; 8f614c80 <scm_random+0x19c>
8f614c5c:	e5921000 	ldr	r1, [r2]
8f614c60:	e51b2008 	ldr	r2, [r11, #-8]
8f614c64:	e0321001 	eors	r1, r2, r1
8f614c68:	e3a02000 	mov	r2, #0
8f614c6c:	0a000000 	beq	8f614c74 <scm_random+0x190>
8f614c70:	eb0077d2 	bl	8f632bc0 <__stack_chk_fail>
8f614c74:	e1a00003 	mov	r0, r3
8f614c78:	e24bd004 	sub	r13, r11, #4
8f614c7c:	e8bd8800 	pop	{r11, r15}
8f614c80:	8f74221c 	.word	0x8f74221c

8f614c84 <get_canary>:

uintptr_t get_canary()
{
8f614c84:	e92d4800 	push	{r11, r14}
8f614c88:	e28db004 	add	r11, r13, #4
8f614c8c:	e24dd008 	sub	r13, r13, #8
8f614c90:	e59f3068 	ldr	r3, [pc, #104]	; 8f614d00 <get_canary+0x7c>
8f614c94:	e5933000 	ldr	r3, [r3]
8f614c98:	e50b3008 	str	r3, [r11, #-8]
8f614c9c:	e3a03000 	mov	r3, #0
	uintptr_t canary;
	if(scm_random(&canary, sizeof(canary))) {
8f614ca0:	e24b300c 	sub	r3, r11, #12
8f614ca4:	e3a01004 	mov	r1, #4
8f614ca8:	e1a00003 	mov	r0, r3
8f614cac:	ebffff8c 	bl	8f614ae4 <scm_random>
8f614cb0:	e1a03000 	mov	r3, r0
8f614cb4:	e3530000 	cmp	r3, #0
8f614cb8:	0a000005 	beq	8f614cd4 <get_canary+0x50>
		dprintf(CRITICAL,"scm_call for random failed !!!");
8f614cbc:	e3040714 	movw	r0, #18196	; 0x4714
8f614cc0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f614cc4:	eb00772a 	bl	8f632974 <_dprintf>
		/*
		* fall back to use lib rand API if scm call failed.
		*/
		canary =  rand();
8f614cc8:	eb007d20 	bl	8f634150 <rand>
8f614ccc:	e1a03000 	mov	r3, r0
8f614cd0:	e50b300c 	str	r3, [r11, #-12]
	}

	return canary;
8f614cd4:	e51b300c 	ldr	r3, [r11, #-12]
}
8f614cd8:	e59f2020 	ldr	r2, [pc, #32]	; 8f614d00 <get_canary+0x7c>
8f614cdc:	e5921000 	ldr	r1, [r2]
8f614ce0:	e51b2008 	ldr	r2, [r11, #-8]
8f614ce4:	e0321001 	eors	r1, r2, r1
8f614ce8:	e3a02000 	mov	r2, #0
8f614cec:	0a000000 	beq	8f614cf4 <get_canary+0x70>
8f614cf0:	eb0077b2 	bl	8f632bc0 <__stack_chk_fail>
8f614cf4:	e1a00003 	mov	r0, r3
8f614cf8:	e24bd004 	sub	r13, r11, #4
8f614cfc:	e8bd8800 	pop	{r11, r15}
8f614d00:	8f74221c 	.word	0x8f74221c

8f614d04 <scm_call_a32>:

	return ret;
}

static uint32_t scm_call_a32(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3, uint32_t x4, uint32_t x5, scmcall_ret *ret)
{
8f614d04:	e92d4870 	push	{r4, r5, r6, r11, r14}
8f614d08:	e28db010 	add	r11, r13, #16
8f614d0c:	e24dd02c 	sub	r13, r13, #44	; 0x2c
8f614d10:	e50b0020 	str	r0, [r11, #-32]	; 0xffffffe0
8f614d14:	e50b1024 	str	r1, [r11, #-36]	; 0xffffffdc
8f614d18:	e50b2028 	str	r2, [r11, #-40]	; 0xffffffd8
8f614d1c:	e50b302c 	str	r3, [r11, #-44]	; 0xffffffd4
8f614d20:	e59b3004 	ldr	r3, [r11, #4]
8f614d24:	e50b3030 	str	r3, [r11, #-48]	; 0xffffffd0
8f614d28:	e59b3008 	ldr	r3, [r11, #8]
8f614d2c:	e50b3034 	str	r3, [r11, #-52]	; 0xffffffcc
8f614d30:	e59b300c 	ldr	r3, [r11, #12]
8f614d34:	e50b3038 	str	r3, [r11, #-56]	; 0xffffffc8
8f614d38:	e59f308c 	ldr	r3, [pc, #140]	; 8f614dcc <scm_call_a32+0xc8>
8f614d3c:	e5933000 	ldr	r3, [r3]
8f614d40:	e50b3018 	str	r3, [r11, #-24]	; 0xffffffe8
8f614d44:	e3a03000 	mov	r3, #0
	register uint32_t r0 __asm__("r0") = x0;
8f614d48:	e51b0020 	ldr	r0, [r11, #-32]	; 0xffffffe0
	register uint32_t r1 __asm__("r1") = x1;
8f614d4c:	e51b1024 	ldr	r1, [r11, #-36]	; 0xffffffdc
	register uint32_t r2 __asm__("r2") = x2;
8f614d50:	e51b2028 	ldr	r2, [r11, #-40]	; 0xffffffd8
	register uint32_t r3 __asm__("r3") = x3;
8f614d54:	e51b302c 	ldr	r3, [r11, #-44]	; 0xffffffd4
	register uint32_t r4 __asm__("r4") = x4;
8f614d58:	e51b4030 	ldr	r4, [r11, #-48]	; 0xffffffd0
	register uint32_t r5 __asm__("r5") = x5;
8f614d5c:	e51b5034 	ldr	r5, [r11, #-52]	; 0xffffffcc
	register uint32_t r6 __asm__("r6") = 0;
8f614d60:	e3a06000 	mov	r6, #0

	do {
		__asm__ volatile(
8f614d64:	e1600070 	smc	0
			__asmeq("%9", "r5")
			__asmeq("%10", "r6")
			"smc    #0  @ switch to secure world\n"
			: "=r" (r0), "=r" (r1), "=r" (r2), "=r" (r3)
			: "r" (r0), "r" (r1), "r" (r2), "r" (r3), "r" (r4), "r" (r5), "r" (r6));
	} while(r0 == 1);
8f614d68:	e3500001 	cmp	r0, #1
8f614d6c:	0afffffc 	beq	8f614d64 <scm_call_a32+0x60>

	if (ret)
8f614d70:	e51bc038 	ldr	r12, [r11, #-56]	; 0xffffffc8
8f614d74:	e35c0000 	cmp	r12, #0
8f614d78:	0a000008 	beq	8f614da0 <scm_call_a32+0x9c>
	{
		ret->x1 = r1;
8f614d7c:	e1a0c001 	mov	r12, r1
8f614d80:	e51b1038 	ldr	r1, [r11, #-56]	; 0xffffffc8
8f614d84:	e581c000 	str	r12, [r1]
		ret->x2 = r2;
8f614d88:	e1a01002 	mov	r1, r2
8f614d8c:	e51b2038 	ldr	r2, [r11, #-56]	; 0xffffffc8
8f614d90:	e5821004 	str	r1, [r2, #4]
		ret->x3 = r3;
8f614d94:	e1a02003 	mov	r2, r3
8f614d98:	e51b3038 	ldr	r3, [r11, #-56]	; 0xffffffc8
8f614d9c:	e5832008 	str	r2, [r3, #8]
	}

	return r0;
8f614da0:	e1a03000 	mov	r3, r0
}
8f614da4:	e59f2020 	ldr	r2, [pc, #32]	; 8f614dcc <scm_call_a32+0xc8>
8f614da8:	e5921000 	ldr	r1, [r2]
8f614dac:	e51b2018 	ldr	r2, [r11, #-24]	; 0xffffffe8
8f614db0:	e0321001 	eors	r1, r2, r1
8f614db4:	e3a02000 	mov	r2, #0
8f614db8:	0a000000 	beq	8f614dc0 <scm_call_a32+0xbc>
8f614dbc:	eb00777f 	bl	8f632bc0 <__stack_chk_fail>
8f614dc0:	e1a00003 	mov	r0, r3
8f614dc4:	e24bd010 	sub	r13, r11, #16
8f614dc8:	e8bd8870 	pop	{r4, r5, r6, r11, r15}
8f614dcc:	8f74221c 	.word	0x8f74221c

8f614dd0 <scm_call2>:

uint32_t scm_call2(scmcall_arg *arg, scmcall_ret *ret)
{
8f614dd0:	e92d4810 	push	{r4, r11, r14}
8f614dd4:	e28db008 	add	r11, r13, #8
8f614dd8:	e24dd034 	sub	r13, r13, #52	; 0x34
8f614ddc:	e1a0400e 	mov	r4, r14
8f614de0:	e50b0028 	str	r0, [r11, #-40]	; 0xffffffd8
8f614de4:	e50b102c 	str	r1, [r11, #-44]	; 0xffffffd4
8f614de8:	e59f31dc 	ldr	r3, [pc, #476]	; 8f614fcc <scm_call2+0x1fc>
8f614dec:	e5933000 	ldr	r3, [r3]
8f614df0:	e50b3010 	str	r3, [r11, #-16]
8f614df4:	e3a03000 	mov	r3, #0
	uint32_t *indir_arg = NULL;
8f614df8:	e3a03000 	mov	r3, #0
8f614dfc:	e50b3020 	str	r3, [r11, #-32]	; 0xffffffe0
	uint32_t x5;
	int i;
	uint32_t rc;

	arg->x0 = arg->atomic ? (arg->x0 | SCM_ATOMIC_BIT) : arg->x0;
8f614e00:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f614e04:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
8f614e08:	e3530000 	cmp	r3, #0
8f614e0c:	0a000003 	beq	8f614e20 <scm_call2+0x50>
8f614e10:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f614e14:	e5933000 	ldr	r3, [r3]
8f614e18:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
8f614e1c:	ea000001 	b	8f614e28 <scm_call2+0x58>
8f614e20:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f614e24:	e5933000 	ldr	r3, [r3]
8f614e28:	e51b2028 	ldr	r2, [r11, #-40]	; 0xffffffd8
8f614e2c:	e5823000 	str	r3, [r2]
	x5 = arg->x5[0];
8f614e30:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f614e34:	e5933014 	ldr	r3, [r3, #20]
8f614e38:	e50b301c 	str	r3, [r11, #-28]	; 0xffffffe4

	if ((arg->x1 & 0xF) > SCM_MAX_ARG_LEN - 1)
8f614e3c:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f614e40:	e5933004 	ldr	r3, [r3, #4]
8f614e44:	e203300f 	and	r3, r3, #15
8f614e48:	e3530004 	cmp	r3, #4
8f614e4c:	9a00002f 	bls	8f614f10 <scm_call2+0x140>
	{
		indir_arg = memalign(CACHE_LINE, ROUNDUP((SCM_INDIR_MAX_LEN * sizeof(uint32_t)), CACHE_LINE));
8f614e50:	e3a01040 	mov	r1, #64	; 0x40
8f614e54:	e3a00040 	mov	r0, #64	; 0x40
8f614e58:	eb007c79 	bl	8f634044 <memalign>
8f614e5c:	e1a03000 	mov	r3, r0
8f614e60:	e50b3020 	str	r3, [r11, #-32]	; 0xffffffe0
		ASSERT(indir_arg);
8f614e64:	e51b3020 	ldr	r3, [r11, #-32]	; 0xffffffe0
8f614e68:	e3530000 	cmp	r3, #0
8f614e6c:	03a03001 	moveq	r3, #1
8f614e70:	13a03000 	movne	r3, #0
8f614e74:	e6ef3073 	uxtb	r3, r3
8f614e78:	e3530000 	cmp	r3, #0
8f614e7c:	0a000009 	beq	8f614ea8 <scm_call2+0xd8>
8f614e80:	e1a00004 	mov	r0, r4
8f614e84:	e3043798 	movw	r3, #18328	; 0x4798
8f614e88:	e3483f70 	movt	r3, #36720	; 0x8f70
8f614e8c:	e58d3000 	str	r3, [r13]
8f614e90:	e30034dd 	movw	r3, #1245	; 0x4dd
8f614e94:	e30424c4 	movw	r2, #17604	; 0x44c4
8f614e98:	e3482f70 	movt	r2, #36720	; 0x8f70
8f614e9c:	e30414e0 	movw	r1, #17632	; 0x44e0
8f614ea0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f614ea4:	eb007704 	bl	8f632abc <_panic>

		for (i = 0 ; i < SCM_INDIR_MAX_LEN; i++)
8f614ea8:	e3a03000 	mov	r3, #0
8f614eac:	e50b3018 	str	r3, [r11, #-24]	; 0xffffffe8
8f614eb0:	ea00000d 	b	8f614eec <scm_call2+0x11c>
		{
			indir_arg[i] = arg->x5[i];
8f614eb4:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f614eb8:	e1a03103 	lsl	r3, r3, #2
8f614ebc:	e51b2020 	ldr	r2, [r11, #-32]	; 0xffffffe0
8f614ec0:	e0822003 	add	r2, r2, r3
8f614ec4:	e51b1028 	ldr	r1, [r11, #-40]	; 0xffffffd8
8f614ec8:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f614ecc:	e2833004 	add	r3, r3, #4
8f614ed0:	e1a03103 	lsl	r3, r3, #2
8f614ed4:	e0813003 	add	r3, r1, r3
8f614ed8:	e5933004 	ldr	r3, [r3, #4]
8f614edc:	e5823000 	str	r3, [r2]
		for (i = 0 ; i < SCM_INDIR_MAX_LEN; i++)
8f614ee0:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f614ee4:	e2833001 	add	r3, r3, #1
8f614ee8:	e50b3018 	str	r3, [r11, #-24]	; 0xffffffe8
8f614eec:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f614ef0:	e3530009 	cmp	r3, #9
8f614ef4:	daffffee 	ble	8f614eb4 <scm_call2+0xe4>
		}
		arch_clean_invalidate_cache_range((addr_t) indir_arg, ROUNDUP((SCM_INDIR_MAX_LEN * sizeof(uint32_t)), CACHE_LINE));
8f614ef8:	e51b3020 	ldr	r3, [r11, #-32]	; 0xffffffe0
8f614efc:	e3a01040 	mov	r1, #64	; 0x40
8f614f00:	e1a00003 	mov	r0, r3
8f614f04:	eb003025 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
		x5 = (addr_t) indir_arg;
8f614f08:	e51b3020 	ldr	r3, [r11, #-32]	; 0xffffffe0
8f614f0c:	e50b301c 	str	r3, [r11, #-28]	; 0xffffffe4
	}

	rc = scm_call_a32(arg->x0, arg->x1, arg->x2, arg->x3, arg->x4, x5, ret);
8f614f10:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f614f14:	e5930000 	ldr	r0, [r3]
8f614f18:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f614f1c:	e5931004 	ldr	r1, [r3, #4]
8f614f20:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f614f24:	e593c008 	ldr	r12, [r3, #8]
8f614f28:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f614f2c:	e593e00c 	ldr	r14, [r3, #12]
8f614f30:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f614f34:	e5933010 	ldr	r3, [r3, #16]
8f614f38:	e51b202c 	ldr	r2, [r11, #-44]	; 0xffffffd4
8f614f3c:	e58d2008 	str	r2, [r13, #8]
8f614f40:	e51b201c 	ldr	r2, [r11, #-28]	; 0xffffffe4
8f614f44:	e58d2004 	str	r2, [r13, #4]
8f614f48:	e58d3000 	str	r3, [r13]
8f614f4c:	e1a0300e 	mov	r3, r14
8f614f50:	e1a0200c 	mov	r2, r12
8f614f54:	ebffff6a 	bl	8f614d04 <scm_call_a32>
8f614f58:	e50b0014 	str	r0, [r11, #-20]	; 0xffffffec

	if (rc)
8f614f5c:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
8f614f60:	e3530000 	cmp	r3, #0
8f614f64:	0a000008 	beq	8f614f8c <scm_call2+0x1bc>
	{
		dprintf(CRITICAL, "SCM call: 0x%x failed with :%x\n", arg->x0, rc);
8f614f68:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f614f6c:	e5933000 	ldr	r3, [r3]
8f614f70:	e51b2014 	ldr	r2, [r11, #-20]	; 0xffffffec
8f614f74:	e1a01003 	mov	r1, r3
8f614f78:	e30407a4 	movw	r0, #18340	; 0x47a4
8f614f7c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f614f80:	eb00767b 	bl	8f632974 <_dprintf>
		return rc;
8f614f84:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
8f614f88:	ea000005 	b	8f614fa4 <scm_call2+0x1d4>
	}

	if (indir_arg)
8f614f8c:	e51b3020 	ldr	r3, [r11, #-32]	; 0xffffffe0
8f614f90:	e3530000 	cmp	r3, #0
8f614f94:	0a000001 	beq	8f614fa0 <scm_call2+0x1d0>
		free(indir_arg);
8f614f98:	e51b0020 	ldr	r0, [r11, #-32]	; 0xffffffe0
8f614f9c:	eb007c5a 	bl	8f63410c <free>

	return 0;
8f614fa0:	e3a03000 	mov	r3, #0
}
8f614fa4:	e59f2020 	ldr	r2, [pc, #32]	; 8f614fcc <scm_call2+0x1fc>
8f614fa8:	e5921000 	ldr	r1, [r2]
8f614fac:	e51b2010 	ldr	r2, [r11, #-16]
8f614fb0:	e0321001 	eors	r1, r2, r1
8f614fb4:	e3a02000 	mov	r2, #0
8f614fb8:	0a000000 	beq	8f614fc0 <scm_call2+0x1f0>
8f614fbc:	eb0076ff 	bl	8f632bc0 <__stack_chk_fail>
8f614fc0:	e1a00003 	mov	r0, r3
8f614fc4:	e24bd008 	sub	r13, r11, #8
8f614fc8:	e8bd8810 	pop	{r4, r11, r15}
8f614fcc:	8f74221c 	.word	0x8f74221c

8f614fd0 <scm_check_boot_fuses>:

static bool secure_boot_enabled = false;
static bool wdog_debug_fuse_disabled = true;

void scm_check_boot_fuses()
{
8f614fd0:	e92d4810 	push	{r4, r11, r14}
8f614fd4:	e28db008 	add	r11, r13, #8
8f614fd8:	e24dd064 	sub	r13, r13, #100	; 0x64
8f614fdc:	e1a0400e 	mov	r4, r14
8f614fe0:	e59f3210 	ldr	r3, [pc, #528]	; 8f6151f8 <scm_check_boot_fuses+0x228>
8f614fe4:	e5933000 	ldr	r3, [r3]
8f614fe8:	e50b3010 	str	r3, [r11, #-16]
8f614fec:	e3a03000 	mov	r3, #0
	uint32_t ret = 0;
8f614ff0:	e3a03000 	mov	r3, #0
8f614ff4:	e50b3064 	str	r3, [r11, #-100]	; 0xffffff9c
	uint32_t *resp = NULL;
8f614ff8:	e3a03000 	mov	r3, #0
8f614ffc:	e50b3060 	str	r3, [r11, #-96]	; 0xffffffa0
	scmcall_arg scm_arg = {0};
8f615000:	e24b3050 	sub	r3, r11, #80	; 0x50
8f615004:	e3a02040 	mov	r2, #64	; 0x40
8f615008:	e3a01000 	mov	r1, #0
8f61500c:	e1a00003 	mov	r0, r3
8f615010:	eb007cab 	bl	8f6342c4 <memset>
	scmcall_ret scm_ret = {0};
8f615014:	e24b305c 	sub	r3, r11, #92	; 0x5c
8f615018:	e3a02000 	mov	r2, #0
8f61501c:	e5832000 	str	r2, [r3]
8f615020:	e5832004 	str	r2, [r3, #4]
8f615024:	e5832008 	str	r2, [r3, #8]

	resp = memalign(CACHE_LINE, (2 * sizeof(uint32_t)));
8f615028:	e3a01008 	mov	r1, #8
8f61502c:	e3a00040 	mov	r0, #64	; 0x40
8f615030:	eb007c03 	bl	8f634044 <memalign>
8f615034:	e1a03000 	mov	r3, r0
8f615038:	e50b3060 	str	r3, [r11, #-96]	; 0xffffffa0
	ASSERT(resp);
8f61503c:	e51b3060 	ldr	r3, [r11, #-96]	; 0xffffffa0
8f615040:	e3530000 	cmp	r3, #0
8f615044:	03a03001 	moveq	r3, #1
8f615048:	13a03000 	movne	r3, #0
8f61504c:	e6ef3073 	uxtb	r3, r3
8f615050:	e3530000 	cmp	r3, #0
8f615054:	0a000009 	beq	8f615080 <scm_check_boot_fuses+0xb0>
8f615058:	e1a00004 	mov	r0, r4
8f61505c:	e30437c4 	movw	r3, #18372	; 0x47c4
8f615060:	e3483f70 	movt	r3, #36720	; 0x8f70
8f615064:	e58d3000 	str	r3, [r13]
8f615068:	e3a03c05 	mov	r3, #1280	; 0x500
8f61506c:	e30424c4 	movw	r2, #17604	; 0x44c4
8f615070:	e3482f70 	movt	r2, #36720	; 0x8f70
8f615074:	e30414e0 	movw	r1, #17632	; 0x44e0
8f615078:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61507c:	eb00768e 	bl	8f632abc <_panic>
	if (!is_scm_armv8_support()) {
8f615080:	ebfff96e 	bl	8f613640 <is_scm_armv8_support>
8f615084:	e1a03000 	mov	r3, r0
8f615088:	e3530000 	cmp	r3, #0
8f61508c:	1a00000b 	bne	8f6150c0 <scm_check_boot_fuses+0xf0>
		ret = scm_call_atomic2(TZBSP_SVC_INFO, IS_SECURE_BOOT_ENABLED, (uint32_t)resp, 2 * sizeof(uint32_t));
8f615090:	e51b2060 	ldr	r2, [r11, #-96]	; 0xffffffa0
8f615094:	e3a03008 	mov	r3, #8
8f615098:	e3a01004 	mov	r1, #4
8f61509c:	e3a00006 	mov	r0, #6
8f6150a0:	ebfffaca 	bl	8f613bd0 <scm_call_atomic2>
8f6150a4:	e1a03000 	mov	r3, r0
8f6150a8:	e50b3064 	str	r3, [r11, #-100]	; 0xffffff9c
		arch_clean_invalidate_cache_range((addr_t)resp, ROUNDUP((2*sizeof(uint32_t)), CACHE_LINE));
8f6150ac:	e51b3060 	ldr	r3, [r11, #-96]	; 0xffffffa0
8f6150b0:	e3a01040 	mov	r1, #64	; 0x40
8f6150b4:	e1a00003 	mov	r0, r3
8f6150b8:	eb002fb8 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
8f6150bc:	ea00000b 	b	8f6150f0 <scm_check_boot_fuses+0x120>
	} else {
		scm_arg.x0 = MAKE_SIP_SCM_CMD(TZBSP_SVC_INFO, IS_SECURE_BOOT_ENABLED);
8f6150c0:	e3003604 	movw	r3, #1540	; 0x604
8f6150c4:	e3403200 	movt	r3, #512	; 0x200
8f6150c8:	e50b3050 	str	r3, [r11, #-80]	; 0xffffffb0
		ret = scm_call2(&scm_arg, &scm_ret);
8f6150cc:	e24b205c 	sub	r2, r11, #92	; 0x5c
8f6150d0:	e24b3050 	sub	r3, r11, #80	; 0x50
8f6150d4:	e1a01002 	mov	r1, r2
8f6150d8:	e1a00003 	mov	r0, r3
8f6150dc:	ebffff3b 	bl	8f614dd0 <scm_call2>
8f6150e0:	e50b0064 	str	r0, [r11, #-100]	; 0xffffff9c
		resp[0] = scm_ret.x1;
8f6150e4:	e51b205c 	ldr	r2, [r11, #-92]	; 0xffffffa4
8f6150e8:	e51b3060 	ldr	r3, [r11, #-96]	; 0xffffffa0
8f6150ec:	e5832000 	str	r2, [r3]
	}

	if (!ret) {
8f6150f0:	e51b3064 	ldr	r3, [r11, #-100]	; 0xffffff9c
8f6150f4:	e3530000 	cmp	r3, #0
8f6150f8:	1a00002f 	bne	8f6151bc <scm_check_boot_fuses+0x1ec>
		/* Check for secure device: Bit#0 = 0, Bit#1 = 0 Bit#2 = 0 , Bit#5 = 0 */
		/* Check Bit#6 = 1 only for TZ.BF.4.0 */
        	if (!CHECK_BIT(resp[0], SECBOOT_FUSE_BIT) && !CHECK_BIT(resp[0], SECBOOT_FUSE_SHK_BIT) &&
8f6150fc:	e51b3060 	ldr	r3, [r11, #-96]	; 0xffffffa0
8f615100:	e5933000 	ldr	r3, [r3]
8f615104:	e2033001 	and	r3, r3, #1
8f615108:	e3530000 	cmp	r3, #0
8f61510c:	1a000020 	bne	8f615194 <scm_check_boot_fuses+0x1c4>
8f615110:	e51b3060 	ldr	r3, [r11, #-96]	; 0xffffffa0
8f615114:	e5933000 	ldr	r3, [r3]
8f615118:	e2033002 	and	r3, r3, #2
8f61511c:	e3530000 	cmp	r3, #0
8f615120:	1a00001b 	bne	8f615194 <scm_check_boot_fuses+0x1c4>
        		!CHECK_BIT(resp[0], SECBOOT_FUSE_DEBUG_DISABLED_BIT) &&
8f615124:	e51b3060 	ldr	r3, [r11, #-96]	; 0xffffffa0
8f615128:	e5933000 	ldr	r3, [r3]
8f61512c:	e2033004 	and	r3, r3, #4
        	if (!CHECK_BIT(resp[0], SECBOOT_FUSE_BIT) && !CHECK_BIT(resp[0], SECBOOT_FUSE_SHK_BIT) &&
8f615130:	e3530000 	cmp	r3, #0
8f615134:	1a000016 	bne	8f615194 <scm_check_boot_fuses+0x1c4>
                        !CHECK_BIT(resp[0], SECBOOT_FUSE_RPMB_ENABLED_BIT)) {
8f615138:	e51b3060 	ldr	r3, [r11, #-96]	; 0xffffffa0
8f61513c:	e5933000 	ldr	r3, [r3]
8f615140:	e2033020 	and	r3, r3, #32
        		!CHECK_BIT(resp[0], SECBOOT_FUSE_DEBUG_DISABLED_BIT) &&
8f615144:	e3530000 	cmp	r3, #0
8f615148:	1a000011 	bne	8f615194 <scm_check_boot_fuses+0x1c4>
                        if ((qseecom_get_version() < QSEE_VERSION_40))
8f61514c:	eb0007c8 	bl	8f617074 <qseecom_get_version>
8f615150:	e1a03000 	mov	r3, r0
8f615154:	e3530401 	cmp	r3, #16777216	; 0x1000000
8f615158:	2a000004 	bcs	8f615170 <scm_check_boot_fuses+0x1a0>
	                        secure_boot_enabled = true;
8f61515c:	e30d30c0 	movw	r3, #53440	; 0xd0c0
8f615160:	e3483f72 	movt	r3, #36722	; 0x8f72
8f615164:	e3a02001 	mov	r2, #1
8f615168:	e5832000 	str	r2, [r3]
8f61516c:	ea000008 	b	8f615194 <scm_check_boot_fuses+0x1c4>
                        else if (CHECK_BIT(resp[0], SECBOOT_FUSE_DEBUG_RE_ENABLED_BIT))
8f615170:	e51b3060 	ldr	r3, [r11, #-96]	; 0xffffffa0
8f615174:	e5933000 	ldr	r3, [r3]
8f615178:	e2033040 	and	r3, r3, #64	; 0x40
8f61517c:	e3530000 	cmp	r3, #0
8f615180:	0a000003 	beq	8f615194 <scm_check_boot_fuses+0x1c4>
	                        secure_boot_enabled = true;
8f615184:	e30d30c0 	movw	r3, #53440	; 0xd0c0
8f615188:	e3483f72 	movt	r3, #36722	; 0x8f72
8f61518c:	e3a02001 	mov	r2, #1
8f615190:	e5832000 	str	r2, [r3]
        	}
		/* Bit 2 - DEBUG_DISABLE_CHECK */
		if (CHECK_BIT(resp[0], SECBOOT_FUSE_DEBUG_DISABLED_BIT))
8f615194:	e51b3060 	ldr	r3, [r11, #-96]	; 0xffffffa0
8f615198:	e5933000 	ldr	r3, [r3]
8f61519c:	e2033004 	and	r3, r3, #4
8f6151a0:	e3530000 	cmp	r3, #0
8f6151a4:	0a000007 	beq	8f6151c8 <scm_check_boot_fuses+0x1f8>
			wdog_debug_fuse_disabled = false;
8f6151a8:	e3013380 	movw	r3, #4992	; 0x1380
8f6151ac:	e3483f71 	movt	r3, #36721	; 0x8f71
8f6151b0:	e3a02000 	mov	r2, #0
8f6151b4:	e5832000 	str	r2, [r3]
8f6151b8:	ea000002 	b	8f6151c8 <scm_check_boot_fuses+0x1f8>
	} else
		dprintf(CRITICAL, "scm call to check secure boot fuses failed\n");
8f6151bc:	e30407cc 	movw	r0, #18380	; 0x47cc
8f6151c0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6151c4:	eb0075ea 	bl	8f632974 <_dprintf>
	free(resp);
8f6151c8:	e51b0060 	ldr	r0, [r11, #-96]	; 0xffffffa0
8f6151cc:	eb007bce 	bl	8f63410c <free>
}
8f6151d0:	e320f000 	nop	{0}
8f6151d4:	e59f301c 	ldr	r3, [pc, #28]	; 8f6151f8 <scm_check_boot_fuses+0x228>
8f6151d8:	e5932000 	ldr	r2, [r3]
8f6151dc:	e51b3010 	ldr	r3, [r11, #-16]
8f6151e0:	e0332002 	eors	r2, r3, r2
8f6151e4:	e3a03000 	mov	r3, #0
8f6151e8:	0a000000 	beq	8f6151f0 <scm_check_boot_fuses+0x220>
8f6151ec:	eb007673 	bl	8f632bc0 <__stack_chk_fail>
8f6151f0:	e24bd008 	sub	r13, r11, #8
8f6151f4:	e8bd8810 	pop	{r4, r11, r15}
8f6151f8:	8f74221c 	.word	0x8f74221c

8f6151fc <is_secure_boot_enable>:

bool is_secure_boot_enable()
{
8f6151fc:	e92d4800 	push	{r11, r14}
8f615200:	e28db004 	add	r11, r13, #4
8f615204:	e24dd008 	sub	r13, r13, #8
8f615208:	e59f3040 	ldr	r3, [pc, #64]	; 8f615250 <is_secure_boot_enable+0x54>
8f61520c:	e5933000 	ldr	r3, [r3]
8f615210:	e50b3008 	str	r3, [r11, #-8]
8f615214:	e3a03000 	mov	r3, #0
	scm_check_boot_fuses();
8f615218:	ebffff6c 	bl	8f614fd0 <scm_check_boot_fuses>
	return secure_boot_enabled;
8f61521c:	e30d30c0 	movw	r3, #53440	; 0xd0c0
8f615220:	e3483f72 	movt	r3, #36722	; 0x8f72
8f615224:	e5933000 	ldr	r3, [r3]
}
8f615228:	e59f2020 	ldr	r2, [pc, #32]	; 8f615250 <is_secure_boot_enable+0x54>
8f61522c:	e5921000 	ldr	r1, [r2]
8f615230:	e51b2008 	ldr	r2, [r11, #-8]
8f615234:	e0321001 	eors	r1, r2, r1
8f615238:	e3a02000 	mov	r2, #0
8f61523c:	0a000000 	beq	8f615244 <is_secure_boot_enable+0x48>
8f615240:	eb00765e 	bl	8f632bc0 <__stack_chk_fail>
8f615244:	e1a00003 	mov	r0, r3
8f615248:	e24bd004 	sub	r13, r11, #4
8f61524c:	e8bd8800 	pop	{r11, r15}
8f615250:	8f74221c 	.word	0x8f74221c

8f615254 <scm_io_write>:
	}
	return ret;
}

uint32_t scm_io_write(uint32_t address, uint32_t val)
{
8f615254:	e92d4800 	push	{r11, r14}
8f615258:	e28db004 	add	r11, r13, #4
8f61525c:	e24dd060 	sub	r13, r13, #96	; 0x60
8f615260:	e50b0060 	str	r0, [r11, #-96]	; 0xffffffa0
8f615264:	e50b1064 	str	r1, [r11, #-100]	; 0xffffff9c
8f615268:	e59f30d0 	ldr	r3, [pc, #208]	; 8f615340 <scm_io_write+0xec>
8f61526c:	e5933000 	ldr	r3, [r3]
8f615270:	e50b3008 	str	r3, [r11, #-8]
8f615274:	e3a03000 	mov	r3, #0
	uint32_t ret;
	scmcall_arg scm_arg = {0};
8f615278:	e24b3048 	sub	r3, r11, #72	; 0x48
8f61527c:	e3a02040 	mov	r2, #64	; 0x40
8f615280:	e3a01000 	mov	r1, #0
8f615284:	e1a00003 	mov	r0, r3
8f615288:	eb007c0d 	bl	8f6342c4 <memset>
	scmcall_ret scm_ret = {0};
8f61528c:	e24b3054 	sub	r3, r11, #84	; 0x54
8f615290:	e3a02000 	mov	r2, #0
8f615294:	e5832000 	str	r2, [r3]
8f615298:	e5832004 	str	r2, [r3, #4]
8f61529c:	e5832008 	str	r2, [r3, #8]

	if (!is_scm_armv8_support()) {
8f6152a0:	ebfff8e6 	bl	8f613640 <is_scm_armv8_support>
8f6152a4:	e1a03000 	mov	r3, r0
8f6152a8:	e3530000 	cmp	r3, #0
8f6152ac:	1a000007 	bne	8f6152d0 <scm_io_write+0x7c>
		ret = scm_call_atomic2(SCM_SVC_IO, SCM_IO_WRITE, address, val);
8f6152b0:	e51b3064 	ldr	r3, [r11, #-100]	; 0xffffff9c
8f6152b4:	e51b2060 	ldr	r2, [r11, #-96]	; 0xffffffa0
8f6152b8:	e3a01002 	mov	r1, #2
8f6152bc:	e3a00005 	mov	r0, #5
8f6152c0:	ebfffa42 	bl	8f613bd0 <scm_call_atomic2>
8f6152c4:	e1a03000 	mov	r3, r0
8f6152c8:	e50b3058 	str	r3, [r11, #-88]	; 0xffffffa8
8f6152cc:	ea000010 	b	8f615314 <scm_io_write+0xc0>
	} else {
		scm_arg.x0 = MAKE_SIP_SCM_CMD(SCM_SVC_IO, SCM_IO_WRITE);
8f6152d0:	e3003502 	movw	r3, #1282	; 0x502
8f6152d4:	e3403200 	movt	r3, #512	; 0x200
8f6152d8:	e50b3048 	str	r3, [r11, #-72]	; 0xffffffb8
		scm_arg.x1 = MAKE_SCM_ARGS(0x2);
8f6152dc:	e3a03002 	mov	r3, #2
8f6152e0:	e50b3044 	str	r3, [r11, #-68]	; 0xffffffbc
		scm_arg.x2 = address;
8f6152e4:	e51b3060 	ldr	r3, [r11, #-96]	; 0xffffffa0
8f6152e8:	e50b3040 	str	r3, [r11, #-64]	; 0xffffffc0
		scm_arg.x3 = val;
8f6152ec:	e51b3064 	ldr	r3, [r11, #-100]	; 0xffffff9c
8f6152f0:	e50b303c 	str	r3, [r11, #-60]	; 0xffffffc4
		scm_arg.atomic = true;
8f6152f4:	e3a03001 	mov	r3, #1
8f6152f8:	e50b300c 	str	r3, [r11, #-12]
		ret = scm_call2(&scm_arg, &scm_ret);
8f6152fc:	e24b2054 	sub	r2, r11, #84	; 0x54
8f615300:	e24b3048 	sub	r3, r11, #72	; 0x48
8f615304:	e1a01002 	mov	r1, r2
8f615308:	e1a00003 	mov	r0, r3
8f61530c:	ebfffeaf 	bl	8f614dd0 <scm_call2>
8f615310:	e50b0058 	str	r0, [r11, #-88]	; 0xffffffa8
	}
	return ret;
8f615314:	e51b3058 	ldr	r3, [r11, #-88]	; 0xffffffa8
}
8f615318:	e59f2020 	ldr	r2, [pc, #32]	; 8f615340 <scm_io_write+0xec>
8f61531c:	e5921000 	ldr	r1, [r2]
8f615320:	e51b2008 	ldr	r2, [r11, #-8]
8f615324:	e0321001 	eors	r1, r2, r1
8f615328:	e3a02000 	mov	r2, #0
8f61532c:	0a000000 	beq	8f615334 <scm_io_write+0xe0>
8f615330:	eb007622 	bl	8f632bc0 <__stack_chk_fail>
8f615334:	e1a00003 	mov	r0, r3
8f615338:	e24bd004 	sub	r13, r11, #4
8f61533c:	e8bd8800 	pop	{r11, r15}
8f615340:	8f74221c 	.word	0x8f74221c

8f615344 <scm_call2_atomic>:

int scm_call2_atomic(uint32_t svc, uint32_t cmd, uint32_t arg1, uint32_t arg2)
{
8f615344:	e92d4800 	push	{r11, r14}
8f615348:	e28db004 	add	r11, r13, #4
8f61534c:	e24dd068 	sub	r13, r13, #104	; 0x68
8f615350:	e50b0060 	str	r0, [r11, #-96]	; 0xffffffa0
8f615354:	e50b1064 	str	r1, [r11, #-100]	; 0xffffff9c
8f615358:	e50b2068 	str	r2, [r11, #-104]	; 0xffffff98
8f61535c:	e50b306c 	str	r3, [r11, #-108]	; 0xffffff94
8f615360:	e59f30e0 	ldr	r3, [pc, #224]	; 8f615448 <scm_call2_atomic+0x104>
8f615364:	e5933000 	ldr	r3, [r3]
8f615368:	e50b3008 	str	r3, [r11, #-8]
8f61536c:	e3a03000 	mov	r3, #0
	uint32_t ret = 0;
8f615370:	e3a03000 	mov	r3, #0
8f615374:	e50b3058 	str	r3, [r11, #-88]	; 0xffffffa8
	scmcall_arg scm_arg = {0};
8f615378:	e24b3048 	sub	r3, r11, #72	; 0x48
8f61537c:	e3a02040 	mov	r2, #64	; 0x40
8f615380:	e3a01000 	mov	r1, #0
8f615384:	e1a00003 	mov	r0, r3
8f615388:	eb007bcd 	bl	8f6342c4 <memset>
	scmcall_ret scm_ret = {0};
8f61538c:	e24b3054 	sub	r3, r11, #84	; 0x54
8f615390:	e3a02000 	mov	r2, #0
8f615394:	e5832000 	str	r2, [r3]
8f615398:	e5832004 	str	r2, [r3, #4]
8f61539c:	e5832008 	str	r2, [r3, #8]

	if (!is_scm_armv8_support())
8f6153a0:	ebfff8a6 	bl	8f613640 <is_scm_armv8_support>
8f6153a4:	e1a03000 	mov	r3, r0
8f6153a8:	e3530000 	cmp	r3, #0
8f6153ac:	1a000007 	bne	8f6153d0 <scm_call2_atomic+0x8c>
	{
		ret = scm_call_atomic2(svc, cmd, arg1, arg2);
8f6153b0:	e51b306c 	ldr	r3, [r11, #-108]	; 0xffffff94
8f6153b4:	e51b2068 	ldr	r2, [r11, #-104]	; 0xffffff98
8f6153b8:	e51b1064 	ldr	r1, [r11, #-100]	; 0xffffff9c
8f6153bc:	e51b0060 	ldr	r0, [r11, #-96]	; 0xffffffa0
8f6153c0:	ebfffa02 	bl	8f613bd0 <scm_call_atomic2>
8f6153c4:	e1a03000 	mov	r3, r0
8f6153c8:	e50b3058 	str	r3, [r11, #-88]	; 0xffffffa8
8f6153cc:	ea000012 	b	8f61541c <scm_call2_atomic+0xd8>
	} else {
		scm_arg.x0 = MAKE_SIP_SCM_CMD(svc, cmd);
8f6153d0:	e51b3060 	ldr	r3, [r11, #-96]	; 0xffffffa0
8f6153d4:	e1a02403 	lsl	r2, r3, #8
8f6153d8:	e51b3064 	ldr	r3, [r11, #-100]	; 0xffffff9c
8f6153dc:	e1823003 	orr	r3, r2, r3
8f6153e0:	e6ff3073 	uxth	r3, r3
8f6153e4:	e3833402 	orr	r3, r3, #33554432	; 0x2000000
8f6153e8:	e50b3048 	str	r3, [r11, #-72]	; 0xffffffb8
		scm_arg.x1 = MAKE_SCM_ARGS(0x2);
8f6153ec:	e3a03002 	mov	r3, #2
8f6153f0:	e50b3044 	str	r3, [r11, #-68]	; 0xffffffbc
		scm_arg.x2 = arg1;
8f6153f4:	e51b3068 	ldr	r3, [r11, #-104]	; 0xffffff98
8f6153f8:	e50b3040 	str	r3, [r11, #-64]	; 0xffffffc0
		scm_arg.x3 = arg2;
8f6153fc:	e51b306c 	ldr	r3, [r11, #-108]	; 0xffffff94
8f615400:	e50b303c 	str	r3, [r11, #-60]	; 0xffffffc4
		ret =  scm_call2(&scm_arg, &scm_ret);
8f615404:	e24b2054 	sub	r2, r11, #84	; 0x54
8f615408:	e24b3048 	sub	r3, r11, #72	; 0x48
8f61540c:	e1a01002 	mov	r1, r2
8f615410:	e1a00003 	mov	r0, r3
8f615414:	ebfffe6d 	bl	8f614dd0 <scm_call2>
8f615418:	e50b0058 	str	r0, [r11, #-88]	; 0xffffffa8
	}
	return ret;
8f61541c:	e51b3058 	ldr	r3, [r11, #-88]	; 0xffffffa8
}
8f615420:	e59f2020 	ldr	r2, [pc, #32]	; 8f615448 <scm_call2_atomic+0x104>
8f615424:	e5921000 	ldr	r1, [r2]
8f615428:	e51b2008 	ldr	r2, [r11, #-8]
8f61542c:	e0321001 	eors	r1, r2, r1
8f615430:	e3a02000 	mov	r2, #0
8f615434:	0a000000 	beq	8f61543c <scm_call2_atomic+0xf8>
8f615438:	eb0075e0 	bl	8f632bc0 <__stack_chk_fail>
8f61543c:	e1a00003 	mov	r0, r3
8f615440:	e24bd004 	sub	r13, r11, #4
8f615444:	e8bd8800 	pop	{r11, r15}
8f615448:	8f74221c 	.word	0x8f74221c

8f61544c <scm_disable_sdi>:

int scm_disable_sdi()
{
8f61544c:	e92d4800 	push	{r11, r14}
8f615450:	e28db004 	add	r11, r13, #4
8f615454:	e24dd008 	sub	r13, r13, #8
8f615458:	e59f309c 	ldr	r3, [pc, #156]	; 8f6154fc <scm_disable_sdi+0xb0>
8f61545c:	e5933000 	ldr	r3, [r3]
8f615460:	e50b3008 	str	r3, [r11, #-8]
8f615464:	e3a03000 	mov	r3, #0
	int ret = 0;
8f615468:	e3a03000 	mov	r3, #0
8f61546c:	e50b300c 	str	r3, [r11, #-12]

	scm_check_boot_fuses();
8f615470:	ebfffed6 	bl	8f614fd0 <scm_check_boot_fuses>

	/* Make WDOG_DEBUG DISABLE scm call only in non-secure boot */
	if(!(secure_boot_enabled || wdog_debug_fuse_disabled)) {
8f615474:	e30d30c0 	movw	r3, #53440	; 0xd0c0
8f615478:	e3483f72 	movt	r3, #36722	; 0x8f72
8f61547c:	e5933000 	ldr	r3, [r3]
8f615480:	e3530000 	cmp	r3, #0
8f615484:	1a000011 	bne	8f6154d0 <scm_disable_sdi+0x84>
8f615488:	e3013380 	movw	r3, #4992	; 0x1380
8f61548c:	e3483f71 	movt	r3, #36721	; 0x8f71
8f615490:	e5933000 	ldr	r3, [r3]
8f615494:	e3530000 	cmp	r3, #0
8f615498:	1a00000c 	bne	8f6154d0 <scm_disable_sdi+0x84>
		ret = scm_call2_atomic(SCM_SVC_BOOT, WDOG_DEBUG_DISABLE, 1, 0);
8f61549c:	e3a03000 	mov	r3, #0
8f6154a0:	e3a02001 	mov	r2, #1
8f6154a4:	e3a01009 	mov	r1, #9
8f6154a8:	e3a00001 	mov	r0, #1
8f6154ac:	ebffffa4 	bl	8f615344 <scm_call2_atomic>
8f6154b0:	e50b000c 	str	r0, [r11, #-12]
		if(ret)
8f6154b4:	e51b300c 	ldr	r3, [r11, #-12]
8f6154b8:	e3530000 	cmp	r3, #0
8f6154bc:	0a000003 	beq	8f6154d0 <scm_disable_sdi+0x84>
			dprintf(CRITICAL, "Failed to disable secure wdog debug: %d\n", ret);
8f6154c0:	e51b100c 	ldr	r1, [r11, #-12]
8f6154c4:	e30407f8 	movw	r0, #18424	; 0x47f8
8f6154c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6154cc:	eb007528 	bl	8f632974 <_dprintf>
	}
	return ret;
8f6154d0:	e51b300c 	ldr	r3, [r11, #-12]
}
8f6154d4:	e59f2020 	ldr	r2, [pc, #32]	; 8f6154fc <scm_disable_sdi+0xb0>
8f6154d8:	e5921000 	ldr	r1, [r2]
8f6154dc:	e51b2008 	ldr	r2, [r11, #-8]
8f6154e0:	e0321001 	eors	r1, r2, r1
8f6154e4:	e3a02000 	mov	r2, #0
8f6154e8:	0a000000 	beq	8f6154f0 <scm_disable_sdi+0xa4>
8f6154ec:	eb0075b3 	bl	8f632bc0 <__stack_chk_fail>
8f6154f0:	e1a00003 	mov	r0, r3
8f6154f4:	e24bd004 	sub	r13, r11, #4
8f6154f8:	e8bd8800 	pop	{r11, r15}
8f6154fc:	8f74221c 	.word	0x8f74221c

8f615500 <scm_dload_mode>:

#if PLATFORM_USE_SCM_DLOAD
int scm_dload_mode(enum reboot_reason mode)
{
8f615500:	e92d4800 	push	{r11, r14}
8f615504:	e28db004 	add	r11, r13, #4
8f615508:	e24dd018 	sub	r13, r13, #24
8f61550c:	e50b0018 	str	r0, [r11, #-24]	; 0xffffffe8
8f615510:	e59f30fc 	ldr	r3, [pc, #252]	; 8f615614 <scm_dload_mode+0x114>
8f615514:	e5933000 	ldr	r3, [r3]
8f615518:	e50b3008 	str	r3, [r11, #-8]
8f61551c:	e3a03000 	mov	r3, #0
	int ret = 0;
8f615520:	e3a03000 	mov	r3, #0
8f615524:	e50b3010 	str	r3, [r11, #-16]
	uint32_t dload_type;

	dprintf(SPEW, "DLOAD mode: %d\n", mode);
8f615528:	e51b1018 	ldr	r1, [r11, #-24]	; 0xffffffe8
8f61552c:	e3040824 	movw	r0, #18468	; 0x4824
8f615530:	e3480f70 	movt	r0, #36720	; 0x8f70
8f615534:	eb00750e 	bl	8f632974 <_dprintf>
	if (mode == NORMAL_DLOAD) {
8f615538:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f61553c:	e353021f 	cmp	r3, #-268435455	; 0xf0000001
8f615540:	1a000002 	bne	8f615550 <scm_dload_mode+0x50>
		dload_type = SCM_DLOAD_MODE;
8f615544:	e3a03010 	mov	r3, #16
8f615548:	e50b300c 	str	r3, [r11, #-12]
8f61554c:	ea000007 	b	8f615570 <scm_dload_mode+0x70>
#if DISABLE_DLOAD_MODE
		return 0;
#endif
	} else if(mode == EMERGENCY_DLOAD)
8f615550:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f615554:	e353022f 	cmp	r3, #-268435454	; 0xf0000002
8f615558:	1a000002 	bne	8f615568 <scm_dload_mode+0x68>
		dload_type = SCM_EDLOAD_MODE;
8f61555c:	e3a03001 	mov	r3, #1
8f615560:	e50b300c 	str	r3, [r11, #-12]
8f615564:	ea000001 	b	8f615570 <scm_dload_mode+0x70>
	else
		dload_type = 0;
8f615568:	e3a03000 	mov	r3, #0
8f61556c:	e50b300c 	str	r3, [r11, #-12]

	/* Write to the Boot MISC register */
	ret = is_scm_call_available(SCM_SVC_BOOT, SCM_DLOAD_CMD);
8f615570:	e3a01010 	mov	r1, #16
8f615574:	e3a00001 	mov	r0, #1
8f615578:	ebfff84b 	bl	8f6136ac <is_scm_call_available>
8f61557c:	e50b0010 	str	r0, [r11, #-16]

	if (ret > 0)
8f615580:	e51b3010 	ldr	r3, [r11, #-16]
8f615584:	e3530000 	cmp	r3, #0
8f615588:	da000006 	ble	8f6155a8 <scm_dload_mode+0xa8>
		ret = scm_call2_atomic(SCM_SVC_BOOT, SCM_DLOAD_CMD, dload_type, 0);
8f61558c:	e3a03000 	mov	r3, #0
8f615590:	e51b200c 	ldr	r2, [r11, #-12]
8f615594:	e3a01010 	mov	r1, #16
8f615598:	e3a00001 	mov	r0, #1
8f61559c:	ebffff68 	bl	8f615344 <scm_call2_atomic>
8f6155a0:	e50b0010 	str	r0, [r11, #-16]
8f6155a4:	ea000005 	b	8f6155c0 <scm_dload_mode+0xc0>
	else
		ret = scm_io_write(TCSR_BOOT_MISC_DETECT,dload_type);
8f6155a8:	e51b100c 	ldr	r1, [r11, #-12]
8f6155ac:	e3a00cd1 	mov	r0, #53504	; 0xd100
8f6155b0:	e3400193 	movt	r0, #403	; 0x193
8f6155b4:	ebffff26 	bl	8f615254 <scm_io_write>
8f6155b8:	e1a03000 	mov	r3, r0
8f6155bc:	e50b3010 	str	r3, [r11, #-16]

	if(ret) {
8f6155c0:	e51b3010 	ldr	r3, [r11, #-16]
8f6155c4:	e3530000 	cmp	r3, #0
8f6155c8:	0a000005 	beq	8f6155e4 <scm_dload_mode+0xe4>
		dprintf(CRITICAL, "Failed to write to boot misc: %d\n", ret);
8f6155cc:	e51b1010 	ldr	r1, [r11, #-16]
8f6155d0:	e3040834 	movw	r0, #18484	; 0x4834
8f6155d4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6155d8:	eb0074e5 	bl	8f632974 <_dprintf>
		return ret;
8f6155dc:	e51b3010 	ldr	r3, [r11, #-16]
8f6155e0:	ea000001 	b	8f6155ec <scm_dload_mode+0xec>
	}

#if !DISABLE_DLOAD_MODE
	return scm_disable_sdi();
8f6155e4:	ebffff98 	bl	8f61544c <scm_disable_sdi>
8f6155e8:	e1a03000 	mov	r3, r0
#else
	return ret;
#endif
}
8f6155ec:	e59f2020 	ldr	r2, [pc, #32]	; 8f615614 <scm_dload_mode+0x114>
8f6155f0:	e5921000 	ldr	r1, [r2]
8f6155f4:	e51b2008 	ldr	r2, [r11, #-8]
8f6155f8:	e0321001 	eors	r1, r2, r1
8f6155fc:	e3a02000 	mov	r2, #0
8f615600:	0a000000 	beq	8f615608 <scm_dload_mode+0x108>
8f615604:	eb00756d 	bl	8f632bc0 <__stack_chk_fail>
8f615608:	e1a00003 	mov	r0, r3
8f61560c:	e24bd004 	sub	r13, r11, #4
8f615610:	e8bd8800 	pop	{r11, r15}
8f615614:	8f74221c 	.word	0x8f74221c

8f615618 <allow_set_fuse>:

	return false;
}
#endif
bool allow_set_fuse(uint32_t version)
{
8f615618:	e92d4800 	push	{r11, r14}
8f61561c:	e28db004 	add	r11, r13, #4
8f615620:	e24dd010 	sub	r13, r13, #16
8f615624:	e50b0010 	str	r0, [r11, #-16]
8f615628:	e59f3070 	ldr	r3, [pc, #112]	; 8f6156a0 <allow_set_fuse+0x88>
8f61562c:	e5933000 	ldr	r3, [r3]
8f615630:	e50b3008 	str	r3, [r11, #-8]
8f615634:	e3a03000 	mov	r3, #0
  /*if((major > 4) || (major == 4 && minor > 0))*/
  if((((version >> 22) & 0x3FF) > 4)
8f615638:	e51b3010 	ldr	r3, [r11, #-16]
8f61563c:	e1a03b23 	lsr	r3, r3, #22
8f615640:	e3530004 	cmp	r3, #4
8f615644:	8a000008 	bhi	8f61566c <allow_set_fuse+0x54>
        || (((version >> 22) & 0x3FF) == 4 && ((version >> 12) & 0x3FF) > 0))
8f615648:	e51b3010 	ldr	r3, [r11, #-16]
8f61564c:	e1a03b23 	lsr	r3, r3, #22
8f615650:	e3530004 	cmp	r3, #4
8f615654:	1a000006 	bne	8f615674 <allow_set_fuse+0x5c>
8f615658:	e51b3010 	ldr	r3, [r11, #-16]
8f61565c:	e1a03623 	lsr	r3, r3, #12
8f615660:	e7e93053 	ubfx	r3, r3, #0, #10
8f615664:	e3530000 	cmp	r3, #0
8f615668:	0a000001 	beq	8f615674 <allow_set_fuse+0x5c>
  {
    return TRUE;
8f61566c:	e3a03001 	mov	r3, #1
8f615670:	ea000000 	b	8f615678 <allow_set_fuse+0x60>
  } else {
    return FALSE;
8f615674:	e3a03000 	mov	r3, #0
  }
}
8f615678:	e59f2020 	ldr	r2, [pc, #32]	; 8f6156a0 <allow_set_fuse+0x88>
8f61567c:	e5921000 	ldr	r1, [r2]
8f615680:	e51b2008 	ldr	r2, [r11, #-8]
8f615684:	e0321001 	eors	r1, r2, r1
8f615688:	e3a02000 	mov	r2, #0
8f61568c:	0a000000 	beq	8f615694 <allow_set_fuse+0x7c>
8f615690:	eb00754a 	bl	8f632bc0 <__stack_chk_fail>
8f615694:	e1a00003 	mov	r0, r3
8f615698:	e24bd004 	sub	r13, r11, #4
8f61569c:	e8bd8800 	pop	{r11, r15}
8f6156a0:	8f74221c 	.word	0x8f74221c

8f6156a4 <allocate_extra_arg_buffer>:
err:
	return ret;
}

static int allocate_extra_arg_buffer(uint32_t fn_id, struct scm_desc *desc)
{
8f6156a4:	e92d4070 	push	{r4, r5, r6, r14}
8f6156a8:	e24dd068 	sub	r13, r13, #104	; 0x68
8f6156ac:	e59f3150 	ldr	r3, [pc, #336]	; 8f615804 <allocate_extra_arg_buffer+0x160>
8f6156b0:	e1a04001 	mov	r4, r1
	int i;
	int ret = GENERIC_ERROR;
	scmcall_arg arg = {0};
8f6156b4:	e3a02040 	mov	r2, #64	; 0x40
{
8f6156b8:	e1a05000 	mov	r5, r0
	scmcall_arg arg = {0};
8f6156bc:	e3a01000 	mov	r1, #0
8f6156c0:	e28d0024 	add	r0, r13, #36	; 0x24
{
8f6156c4:	e5933000 	ldr	r3, [r3]
8f6156c8:	e58d3064 	str	r3, [r13, #100]	; 0x64
8f6156cc:	e3a03000 	mov	r3, #0
	scmcall_arg arg = {0};
8f6156d0:	eb007afb 	bl	8f6342c4 <memset>
	if (!desc) {
		dprintf(CRITICAL, "%s: Invalid input\n", __func__);
		return GENERIC_ERROR;
	}

	dprintf(SPEW, "%s called\n", __func__);
8f6156d4:	e305127c 	movw	r1, #21116	; 0x527c
8f6156d8:	e3040890 	movw	r0, #18576	; 0x4890
8f6156dc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6156e0:	e3480f70 	movt	r0, #36720	; 0x8f70
	scmcall_ret ret_arg = {0};
8f6156e4:	e3a03000 	mov	r3, #0
8f6156e8:	e58d3018 	str	r3, [r13, #24]
8f6156ec:	e58d301c 	str	r3, [r13, #28]
8f6156f0:	e58d3020 	str	r3, [r13, #32]
	dprintf(SPEW, "%s called\n", __func__);
8f6156f4:	eb00749e 	bl	8f632974 <_dprintf>
	arglen = desc->arginfo & 0xf;

	dprintf(SPEW, "%s:fn_id:%u, desc->arginfo:%u desc->args[0]:%u desc->args[1]:%u desc->args[2]:%u desc->args[3]:%u desc->args[4]:%u\n",
8f6156f8:	e5943014 	ldr	r3, [r4, #20]
8f6156fc:	e1a02005 	mov	r2, r5
	arglen = desc->arginfo & 0xf;
8f615700:	e5946000 	ldr	r6, [r4]
	dprintf(SPEW, "%s:fn_id:%u, desc->arginfo:%u desc->args[0]:%u desc->args[1]:%u desc->args[2]:%u desc->args[3]:%u desc->args[4]:%u\n",
8f615704:	e305127c 	movw	r1, #21116	; 0x527c
8f615708:	e304089c 	movw	r0, #18588	; 0x489c
8f61570c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f615710:	e58d3010 	str	r3, [r13, #16]
8f615714:	e3480f70 	movt	r0, #36720	; 0x8f70
8f615718:	e5943010 	ldr	r3, [r4, #16]
8f61571c:	e58d300c 	str	r3, [r13, #12]
8f615720:	e594300c 	ldr	r3, [r4, #12]
8f615724:	e58d3008 	str	r3, [r13, #8]
8f615728:	e5943008 	ldr	r3, [r4, #8]
8f61572c:	e58d3004 	str	r3, [r13, #4]
8f615730:	e5943004 	ldr	r3, [r4, #4]
8f615734:	e58d3000 	str	r3, [r13]
8f615738:	e1a03006 	mov	r3, r6
8f61573c:	eb00748c 	bl	8f632974 <_dprintf>
			__func__, fn_id, desc->arginfo, desc->args[0], desc->args[1], desc->args[2], desc->args[3], desc->args[4]);

	arg.x0 = fn_id;
	arg.x1 = desc->arginfo;
8f615740:	e5943000 	ldr	r3, [r4]
	arg.x2 = desc->args[0];
	arg.x3 = desc->args[1];
	arg.x4 = desc->args[2];

	if (arglen > FIRST_EXT_ARG_IDX) {
8f615744:	e316000c 	tst	r6, #12
	arg.x0 = fn_id;
8f615748:	e58d5024 	str	r5, [r13, #36]	; 0x24
	arg.x1 = desc->arginfo;
8f61574c:	e58d3028 	str	r3, [r13, #40]	; 0x28
	arg.x2 = desc->args[0];
8f615750:	e5943004 	ldr	r3, [r4, #4]
8f615754:	e58d302c 	str	r3, [r13, #44]	; 0x2c
	arg.x3 = desc->args[1];
8f615758:	e5943008 	ldr	r3, [r4, #8]
8f61575c:	e58d3030 	str	r3, [r13, #48]	; 0x30
	arg.x4 = desc->args[2];
8f615760:	e594300c 	ldr	r3, [r4, #12]
8f615764:	e58d3034 	str	r3, [r13, #52]	; 0x34
	if (arglen > FIRST_EXT_ARG_IDX) {
8f615768:	0a00000b 	beq	8f61579c <allocate_extra_arg_buffer+0xf8>
	arglen = desc->arginfo & 0xf;
8f61576c:	e206600f 	and	r6, r6, #15
		for (i = 0; i < (arglen - FIRST_EXT_ARG_IDX); i++) {
8f615770:	e2463003 	sub	r3, r6, #3
8f615774:	e3530000 	cmp	r3, #0
8f615778:	da000007 	ble	8f61579c <allocate_extra_arg_buffer+0xf8>
8f61577c:	e2843004 	add	r3, r4, #4
8f615780:	e2842010 	add	r2, r4, #16
8f615784:	e0836106 	add	r6, r3, r6, lsl #2
8f615788:	e28d3038 	add	r3, r13, #56	; 0x38
			arg.x5[i] = desc->args[i + FIRST_EXT_ARG_IDX];
8f61578c:	e4921004 	ldr	r1, [r2], #4
		for (i = 0; i < (arglen - FIRST_EXT_ARG_IDX); i++) {
8f615790:	e1520006 	cmp	r2, r6
			arg.x5[i] = desc->args[i + FIRST_EXT_ARG_IDX];
8f615794:	e4831004 	str	r1, [r3], #4
		for (i = 0; i < (arglen - FIRST_EXT_ARG_IDX); i++) {
8f615798:	1afffffb 	bne	8f61578c <allocate_extra_arg_buffer+0xe8>
		}
	}
	ret = scm_call2(&arg, &ret_arg);
8f61579c:	e28d1018 	add	r1, r13, #24
8f6157a0:	e28d0024 	add	r0, r13, #36	; 0x24
8f6157a4:	ebfffd89 	bl	8f614dd0 <scm_call2>
	desc->ret[0] = ret_arg.x1;
	desc->ret[1] = ret_arg.x2;
	desc->ret[2] = ret_arg.x3;
8f6157a8:	e28d3018 	add	r3, r13, #24

	dprintf(SPEW, "%s:ret:%d, desc->ret[0]]:%u desc->ret[1]:%u desc->ret[2]:%u\n",
8f6157ac:	e305127c 	movw	r1, #21116	; 0x527c
8f6157b0:	e3481f70 	movt	r1, #36720	; 0x8f70
	desc->ret[2] = ret_arg.x3;
8f6157b4:	e8935008 	ldm	r3, {r3, r12, r14}
	desc->ret[0] = ret_arg.x1;
8f6157b8:	e584302c 	str	r3, [r4, #44]	; 0x2c
	desc->ret[1] = ret_arg.x2;
8f6157bc:	e584c030 	str	r12, [r4, #48]	; 0x30
	desc->ret[2] = ret_arg.x3;
8f6157c0:	e584e034 	str	r14, [r4, #52]	; 0x34
	dprintf(SPEW, "%s:ret:%d, desc->ret[0]]:%u desc->ret[1]:%u desc->ret[2]:%u\n",
8f6157c4:	e88d5000 	stm	r13, {r12, r14}
8f6157c8:	e1a02000 	mov	r2, r0
	ret = scm_call2(&arg, &ret_arg);
8f6157cc:	e1a05000 	mov	r5, r0
	dprintf(SPEW, "%s:ret:%d, desc->ret[0]]:%u desc->ret[1]:%u desc->ret[2]:%u\n",
8f6157d0:	e3040910 	movw	r0, #18704	; 0x4910
8f6157d4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6157d8:	eb007465 	bl	8f632974 <_dprintf>
			__func__, ret, desc->ret[0], desc->ret[1], desc->ret[2]);
	return ret;
}
8f6157dc:	e59f3020 	ldr	r3, [pc, #32]	; 8f615804 <allocate_extra_arg_buffer+0x160>
8f6157e0:	e5932000 	ldr	r2, [r3]
8f6157e4:	e59d3064 	ldr	r3, [r13, #100]	; 0x64
8f6157e8:	e0332002 	eors	r2, r3, r2
8f6157ec:	e3a03000 	mov	r3, #0
8f6157f0:	1a000002 	bne	8f615800 <allocate_extra_arg_buffer+0x15c>
8f6157f4:	e1a00005 	mov	r0, r5
8f6157f8:	e28dd068 	add	r13, r13, #104	; 0x68
8f6157fc:	e8bd8070 	pop	{r4, r5, r6, r15}
8f615800:	eb0074ee 	bl	8f632bc0 <__stack_chk_fail>
8f615804:	8f74221c 	.word	0x8f74221c

8f615808 <qseecom_scm_call.constprop.0>:
	dprintf(SPEW, "scm_resp->result = 0x%x, scm_resp->resp_type = 0x%x, scm_resp->data = 0x%x\n",
		scm_resp->result, scm_resp->resp_type, scm_resp->data);
	return ret;
}

static int qseecom_scm_call(uint32_t svc_id, uint32_t tz_cmd_id, void *cmd_buf,
8f615808:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f61580c:	e24dd09c 	sub	r13, r13, #156	; 0x9c
8f615810:	e1a08001 	mov	r8, r1
8f615814:	e1a05000 	mov	r5, r0
8f615818:	e58d3018 	str	r3, [r13, #24]
	uint32_t QseeLogNewStart = 0;

	if ((!cmd_buf) || (!resp_buf))
			return GENERIC_ERROR;

	dprintf(SPEW, "%s called\n", __func__);
8f61581c:	e30512ac 	movw	r1, #21164	; 0x52ac
static int qseecom_scm_call(uint32_t svc_id, uint32_t tz_cmd_id, void *cmd_buf,
8f615820:	e59f3828 	ldr	r3, [pc, #2088]	; 8f616050 <qseecom_scm_call.constprop.0+0x848>
	dprintf(SPEW, "%s called\n", __func__);
8f615824:	e3481f70 	movt	r1, #36720	; 0x8f70
8f615828:	e3040890 	movw	r0, #18576	; 0x4890
8f61582c:	e3480f70 	movt	r0, #36720	; 0x8f70
static int qseecom_scm_call(uint32_t svc_id, uint32_t tz_cmd_id, void *cmd_buf,
8f615830:	e5933000 	ldr	r3, [r3]
8f615834:	e58d3094 	str	r3, [r13, #148]	; 0x94
8f615838:	e3a03000 	mov	r3, #0
	struct qseecom_client_listener_data_irsp send_data_rsp = {0};
8f61583c:	e3a07000 	mov	r7, #0
static int qseecom_scm_call(uint32_t svc_id, uint32_t tz_cmd_id, void *cmd_buf,
8f615840:	e1a06002 	mov	r6, r2
8f615844:	e59d40c0 	ldr	r4, [r13, #192]	; 0xc0
	struct qseecom_client_listener_data_irsp send_data_rsp = {0};
8f615848:	e58d703c 	str	r7, [r13, #60]	; 0x3c
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f61584c:	e300a106 	movw	r10, #262	; 0x106
	struct qseecom_client_listener_data_irsp send_data_rsp = {0};
8f615850:	e58d7040 	str	r7, [r13, #64]	; 0x40
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615854:	e343a200 	movt	r10, #12800	; 0x3200
	struct qseecom_client_listener_data_irsp send_data_rsp = {0};
8f615858:	e58d7044 	str	r7, [r13, #68]	; 0x44
	dprintf(SPEW, "%s called\n", __func__);
8f61585c:	eb007444 	bl	8f632974 <_dprintf>
	mutex_acquire(&qseecom.registered_app_list_lock);
8f615860:	e59f07ec 	ldr	r0, [pc, #2028]	; 8f616054 <qseecom_scm_call.constprop.0+0x84c>
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615864:	e300b201 	movw	r11, #513	; 0x201
	uint32_t QseeLogStart = 0;
8f615868:	e58d700c 	str	r7, [r13, #12]
	mutex_acquire(&qseecom.registered_app_list_lock);
8f61586c:	eb0035d6 	bl	8f622fcc <mutex_acquire>
	req = cmd_buf;
	qseos_cmd_id = *(uint32_t *)req;
8f615870:	e5963000 	ldr	r3, [r6]
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615874:	e343b200 	movt	r11, #12800	; 0x3200
	struct tzdbg_log_t *log = NULL;
8f615878:	e1cda2fc 	strd	r10, [r13, #44]	; 0x2c
8f61587c:	e1a0b008 	mov	r11, r8
8f615880:	e58d7014 	str	r7, [r13, #20]
	qseos_cmd_id = *(uint32_t *)req;
8f615884:	e58d3010 	str	r3, [r13, #16]
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615888:	e3003402 	movw	r3, #1026	; 0x402
8f61588c:	e3433200 	movt	r3, #12800	; 0x3200
8f615890:	e58d301c 	str	r3, [r13, #28]
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615894:	e3003401 	movw	r3, #1025	; 0x401
8f615898:	e3433200 	movt	r3, #12800	; 0x3200
8f61589c:	e58d3020 	str	r3, [r13, #32]
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f6158a0:	e3003203 	movw	r3, #515	; 0x203
8f6158a4:	e3433200 	movt	r3, #12800	; 0x3200
8f6158a8:	e58d3024 	str	r3, [r13, #36]	; 0x24
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f6158ac:	e3003202 	movw	r3, #514	; 0x202
8f6158b0:	e3433200 	movt	r3, #12800	; 0x3200
8f6158b4:	e58d3028 	str	r3, [r13, #40]	; 0x28
	resp = (struct qseecom_command_scm_resp *) resp_buf;

	do {
		if (!is_scm_armv8_support()) {
8f6158b8:	ebfff760 	bl	8f613640 <is_scm_armv8_support>
8f6158bc:	e3500000 	cmp	r0, #0
8f6158c0:	0a00005e 	beq	8f615a40 <qseecom_scm_call.constprop.0+0x238>
			ret = scm_call(svc_id, tz_cmd_id, req, cmd_len,
					resp_buf, resp_len);
		} else {
			if(logbuf_req.phy_addr)
8f6158c4:	e30d70c8 	movw	r7, #53448	; 0xd0c8
8f6158c8:	e3487f72 	movt	r7, #36722	; 0x8f72
8f6158cc:	e5973004 	ldr	r3, [r7, #4]
8f6158d0:	e3530000 	cmp	r3, #0
8f6158d4:	1a0000ec 	bne	8f615c8c <qseecom_scm_call.constprop.0+0x484>
	struct scm_desc desc = {0};
8f6158d8:	e3a02048 	mov	r2, #72	; 0x48
8f6158dc:	e3a01000 	mov	r1, #0
8f6158e0:	e08d0002 	add	r0, r13, r2
8f6158e4:	eb007a76 	bl	8f6342c4 <memset>
	dprintf(SPEW, "%s called\n", __func__);
8f6158e8:	e3051298 	movw	r1, #21144	; 0x5298
8f6158ec:	e3040890 	movw	r0, #18576	; 0x4890
8f6158f0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6158f4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6158f8:	eb00741d 	bl	8f632974 <_dprintf>
	switch (svc_id) {
8f6158fc:	e3550006 	cmp	r5, #6
	qseos_cmd_id = *(uint32_t *)req_buf;
8f615900:	e5968000 	ldr	r8, [r6]
	switch (svc_id) {
8f615904:	0a0000e8 	beq	8f615cac <qseecom_scm_call.constprop.0+0x4a4>
8f615908:	e35500fc 	cmp	r5, #252	; 0xfc
8f61590c:	0a000037 	beq	8f6159f0 <qseecom_scm_call.constprop.0+0x1e8>
			dprintf(CRITICAL, "svc_id 0x%x is not supported by armv8 scm_call2.\n",
8f615910:	e1a01005 	mov	r1, r5
8f615914:	e3040a10 	movw	r0, #18960	; 0x4a10
8f615918:	e3480f70 	movt	r0, #36720	; 0x8f70
	uint32_t smc_id = 0;
8f61591c:	e3a09000 	mov	r9, #0
			dprintf(CRITICAL, "svc_id 0x%x is not supported by armv8 scm_call2.\n",
8f615920:	eb007413 	bl	8f632974 <_dprintf>
			ret = GENERIC_ERROR;
8f615924:	e3e06000 	mvn	r6, #0
	scm_resp->result = desc.ret[0];
8f615928:	e59d2074 	ldr	r2, [r13, #116]	; 0x74
	dprintf(SPEW, "svc_id = 0x%x, tz_cmd_id = 0x%x, qseos_cmd_id = 0x%x, smc_id = 0x%x, param_id = 0x%x\n",
8f61592c:	e1a03008 	mov	r3, r8
8f615930:	e58d9000 	str	r9, [r13]
8f615934:	e1a01005 	mov	r1, r5
8f615938:	e3040a44 	movw	r0, #19012	; 0x4a44
8f61593c:	e3480f70 	movt	r0, #36720	; 0x8f70
	scm_resp->result = desc.ret[0];
8f615940:	e5842000 	str	r2, [r4]
	scm_resp->resp_type = desc.ret[1];
8f615944:	e59d2078 	ldr	r2, [r13, #120]	; 0x78
8f615948:	e5842004 	str	r2, [r4, #4]
	scm_resp->data = desc.ret[2];
8f61594c:	e59d207c 	ldr	r2, [r13, #124]	; 0x7c
8f615950:	e5842008 	str	r2, [r4, #8]
	dprintf(SPEW, "svc_id = 0x%x, tz_cmd_id = 0x%x, qseos_cmd_id = 0x%x, smc_id = 0x%x, param_id = 0x%x\n",
8f615954:	e59d2048 	ldr	r2, [r13, #72]	; 0x48
8f615958:	e58d2004 	str	r2, [r13, #4]
8f61595c:	e1a0200b 	mov	r2, r11
8f615960:	eb007403 	bl	8f632974 <_dprintf>
	dprintf(SPEW, "scm_resp->result = 0x%x, scm_resp->resp_type = 0x%x, scm_resp->data = 0x%x\n",
8f615964:	e5943008 	ldr	r3, [r4, #8]
8f615968:	e5942004 	ldr	r2, [r4, #4]
8f61596c:	e3040a9c 	movw	r0, #19100	; 0x4a9c
8f615970:	e5941000 	ldr	r1, [r4]
8f615974:	e3480f70 	movt	r0, #36720	; 0x8f70
8f615978:	eb0073fd 	bl	8f632974 <_dprintf>
				arch_invalidate_cache_range((addr_t) logbuf_req.phy_addr, logbuf_req.len);
				QseeLogStart = (uint32_t) log->log_pos.offset;
			}

			ret = qseecom_scm_call2(svc_id, tz_cmd_id, req, resp);
			if(logbuf_req.phy_addr)
8f61597c:	e5970004 	ldr	r0, [r7, #4]
8f615980:	e3500000 	cmp	r0, #0
8f615984:	1a000073 	bne	8f615b58 <qseecom_scm_call.constprop.0+0x350>
					QSEE_LOG_BUF_SIZE - sizeof(struct tzdbg_log_pos_t),
					QseeLogStart, QseeLogNewStart);
			}
		}

		if (ret) {
8f615988:	e3560000 	cmp	r6, #0
8f61598c:	1a00019e 	bne	8f61600c <qseecom_scm_call.constprop.0+0x804>
			dprintf(CRITICAL, "ERROR: scm_call to load failed : ret %d\n", ret);
			ret = GENERIC_ERROR;
			goto err;
		}

		if (svc_id == TZ_CALL) {
8f615990:	e3550006 	cmp	r5, #6
8f615994:	0a00000a 	beq	8f6159c4 <qseecom_scm_call.constprop.0+0x1bc>
			goto err;
		}

		switch (resp->result) {
8f615998:	e5941000 	ldr	r1, [r4]
8f61599c:	e3510001 	cmp	r1, #1
8f6159a0:	0a000042 	beq	8f615ab0 <qseecom_scm_call.constprop.0+0x2a8>
8f6159a4:	e3710001 	cmn	r1, #1
8f6159a8:	0a00003b 	beq	8f615a9c <qseecom_scm_call.constprop.0+0x294>
8f6159ac:	e3510000 	cmp	r1, #0
8f6159b0:	0a00002c 	beq	8f615a68 <qseecom_scm_call.constprop.0+0x260>
				__qseecom_process_incomplete_cmd(resp, &send_data_rsp);
				req = (void *)&send_data_rsp;
				qseos_cmd_id = QSEE_LISTENER_DATA_RSP_COMMAND;
				break;
			default:
				dprintf(CRITICAL, "scm call return unknown response %d\n",	resp->result);
8f6159b4:	e3040bd8 	movw	r0, #19416	; 0x4bd8
8f6159b8:	e3480f70 	movt	r0, #36720	; 0x8f70
				ret = GENERIC_ERROR;
8f6159bc:	e3e06000 	mvn	r6, #0
				dprintf(CRITICAL, "scm call return unknown response %d\n",	resp->result);
8f6159c0:	eb0073eb 	bl	8f632974 <_dprintf>
				goto err;
		}
	} while(true);

err:
	mutex_release(&qseecom.registered_app_list_lock);
8f6159c4:	e59f0688 	ldr	r0, [pc, #1672]	; 8f616054 <qseecom_scm_call.constprop.0+0x84c>
8f6159c8:	eb0035cd 	bl	8f623104 <mutex_release>
	return ret;

}
8f6159cc:	e59f367c 	ldr	r3, [pc, #1660]	; 8f616050 <qseecom_scm_call.constprop.0+0x848>
8f6159d0:	e5932000 	ldr	r2, [r3]
8f6159d4:	e59d3094 	ldr	r3, [r13, #148]	; 0x94
8f6159d8:	e0332002 	eors	r2, r3, r2
8f6159dc:	e3a03000 	mov	r3, #0
8f6159e0:	1a000194 	bne	8f616038 <qseecom_scm_call.constprop.0+0x830>
8f6159e4:	e1a00006 	mov	r0, r6
8f6159e8:	e28dd09c 	add	r13, r13, #156	; 0x9c
8f6159ec:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
			switch (qseos_cmd_id) {
8f6159f0:	e2483001 	sub	r3, r8, #1
8f6159f4:	e353000f 	cmp	r3, #15
8f6159f8:	979ff103 	ldrls	r15, [r15, r3, lsl #2]
8f6159fc:	ea0000d7 	b	8f615d60 <qseecom_scm_call.constprop.0+0x558>
8f615a00:	8f615fa8 	.word	0x8f615fa8
8f615a04:	8f615ed0 	.word	0x8f615ed0
8f615a08:	8f615d60 	.word	0x8f615d60
8f615a0c:	8f615f00 	.word	0x8f615f00
8f615a10:	8f615f38 	.word	0x8f615f38
8f615a14:	8f615f60 	.word	0x8f615f60
8f615a18:	8f615d7c 	.word	0x8f615d7c
8f615a1c:	8f615d60 	.word	0x8f615d60
8f615a20:	8f615d60 	.word	0x8f615d60
8f615a24:	8f615d60 	.word	0x8f615d60
8f615a28:	8f615dac 	.word	0x8f615dac
8f615a2c:	8f615df8 	.word	0x8f615df8
8f615a30:	8f615e20 	.word	0x8f615e20
8f615a34:	8f615e58 	.word	0x8f615e58
8f615a38:	8f615e88 	.word	0x8f615e88
8f615a3c:	8f615eb0 	.word	0x8f615eb0
			ret = scm_call(svc_id, tz_cmd_id, req, cmd_len,
8f615a40:	e1a02006 	mov	r2, r6
8f615a44:	e3a0300c 	mov	r3, #12
8f615a48:	e1a0100b 	mov	r1, r11
8f615a4c:	e58d3004 	str	r3, [r13, #4]
8f615a50:	e1a00005 	mov	r0, r5
8f615a54:	e59d3018 	ldr	r3, [r13, #24]
8f615a58:	e58d4000 	str	r4, [r13]
8f615a5c:	ebfff881 	bl	8f613c68 <scm_call>
8f615a60:	e1a06000 	mov	r6, r0
8f615a64:	eaffffc7 	b	8f615988 <qseecom_scm_call.constprop.0+0x180>
				if(((resp->resp_type != QSEOS_APP_ID) || (resp->data <= 0)) &&
8f615a68:	e5941004 	ldr	r1, [r4, #4]
8f615a6c:	e30e3e01 	movw	r3, #60929	; 0xee01
8f615a70:	e1510003 	cmp	r1, r3
8f615a74:	0a0000b5 	beq	8f615d50 <qseecom_scm_call.constprop.0+0x548>
8f615a78:	e59d3010 	ldr	r3, [r13, #16]
8f615a7c:	e3530006 	cmp	r3, #6
8f615a80:	1affffcf 	bne	8f6159c4 <qseecom_scm_call.constprop.0+0x1bc>
					dprintf(CRITICAL, "ERROR: Resp type %d or Resp Data %d incorrect\n",
8f615a84:	e5942008 	ldr	r2, [r4, #8]
8f615a88:	e3040b40 	movw	r0, #19264	; 0x4b40
8f615a8c:	e3480f70 	movt	r0, #36720	; 0x8f70
					ret = GENERIC_ERROR;
8f615a90:	e3e06000 	mvn	r6, #0
					dprintf(CRITICAL, "ERROR: Resp type %d or Resp Data %d incorrect\n",
8f615a94:	eb0073b6 	bl	8f632974 <_dprintf>
					goto err;
8f615a98:	eaffffc9 	b	8f6159c4 <qseecom_scm_call.constprop.0+0x1bc>
				dprintf(CRITICAL, "scm call failed w/response result%d\n", resp->result);
8f615a9c:	e3040b70 	movw	r0, #19312	; 0x4b70
8f615aa0:	e3480f70 	movt	r0, #36720	; 0x8f70
				ret = GENERIC_ERROR;
8f615aa4:	e1a06001 	mov	r6, r1
				dprintf(CRITICAL, "scm call failed w/response result%d\n", resp->result);
8f615aa8:	eb0073b1 	bl	8f632974 <_dprintf>
				goto err;
8f615aac:	eaffffc4 	b	8f6159c4 <qseecom_scm_call.constprop.0+0x1bc>
				if(resp->resp_type != QSEOS_LISTENER_ID)
8f615ab0:	e5942004 	ldr	r2, [r4, #4]
8f615ab4:	e30e3e02 	movw	r3, #60930	; 0xee02
8f615ab8:	e1520003 	cmp	r2, r3
8f615abc:	1a000158 	bne	8f616024 <qseecom_scm_call.constprop.0+0x81c>
	if ((!resp) || (!send_data_rsp))
	{
		return GENERIC_ERROR;
	}

	dprintf(SPEW, "%s called\n", __func__);
8f615ac0:	e3051248 	movw	r1, #21064	; 0x5248
8f615ac4:	e3040890 	movw	r0, #18576	; 0x4890
8f615ac8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f615acc:	e3480f70 	movt	r0, #36720	; 0x8f70
	mutex_acquire(&qseecom.global_data_lock);
8f615ad0:	e30d70d4 	movw	r7, #53460	; 0xd0d4
8f615ad4:	e3487f72 	movt	r7, #36722	; 0x8f72
	dprintf(SPEW, "%s called\n", __func__);
8f615ad8:	eb0073a5 	bl	8f632974 <_dprintf>
	mutex_acquire(&qseecom.global_data_lock);
8f615adc:	e2870058 	add	r0, r7, #88	; 0x58
8f615ae0:	eb003539 	bl	8f622fcc <mutex_acquire>

	list_for_every_entry(&qseecom.registered_listener_list_head,
8f615ae4:	e5976004 	ldr	r6, [r7, #4]
8f615ae8:	e1560007 	cmp	r6, r7
8f615aec:	0a00000e 	beq	8f615b2c <qseecom_scm_call.constprop.0+0x324>
			entry, struct qseecom_registered_listener_list, node) {
		if (resp->data == entry->svc.listener_id) {
8f615af0:	e5942008 	ldr	r2, [r4, #8]
8f615af4:	ea000002 	b	8f615b04 <qseecom_scm_call.constprop.0+0x2fc>
	list_for_every_entry(&qseecom.registered_listener_list_head,
8f615af8:	e5966004 	ldr	r6, [r6, #4]
8f615afc:	e1560007 	cmp	r6, r7
8f615b00:	0a000009 	beq	8f615b2c <qseecom_scm_call.constprop.0+0x324>
		if (resp->data == entry->svc.listener_id) {
8f615b04:	e5963008 	ldr	r3, [r6, #8]
8f615b08:	e1520003 	cmp	r2, r3
8f615b0c:	1afffff9 	bne	8f615af8 <qseecom_scm_call.constprop.0+0x2f0>
			arch_invalidate_cache_range((addr_t) entry->svc.virt_sb_base, entry->svc.sb_size);
8f615b10:	e1c600dc 	ldrd	r0, [r6, #12]
8f615b14:	eb002d2b 	bl	8f620fc8 <arch_invalidate_cache_range>
			entry->CallbackFn(entry->svc.virt_sb_base, entry->svc.sb_size);
8f615b18:	e286000c 	add	r0, r6, #12
8f615b1c:	e890000b 	ldm	r0, {r0, r1, r3}
8f615b20:	e12fff33 	blx	r3
			arch_clean_invalidate_cache_range((addr_t) entry->svc.virt_sb_base, entry->svc.sb_size);
8f615b24:	e1c600dc 	ldrd	r0, [r6, #12]
8f615b28:	eb002d1c 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
			break;
		}
	}
	send_data_rsp->qsee_cmd_id = QSEE_LISTENER_DATA_RSP_COMMAND;
	send_data_rsp->listener_id  = entry->svc.listener_id;
8f615b2c:	e5963008 	ldr	r3, [r6, #8]
	send_data_rsp->status  = 0;
	mutex_release(&qseecom.global_data_lock);
8f615b30:	e28d603c 	add	r6, r13, #60	; 0x3c
8f615b34:	e59f051c 	ldr	r0, [pc, #1308]	; 8f616058 <qseecom_scm_call.constprop.0+0x850>
	send_data_rsp->listener_id  = entry->svc.listener_id;
8f615b38:	e58d3040 	str	r3, [r13, #64]	; 0x40
	send_data_rsp->qsee_cmd_id = QSEE_LISTENER_DATA_RSP_COMMAND;
8f615b3c:	e3a03007 	mov	r3, #7
8f615b40:	e58d303c 	str	r3, [r13, #60]	; 0x3c
	mutex_release(&qseecom.global_data_lock);
8f615b44:	e58d3010 	str	r3, [r13, #16]
	send_data_rsp->status  = 0;
8f615b48:	e3a03000 	mov	r3, #0
8f615b4c:	e58d3044 	str	r3, [r13, #68]	; 0x44
	mutex_release(&qseecom.global_data_lock);
8f615b50:	eb00356b 	bl	8f623104 <mutex_release>
	return ret;
8f615b54:	eaffff57 	b	8f6158b8 <qseecom_scm_call.constprop.0+0xb0>
				arch_invalidate_cache_range((addr_t) logbuf_req.phy_addr, logbuf_req.len);
8f615b58:	e5971008 	ldr	r1, [r7, #8]
8f615b5c:	eb002d19 	bl	8f620fc8 <arch_invalidate_cache_range>
				QseeLogNewStart = (uint32_t) log->log_pos.offset;
8f615b60:	e59d3014 	ldr	r3, [r13, #20]
	dprintf(SPEW, "%s called\n", __func__);
8f615b64:	e305126c 	movw	r1, #21100	; 0x526c
8f615b68:	e3040890 	movw	r0, #18576	; 0x4890
8f615b6c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f615b70:	e3480f70 	movt	r0, #36720	; 0x8f70
				QseeLogNewStart = (uint32_t) log->log_pos.offset;
8f615b74:	e1d380b2 	ldrh	r8, [r3, #2]
				_disp_log_stats((struct tzdbg_log_t *) logbuf_req.phy_addr,
8f615b78:	e5977004 	ldr	r7, [r7, #4]
	dprintf(SPEW, "%s called\n", __func__);
8f615b7c:	eb00737c 	bl	8f632974 <_dprintf>
	if (startOffset < endOffset)
8f615b80:	e59d300c 	ldr	r3, [r13, #12]
8f615b84:	e1580003 	cmp	r8, r3
8f615b88:	8a00005c 	bhi	8f615d00 <qseecom_scm_call.constprop.0+0x4f8>
	else if ( endOffset < startOffset)
8f615b8c:	2affff7d 	bcs	8f615988 <qseecom_scm_call.constprop.0+0x180>
		LogBufSize =  MaxBufSize - (startOffset - endOffset);
8f615b90:	e59d300c 	ldr	r3, [r13, #12]
8f615b94:	e2633eff 	rsb	r3, r3, #4080	; 0xff0
8f615b98:	e283300c 	add	r3, r3, #12
8f615b9c:	e58d3034 	str	r3, [r13, #52]	; 0x34
8f615ba0:	e0889003 	add	r9, r8, r3
		pLogBuf = malloc(LogBufSize);
8f615ba4:	e1a00009 	mov	r0, r9
8f615ba8:	eb007913 	bl	8f633ffc <malloc>
		if (NULL == pLogBuf)
8f615bac:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f615bb0:	e250a000 	subs	r10, r0, #0
8f615bb4:	0a000120 	beq	8f61603c <qseecom_scm_call.constprop.0+0x834>
		memset(pLogBuf, 0, LogBufSize);
8f615bb8:	e1a02009 	mov	r2, r9
8f615bbc:	e3a01000 	mov	r1, #0
8f615bc0:	e58d3034 	str	r3, [r13, #52]	; 0x34
8f615bc4:	eb0079be 	bl	8f6342c4 <memset>
		memscpy(pLogBuf, LogBufSize, (char *)((uint32_t)log->log_buf + startOffset), LogBufFirstHalf);
8f615bc8:	e59d300c 	ldr	r3, [r13, #12]
8f615bcc:	e2877004 	add	r7, r7, #4
8f615bd0:	e1a01009 	mov	r1, r9
8f615bd4:	e1a0000a 	mov	r0, r10
8f615bd8:	e0872003 	add	r2, r7, r3
8f615bdc:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f615be0:	eb007a1d 	bl	8f63445c <memscpy>
		memscpy((char *)((uint32_t)pLogBuf+ LogBufFirstHalf), (LogBufSize - LogBufFirstHalf), log->log_buf, endOffset);
8f615be4:	e59d100c 	ldr	r1, [r13, #12]
8f615be8:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f615bec:	e1a02007 	mov	r2, r7
8f615bf0:	e2411eff 	sub	r1, r1, #4080	; 0xff0
8f615bf4:	e241100c 	sub	r1, r1, #12
8f615bf8:	e08a0003 	add	r0, r10, r3
8f615bfc:	e0811009 	add	r1, r1, r9
8f615c00:	e1a03008 	mov	r3, r8
8f615c04:	eb007a14 	bl	8f63445c <memscpy>
	while (len < LogBufSize)
8f615c08:	e3590000 	cmp	r9, #0
8f615c0c:	0a00004c 	beq	8f615d44 <qseecom_scm_call.constprop.0+0x53c>
				dprintf(ALWAYS, "%s\n", pPrintPos);
8f615c10:	e30336e0 	movw	r3, #14048	; 0x36e0
8f615c14:	e3483f70 	movt	r3, #36720	; 0x8f70
			ret = GENERIC_ERROR;
8f615c18:	e3a08000 	mov	r8, #0
8f615c1c:	e1a0100a 	mov	r1, r10
				*pCurPos = '\0';
8f615c20:	e1a00003 	mov	r0, r3
			ret = GENERIC_ERROR;
8f615c24:	e1a0700a 	mov	r7, r10
				*pCurPos = '\0';
8f615c28:	e1a03004 	mov	r3, r4
8f615c2c:	e1a02008 	mov	r2, r8
8f615c30:	e1a04000 	mov	r4, r0
8f615c34:	ea000003 	b	8f615c48 <qseecom_scm_call.constprop.0+0x440>
			len++;
8f615c38:	e2888001 	add	r8, r8, #1
			pCurPos++;
8f615c3c:	e2877001 	add	r7, r7, #1
	while (len < LogBufSize)
8f615c40:	e1590008 	cmp	r9, r8
8f615c44:	9a00003d 	bls	8f615d40 <qseecom_scm_call.constprop.0+0x538>
			if ((*pCurPos == '\r')&&(*(pCurPos+1) == '\n'))
8f615c48:	e5d70000 	ldrb	r0, [r7]
8f615c4c:	e350000d 	cmp	r0, #13
8f615c50:	1afffff8 	bne	8f615c38 <qseecom_scm_call.constprop.0+0x430>
8f615c54:	e5d70001 	ldrb	r0, [r7, #1]
8f615c58:	e350000a 	cmp	r0, #10
8f615c5c:	1afffff5 	bne	8f615c38 <qseecom_scm_call.constprop.0+0x430>
				*pCurPos = '\0';
8f615c60:	e5c72000 	strb	r2, [r7]
				pCurPos++;
8f615c64:	e2877002 	add	r7, r7, #2
				*pCurPos = '\0';
8f615c68:	e5472001 	strb	r2, [r7, #-1]
				dprintf(ALWAYS, "%s\n", pPrintPos);
8f615c6c:	e1a00004 	mov	r0, r4
8f615c70:	e58d3034 	str	r3, [r13, #52]	; 0x34
				len++;
8f615c74:	e2888002 	add	r8, r8, #2
				dprintf(ALWAYS, "%s\n", pPrintPos);
8f615c78:	eb00733d 	bl	8f632974 <_dprintf>
				continue;
8f615c7c:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
				pPrintPos = pCurPos;
8f615c80:	e1a01007 	mov	r1, r7
				continue;
8f615c84:	e3a02000 	mov	r2, #0
8f615c88:	eaffffec 	b	8f615c40 <qseecom_scm_call.constprop.0+0x438>
				log = (struct tzdbg_log_t *)logbuf_req.phy_addr;
8f615c8c:	e1a08003 	mov	r8, r3
				arch_invalidate_cache_range((addr_t) logbuf_req.phy_addr, logbuf_req.len);
8f615c90:	e1a00003 	mov	r0, r3
8f615c94:	e5971008 	ldr	r1, [r7, #8]
				log = (struct tzdbg_log_t *)logbuf_req.phy_addr;
8f615c98:	e58d3014 	str	r3, [r13, #20]
				arch_invalidate_cache_range((addr_t) logbuf_req.phy_addr, logbuf_req.len);
8f615c9c:	eb002cc9 	bl	8f620fc8 <arch_invalidate_cache_range>
				QseeLogStart = (uint32_t) log->log_pos.offset;
8f615ca0:	e1d830b2 	ldrh	r3, [r8, #2]
8f615ca4:	e58d300c 	str	r3, [r13, #12]
8f615ca8:	eaffff0a 	b	8f6158d8 <qseecom_scm_call.constprop.0+0xd0>
			if (tz_cmd_id == 1) {
8f615cac:	e35b0001 	cmp	r11, #1
8f615cb0:	0a00000b 	beq	8f615ce4 <qseecom_scm_call.constprop.0+0x4dc>
			} else if (tz_cmd_id == 3) {
8f615cb4:	e35b0003 	cmp	r11, #3
				desc.args[0] = *(uint32_t *)req_buf;
8f615cb8:	058d804c 	streq	r8, [r13, #76]	; 0x4c
				smc_id = TZ_INFO_GET_FEATURE_VERSION_ID;
8f615cbc:	03009603 	movweq	r9, #1539	; 0x603
8f615cc0:	03409200 	movteq	r9, #512	; 0x200
	uint32_t smc_id = 0;
8f615cc4:	13a09000 	movne	r9, #0
				desc.arginfo = TZ_INFO_GET_FEATURE_VERSION_ID_PARAM_ID;
8f615cc8:	03a03001 	moveq	r3, #1
8f615ccc:	058d3048 	streq	r3, [r13, #72]	; 0x48
			ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615cd0:	e28d1048 	add	r1, r13, #72	; 0x48
8f615cd4:	e1a00009 	mov	r0, r9
8f615cd8:	ebfffe71 	bl	8f6156a4 <allocate_extra_arg_buffer>
8f615cdc:	e1a06000 	mov	r6, r0
			break;
8f615ce0:	eaffff10 	b	8f615928 <qseecom_scm_call.constprop.0+0x120>
				desc.args[0] = TZ_INFO_GET_FEATURE_VERSION_ID;
8f615ce4:	e3003603 	movw	r3, #1539	; 0x603
				smc_id = TZ_INFO_IS_SVC_AVAILABLE_ID;
8f615ce8:	e3009601 	movw	r9, #1537	; 0x601
				desc.args[0] = TZ_INFO_GET_FEATURE_VERSION_ID;
8f615cec:	e3403200 	movt	r3, #512	; 0x200
				smc_id = TZ_INFO_IS_SVC_AVAILABLE_ID;
8f615cf0:	e3409200 	movt	r9, #512	; 0x200
				desc.arginfo = TZ_INFO_IS_SVC_AVAILABLE_ID_PARAM_ID;
8f615cf4:	e58db048 	str	r11, [r13, #72]	; 0x48
				desc.args[0] = TZ_INFO_GET_FEATURE_VERSION_ID;
8f615cf8:	e58d304c 	str	r3, [r13, #76]	; 0x4c
8f615cfc:	eafffff3 	b	8f615cd0 <qseecom_scm_call.constprop.0+0x4c8>
		LogBufSize = endOffset - startOffset;
8f615d00:	e0489003 	sub	r9, r8, r3
		pLogBuf = malloc(LogBufSize);
8f615d04:	e1a00009 	mov	r0, r9
8f615d08:	eb0078bb 	bl	8f633ffc <malloc>
		if (NULL == pLogBuf)
8f615d0c:	e250a000 	subs	r10, r0, #0
8f615d10:	0a0000c9 	beq	8f61603c <qseecom_scm_call.constprop.0+0x834>
		memset(pLogBuf, 0, LogBufSize);
8f615d14:	e1a02009 	mov	r2, r9
8f615d18:	e3a01000 	mov	r1, #0
8f615d1c:	eb007968 	bl	8f6342c4 <memset>
		memscpy(pLogBuf, LogBufSize, (char *)((uint32_t)log->log_buf + startOffset), LogBufSize);
8f615d20:	e59d300c 	ldr	r3, [r13, #12]
8f615d24:	e2872004 	add	r2, r7, #4
8f615d28:	e1a01009 	mov	r1, r9
8f615d2c:	e0822003 	add	r2, r2, r3
8f615d30:	e1a0000a 	mov	r0, r10
8f615d34:	e1a03009 	mov	r3, r9
8f615d38:	eb0079c7 	bl	8f63445c <memscpy>
	while (len < LogBufSize)
8f615d3c:	eaffffb3 	b	8f615c10 <qseecom_scm_call.constprop.0+0x408>
8f615d40:	e1a04003 	mov	r4, r3
	free(pLogBuf);
8f615d44:	e1a0000a 	mov	r0, r10
8f615d48:	eb0078ef 	bl	8f63410c <free>
8f615d4c:	eaffff0d 	b	8f615988 <qseecom_scm_call.constprop.0+0x180>
				if(((resp->resp_type != QSEOS_APP_ID) || (resp->data <= 0)) &&
8f615d50:	e5943008 	ldr	r3, [r4, #8]
8f615d54:	e3530000 	cmp	r3, #0
8f615d58:	0affff46 	beq	8f615a78 <qseecom_scm_call.constprop.0+0x270>
8f615d5c:	eaffff18 	b	8f6159c4 <qseecom_scm_call.constprop.0+0x1bc>
					dprintf(CRITICAL, "qseos_cmd_id 0x%d is not supported by armv8 scm_call2.\n",
8f615d60:	e1a01008 	mov	r1, r8
8f615d64:	e30409d8 	movw	r0, #18904	; 0x49d8
8f615d68:	e3480f70 	movt	r0, #36720	; 0x8f70
	uint32_t smc_id = 0;
8f615d6c:	e3a09000 	mov	r9, #0
					dprintf(CRITICAL, "qseos_cmd_id 0x%d is not supported by armv8 scm_call2.\n",
8f615d70:	eb0072ff 	bl	8f632974 <_dprintf>
					ret = GENERIC_ERROR;
8f615d74:	e3e06000 	mvn	r6, #0
					break;
8f615d78:	eafffeea 	b	8f615928 <qseecom_scm_call.constprop.0+0x120>
					desc.arginfo =
8f615d7c:	e3a03002 	mov	r3, #2
8f615d80:	e58d3048 	str	r3, [r13, #72]	; 0x48
					desc.args[0] = req->listener_id;
8f615d84:	e5963004 	ldr	r3, [r6, #4]
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615d88:	e28d1048 	add	r1, r13, #72	; 0x48
8f615d8c:	e59d9024 	ldr	r9, [r13, #36]	; 0x24
					desc.args[0] = req->listener_id;
8f615d90:	e58d304c 	str	r3, [r13, #76]	; 0x4c
					desc.args[1] = req->status;
8f615d94:	e5963008 	ldr	r3, [r6, #8]
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615d98:	e1a00009 	mov	r0, r9
					desc.args[1] = req->status;
8f615d9c:	e58d3050 	str	r3, [r13, #80]	; 0x50
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615da0:	ebfffe3f 	bl	8f6156a4 <allocate_extra_arg_buffer>
8f615da4:	e1a06000 	mov	r6, r0
					break;
8f615da8:	eafffede 	b	8f615928 <qseecom_scm_call.constprop.0+0x120>
					desc.arginfo = TZ_OS_LOAD_SERVICES_IMAGE_ID_PARAM_ID;
8f615dac:	e3a03003 	mov	r3, #3
8f615db0:	e58d3048 	str	r3, [r13, #72]	; 0x48
					desc.args[0] = req->mdt_len;
8f615db4:	e5961004 	ldr	r1, [r6, #4]
					dprintf(SPEW, "QSEE_LOAD_SERV_IMAGE_COMMAND mdt_len:%u img_len:%u phy_addr:%u\n",
8f615db8:	e3040998 	movw	r0, #18840	; 0x4998
8f615dbc:	e3480f70 	movt	r0, #36720	; 0x8f70
					smc_id = TZ_OS_LOAD_SERVICES_IMAGE_ID;
8f615dc0:	e3009107 	movw	r9, #263	; 0x107
8f615dc4:	e3439200 	movt	r9, #12800	; 0x3200
					desc.args[0] = req->mdt_len;
8f615dc8:	e58d104c 	str	r1, [r13, #76]	; 0x4c
					desc.args[1] = req->img_len;
8f615dcc:	e5962008 	ldr	r2, [r6, #8]
8f615dd0:	e58d2050 	str	r2, [r13, #80]	; 0x50
					desc.args[2] = req->phy_addr;
8f615dd4:	e596300c 	ldr	r3, [r6, #12]
8f615dd8:	e58d3054 	str	r3, [r13, #84]	; 0x54
					dprintf(SPEW, "QSEE_LOAD_SERV_IMAGE_COMMAND mdt_len:%u img_len:%u phy_addr:%u\n",
8f615ddc:	eb0072e4 	bl	8f632974 <_dprintf>
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615de0:	e28d1048 	add	r1, r13, #72	; 0x48
8f615de4:	e3000107 	movw	r0, #263	; 0x107
8f615de8:	e3430200 	movt	r0, #12800	; 0x3200
8f615dec:	ebfffe2c 	bl	8f6156a4 <allocate_extra_arg_buffer>
8f615df0:	e1a06000 	mov	r6, r0
					break;
8f615df4:	eafffecb 	b	8f615928 <qseecom_scm_call.constprop.0+0x120>
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615df8:	e28d1048 	add	r1, r13, #72	; 0x48
8f615dfc:	e3a00f42 	mov	r0, #264	; 0x108
8f615e00:	e3430200 	movt	r0, #12800	; 0x3200
					desc.arginfo = TZ_OS_UNLOAD_SERVICES_IMAGE_ID_PARAM_ID;
8f615e04:	e3a03000 	mov	r3, #0
8f615e08:	e58d3048 	str	r3, [r13, #72]	; 0x48
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615e0c:	ebfffe24 	bl	8f6156a4 <allocate_extra_arg_buffer>
					smc_id = TZ_OS_UNLOAD_SERVICES_IMAGE_ID;
8f615e10:	e3a09f42 	mov	r9, #264	; 0x108
8f615e14:	e3439200 	movt	r9, #12800	; 0x3200
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615e18:	e1a06000 	mov	r6, r0
					break;
8f615e1c:	eafffec1 	b	8f615928 <qseecom_scm_call.constprop.0+0x120>
					desc.arginfo =
8f615e20:	e3a03022 	mov	r3, #34	; 0x22
8f615e24:	e58d3048 	str	r3, [r13, #72]	; 0x48
					desc.args[0] = req->addr;
8f615e28:	e5963004 	ldr	r3, [r6, #4]
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615e2c:	e28d1048 	add	r1, r13, #72	; 0x48
8f615e30:	e3000105 	movw	r0, #261	; 0x105
8f615e34:	e3430200 	movt	r0, #12800	; 0x3200
					smc_id = TZ_OS_APP_REGION_NOTIFICATION_ID;
8f615e38:	e3009105 	movw	r9, #261	; 0x105
8f615e3c:	e3439200 	movt	r9, #12800	; 0x3200
					desc.args[0] = req->addr;
8f615e40:	e58d304c 	str	r3, [r13, #76]	; 0x4c
					desc.args[1] = req->size;
8f615e44:	e5963008 	ldr	r3, [r6, #8]
8f615e48:	e58d3050 	str	r3, [r13, #80]	; 0x50
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615e4c:	ebfffe14 	bl	8f6156a4 <allocate_extra_arg_buffer>
8f615e50:	e1a06000 	mov	r6, r0
					break;
8f615e54:	eafffeb3 	b	8f615928 <qseecom_scm_call.constprop.0+0x120>
					desc.arginfo = TZ_OS_REGISTER_LOG_BUFFER_ID_PARAM_ID;
8f615e58:	e3a03022 	mov	r3, #34	; 0x22
8f615e5c:	e58d3048 	str	r3, [r13, #72]	; 0x48
					desc.args[0] = req->phy_addr;
8f615e60:	e5963004 	ldr	r3, [r6, #4]
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615e64:	e28d1048 	add	r1, r13, #72	; 0x48
8f615e68:	e59d902c 	ldr	r9, [r13, #44]	; 0x2c
					desc.args[0] = req->phy_addr;
8f615e6c:	e58d304c 	str	r3, [r13, #76]	; 0x4c
					desc.args[1] = req->len;
8f615e70:	e5963008 	ldr	r3, [r6, #8]
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615e74:	e1a00009 	mov	r0, r9
					desc.args[1] = req->len;
8f615e78:	e58d3050 	str	r3, [r13, #80]	; 0x50
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615e7c:	ebfffe08 	bl	8f6156a4 <allocate_extra_arg_buffer>
8f615e80:	e1a06000 	mov	r6, r0
					break;
8f615e84:	eafffea7 	b	8f615928 <qseecom_scm_call.constprop.0+0x120>
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615e88:	e59d9020 	ldr	r9, [r13, #32]
					desc.arginfo = TZ_OS_RPMB_PROVISION_KEY_ID_PARAM_ID;
8f615e8c:	e3a03001 	mov	r3, #1
8f615e90:	e58d3048 	str	r3, [r13, #72]	; 0x48
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615e94:	e28d1048 	add	r1, r13, #72	; 0x48
					desc.args[0] = req->key_type;
8f615e98:	e5963004 	ldr	r3, [r6, #4]
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615e9c:	e1a00009 	mov	r0, r9
					desc.args[0] = req->key_type;
8f615ea0:	e58d304c 	str	r3, [r13, #76]	; 0x4c
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615ea4:	ebfffdfe 	bl	8f6156a4 <allocate_extra_arg_buffer>
8f615ea8:	e1a06000 	mov	r6, r0
					break;
8f615eac:	eafffe9d 	b	8f615928 <qseecom_scm_call.constprop.0+0x120>
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615eb0:	e59d901c 	ldr	r9, [r13, #28]
8f615eb4:	e28d1048 	add	r1, r13, #72	; 0x48
					desc.arginfo = TZ_OS_RPMB_ERASE_ID_PARAM_ID;
8f615eb8:	e3a03000 	mov	r3, #0
8f615ebc:	e58d3048 	str	r3, [r13, #72]	; 0x48
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615ec0:	e1a00009 	mov	r0, r9
8f615ec4:	ebfffdf6 	bl	8f6156a4 <allocate_extra_arg_buffer>
8f615ec8:	e1a06000 	mov	r6, r0
					break;
8f615ecc:	eafffe95 	b	8f615928 <qseecom_scm_call.constprop.0+0x120>
					desc.arginfo = TZ_OS_APP_SHUTDOWN_ID_PARAM_ID;
8f615ed0:	e3a03001 	mov	r3, #1
8f615ed4:	e58d3048 	str	r3, [r13, #72]	; 0x48
					desc.args[0] = req->app_id;
8f615ed8:	e5963004 	ldr	r3, [r6, #4]
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615edc:	e28d1048 	add	r1, r13, #72	; 0x48
8f615ee0:	e3000102 	movw	r0, #258	; 0x102
8f615ee4:	e3430200 	movt	r0, #12800	; 0x3200
					smc_id = TZ_OS_APP_SHUTDOWN_ID;
8f615ee8:	e3009102 	movw	r9, #258	; 0x102
8f615eec:	e3439200 	movt	r9, #12800	; 0x3200
					desc.args[0] = req->app_id;
8f615ef0:	e58d304c 	str	r3, [r13, #76]	; 0x4c
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615ef4:	ebfffdea 	bl	8f6156a4 <allocate_extra_arg_buffer>
8f615ef8:	e1a06000 	mov	r6, r0
					break;
8f615efc:	eafffe89 	b	8f615928 <qseecom_scm_call.constprop.0+0x120>
					desc.arginfo =
8f615f00:	e3a03083 	mov	r3, #131	; 0x83
8f615f04:	e58d3048 	str	r3, [r13, #72]	; 0x48
					desc.args[0] = req->listener_id;
8f615f08:	e5963004 	ldr	r3, [r6, #4]
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615f0c:	e28d1048 	add	r1, r13, #72	; 0x48
8f615f10:	e59d9030 	ldr	r9, [r13, #48]	; 0x30
					desc.args[0] = req->listener_id;
8f615f14:	e58d304c 	str	r3, [r13, #76]	; 0x4c
					desc.args[1] = req->sb_ptr;
8f615f18:	e5963008 	ldr	r3, [r6, #8]
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615f1c:	e1a00009 	mov	r0, r9
					desc.args[1] = req->sb_ptr;
8f615f20:	e58d3050 	str	r3, [r13, #80]	; 0x50
					desc.args[2] = req->sb_len;
8f615f24:	e596300c 	ldr	r3, [r6, #12]
8f615f28:	e58d3054 	str	r3, [r13, #84]	; 0x54
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615f2c:	ebfffddc 	bl	8f6156a4 <allocate_extra_arg_buffer>
8f615f30:	e1a06000 	mov	r6, r0
					break;
8f615f34:	eafffe7b 	b	8f615928 <qseecom_scm_call.constprop.0+0x120>
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615f38:	e59d9028 	ldr	r9, [r13, #40]	; 0x28
					desc.arginfo = TZ_OS_DEREGISTER_LISTENER_ID_PARAM_ID;
8f615f3c:	e3a03001 	mov	r3, #1
8f615f40:	e58d3048 	str	r3, [r13, #72]	; 0x48
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615f44:	e28d1048 	add	r1, r13, #72	; 0x48
					desc.args[0] = req->listener_id;
8f615f48:	e5963004 	ldr	r3, [r6, #4]
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615f4c:	e1a00009 	mov	r0, r9
					desc.args[0] = req->listener_id;
8f615f50:	e58d304c 	str	r3, [r13, #76]	; 0x4c
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615f54:	ebfffdd2 	bl	8f6156a4 <allocate_extra_arg_buffer>
8f615f58:	e1a06000 	mov	r6, r0
					break;
8f615f5c:	eafffe71 	b	8f615928 <qseecom_scm_call.constprop.0+0x120>
					desc.arginfo = TZ_APP_QSAPP_SEND_DATA_ID_PARAM_ID;
8f615f60:	e3003885 	movw	r3, #2181	; 0x885
8f615f64:	e58d3048 	str	r3, [r13, #72]	; 0x48
					desc.args[0] = req->app_id;
8f615f68:	e5963004 	ldr	r3, [r6, #4]
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615f6c:	e28d1048 	add	r1, r13, #72	; 0x48
8f615f70:	e3a00213 	mov	r0, #805306369	; 0x30000001
					smc_id = TZ_APP_QSAPP_SEND_DATA_ID;
8f615f74:	e3a09213 	mov	r9, #805306369	; 0x30000001
					desc.args[0] = req->app_id;
8f615f78:	e58d304c 	str	r3, [r13, #76]	; 0x4c
					desc.args[1] = req->req_ptr;
8f615f7c:	e5963008 	ldr	r3, [r6, #8]
8f615f80:	e58d3050 	str	r3, [r13, #80]	; 0x50
					desc.args[2] = req->req_len;
8f615f84:	e596300c 	ldr	r3, [r6, #12]
8f615f88:	e58d3054 	str	r3, [r13, #84]	; 0x54
					desc.args[3] = req->rsp_ptr;
8f615f8c:	e5963010 	ldr	r3, [r6, #16]
8f615f90:	e58d3058 	str	r3, [r13, #88]	; 0x58
					desc.args[4] = req->rsp_len;
8f615f94:	e5963014 	ldr	r3, [r6, #20]
8f615f98:	e58d305c 	str	r3, [r13, #92]	; 0x5c
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615f9c:	ebfffdc0 	bl	8f6156a4 <allocate_extra_arg_buffer>
8f615fa0:	e1a06000 	mov	r6, r0
					break;
8f615fa4:	eafffe5f 	b	8f615928 <qseecom_scm_call.constprop.0+0x120>
					desc.arginfo = TZ_OS_APP_START_ID_PARAM_ID;
8f615fa8:	e3a03003 	mov	r3, #3
8f615fac:	e58d3048 	str	r3, [r13, #72]	; 0x48
					desc.args[0] = req->mdt_len;
8f615fb0:	e5961004 	ldr	r1, [r6, #4]
					dprintf(SPEW, "args[0]:%u args[1]:%u args[2]:%u\n",
8f615fb4:	e3040950 	movw	r0, #18768	; 0x4950
8f615fb8:	e3480f70 	movt	r0, #36720	; 0x8f70
					smc_id = TZ_OS_APP_START_ID;
8f615fbc:	e3009101 	movw	r9, #257	; 0x101
8f615fc0:	e3439200 	movt	r9, #12800	; 0x3200
					desc.args[0] = req->mdt_len;
8f615fc4:	e58d104c 	str	r1, [r13, #76]	; 0x4c
					desc.args[1] = req->img_len;
8f615fc8:	e5962008 	ldr	r2, [r6, #8]
8f615fcc:	e58d2050 	str	r2, [r13, #80]	; 0x50
					desc.args[2] = req->phy_addr;
8f615fd0:	e596300c 	ldr	r3, [r6, #12]
8f615fd4:	e58d3054 	str	r3, [r13, #84]	; 0x54
					dprintf(SPEW, "args[0]:%u args[1]:%u args[2]:%u\n",
8f615fd8:	eb007265 	bl	8f632974 <_dprintf>
					dprintf(SPEW, "mdt_len:%u img_len:%u phy_addr:%u\n",
8f615fdc:	e596300c 	ldr	r3, [r6, #12]
8f615fe0:	e3040974 	movw	r0, #18804	; 0x4974
8f615fe4:	e5962008 	ldr	r2, [r6, #8]
8f615fe8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f615fec:	e5961004 	ldr	r1, [r6, #4]
8f615ff0:	eb00725f 	bl	8f632974 <_dprintf>
					ret = allocate_extra_arg_buffer(smc_id, &desc);
8f615ff4:	e28d1048 	add	r1, r13, #72	; 0x48
8f615ff8:	e3000101 	movw	r0, #257	; 0x101
8f615ffc:	e3430200 	movt	r0, #12800	; 0x3200
8f616000:	ebfffda7 	bl	8f6156a4 <allocate_extra_arg_buffer>
8f616004:	e1a06000 	mov	r6, r0
					break;
8f616008:	eafffe46 	b	8f615928 <qseecom_scm_call.constprop.0+0x120>
			dprintf(CRITICAL, "ERROR: scm_call to load failed : ret %d\n", ret);
8f61600c:	e1a01006 	mov	r1, r6
8f616010:	e3040b14 	movw	r0, #19220	; 0x4b14
8f616014:	e3480f70 	movt	r0, #36720	; 0x8f70
			ret = GENERIC_ERROR;
8f616018:	e3e06000 	mvn	r6, #0
			dprintf(CRITICAL, "ERROR: scm_call to load failed : ret %d\n", ret);
8f61601c:	eb007254 	bl	8f632974 <_dprintf>
			goto err;
8f616020:	eafffe67 	b	8f6159c4 <qseecom_scm_call.constprop.0+0x1bc>
					dprintf(CRITICAL, "Listener service incorrect resp->result:%d resp->resp_type:%d\n",
8f616024:	e3040b98 	movw	r0, #19352	; 0x4b98
8f616028:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61602c:	eb007250 	bl	8f632974 <_dprintf>
					ret = GENERIC_ERROR;
8f616030:	e3e06000 	mvn	r6, #0
					goto err;
8f616034:	eafffe62 	b	8f6159c4 <qseecom_scm_call.constprop.0+0x1bc>
}
8f616038:	eb0072e0 	bl	8f632bc0 <__stack_chk_fail>
			dprintf(CRITICAL, "Failed to alloc buffer to print TZ Log:%u\n", LogBufSize);
8f61603c:	e1a01009 	mov	r1, r9
8f616040:	e3040ae8 	movw	r0, #19176	; 0x4ae8
8f616044:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616048:	eb007249 	bl	8f632974 <_dprintf>
			goto err;
8f61604c:	eafffe4d 	b	8f615988 <qseecom_scm_call.constprop.0+0x180>
8f616050:	8f74221c 	.word	0x8f74221c
8f616054:	8f72d100 	.word	0x8f72d100
8f616058:	8f72d12c 	.word	0x8f72d12c

8f61605c <qseecom_load_commonlib_image>:
		free(buf);
	return ret;
}

static int qseecom_load_commonlib_image(char * app_name)
{
8f61605c:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f616060:	e24dd04c 	sub	r13, r13, #76	; 0x4c
8f616064:	e59f31b8 	ldr	r3, [pc, #440]	; 8f616224 <qseecom_load_commonlib_image+0x1c8>
	unsigned long long ptn = 0;
	unsigned long long size = 0;
	unsigned  long rounded_size = 0;
	void *buf = NULL;
	void *req = NULL;
	struct qseecom_load_app_ireq load_req = {0};
8f616068:	e3a02030 	mov	r2, #48	; 0x30
{
8f61606c:	e1a06000 	mov	r6, r0
	struct qseecom_load_app_ireq load_req = {0};
8f616070:	e3a01000 	mov	r1, #0
8f616074:	e28d0014 	add	r0, r13, #20
{
8f616078:	e5933000 	ldr	r3, [r3]
8f61607c:	e58d3044 	str	r3, [r13, #68]	; 0x44
8f616080:	e3a03000 	mov	r3, #0
	struct qseecom_load_app_ireq load_req = {0};
8f616084:	eb00788e 	bl	8f6342c4 <memset>
	struct qseecom_command_scm_resp resp = {0};
	int ret = GENERIC_ERROR;
	uint8_t lun = 0;

	dprintf(SPEW, "%s called\n", __func__);
8f616088:	e30512dc 	movw	r1, #21212	; 0x52dc
8f61608c:	e3040890 	movw	r0, #18576	; 0x4890
8f616090:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616094:	e3480f70 	movt	r0, #36720	; 0x8f70
	struct qseecom_command_scm_resp resp = {0};
8f616098:	e3a03000 	mov	r3, #0
8f61609c:	e58d3008 	str	r3, [r13, #8]
8f6160a0:	e58d300c 	str	r3, [r13, #12]
8f6160a4:	e58d3010 	str	r3, [r13, #16]
	dprintf(SPEW, "%s called\n", __func__);
8f6160a8:	eb007231 	bl	8f632974 <_dprintf>
	index = partition_get_index(app_name);
8f6160ac:	e1a00006 	mov	r0, r6
8f6160b0:	ebffb6f5 	bl	8f603c8c <partition_get_index>
8f6160b4:	e1a07000 	mov	r7, r0
	lun = partition_get_lun(index);
8f6160b8:	ebffba20 	bl	8f604940 <partition_get_lun>
	mmc_set_lun(lun);
8f6160bc:	ebffdcdc 	bl	8f60d434 <mmc_set_lun>

	size = partition_get_size(index);
8f6160c0:	e1a00007 	mov	r0, r7
8f6160c4:	ebffb9db 	bl	8f604838 <partition_get_size>
	if (MAX_TA_PARTITION_SIZE < size) {
8f6160c8:	e2703601 	rsbs	r3, r0, #1048576	; 0x100000
8f6160cc:	e2f13000 	rscs	r3, r1, #0
8f6160d0:	3a000045 	bcc	8f6161ec <qseecom_load_commonlib_image+0x190>
		dprintf(CRITICAL, "Invalid cmnlib partition size!");
		ret = GENERIC_ERROR;
		goto err;
	}
	rounded_size = ROUNDUP(size, PAGE_SIZE);
8f6160d4:	e2801eff 	add	r1, r0, #4080	; 0xff0
8f6160d8:	e1a04000 	mov	r4, r0
8f6160dc:	e281100f 	add	r1, r1, #15
	buf = memalign(PAGE_SIZE, rounded_size);
8f6160e0:	e3a00a01 	mov	r0, #4096	; 0x1000
8f6160e4:	e3c11eff 	bic	r1, r1, #4080	; 0xff0
8f6160e8:	e3c1100f 	bic	r1, r1, #15
8f6160ec:	eb0077d4 	bl	8f634044 <memalign>
	if (!buf) {
8f6160f0:	e2505000 	subs	r5, r0, #0
8f6160f4:	0a000041 	beq	8f616200 <qseecom_load_commonlib_image+0x1a4>
				__func__, app_name);
		ret = GENERIC_ERROR;
		goto err;
	}

	ptn = partition_get_offset(index);
8f6160f8:	e1a00007 	mov	r0, r7
8f6160fc:	ebffb9ee 	bl	8f6048bc <partition_get_offset>
	if(ptn == 0) {
8f616100:	e1903001 	orrs	r3, r0, r1
8f616104:	0a000032 	beq	8f6161d4 <qseecom_load_commonlib_image+0x178>
		dprintf(CRITICAL, "ERROR: No %s found\n", app_name);
		ret = GENERIC_ERROR;
		goto err;
	}
	if (mmc_read(ptn, (unsigned int *) buf, size)) {
8f616108:	e1a03004 	mov	r3, r4
8f61610c:	e1a02005 	mov	r2, r5
8f616110:	ebffdadc 	bl	8f60cc88 <mmc_read>
8f616114:	e2507000 	subs	r7, r0, #0
8f616118:	1a000027 	bne	8f6161bc <qseecom_load_commonlib_image+0x160>
	dprintf(SPEW, "%s called\n", __func__);
8f61611c:	e30512c0 	movw	r1, #21184	; 0x52c0
8f616120:	e3040890 	movw	r0, #18576	; 0x4890
8f616124:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616128:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61612c:	eb007210 	bl	8f632974 <_dprintf>
	return (uint32_t)platform_get_virt_to_phys_mapping((addr_t)virt);
8f616130:	e1a00005 	mov	r0, r5
8f616134:	ebffad86 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	load_req.phy_addr = (uint32_t)__qseecom_uvirt_to_kphys((uint32_t) buf);
	load_req.qsee_cmd_id = QSEE_LOAD_SERV_IMAGE_COMMAND;
	load_req.img_len = size;
	load_req.mdt_len = 0;

	memscpy(load_req.app_name, MAX_APP_NAME_SIZE, app_name, MAX_APP_NAME_SIZE);
8f616138:	e3a03020 	mov	r3, #32
8f61613c:	e1a01003 	mov	r1, r3
8f616140:	e1a02006 	mov	r2, r6
	load_req.qsee_cmd_id = QSEE_LOAD_SERV_IMAGE_COMMAND;
8f616144:	e3a0c00b 	mov	r12, #11
	load_req.img_len = size;
8f616148:	e58d401c 	str	r4, [r13, #28]
	load_req.qsee_cmd_id = QSEE_LOAD_SERV_IMAGE_COMMAND;
8f61614c:	e58dc014 	str	r12, [r13, #20]
	load_req.mdt_len = 0;
8f616150:	e58d7018 	str	r7, [r13, #24]
	load_req.phy_addr = (uint32_t)__qseecom_uvirt_to_kphys((uint32_t) buf);
8f616154:	e58d0020 	str	r0, [r13, #32]
	memscpy(load_req.app_name, MAX_APP_NAME_SIZE, app_name, MAX_APP_NAME_SIZE);
8f616158:	e28d0024 	add	r0, r13, #36	; 0x24
8f61615c:	eb0078be 	bl	8f63445c <memscpy>
	req = (void *)&load_req;

	arch_clean_invalidate_cache_range((addr_t) load_req.phy_addr, load_req.img_len);
8f616160:	e59d101c 	ldr	r1, [r13, #28]
8f616164:	e59d0020 	ldr	r0, [r13, #32]
8f616168:	eb002b8c 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	ret = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1, req,
8f61616c:	e28d0008 	add	r0, r13, #8
8f616170:	e28d2014 	add	r2, r13, #20
8f616174:	e58d0000 	str	r0, [r13]
8f616178:	e3a03010 	mov	r3, #16
8f61617c:	e3a01001 	mov	r1, #1
8f616180:	e3a000fc 	mov	r0, #252	; 0xfc
8f616184:	ebfffd9f 	bl	8f615808 <qseecom_scm_call.constprop.0>
				sizeof(struct qseecom_load_lib_image_ireq),
							&resp, sizeof(resp));
	if(ret == 0)
8f616188:	e2504000 	subs	r4, r0, #0
		ret = resp.data;
8f61618c:	059d4010 	ldreq	r4, [r13, #16]

err:
	if (buf)
		free(buf);
8f616190:	e1a00005 	mov	r0, r5
8f616194:	eb0077dc 	bl	8f63410c <free>
	return ret;
}
8f616198:	e59f3084 	ldr	r3, [pc, #132]	; 8f616224 <qseecom_load_commonlib_image+0x1c8>
8f61619c:	e5932000 	ldr	r2, [r3]
8f6161a0:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f6161a4:	e0332002 	eors	r2, r3, r2
8f6161a8:	e3a03000 	mov	r3, #0
8f6161ac:	1a00001b 	bne	8f616220 <qseecom_load_commonlib_image+0x1c4>
8f6161b0:	e1a00004 	mov	r0, r4
8f6161b4:	e28dd04c 	add	r13, r13, #76	; 0x4c
8f6161b8:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		dprintf(CRITICAL, "ERROR: Cannot read %s image\n", app_name);
8f6161bc:	e1a01006 	mov	r1, r6
8f6161c0:	e3040c54 	movw	r0, #19540	; 0x4c54
8f6161c4:	e3480f70 	movt	r0, #36720	; 0x8f70
		ret = GENERIC_ERROR;
8f6161c8:	e3e04000 	mvn	r4, #0
		dprintf(CRITICAL, "ERROR: Cannot read %s image\n", app_name);
8f6161cc:	eb0071e8 	bl	8f632974 <_dprintf>
		goto err;
8f6161d0:	eaffffee 	b	8f616190 <qseecom_load_commonlib_image+0x134>
		dprintf(CRITICAL, "ERROR: No %s found\n", app_name);
8f6161d4:	e1a01006 	mov	r1, r6
8f6161d8:	e3040c40 	movw	r0, #19520	; 0x4c40
8f6161dc:	e3480f70 	movt	r0, #36720	; 0x8f70
		ret = GENERIC_ERROR;
8f6161e0:	e3e04000 	mvn	r4, #0
		dprintf(CRITICAL, "ERROR: No %s found\n", app_name);
8f6161e4:	eb0071e2 	bl	8f632974 <_dprintf>
		goto err;
8f6161e8:	eaffffe8 	b	8f616190 <qseecom_load_commonlib_image+0x134>
		dprintf(CRITICAL, "Invalid cmnlib partition size!");
8f6161ec:	e3040c00 	movw	r0, #19456	; 0x4c00
8f6161f0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6161f4:	eb0071de 	bl	8f632974 <_dprintf>
		ret = GENERIC_ERROR;
8f6161f8:	e3e04000 	mvn	r4, #0
8f6161fc:	eaffffe5 	b	8f616198 <qseecom_load_commonlib_image+0x13c>
		dprintf(CRITICAL, "%s: Aloc failed for %s image\n",
8f616200:	e1a02006 	mov	r2, r6
8f616204:	e30512dc 	movw	r1, #21212	; 0x52dc
8f616208:	e3040c20 	movw	r0, #19488	; 0x4c20
8f61620c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616210:	e3480f70 	movt	r0, #36720	; 0x8f70
		ret = GENERIC_ERROR;
8f616214:	e3e04000 	mvn	r4, #0
		dprintf(CRITICAL, "%s: Aloc failed for %s image\n",
8f616218:	eb0071d5 	bl	8f632974 <_dprintf>
	if (buf)
8f61621c:	eaffffdd 	b	8f616198 <qseecom_load_commonlib_image+0x13c>
}
8f616220:	eb007266 	bl	8f632bc0 <__stack_chk_fail>
8f616224:	8f74221c 	.word	0x8f74221c

8f616228 <qseecom_start_app>:
*   Success:	handle to be used for all calls to
*   			Secure app. Always greater than zero.
*   Failure:	Error code (negative only).
*/
int qseecom_start_app(char *app_name)
{
8f616228:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
	int32_t ret = GENERIC_ERROR;
	int handle = 0;
	struct qseecom_registered_app_list *entry = NULL;
	unsigned int app_id = 0;

	if (!app_name) {
8f61622c:	e2505000 	subs	r5, r0, #0
{
8f616230:	e59f3464 	ldr	r3, [pc, #1124]	; 8f61669c <qseecom_start_app+0x474>
8f616234:	e24dd048 	sub	r13, r13, #72	; 0x48
		dprintf(CRITICAL, "%s: Input error\n", __func__);
8f616238:	e3051318 	movw	r1, #21272	; 0x5318
{
8f61623c:	e5933000 	ldr	r3, [r3]
8f616240:	e58d3044 	str	r3, [r13, #68]	; 0x44
8f616244:	e3a03000 	mov	r3, #0
	if (!app_name) {
8f616248:	0a0000f3 	beq	8f61661c <qseecom_start_app+0x3f4>
		goto err;
	}
	dprintf(SPEW, "%s called\n", __func__);
8f61624c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616250:	e3040890 	movw	r0, #18576	; 0x4890


	mutex_acquire(&qseecom.global_data_lock);
8f616254:	e30d60d4 	movw	r6, #53460	; 0xd0d4
	dprintf(SPEW, "%s called\n", __func__);
8f616258:	e3480f70 	movt	r0, #36720	; 0x8f70
	mutex_acquire(&qseecom.global_data_lock);
8f61625c:	e3486f72 	movt	r6, #36722	; 0x8f72
	dprintf(SPEW, "%s called\n", __func__);
8f616260:	eb0071c3 	bl	8f632974 <_dprintf>
	mutex_acquire(&qseecom.global_data_lock);
8f616264:	e2860058 	add	r0, r6, #88	; 0x58
8f616268:	eb003357 	bl	8f622fcc <mutex_acquire>
	if ((!qseecom.qseecom_init_done)
8f61626c:	e5963078 	ldr	r3, [r6, #120]	; 0x78
8f616270:	e3530000 	cmp	r3, #0
8f616274:	0a0000df 	beq	8f6165f8 <qseecom_start_app+0x3d0>
			|| (!qseecom.qseecom_tz_init_done)){
8f616278:	e596307c 	ldr	r3, [r6, #124]	; 0x7c
8f61627c:	e3530000 	cmp	r3, #0
8f616280:	0a0000dc 	beq	8f6165f8 <qseecom_start_app+0x3d0>
		dprintf(CRITICAL, "%s qseecom_init not done\n",
							__func__);
		mutex_release(&qseecom.global_data_lock);
		return ret;
	}
	mutex_release(&qseecom.global_data_lock);
8f616284:	e2860058 	add	r0, r6, #88	; 0x58
8f616288:	eb00339d 	bl	8f623104 <mutex_release>
	/* Load commonlib image*/
	if (!qseecom.cmnlib_loaded) {
8f61628c:	e5963074 	ldr	r3, [r6, #116]	; 0x74
8f616290:	e3530000 	cmp	r3, #0
8f616294:	1a000011 	bne	8f6162e0 <qseecom_start_app+0xb8>
		ret = qseecom_load_commonlib_image("cmnlib");
8f616298:	e3040cb8 	movw	r0, #19640	; 0x4cb8
8f61629c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6162a0:	ebffff6d 	bl	8f61605c <qseecom_load_commonlib_image>
		if (ret) {
8f6162a4:	e2507000 	subs	r7, r0, #0
8f6162a8:	1a0000b1 	bne	8f616574 <qseecom_start_app+0x34c>
			dprintf(CRITICAL, "%s qseecom_load_commonlib_image failed with status:%d\n",
					__func__, ret);
			goto err;
		}
                dprintf(DEBUG, "Loading cmnlib done\n");
8f6162ac:	e3040cf8 	movw	r0, #19704	; 0x4cf8
8f6162b0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6162b4:	eb0071ae 	bl	8f632974 <_dprintf>
#if ENABLE_CMNLIB64_LOADING
                ret = qseecom_load_commonlib_image("cmnlib64");
8f6162b8:	e3040d10 	movw	r0, #19728	; 0x4d10
8f6162bc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6162c0:	ebffff65 	bl	8f61605c <qseecom_load_commonlib_image>
                if (ret) {
8f6162c4:	e2507000 	subs	r7, r0, #0
8f6162c8:	1a0000a9 	bne	8f616574 <qseecom_start_app+0x34c>
                        dprintf(CRITICAL, "%s qseecom_load_commonlib_image failed with status:%d\n",
                                        __func__, ret);
                        goto err;
                }
                dprintf(DEBUG, "Loading cmnlib64 done\n");
8f6162cc:	e3040d1c 	movw	r0, #19740	; 0x4d1c
8f6162d0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6162d4:	eb0071a6 	bl	8f632974 <_dprintf>
#endif
		qseecom.cmnlib_loaded = 1;
8f6162d8:	e3a03001 	mov	r3, #1
8f6162dc:	e5863074 	str	r3, [r6, #116]	; 0x74
	/* Check if App already exits, if exits increase ref_cnt
	 * and return handle, else load the app from partition,
	 * call into TZ to load it, add to list and then return
	 * handle.
	 */
	mutex_acquire(&qseecom.global_data_lock);
8f6162e0:	e59f03b8 	ldr	r0, [pc, #952]	; 8f6166a0 <qseecom_start_app+0x478>
	list_for_every_entry(&qseecom.registered_app_list_head,
8f6162e4:	e2407034 	sub	r7, r0, #52	; 0x34
	mutex_acquire(&qseecom.global_data_lock);
8f6162e8:	eb003337 	bl	8f622fcc <mutex_acquire>
	dprintf(SPEW, "%s called\n", __func__);
8f6162ec:	e305122c 	movw	r1, #21036	; 0x522c
8f6162f0:	e3040890 	movw	r0, #18576	; 0x4890
8f6162f4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6162f8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6162fc:	eb00719c 	bl	8f632974 <_dprintf>
	list_for_every_entry(&qseecom.registered_app_list_head,
8f616300:	e5964028 	ldr	r4, [r6, #40]	; 0x28
8f616304:	e1540007 	cmp	r4, r7
8f616308:	1a000003 	bne	8f61631c <qseecom_start_app+0xf4>
8f61630c:	ea00001f 	b	8f616390 <qseecom_start_app+0x168>
8f616310:	e5944004 	ldr	r4, [r4, #4]
8f616314:	e1540007 	cmp	r4, r7
8f616318:	0a00001c 	beq	8f616390 <qseecom_start_app+0x168>
		if (!strncmp(app_name, entry->app_name, 32)) {
8f61631c:	e2841010 	add	r1, r4, #16
8f616320:	e3a02020 	mov	r2, #32
8f616324:	e1a00005 	mov	r0, r5
8f616328:	eb00794f 	bl	8f63486c <strncmp>
8f61632c:	e3500000 	cmp	r0, #0
8f616330:	1afffff6 	bne	8f616310 <qseecom_start_app+0xe8>
			dprintf(SPEW, "%s: app_name:%s\n", __func__, app_name);
8f616334:	e1a02005 	mov	r2, r5
8f616338:	e305122c 	movw	r1, #21036	; 0x522c
8f61633c:	e3040d34 	movw	r0, #19764	; 0x4d34
8f616340:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616344:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616348:	eb007189 	bl	8f632974 <_dprintf>
	entry = __qseecom_check_app_exists(app_name);
	if (!entry) {
8f61634c:	e3540000 	cmp	r4, #0
8f616350:	0a00000e 	beq	8f616390 <qseecom_start_app+0x168>
		entry->handle = qseecom.handle;
		handle = entry->handle;
		mutex_release(&qseecom.global_data_lock);
	}
	else {
		entry->ref_cnt++;
8f616354:	e594300c 	ldr	r3, [r4, #12]
		handle = entry->handle;
		mutex_release(&qseecom.global_data_lock);
8f616358:	e59f0340 	ldr	r0, [pc, #832]	; 8f6166a0 <qseecom_start_app+0x478>
		entry->ref_cnt++;
8f61635c:	e2833001 	add	r3, r3, #1
8f616360:	e584300c 	str	r3, [r4, #12]
		handle = entry->handle;
8f616364:	e5947030 	ldr	r7, [r4, #48]	; 0x30
		mutex_release(&qseecom.global_data_lock);
8f616368:	eb003365 	bl	8f623104 <mutex_release>
	}
	return handle;
err:
	return ret;
}
8f61636c:	e59f3328 	ldr	r3, [pc, #808]	; 8f61669c <qseecom_start_app+0x474>
8f616370:	e5932000 	ldr	r2, [r3]
8f616374:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f616378:	e0332002 	eors	r2, r3, r2
8f61637c:	e3a03000 	mov	r3, #0
8f616380:	1a0000bc 	bne	8f616678 <qseecom_start_app+0x450>
8f616384:	e1a00007 	mov	r0, r7
8f616388:	e28dd048 	add	r13, r13, #72	; 0x48
8f61638c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
		mutex_release(&qseecom.global_data_lock);
8f616390:	e59f0308 	ldr	r0, [pc, #776]	; 8f6166a0 <qseecom_start_app+0x478>
8f616394:	eb00335a 	bl	8f623104 <mutex_release>
		dprintf(INFO, "%s: Loading app %s for the first time'\n",
8f616398:	e1a02005 	mov	r2, r5
8f61639c:	e3051318 	movw	r1, #21272	; 0x5318
8f6163a0:	e3040d48 	movw	r0, #19784	; 0x4d48
8f6163a4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6163a8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6163ac:	eb007170 	bl	8f632974 <_dprintf>
	struct qseecom_load_app_ireq load_req = {0};
8f6163b0:	e3a02030 	mov	r2, #48	; 0x30
8f6163b4:	e3a01000 	mov	r1, #0
8f6163b8:	e28d0014 	add	r0, r13, #20
8f6163bc:	eb0077c0 	bl	8f6342c4 <memset>
	dprintf(SPEW, "%s called\n", __func__);
8f6163c0:	e3051218 	movw	r1, #21016	; 0x5218
8f6163c4:	e3040890 	movw	r0, #18576	; 0x4890
8f6163c8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6163cc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6163d0:	eb007167 	bl	8f632974 <_dprintf>
	index = partition_get_index(app_name);
8f6163d4:	e1a00005 	mov	r0, r5
8f6163d8:	ebffb62b 	bl	8f603c8c <partition_get_index>
8f6163dc:	e1a08000 	mov	r8, r0
	lun = partition_get_lun(index);
8f6163e0:	ebffb956 	bl	8f604940 <partition_get_lun>
	mmc_set_lun(lun);
8f6163e4:	ebffdc12 	bl	8f60d434 <mmc_set_lun>
	size = partition_get_size(index);
8f6163e8:	e1a00008 	mov	r0, r8
8f6163ec:	ebffb911 	bl	8f604838 <partition_get_size>
	if (MAX_TA_PARTITION_SIZE < size) {
8f6163f0:	e2703601 	rsbs	r3, r0, #1048576	; 0x100000
	size = partition_get_size(index);
8f6163f4:	e1a04000 	mov	r4, r0
	if (MAX_TA_PARTITION_SIZE < size) {
8f6163f8:	e2f13000 	rscs	r3, r1, #0
8f6163fc:	3a00008c 	bcc	8f616634 <qseecom_start_app+0x40c>
	rounded_size = ROUNDUP(size, PAGE_SIZE);
8f616400:	e2801eff 	add	r1, r0, #4080	; 0xff0
	buf = memalign(PAGE_SIZE, rounded_size);
8f616404:	e3a00a01 	mov	r0, #4096	; 0x1000
	rounded_size = ROUNDUP(size, PAGE_SIZE);
8f616408:	e281100f 	add	r1, r1, #15
	buf = memalign(PAGE_SIZE, rounded_size);
8f61640c:	e3c11eff 	bic	r1, r1, #4080	; 0xff0
8f616410:	e3c1100f 	bic	r1, r1, #15
8f616414:	eb00770a 	bl	8f634044 <memalign>
	if (!buf) {
8f616418:	e2509000 	subs	r9, r0, #0
8f61641c:	0a000096 	beq	8f61667c <qseecom_start_app+0x454>
	ptn = partition_get_offset(index);
8f616420:	e1a00008 	mov	r0, r8
8f616424:	ebffb924 	bl	8f6048bc <partition_get_offset>
	if(ptn == 0) {
8f616428:	e1903001 	orrs	r3, r0, r1
8f61642c:	0a000057 	beq	8f616590 <qseecom_start_app+0x368>
	if (mmc_read(ptn, (unsigned int *) buf, size)) {
8f616430:	e1a03004 	mov	r3, r4
8f616434:	e1a02009 	mov	r2, r9
8f616438:	ebffda12 	bl	8f60cc88 <mmc_read>
8f61643c:	e2508000 	subs	r8, r0, #0
8f616440:	1a000064 	bne	8f6165d8 <qseecom_start_app+0x3b0>
	dprintf(SPEW, "%s called\n", __func__);
8f616444:	e30512c0 	movw	r1, #21184	; 0x52c0
8f616448:	e3040890 	movw	r0, #18576	; 0x4890
8f61644c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616450:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616454:	eb007146 	bl	8f632974 <_dprintf>
	return (uint32_t)platform_get_virt_to_phys_mapping((addr_t)virt);
8f616458:	e1a00009 	mov	r0, r9
8f61645c:	ebffacbc 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	dprintf(SPEW, "phy_addr:%u img_len:%u\n", load_req.phy_addr, load_req.img_len);
8f616460:	e1a02004 	mov	r2, r4
	load_req.qsee_cmd_id = QSEE_APP_START_COMMAND;
8f616464:	e3a0a001 	mov	r10, #1
	load_req.img_len = size;
8f616468:	e58d401c 	str	r4, [r13, #28]
	load_req.mdt_len = 0;
8f61646c:	e58d8018 	str	r8, [r13, #24]
	load_req.qsee_cmd_id = QSEE_APP_START_COMMAND;
8f616470:	e58da014 	str	r10, [r13, #20]
	return (uint32_t)platform_get_virt_to_phys_mapping((addr_t)virt);
8f616474:	e1a01000 	mov	r1, r0
	load_req.phy_addr = (uint32_t)__qseecom_uvirt_to_kphys((uint32_t) buf);
8f616478:	e58d0020 	str	r0, [r13, #32]
	dprintf(SPEW, "phy_addr:%u img_len:%u\n", load_req.phy_addr, load_req.img_len);
8f61647c:	e3040d8c 	movw	r0, #19852	; 0x4d8c
8f616480:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616484:	eb00713a 	bl	8f632974 <_dprintf>
	memscpy(&load_req.app_name, MAX_APP_NAME_SIZE, app_name, MAX_APP_NAME_SIZE);
8f616488:	e3a03020 	mov	r3, #32
8f61648c:	e1a01003 	mov	r1, r3
8f616490:	e1a02005 	mov	r2, r5
8f616494:	e28d0024 	add	r0, r13, #36	; 0x24
8f616498:	eb0077ef 	bl	8f63445c <memscpy>
	arch_clean_invalidate_cache_range((addr_t) load_req.phy_addr, load_req.img_len);
8f61649c:	e59d101c 	ldr	r1, [r13, #28]
8f6164a0:	e59d0020 	ldr	r0, [r13, #32]
8f6164a4:	eb002abd 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	ret = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1, req,
8f6164a8:	e28d3008 	add	r3, r13, #8
8f6164ac:	e28d2014 	add	r2, r13, #20
8f6164b0:	e58d3000 	str	r3, [r13]
8f6164b4:	e1a0100a 	mov	r1, r10
8f6164b8:	e3a03010 	mov	r3, #16
8f6164bc:	e3a000fc 	mov	r0, #252	; 0xfc
8f6164c0:	ebfffcd0 	bl	8f615808 <qseecom_scm_call.constprop.0>
	if(ret == 0)
8f6164c4:	e2504000 	subs	r4, r0, #0
		free(buf);
8f6164c8:	e1a00009 	mov	r0, r9
	if(ret == 0)
8f6164cc:	1a00003f 	bne	8f6165d0 <qseecom_start_app+0x3a8>
		*app_id = resp.data;
8f6164d0:	e59d8010 	ldr	r8, [r13, #16]
		free(buf);
8f6164d4:	eb00770c 	bl	8f63410c <free>
		if ((ret < 0) || (app_id ==0)) {
8f6164d8:	e3580000 	cmp	r8, #0
8f6164dc:	0a000032 	beq	8f6165ac <qseecom_start_app+0x384>
		mutex_acquire(&qseecom.global_data_lock);
8f6164e0:	e59f01b8 	ldr	r0, [pc, #440]	; 8f6166a0 <qseecom_start_app+0x478>
8f6164e4:	eb0032b8 	bl	8f622fcc <mutex_acquire>
	dprintf(SPEW, "%s called\n", __func__);
8f6164e8:	e3051200 	movw	r1, #20992	; 0x5200
8f6164ec:	e3040890 	movw	r0, #18576	; 0x4890
8f6164f0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6164f4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6164f8:	eb00711d 	bl	8f632974 <_dprintf>
	entry = malloc(sizeof(*entry));
8f6164fc:	e3a00034 	mov	r0, #52	; 0x34
8f616500:	eb0076bd 	bl	8f633ffc <malloc>
	if (!entry) {
8f616504:	e2504000 	subs	r4, r0, #0
8f616508:	0a00004e 	beq	8f616648 <qseecom_start_app+0x420>
	strlcpy(entry->app_name, app_name, MAX_APP_NAME_SIZE);
8f61650c:	e1a01005 	mov	r1, r5
8f616510:	e2845010 	add	r5, r4, #16
8f616514:	e3a02020 	mov	r2, #32
	entry->app_id = app_id;
8f616518:	e5848008 	str	r8, [r4, #8]
	strlcpy(entry->app_name, app_name, MAX_APP_NAME_SIZE);
8f61651c:	e1a00005 	mov	r0, r5
	entry->ref_cnt = 1;
8f616520:	e584a00c 	str	r10, [r4, #12]
	strlcpy(entry->app_name, app_name, MAX_APP_NAME_SIZE);
8f616524:	eb007881 	bl	8f634730 <strlcpy>
	dprintf(SPEW, "%s: Adding app:%s app_id:%u to list\n", __func__, entry->app_name, entry->app_id);
8f616528:	e5943008 	ldr	r3, [r4, #8]
8f61652c:	e1a02005 	mov	r2, r5
8f616530:	e3051200 	movw	r1, #20992	; 0x5200
8f616534:	e3040e20 	movw	r0, #20000	; 0x4e20
8f616538:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61653c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616540:	eb00710b 	bl	8f632974 <_dprintf>

#define list_add_after(entry, new_entry) list_add_head(entry, new_entry)

static inline void list_add_tail(struct list_node *list, struct list_node *item)
{
	item->prev = list->prev;
8f616544:	e5963024 	ldr	r3, [r6, #36]	; 0x24
		qseecom.handle++;
8f616548:	e5962050 	ldr	r2, [r6, #80]	; 0x50
	item->next = list;
8f61654c:	e5847004 	str	r7, [r4, #4]
	item->prev = list->prev;
8f616550:	e5843000 	str	r3, [r4]
8f616554:	e2827001 	add	r7, r2, #1
	list->prev->next = item;
8f616558:	e5834004 	str	r4, [r3, #4]
		mutex_release(&qseecom.global_data_lock);
8f61655c:	e59f013c 	ldr	r0, [pc, #316]	; 8f6166a0 <qseecom_start_app+0x478>
		entry->handle = qseecom.handle;
8f616560:	e5847030 	str	r7, [r4, #48]	; 0x30
	list->prev = item;
8f616564:	e5864024 	str	r4, [r6, #36]	; 0x24
		qseecom.handle++;
8f616568:	e5867050 	str	r7, [r6, #80]	; 0x50
		mutex_release(&qseecom.global_data_lock);
8f61656c:	eb0032e4 	bl	8f623104 <mutex_release>
8f616570:	eaffff7d 	b	8f61636c <qseecom_start_app+0x144>
                        dprintf(CRITICAL, "%s qseecom_load_commonlib_image failed with status:%d\n",
8f616574:	e1a02007 	mov	r2, r7
8f616578:	e3051318 	movw	r1, #21272	; 0x5318
8f61657c:	e3040cc0 	movw	r0, #19648	; 0x4cc0
8f616580:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616584:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616588:	eb0070f9 	bl	8f632974 <_dprintf>
                        goto err;
8f61658c:	eaffff76 	b	8f61636c <qseecom_start_app+0x144>
		dprintf(CRITICAL, "ERROR: No %s found\n", app_name);
8f616590:	e1a01005 	mov	r1, r5
8f616594:	e3040c40 	movw	r0, #19520	; 0x4c40
8f616598:	e3480f70 	movt	r0, #36720	; 0x8f70
		ret = GENERIC_ERROR;
8f61659c:	e3e04000 	mvn	r4, #0
		dprintf(CRITICAL, "ERROR: No %s found\n", app_name);
8f6165a0:	eb0070f3 	bl	8f632974 <_dprintf>
		free(buf);
8f6165a4:	e1a00009 	mov	r0, r9
8f6165a8:	eb0076d7 	bl	8f63410c <free>
			dprintf(CRITICAL, "%s: __qseecom_load_app failed with err:%d for app:%s\n",
8f6165ac:	e1a03005 	mov	r3, r5
8f6165b0:	e1a02004 	mov	r2, r4
8f6165b4:	e3051318 	movw	r1, #21272	; 0x5318
8f6165b8:	e3040da4 	movw	r0, #19876	; 0x4da4
8f6165bc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6165c0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6165c4:	eb0070ea 	bl	8f632974 <_dprintf>
			ret = GENERIC_ERROR;
8f6165c8:	e3e07000 	mvn	r7, #0
			goto err;
8f6165cc:	eaffff66 	b	8f61636c <qseecom_start_app+0x144>
		free(buf);
8f6165d0:	eb0076cd 	bl	8f63410c <free>
		if ((ret < 0) || (app_id ==0)) {
8f6165d4:	eafffff4 	b	8f6165ac <qseecom_start_app+0x384>
		dprintf(CRITICAL, "ERROR: Cannot read %s image\n", app_name);
8f6165d8:	e1a01005 	mov	r1, r5
8f6165dc:	e3040c54 	movw	r0, #19540	; 0x4c54
8f6165e0:	e3480f70 	movt	r0, #36720	; 0x8f70
		ret = GENERIC_ERROR;
8f6165e4:	e3e04000 	mvn	r4, #0
		dprintf(CRITICAL, "ERROR: Cannot read %s image\n", app_name);
8f6165e8:	eb0070e1 	bl	8f632974 <_dprintf>
		free(buf);
8f6165ec:	e1a00009 	mov	r0, r9
8f6165f0:	eb0076c5 	bl	8f63410c <free>
		if ((ret < 0) || (app_id ==0)) {
8f6165f4:	eaffffec 	b	8f6165ac <qseecom_start_app+0x384>
		dprintf(CRITICAL, "%s qseecom_init not done\n",
8f6165f8:	e3051318 	movw	r1, #21272	; 0x5318
8f6165fc:	e3040c9c 	movw	r0, #19612	; 0x4c9c
8f616600:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616604:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616608:	eb0070d9 	bl	8f632974 <_dprintf>
		mutex_release(&qseecom.global_data_lock);
8f61660c:	e59f008c 	ldr	r0, [pc, #140]	; 8f6166a0 <qseecom_start_app+0x478>
8f616610:	eb0032bb 	bl	8f623104 <mutex_release>
		return ret;
8f616614:	e3e07000 	mvn	r7, #0
8f616618:	eaffff53 	b	8f61636c <qseecom_start_app+0x144>
		dprintf(CRITICAL, "%s: Input error\n", __func__);
8f61661c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616620:	e3040c88 	movw	r0, #19592	; 0x4c88
8f616624:	e3480f70 	movt	r0, #36720	; 0x8f70
	int32_t ret = GENERIC_ERROR;
8f616628:	e3e07000 	mvn	r7, #0
		dprintf(CRITICAL, "%s: Input error\n", __func__);
8f61662c:	eb0070d0 	bl	8f632974 <_dprintf>
		goto err;
8f616630:	eaffff4d 	b	8f61636c <qseecom_start_app+0x144>
		dprintf(CRITICAL, "Invalid TA partition size!");
8f616634:	e3040d70 	movw	r0, #19824	; 0x4d70
8f616638:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61663c:	eb0070cc 	bl	8f632974 <_dprintf>
		ret = GENERIC_ERROR;
8f616640:	e3e04000 	mvn	r4, #0
8f616644:	eaffffd8 	b	8f6165ac <qseecom_start_app+0x384>
		dprintf(CRITICAL, "malloc for app entry failed\n");
8f616648:	e3040ddc 	movw	r0, #19932	; 0x4ddc
8f61664c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616650:	eb0070c7 	bl	8f632974 <_dprintf>
			dprintf(CRITICAL, "%s: __qseecom_add_app_entry failed\n", __func__);
8f616654:	e3051318 	movw	r1, #21272	; 0x5318
8f616658:	e3040dfc 	movw	r0, #19964	; 0x4dfc
8f61665c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616660:	e3480f70 	movt	r0, #36720	; 0x8f70
			ret = GENERIC_ERROR;
8f616664:	e3e07000 	mvn	r7, #0
			dprintf(CRITICAL, "%s: __qseecom_add_app_entry failed\n", __func__);
8f616668:	eb0070c1 	bl	8f632974 <_dprintf>
			mutex_release(&qseecom.global_data_lock);
8f61666c:	e59f002c 	ldr	r0, [pc, #44]	; 8f6166a0 <qseecom_start_app+0x478>
8f616670:	eb0032a3 	bl	8f623104 <mutex_release>
			goto err;
8f616674:	eaffff3c 	b	8f61636c <qseecom_start_app+0x144>
}
8f616678:	eb007150 	bl	8f632bc0 <__stack_chk_fail>
		dprintf(CRITICAL, "%s: Aloc failed for %s image\n",
8f61667c:	e1a02005 	mov	r2, r5
8f616680:	e3051218 	movw	r1, #21016	; 0x5218
8f616684:	e3040c20 	movw	r0, #19488	; 0x4c20
8f616688:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61668c:	e3480f70 	movt	r0, #36720	; 0x8f70
		ret = GENERIC_ERROR;
8f616690:	e3e04000 	mvn	r4, #0
		dprintf(CRITICAL, "%s: Aloc failed for %s image\n",
8f616694:	eb0070b6 	bl	8f632974 <_dprintf>
		if ((ret < 0) || (app_id ==0)) {
8f616698:	eaffffc3 	b	8f6165ac <qseecom_start_app+0x384>
8f61669c:	8f74221c 	.word	0x8f74221c
8f6166a0:	8f72d12c 	.word	0x8f72d12c

8f6166a4 <qseecom_send_command>:
*     0 - Success
*     Negative value indicates failure.
*/
int qseecom_send_command(int handle, void *send_buf,
			uint32_t sbuf_len, void *resp_buf, uint32_t rbuf_len)
{
8f6166a4:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f6166a8:	e1a08003 	mov	r8, r3
8f6166ac:	e24dd034 	sub	r13, r13, #52	; 0x34
8f6166b0:	e59f32e8 	ldr	r3, [pc, #744]	; 8f6169a0 <qseecom_send_command+0x2fc>
	int ret = GENERIC_ERROR;
	uint32_t app_id = 0;
	struct qseecom_registered_app_list *entry = NULL;
	struct qseecom_send_cmd_req req = {0, 0, 0, 0};

	if (handle <= 0) {
8f6166b4:	e2505000 	subs	r5, r0, #0
{
8f6166b8:	e59d7050 	ldr	r7, [r13, #80]	; 0x50
8f6166bc:	e5933000 	ldr	r3, [r3]
8f6166c0:	e58d302c 	str	r3, [r13, #44]	; 0x2c
8f6166c4:	e3a03000 	mov	r3, #0
	if (handle <= 0) {
8f6166c8:	da0000ac 	ble	8f616980 <qseecom_send_command+0x2dc>
		dprintf(CRITICAL, "%s Handle is Invalid\n", __func__);
		return GENERIC_ERROR;
	}

	if((!send_buf) || (!resp_buf)) {
8f6166cc:	e3580000 	cmp	r8, #0
8f6166d0:	13510000 	cmpne	r1, #0
8f6166d4:	e1a09001 	mov	r9, r1
8f6166d8:	0a000097 	beq	8f61693c <qseecom_send_command+0x298>
		dprintf(CRITICAL, "%s: Input Buffers invalid\n", __func__);
		return GENERIC_ERROR;
	}
	dprintf(SPEW, "%s called\n", __func__);
8f6166dc:	e305137c 	movw	r1, #21372	; 0x537c
8f6166e0:	e3040890 	movw	r0, #18576	; 0x4890
8f6166e4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6166e8:	e3480f70 	movt	r0, #36720	; 0x8f70
	mutex_acquire(&qseecom.global_data_lock);
8f6166ec:	e30d40d4 	movw	r4, #53460	; 0xd0d4
8f6166f0:	e3484f72 	movt	r4, #36722	; 0x8f72
8f6166f4:	e1a06002 	mov	r6, r2
	dprintf(SPEW, "%s called\n", __func__);
8f6166f8:	eb00709d 	bl	8f632974 <_dprintf>
	mutex_acquire(&qseecom.global_data_lock);
8f6166fc:	e2840058 	add	r0, r4, #88	; 0x58
8f616700:	eb003231 	bl	8f622fcc <mutex_acquire>
	if ((!qseecom.qseecom_init_done)
8f616704:	e5943078 	ldr	r3, [r4, #120]	; 0x78
8f616708:	e3530000 	cmp	r3, #0
8f61670c:	0a000081 	beq	8f616918 <qseecom_send_command+0x274>
			|| (!qseecom.qseecom_tz_init_done)) {
8f616710:	e594307c 	ldr	r3, [r4, #124]	; 0x7c
8f616714:	e3530000 	cmp	r3, #0
8f616718:	0a00007e 	beq	8f616918 <qseecom_send_command+0x274>
	dprintf(SPEW, "%s called\n", __func__);
8f61671c:	e3051394 	movw	r1, #21396	; 0x5394
8f616720:	e3040890 	movw	r0, #18576	; 0x4890
8f616724:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616728:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61672c:	eb007090 	bl	8f632974 <_dprintf>
	list_for_every_entry(&qseecom.registered_app_list_head,
8f616730:	e594c028 	ldr	r12, [r4, #40]	; 0x28
8f616734:	e284e024 	add	r14, r4, #36	; 0x24
8f616738:	e15c000e 	cmp	r12, r14
8f61673c:	1a000003 	bne	8f616750 <qseecom_send_command+0xac>
8f616740:	ea000084 	b	8f616958 <qseecom_send_command+0x2b4>
8f616744:	e59cc004 	ldr	r12, [r12, #4]
8f616748:	e15c000e 	cmp	r12, r14
8f61674c:	0a000081 	beq	8f616958 <qseecom_send_command+0x2b4>
		if (entry->handle == handle) {
8f616750:	e59c3030 	ldr	r3, [r12, #48]	; 0x30
8f616754:	e1550003 	cmp	r5, r3
8f616758:	1afffff9 	bne	8f616744 <qseecom_send_command+0xa0>
		mutex_release(&qseecom.global_data_lock);
		goto err;
	}

	app_id = entry->app_id;
	mutex_release(&qseecom.global_data_lock);
8f61675c:	e59f0240 	ldr	r0, [pc, #576]	; 8f6169a4 <qseecom_send_command+0x300>
	app_id = entry->app_id;
8f616760:	e59c4008 	ldr	r4, [r12, #8]
	mutex_release(&qseecom.global_data_lock);
8f616764:	eb003266 	bl	8f623104 <mutex_release>
	dprintf(SPEW, "%s called\n", __func__);
8f616768:	e3051368 	movw	r1, #21352	; 0x5368
8f61676c:	e3040890 	movw	r0, #18576	; 0x4890
8f616770:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616774:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616778:	eb00707d 	bl	8f632974 <_dprintf>
	if (req->cmd_req_len > (UINT_MAX - req->resp_len)) {
8f61677c:	e1e03007 	mvn	r3, r7
8f616780:	e1560003 	cmp	r6, r3
		dprintf(CRITICAL, "%s:Integer overflow\n", __func__);
8f616784:	83051368 	movwhi	r1, #21352	; 0x5368
8f616788:	83040eb4 	movwhi	r0, #20148	; 0x4eb4
8f61678c:	83481f70 	movthi	r1, #36720	; 0x8f70
8f616790:	83480f70 	movthi	r0, #36720	; 0x8f70
	if (req->cmd_req_len > (UINT_MAX - req->resp_len)) {
8f616794:	8a00004d 	bhi	8f6168d0 <qseecom_send_command+0x22c>
	if ((req->cmd_req_len + req->resp_len) > (RPMB_SND_RCV_BUF_SZ * 1024 * 1024)) {
8f616798:	e0863007 	add	r3, r6, r7
8f61679c:	e3530601 	cmp	r3, #1048576	; 0x100000
8f6167a0:	8a000046 	bhi	8f6168c0 <qseecom_send_command+0x21c>
	dprintf(SPEW, "%s called\n", __func__);
8f6167a4:	e30512c0 	movw	r1, #21184	; 0x52c0
8f6167a8:	e3040890 	movw	r0, #18576	; 0x4890
8f6167ac:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6167b0:	e3480f70 	movt	r0, #36720	; 0x8f70
	send_data_req.qsee_cmd_id = QSEE_CLIENT_SEND_DATA_COMMAND;
8f6167b4:	e3a03006 	mov	r3, #6
	send_data_req.app_id = app_id;
8f6167b8:	e58d4018 	str	r4, [r13, #24]
	send_data_req.qsee_cmd_id = QSEE_CLIENT_SEND_DATA_COMMAND;
8f6167bc:	e58d3014 	str	r3, [r13, #20]
	dprintf(SPEW, "%s called\n", __func__);
8f6167c0:	eb00706b 	bl	8f632974 <_dprintf>
	return (uint32_t)platform_get_virt_to_phys_mapping((addr_t)virt);
8f6167c4:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
	size = ROUNDUP(req->cmd_req_len, PAGE_SIZE);
8f6167c8:	e2864eff 	add	r4, r6, #4080	; 0xff0
	return (uint32_t)platform_get_virt_to_phys_mapping((addr_t)virt);
8f6167cc:	ebffabe0 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	size = ROUNDUP(req->cmd_req_len, PAGE_SIZE);
8f6167d0:	e284400f 	add	r4, r4, #15
8f6167d4:	e3c44eff 	bic	r4, r4, #4080	; 0xff0
	dprintf(SPEW, "%s called\n", __func__);
8f6167d8:	e30512c0 	movw	r1, #21184	; 0x52c0
	size = ROUNDUP(req->cmd_req_len, PAGE_SIZE);
8f6167dc:	e3c4400f 	bic	r4, r4, #15
	dprintf(SPEW, "%s called\n", __func__);
8f6167e0:	e3481f70 	movt	r1, #36720	; 0x8f70
	rsp_buf_temp = (uint8_t *)buf + size;
8f6167e4:	e284420a 	add	r4, r4, #-1610612736	; 0xa0000000
	send_data_req.req_len = req->cmd_req_len;
8f6167e8:	e58d6020 	str	r6, [r13, #32]
	send_data_req.req_ptr = (uint32_t)__qseecom_uvirt_to_kphys((uint32_t) buf);
8f6167ec:	e58d001c 	str	r0, [r13, #28]
	dprintf(SPEW, "%s called\n", __func__);
8f6167f0:	e3040890 	movw	r0, #18576	; 0x4890
8f6167f4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6167f8:	eb00705d 	bl	8f632974 <_dprintf>
	return (uint32_t)platform_get_virt_to_phys_mapping((addr_t)virt);
8f6167fc:	e1a00004 	mov	r0, r4
8f616800:	ebffabd3 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	memscpy(buf, (RPMB_SND_RCV_BUF_SZ * 1024 * 1024), req->cmd_req_buf, req->cmd_req_len);
8f616804:	e1a03006 	mov	r3, r6
8f616808:	e1a02009 	mov	r2, r9
8f61680c:	e3a01601 	mov	r1, #1048576	; 0x100000
	send_data_req.rsp_len = req->resp_len;
8f616810:	e58d7028 	str	r7, [r13, #40]	; 0x28
	send_data_req.rsp_ptr = (uint32_t)__qseecom_uvirt_to_kphys((uint32_t)rsp_buf_temp);
8f616814:	e58d0024 	str	r0, [r13, #36]	; 0x24
	memscpy(buf, (RPMB_SND_RCV_BUF_SZ * 1024 * 1024), req->cmd_req_buf, req->cmd_req_len);
8f616818:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
8f61681c:	eb00770e 	bl	8f63445c <memscpy>
	memscpy(rsp_buf_temp, req->resp_len, req->resp_buf, req->resp_len);
8f616820:	e1a03007 	mov	r3, r7
8f616824:	e1a02008 	mov	r2, r8
8f616828:	e1a01007 	mov	r1, r7
8f61682c:	e1a00004 	mov	r0, r4
8f616830:	eb007709 	bl	8f63445c <memscpy>
	ret = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1,
8f616834:	e28d2014 	add	r2, r13, #20
8f616838:	e28d0008 	add	r0, r13, #8
8f61683c:	e3a03018 	mov	r3, #24
8f616840:	e3a01001 	mov	r1, #1
8f616844:	e58d0000 	str	r0, [r13]
8f616848:	e3a000fc 	mov	r0, #252	; 0xfc
8f61684c:	ebfffbed 	bl	8f615808 <qseecom_scm_call.constprop.0>
	memscpy(req->cmd_req_buf, req->cmd_req_len, (void *)buf, send_data_req.req_len);
8f616850:	e1a01006 	mov	r1, r6
8f616854:	e3a0220a 	mov	r2, #-1610612736	; 0xa0000000
	ret = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1,
8f616858:	e1a03000 	mov	r3, r0
	memscpy(req->cmd_req_buf, req->cmd_req_len, (void *)buf, send_data_req.req_len);
8f61685c:	e1a00009 	mov	r0, r9
	ret = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1,
8f616860:	e1a06003 	mov	r6, r3
	memscpy(req->cmd_req_buf, req->cmd_req_len, (void *)buf, send_data_req.req_len);
8f616864:	e59d3020 	ldr	r3, [r13, #32]
8f616868:	eb0076fb 	bl	8f63445c <memscpy>
	memscpy(req->resp_buf, req->resp_len, (void *)rsp_buf_temp, send_data_req.rsp_len);
8f61686c:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f616870:	e1a02004 	mov	r2, r4
8f616874:	e1a01007 	mov	r1, r7
8f616878:	e1a00008 	mov	r0, r8
8f61687c:	eb0076f6 	bl	8f63445c <memscpy>
	req.resp_len = rbuf_len;
	req.cmd_req_buf = send_buf;
	req.resp_buf = resp_buf;

	ret = __qseecom_send_cmd(app_id, &req);
	if (ret) {
8f616880:	e3560000 	cmp	r6, #0
8f616884:	1a00001b 	bne	8f6168f8 <qseecom_send_command+0x254>
				__func__, ret, handle);
		goto err;
	}

	ret = 0;
	dprintf(SPEW, "sending cmd_req->rsp size: %u, ptr: 0x%p\n",
8f616888:	e3040f58 	movw	r0, #20312	; 0x4f58
8f61688c:	e1a02008 	mov	r2, r8
8f616890:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616894:	e1a01007 	mov	r1, r7
8f616898:	eb007035 	bl	8f632974 <_dprintf>
			req.resp_len, req.resp_buf);
err:
	return ret;
}
8f61689c:	e59f30fc 	ldr	r3, [pc, #252]	; 8f6169a0 <qseecom_send_command+0x2fc>
8f6168a0:	e5932000 	ldr	r2, [r3]
8f6168a4:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
8f6168a8:	e0332002 	eors	r2, r3, r2
8f6168ac:	e3a03000 	mov	r3, #0
8f6168b0:	1a000039 	bne	8f61699c <qseecom_send_command+0x2f8>
8f6168b4:	e1a00006 	mov	r0, r6
8f6168b8:	e28dd034 	add	r13, r13, #52	; 0x34
8f6168bc:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
		dprintf(CRITICAL, "%s:Cmd + Rsp len greater than TA buf\n", __func__);
8f6168c0:	e3051368 	movw	r1, #21352	; 0x5368
8f6168c4:	e3040ef8 	movw	r0, #20216	; 0x4ef8
8f6168c8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6168cc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6168d0:	eb007027 	bl	8f632974 <_dprintf>
		dprintf(CRITICAL, "req->cmd_req_len: %u\n", req->cmd_req_len);
8f6168d4:	e1a01006 	mov	r1, r6
8f6168d8:	e3040ecc 	movw	r0, #20172	; 0x4ecc
8f6168dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6168e0:	eb007023 	bl	8f632974 <_dprintf>
		dprintf(CRITICAL, "req->resp_len: %u\n", req->resp_len);
8f6168e4:	e1a01007 	mov	r1, r7
8f6168e8:	e3040ee4 	movw	r0, #20196	; 0x4ee4
8f6168ec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6168f0:	eb00701f 	bl	8f632974 <_dprintf>
		return GENERIC_ERROR;
8f6168f4:	e3e06000 	mvn	r6, #0
		dprintf(CRITICAL, "%s __qseecom_send_cmd failed with err:%d for handle:%d\n",
8f6168f8:	e1a03005 	mov	r3, r5
8f6168fc:	e1a02006 	mov	r2, r6
8f616900:	e305137c 	movw	r1, #21372	; 0x537c
8f616904:	e3040f20 	movw	r0, #20256	; 0x4f20
8f616908:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61690c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616910:	eb007017 	bl	8f632974 <_dprintf>
		goto err;
8f616914:	eaffffe0 	b	8f61689c <qseecom_send_command+0x1f8>
		dprintf(CRITICAL, "%s qseecom_init not done\n",
8f616918:	e305137c 	movw	r1, #21372	; 0x537c
8f61691c:	e3040c9c 	movw	r0, #19612	; 0x4c9c
8f616920:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616924:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616928:	eb007011 	bl	8f632974 <_dprintf>
		mutex_release(&qseecom.global_data_lock);
8f61692c:	e59f0070 	ldr	r0, [pc, #112]	; 8f6169a4 <qseecom_send_command+0x300>
8f616930:	eb0031f3 	bl	8f623104 <mutex_release>
		return ret;
8f616934:	e3e06000 	mvn	r6, #0
8f616938:	eaffffd7 	b	8f61689c <qseecom_send_command+0x1f8>
		dprintf(CRITICAL, "%s: Input Buffers invalid\n", __func__);
8f61693c:	e305137c 	movw	r1, #21372	; 0x537c
8f616940:	e3040e60 	movw	r0, #20064	; 0x4e60
8f616944:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616948:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61694c:	eb007008 	bl	8f632974 <_dprintf>
		return GENERIC_ERROR;
8f616950:	e3e06000 	mvn	r6, #0
8f616954:	eaffffd0 	b	8f61689c <qseecom_send_command+0x1f8>
		dprintf(CRITICAL, "%s: Send cmd on an app that was never loaded handle:%d\n",
8f616958:	e1a02005 	mov	r2, r5
8f61695c:	e305137c 	movw	r1, #21372	; 0x537c
8f616960:	e3040e7c 	movw	r0, #20092	; 0x4e7c
8f616964:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616968:	e3480f70 	movt	r0, #36720	; 0x8f70
		ret = GENERIC_ERROR;
8f61696c:	e3e06000 	mvn	r6, #0
		dprintf(CRITICAL, "%s: Send cmd on an app that was never loaded handle:%d\n",
8f616970:	eb006fff 	bl	8f632974 <_dprintf>
		mutex_release(&qseecom.global_data_lock);
8f616974:	e59f0028 	ldr	r0, [pc, #40]	; 8f6169a4 <qseecom_send_command+0x300>
8f616978:	eb0031e1 	bl	8f623104 <mutex_release>
		goto err;
8f61697c:	eaffffc6 	b	8f61689c <qseecom_send_command+0x1f8>
		dprintf(CRITICAL, "%s Handle is Invalid\n", __func__);
8f616980:	e305137c 	movw	r1, #21372	; 0x537c
8f616984:	e3040e48 	movw	r0, #20040	; 0x4e48
8f616988:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61698c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616990:	eb006ff7 	bl	8f632974 <_dprintf>
		return GENERIC_ERROR;
8f616994:	e3e06000 	mvn	r6, #0
8f616998:	eaffffbf 	b	8f61689c <qseecom_send_command+0x1f8>
}
8f61699c:	eb007087 	bl	8f632bc0 <__stack_chk_fail>
8f6169a0:	8f74221c 	.word	0x8f74221c
8f6169a4:	8f72d12c 	.word	0x8f72d12c

8f6169a8 <qseecom_register_listener>:
*   Status:
*     0 - Success
*     Negative value indicates failure.
*/
int qseecom_register_listener(struct qseecom_listener_services *listnr)
{
8f6169a8:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
	int ret = GENERIC_ERROR;
	struct qseecom_registered_listener_list *new_entry = NULL;
	struct qseecom_register_listener_ireq req;
	struct qseecom_command_scm_resp resp;

	mutex_acquire(&qseecom.global_data_lock);
8f6169ac:	e30d40d4 	movw	r4, #53460	; 0xd0d4
{
8f6169b0:	e59f32cc 	ldr	r3, [pc, #716]	; 8f616c84 <qseecom_register_listener+0x2dc>
	mutex_acquire(&qseecom.global_data_lock);
8f6169b4:	e3484f72 	movt	r4, #36722	; 0x8f72
{
8f6169b8:	e24dd028 	sub	r13, r13, #40	; 0x28
8f6169bc:	e1a05000 	mov	r5, r0
	mutex_acquire(&qseecom.global_data_lock);
8f6169c0:	e2840058 	add	r0, r4, #88	; 0x58
{
8f6169c4:	e5933000 	ldr	r3, [r3]
8f6169c8:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f6169cc:	e3a03000 	mov	r3, #0
	mutex_acquire(&qseecom.global_data_lock);
8f6169d0:	eb00317d 	bl	8f622fcc <mutex_acquire>
	if (!qseecom.qseecom_init_done) {
8f6169d4:	e5943078 	ldr	r3, [r4, #120]	; 0x78
8f6169d8:	e3530000 	cmp	r3, #0
8f6169dc:	0a000091 	beq	8f616c28 <qseecom_register_listener+0x280>
		dprintf(CRITICAL, "%s qseecom_init not done\n",
							__func__);
		mutex_release(&qseecom.global_data_lock);
		return ret;
	}
	mutex_release(&qseecom.global_data_lock);
8f6169e0:	e2840058 	add	r0, r4, #88	; 0x58
8f6169e4:	eb0031c6 	bl	8f623104 <mutex_release>

	mutex_acquire(&qseecom.registered_listener_list_lock);
8f6169e8:	e2840008 	add	r0, r4, #8
8f6169ec:	eb003176 	bl	8f622fcc <mutex_acquire>

	if ((!listnr)) {
8f6169f0:	e3550000 	cmp	r5, #0
8f6169f4:	0a000094 	beq	8f616c4c <qseecom_register_listener+0x2a4>
		dprintf(CRITICAL, "%s Invalid Input listnr\n", __func__);
		return GENERIC_ERROR;
	}

	if ((!listnr->id) || (!listnr->sb_size) || (!listnr->service_cmd_handler)) {
8f6169f8:	e1c520d4 	ldrd	r2, [r5, #4]
8f6169fc:	e3520000 	cmp	r2, #0
8f616a00:	0a000081 	beq	8f616c0c <qseecom_register_listener+0x264>
8f616a04:	e3530000 	cmp	r3, #0
8f616a08:	0a00007f 	beq	8f616c0c <qseecom_register_listener+0x264>
8f616a0c:	e595100c 	ldr	r1, [r5, #12]
8f616a10:	e3510000 	cmp	r1, #0
8f616a14:	0a00007c 	beq	8f616c0c <qseecom_register_listener+0x264>
		dprintf(CRITICAL, "%s Invalid Input listnr_id:%d sb_size:%d\n",
				__func__, listnr->id, listnr->sb_size);
		return GENERIC_ERROR;
	}
	dprintf(SPEW, "%s called\n", __func__);
8f616a18:	e305134c 	movw	r1, #21324	; 0x534c
8f616a1c:	e3040890 	movw	r0, #18576	; 0x4890
8f616a20:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616a24:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616a28:	eb006fd1 	bl	8f632974 <_dprintf>
	new_entry = __qseecom_check_listener_exists(listnr->id);
8f616a2c:	e5956004 	ldr	r6, [r5, #4]
		dprintf(CRITICAL, "%s: Invalid Input\n", __func__);
8f616a30:	e305132c 	movw	r1, #21292	; 0x532c
	if (!listener_id) {
8f616a34:	e3560000 	cmp	r6, #0
8f616a38:	0a00001c 	beq	8f616ab0 <qseecom_register_listener+0x108>
	dprintf(SPEW, "%s called\n", __func__);
8f616a3c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616a40:	e3040890 	movw	r0, #18576	; 0x4890
8f616a44:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616a48:	eb006fc9 	bl	8f632974 <_dprintf>
	list_for_every_entry(&qseecom.registered_listener_list_head,
8f616a4c:	e5943004 	ldr	r3, [r4, #4]
8f616a50:	e1530004 	cmp	r3, r4
8f616a54:	1a000003 	bne	8f616a68 <qseecom_register_listener+0xc0>
8f616a58:	ea000018 	b	8f616ac0 <qseecom_register_listener+0x118>
8f616a5c:	e5933004 	ldr	r3, [r3, #4]
8f616a60:	e1530004 	cmp	r3, r4
8f616a64:	0a000015 	beq	8f616ac0 <qseecom_register_listener+0x118>
		if (entry->svc.listener_id == listener_id) {
8f616a68:	e5932008 	ldr	r2, [r3, #8]
8f616a6c:	e1560002 	cmp	r6, r2
8f616a70:	1afffff9 	bne	8f616a5c <qseecom_register_listener+0xb4>
	if (new_entry) {
		dprintf(CRITICAL, "Service is not unique and is already registered\n");
8f616a74:	e3050048 	movw	r0, #20552	; 0x5048
8f616a78:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616a7c:	eb006fbc 	bl	8f632974 <_dprintf>
		ret = LISTENER_ALREADY_PRESENT_ERROR;
8f616a80:	e3e05001 	mvn	r5, #1
				(new_entry->svc.virt_sb_base))
			free(new_entry->svc.virt_sb_base);
		if (new_entry)
			free(new_entry);
	}
	mutex_release(&qseecom.registered_listener_list_lock);
8f616a84:	e59f01fc 	ldr	r0, [pc, #508]	; 8f616c88 <qseecom_register_listener+0x2e0>
8f616a88:	eb00319d 	bl	8f623104 <mutex_release>
	return ret;
}
8f616a8c:	e59f31f0 	ldr	r3, [pc, #496]	; 8f616c84 <qseecom_register_listener+0x2dc>
8f616a90:	e5932000 	ldr	r2, [r3]
8f616a94:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f616a98:	e0332002 	eors	r2, r3, r2
8f616a9c:	e3a03000 	mov	r3, #0
8f616aa0:	1a000070 	bne	8f616c68 <qseecom_register_listener+0x2c0>
8f616aa4:	e1a00005 	mov	r0, r5
8f616aa8:	e28dd028 	add	r13, r13, #40	; 0x28
8f616aac:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
		dprintf(CRITICAL, "%s: Invalid Input\n", __func__);
8f616ab0:	e3040c74 	movw	r0, #19572	; 0x4c74
8f616ab4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616ab8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616abc:	eb006fac 	bl	8f632974 <_dprintf>
	new_entry = malloc(sizeof(*new_entry));
8f616ac0:	e3a00018 	mov	r0, #24
8f616ac4:	eb00754c 	bl	8f633ffc <malloc>
		dprintf(CRITICAL, "%s new_entry malloc failed for size:%d\n", __func__, sizeof(*new_entry));
8f616ac8:	e3a02018 	mov	r2, #24
	if (!new_entry) {
8f616acc:	e2506000 	subs	r6, r0, #0
8f616ad0:	0a00003a 	beq	8f616bc0 <qseecom_register_listener+0x218>
	memset(new_entry, 0, sizeof(*new_entry));
8f616ad4:	e3a01000 	mov	r1, #0
	new_entry->svc.virt_sb_base = memalign(PAGE_SIZE, ROUNDUP(listnr->sb_size, PAGE_SIZE));
8f616ad8:	e3007fff 	movw	r7, #4095	; 0xfff
	memset(new_entry, 0, sizeof(*new_entry));
8f616adc:	eb0075f8 	bl	8f6342c4 <memset>
	new_entry->svc.listener_id = listnr->id;
8f616ae0:	e5953004 	ldr	r3, [r5, #4]
	new_entry->svc.sb_size = listnr->sb_size;
8f616ae4:	e5951008 	ldr	r1, [r5, #8]
	new_entry->svc.virt_sb_base = memalign(PAGE_SIZE, ROUNDUP(listnr->sb_size, PAGE_SIZE));
8f616ae8:	e3a08a0f 	mov	r8, #61440	; 0xf000
8f616aec:	e34f8fff 	movt	r8, #65535	; 0xffff
8f616af0:	e3a00a01 	mov	r0, #4096	; 0x1000
	new_entry->svc.listener_id = listnr->id;
8f616af4:	e5863008 	str	r3, [r6, #8]
	new_entry->CallbackFn = listnr->service_cmd_handler;
8f616af8:	e595300c 	ldr	r3, [r5, #12]
	new_entry->svc.sb_size = listnr->sb_size;
8f616afc:	e5861010 	str	r1, [r6, #16]
	new_entry->svc.virt_sb_base = memalign(PAGE_SIZE, ROUNDUP(listnr->sb_size, PAGE_SIZE));
8f616b00:	e0811007 	add	r1, r1, r7
8f616b04:	e0011008 	and	r1, r1, r8
	new_entry->CallbackFn = listnr->service_cmd_handler;
8f616b08:	e5863014 	str	r3, [r6, #20]
	new_entry->svc.virt_sb_base = memalign(PAGE_SIZE, ROUNDUP(listnr->sb_size, PAGE_SIZE));
8f616b0c:	eb00754c 	bl	8f634044 <memalign>
		dprintf(CRITICAL, "%s virt_sb_base malloc failed for size:%d\n", __func__, listnr->sb_size);
8f616b10:	e5952008 	ldr	r2, [r5, #8]
	if (!new_entry->svc.virt_sb_base) {
8f616b14:	e3500000 	cmp	r0, #0
	new_entry->svc.virt_sb_base = memalign(PAGE_SIZE, ROUNDUP(listnr->sb_size, PAGE_SIZE));
8f616b18:	e586000c 	str	r0, [r6, #12]
	if (!new_entry->svc.virt_sb_base) {
8f616b1c:	0a000052 	beq	8f616c6c <qseecom_register_listener+0x2c4>
	memset(new_entry->svc.virt_sb_base, 0, ROUNDUP(listnr->sb_size, PAGE_SIZE));
8f616b20:	e0872002 	add	r2, r7, r2
8f616b24:	e3a01000 	mov	r1, #0
8f616b28:	e0022008 	and	r2, r2, r8
8f616b2c:	eb0075e4 	bl	8f6342c4 <memset>
	arch_clean_invalidate_cache_range((addr_t) new_entry->svc.virt_sb_base, ROUNDUP(listnr->sb_size, PAGE_SIZE));
8f616b30:	e5951008 	ldr	r1, [r5, #8]
8f616b34:	e596000c 	ldr	r0, [r6, #12]
8f616b38:	e0871001 	add	r1, r7, r1
8f616b3c:	e0011008 	and	r1, r1, r8
8f616b40:	eb002916 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	req.listener_id = new_entry->svc.listener_id;
8f616b44:	e5962008 	ldr	r2, [r6, #8]
	req.sb_len = new_entry->svc.sb_size;
8f616b48:	e5963010 	ldr	r3, [r6, #16]
	req.qsee_cmd_id = QSEE_REGISTER_LISTENER;
8f616b4c:	e3a01004 	mov	r1, #4
	req.sb_ptr = (uint32_t)__qseecom_uvirt_to_kphys((uint32_t) new_entry->svc.virt_sb_base);
8f616b50:	e596500c 	ldr	r5, [r6, #12]
	dprintf(SPEW, "%s called\n", __func__);
8f616b54:	e3040890 	movw	r0, #18576	; 0x4890
	req.qsee_cmd_id = QSEE_REGISTER_LISTENER;
8f616b58:	e58d1014 	str	r1, [r13, #20]
	dprintf(SPEW, "%s called\n", __func__);
8f616b5c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616b60:	e30512c0 	movw	r1, #21184	; 0x52c0
8f616b64:	e3481f70 	movt	r1, #36720	; 0x8f70
	req.listener_id = new_entry->svc.listener_id;
8f616b68:	e58d2018 	str	r2, [r13, #24]
	req.sb_len = new_entry->svc.sb_size;
8f616b6c:	e58d3020 	str	r3, [r13, #32]
	dprintf(SPEW, "%s called\n", __func__);
8f616b70:	eb006f7f 	bl	8f632974 <_dprintf>
	return (uint32_t)platform_get_virt_to_phys_mapping((addr_t)virt);
8f616b74:	e1a00005 	mov	r0, r5
8f616b78:	ebffaaf5 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	ret = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1, &req,
8f616b7c:	e28d3008 	add	r3, r13, #8
	resp.result = QSEOS_RESULT_INCOMPLETE;
8f616b80:	e3a01001 	mov	r1, #1
	ret = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1, &req,
8f616b84:	e58d3000 	str	r3, [r13]
8f616b88:	e28d2014 	add	r2, r13, #20
8f616b8c:	e3a03010 	mov	r3, #16
	resp.result = QSEOS_RESULT_INCOMPLETE;
8f616b90:	e58d1008 	str	r1, [r13, #8]
	req.sb_ptr = (uint32_t)__qseecom_uvirt_to_kphys((uint32_t) new_entry->svc.virt_sb_base);
8f616b94:	e58d001c 	str	r0, [r13, #28]
	ret = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1, &req,
8f616b98:	e3a000fc 	mov	r0, #252	; 0xfc
8f616b9c:	ebfffb19 	bl	8f615808 <qseecom_scm_call.constprop.0>
	if (ret) {
8f616ba0:	e2505000 	subs	r5, r0, #0
8f616ba4:	1a00000c 	bne	8f616bdc <qseecom_register_listener+0x234>
	item->prev = list->prev;
8f616ba8:	e5943000 	ldr	r3, [r4]
	item->next = list;
8f616bac:	e5864004 	str	r4, [r6, #4]
	list->prev = item;
8f616bb0:	e5846000 	str	r6, [r4]
	item->prev = list->prev;
8f616bb4:	e5863000 	str	r3, [r6]
	list->prev->next = item;
8f616bb8:	e5836004 	str	r6, [r3, #4]
}
8f616bbc:	eaffffb0 	b	8f616a84 <qseecom_register_listener+0xdc>
		dprintf(CRITICAL, "%s new_entry malloc failed for size:%d\n", __func__, sizeof(*new_entry));
8f616bc0:	e305134c 	movw	r1, #21324	; 0x534c
8f616bc4:	e3040fcc 	movw	r0, #20428	; 0x4fcc
8f616bc8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616bcc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616bd0:	e3e05000 	mvn	r5, #0
8f616bd4:	eb006f66 	bl	8f632974 <_dprintf>
		if (new_entry)
8f616bd8:	eaffffa9 	b	8f616a84 <qseecom_register_listener+0xdc>
		dprintf(CRITICAL, "qseecom_scm_call failed with err: %d\n", ret);
8f616bdc:	e3050020 	movw	r0, #20512	; 0x5020
8f616be0:	e1a01005 	mov	r1, r5
8f616be4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616be8:	eb006f61 	bl	8f632974 <_dprintf>
				(new_entry->svc.virt_sb_base))
8f616bec:	e596000c 	ldr	r0, [r6, #12]
		if ((new_entry) &&
8f616bf0:	e3500000 	cmp	r0, #0
8f616bf4:	0a000000 	beq	8f616bfc <qseecom_register_listener+0x254>
			free(new_entry->svc.virt_sb_base);
8f616bf8:	eb007543 	bl	8f63410c <free>
			free(new_entry);
8f616bfc:	e1a00006 	mov	r0, r6
8f616c00:	e3e05000 	mvn	r5, #0
8f616c04:	eb007540 	bl	8f63410c <free>
8f616c08:	eaffff9d 	b	8f616a84 <qseecom_register_listener+0xdc>
		dprintf(CRITICAL, "%s Invalid Input listnr_id:%d sb_size:%d\n",
8f616c0c:	e305134c 	movw	r1, #21324	; 0x534c
8f616c10:	e3040fa0 	movw	r0, #20384	; 0x4fa0
8f616c14:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616c18:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616c1c:	eb006f54 	bl	8f632974 <_dprintf>
		return GENERIC_ERROR;
8f616c20:	e3e05000 	mvn	r5, #0
8f616c24:	eaffff98 	b	8f616a8c <qseecom_register_listener+0xe4>
		dprintf(CRITICAL, "%s qseecom_init not done\n",
8f616c28:	e305134c 	movw	r1, #21324	; 0x534c
8f616c2c:	e3040c9c 	movw	r0, #19612	; 0x4c9c
8f616c30:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616c34:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616c38:	eb006f4d 	bl	8f632974 <_dprintf>
		mutex_release(&qseecom.global_data_lock);
8f616c3c:	e2840058 	add	r0, r4, #88	; 0x58
8f616c40:	eb00312f 	bl	8f623104 <mutex_release>
		return ret;
8f616c44:	e3e05000 	mvn	r5, #0
8f616c48:	eaffff8f 	b	8f616a8c <qseecom_register_listener+0xe4>
		dprintf(CRITICAL, "%s Invalid Input listnr\n", __func__);
8f616c4c:	e305134c 	movw	r1, #21324	; 0x534c
8f616c50:	e3040f84 	movw	r0, #20356	; 0x4f84
8f616c54:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616c58:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616c5c:	eb006f44 	bl	8f632974 <_dprintf>
		return GENERIC_ERROR;
8f616c60:	e3e05000 	mvn	r5, #0
8f616c64:	eaffff88 	b	8f616a8c <qseecom_register_listener+0xe4>
}
8f616c68:	eb006fd4 	bl	8f632bc0 <__stack_chk_fail>
		dprintf(CRITICAL, "%s virt_sb_base malloc failed for size:%d\n", __func__, listnr->sb_size);
8f616c6c:	e305134c 	movw	r1, #21324	; 0x534c
8f616c70:	e3040ff4 	movw	r0, #20468	; 0x4ff4
8f616c74:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616c78:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616c7c:	eb006f3c 	bl	8f632974 <_dprintf>
		goto err;
8f616c80:	eaffffd9 	b	8f616bec <qseecom_register_listener+0x244>
8f616c84:	8f74221c 	.word	0x8f74221c
8f616c88:	8f72d0dc 	.word	0x8f72d0dc

8f616c8c <qseecom_deregister_listener>:
*   Status:
*     0 - Success
*     Negative value indicates failure.
*/
int qseecom_deregister_listener(uint32_t listnr_id)
{
8f616c8c:	e92d4070 	push	{r4, r5, r6, r14}
	int ret = GENERIC_ERROR;
	struct qseecom_registered_listener_list *new_entry = NULL;
	struct qseecom_unregister_listener_ireq req;
	struct qseecom_command_scm_resp resp;

	mutex_acquire(&qseecom.global_data_lock);
8f616c90:	e30d50d4 	movw	r5, #53460	; 0xd0d4
{
8f616c94:	e59f3178 	ldr	r3, [pc, #376]	; 8f616e14 <qseecom_deregister_listener+0x188>
	mutex_acquire(&qseecom.global_data_lock);
8f616c98:	e3485f72 	movt	r5, #36722	; 0x8f72
{
8f616c9c:	e24dd020 	sub	r13, r13, #32
8f616ca0:	e1a06000 	mov	r6, r0
	mutex_acquire(&qseecom.global_data_lock);
8f616ca4:	e2850058 	add	r0, r5, #88	; 0x58
{
8f616ca8:	e5933000 	ldr	r3, [r3]
8f616cac:	e58d301c 	str	r3, [r13, #28]
8f616cb0:	e3a03000 	mov	r3, #0
	mutex_acquire(&qseecom.global_data_lock);
8f616cb4:	eb0030c4 	bl	8f622fcc <mutex_acquire>
	if (!qseecom.qseecom_init_done) {
8f616cb8:	e5953078 	ldr	r3, [r5, #120]	; 0x78
8f616cbc:	e3530000 	cmp	r3, #0
8f616cc0:	0a000049 	beq	8f616dec <qseecom_deregister_listener+0x160>
		dprintf(CRITICAL, "%s qseecom_init not done\n",
							__func__);
		mutex_release(&qseecom.global_data_lock);
		return ret;
	}
	mutex_release(&qseecom.global_data_lock);
8f616cc4:	e2850058 	add	r0, r5, #88	; 0x58
8f616cc8:	eb00310d 	bl	8f623104 <mutex_release>

	mutex_acquire(&qseecom.registered_listener_list_lock);
8f616ccc:	e2850008 	add	r0, r5, #8
8f616cd0:	eb0030bd 	bl	8f622fcc <mutex_acquire>
	dprintf(SPEW, "%s called\n", __func__);
8f616cd4:	e30512fc 	movw	r1, #21244	; 0x52fc
8f616cd8:	e3040890 	movw	r0, #18576	; 0x4890
8f616cdc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616ce0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616ce4:	eb006f22 	bl	8f632974 <_dprintf>
	if (!listener_id) {
8f616ce8:	e3560000 	cmp	r6, #0
		dprintf(CRITICAL, "%s: Invalid Input\n", __func__);
8f616cec:	e305132c 	movw	r1, #21292	; 0x532c
	if (!listener_id) {
8f616cf0:	0a000034 	beq	8f616dc8 <qseecom_deregister_listener+0x13c>
	dprintf(SPEW, "%s called\n", __func__);
8f616cf4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616cf8:	e3040890 	movw	r0, #18576	; 0x4890
8f616cfc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616d00:	eb006f1b 	bl	8f632974 <_dprintf>
	list_for_every_entry(&qseecom.registered_listener_list_head,
8f616d04:	e5954004 	ldr	r4, [r5, #4]
8f616d08:	e1540005 	cmp	r4, r5
8f616d0c:	1a000003 	bne	8f616d20 <qseecom_deregister_listener+0x94>
8f616d10:	ea000030 	b	8f616dd8 <qseecom_deregister_listener+0x14c>
8f616d14:	e5944004 	ldr	r4, [r4, #4]
8f616d18:	e1540005 	cmp	r4, r5
8f616d1c:	0a00002d 	beq	8f616dd8 <qseecom_deregister_listener+0x14c>
		if (entry->svc.listener_id == listener_id) {
8f616d20:	e5943008 	ldr	r3, [r4, #8]
8f616d24:	e1560003 	cmp	r6, r3
8f616d28:	1afffff9 	bne	8f616d14 <qseecom_deregister_listener+0x88>

	req.qsee_cmd_id = QSEE_DEREGISTER_LISTENER;
	req.listener_id = listnr_id;
	resp.result = QSEOS_RESULT_INCOMPLETE;

	ret = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1, &req,
8f616d2c:	e28d0010 	add	r0, r13, #16
	resp.result = QSEOS_RESULT_INCOMPLETE;
8f616d30:	e3a01001 	mov	r1, #1
	ret = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1, &req,
8f616d34:	e58d0000 	str	r0, [r13]
8f616d38:	e28d2008 	add	r2, r13, #8
	req.qsee_cmd_id = QSEE_DEREGISTER_LISTENER;
8f616d3c:	e3a00005 	mov	r0, #5
	ret = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1, &req,
8f616d40:	e3a03008 	mov	r3, #8
	req.qsee_cmd_id = QSEE_DEREGISTER_LISTENER;
8f616d44:	e58d0008 	str	r0, [r13, #8]
	ret = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1, &req,
8f616d48:	e3a000fc 	mov	r0, #252	; 0xfc
	req.listener_id = listnr_id;
8f616d4c:	e58d600c 	str	r6, [r13, #12]
	resp.result = QSEOS_RESULT_INCOMPLETE;
8f616d50:	e58d1010 	str	r1, [r13, #16]
	ret = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1, &req,
8f616d54:	ebfffaab 	bl	8f615808 <qseecom_scm_call.constprop.0>
					sizeof(req), &resp, sizeof(resp));
	if (ret) {
8f616d58:	e2505000 	subs	r5, r0, #0
8f616d5c:	1a000012 	bne	8f616dac <qseecom_deregister_listener+0x120>

#define list_add_before(entry, new_entry) list_add_tail(entry, new_entry)

static inline void list_delete(struct list_node *item)
{
	item->next->prev = item->prev;
8f616d60:	e5942004 	ldr	r2, [r4, #4]
	list_delete(&new_entry->node);

err:
	if (ret == 0) {
		if (new_entry)
			free(new_entry);
8f616d64:	e1a00004 	mov	r0, r4
8f616d68:	e5943000 	ldr	r3, [r4]
8f616d6c:	e5823000 	str	r3, [r2]
	item->prev->next = item->next;
8f616d70:	e5832004 	str	r2, [r3, #4]
	item->prev = item->next = 0;
8f616d74:	e5845004 	str	r5, [r4, #4]
8f616d78:	e5845000 	str	r5, [r4]
8f616d7c:	eb0074e2 	bl	8f63410c <free>
	}
	mutex_release(&qseecom.registered_listener_list_lock);
8f616d80:	e59f0090 	ldr	r0, [pc, #144]	; 8f616e18 <qseecom_deregister_listener+0x18c>
8f616d84:	eb0030de 	bl	8f623104 <mutex_release>
	return ret;
}
8f616d88:	e59f3084 	ldr	r3, [pc, #132]	; 8f616e14 <qseecom_deregister_listener+0x188>
8f616d8c:	e5932000 	ldr	r2, [r3]
8f616d90:	e59d301c 	ldr	r3, [r13, #28]
8f616d94:	e0332002 	eors	r2, r3, r2
8f616d98:	e3a03000 	mov	r3, #0
8f616d9c:	1a00001b 	bne	8f616e10 <qseecom_deregister_listener+0x184>
8f616da0:	e1a00005 	mov	r0, r5
8f616da4:	e28dd020 	add	r13, r13, #32
8f616da8:	e8bd8070 	pop	{r4, r5, r6, r15}
		dprintf(CRITICAL, "scm_call() failed with err: %d (lstnr id=%d)\n",
8f616dac:	e1a01005 	mov	r1, r5
8f616db0:	e59d200c 	ldr	r2, [r13, #12]
8f616db4:	e3050094 	movw	r0, #20628	; 0x5094
8f616db8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616dbc:	eb006eec 	bl	8f632974 <_dprintf>
		ret = GENERIC_ERROR;
8f616dc0:	e3e05000 	mvn	r5, #0
8f616dc4:	eaffffed 	b	8f616d80 <qseecom_deregister_listener+0xf4>
		dprintf(CRITICAL, "%s: Invalid Input\n", __func__);
8f616dc8:	e3040c74 	movw	r0, #19572	; 0x4c74
8f616dcc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616dd0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616dd4:	eb006ee6 	bl	8f632974 <_dprintf>
		dprintf(CRITICAL, "Service not present\n");
8f616dd8:	e305007c 	movw	r0, #20604	; 0x507c
8f616ddc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616de0:	eb006ee3 	bl	8f632974 <_dprintf>
		ret = GENERIC_ERROR;
8f616de4:	e3e05000 	mvn	r5, #0
8f616de8:	eaffffe4 	b	8f616d80 <qseecom_deregister_listener+0xf4>
		dprintf(CRITICAL, "%s qseecom_init not done\n",
8f616dec:	e30512fc 	movw	r1, #21244	; 0x52fc
8f616df0:	e3040c9c 	movw	r0, #19612	; 0x4c9c
8f616df4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616df8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616dfc:	eb006edc 	bl	8f632974 <_dprintf>
		mutex_release(&qseecom.global_data_lock);
8f616e00:	e2850058 	add	r0, r5, #88	; 0x58
8f616e04:	eb0030be 	bl	8f623104 <mutex_release>
		return ret;
8f616e08:	e3e05000 	mvn	r5, #0
8f616e0c:	eaffffdd 	b	8f616d88 <qseecom_deregister_listener+0xfc>
}
8f616e10:	eb006f6a 	bl	8f632bc0 <__stack_chk_fail>
8f616e14:	8f74221c 	.word	0x8f74221c
8f616e18:	8f72d0dc 	.word	0x8f72d0dc

8f616e1c <qseecom_tz_init>:

int qseecom_tz_init()
{
8f616e1c:	e92d4070 	push	{r4, r5, r6, r14}
8f616e20:	e24dd028 	sub	r13, r13, #40	; 0x28
	struct qseecom_command_scm_resp resp;
	int rc = GENERIC_ERROR;
	/* register log buffer scm request */
	void *buf = NULL;
	/* Register app region with TZ */
	req.qsee_cmd_id = QSEE_APP_REGION_NOTIFICATION;
8f616e24:	e3a0300d 	mov	r3, #13
	req.addr = APP_REGION_ADDR;
	req.size = APP_REGION_SIZE;
8f616e28:	e3a02502 	mov	r2, #8388608	; 0x800000
	req.qsee_cmd_id = QSEE_APP_REGION_NOTIFICATION;
8f616e2c:	e58d300c 	str	r3, [r13, #12]
	req.addr = APP_REGION_ADDR;
8f616e30:	e3a01000 	mov	r1, #0
{
8f616e34:	e59f314c 	ldr	r3, [pc, #332]	; 8f616f88 <qseecom_tz_init+0x16c>
	req.addr = APP_REGION_ADDR;
8f616e38:	e34815b0 	movt	r1, #34224	; 0x85b0
	dprintf(ALWAYS, "secure app region addr=0x%x size=0x%x",
8f616e3c:	e30500c4 	movw	r0, #20676	; 0x50c4
8f616e40:	e3480f70 	movt	r0, #36720	; 0x8f70
	req.addr = APP_REGION_ADDR;
8f616e44:	e58d1010 	str	r1, [r13, #16]
{
8f616e48:	e5933000 	ldr	r3, [r3]
8f616e4c:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f616e50:	e3a03000 	mov	r3, #0
	req.size = APP_REGION_SIZE;
8f616e54:	e58d2014 	str	r2, [r13, #20]
	dprintf(ALWAYS, "secure app region addr=0x%x size=0x%x",
8f616e58:	eb006ec5 	bl	8f632974 <_dprintf>
					req.addr, req.size);
	rc = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1,
8f616e5c:	e28dc018 	add	r12, r13, #24
8f616e60:	e28d200c 	add	r2, r13, #12
8f616e64:	e3a0300c 	mov	r3, #12
8f616e68:	e3a01001 	mov	r1, #1
8f616e6c:	e58dc000 	str	r12, [r13]
8f616e70:	e3a000fc 	mov	r0, #252	; 0xfc
8f616e74:	ebfffa63 	bl	8f615808 <qseecom_scm_call.constprop.0>
			&req, sizeof(req),
			&resp, sizeof(resp));
	dprintf(ALWAYS, "TZ App region notif returned with status:%d addr:%x size:%d\n",
8f616e78:	e1cd21d0 	ldrd	r2, [r13, #16]
	rc = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1,
8f616e7c:	e1a04000 	mov	r4, r0
	dprintf(ALWAYS, "TZ App region notif returned with status:%d addr:%x size:%d\n",
8f616e80:	e1a01000 	mov	r1, r0
8f616e84:	e30500ec 	movw	r0, #20716	; 0x50ec
8f616e88:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616e8c:	eb006eb8 	bl	8f632974 <_dprintf>
			rc, req.addr, req.size);
	if (rc)
8f616e90:	e3540000 	cmp	r4, #0
8f616e94:	0a000008 	beq	8f616ebc <qseecom_tz_init+0xa0>
	if (!rc) {
		qseecom.qseecom_tz_init_done = 1;
		dprintf(ALWAYS, "Qseecom TZ Init Done in Appsbl\n");
	}
	return rc;
}
8f616e98:	e59f30e8 	ldr	r3, [pc, #232]	; 8f616f88 <qseecom_tz_init+0x16c>
8f616e9c:	e5932000 	ldr	r2, [r3]
8f616ea0:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f616ea4:	e0332002 	eors	r2, r3, r2
8f616ea8:	e3a03000 	mov	r3, #0
8f616eac:	1a000032 	bne	8f616f7c <qseecom_tz_init+0x160>
8f616eb0:	e1a00004 	mov	r0, r4
8f616eb4:	e28dd028 	add	r13, r13, #40	; 0x28
8f616eb8:	e8bd8070 	pop	{r4, r5, r6, r15}
	buf = memalign(PAGE_SIZE, ROUNDUP(QSEE_LOG_BUF_SIZE, PAGE_SIZE));
8f616ebc:	e3a01a01 	mov	r1, #4096	; 0x1000
8f616ec0:	e1a00001 	mov	r0, r1
8f616ec4:	eb00745e 	bl	8f634044 <memalign>
	if (!buf) {
8f616ec8:	e2506000 	subs	r6, r0, #0
8f616ecc:	0a00002b 	beq	8f616f80 <qseecom_tz_init+0x164>
	memset(buf, 0, ROUNDUP(QSEE_LOG_BUF_SIZE, PAGE_SIZE));
8f616ed0:	e3a02a01 	mov	r2, #4096	; 0x1000
8f616ed4:	e1a01004 	mov	r1, r4
8f616ed8:	eb0074f9 	bl	8f6342c4 <memset>
	logbuf_req.qsee_cmd_id = QSEE_REGISTER_LOG_BUF_COMMAND;
8f616edc:	e30d50c8 	movw	r5, #53448	; 0xd0c8
	arch_clean_invalidate_cache_range((addr_t) buf, QSEE_LOG_BUF_SIZE);
8f616ee0:	e3a01a01 	mov	r1, #4096	; 0x1000
	logbuf_req.qsee_cmd_id = QSEE_REGISTER_LOG_BUF_COMMAND;
8f616ee4:	e3485f72 	movt	r5, #36722	; 0x8f72
	arch_clean_invalidate_cache_range((addr_t) buf, QSEE_LOG_BUF_SIZE);
8f616ee8:	e1a00006 	mov	r0, r6
8f616eec:	eb00282b 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	dprintf(SPEW, "%s called\n", __func__);
8f616ef0:	e30512c0 	movw	r1, #21184	; 0x52c0
8f616ef4:	e3040890 	movw	r0, #18576	; 0x4890
8f616ef8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616efc:	e3480f70 	movt	r0, #36720	; 0x8f70
	logbuf_req.qsee_cmd_id = QSEE_REGISTER_LOG_BUF_COMMAND;
8f616f00:	e3a0300e 	mov	r3, #14
8f616f04:	e5853000 	str	r3, [r5]
	dprintf(SPEW, "%s called\n", __func__);
8f616f08:	eb006e99 	bl	8f632974 <_dprintf>
	return (uint32_t)platform_get_virt_to_phys_mapping((addr_t)virt);
8f616f0c:	e1a00006 	mov	r0, r6
8f616f10:	ebffaa0f 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	rc = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1,
8f616f14:	e28d1018 	add	r1, r13, #24
8f616f18:	e3a0300c 	mov	r3, #12
8f616f1c:	e1a02005 	mov	r2, r5
8f616f20:	e58d1000 	str	r1, [r13]
8f616f24:	e3a01001 	mov	r1, #1
	logbuf_req.len = QSEE_LOG_BUF_SIZE;
8f616f28:	e3a0ca01 	mov	r12, #4096	; 0x1000
8f616f2c:	e585c008 	str	r12, [r5, #8]
	logbuf_req.phy_addr = (uint32_t)__qseecom_uvirt_to_kphys((uint32_t) buf);
8f616f30:	e5850004 	str	r0, [r5, #4]
	rc = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1,
8f616f34:	e3a000fc 	mov	r0, #252	; 0xfc
8f616f38:	ebfffa32 	bl	8f615808 <qseecom_scm_call.constprop.0>
	dprintf(ALWAYS, "TZ App log region register returned with status:%d addr:%x size:%d\n",
8f616f3c:	e1c520d4 	ldrd	r2, [r5, #4]
	rc = qseecom_scm_call(SCM_SVC_TZSCHEDULER, 1,
8f616f40:	e1a04000 	mov	r4, r0
	dprintf(ALWAYS, "TZ App log region register returned with status:%d addr:%x size:%d\n",
8f616f44:	e1a01000 	mov	r1, r0
8f616f48:	e305012c 	movw	r0, #20780	; 0x512c
8f616f4c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616f50:	eb006e87 	bl	8f632974 <_dprintf>
	if (!rc) {
8f616f54:	e3540000 	cmp	r4, #0
8f616f58:	1affffce 	bne	8f616e98 <qseecom_tz_init+0x7c>
		qseecom.qseecom_tz_init_done = 1;
8f616f5c:	e30d30d4 	movw	r3, #53460	; 0xd0d4
8f616f60:	e3483f72 	movt	r3, #36722	; 0x8f72
		dprintf(ALWAYS, "Qseecom TZ Init Done in Appsbl\n");
8f616f64:	e3050170 	movw	r0, #20848	; 0x5170
8f616f68:	e3480f70 	movt	r0, #36720	; 0x8f70
		qseecom.qseecom_tz_init_done = 1;
8f616f6c:	e3a02001 	mov	r2, #1
8f616f70:	e583207c 	str	r2, [r3, #124]	; 0x7c
		dprintf(ALWAYS, "Qseecom TZ Init Done in Appsbl\n");
8f616f74:	eb006e7e 	bl	8f632974 <_dprintf>
8f616f78:	eaffffc6 	b	8f616e98 <qseecom_tz_init+0x7c>
}
8f616f7c:	eb006f0f 	bl	8f632bc0 <__stack_chk_fail>
		rc = GENERIC_ERROR;
8f616f80:	e3e04000 	mvn	r4, #0
	return rc;
8f616f84:	eaffffc3 	b	8f616e98 <qseecom_tz_init+0x7c>
8f616f88:	8f74221c 	.word	0x8f74221c

8f616f8c <qseecom_init>:

int qseecom_init()
{
8f616f8c:	e92d4030 	push	{r4, r5, r14}
	int rc = GENERIC_ERROR;
	struct qseecom_command_scm_resp resp;
	uint32_t ver = TZ_FVER_QSEE;

	memset (&qseecom, 0, sizeof(struct qseecom_control));
8f616f90:	e30d40d4 	movw	r4, #53460	; 0xd0d4
8f616f94:	e3484f72 	movt	r4, #36722	; 0x8f72
{
8f616f98:	e24dd024 	sub	r13, r13, #36	; 0x24
8f616f9c:	e59fc0cc 	ldr	r12, [pc, #204]	; 8f617070 <qseecom_init+0xe4>
	memset (&qseecom, 0, sizeof(struct qseecom_control));
8f616fa0:	e3a02080 	mov	r2, #128	; 0x80
8f616fa4:	e3a01000 	mov	r1, #0
8f616fa8:	e1a00004 	mov	r0, r4
{
8f616fac:	e59cc000 	ldr	r12, [r12]
8f616fb0:	e58dc01c 	str	r12, [r13, #28]
8f616fb4:	e3a0c000 	mov	r12, #0
	uint32_t ver = TZ_FVER_QSEE;
8f616fb8:	e3a0300a 	mov	r3, #10
8f616fbc:	e58d300c 	str	r3, [r13, #12]
	memset (&qseecom, 0, sizeof(struct qseecom_control));
8f616fc0:	eb0074bf 	bl	8f6342c4 <memset>
	dprintf(SPEW, "%s called\n", __func__);
8f616fc4:	e30511f0 	movw	r1, #20976	; 0x51f0
8f616fc8:	e3040890 	movw	r0, #18576	; 0x4890
8f616fcc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f616fd0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f616fd4:	eb006e66 	bl	8f632974 <_dprintf>
	mutex_init(&(qseecom.global_data_lock));
8f616fd8:	e2840058 	add	r0, r4, #88	; 0x58
8f616fdc:	eb002fe3 	bl	8f622f70 <mutex_init>
	mutex_init(&(qseecom.registered_app_list_lock));
8f616fe0:	e284002c 	add	r0, r4, #44	; 0x2c
8f616fe4:	eb002fe1 	bl	8f622f70 <mutex_init>
	mutex_init(&(qseecom.registered_listener_list_lock));
8f616fe8:	e2840008 	add	r0, r4, #8
8f616fec:	eb002fdf 	bl	8f622f70 <mutex_init>

	list_initialize(&(qseecom.registered_app_list_head));
	list_initialize(&(qseecom.registered_listener_list_head));

	rc = qseecom_scm_call(TZ_SVC_INFO, 3,
8f616ff0:	e28d0010 	add	r0, r13, #16
8f616ff4:	e28d200c 	add	r2, r13, #12
8f616ff8:	e58d0000 	str	r0, [r13]
8f616ffc:	e3a03004 	mov	r3, #4
	list->prev = list->next = list;
8f617000:	e2840024 	add	r0, r4, #36	; 0x24
8f617004:	e3a01003 	mov	r1, #3
8f617008:	e5840028 	str	r0, [r4, #40]	; 0x28
8f61700c:	e5840024 	str	r0, [r4, #36]	; 0x24
8f617010:	e3a00006 	mov	r0, #6
8f617014:	e5844004 	str	r4, [r4, #4]
8f617018:	e5844000 	str	r4, [r4]
8f61701c:	ebfff9f9 	bl	8f615808 <qseecom_scm_call.constprop.0>
						  &ver, sizeof(ver),
						  &resp, sizeof(resp));

	if (!rc) {
8f617020:	e2505000 	subs	r5, r0, #0
8f617024:	0a000008 	beq	8f61704c <qseecom_init+0xc0>
		qseecom.qseecom_init_done = 1;
		qseecom.qseos_version = resp.result;
		dprintf(ALWAYS, "Qseecom Init Done in Appsbl version is 0x%x\n",resp.result);
	}
	return rc;
}
8f617028:	e59f3040 	ldr	r3, [pc, #64]	; 8f617070 <qseecom_init+0xe4>
8f61702c:	e5932000 	ldr	r2, [r3]
8f617030:	e59d301c 	ldr	r3, [r13, #28]
8f617034:	e0332002 	eors	r2, r3, r2
8f617038:	e3a03000 	mov	r3, #0
8f61703c:	1a00000a 	bne	8f61706c <qseecom_init+0xe0>
8f617040:	e1a00005 	mov	r0, r5
8f617044:	e28dd024 	add	r13, r13, #36	; 0x24
8f617048:	e8bd8030 	pop	{r4, r5, r15}
		qseecom.qseos_version = resp.result;
8f61704c:	e59d1010 	ldr	r1, [r13, #16]
		dprintf(ALWAYS, "Qseecom Init Done in Appsbl version is 0x%x\n",resp.result);
8f617050:	e3050190 	movw	r0, #20880	; 0x5190
8f617054:	e3480f70 	movt	r0, #36720	; 0x8f70
		qseecom.qseecom_init_done = 1;
8f617058:	e3a03001 	mov	r3, #1
8f61705c:	e5843078 	str	r3, [r4, #120]	; 0x78
		qseecom.qseos_version = resp.result;
8f617060:	e5841048 	str	r1, [r4, #72]	; 0x48
		dprintf(ALWAYS, "Qseecom Init Done in Appsbl version is 0x%x\n",resp.result);
8f617064:	eb006e42 	bl	8f632974 <_dprintf>
	return rc;
8f617068:	eaffffee 	b	8f617028 <qseecom_init+0x9c>
}
8f61706c:	eb006ed3 	bl	8f632bc0 <__stack_chk_fail>
8f617070:	8f74221c 	.word	0x8f74221c

8f617074 <qseecom_get_version>:

unsigned int qseecom_get_version()
{
	return qseecom.qseos_version;
8f617074:	e30d30d4 	movw	r3, #53460	; 0xd0d4
8f617078:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f61707c:	e59f2038 	ldr	r2, [pc, #56]	; 8f6170bc <qseecom_get_version+0x48>
8f617080:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f617084:	e24dd00c 	sub	r13, r13, #12
	return qseecom.qseos_version;
8f617088:	e5930048 	ldr	r0, [r3, #72]	; 0x48
{
8f61708c:	e5922000 	ldr	r2, [r2]
8f617090:	e58d2004 	str	r2, [r13, #4]
8f617094:	e3a02000 	mov	r2, #0
}
8f617098:	e59f301c 	ldr	r3, [pc, #28]	; 8f6170bc <qseecom_get_version+0x48>
8f61709c:	e5932000 	ldr	r2, [r3]
8f6170a0:	e59d3004 	ldr	r3, [r13, #4]
8f6170a4:	e0332002 	eors	r2, r3, r2
8f6170a8:	e3a03000 	mov	r3, #0
8f6170ac:	1a000001 	bne	8f6170b8 <qseecom_get_version+0x44>
8f6170b0:	e28dd00c 	add	r13, r13, #12
8f6170b4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6170b8:	eb006ec0 	bl	8f632bc0 <__stack_chk_fail>
8f6170bc:	8f74221c 	.word	0x8f74221c

8f6170c0 <qseecom_exit>:

int qseecom_exit()
{
8f6170c0:	e59f3084 	ldr	r3, [pc, #132]	; 8f61714c <qseecom_exit+0x8c>
	dprintf(SPEW, "%s called\n", __func__);
8f6170c4:	e30511e0 	movw	r1, #20960	; 0x51e0
{
8f6170c8:	e92d4010 	push	{r4, r14}
	dprintf(SPEW, "%s called\n", __func__);
8f6170cc:	e3481f70 	movt	r1, #36720	; 0x8f70
{
8f6170d0:	e24dd008 	sub	r13, r13, #8
	dprintf(SPEW, "%s called\n", __func__);
8f6170d4:	e3040890 	movw	r0, #18576	; 0x4890
8f6170d8:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f6170dc:	e5933000 	ldr	r3, [r3]
8f6170e0:	e58d3004 	str	r3, [r13, #4]
8f6170e4:	e3a03000 	mov	r3, #0
	dprintf(SPEW, "%s called\n", __func__);
8f6170e8:	eb006e21 	bl	8f632974 <_dprintf>

	if (logbuf_req.phy_addr)
8f6170ec:	e30d30c8 	movw	r3, #53448	; 0xd0c8
8f6170f0:	e3483f72 	movt	r3, #36722	; 0x8f72
8f6170f4:	e5930004 	ldr	r0, [r3, #4]
8f6170f8:	e3500000 	cmp	r0, #0
8f6170fc:	1a00000f 	bne	8f617140 <qseecom_exit+0x80>
		free((void *)logbuf_req.phy_addr);
	qseecom.qseecom_init_done = 0;
8f617100:	e30d30d4 	movw	r3, #53460	; 0xd0d4
8f617104:	e3483f72 	movt	r3, #36722	; 0x8f72
	dprintf(ALWAYS, "Qseecom De-Init Done in Appsbl\n");
8f617108:	e30501c0 	movw	r0, #20928	; 0x51c0
8f61710c:	e3480f70 	movt	r0, #36720	; 0x8f70
	qseecom.qseecom_init_done = 0;
8f617110:	e3a04000 	mov	r4, #0
8f617114:	e5834078 	str	r4, [r3, #120]	; 0x78
	dprintf(ALWAYS, "Qseecom De-Init Done in Appsbl\n");
8f617118:	eb006e15 	bl	8f632974 <_dprintf>
	return 0;
}
8f61711c:	e59f3028 	ldr	r3, [pc, #40]	; 8f61714c <qseecom_exit+0x8c>
8f617120:	e5932000 	ldr	r2, [r3]
8f617124:	e59d3004 	ldr	r3, [r13, #4]
8f617128:	e0332002 	eors	r2, r3, r2
8f61712c:	e3a03000 	mov	r3, #0
8f617130:	1a000004 	bne	8f617148 <qseecom_exit+0x88>
8f617134:	e1a00004 	mov	r0, r4
8f617138:	e28dd008 	add	r13, r13, #8
8f61713c:	e8bd8010 	pop	{r4, r15}
		free((void *)logbuf_req.phy_addr);
8f617140:	eb0073f1 	bl	8f63410c <free>
8f617144:	eaffffed 	b	8f617100 <qseecom_exit+0x40>
}
8f617148:	eb006e9c 	bl	8f632bc0 <__stack_chk_fail>
8f61714c:	8f74221c 	.word	0x8f74221c

8f617150 <platform_dt_absolute_match>:

	return 0;
}

static int platform_dt_absolute_match(struct dt_entry *cur_dt_entry, struct dt_entry_node *dt_list)
{
8f617150:	e59f3244 	ldr	r3, [pc, #580]	; 8f61739c <platform_dt_absolute_match+0x24c>
8f617154:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f617158:	e24dd02c 	sub	r13, r13, #44	; 0x2c

	/* Platform-id
	* bit no |31	 24|23	16|15	0|
	*        |reserved|foundry-id|msm-id|
	*/
	cur_dt_msm_id = (cur_dt_entry->platform_id & 0x0000ffff);
8f61715c:	e1d050b0 	ldrh	r5, [r0]
{
8f617160:	e5933000 	ldr	r3, [r3]
8f617164:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f617168:	e3a03000 	mov	r3, #0
	cur_dt_hw_platform = (cur_dt_entry->variant_id & 0x000000ff);
8f61716c:	e5907004 	ldr	r7, [r0, #4]
{
8f617170:	e1a04000 	mov	r4, r0
	cur_dt_hw_subtype = (cur_dt_entry->board_hw_subtype & 0xff);
8f617174:	e5909008 	ldr	r9, [r0, #8]
	/* 1. must match the msm_id, platform_hw_id, platform_subtype and DDR size
	*  soc, board major/minor, pmic major/minor must less than board info
	*  2. find the matched DTB then return 1
	*  3. otherwise return 0
	*/
	if((cur_dt_msm_id == (board_platform_id() & 0x0000ffff)) &&
8f617178:	e1a0800e 	mov	r8, r14
{
8f61717c:	e1a06001 	mov	r6, r1
	if((cur_dt_msm_id == (board_platform_id() & 0x0000ffff)) &&
8f617180:	ebffe411 	bl	8f6101cc <board_platform_id>
8f617184:	e6ff0070 	uxth	r0, r0
8f617188:	e1500005 	cmp	r0, r5
8f61718c:	0a000008 	beq	8f6171b4 <platform_dt_absolute_match+0x64>
			dt_node_tmp->dt_entry_m->offset, dt_node_tmp->dt_entry_m->size);

		insert_dt_entry_in_queue(dt_list, dt_node_tmp);
		return 1;
	}
	return 0;
8f617190:	e3a00000 	mov	r0, #0
}
8f617194:	e59f3200 	ldr	r3, [pc, #512]	; 8f61739c <platform_dt_absolute_match+0x24c>
8f617198:	e5932000 	ldr	r2, [r3]
8f61719c:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f6171a0:	e0332002 	eors	r2, r3, r2
8f6171a4:	e3a03000 	mov	r3, #0
8f6171a8:	1a000064 	bne	8f617340 <platform_dt_absolute_match+0x1f0>
8f6171ac:	e28dd02c 	add	r13, r13, #44	; 0x2c
8f6171b0:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
		(cur_dt_hw_platform == board_hardware_id()) &&
8f6171b4:	ebffe42a 	bl	8f610264 <board_hardware_id>
	cur_dt_hw_platform = (cur_dt_entry->variant_id & 0x000000ff);
8f6171b8:	e6ef7077 	uxtb	r7, r7
	if((cur_dt_msm_id == (board_platform_id() & 0x0000ffff)) &&
8f6171bc:	e1500007 	cmp	r0, r7
8f6171c0:	1afffff2 	bne	8f617190 <platform_dt_absolute_match+0x40>
		(cur_dt_hw_subtype == board_hardware_subtype()) &&
8f6171c4:	ebffe439 	bl	8f6102b0 <board_hardware_subtype>
	cur_dt_hw_subtype = (cur_dt_entry->board_hw_subtype & 0xff);
8f6171c8:	e6ef3079 	uxtb	r3, r9
		(cur_dt_hw_platform == board_hardware_id()) &&
8f6171cc:	e1500003 	cmp	r0, r3
8f6171d0:	1affffee 	bne	8f617190 <platform_dt_absolute_match+0x40>
		(cur_dt_hlos_ddr == (target_get_hlos_subtype() & 0x700)) &&
8f6171d4:	eb002a8c 	bl	8f621c0c <target_get_hlos_subtype>
	cur_dt_hlos_ddr = (cur_dt_entry->board_hw_subtype & 0x700);
8f6171d8:	e2099c07 	and	r9, r9, #1792	; 0x700
		(cur_dt_hlos_ddr == (target_get_hlos_subtype() & 0x700)) &&
8f6171dc:	e2003c07 	and	r3, r0, #1792	; 0x700
		(cur_dt_hw_subtype == board_hardware_subtype()) &&
8f6171e0:	e1530009 	cmp	r3, r9
8f6171e4:	1affffe9 	bne	8f617190 <platform_dt_absolute_match+0x40>
		(cur_dt_entry->soc_rev <= board_soc_version()) &&
8f6171e8:	e594500c 	ldr	r5, [r4, #12]
8f6171ec:	ebffe488 	bl	8f610414 <board_soc_version>
		(cur_dt_hlos_ddr == (target_get_hlos_subtype() & 0x700)) &&
8f6171f0:	e1550000 	cmp	r5, r0
8f6171f4:	8affffe5 	bhi	8f617190 <platform_dt_absolute_match+0x40>
		((cur_dt_entry->variant_id & 0x00ffff00) <= (board_target_id() & 0x00ffff00)) &&
8f6171f8:	e5947004 	ldr	r7, [r4, #4]
8f6171fc:	ebffe405 	bl	8f610218 <board_target_id>
8f617200:	e3a05cff 	mov	r5, #65280	; 0xff00
8f617204:	e34050ff 	movt	r5, #255	; 0xff
8f617208:	e0077005 	and	r7, r7, r5
8f61720c:	e0003005 	and	r3, r0, r5
		(cur_dt_entry->soc_rev <= board_soc_version()) &&
8f617210:	e1570003 	cmp	r7, r3
8f617214:	8affffdd 	bhi	8f617190 <platform_dt_absolute_match+0x40>
		((cur_dt_entry->pmic_rev[0] & 0x00ffff00) <= (board_pmic_target(0) & 0x00ffff00)) &&
8f617218:	e3a00000 	mov	r0, #0
8f61721c:	e5947010 	ldr	r7, [r4, #16]
8f617220:	ebffe448 	bl	8f610348 <board_pmic_target>
8f617224:	e0077005 	and	r7, r7, r5
8f617228:	e0003005 	and	r3, r0, r5
		((cur_dt_entry->variant_id & 0x00ffff00) <= (board_target_id() & 0x00ffff00)) &&
8f61722c:	e1570003 	cmp	r7, r3
8f617230:	8affffd6 	bhi	8f617190 <platform_dt_absolute_match+0x40>
		((cur_dt_entry->pmic_rev[1] & 0x00ffff00) <= (board_pmic_target(1) & 0x00ffff00)) &&
8f617234:	e3a00001 	mov	r0, #1
8f617238:	e5947014 	ldr	r7, [r4, #20]
8f61723c:	ebffe441 	bl	8f610348 <board_pmic_target>
8f617240:	e0077005 	and	r7, r7, r5
8f617244:	e0003005 	and	r3, r0, r5
		((cur_dt_entry->pmic_rev[0] & 0x00ffff00) <= (board_pmic_target(0) & 0x00ffff00)) &&
8f617248:	e1570003 	cmp	r7, r3
8f61724c:	8affffcf 	bhi	8f617190 <platform_dt_absolute_match+0x40>
		((cur_dt_entry->pmic_rev[2] & 0x00ffff00) <= (board_pmic_target(2) & 0x00ffff00)) &&
8f617250:	e3a00002 	mov	r0, #2
8f617254:	e5947018 	ldr	r7, [r4, #24]
8f617258:	ebffe43a 	bl	8f610348 <board_pmic_target>
8f61725c:	e0077005 	and	r7, r7, r5
8f617260:	e0003005 	and	r3, r0, r5
		((cur_dt_entry->pmic_rev[1] & 0x00ffff00) <= (board_pmic_target(1) & 0x00ffff00)) &&
8f617264:	e1570003 	cmp	r7, r3
8f617268:	8affffc8 	bhi	8f617190 <platform_dt_absolute_match+0x40>
		((cur_dt_entry->pmic_rev[3] & 0x00ffff00) <= (board_pmic_target(3) & 0x00ffff00))) {
8f61726c:	e3a00003 	mov	r0, #3
8f617270:	e594701c 	ldr	r7, [r4, #28]
8f617274:	ebffe433 	bl	8f610348 <board_pmic_target>
8f617278:	e0077005 	and	r7, r7, r5
8f61727c:	e0055000 	and	r5, r5, r0
		((cur_dt_entry->pmic_rev[2] & 0x00ffff00) <= (board_pmic_target(2) & 0x00ffff00)) &&
8f617280:	e1570005 	cmp	r7, r5
8f617284:	8affffc1 	bhi	8f617190 <platform_dt_absolute_match+0x40>
		malloc(sizeof(struct dt_entry_node));
8f617288:	e3a0000c 	mov	r0, #12
8f61728c:	eb00735a 	bl	8f633ffc <malloc>
	ASSERT(dt_node_member);
8f617290:	e2505000 	subs	r5, r0, #0
8f617294:	0a000035 	beq	8f617370 <platform_dt_absolute_match+0x220>
	item->prev = item->next = 0;
8f617298:	e3a03000 	mov	r3, #0
			malloc(sizeof(struct dt_entry));
8f61729c:	e3a00028 	mov	r0, #40	; 0x28
8f6172a0:	e5853004 	str	r3, [r5, #4]
8f6172a4:	e5853000 	str	r3, [r5]
8f6172a8:	eb007353 	bl	8f633ffc <malloc>
	ASSERT(dt_node_member->dt_entry_m);
8f6172ac:	e3500000 	cmp	r0, #0
	dt_node_member->dt_entry_m = (struct dt_entry *)
8f6172b0:	e5850008 	str	r0, [r5, #8]
	ASSERT(dt_node_member->dt_entry_m);
8f6172b4:	0a000022 	beq	8f617344 <platform_dt_absolute_match+0x1f4>
	memset(dt_node_member->dt_entry_m ,0 ,sizeof(struct dt_entry));
8f6172b8:	e3a02028 	mov	r2, #40	; 0x28
8f6172bc:	e3a01000 	mov	r1, #0
8f6172c0:	e5950008 	ldr	r0, [r5, #8]
8f6172c4:	eb0073fe 	bl	8f6342c4 <memset>
		memcpy((char*)dt_node_tmp->dt_entry_m,(char*)cur_dt_entry, sizeof(struct dt_entry));
8f6172c8:	e3a02028 	mov	r2, #40	; 0x28
8f6172cc:	e1a01004 	mov	r1, r4
8f6172d0:	e5950008 	ldr	r0, [r5, #8]
8f6172d4:	eb0073b7 	bl	8f6341b8 <memcpy>
		dprintf(SPEW, "Add DTB entry %u/%08x/0x%08x/%x/%x/%x/%x/%x/%x/%x\n",
8f6172d8:	e5951008 	ldr	r1, [r5, #8]
8f6172dc:	e30507a0 	movw	r0, #22432	; 0x57a0
8f6172e0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6172e4:	e5913024 	ldr	r3, [r1, #36]	; 0x24
8f6172e8:	e58d3018 	str	r3, [r13, #24]
8f6172ec:	e5913020 	ldr	r3, [r1, #32]
8f6172f0:	e58d3014 	str	r3, [r13, #20]
8f6172f4:	e591301c 	ldr	r3, [r1, #28]
8f6172f8:	e58d3010 	str	r3, [r13, #16]
8f6172fc:	e5913018 	ldr	r3, [r1, #24]
8f617300:	e58d300c 	str	r3, [r13, #12]
8f617304:	e5913014 	ldr	r3, [r1, #20]
8f617308:	e58d3008 	str	r3, [r13, #8]
8f61730c:	e5913010 	ldr	r3, [r1, #16]
8f617310:	e58d3004 	str	r3, [r13, #4]
8f617314:	e591300c 	ldr	r3, [r1, #12]
8f617318:	e58d3000 	str	r3, [r13]
8f61731c:	e1c120d4 	ldrd	r2, [r1, #4]
8f617320:	e5911000 	ldr	r1, [r1]
8f617324:	eb006d92 	bl	8f632974 <_dprintf>
	item->prev = list->prev;
8f617328:	e5963000 	ldr	r3, [r6]
		return 1;
8f61732c:	e3a00001 	mov	r0, #1
8f617330:	e8850048 	stm	r5, {r3, r6}
	list->prev->next = item;
8f617334:	e5835004 	str	r5, [r3, #4]
	list->prev = item;
8f617338:	e5865000 	str	r5, [r6]
8f61733c:	eaffff94 	b	8f617194 <platform_dt_absolute_match+0x44>
}
8f617340:	eb006e1e 	bl	8f632bc0 <__stack_chk_fail>
	ASSERT(dt_node_member->dt_entry_m);
8f617344:	e3053784 	movw	r3, #22404	; 0x5784
8f617348:	e1a00008 	mov	r0, r8
8f61734c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f617350:	e3052754 	movw	r2, #22356	; 0x5754
8f617354:	e58d3000 	str	r3, [r13]
8f617358:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61735c:	e3a0309f 	mov	r3, #159	; 0x9f
8f617360:	e3001130 	movw	r1, #304	; 0x130
8f617364:	e3481f70 	movt	r1, #36720	; 0x8f70
8f617368:	eb006dd3 	bl	8f632abc <_panic>
8f61736c:	eaffffd1 	b	8f6172b8 <platform_dt_absolute_match+0x168>
	ASSERT(dt_node_member);
8f617370:	e3053774 	movw	r3, #22388	; 0x5774
8f617374:	e3052754 	movw	r2, #22356	; 0x5754
8f617378:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61737c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f617380:	e58d3000 	str	r3, [r13]
8f617384:	e3001130 	movw	r1, #304	; 0x130
8f617388:	e3a0309a 	mov	r3, #154	; 0x9a
8f61738c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f617390:	e1a00008 	mov	r0, r8
8f617394:	eb006dc8 	bl	8f632abc <_panic>
8f617398:	eaffffbe 	b	8f617298 <platform_dt_absolute_match+0x148>
8f61739c:	8f74221c 	.word	0x8f74221c

8f6173a0 <update_dtb_entry_node>:
	}

	return 1;
}

static int update_dtb_entry_node(struct dt_entry_node *dt_list, uint32_t dtb_info) {
8f6173a0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f6173a4:	e24dd02c 	sub	r13, r13, #44	; 0x2c
	uint32_t current_info = 0;
	uint32_t board_info = 0;
	uint32_t best_info = 0;

	/* start to select the best entry*/
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f6173a8:	e5904004 	ldr	r4, [r0, #4]
static int update_dtb_entry_node(struct dt_entry_node *dt_list, uint32_t dtb_info) {
8f6173ac:	e59f3348 	ldr	r3, [pc, #840]	; 8f6176fc <update_dtb_entry_node+0x35c>
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f6173b0:	e1500004 	cmp	r0, r4
static int update_dtb_entry_node(struct dt_entry_node *dt_list, uint32_t dtb_info) {
8f6173b4:	e5933000 	ldr	r3, [r3]
8f6173b8:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f6173bc:	e3a03000 	mov	r3, #0
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f6173c0:	0a0000a7 	beq	8f617664 <update_dtb_entry_node+0x2c4>
		if (!dt_node_tmp1){
8f6173c4:	e3540000 	cmp	r4, #0
8f6173c8:	e1a07000 	mov	r7, r0
8f6173cc:	e1a0a001 	mov	r10, r1
8f6173d0:	0a0000c1 	beq	8f6176dc <update_dtb_entry_node+0x33c>
		case DTB_PMIC2:
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[2]) & 0x00ffff00);
			board_info = (board_pmic_target(2) & 0x00ffff00);
			break;
		case DTB_PMIC3:
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[3]) & 0x00ffff00);
8f6173d4:	e3a09cff 	mov	r9, #65280	; 0xff00
		}
		if ((current_info < board_info) && (current_info > best_info)) {
			best_info = current_info;
		}
		if (current_info < best_info) {
			dprintf(SPEW, "Delete don't fit DTB entry %u/%08x/0x%08x/%x/%x/%x/%x/%x/%x/%x\n",
8f6173d8:	e305b7f0 	movw	r11, #22512	; 0x57f0
8f6173dc:	e2416002 	sub	r6, r1, #2
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[3]) & 0x00ffff00);
8f6173e0:	e34090ff 	movt	r9, #255	; 0xff
			dprintf(SPEW, "Delete don't fit DTB entry %u/%08x/0x%08x/%x/%x/%x/%x/%x/%x/%x\n",
8f6173e4:	e348bf70 	movt	r11, #36720	; 0x8f70
	uint32_t best_info = 0;
8f6173e8:	e3a08000 	mov	r8, #0
			current_info = dt_node_tmp1->dt_entry_m->soc_rev;
8f6173ec:	e5943008 	ldr	r3, [r4, #8]
		switch(dtb_info) {
8f6173f0:	e3560004 	cmp	r6, #4
8f6173f4:	979ff106 	ldrls	r15, [r15, r6, lsl #2]
8f6173f8:	ea0000bc 	b	8f6176f0 <update_dtb_entry_node+0x350>
8f6173fc:	8f61759c 	.word	0x8f61759c
8f617400:	8f617584 	.word	0x8f617584
8f617404:	8f61756c 	.word	0x8f61756c
8f617408:	8f617544 	.word	0x8f617544
8f61740c:	8f617410 	.word	0x8f617410
			board_info = (board_pmic_target(3) & 0x00ffff00);
8f617410:	e3a00003 	mov	r0, #3
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[3]) & 0x00ffff00);
8f617414:	e593501c 	ldr	r5, [r3, #28]
			board_info = (board_pmic_target(3) & 0x00ffff00);
8f617418:	ebffe3ca 	bl	8f610348 <board_pmic_target>
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[3]) & 0x00ffff00);
8f61741c:	e0055009 	and	r5, r5, r9
			board_info = (board_pmic_target(3) & 0x00ffff00);
8f617420:	e0000009 	and	r0, r0, r9
		if (current_info == board_info) {
8f617424:	e1550000 	cmp	r5, r0
8f617428:	0a00004c 	beq	8f617560 <update_dtb_entry_node+0x1c0>
		if ((current_info < board_info) && (current_info > best_info)) {
8f61742c:	33a03001 	movcc	r3, #1
8f617430:	23a03000 	movcs	r3, #0
8f617434:	e1550008 	cmp	r5, r8
8f617438:	93a03000 	movls	r3, #0
8f61743c:	82033001 	andhi	r3, r3, #1
8f617440:	e3530000 	cmp	r3, #0
8f617444:	1a000059 	bne	8f6175b0 <update_dtb_entry_node+0x210>
		if (current_info < best_info) {
8f617448:	e1550008 	cmp	r5, r8
8f61744c:	2a000020 	bcs	8f6174d4 <update_dtb_entry_node+0x134>
			dprintf(SPEW, "Delete don't fit DTB entry %u/%08x/0x%08x/%x/%x/%x/%x/%x/%x/%x\n",
8f617450:	e594c008 	ldr	r12, [r4, #8]
8f617454:	e1a0000b 	mov	r0, r11
8f617458:	e59ce024 	ldr	r14, [r12, #36]	; 0x24
8f61745c:	e1cc20d4 	ldrd	r2, [r12, #4]
8f617460:	e59c1000 	ldr	r1, [r12]
8f617464:	e58de018 	str	r14, [r13, #24]
8f617468:	e59ce020 	ldr	r14, [r12, #32]
8f61746c:	e58de014 	str	r14, [r13, #20]
8f617470:	e59ce01c 	ldr	r14, [r12, #28]
8f617474:	e58de010 	str	r14, [r13, #16]
8f617478:	e59ce018 	ldr	r14, [r12, #24]
8f61747c:	e58de00c 	str	r14, [r13, #12]
8f617480:	e59ce014 	ldr	r14, [r12, #20]
8f617484:	e58de008 	str	r14, [r13, #8]
8f617488:	e59ce010 	ldr	r14, [r12, #16]
8f61748c:	e58de004 	str	r14, [r13, #4]
8f617490:	e59cc00c 	ldr	r12, [r12, #12]
8f617494:	e58dc000 	str	r12, [r13]
8f617498:	eb006d35 	bl	8f632974 <_dprintf>
				dt_node_tmp1->dt_entry_m->board_hw_subtype, dt_node_tmp1->dt_entry_m->soc_rev,
				dt_node_tmp1->dt_entry_m->pmic_rev[0], dt_node_tmp1->dt_entry_m->pmic_rev[1],
				dt_node_tmp1->dt_entry_m->pmic_rev[2], dt_node_tmp1->dt_entry_m->pmic_rev[3],
				dt_node_tmp1->dt_entry_m->offset, dt_node_tmp1->dt_entry_m->size);

			dt_node_tmp2 = (struct dt_entry_node *) dt_node_tmp1->node.prev;
8f61749c:	e5945000 	ldr	r5, [r4]
	if (item->prev == 0 && item->next == 0)
8f6174a0:	e5943004 	ldr	r3, [r4, #4]
8f6174a4:	e3550000 	cmp	r5, #0
8f6174a8:	0a000076 	beq	8f617688 <update_dtb_entry_node+0x2e8>
	item->next->prev = item->prev;
8f6174ac:	e5835000 	str	r5, [r3]
			free(dt_node_member->dt_entry_m);
8f6174b0:	e5940008 	ldr	r0, [r4, #8]
	item->prev->next = item->next;
8f6174b4:	e5853004 	str	r3, [r5, #4]
	item->prev = item->next = 0;
8f6174b8:	e3a03000 	mov	r3, #0
8f6174bc:	e5843004 	str	r3, [r4, #4]
8f6174c0:	e5843000 	str	r3, [r4]
8f6174c4:	eb007310 	bl	8f63410c <free>
			free(dt_node_member);
8f6174c8:	e1a00004 	mov	r0, r4
8f6174cc:	eb00730e 	bl	8f63410c <free>
8f6174d0:	e1a04005 	mov	r4, r5
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f6174d4:	e5944004 	ldr	r4, [r4, #4]
8f6174d8:	e1570004 	cmp	r7, r4
8f6174dc:	0a00007c 	beq	8f6176d4 <update_dtb_entry_node+0x334>
		if (!dt_node_tmp1){
8f6174e0:	e3540000 	cmp	r4, #0
8f6174e4:	1affffc0 	bne	8f6173ec <update_dtb_entry_node+0x4c>
			dprintf(SPEW, "Current node is the end\n");
8f6174e8:	e30507d4 	movw	r0, #22484	; 0x57d4
8f6174ec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6174f0:	eb006d1f 	bl	8f632974 <_dprintf>
			dt_entry_list_delete(dt_node_tmp1);
			dt_node_tmp1 = dt_node_tmp2;
		}
	}

	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f6174f4:	e5974004 	ldr	r4, [r7, #4]
8f6174f8:	e1570004 	cmp	r7, r4
8f6174fc:	0a000058 	beq	8f617664 <update_dtb_entry_node+0x2c4>
		if (!dt_node_tmp1){
8f617500:	e3540000 	cmp	r4, #0
8f617504:	0a000053 	beq	8f617658 <update_dtb_entry_node+0x2b8>
			break;
		case DTB_PMIC2:
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[2]) & 0x00ffff00);
			break;
		case DTB_PMIC3:
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[3]) & 0x00ffff00);
8f617508:	e3a05cff 	mov	r5, #65280	; 0xff00
					dtb_info);
			return 0;
		}

		if (current_info != best_info) {
			dprintf(SPEW, "Delete don't fit DTB entry %u/%08x/0x%08x/%x/%x/%x/%x/%x/%x/%x\n",
8f61750c:	e30597f0 	movw	r9, #22512	; 0x57f0
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[3]) & 0x00ffff00);
8f617510:	e34050ff 	movt	r5, #255	; 0xff
			dprintf(SPEW, "Delete don't fit DTB entry %u/%08x/0x%08x/%x/%x/%x/%x/%x/%x/%x\n",
8f617514:	e3489f70 	movt	r9, #36720	; 0x8f70
8f617518:	e24a6002 	sub	r6, r10, #2
8f61751c:	e3a0a000 	mov	r10, #0
			current_info = dt_node_tmp1->dt_entry_m->soc_rev;
8f617520:	e5940008 	ldr	r0, [r4, #8]
		switch(dtb_info) {
8f617524:	e3560004 	cmp	r6, #4
8f617528:	979ff106 	ldrls	r15, [r15, r6, lsl #2]
8f61752c:	ea00006d 	b	8f6176e8 <update_dtb_entry_node+0x348>
8f617530:	8f6176bc 	.word	0x8f6176bc
8f617534:	8f6176a4 	.word	0x8f6176a4
8f617538:	8f617698 	.word	0x8f617698
8f61753c:	8f6176b0 	.word	0x8f6176b0
8f617540:	8f6175b8 	.word	0x8f6175b8
			board_info = (board_pmic_target(2) & 0x00ffff00);
8f617544:	e3a00002 	mov	r0, #2
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[2]) & 0x00ffff00);
8f617548:	e5935018 	ldr	r5, [r3, #24]
			board_info = (board_pmic_target(2) & 0x00ffff00);
8f61754c:	ebffe37d 	bl	8f610348 <board_pmic_target>
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[2]) & 0x00ffff00);
8f617550:	e0055009 	and	r5, r5, r9
			board_info = (board_pmic_target(2) & 0x00ffff00);
8f617554:	e0000009 	and	r0, r0, r9
		if (current_info == board_info) {
8f617558:	e1550000 	cmp	r5, r0
8f61755c:	1affffb2 	bne	8f61742c <update_dtb_entry_node+0x8c>
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f617560:	e5974004 	ldr	r4, [r7, #4]
8f617564:	e1a08005 	mov	r8, r5
8f617568:	eaffffe2 	b	8f6174f8 <update_dtb_entry_node+0x158>
			board_info = (board_pmic_target(1) & 0x00ffff00);
8f61756c:	e3a00001 	mov	r0, #1
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[1]) & 0x00ffff00);
8f617570:	e5935014 	ldr	r5, [r3, #20]
			board_info = (board_pmic_target(1) & 0x00ffff00);
8f617574:	ebffe373 	bl	8f610348 <board_pmic_target>
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[1]) & 0x00ffff00);
8f617578:	e0055009 	and	r5, r5, r9
			board_info = (board_pmic_target(1) & 0x00ffff00);
8f61757c:	e0000009 	and	r0, r0, r9
			break;
8f617580:	eaffffa7 	b	8f617424 <update_dtb_entry_node+0x84>
			board_info = (board_pmic_target(0) & 0x00ffff00);
8f617584:	e3a00000 	mov	r0, #0
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[0]) & 0x00ffff00);
8f617588:	e5935010 	ldr	r5, [r3, #16]
			board_info = (board_pmic_target(0) & 0x00ffff00);
8f61758c:	ebffe36d 	bl	8f610348 <board_pmic_target>
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[0]) & 0x00ffff00);
8f617590:	e0055009 	and	r5, r5, r9
			board_info = (board_pmic_target(0) & 0x00ffff00);
8f617594:	e0000009 	and	r0, r0, r9
			break;
8f617598:	eaffffa1 	b	8f617424 <update_dtb_entry_node+0x84>
			current_info = ((dt_node_tmp1->dt_entry_m->variant_id) & 0x00ffff00);
8f61759c:	e5935004 	ldr	r5, [r3, #4]
			board_info = (board_target_id() & 0x00ffff00);
8f6175a0:	ebffe31c 	bl	8f610218 <board_target_id>
			current_info = ((dt_node_tmp1->dt_entry_m->variant_id) & 0x00ffff00);
8f6175a4:	e0055009 	and	r5, r5, r9
			board_info = (board_target_id() & 0x00ffff00);
8f6175a8:	e0000009 	and	r0, r0, r9
			break;
8f6175ac:	eaffff9c 	b	8f617424 <update_dtb_entry_node+0x84>
8f6175b0:	e1a08005 	mov	r8, r5
8f6175b4:	eaffffc6 	b	8f6174d4 <update_dtb_entry_node+0x134>
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[3]) & 0x00ffff00);
8f6175b8:	e590301c 	ldr	r3, [r0, #28]
8f6175bc:	e0033005 	and	r3, r3, r5
		if (current_info != best_info) {
8f6175c0:	e1530008 	cmp	r3, r8
8f6175c4:	0a00001e 	beq	8f617644 <update_dtb_entry_node+0x2a4>
			dprintf(SPEW, "Delete don't fit DTB entry %u/%08x/0x%08x/%x/%x/%x/%x/%x/%x/%x\n",
8f6175c8:	e590c024 	ldr	r12, [r0, #36]	; 0x24
8f6175cc:	e1c020d4 	ldrd	r2, [r0, #4]
8f6175d0:	e5901000 	ldr	r1, [r0]
8f6175d4:	e58dc018 	str	r12, [r13, #24]
8f6175d8:	e590c020 	ldr	r12, [r0, #32]
8f6175dc:	e58dc014 	str	r12, [r13, #20]
8f6175e0:	e590c01c 	ldr	r12, [r0, #28]
8f6175e4:	e58dc010 	str	r12, [r13, #16]
8f6175e8:	e590c018 	ldr	r12, [r0, #24]
8f6175ec:	e58dc00c 	str	r12, [r13, #12]
8f6175f0:	e590c014 	ldr	r12, [r0, #20]
8f6175f4:	e58dc008 	str	r12, [r13, #8]
8f6175f8:	e590c010 	ldr	r12, [r0, #16]
8f6175fc:	e58dc004 	str	r12, [r13, #4]
8f617600:	e590000c 	ldr	r0, [r0, #12]
8f617604:	e58d0000 	str	r0, [r13]
8f617608:	e1a00009 	mov	r0, r9
8f61760c:	eb006cd8 	bl	8f632974 <_dprintf>
				dt_node_tmp1->dt_entry_m->board_hw_subtype, dt_node_tmp1->dt_entry_m->soc_rev,
				dt_node_tmp1->dt_entry_m->pmic_rev[0], dt_node_tmp1->dt_entry_m->pmic_rev[1],
				dt_node_tmp1->dt_entry_m->pmic_rev[2], dt_node_tmp1->dt_entry_m->pmic_rev[3],
				dt_node_tmp1->dt_entry_m->offset, dt_node_tmp1->dt_entry_m->size);

			dt_node_tmp2 = (struct dt_entry_node *) dt_node_tmp1->node.prev;
8f617610:	e594b000 	ldr	r11, [r4]
	if (item->prev == 0 && item->next == 0)
8f617614:	e5943004 	ldr	r3, [r4, #4]
8f617618:	e35b0000 	cmp	r11, #0
8f61761c:	0a000029 	beq	8f6176c8 <update_dtb_entry_node+0x328>
	item->next->prev = item->prev;
8f617620:	e583b000 	str	r11, [r3]
			free(dt_node_member->dt_entry_m);
8f617624:	e5940008 	ldr	r0, [r4, #8]
	item->prev->next = item->next;
8f617628:	e58b3004 	str	r3, [r11, #4]
	item->prev = item->next = 0;
8f61762c:	e584a004 	str	r10, [r4, #4]
8f617630:	e584a000 	str	r10, [r4]
8f617634:	eb0072b4 	bl	8f63410c <free>
			free(dt_node_member);
8f617638:	e1a00004 	mov	r0, r4
8f61763c:	eb0072b2 	bl	8f63410c <free>
8f617640:	e1a0400b 	mov	r4, r11
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f617644:	e5944004 	ldr	r4, [r4, #4]
8f617648:	e1570004 	cmp	r7, r4
8f61764c:	0a000004 	beq	8f617664 <update_dtb_entry_node+0x2c4>
		if (!dt_node_tmp1){
8f617650:	e3540000 	cmp	r4, #0
8f617654:	1affffb1 	bne	8f617520 <update_dtb_entry_node+0x180>
			dprintf(SPEW, "Current node is the end\n");
8f617658:	e30507d4 	movw	r0, #22484	; 0x57d4
8f61765c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f617660:	eb006cc3 	bl	8f632974 <_dprintf>
			dt_entry_list_delete(dt_node_tmp1);
			dt_node_tmp1 = dt_node_tmp2;
		}
	}
	return 1;
}
8f617664:	e59f3090 	ldr	r3, [pc, #144]	; 8f6176fc <update_dtb_entry_node+0x35c>
8f617668:	e5932000 	ldr	r2, [r3]
8f61766c:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f617670:	e0332002 	eors	r2, r3, r2
8f617674:	e3a03000 	mov	r3, #0
8f617678:	1a000019 	bne	8f6176e4 <update_dtb_entry_node+0x344>
8f61767c:	e3a00001 	mov	r0, #1
8f617680:	e28dd02c 	add	r13, r13, #44	; 0x2c
8f617684:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	if (item->prev == 0 && item->next == 0)
8f617688:	e3530000 	cmp	r3, #0
8f61768c:	1affff86 	bne	8f6174ac <update_dtb_entry_node+0x10c>
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f617690:	e5933004 	ldr	r3, [r3, #4]
8f617694:	e7f000f0 	udf	#0
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[1]) & 0x00ffff00);
8f617698:	e5903014 	ldr	r3, [r0, #20]
8f61769c:	e0033005 	and	r3, r3, r5
			break;
8f6176a0:	eaffffc6 	b	8f6175c0 <update_dtb_entry_node+0x220>
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[0]) & 0x00ffff00);
8f6176a4:	e5903010 	ldr	r3, [r0, #16]
8f6176a8:	e0033005 	and	r3, r3, r5
			break;
8f6176ac:	eaffffc3 	b	8f6175c0 <update_dtb_entry_node+0x220>
			current_info = ((dt_node_tmp1->dt_entry_m->pmic_rev[2]) & 0x00ffff00);
8f6176b0:	e5903018 	ldr	r3, [r0, #24]
8f6176b4:	e0033005 	and	r3, r3, r5
			break;
8f6176b8:	eaffffc0 	b	8f6175c0 <update_dtb_entry_node+0x220>
			current_info = ((dt_node_tmp1->dt_entry_m->variant_id) & 0x00ffff00);
8f6176bc:	e5903004 	ldr	r3, [r0, #4]
8f6176c0:	e0033005 	and	r3, r3, r5
			break;
8f6176c4:	eaffffbd 	b	8f6175c0 <update_dtb_entry_node+0x220>
8f6176c8:	e3530000 	cmp	r3, #0
8f6176cc:	1affffd3 	bne	8f617620 <update_dtb_entry_node+0x280>
8f6176d0:	eaffffee 	b	8f617690 <update_dtb_entry_node+0x2f0>
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f6176d4:	e5974004 	ldr	r4, [r7, #4]
8f6176d8:	eaffff86 	b	8f6174f8 <update_dtb_entry_node+0x158>
	uint32_t best_info = 0;
8f6176dc:	e1a08004 	mov	r8, r4
8f6176e0:	eaffff80 	b	8f6174e8 <update_dtb_entry_node+0x148>
}
8f6176e4:	eb006d35 	bl	8f632bc0 <__stack_chk_fail>
			current_info = dt_node_tmp1->dt_entry_m->soc_rev;
8f6176e8:	e590300c 	ldr	r3, [r0, #12]
			break;
8f6176ec:	eaffffb3 	b	8f6175c0 <update_dtb_entry_node+0x220>
			current_info = dt_node_tmp1->dt_entry_m->soc_rev;
8f6176f0:	e593500c 	ldr	r5, [r3, #12]
			board_info = board_soc_version();
8f6176f4:	ebffe346 	bl	8f610414 <board_soc_version>
			break;
8f6176f8:	eaffff49 	b	8f617424 <update_dtb_entry_node+0x84>
8f6176fc:	8f74221c 	.word	0x8f74221c

8f617700 <platform_dt_absolute_compat_match>:
static int platform_dt_absolute_compat_match(struct dt_entry_node *dt_list, uint32_t dtb_info) {
8f617700:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f617704:	e24dd05c 	sub	r13, r13, #92	; 0x5c
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f617708:	e5907004 	ldr	r7, [r0, #4]
	uint32_t current_pmic_model[4] = {0, 0, 0, 0};
8f61770c:	e3a03000 	mov	r3, #0
static int platform_dt_absolute_compat_match(struct dt_entry_node *dt_list, uint32_t dtb_info) {
8f617710:	e59f239c 	ldr	r2, [pc, #924]	; 8f617ab4 <platform_dt_absolute_compat_match+0x3b4>
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f617714:	e1500007 	cmp	r0, r7
static int platform_dt_absolute_compat_match(struct dt_entry_node *dt_list, uint32_t dtb_info) {
8f617718:	e5922000 	ldr	r2, [r2]
8f61771c:	e58d2054 	str	r2, [r13, #84]	; 0x54
8f617720:	e3a02000 	mov	r2, #0
	uint32_t current_pmic_model[4] = {0, 0, 0, 0};
8f617724:	e58d3034 	str	r3, [r13, #52]	; 0x34
8f617728:	e58d3038 	str	r3, [r13, #56]	; 0x38
8f61772c:	e58d303c 	str	r3, [r13, #60]	; 0x3c
8f617730:	e58d3040 	str	r3, [r13, #64]	; 0x40
	uint32_t board_pmic_model[4] = {0, 0, 0, 0};
8f617734:	e58d3044 	str	r3, [r13, #68]	; 0x44
8f617738:	e58d3048 	str	r3, [r13, #72]	; 0x48
8f61773c:	e58d304c 	str	r3, [r13, #76]	; 0x4c
8f617740:	e58d3050 	str	r3, [r13, #80]	; 0x50
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f617744:	0a0000a1 	beq	8f6179d0 <platform_dt_absolute_compat_match+0x2d0>
		if (!dt_node_tmp1){
8f617748:	e1570003 	cmp	r7, r3
8f61774c:	e1a06000 	mov	r6, r0
8f617750:	e1a04001 	mov	r4, r1
8f617754:	0a000025 	beq	8f6177f0 <platform_dt_absolute_compat_match+0xf0>
		switch(dtb_info) {
8f617758:	e3540009 	cmp	r4, #9
8f61775c:	979ff104 	ldrls	r15, [r15, r4, lsl #2]
8f617760:	ea000009 	b	8f61778c <platform_dt_absolute_compat_match+0x8c>
8f617764:	8f61790c 	.word	0x8f61790c
8f617768:	8f61778c 	.word	0x8f61778c
8f61776c:	8f61778c 	.word	0x8f61778c
8f617770:	8f61778c 	.word	0x8f61778c
8f617774:	8f61778c 	.word	0x8f61778c
8f617778:	8f61778c 	.word	0x8f61778c
8f61777c:	8f61778c 	.word	0x8f61778c
8f617780:	8f617880 	.word	0x8f617880
8f617784:	8f617868 	.word	0x8f617868
8f617788:	8f6177c0 	.word	0x8f6177c0
			dprintf(CRITICAL, "ERROR: Unsupported version (%d) in dt node check \n",
8f61778c:	e1a01004 	mov	r1, r4
8f617790:	e3050830 	movw	r0, #22576	; 0x5830
8f617794:	e3480f70 	movt	r0, #36720	; 0x8f70
8f617798:	eb006c75 	bl	8f632974 <_dprintf>
			return 0;
8f61779c:	e3a00000 	mov	r0, #0
}
8f6177a0:	e59f330c 	ldr	r3, [pc, #780]	; 8f617ab4 <platform_dt_absolute_compat_match+0x3b4>
8f6177a4:	e5932000 	ldr	r2, [r3]
8f6177a8:	e59d3054 	ldr	r3, [r13, #84]	; 0x54
8f6177ac:	e0332002 	eors	r2, r3, r2
8f6177b0:	e3a03000 	mov	r3, #0
8f6177b4:	1a0000bd 	bne	8f617ab0 <platform_dt_absolute_compat_match+0x3b0>
8f6177b8:	e28dd05c 	add	r13, r13, #92	; 0x5c
8f6177bc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
			current_info = ((dt_node_tmp1->dt_entry_m->board_hw_subtype) & 0xf0000);
8f6177c0:	e5973008 	ldr	r3, [r7, #8]
8f6177c4:	e5935008 	ldr	r5, [r3, #8]
			board_info = (target_get_hlos_subtype() & 0xf0000);
8f6177c8:	eb00290f 	bl	8f621c0c <target_get_hlos_subtype>
			current_info = ((dt_node_tmp1->dt_entry_m->board_hw_subtype) & 0xf0000);
8f6177cc:	e205580f 	and	r5, r5, #983040	; 0xf0000
			board_info = (target_get_hlos_subtype() & 0xf0000);
8f6177d0:	e200080f 	and	r0, r0, #983040	; 0xf0000
			if (current_info == board_info) {
8f6177d4:	e1550000 	cmp	r5, r0
8f6177d8:	0a0000ad 	beq	8f617a94 <platform_dt_absolute_compat_match+0x394>
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f6177dc:	e5977004 	ldr	r7, [r7, #4]
8f6177e0:	e1560007 	cmp	r6, r7
8f6177e4:	0a0000a3 	beq	8f617a78 <platform_dt_absolute_compat_match+0x378>
		if (!dt_node_tmp1){
8f6177e8:	e3570000 	cmp	r7, #0
8f6177ec:	1affffd9 	bne	8f617758 <platform_dt_absolute_compat_match+0x58>
			dprintf(SPEW, "Current node is the end\n");
8f6177f0:	e30507d4 	movw	r0, #22484	; 0x57d4
8f6177f4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6177f8:	eb006c5d 	bl	8f632974 <_dprintf>
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f6177fc:	e5967004 	ldr	r7, [r6, #4]
	uint32_t best_pmic_model[4] = {0, 0, 0, 0};
8f617800:	e3a0b000 	mov	r11, #0
8f617804:	e58db028 	str	r11, [r13, #40]	; 0x28
8f617808:	e1a0800b 	mov	r8, r11
	uint32_t best_info = 0;
8f61780c:	e1a0500b 	mov	r5, r11
	uint32_t best_pmic_model[4] = {0, 0, 0, 0};
8f617810:	e58db024 	str	r11, [r13, #36]	; 0x24
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f617814:	e1560007 	cmp	r6, r7
8f617818:	0a00006c 	beq	8f6179d0 <platform_dt_absolute_compat_match+0x2d0>
		if (!dt_node_tmp1){
8f61781c:	e3570000 	cmp	r7, #0
8f617820:	0a000067 	beq	8f6179c4 <platform_dt_absolute_compat_match+0x2c4>
			dprintf(SPEW, "Delete don't fit DTB entry %u/%08x/0x%08x/%x/%x/%x/%x/%x/%x/%x\n",
8f617824:	e30597f0 	movw	r9, #22512	; 0x57f0
8f617828:	e3489f70 	movt	r9, #36720	; 0x8f70
	item->prev = item->next = 0;
8f61782c:	e3a0a000 	mov	r10, #0
8f617830:	e58db02c 	str	r11, [r13, #44]	; 0x2c
		switch(dtb_info) {
8f617834:	e3540009 	cmp	r4, #9
8f617838:	979ff104 	ldrls	r15, [r15, r4, lsl #2]
8f61783c:	eaffffd2 	b	8f61778c <platform_dt_absolute_compat_match+0x8c>
8f617840:	8f617a58 	.word	0x8f617a58
8f617844:	8f61778c 	.word	0x8f61778c
8f617848:	8f61778c 	.word	0x8f61778c
8f61784c:	8f61778c 	.word	0x8f61778c
8f617850:	8f61778c 	.word	0x8f61778c
8f617854:	8f61778c 	.word	0x8f61778c
8f617858:	8f61778c 	.word	0x8f61778c
8f61785c:	8f6179f4 	.word	0x8f6179f4
8f617860:	8f6179d8 	.word	0x8f6179d8
8f617864:	8f617924 	.word	0x8f617924
			current_info = ((dt_node_tmp1->dt_entry_m->board_hw_subtype) & 0x1800);
8f617868:	e5973008 	ldr	r3, [r7, #8]
8f61786c:	e5935008 	ldr	r5, [r3, #8]
			board_info = (target_get_hlos_subtype() & 0x1800);
8f617870:	eb0028e5 	bl	8f621c0c <target_get_hlos_subtype>
			current_info = ((dt_node_tmp1->dt_entry_m->board_hw_subtype) & 0x1800);
8f617874:	e2055b06 	and	r5, r5, #6144	; 0x1800
			board_info = (target_get_hlos_subtype() & 0x1800);
8f617878:	e2000b06 	and	r0, r0, #6144	; 0x1800
			break;
8f61787c:	eaffffd4 	b	8f6177d4 <platform_dt_absolute_compat_match+0xd4>
8f617880:	e28d9034 	add	r9, r13, #52	; 0x34
8f617884:	e28d8044 	add	r8, r13, #68	; 0x44
			for (i = 0; i < 4; i++) {
8f617888:	e3a05000 	mov	r5, #0
				current_pmic_model[i] = (dt_node_tmp1->dt_entry_m->pmic_rev[i] & 0xff);
8f61788c:	e5973008 	ldr	r3, [r7, #8]
8f617890:	e2852004 	add	r2, r5, #4
				board_pmic_model[i] = (board_pmic_target(i) & 0xff);
8f617894:	e6ef0075 	uxtb	r0, r5
			for (i = 0; i < 4; i++) {
8f617898:	e2855001 	add	r5, r5, #1
				current_pmic_model[i] = (dt_node_tmp1->dt_entry_m->pmic_rev[i] & 0xff);
8f61789c:	e7d33102 	ldrb	r3, [r3, r2, lsl #2]
8f6178a0:	e4893004 	str	r3, [r9], #4
				board_pmic_model[i] = (board_pmic_target(i) & 0xff);
8f6178a4:	ebffe2a7 	bl	8f610348 <board_pmic_target>
			for (i = 0; i < 4; i++) {
8f6178a8:	e3550004 	cmp	r5, #4
				board_pmic_model[i] = (board_pmic_target(i) & 0xff);
8f6178ac:	e6ef0070 	uxtb	r0, r0
8f6178b0:	e4880004 	str	r0, [r8], #4
			for (i = 0; i < 4; i++) {
8f6178b4:	1afffff4 	bne	8f61788c <platform_dt_absolute_compat_match+0x18c>
			if ((current_pmic_model[0] == board_pmic_model[0]) &&
8f6178b8:	e59d8034 	ldr	r8, [r13, #52]	; 0x34
8f6178bc:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f6178c0:	e1580003 	cmp	r8, r3
8f6178c4:	1affffc4 	bne	8f6177dc <platform_dt_absolute_compat_match+0xdc>
				(current_pmic_model[1] == board_pmic_model[1]) &&
8f6178c8:	e59d3038 	ldr	r3, [r13, #56]	; 0x38
			if ((current_pmic_model[0] == board_pmic_model[0]) &&
8f6178cc:	e59d2048 	ldr	r2, [r13, #72]	; 0x48
8f6178d0:	e1530002 	cmp	r3, r2
8f6178d4:	1affffc0 	bne	8f6177dc <platform_dt_absolute_compat_match+0xdc>
				(current_pmic_model[2] == board_pmic_model[2]) &&
8f6178d8:	e59d203c 	ldr	r2, [r13, #60]	; 0x3c
				(current_pmic_model[1] == board_pmic_model[1]) &&
8f6178dc:	e59d104c 	ldr	r1, [r13, #76]	; 0x4c
8f6178e0:	e1520001 	cmp	r2, r1
8f6178e4:	1affffbc 	bne	8f6177dc <platform_dt_absolute_compat_match+0xdc>
				(current_pmic_model[3] == board_pmic_model[3])) {
8f6178e8:	e59db040 	ldr	r11, [r13, #64]	; 0x40
				(current_pmic_model[2] == board_pmic_model[2]) &&
8f6178ec:	e59d1050 	ldr	r1, [r13, #80]	; 0x50
8f6178f0:	e15b0001 	cmp	r11, r1
8f6178f4:	1affffb8 	bne	8f6177dc <platform_dt_absolute_compat_match+0xdc>
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f6178f8:	e5967004 	ldr	r7, [r6, #4]
	uint32_t best_info = 0;
8f6178fc:	e3a05000 	mov	r5, #0
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f617900:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f617904:	e58d2028 	str	r2, [r13, #40]	; 0x28
8f617908:	eaffffc1 	b	8f617814 <platform_dt_absolute_compat_match+0x114>
			current_info = ((dt_node_tmp1->dt_entry_m->platform_id) & 0x00ff0000);
8f61790c:	e5973008 	ldr	r3, [r7, #8]
8f617910:	e5935000 	ldr	r5, [r3]
			board_info = board_foundry_id() << 16;
8f617914:	ebffe278 	bl	8f6102fc <board_foundry_id>
			current_info = ((dt_node_tmp1->dt_entry_m->platform_id) & 0x00ff0000);
8f617918:	e20558ff 	and	r5, r5, #16711680	; 0xff0000
			board_info = board_foundry_id() << 16;
8f61791c:	e1a00800 	lsl	r0, r0, #16
			break;
8f617920:	eaffffab 	b	8f6177d4 <platform_dt_absolute_compat_match+0xd4>
			current_info = ((dt_node_tmp1->dt_entry_m->board_hw_subtype) & 0xf0000);
8f617924:	e5970008 	ldr	r0, [r7, #8]
8f617928:	e5903008 	ldr	r3, [r0, #8]
8f61792c:	e203380f 	and	r3, r3, #983040	; 0xf0000
			if (current_info != best_info) {
8f617930:	e1550003 	cmp	r5, r3
8f617934:	0a00002c 	beq	8f6179ec <platform_dt_absolute_compat_match+0x2ec>
			dprintf(SPEW, "Delete don't fit DTB entry %u/%08x/0x%08x/%x/%x/%x/%x/%x/%x/%x\n",
8f617938:	e590c024 	ldr	r12, [r0, #36]	; 0x24
8f61793c:	e1c020d4 	ldrd	r2, [r0, #4]
8f617940:	e5901000 	ldr	r1, [r0]
8f617944:	e58dc018 	str	r12, [r13, #24]
8f617948:	e590c020 	ldr	r12, [r0, #32]
8f61794c:	e58dc014 	str	r12, [r13, #20]
8f617950:	e590c01c 	ldr	r12, [r0, #28]
8f617954:	e58dc010 	str	r12, [r13, #16]
8f617958:	e590c018 	ldr	r12, [r0, #24]
8f61795c:	e58dc00c 	str	r12, [r13, #12]
8f617960:	e590c014 	ldr	r12, [r0, #20]
8f617964:	e58dc008 	str	r12, [r13, #8]
8f617968:	e590c010 	ldr	r12, [r0, #16]
8f61796c:	e58dc004 	str	r12, [r13, #4]
8f617970:	e590000c 	ldr	r0, [r0, #12]
8f617974:	e58d0000 	str	r0, [r13]
8f617978:	e1a00009 	mov	r0, r9
8f61797c:	eb006bfc 	bl	8f632974 <_dprintf>
			dt_node_tmp2 = (struct dt_entry_node *) dt_node_tmp1->node.prev;
8f617980:	e597b000 	ldr	r11, [r7]
	if (item->prev == 0 && item->next == 0)
8f617984:	e5972004 	ldr	r2, [r7, #4]
8f617988:	e35b0000 	cmp	r11, #0
8f61798c:	0a000035 	beq	8f617a68 <platform_dt_absolute_compat_match+0x368>
	item->next->prev = item->prev;
8f617990:	e582b000 	str	r11, [r2]
			free(dt_node_member->dt_entry_m);
8f617994:	e5970008 	ldr	r0, [r7, #8]
	item->prev->next = item->next;
8f617998:	e58b2004 	str	r2, [r11, #4]
	item->prev = item->next = 0;
8f61799c:	e587a004 	str	r10, [r7, #4]
8f6179a0:	e587a000 	str	r10, [r7]
8f6179a4:	eb0071d8 	bl	8f63410c <free>
			free(dt_node_member);
8f6179a8:	e1a00007 	mov	r0, r7
8f6179ac:	eb0071d6 	bl	8f63410c <free>
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f6179b0:	e59b7004 	ldr	r7, [r11, #4]
8f6179b4:	e1560007 	cmp	r6, r7
8f6179b8:	0a000004 	beq	8f6179d0 <platform_dt_absolute_compat_match+0x2d0>
		if (!dt_node_tmp1){
8f6179bc:	e3570000 	cmp	r7, #0
8f6179c0:	1affff9b 	bne	8f617834 <platform_dt_absolute_compat_match+0x134>
			dprintf(SPEW, "Current node is the end\n");
8f6179c4:	e30507d4 	movw	r0, #22484	; 0x57d4
8f6179c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6179cc:	eb006be8 	bl	8f632974 <_dprintf>
	return 1;
8f6179d0:	e3a00001 	mov	r0, #1
			break;
8f6179d4:	eaffff71 	b	8f6177a0 <platform_dt_absolute_compat_match+0xa0>
			current_info = ((dt_node_tmp1->dt_entry_m->board_hw_subtype) & 0x1800);
8f6179d8:	e5970008 	ldr	r0, [r7, #8]
8f6179dc:	e5903008 	ldr	r3, [r0, #8]
8f6179e0:	e2033b06 	and	r3, r3, #6144	; 0x1800
			if (current_info != best_info) {
8f6179e4:	e1550003 	cmp	r5, r3
8f6179e8:	1affffd2 	bne	8f617938 <platform_dt_absolute_compat_match+0x238>
8f6179ec:	e1a0b007 	mov	r11, r7
8f6179f0:	eaffffee 	b	8f6179b0 <platform_dt_absolute_compat_match+0x2b0>
				current_pmic_model[i] = (dt_node_tmp1->dt_entry_m->pmic_rev[i] & 0xff);
8f6179f4:	e5970008 	ldr	r0, [r7, #8]
8f6179f8:	e28d1034 	add	r1, r13, #52	; 0x34
8f6179fc:	e2802010 	add	r2, r0, #16
8f617a00:	e280c020 	add	r12, r0, #32
8f617a04:	e4923004 	ldr	r3, [r2], #4
			for (i = 0; i < 4; i++) {
8f617a08:	e15c0002 	cmp	r12, r2
				current_pmic_model[i] = (dt_node_tmp1->dt_entry_m->pmic_rev[i] & 0xff);
8f617a0c:	e6ef3073 	uxtb	r3, r3
8f617a10:	e4813004 	str	r3, [r1], #4
			for (i = 0; i < 4; i++) {
8f617a14:	1afffffa 	bne	8f617a04 <platform_dt_absolute_compat_match+0x304>
			if ((current_pmic_model[0] != best_pmic_model[0]) ||
8f617a18:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f617a1c:	e1530008 	cmp	r3, r8
8f617a20:	1affffc4 	bne	8f617938 <platform_dt_absolute_compat_match+0x238>
8f617a24:	e59d3038 	ldr	r3, [r13, #56]	; 0x38
8f617a28:	e59d2024 	ldr	r2, [r13, #36]	; 0x24
8f617a2c:	e1530002 	cmp	r3, r2
8f617a30:	1affffc0 	bne	8f617938 <platform_dt_absolute_compat_match+0x238>
				(current_pmic_model[1] != best_pmic_model[1]) ||
8f617a34:	e59d303c 	ldr	r3, [r13, #60]	; 0x3c
8f617a38:	e59d2028 	ldr	r2, [r13, #40]	; 0x28
8f617a3c:	e1530002 	cmp	r3, r2
8f617a40:	1affffbc 	bne	8f617938 <platform_dt_absolute_compat_match+0x238>
				(current_pmic_model[2] != best_pmic_model[2]) ||
8f617a44:	e59d3040 	ldr	r3, [r13, #64]	; 0x40
8f617a48:	e59d202c 	ldr	r2, [r13, #44]	; 0x2c
8f617a4c:	e1530002 	cmp	r3, r2
8f617a50:	1affffb8 	bne	8f617938 <platform_dt_absolute_compat_match+0x238>
8f617a54:	eaffffe4 	b	8f6179ec <platform_dt_absolute_compat_match+0x2ec>
			current_info = ((dt_node_tmp1->dt_entry_m->platform_id) & 0x00ff0000);
8f617a58:	e5970008 	ldr	r0, [r7, #8]
8f617a5c:	e5903000 	ldr	r3, [r0]
8f617a60:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
			break;
8f617a64:	eaffffb1 	b	8f617930 <platform_dt_absolute_compat_match+0x230>
	if (item->prev == 0 && item->next == 0)
8f617a68:	e3520000 	cmp	r2, #0
8f617a6c:	1affffc7 	bne	8f617990 <platform_dt_absolute_compat_match+0x290>
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f617a70:	e5923004 	ldr	r3, [r2, #4]
8f617a74:	e7f000f0 	udf	#0
	uint32_t best_pmic_model[4] = {0, 0, 0, 0};
8f617a78:	e3a0b000 	mov	r11, #0
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f617a7c:	e5967004 	ldr	r7, [r6, #4]
	uint32_t best_pmic_model[4] = {0, 0, 0, 0};
8f617a80:	e1a0800b 	mov	r8, r11
	uint32_t best_info = 0;
8f617a84:	e1a0500b 	mov	r5, r11
	uint32_t best_pmic_model[4] = {0, 0, 0, 0};
8f617a88:	e58db028 	str	r11, [r13, #40]	; 0x28
8f617a8c:	e58db024 	str	r11, [r13, #36]	; 0x24
8f617a90:	eaffff5f 	b	8f617814 <platform_dt_absolute_compat_match+0x114>
8f617a94:	e3a0b000 	mov	r11, #0
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f617a98:	e5967004 	ldr	r7, [r6, #4]
8f617a9c:	e1a05000 	mov	r5, r0
	uint32_t best_pmic_model[4] = {0, 0, 0, 0};
8f617aa0:	e1a0800b 	mov	r8, r11
8f617aa4:	e58db028 	str	r11, [r13, #40]	; 0x28
8f617aa8:	e58db024 	str	r11, [r13, #36]	; 0x24
8f617aac:	eaffff58 	b	8f617814 <platform_dt_absolute_compat_match+0x114>
}
8f617ab0:	eb006c42 	bl	8f632bc0 <__stack_chk_fail>
8f617ab4:	8f74221c 	.word	0x8f74221c

8f617ab8 <platform_dt_match_best>:

static struct dt_entry *platform_dt_match_best(struct dt_entry_node *dt_list)
{
8f617ab8:	e59f313c 	ldr	r3, [pc, #316]	; 8f617bfc <platform_dt_match_best+0x144>

	/* check Foundry id
	* the foundry id must exact match board founddry id, this is compatibility check,
	* if couldn't find the exact match from DTB, will exact match 0x0.
	*/
	if (!platform_dt_absolute_compat_match(dt_list, DTB_FOUNDRY))
8f617abc:	e3a01000 	mov	r1, #0
{
8f617ac0:	e92d4010 	push	{r4, r14}
8f617ac4:	e24dd008 	sub	r13, r13, #8
8f617ac8:	e5933000 	ldr	r3, [r3]
8f617acc:	e58d3004 	str	r3, [r13, #4]
8f617ad0:	e3a03000 	mov	r3, #0
8f617ad4:	e1a04000 	mov	r4, r0
	if (!platform_dt_absolute_compat_match(dt_list, DTB_FOUNDRY))
8f617ad8:	ebffff08 	bl	8f617700 <platform_dt_absolute_compat_match>
8f617adc:	e3500000 	cmp	r0, #0
8f617ae0:	0a00003b 	beq	8f617bd4 <platform_dt_match_best+0x11c>

	/* check PMIC model
	* the PMIC model must exact match board PMIC model, this is compatibility check,
	* if couldn't find the exact match from DTB, will exact match 0x0.
	*/
	if (!platform_dt_absolute_compat_match(dt_list, DTB_PMIC_MODEL))
8f617ae4:	e3a01007 	mov	r1, #7
8f617ae8:	e1a00004 	mov	r0, r4
8f617aec:	ebffff03 	bl	8f617700 <platform_dt_absolute_compat_match>
8f617af0:	e3500000 	cmp	r0, #0
8f617af4:	0a000036 	beq	8f617bd4 <platform_dt_match_best+0x11c>

	/* check panel type
	* the panel  type must exact match board panel type, this is compatibility check,
	* if couldn't find the exact match from DTB, will exact match 0x0.
	*/
	if (!platform_dt_absolute_compat_match(dt_list, DTB_PANEL_TYPE))
8f617af8:	e3a01008 	mov	r1, #8
8f617afc:	e1a00004 	mov	r0, r4
8f617b00:	ebfffefe 	bl	8f617700 <platform_dt_absolute_compat_match>
8f617b04:	e3500000 	cmp	r0, #0
8f617b08:	0a000031 	beq	8f617bd4 <platform_dt_match_best+0x11c>

	/* check boot device subtype
	* the boot device subtype must exact match board boot device subtype, this is compatibility check,
	* if couldn't find the exact match from DTB, will exact match 0x0.
	*/
	if (!platform_dt_absolute_compat_match(dt_list, DTB_BOOT_DEVICE))
8f617b0c:	e3a01009 	mov	r1, #9
8f617b10:	e1a00004 	mov	r0, r4
8f617b14:	ebfffef9 	bl	8f617700 <platform_dt_absolute_compat_match>
8f617b18:	e3500000 	cmp	r0, #0
8f617b1c:	0a00002c 	beq	8f617bd4 <platform_dt_match_best+0x11c>
		return NULL;

	/* check soc version
	* the suitable soc version must less than or equal to board soc version
	*/
	if (!update_dtb_entry_node(dt_list, DTB_SOC))
8f617b20:	e3a01001 	mov	r1, #1
8f617b24:	e1a00004 	mov	r0, r4
8f617b28:	ebfffe1c 	bl	8f6173a0 <update_dtb_entry_node>
8f617b2c:	e3500000 	cmp	r0, #0
8f617b30:	0a000027 	beq	8f617bd4 <platform_dt_match_best+0x11c>
		return NULL;

	/*check major and minor version
	* the suitable major&minor version must less than or equal to board major&minor version
	*/
	if (!update_dtb_entry_node(dt_list, DTB_MAJOR_MINOR))
8f617b34:	e3a01002 	mov	r1, #2
8f617b38:	e1a00004 	mov	r0, r4
8f617b3c:	ebfffe17 	bl	8f6173a0 <update_dtb_entry_node>
8f617b40:	e3500000 	cmp	r0, #0
8f617b44:	0a000022 	beq	8f617bd4 <platform_dt_match_best+0x11c>
		return NULL;

	/*check pmic info
	* the suitable pmic major&minor info must less than or equal to board pmic major&minor version
	*/
	if (!update_dtb_entry_node(dt_list, DTB_PMIC0))
8f617b48:	e3a01003 	mov	r1, #3
8f617b4c:	e1a00004 	mov	r0, r4
8f617b50:	ebfffe12 	bl	8f6173a0 <update_dtb_entry_node>
8f617b54:	e3500000 	cmp	r0, #0
8f617b58:	0a00001d 	beq	8f617bd4 <platform_dt_match_best+0x11c>
		return NULL;
	if (!update_dtb_entry_node(dt_list, DTB_PMIC1))
8f617b5c:	e3a01004 	mov	r1, #4
8f617b60:	e1a00004 	mov	r0, r4
8f617b64:	ebfffe0d 	bl	8f6173a0 <update_dtb_entry_node>
8f617b68:	e3500000 	cmp	r0, #0
8f617b6c:	0a000018 	beq	8f617bd4 <platform_dt_match_best+0x11c>
		return NULL;
	if (!update_dtb_entry_node(dt_list, DTB_PMIC2))
8f617b70:	e3a01005 	mov	r1, #5
8f617b74:	e1a00004 	mov	r0, r4
8f617b78:	ebfffe08 	bl	8f6173a0 <update_dtb_entry_node>
8f617b7c:	e3500000 	cmp	r0, #0
8f617b80:	0a000013 	beq	8f617bd4 <platform_dt_match_best+0x11c>
		return NULL;
	if (!update_dtb_entry_node(dt_list, DTB_PMIC3))
8f617b84:	e3a01006 	mov	r1, #6
8f617b88:	e1a00004 	mov	r0, r4
8f617b8c:	ebfffe03 	bl	8f6173a0 <update_dtb_entry_node>
8f617b90:	e3500000 	cmp	r0, #0
8f617b94:	0a00000e 	beq	8f617bd4 <platform_dt_match_best+0x11c>
		return NULL;

	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f617b98:	e5943004 	ldr	r3, [r4, #4]
8f617b9c:	e1540003 	cmp	r4, r3
8f617ba0:	1a000006 	bne	8f617bc0 <platform_dt_match_best+0x108>
8f617ba4:	ea00000a 	b	8f617bd4 <platform_dt_match_best+0x11c>
		if (!dt_node_tmp1) {
			dprintf(CRITICAL, "ERROR: Couldn't find the suitable DTB!\n");
			return NULL;
		}
		if (dt_node_tmp1->dt_entry_m)
8f617ba8:	e5930008 	ldr	r0, [r3, #8]
8f617bac:	e3500000 	cmp	r0, #0
8f617bb0:	1a000008 	bne	8f617bd8 <platform_dt_match_best+0x120>
	list_for_every_entry(&dt_list->node, dt_node_tmp1, dt_node, node) {
8f617bb4:	e5933004 	ldr	r3, [r3, #4]
8f617bb8:	e1540003 	cmp	r4, r3
8f617bbc:	0a000004 	beq	8f617bd4 <platform_dt_match_best+0x11c>
		if (!dt_node_tmp1) {
8f617bc0:	e3530000 	cmp	r3, #0
8f617bc4:	1afffff7 	bne	8f617ba8 <platform_dt_match_best+0xf0>
			dprintf(CRITICAL, "ERROR: Couldn't find the suitable DTB!\n");
8f617bc8:	e3050864 	movw	r0, #22628	; 0x5864
8f617bcc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f617bd0:	eb006b67 	bl	8f632974 <_dprintf>
			return NULL;
8f617bd4:	e3a00000 	mov	r0, #0
			return dt_node_tmp1->dt_entry_m;
	}

	return NULL;
}
8f617bd8:	e59f301c 	ldr	r3, [pc, #28]	; 8f617bfc <platform_dt_match_best+0x144>
8f617bdc:	e5932000 	ldr	r2, [r3]
8f617be0:	e59d3004 	ldr	r3, [r13, #4]
8f617be4:	e0332002 	eors	r2, r3, r2
8f617be8:	e3a03000 	mov	r3, #0
8f617bec:	1a000001 	bne	8f617bf8 <platform_dt_match_best+0x140>
8f617bf0:	e28dd008 	add	r13, r13, #8
8f617bf4:	e8bd8010 	pop	{r4, r15}
8f617bf8:	eb006bf0 	bl	8f632bc0 <__stack_chk_fail>
8f617bfc:	8f74221c 	.word	0x8f74221c

8f617c00 <fdt_check_header_ext>:
	if(fdt_start + fdt_totalsize(fdt) < fdt_start)
8f617c00:	e5902004 	ldr	r2, [r0, #4]
{
8f617c04:	e59f3140 	ldr	r3, [pc, #320]	; 8f617d4c <fdt_check_header_ext+0x14c>
8f617c08:	e92d4070 	push	{r4, r5, r6, r14}
8f617c0c:	e24dd008 	sub	r13, r13, #8
}
#define cpu_to_fdt16(x) fdt16_to_cpu(x)

static inline uint32_t fdt32_to_cpu(uint32_t x)
{
	return (EXTRACT_BYTE(0) << 24) | (EXTRACT_BYTE(1) << 16) | (EXTRACT_BYTE(2) << 8) | EXTRACT_BYTE(3);
8f617c10:	e7e7e452 	ubfx	r14, r2, #8, #8
8f617c14:	e5933000 	ldr	r3, [r3]
8f617c18:	e58d3004 	str	r3, [r13, #4]
8f617c1c:	e3a03000 	mov	r3, #0
8f617c20:	e1a03c22 	lsr	r3, r2, #24
8f617c24:	e7e7c852 	ubfx	r12, r2, #16, #8
8f617c28:	e1833c02 	orr	r3, r3, r2, lsl #24
8f617c2c:	e183380e 	orr	r3, r3, r14, lsl #16
8f617c30:	e183340c 	orr	r3, r3, r12, lsl #8
8f617c34:	e0902003 	adds	r2, r0, r3
8f617c38:	2a00003a 	bcs	8f617d28 <fdt_check_header_ext+0x128>
	if (((uint64_t)fdt_start + (uint64_t)fdt_off_dt_struct(fdt) + (uint64_t)fdt_size_dt_struct(fdt)) > UINT_MAX)
8f617c3c:	e590c008 	ldr	r12, [r0, #8]
8f617c40:	e3a01000 	mov	r1, #0
8f617c44:	e590e024 	ldr	r14, [r0, #36]	; 0x24
8f617c48:	e7e7445c 	ubfx	r4, r12, #8, #8
8f617c4c:	e1a03c2c 	lsr	r3, r12, #24
8f617c50:	e1833c0c 	orr	r3, r3, r12, lsl #24
8f617c54:	e7e7c85c 	ubfx	r12, r12, #16, #8
8f617c58:	e1833804 	orr	r3, r3, r4, lsl #16
8f617c5c:	e7e7445e 	ubfx	r4, r14, #8, #8
8f617c60:	e183340c 	orr	r3, r3, r12, lsl #8
8f617c64:	e1a0cc2e 	lsr	r12, r14, #24
8f617c68:	e18ccc0e 	orr	r12, r12, r14, lsl #24
8f617c6c:	e7e7e85e 	ubfx	r14, r14, #16, #8
8f617c70:	e18cc804 	orr	r12, r12, r4, lsl #16
8f617c74:	e18cc40e 	orr	r12, r12, r14, lsl #8
8f617c78:	e3e0e000 	mvn	r14, #0
8f617c7c:	e093300c 	adds	r3, r3, r12
8f617c80:	e0a1c001 	adc	r12, r1, r1
8f617c84:	e0903003 	adds	r3, r0, r3
8f617c88:	e2acc000 	adc	r12, r12, #0
8f617c8c:	e15e0003 	cmp	r14, r3
8f617c90:	e0d1c00c 	sbcs	r12, r1, r12
8f617c94:	3a000021 	bcc	8f617d20 <fdt_check_header_ext+0x120>
	if ((fdt_start + fdt_off_dt_struct(fdt) + fdt_size_dt_struct(fdt)) > fdt_end)
8f617c98:	e1520003 	cmp	r2, r3
8f617c9c:	3a00001f 	bcc	8f617d20 <fdt_check_header_ext+0x120>
	if (((uint64_t)fdt_start + (uint64_t)fdt_off_dt_strings(fdt) + (uint64_t)fdt_size_dt_strings(fdt)) > UINT_MAX)
8f617ca0:	e590500c 	ldr	r5, [r0, #12]
8f617ca4:	e5904020 	ldr	r4, [r0, #32]
8f617ca8:	e7e7c455 	ubfx	r12, r5, #8, #8
8f617cac:	e1a03c25 	lsr	r3, r5, #24
8f617cb0:	e7e76454 	ubfx	r6, r4, #8, #8
8f617cb4:	e1833c05 	orr	r3, r3, r5, lsl #24
8f617cb8:	e7e75855 	ubfx	r5, r5, #16, #8
8f617cbc:	e183380c 	orr	r3, r3, r12, lsl #16
8f617cc0:	e1a0cc24 	lsr	r12, r4, #24
8f617cc4:	e18ccc04 	orr	r12, r12, r4, lsl #24
8f617cc8:	e7e74854 	ubfx	r4, r4, #16, #8
8f617ccc:	e18cc806 	orr	r12, r12, r6, lsl #16
8f617cd0:	e1833405 	orr	r3, r3, r5, lsl #8
8f617cd4:	e18cc404 	orr	r12, r12, r4, lsl #8
8f617cd8:	e093300c 	adds	r3, r3, r12
8f617cdc:	e0a1c001 	adc	r12, r1, r1
8f617ce0:	e0900003 	adds	r0, r0, r3
8f617ce4:	e2ac3000 	adc	r3, r12, #0
8f617ce8:	e15e0000 	cmp	r14, r0
8f617cec:	e0d13003 	sbcs	r3, r1, r3
8f617cf0:	3a00000a 	bcc	8f617d20 <fdt_check_header_ext+0x120>
	return 0;
8f617cf4:	e1520000 	cmp	r2, r0
8f617cf8:	33a00004 	movcc	r0, #4
8f617cfc:	23a00000 	movcs	r0, #0
}
8f617d00:	e59f3044 	ldr	r3, [pc, #68]	; 8f617d4c <fdt_check_header_ext+0x14c>
8f617d04:	e5932000 	ldr	r2, [r3]
8f617d08:	e59d3004 	ldr	r3, [r13, #4]
8f617d0c:	e0332002 	eors	r2, r3, r2
8f617d10:	e3a03000 	mov	r3, #0
8f617d14:	1a00000b 	bne	8f617d48 <fdt_check_header_ext+0x148>
8f617d18:	e28dd008 	add	r13, r13, #8
8f617d1c:	e8bd8070 	pop	{r4, r5, r6, r15}
		return FDT_ERR_BADOFFSET;
8f617d20:	e3a00004 	mov	r0, #4
8f617d24:	eafffff5 	b	8f617d00 <fdt_check_header_ext+0x100>
		dprintf(CRITICAL,"Integer over in fdt header %s\t%d",__func__,__LINE__);
8f617d28:	e3a02078 	mov	r2, #120	; 0x78
8f617d2c:	e30614c8 	movw	r1, #25800	; 0x64c8
8f617d30:	e305088c 	movw	r0, #22668	; 0x588c
8f617d34:	e3481f70 	movt	r1, #36720	; 0x8f70
8f617d38:	e3480f70 	movt	r0, #36720	; 0x8f70
8f617d3c:	eb006b0c 	bl	8f632974 <_dprintf>
		return FDT_ERR_BADOFFSET;
8f617d40:	e3a00004 	mov	r0, #4
8f617d44:	eaffffed 	b	8f617d00 <fdt_check_header_ext+0x100>
}
8f617d48:	eb006b9c 	bl	8f632bc0 <__stack_chk_fail>
8f617d4c:	8f74221c 	.word	0x8f74221c

8f617d50 <dev_tree_appended>:
{
8f617d50:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f617d54:	e24dd0c4 	sub	r13, r13, #196	; 0xc4
	uintptr_t kernel_end = (uintptr_t)kernel + kernel_size;
8f617d58:	e0801001 	add	r1, r0, r1
{
8f617d5c:	e1a04002 	mov	r4, r2
8f617d60:	e58d3070 	str	r3, [r13, #112]	; 0x70
8f617d64:	e59f3ecc 	ldr	r3, [pc, #3788]	; 8f618c38 <dev_tree_appended+0xee8>
8f617d68:	e58d006c 	str	r0, [r13, #108]	; 0x6c
				malloc(sizeof(struct dt_entry_node));
8f617d6c:	e3a0000c 	mov	r0, #12
8f617d70:	e58de078 	str	r14, [r13, #120]	; 0x78
	uintptr_t kernel_end = (uintptr_t)kernel + kernel_size;
8f617d74:	e58d1034 	str	r1, [r13, #52]	; 0x34
{
8f617d78:	e5933000 	ldr	r3, [r3]
8f617d7c:	e58d30bc 	str	r3, [r13, #188]	; 0xbc
8f617d80:	e3a03000 	mov	r3, #0
	uint32_t app_dtb_offset = 0;
8f617d84:	e3a03000 	mov	r3, #0
8f617d88:	e58d3080 	str	r3, [r13, #128]	; 0x80
				malloc(sizeof(struct dt_entry_node));
8f617d8c:	eb00709a 	bl	8f633ffc <malloc>
	if (!dt_entry_queue) {
8f617d90:	e2503000 	subs	r3, r0, #0
8f617d94:	e58d3054 	str	r3, [r13, #84]	; 0x54
8f617d98:	0a0003a1 	beq	8f618c24 <dev_tree_appended+0xed4>
	list->prev = list->next = list;
8f617d9c:	e59d3054 	ldr	r3, [r13, #84]	; 0x54
	if (dtb_offset)
8f617da0:	e3540000 	cmp	r4, #0
		app_dtb_offset = dtb_offset;
8f617da4:	158d4080 	strne	r4, [r13, #128]	; 0x80
8f617da8:	e5833004 	str	r3, [r3, #4]
8f617dac:	e5833000 	str	r3, [r3]
	if (dtb_offset)
8f617db0:	0a00025e 	beq	8f618730 <dev_tree_appended+0x9e0>
	if (((uintptr_t)kernel + (uintptr_t)app_dtb_offset) < (uintptr_t)kernel) {
8f617db4:	e59d306c 	ldr	r3, [r13, #108]	; 0x6c
8f617db8:	e0934004 	adds	r4, r3, r4
8f617dbc:	23a03001 	movcs	r3, #1
8f617dc0:	33a03000 	movcc	r3, #0
8f617dc4:	e3530000 	cmp	r3, #0
8f617dc8:	e1a0b004 	mov	r11, r4
		return NULL;
8f617dcc:	13a05000 	movne	r5, #0
	if (((uintptr_t)kernel + (uintptr_t)app_dtb_offset) < (uintptr_t)kernel) {
8f617dd0:	1a000194 	bne	8f618428 <dev_tree_appended+0x6d8>
	while (((uintptr_t)dtb + sizeof(struct fdt_header)) < (uintptr_t)kernel_end) {
8f617dd4:	e59d1034 	ldr	r1, [r13, #52]	; 0x34
8f617dd8:	e2842028 	add	r2, r4, #40	; 0x28
	dtb = (void *)((uintptr_t)kernel + app_dtb_offset);
8f617ddc:	e1a08004 	mov	r8, r4
	while (((uintptr_t)dtb + sizeof(struct fdt_header)) < (uintptr_t)kernel_end) {
8f617de0:	e1510002 	cmp	r1, r2
8f617de4:	9a000137 	bls	8f6182c8 <dev_tree_appended+0x578>
8f617de8:	e1a07004 	mov	r7, r4
	unsigned dtb_count = 0;
8f617dec:	e58d3038 	str	r3, [r13, #56]	; 0x38
	root_offset = fdt_path_offset(dtb, "/");
8f617df0:	e30a3a5c 	movw	r3, #43612	; 0xaa5c
8f617df4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f617df8:	e58d3050 	str	r3, [r13, #80]	; 0x50
			dprintf(SPEW, "Found an appended flattened device tree (%s - %u %u %u 0x%x)\n",
8f617dfc:	e30538b0 	movw	r3, #22704	; 0x58b0
8f617e00:	e3483f70 	movt	r3, #36720	; 0x8f70
8f617e04:	e58d304c 	str	r3, [r13, #76]	; 0x4c
		memcpy(&dtb_hdr, dtb, sizeof(struct fdt_header));
8f617e08:	e3a02028 	mov	r2, #40	; 0x28
8f617e0c:	e1a01007 	mov	r1, r7
8f617e10:	e28d0094 	add	r0, r13, #148	; 0x94
8f617e14:	eb0070e7 	bl	8f6341b8 <memcpy>
		if (fdt_check_header((const void *)&dtb_hdr) != 0 ||
8f617e18:	e28d0094 	add	r0, r13, #148	; 0x94
8f617e1c:	eb00737a 	bl	8f634c0c <fdt_check_header>
8f617e20:	e3500000 	cmp	r0, #0
8f617e24:	1a000121 	bne	8f6182b0 <dev_tree_appended+0x560>
		    fdt_check_header_ext((const void *)&dtb_hdr) != 0 ||
8f617e28:	e28d0094 	add	r0, r13, #148	; 0x94
8f617e2c:	ebffff73 	bl	8f617c00 <fdt_check_header_ext>
		if (fdt_check_header((const void *)&dtb_hdr) != 0 ||
8f617e30:	e3500000 	cmp	r0, #0
8f617e34:	1a00011d 	bne	8f6182b0 <dev_tree_appended+0x560>
		    ((uintptr_t)dtb + (uintptr_t)fdt_totalsize((const void *)&dtb_hdr) < (uintptr_t)dtb) ||
8f617e38:	e59d2098 	ldr	r2, [r13, #152]	; 0x98
8f617e3c:	e7e70452 	ubfx	r0, r2, #8, #8
8f617e40:	e7e71852 	ubfx	r1, r2, #16, #8
8f617e44:	e1a03c22 	lsr	r3, r2, #24
8f617e48:	e1833c02 	orr	r3, r3, r2, lsl #24
8f617e4c:	e1833800 	orr	r3, r3, r0, lsl #16
8f617e50:	e183a401 	orr	r10, r3, r1, lsl #8
8f617e54:	e59d1034 	ldr	r1, [r13, #52]	; 0x34
8f617e58:	e09a200b 	adds	r2, r10, r11
8f617e5c:	23a03001 	movcs	r3, #1
8f617e60:	33a03000 	movcc	r3, #0
8f617e64:	e1520001 	cmp	r2, r1
8f617e68:	83833001 	orrhi	r3, r3, #1
8f617e6c:	e3530000 	cmp	r3, #0
8f617e70:	1a00010e 	bne	8f6182b0 <dev_tree_appended+0x560>
	root_offset = fdt_path_offset(dtb, "/");
8f617e74:	e59d1050 	ldr	r1, [r13, #80]	; 0x50
8f617e78:	e1a00007 	mov	r0, r7
8f617e7c:	eb007634 	bl	8f635754 <fdt_path_offset>
	if (root_offset < 0)
8f617e80:	e2504000 	subs	r4, r0, #0
8f617e84:	ba000100 	blt	8f61828c <dev_tree_appended+0x53c>
	prop = fdt_getprop(dtb, root_offset, "model", &len);
8f617e88:	e30568c8 	movw	r6, #22728	; 0x58c8
8f617e8c:	e3486f70 	movt	r6, #36720	; 0x8f70
8f617e90:	e28d3084 	add	r3, r13, #132	; 0x84
8f617e94:	e1a01004 	mov	r1, r4
8f617e98:	e1a02006 	mov	r2, r6
8f617e9c:	e1a00007 	mov	r0, r7
8f617ea0:	eb0076a2 	bl	8f635930 <fdt_getprop>
	if (prop && len > 0) {
8f617ea4:	e2505000 	subs	r5, r0, #0
8f617ea8:	0a000002 	beq	8f617eb8 <dev_tree_appended+0x168>
8f617eac:	e59d0084 	ldr	r0, [r13, #132]	; 0x84
8f617eb0:	e3500000 	cmp	r0, #0
8f617eb4:	ca000175 	bgt	8f618490 <dev_tree_appended+0x740>
		dprintf(INFO, "model does not exist in device tree\n");
8f617eb8:	e30508d0 	movw	r0, #22736	; 0x58d0
8f617ebc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f617ec0:	eb006aab 	bl	8f632974 <_dprintf>
	char *model = NULL;
8f617ec4:	e3a03000 	mov	r3, #0
8f617ec8:	e58d3044 	str	r3, [r13, #68]	; 0x44
	pmic_prop = (const char *)fdt_getprop(dtb, root_offset, "qcom,pmic-id", &len_pmic_id);
8f617ecc:	e28d3090 	add	r3, r13, #144	; 0x90
8f617ed0:	e1a01004 	mov	r1, r4
8f617ed4:	e305263c 	movw	r2, #22076	; 0x563c
8f617ed8:	e1a00007 	mov	r0, r7
8f617edc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f617ee0:	eb007692 	bl	8f635930 <fdt_getprop>
	board_prop = (const char *)fdt_getprop(dtb, root_offset, "qcom,board-id", &len_board_id);
8f617ee4:	e28d3088 	add	r3, r13, #136	; 0x88
8f617ee8:	e30524f0 	movw	r2, #21744	; 0x54f0
8f617eec:	e1a01004 	mov	r1, r4
8f617ef0:	e3482f70 	movt	r2, #36720	; 0x8f70
	pmic_prop = (const char *)fdt_getprop(dtb, root_offset, "qcom,pmic-id", &len_pmic_id);
8f617ef4:	e1a05000 	mov	r5, r0
8f617ef8:	e58d0040 	str	r0, [r13, #64]	; 0x40
	board_prop = (const char *)fdt_getprop(dtb, root_offset, "qcom,board-id", &len_board_id);
8f617efc:	e1a00007 	mov	r0, r7
8f617f00:	eb00768a 	bl	8f635930 <fdt_getprop>
	if (pmic_prop && (len_pmic_id > 0) && board_prop && (len_board_id > 0)) {
8f617f04:	e3550000 	cmp	r5, #0
	board_prop = (const char *)fdt_getprop(dtb, root_offset, "qcom,board-id", &len_board_id);
8f617f08:	e1a05000 	mov	r5, r0
	if (pmic_prop && (len_pmic_id > 0) && board_prop && (len_board_id > 0)) {
8f617f0c:	0a00014e 	beq	8f61844c <dev_tree_appended+0x6fc>
8f617f10:	e59d1090 	ldr	r1, [r13, #144]	; 0x90
8f617f14:	e3510000 	cmp	r1, #0
8f617f18:	da00014b 	ble	8f61844c <dev_tree_appended+0x6fc>
8f617f1c:	e3500000 	cmp	r0, #0
8f617f20:	0a000157 	beq	8f618484 <dev_tree_appended+0x734>
8f617f24:	e59d2088 	ldr	r2, [r13, #136]	; 0x88
8f617f28:	e3520000 	cmp	r2, #0
8f617f2c:	da000154 	ble	8f618484 <dev_tree_appended+0x734>
		if ((len_pmic_id % PMIC_ID_SIZE) || (len_board_id % BOARD_ID_SIZE))
8f617f30:	e1813002 	orr	r3, r1, r2
8f617f34:	e3130007 	tst	r3, #7
		dtb_ver = DEV_TREE_VERSION_V3;
8f617f38:	03a08003 	moveq	r8, #3
		min_plat_id_len = PLAT_ID_SIZE;
8f617f3c:	03a06008 	moveq	r6, #8
		if ((len_pmic_id % PMIC_ID_SIZE) || (len_board_id % BOARD_ID_SIZE))
8f617f40:	1a0001e9 	bne	8f6186ec <dev_tree_appended+0x99c>
	plat_prop = (const char *)fdt_getprop(dtb, root_offset, "qcom,msm-id", &len_plat_id);
8f617f44:	e1a01004 	mov	r1, r4
8f617f48:	e28d308c 	add	r3, r13, #140	; 0x8c
8f617f4c:	e30523d8 	movw	r2, #21464	; 0x53d8
8f617f50:	e1a00007 	mov	r0, r7
8f617f54:	e3482f70 	movt	r2, #36720	; 0x8f70
8f617f58:	eb007674 	bl	8f635930 <fdt_getprop>
	if (!plat_prop || len_plat_id <= 0) {
8f617f5c:	e2504000 	subs	r4, r0, #0
8f617f60:	0a000153 	beq	8f6184b4 <dev_tree_appended+0x764>
8f617f64:	e59d908c 	ldr	r9, [r13, #140]	; 0x8c
8f617f68:	e3590000 	cmp	r9, #0
8f617f6c:	da000150 	ble	8f6184b4 <dev_tree_appended+0x764>
	} else if (len_plat_id % min_plat_id_len) {
8f617f70:	e1a01006 	mov	r1, r6
8f617f74:	e1a00009 	mov	r0, r9
8f617f78:	fa009459 	blx	8f63d0e4 <__aeabi_idivmod>
8f617f7c:	e3510000 	cmp	r1, #0
8f617f80:	1a0001e4 	bne	8f618718 <dev_tree_appended+0x9c8>
	if (dtb_ver == DEV_TREE_VERSION_V1) {
8f617f84:	e3580001 	cmp	r8, #1
8f617f88:	0a00014d 	beq	8f6184c4 <dev_tree_appended+0x774>
		board_data_count = (len_board_id / BOARD_ID_SIZE);
8f617f8c:	e59d2088 	ldr	r2, [r13, #136]	; 0x88
		msm_data_count = (len_plat_id / PLAT_ID_SIZE);
8f617f90:	e1a031c9 	asr	r3, r9, #3
		pmic_data_count = (len_pmic_id / PMIC_ID_SIZE);
8f617f94:	e59d1090 	ldr	r1, [r13, #144]	; 0x90
		board_data_count = (len_board_id / BOARD_ID_SIZE);
8f617f98:	e3520000 	cmp	r2, #0
		msm_data_count = (len_plat_id / PLAT_ID_SIZE);
8f617f9c:	e58d3048 	str	r3, [r13, #72]	; 0x48
		board_data_count = (len_board_id / BOARD_ID_SIZE);
8f617fa0:	e2823007 	add	r3, r2, #7
8f617fa4:	a1a03002 	movge	r3, r2
		pmic_data_count = (len_pmic_id / PMIC_ID_SIZE);
8f617fa8:	e3510000 	cmp	r1, #0
		board_data = (struct board_id *) malloc(sizeof(struct board_id) * (len_board_id / BOARD_ID_SIZE));
8f617fac:	e3c39007 	bic	r9, r3, #7
		pmic_data_count = (len_pmic_id / PMIC_ID_SIZE);
8f617fb0:	e2812007 	add	r2, r1, #7
8f617fb4:	a1a02001 	movge	r2, r1
		board_data_count = (len_board_id / BOARD_ID_SIZE);
8f617fb8:	e1a031c3 	asr	r3, r3, #3
		board_data = (struct board_id *) malloc(sizeof(struct board_id) * (len_board_id / BOARD_ID_SIZE));
8f617fbc:	e1a00009 	mov	r0, r9
		pmic_data_count = (len_pmic_id / PMIC_ID_SIZE);
8f617fc0:	e1a021c2 	asr	r2, r2, #3
		board_data_count = (len_board_id / BOARD_ID_SIZE);
8f617fc4:	e58d3028 	str	r3, [r13, #40]	; 0x28
		pmic_data_count = (len_pmic_id / PMIC_ID_SIZE);
8f617fc8:	e58d202c 	str	r2, [r13, #44]	; 0x2c
		board_data = (struct board_id *) malloc(sizeof(struct board_id) * (len_board_id / BOARD_ID_SIZE));
8f617fcc:	eb00700a 	bl	8f633ffc <malloc>
		ASSERT(board_data);
8f617fd0:	e2503000 	subs	r3, r0, #0
8f617fd4:	e58d3058 	str	r3, [r13, #88]	; 0x58
8f617fd8:	0a0002e2 	beq	8f618b68 <dev_tree_appended+0xe18>
		platform_data = (struct plat_id *) malloc(sizeof(struct plat_id) * (len_plat_id / PLAT_ID_SIZE));
8f617fdc:	e59d308c 	ldr	r3, [r13, #140]	; 0x8c
8f617fe0:	e3530000 	cmp	r3, #0
8f617fe4:	e2830007 	add	r0, r3, #7
8f617fe8:	a1a00003 	movge	r0, r3
8f617fec:	e3c00007 	bic	r0, r0, #7
8f617ff0:	eb007001 	bl	8f633ffc <malloc>
		ASSERT(platform_data);
8f617ff4:	e2503000 	subs	r3, r0, #0
8f617ff8:	e58d3064 	str	r3, [r13, #100]	; 0x64
8f617ffc:	0a0002e4 	beq	8f618b94 <dev_tree_appended+0xe44>
		if (dtb_ver == DEV_TREE_VERSION_V3) {
8f618000:	e3580003 	cmp	r8, #3
	struct pmic_id *pmic_data = NULL;
8f618004:	13a03000 	movne	r3, #0
8f618008:	158d303c 	strne	r3, [r13, #60]	; 0x3c
		if (dtb_ver == DEV_TREE_VERSION_V3) {
8f61800c:	0a000296 	beq	8f618a6c <dev_tree_appended+0xd1c>
		for(i = 0 ; i < board_data_count; i++) {
8f618010:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f618014:	e3530000 	cmp	r3, #0
8f618018:	0a00001c 	beq	8f618090 <dev_tree_appended+0x340>
8f61801c:	e59d1058 	ldr	r1, [r13, #88]	; 0x58
8f618020:	e2852008 	add	r2, r5, #8
8f618024:	e59de088 	ldr	r14, [r13, #136]	; 0x88
8f618028:	e081c009 	add	r12, r1, r9
			board_data[i].variant_id = fdt32_to_cpu(((struct board_id *)board_prop)->variant_id);
8f61802c:	e5126008 	ldr	r6, [r2, #-8]
		for(i = 0 ; i < board_data_count; i++) {
8f618030:	e2811008 	add	r1, r1, #8
8f618034:	e2822008 	add	r2, r2, #8
8f618038:	e7e75456 	ubfx	r5, r6, #8, #8
8f61803c:	e7e70856 	ubfx	r0, r6, #16, #8
8f618040:	e1a03c26 	lsr	r3, r6, #24
8f618044:	e1833c06 	orr	r3, r3, r6, lsl #24
8f618048:	e1833805 	orr	r3, r3, r5, lsl #16
8f61804c:	e1833400 	orr	r3, r3, r0, lsl #8
			board_data[i].variant_id = fdt32_to_cpu(((struct board_id *)board_prop)->variant_id);
8f618050:	e5013008 	str	r3, [r1, #-8]
			board_data[i].platform_subtype = fdt32_to_cpu(((struct board_id *)board_prop)->platform_subtype);
8f618054:	e512600c 	ldr	r6, [r2, #-12]
8f618058:	e7e75456 	ubfx	r5, r6, #8, #8
8f61805c:	e7e70856 	ubfx	r0, r6, #16, #8
8f618060:	e1a03c26 	lsr	r3, r6, #24
8f618064:	e1833c06 	orr	r3, r3, r6, lsl #24
8f618068:	e1833805 	orr	r3, r3, r5, lsl #16
8f61806c:	e1833400 	orr	r3, r3, r0, lsl #8
8f618070:	e5013004 	str	r3, [r1, #-4]
			if (board_data[i].platform_subtype == 0)
8f618074:	e3530000 	cmp	r3, #0
					fdt32_to_cpu(((struct board_id *)board_prop)->variant_id) >> 0x18;
8f618078:	05523010 	ldrbeq	r3, [r2, #-16]
				board_data[i].platform_subtype =
8f61807c:	05013004 	streq	r3, [r1, #-4]
		for(i = 0 ; i < board_data_count; i++) {
8f618080:	e15c0001 	cmp	r12, r1
8f618084:	1affffe8 	bne	8f61802c <dev_tree_appended+0x2dc>
			len_board_id -= sizeof(struct board_id);
8f618088:	e04ee009 	sub	r14, r14, r9
8f61808c:	e58de088 	str	r14, [r13, #136]	; 0x88
		for(i = 0 ; i < msm_data_count; i++) {
8f618090:	e59d5048 	ldr	r5, [r13, #72]	; 0x48
8f618094:	e3550000 	cmp	r5, #0
8f618098:	0a00001c 	beq	8f618110 <dev_tree_appended+0x3c0>
8f61809c:	e59d6064 	ldr	r6, [r13, #100]	; 0x64
8f6180a0:	e284c004 	add	r12, r4, #4
8f6180a4:	e59de08c 	ldr	r14, [r13, #140]	; 0x8c
8f6180a8:	e3a02000 	mov	r2, #0
8f6180ac:	e2860004 	add	r0, r6, #4
8f6180b0:	e58db024 	str	r11, [r13, #36]	; 0x24
			platform_data[i].platform_id = fdt32_to_cpu(((struct plat_id *)plat_prop)->platform_id);
8f6180b4:	e7941182 	ldr	r1, [r4, r2, lsl #3]
8f6180b8:	e7e7b451 	ubfx	r11, r1, #8, #8
8f6180bc:	e7e79851 	ubfx	r9, r1, #16, #8
8f6180c0:	e1a03c21 	lsr	r3, r1, #24
8f6180c4:	e1833c01 	orr	r3, r3, r1, lsl #24
8f6180c8:	e183b80b 	orr	r11, r3, r11, lsl #16
8f6180cc:	e18b9409 	orr	r9, r11, r9, lsl #8
8f6180d0:	e7869182 	str	r9, [r6, r2, lsl #3]
			platform_data[i].soc_rev = fdt32_to_cpu(((struct plat_id *)plat_prop)->soc_rev);
8f6180d4:	e79c1182 	ldr	r1, [r12, r2, lsl #3]
8f6180d8:	e7e7b451 	ubfx	r11, r1, #8, #8
8f6180dc:	e7e79851 	ubfx	r9, r1, #16, #8
8f6180e0:	e1a03c21 	lsr	r3, r1, #24
8f6180e4:	e1833c01 	orr	r3, r3, r1, lsl #24
8f6180e8:	e183b80b 	orr	r11, r3, r11, lsl #16
8f6180ec:	e18b9409 	orr	r9, r11, r9, lsl #8
8f6180f0:	e7809182 	str	r9, [r0, r2, lsl #3]
		for(i = 0 ; i < msm_data_count; i++) {
8f6180f4:	e2822001 	add	r2, r2, #1
8f6180f8:	e1550002 	cmp	r5, r2
8f6180fc:	1affffec 	bne	8f6180b4 <dev_tree_appended+0x364>
			len_plat_id -= sizeof(struct plat_id);
8f618100:	e59d3048 	ldr	r3, [r13, #72]	; 0x48
8f618104:	e59db024 	ldr	r11, [r13, #36]	; 0x24
8f618108:	e04ee183 	sub	r14, r14, r3, lsl #3
8f61810c:	e58de08c 	str	r14, [r13, #140]	; 0x8c
		if (dtb_ver == DEV_TREE_VERSION_V3 && pmic_prop) {
8f618110:	e2483003 	sub	r3, r8, #3
8f618114:	e59d2040 	ldr	r2, [r13, #64]	; 0x40
8f618118:	e16f3f13 	clz	r3, r3
8f61811c:	e1a032a3 	lsr	r3, r3, #5
8f618120:	e58d3068 	str	r3, [r13, #104]	; 0x68
8f618124:	e3520000 	cmp	r2, #0
8f618128:	03a03000 	moveq	r3, #0
8f61812c:	12033001 	andne	r3, r3, #1
8f618130:	e3530000 	cmp	r3, #0
8f618134:	0a000165 	beq	8f6186d0 <dev_tree_appended+0x980>
			for(i = 0 ; i < pmic_data_count; i++) {
8f618138:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
8f61813c:	e3530000 	cmp	r3, #0
8f618140:	0a00002d 	beq	8f6181fc <dev_tree_appended+0x4ac>
8f618144:	e2821010 	add	r1, r2, #16
8f618148:	e59d203c 	ldr	r2, [r13, #60]	; 0x3c
8f61814c:	e1a05203 	lsl	r5, r3, #4
8f618150:	e59d6090 	ldr	r6, [r13, #144]	; 0x90
8f618154:	e0820005 	add	r0, r2, r5
				pmic_data[i].pmic_version[0]= fdt32_to_cpu(((struct pmic_id *)pmic_prop)->pmic_version[0]);
8f618158:	e511c010 	ldr	r12, [r1, #-16]
			for(i = 0 ; i < pmic_data_count; i++) {
8f61815c:	e2822010 	add	r2, r2, #16
8f618160:	e2811010 	add	r1, r1, #16
8f618164:	e1500002 	cmp	r0, r2
8f618168:	e7e7445c 	ubfx	r4, r12, #8, #8
8f61816c:	e7e7e85c 	ubfx	r14, r12, #16, #8
8f618170:	e1a03c2c 	lsr	r3, r12, #24
8f618174:	e1833c0c 	orr	r3, r3, r12, lsl #24
8f618178:	e1833804 	orr	r3, r3, r4, lsl #16
8f61817c:	e183340e 	orr	r3, r3, r14, lsl #8
				pmic_data[i].pmic_version[0]= fdt32_to_cpu(((struct pmic_id *)pmic_prop)->pmic_version[0]);
8f618180:	e5023010 	str	r3, [r2, #-16]
				pmic_data[i].pmic_version[1]= fdt32_to_cpu(((struct pmic_id *)pmic_prop)->pmic_version[1]);
8f618184:	e511c01c 	ldr	r12, [r1, #-28]	; 0xffffffe4
8f618188:	e7e7445c 	ubfx	r4, r12, #8, #8
8f61818c:	e7e7e85c 	ubfx	r14, r12, #16, #8
8f618190:	e1a03c2c 	lsr	r3, r12, #24
8f618194:	e1833c0c 	orr	r3, r3, r12, lsl #24
8f618198:	e1833804 	orr	r3, r3, r4, lsl #16
8f61819c:	e183340e 	orr	r3, r3, r14, lsl #8
8f6181a0:	e502300c 	str	r3, [r2, #-12]
				pmic_data[i].pmic_version[2]= fdt32_to_cpu(((struct pmic_id *)pmic_prop)->pmic_version[2]);
8f6181a4:	e511c018 	ldr	r12, [r1, #-24]	; 0xffffffe8
8f6181a8:	e7e7445c 	ubfx	r4, r12, #8, #8
8f6181ac:	e7e7e85c 	ubfx	r14, r12, #16, #8
8f6181b0:	e1a03c2c 	lsr	r3, r12, #24
8f6181b4:	e1833c0c 	orr	r3, r3, r12, lsl #24
8f6181b8:	e1833804 	orr	r3, r3, r4, lsl #16
8f6181bc:	e183340e 	orr	r3, r3, r14, lsl #8
8f6181c0:	e5023008 	str	r3, [r2, #-8]
				pmic_data[i].pmic_version[3]= fdt32_to_cpu(((struct pmic_id *)pmic_prop)->pmic_version[3]);
8f6181c4:	e511c014 	ldr	r12, [r1, #-20]	; 0xffffffec
8f6181c8:	e7e7445c 	ubfx	r4, r12, #8, #8
8f6181cc:	e7e7e85c 	ubfx	r14, r12, #16, #8
8f6181d0:	e1a03c2c 	lsr	r3, r12, #24
8f6181d4:	e1833c0c 	orr	r3, r3, r12, lsl #24
8f6181d8:	e1833804 	orr	r3, r3, r4, lsl #16
8f6181dc:	e183340e 	orr	r3, r3, r14, lsl #8
8f6181e0:	e5023004 	str	r3, [r2, #-4]
			for(i = 0 ; i < pmic_data_count; i++) {
8f6181e4:	1affffdb 	bne	8f618158 <dev_tree_appended+0x408>
				pmic_prop += sizeof(struct pmic_id);
8f6181e8:	e59d3040 	ldr	r3, [r13, #64]	; 0x40
8f6181ec:	e0833005 	add	r3, r3, r5
				len_pmic_id -= sizeof(struct pmic_id);
8f6181f0:	e0465005 	sub	r5, r6, r5
				pmic_prop += sizeof(struct pmic_id);
8f6181f4:	e58d3040 	str	r3, [r13, #64]	; 0x40
8f6181f8:	e58d5090 	str	r5, [r13, #144]	; 0x90
			num_entries = msm_data_count * board_data_count * pmic_data_count;
8f6181fc:	e59d2048 	ldr	r2, [r13, #72]	; 0x48
8f618200:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f618204:	e0030392 	mul	r3, r2, r3
8f618208:	e59d202c 	ldr	r2, [r13, #44]	; 0x2c
8f61820c:	e0030392 	mul	r3, r2, r3
8f618210:	e1a0e003 	mov	r14, r3
8f618214:	e58d3060 	str	r3, [r13, #96]	; 0x60
		if ((((uint64_t)msm_data_count * (uint64_t)board_data_count * (uint64_t)pmic_data_count) !=
8f618218:	e59dc028 	ldr	r12, [r13, #40]	; 0x28
8f61821c:	e3a00000 	mov	r0, #0
8f618220:	e59d2048 	ldr	r2, [r13, #72]	; 0x48
8f618224:	e59d402c 	ldr	r4, [r13, #44]	; 0x2c
8f618228:	e1a03fc2 	asr	r3, r2, #31
8f61822c:	e0812c92 	umull	r2, r1, r2, r12
8f618230:	e023139c 	mla	r3, r12, r3, r1
8f618234:	e081c294 	umull	r12, r1, r4, r2
8f618238:	e0211394 	mla	r1, r4, r3, r1
8f61823c:	e1510000 	cmp	r1, r0
8f618240:	015c000e 	cmpeq	r12, r14
8f618244:	1a000002 	bne	8f618254 <dev_tree_appended+0x504>
			msm_data_count * board_data_count * pmic_data_count) ||
8f618248:	e1530000 	cmp	r3, r0
8f61824c:	01520002 	cmpeq	r2, r2
8f618250:	0a00013d 	beq	8f61874c <dev_tree_appended+0x9fc>
			free(board_data);
8f618254:	e59d0058 	ldr	r0, [r13, #88]	; 0x58
8f618258:	eb006fab 	bl	8f63410c <free>
			free(platform_data);
8f61825c:	e59d0064 	ldr	r0, [r13, #100]	; 0x64
8f618260:	eb006fa9 	bl	8f63410c <free>
			if (pmic_data)
8f618264:	e59d303c 	ldr	r3, [r13, #60]	; 0x3c
8f618268:	e3530000 	cmp	r3, #0
8f61826c:	0a000001 	beq	8f618278 <dev_tree_appended+0x528>
				free(pmic_data);
8f618270:	e1a00003 	mov	r0, r3
8f618274:	eb006fa4 	bl	8f63410c <free>
	if (model)
8f618278:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f61827c:	e3530000 	cmp	r3, #0
8f618280:	0a000001 	beq	8f61828c <dev_tree_appended+0x53c>
		free(model);
8f618284:	e1a00003 	mov	r0, r3
8f618288:	eb006f9f 	bl	8f63410c <free>
		dtb_count++;
8f61828c:	e59d3038 	ldr	r3, [r13, #56]	; 0x38
		dtb += dtb_size;
8f618290:	e087700a 	add	r7, r7, r10
	while (((uintptr_t)dtb + sizeof(struct fdt_header)) < (uintptr_t)kernel_end) {
8f618294:	e59d2034 	ldr	r2, [r13, #52]	; 0x34
		dtb_count++;
8f618298:	e2833001 	add	r3, r3, #1
8f61829c:	e58d3038 	str	r3, [r13, #56]	; 0x38
	while (((uintptr_t)dtb + sizeof(struct fdt_header)) < (uintptr_t)kernel_end) {
8f6182a0:	e2873028 	add	r3, r7, #40	; 0x28
8f6182a4:	e1a0b007 	mov	r11, r7
8f6182a8:	e1530002 	cmp	r3, r2
8f6182ac:	3afffed5 	bcc	8f617e08 <dev_tree_appended+0xb8>
	if (list_is_empty(&dt_entry_queue->node) && (dtb_count == 1)) {
8f6182b0:	e59d2054 	ldr	r2, [r13, #84]	; 0x54
8f6182b4:	e59d1038 	ldr	r1, [r13, #56]	; 0x38
8f6182b8:	e5923004 	ldr	r3, [r2, #4]
8f6182bc:	e1530002 	cmp	r3, r2
8f6182c0:	03510001 	cmpeq	r1, #1
8f6182c4:	0a00023d 	beq	8f618bc0 <dev_tree_appended+0xe70>
	void *bestmatch_tag = NULL;
8f6182c8:	e3a05000 	mov	r5, #0
	best_match_dt_entry = platform_dt_match_best(dt_entry_queue);
8f6182cc:	e59d0054 	ldr	r0, [r13, #84]	; 0x54
8f6182d0:	ebfffdf8 	bl	8f617ab8 <platform_dt_match_best>
	if (best_match_dt_entry){
8f6182d4:	e2504000 	subs	r4, r0, #0
8f6182d8:	0a00002a 	beq	8f618388 <dev_tree_appended+0x638>
		bestmatch_tag_size = best_match_dt_entry->size;
8f6182dc:	e5940024 	ldr	r0, [r4, #36]	; 0x24
		bestmatch_tag = (void *)best_match_dt_entry->offset;
8f6182e0:	e5945020 	ldr	r5, [r4, #32]
		dprintf(INFO, "Best match DTB tags %u/%08x/0x%08x/%x/%x/%x/%x/%x/%x/%x\n",
8f6182e4:	e1c420d4 	ldrd	r2, [r4, #4]
8f6182e8:	e5941000 	ldr	r1, [r4]
		bestmatch_tag_size = best_match_dt_entry->size;
8f6182ec:	e58d0074 	str	r0, [r13, #116]	; 0x74
		dprintf(INFO, "Best match DTB tags %u/%08x/0x%08x/%x/%x/%x/%x/%x/%x/%x\n",
8f6182f0:	e58d0018 	str	r0, [r13, #24]
8f6182f4:	e58d5014 	str	r5, [r13, #20]
8f6182f8:	e594001c 	ldr	r0, [r4, #28]
8f6182fc:	e58d0010 	str	r0, [r13, #16]
8f618300:	e5940018 	ldr	r0, [r4, #24]
8f618304:	e58d000c 	str	r0, [r13, #12]
8f618308:	e5940014 	ldr	r0, [r4, #20]
8f61830c:	e58d0008 	str	r0, [r13, #8]
8f618310:	e5940010 	ldr	r0, [r4, #16]
8f618314:	e58d0004 	str	r0, [r13, #4]
8f618318:	e594000c 	ldr	r0, [r4, #12]
8f61831c:	e58d0000 	str	r0, [r13]
8f618320:	e3050bf8 	movw	r0, #23544	; 0x5bf8
8f618324:	e3480f70 	movt	r0, #36720	; 0x8f70
8f618328:	eb006991 	bl	8f632974 <_dprintf>
		dprintf(INFO, "Using pmic info 0x%0x/0x%x/0x%x/0x%0x for device 0x%0x/0x%x/0x%x/0x%0x\n",
8f61832c:	e3a00000 	mov	r0, #0
8f618330:	e1c481d0 	ldrd	r8, [r4, #16]
8f618334:	e1c4a1d8 	ldrd	r10, [r4, #24]
8f618338:	ebffe002 	bl	8f610348 <board_pmic_target>
8f61833c:	e1a04000 	mov	r4, r0
8f618340:	e3a00001 	mov	r0, #1
8f618344:	ebffdfff 	bl	8f610348 <board_pmic_target>
8f618348:	e1a06000 	mov	r6, r0
8f61834c:	e3a00002 	mov	r0, #2
8f618350:	ebffdffc 	bl	8f610348 <board_pmic_target>
8f618354:	e1a07000 	mov	r7, r0
8f618358:	e3a00003 	mov	r0, #3
8f61835c:	ebffdff9 	bl	8f610348 <board_pmic_target>
8f618360:	e1a0300a 	mov	r3, r10
8f618364:	e1a02009 	mov	r2, r9
8f618368:	e1a01008 	mov	r1, r8
8f61836c:	e58d700c 	str	r7, [r13, #12]
8f618370:	e98d0050 	stmib	r13, {r4, r6}
8f618374:	e58db000 	str	r11, [r13]
8f618378:	e58d0010 	str	r0, [r13, #16]
8f61837c:	e3050c34 	movw	r0, #23604	; 0x5c34
8f618380:	e3480f70 	movt	r0, #36720	; 0x8f70
8f618384:	eb00697a 	bl	8f632974 <_dprintf>
	list_for_every_entry(&dt_entry_queue->node, dt_node_tmp1, dt_node, node) {
8f618388:	e59d8054 	ldr	r8, [r13, #84]	; 0x54
8f61838c:	e5984004 	ldr	r4, [r8, #4]
8f618390:	e1580004 	cmp	r8, r4
8f618394:	0a000015 	beq	8f6183f0 <dev_tree_appended+0x6a0>
	item->prev = item->next = 0;
8f618398:	e3a07000 	mov	r7, #0
8f61839c:	ea00000a 	b	8f6183cc <dev_tree_appended+0x67c>
	item->next->prev = item->prev;
8f6183a0:	e5836000 	str	r6, [r3]
			free(dt_node_member->dt_entry_m);
8f6183a4:	e5940008 	ldr	r0, [r4, #8]
	item->prev->next = item->next;
8f6183a8:	e5863004 	str	r3, [r6, #4]
	item->prev = item->next = 0;
8f6183ac:	e5847004 	str	r7, [r4, #4]
8f6183b0:	e5847000 	str	r7, [r4]
8f6183b4:	eb006f54 	bl	8f63410c <free>
			free(dt_node_member);
8f6183b8:	e1a00004 	mov	r0, r4
8f6183bc:	eb006f52 	bl	8f63410c <free>
	list_for_every_entry(&dt_entry_queue->node, dt_node_tmp1, dt_node, node) {
8f6183c0:	e5964004 	ldr	r4, [r6, #4]
8f6183c4:	e1580004 	cmp	r8, r4
8f6183c8:	0a000008 	beq	8f6183f0 <dev_tree_appended+0x6a0>
		dt_node_tmp2 = (struct dt_entry_node *) dt_node_tmp1->node.prev;
8f6183cc:	e5946000 	ldr	r6, [r4]
	if (item->prev == 0 && item->next == 0)
8f6183d0:	e5943004 	ldr	r3, [r4, #4]
8f6183d4:	e3560000 	cmp	r6, #0
8f6183d8:	1afffff0 	bne	8f6183a0 <dev_tree_appended+0x650>
8f6183dc:	e3530000 	cmp	r3, #0
8f6183e0:	1affffee 	bne	8f6183a0 <dev_tree_appended+0x650>
	list_for_every_entry(&dt_entry_queue->node, dt_node_tmp1, dt_node, node) {
8f6183e4:	e5964004 	ldr	r4, [r6, #4]
8f6183e8:	e1580004 	cmp	r8, r4
8f6183ec:	1afffff6 	bne	8f6183cc <dev_tree_appended+0x67c>
	if(bestmatch_tag) {
8f6183f0:	e3550000 	cmp	r5, #0
8f6183f4:	0a0001ba 	beq	8f618ae4 <dev_tree_appended+0xd94>
		if (check_aboot_addr_range_overlap((uintptr_t)tags, bestmatch_tag_size)) {
8f6183f8:	e1cd07d0 	ldrd	r0, [r13, #112]	; 0x70
8f6183fc:	eb0039fd 	bl	8f626bf8 <check_aboot_addr_range_overlap>
8f618400:	e2504000 	subs	r4, r0, #0
8f618404:	1a0000be 	bne	8f618704 <dev_tree_appended+0x9b4>
		memcpy(tags, bestmatch_tag, bestmatch_tag_size);
8f618408:	e1a01005 	mov	r1, r5
8f61840c:	e59d5070 	ldr	r5, [r13, #112]	; 0x70
8f618410:	e59d2074 	ldr	r2, [r13, #116]	; 0x74
8f618414:	e1a00005 	mov	r0, r5
8f618418:	eb006f66 	bl	8f6341b8 <memcpy>
		*((uint32_t *)(kernel + app_dtb_offset)) = 0;
8f61841c:	e59d3080 	ldr	r3, [r13, #128]	; 0x80
8f618420:	e59d206c 	ldr	r2, [r13, #108]	; 0x6c
8f618424:	e7824003 	str	r4, [r2, r3]
}
8f618428:	e59f3808 	ldr	r3, [pc, #2056]	; 8f618c38 <dev_tree_appended+0xee8>
8f61842c:	e5932000 	ldr	r2, [r3]
8f618430:	e59d30bc 	ldr	r3, [r13, #188]	; 0xbc
8f618434:	e0332002 	eors	r2, r3, r2
8f618438:	e3a03000 	mov	r3, #0
8f61843c:	1a0001f7 	bne	8f618c20 <dev_tree_appended+0xed0>
8f618440:	e1a00005 	mov	r0, r5
8f618444:	e28dd0c4 	add	r13, r13, #196	; 0xc4
8f618448:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	} else if (board_prop && len_board_id > 0) {
8f61844c:	e3550000 	cmp	r5, #0
8f618450:	0a00000b 	beq	8f618484 <dev_tree_appended+0x734>
8f618454:	e59d1088 	ldr	r1, [r13, #136]	; 0x88
8f618458:	e3510000 	cmp	r1, #0
8f61845c:	da000008 	ble	8f618484 <dev_tree_appended+0x734>
		if (len_board_id % BOARD_ID_SIZE)
8f618460:	e3110007 	tst	r1, #7
		dtb_ver = DEV_TREE_VERSION_V2;
8f618464:	03a08002 	moveq	r8, #2
		min_plat_id_len = PLAT_ID_SIZE;
8f618468:	03a06008 	moveq	r6, #8
		if (len_board_id % BOARD_ID_SIZE)
8f61846c:	0afffeb4 	beq	8f617f44 <dev_tree_appended+0x1f4>
			dprintf(CRITICAL, "qcom,board-id in device tree is (%d) not a multiple of (%d)\n",
8f618470:	e3a02008 	mov	r2, #8
8f618474:	e305094c 	movw	r0, #22860	; 0x594c
8f618478:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61847c:	eb00693c 	bl	8f632974 <_dprintf>
			return false;
8f618480:	eaffff81 	b	8f61828c <dev_tree_appended+0x53c>
		dtb_ver = DEV_TREE_VERSION_V1;
8f618484:	e3a08001 	mov	r8, #1
		min_plat_id_len = DT_ENTRY_V1_SIZE;
8f618488:	e3a0600c 	mov	r6, #12
8f61848c:	eafffeac 	b	8f617f44 <dev_tree_appended+0x1f4>
		model = (char *) malloc(sizeof(char) * len);
8f618490:	eb006ed9 	bl	8f633ffc <malloc>
		ASSERT(model);
8f618494:	e2503000 	subs	r3, r0, #0
8f618498:	e58d3044 	str	r3, [r13, #68]	; 0x44
8f61849c:	0a000187 	beq	8f618ac0 <dev_tree_appended+0xd70>
		strlcpy(model, prop, len);
8f6184a0:	e59d2084 	ldr	r2, [r13, #132]	; 0x84
8f6184a4:	e1a01005 	mov	r1, r5
8f6184a8:	e59d0044 	ldr	r0, [r13, #68]	; 0x44
8f6184ac:	eb00709f 	bl	8f634730 <strlcpy>
8f6184b0:	eafffe85 	b	8f617ecc <dev_tree_appended+0x17c>
		dprintf(INFO, "qcom,msm-id entry not found\n");
8f6184b4:	e305098c 	movw	r0, #22924	; 0x598c
8f6184b8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6184bc:	eb00692c 	bl	8f632974 <_dprintf>
		return false;
8f6184c0:	eaffff71 	b	8f61828c <dev_tree_appended+0x53c>
				malloc(sizeof(struct dt_entry));
8f6184c4:	e3a00028 	mov	r0, #40	; 0x28
8f6184c8:	e58d1024 	str	r1, [r13, #36]	; 0x24
8f6184cc:	eb006eca 	bl	8f633ffc <malloc>
		if (!cur_dt_entry) {
8f6184d0:	e59d1024 	ldr	r1, [r13, #36]	; 0x24
8f6184d4:	e2505000 	subs	r5, r0, #0
8f6184d8:	0a0001cc 	beq	8f618c10 <dev_tree_appended+0xec0>
		memset(cur_dt_entry, 0, sizeof(struct dt_entry));
8f6184dc:	e3a02028 	mov	r2, #40	; 0x28
8f6184e0:	eb006f77 	bl	8f6342c4 <memset>
		while (len_plat_id) {
8f6184e4:	e59d308c 	ldr	r3, [r13, #140]	; 0x8c
8f6184e8:	e3530000 	cmp	r3, #0
8f6184ec:	0a000072 	beq	8f6186bc <dev_tree_appended+0x96c>
			dprintf(SPEW, "Found an appended flattened device tree (%s - %u %u 0x%x)\n",
8f6184f0:	e30589e8 	movw	r8, #23016	; 0x59e8
				dprintf(SPEW, "Device tree's msm_id doesn't match the board: <%u %u 0x%x> != <%u %u 0x%x>\n",
8f6184f4:	e3053a68 	movw	r3, #23144	; 0x5a68
8f6184f8:	e58db030 	str	r11, [r13, #48]	; 0x30
8f6184fc:	e3483f70 	movt	r3, #36720	; 0x8f70
8f618500:	e59db054 	ldr	r11, [r13, #84]	; 0x54
			dprintf(SPEW, "Found an appended flattened device tree (%s - %u %u 0x%x)\n",
8f618504:	e3488f70 	movt	r8, #36720	; 0x8f70
8f618508:	e59d9044 	ldr	r9, [r13, #68]	; 0x44
				dprintf(SPEW, "Device tree's msm_id doesn't match the board: <%u %u 0x%x> != <%u %u 0x%x>\n",
8f61850c:	e58d303c 	str	r3, [r13, #60]	; 0x3c
8f618510:	e58d7040 	str	r7, [r13, #64]	; 0x40
8f618514:	ea000016 	b	8f618574 <dev_tree_appended+0x824>
				dprintf(SPEW, "Device tree exact match the board: <%u %u 0x%x> != <%u %u 0x%x>\n",
8f618518:	e5951000 	ldr	r1, [r5]
8f61851c:	e5952004 	ldr	r2, [r5, #4]
8f618520:	e595300c 	ldr	r3, [r5, #12]
8f618524:	e58d102c 	str	r1, [r13, #44]	; 0x2c
8f618528:	e58d2028 	str	r2, [r13, #40]	; 0x28
8f61852c:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f618530:	ebffdf25 	bl	8f6101cc <board_platform_id>
8f618534:	e1a06000 	mov	r6, r0
8f618538:	ebffdf49 	bl	8f610264 <board_hardware_id>
8f61853c:	e1a07000 	mov	r7, r0
8f618540:	ebffdfb3 	bl	8f610414 <board_soc_version>
8f618544:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f618548:	e59d2028 	ldr	r2, [r13, #40]	; 0x28
8f61854c:	e59d102c 	ldr	r1, [r13, #44]	; 0x2c
8f618550:	e58d7004 	str	r7, [r13, #4]
8f618554:	e58d6000 	str	r6, [r13]
8f618558:	e58d0008 	str	r0, [r13, #8]
8f61855c:	e3050a24 	movw	r0, #23076	; 0x5a24
8f618560:	e3480f70 	movt	r0, #36720	; 0x8f70
8f618564:	eb006902 	bl	8f632974 <_dprintf>
		while (len_plat_id) {
8f618568:	e59d308c 	ldr	r3, [r13, #140]	; 0x8c
8f61856c:	e3530000 	cmp	r3, #0
8f618570:	0a000050 	beq	8f6186b8 <dev_tree_appended+0x968>
			cur_dt_entry->platform_id = fdt32_to_cpu(((const struct dt_entry_v1 *)plat_prop)->platform_id);
8f618574:	e8941002 	ldm	r4, {r1, r12}
			cur_dt_entry->pmic_rev[0] = board_pmic_target(0);
8f618578:	e3a00000 	mov	r0, #0
			cur_dt_entry->soc_rev = fdt32_to_cpu(((const struct dt_entry_v1 *)plat_prop)->soc_rev);
8f61857c:	e5942008 	ldr	r2, [r4, #8]
8f618580:	e7e7645c 	ubfx	r6, r12, #8, #8
8f618584:	e7e7e85c 	ubfx	r14, r12, #16, #8
8f618588:	e1a03c2c 	lsr	r3, r12, #24
8f61858c:	e1833c0c 	orr	r3, r3, r12, lsl #24
8f618590:	e7e7c451 	ubfx	r12, r1, #8, #8
8f618594:	e1836806 	orr	r6, r3, r6, lsl #16
8f618598:	e1a03c21 	lsr	r3, r1, #24
8f61859c:	e1833c01 	orr	r3, r3, r1, lsl #24
8f6185a0:	e7e71851 	ubfx	r1, r1, #16, #8
8f6185a4:	e183380c 	orr	r3, r3, r12, lsl #16
8f6185a8:	e186e40e 	orr	r14, r6, r14, lsl #8
8f6185ac:	e1831401 	orr	r1, r3, r1, lsl #8
8f6185b0:	e1a03c22 	lsr	r3, r2, #24
			cur_dt_entry->platform_id = fdt32_to_cpu(((const struct dt_entry_v1 *)plat_prop)->platform_id);
8f6185b4:	e5851000 	str	r1, [r5]
8f6185b8:	e7e71452 	ubfx	r1, r2, #8, #8
8f6185bc:	e1833c02 	orr	r3, r3, r2, lsl #24
8f6185c0:	e7e72852 	ubfx	r2, r2, #16, #8
8f6185c4:	e1833801 	orr	r3, r3, r1, lsl #16
			cur_dt_entry->variant_id = fdt32_to_cpu(((const struct dt_entry_v1 *)plat_prop)->variant_id);
8f6185c8:	e585e004 	str	r14, [r5, #4]
8f6185cc:	e1832402 	orr	r2, r3, r2, lsl #8
				fdt32_to_cpu(((const struct dt_entry_v1 *)plat_prop)->variant_id) >> 0x18;
8f6185d0:	e1a0ec2e 	lsr	r14, r14, #24
			cur_dt_entry->soc_rev = fdt32_to_cpu(((const struct dt_entry_v1 *)plat_prop)->soc_rev);
8f6185d4:	e585200c 	str	r2, [r5, #12]
			cur_dt_entry->board_hw_subtype =
8f6185d8:	e585e008 	str	r14, [r5, #8]
			cur_dt_entry->pmic_rev[0] = board_pmic_target(0);
8f6185dc:	ebffdf59 	bl	8f610348 <board_pmic_target>
8f6185e0:	e5850010 	str	r0, [r5, #16]
			cur_dt_entry->pmic_rev[1] = board_pmic_target(1);
8f6185e4:	e3a00001 	mov	r0, #1
8f6185e8:	ebffdf56 	bl	8f610348 <board_pmic_target>
8f6185ec:	e5850014 	str	r0, [r5, #20]
			cur_dt_entry->pmic_rev[2] = board_pmic_target(2);
8f6185f0:	e3a00002 	mov	r0, #2
8f6185f4:	ebffdf53 	bl	8f610348 <board_pmic_target>
8f6185f8:	e5850018 	str	r0, [r5, #24]
			cur_dt_entry->pmic_rev[3] = board_pmic_target(3);
8f6185fc:	e3a00003 	mov	r0, #3
8f618600:	ebffdf50 	bl	8f610348 <board_pmic_target>
			cur_dt_entry->offset = (uint32_t)dtb;
8f618604:	e59d3030 	ldr	r3, [r13, #48]	; 0x30
			dprintf(SPEW, "Found an appended flattened device tree (%s - %u %u 0x%x)\n",
8f618608:	e3590000 	cmp	r9, #0
			cur_dt_entry->size = dtb_size;
8f61860c:	e585a024 	str	r10, [r5, #36]	; 0x24
			cur_dt_entry->offset = (uint32_t)dtb;
8f618610:	e5853020 	str	r3, [r5, #32]
			cur_dt_entry->pmic_rev[3] = board_pmic_target(3);
8f618614:	e585001c 	str	r0, [r5, #28]
			dprintf(SPEW, "Found an appended flattened device tree (%s - %u %u 0x%x)\n",
8f618618:	0a00002a 	beq	8f6186c8 <dev_tree_appended+0x978>
8f61861c:	e5d93000 	ldrb	r3, [r9]
8f618620:	e59d104c 	ldr	r1, [r13, #76]	; 0x4c
8f618624:	e3530000 	cmp	r3, #0
8f618628:	11a01009 	movne	r1, r9
8f61862c:	e595300c 	ldr	r3, [r5, #12]
8f618630:	e1a00008 	mov	r0, r8
8f618634:	e58d3000 	str	r3, [r13]
8f618638:	e1c520d0 	ldrd	r2, [r5]
8f61863c:	eb0068cc 	bl	8f632974 <_dprintf>
			if (platform_dt_absolute_match(cur_dt_entry, dtb_list)) {
8f618640:	e1a0100b 	mov	r1, r11
8f618644:	e1a00005 	mov	r0, r5
8f618648:	ebfffac0 	bl	8f617150 <platform_dt_absolute_match>
8f61864c:	e3500000 	cmp	r0, #0
8f618650:	1affffb0 	bne	8f618518 <dev_tree_appended+0x7c8>
				dprintf(SPEW, "Device tree's msm_id doesn't match the board: <%u %u 0x%x> != <%u %u 0x%x>\n",
8f618654:	e5951000 	ldr	r1, [r5]
				plat_prop += DT_ENTRY_V1_SIZE;
8f618658:	e284400c 	add	r4, r4, #12
				dprintf(SPEW, "Device tree's msm_id doesn't match the board: <%u %u 0x%x> != <%u %u 0x%x>\n",
8f61865c:	e5952004 	ldr	r2, [r5, #4]
8f618660:	e595300c 	ldr	r3, [r5, #12]
8f618664:	e58d102c 	str	r1, [r13, #44]	; 0x2c
8f618668:	e58d2028 	str	r2, [r13, #40]	; 0x28
8f61866c:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f618670:	ebffded5 	bl	8f6101cc <board_platform_id>
8f618674:	e1a06000 	mov	r6, r0
8f618678:	ebffdef9 	bl	8f610264 <board_hardware_id>
8f61867c:	e1a07000 	mov	r7, r0
8f618680:	ebffdf63 	bl	8f610414 <board_soc_version>
8f618684:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f618688:	e59d2028 	ldr	r2, [r13, #40]	; 0x28
8f61868c:	e59d102c 	ldr	r1, [r13, #44]	; 0x2c
8f618690:	e58d7004 	str	r7, [r13, #4]
8f618694:	e58d6000 	str	r6, [r13]
8f618698:	e58d0008 	str	r0, [r13, #8]
8f61869c:	e59d003c 	ldr	r0, [r13, #60]	; 0x3c
8f6186a0:	eb0068b3 	bl	8f632974 <_dprintf>
				len_plat_id -= DT_ENTRY_V1_SIZE;
8f6186a4:	e59d308c 	ldr	r3, [r13, #140]	; 0x8c
8f6186a8:	e243300c 	sub	r3, r3, #12
8f6186ac:	e58d308c 	str	r3, [r13, #140]	; 0x8c
		while (len_plat_id) {
8f6186b0:	e3530000 	cmp	r3, #0
8f6186b4:	1affffae 	bne	8f618574 <dev_tree_appended+0x824>
8f6186b8:	e59d7040 	ldr	r7, [r13, #64]	; 0x40
		free(cur_dt_entry);
8f6186bc:	e1a00005 	mov	r0, r5
8f6186c0:	eb006e91 	bl	8f63410c <free>
8f6186c4:	eafffeeb 	b	8f618278 <dev_tree_appended+0x528>
			dprintf(SPEW, "Found an appended flattened device tree (%s - %u %u 0x%x)\n",
8f6186c8:	e59d104c 	ldr	r1, [r13, #76]	; 0x4c
8f6186cc:	eaffffd6 	b	8f61862c <dev_tree_appended+0x8dc>
			num_entries = msm_data_count * board_data_count;
8f6186d0:	e59d2048 	ldr	r2, [r13, #72]	; 0x48
8f6186d4:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f6186d8:	e0030392 	mul	r3, r2, r3
			num_entries = msm_data_count * board_data_count * pmic_data_count;
8f6186dc:	e59d202c 	ldr	r2, [r13, #44]	; 0x2c
			num_entries = msm_data_count * board_data_count;
8f6186e0:	e58d3060 	str	r3, [r13, #96]	; 0x60
			num_entries = msm_data_count * board_data_count * pmic_data_count;
8f6186e4:	e00e0293 	mul	r14, r3, r2
8f6186e8:	eafffeca 	b	8f618218 <dev_tree_appended+0x4c8>
			dprintf(CRITICAL, "qcom,pmic-id(%d) or qcom,board-id(%d) in device tree is not a multiple of (%d %d)\n",
8f6186ec:	e3a03008 	mov	r3, #8
8f6186f0:	e30508f8 	movw	r0, #22776	; 0x58f8
8f6186f4:	e58d3000 	str	r3, [r13]
8f6186f8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6186fc:	eb00689c 	bl	8f632974 <_dprintf>
			return false;
8f618700:	eafffee1 	b	8f61828c <dev_tree_appended+0x53c>
			dprintf(CRITICAL, "Tags addresses overlap with aboot addresses.\n");
8f618704:	e3050c7c 	movw	r0, #23676	; 0x5c7c
8f618708:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61870c:	eb006898 	bl	8f632974 <_dprintf>
			return NULL;
8f618710:	e3a05000 	mov	r5, #0
8f618714:	eaffff43 	b	8f618428 <dev_tree_appended+0x6d8>
		dprintf(INFO, "qcom,msm-id in device tree is (%d) not a multiple of (%d)\n",
8f618718:	e1a02006 	mov	r2, r6
8f61871c:	e1a01009 	mov	r1, r9
8f618720:	e30509ac 	movw	r0, #22956	; 0x59ac
8f618724:	e3480f70 	movt	r0, #36720	; 0x8f70
8f618728:	eb006891 	bl	8f632974 <_dprintf>
		return false;
8f61872c:	eafffed6 	b	8f61828c <dev_tree_appended+0x53c>
		memcpy((void*) &app_dtb_offset, (void*) (kernel + DTB_OFFSET), sizeof(uint32_t));
8f618730:	e59d306c 	ldr	r3, [r13, #108]	; 0x6c
8f618734:	e28d0080 	add	r0, r13, #128	; 0x80
8f618738:	e3a02004 	mov	r2, #4
8f61873c:	e283102c 	add	r1, r3, #44	; 0x2c
8f618740:	eb006e9c 	bl	8f6341b8 <memcpy>
	if (((uintptr_t)kernel + (uintptr_t)app_dtb_offset) < (uintptr_t)kernel) {
8f618744:	e59d4080 	ldr	r4, [r13, #128]	; 0x80
8f618748:	eafffd99 	b	8f617db4 <dev_tree_appended+0x64>
		dt_entry_array = (struct dt_entry*) malloc(sizeof(struct dt_entry) * num_entries);
8f61874c:	e59d3060 	ldr	r3, [r13, #96]	; 0x60
8f618750:	e3a00028 	mov	r0, #40	; 0x28
8f618754:	e0000390 	mul	r0, r0, r3
8f618758:	eb006e27 	bl	8f633ffc <malloc>
		ASSERT(dt_entry_array);
8f61875c:	e2503000 	subs	r3, r0, #0
8f618760:	e58d3030 	str	r3, [r13, #48]	; 0x30
8f618764:	0a00011e 	beq	8f618be4 <dev_tree_appended+0xe94>
		for (i = 0; i < msm_data_count; i++) {
8f618768:	e59d3048 	ldr	r3, [r13, #72]	; 0x48
8f61876c:	e3530000 	cmp	r3, #0
8f618770:	0a00005d 	beq	8f6188ec <dev_tree_appended+0xb9c>
8f618774:	e59d2064 	ldr	r2, [r13, #100]	; 0x64
8f618778:	e3a03000 	mov	r3, #0
8f61877c:	e59d102c 	ldr	r1, [r13, #44]	; 0x2c
8f618780:	e2829004 	add	r9, r2, #4
8f618784:	e59d203c 	ldr	r2, [r13, #60]	; 0x3c
8f618788:	e58d707c 	str	r7, [r13, #124]	; 0x7c
8f61878c:	e1a07003 	mov	r7, r3
8f618790:	e0825201 	add	r5, r2, r1, lsl #4
8f618794:	e58d305c 	str	r3, [r13, #92]	; 0x5c
			for (j = 0; j < board_data_count; j++) {
8f618798:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f61879c:	e3530000 	cmp	r3, #0
8f6187a0:	0a000049 	beq	8f6188cc <dev_tree_appended+0xb7c>
				if (dtb_ver == DEV_TREE_VERSION_V3 && pmic_prop) {
8f6187a4:	e59d3068 	ldr	r3, [r13, #104]	; 0x68
			for (j = 0; j < board_data_count; j++) {
8f6187a8:	e3a06000 	mov	r6, #0
				if (dtb_ver == DEV_TREE_VERSION_V3 && pmic_prop) {
8f6187ac:	e59d2040 	ldr	r2, [r13, #64]	; 0x40
8f6187b0:	e3520000 	cmp	r2, #0
8f6187b4:	03a03000 	moveq	r3, #0
8f6187b8:	12033001 	andne	r3, r3, #1
8f6187bc:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f6187c0:	e59d3058 	ldr	r3, [r13, #88]	; 0x58
8f6187c4:	e2834004 	add	r4, r3, #4
8f6187c8:	ea00001f 	b	8f61884c <dev_tree_appended+0xafc>
					dt_entry_array[k].platform_id = platform_data[i].platform_id;
8f6187cc:	e3a03028 	mov	r3, #40	; 0x28
8f6187d0:	e59d1030 	ldr	r1, [r13, #48]	; 0x30
8f6187d4:	e0030793 	mul	r3, r3, r7
8f6187d8:	e5192004 	ldr	r2, [r9, #-4]
					dt_entry_array[k].pmic_rev[0]= board_pmic_target(0);
8f6187dc:	e59d0024 	ldr	r0, [r13, #36]	; 0x24
					dt_entry_array[k].platform_id = platform_data[i].platform_id;
8f6187e0:	e2877001 	add	r7, r7, #1
8f6187e4:	e0818003 	add	r8, r1, r3
8f6187e8:	e7812003 	str	r2, [r1, r3]
					dt_entry_array[k].soc_rev = platform_data[i].soc_rev;
8f6187ec:	e5992000 	ldr	r2, [r9]
8f6187f0:	e588200c 	str	r2, [r8, #12]
					dt_entry_array[k].variant_id = board_data[j].variant_id;
8f6187f4:	e5142004 	ldr	r2, [r4, #-4]
8f6187f8:	e5882004 	str	r2, [r8, #4]
					dt_entry_array[k].board_hw_subtype = board_data[j].platform_subtype;
8f6187fc:	e5942000 	ldr	r2, [r4]
8f618800:	e5882008 	str	r2, [r8, #8]
					dt_entry_array[k].pmic_rev[0]= board_pmic_target(0);
8f618804:	ebffdecf 	bl	8f610348 <board_pmic_target>
8f618808:	e5880010 	str	r0, [r8, #16]
					dt_entry_array[k].pmic_rev[1]= board_pmic_target(1);
8f61880c:	e3a00001 	mov	r0, #1
8f618810:	ebffdecc 	bl	8f610348 <board_pmic_target>
8f618814:	e5880014 	str	r0, [r8, #20]
					dt_entry_array[k].pmic_rev[2]= board_pmic_target(2);
8f618818:	e3a00002 	mov	r0, #2
8f61881c:	ebffdec9 	bl	8f610348 <board_pmic_target>
8f618820:	e5880018 	str	r0, [r8, #24]
					dt_entry_array[k].pmic_rev[3]= board_pmic_target(3);
8f618824:	e3a00003 	mov	r0, #3
8f618828:	ebffdec6 	bl	8f610348 <board_pmic_target>
					dt_entry_array[k].offset = (uint32_t)dtb;
8f61882c:	e588b020 	str	r11, [r8, #32]
					dt_entry_array[k].size = dtb_size;
8f618830:	e588a024 	str	r10, [r8, #36]	; 0x24
					dt_entry_array[k].pmic_rev[3]= board_pmic_target(3);
8f618834:	e588001c 	str	r0, [r8, #28]
			for (j = 0; j < board_data_count; j++) {
8f618838:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f61883c:	e2866001 	add	r6, r6, #1
8f618840:	e2844008 	add	r4, r4, #8
8f618844:	e1530006 	cmp	r3, r6
8f618848:	0a00001f 	beq	8f6188cc <dev_tree_appended+0xb7c>
				if (dtb_ver == DEV_TREE_VERSION_V3 && pmic_prop) {
8f61884c:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f618850:	e3530000 	cmp	r3, #0
8f618854:	0affffdc 	beq	8f6187cc <dev_tree_appended+0xa7c>
					for (n = 0; n < pmic_data_count; n++) {
8f618858:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
8f61885c:	e3530000 	cmp	r3, #0
8f618860:	0afffff4 	beq	8f618838 <dev_tree_appended+0xae8>
8f618864:	e59d3030 	ldr	r3, [r13, #48]	; 0x30
8f618868:	e3a02028 	mov	r2, #40	; 0x28
						dt_entry_array[k].platform_id = platform_data[i].platform_id;
8f61886c:	e519e004 	ldr	r14, [r9, #-4]
						dt_entry_array[k].soc_rev = platform_data[i].soc_rev;
8f618870:	e599c000 	ldr	r12, [r9]
8f618874:	e0233792 	mla	r3, r2, r7, r3
						dt_entry_array[k].board_hw_subtype = board_data[j].platform_subtype;
8f618878:	e14400d4 	ldrd	r0, [r4, #-4]
8f61887c:	e59d203c 	ldr	r2, [r13, #60]	; 0x3c
						dt_entry_array[k].pmic_rev[0]= pmic_data[n].pmic_version[0];
8f618880:	e5928000 	ldr	r8, [r2]
					for (n = 0; n < pmic_data_count; n++) {
8f618884:	e2822010 	add	r2, r2, #16
						dt_entry_array[k].platform_id = platform_data[i].platform_id;
8f618888:	e583e000 	str	r14, [r3]
						dt_entry_array[k].board_hw_subtype = board_data[j].platform_subtype;
8f61888c:	e9831003 	stmib	r3, {r0, r1, r12}
					for (n = 0; n < pmic_data_count; n++) {
8f618890:	e2833028 	add	r3, r3, #40	; 0x28
						dt_entry_array[k].pmic_rev[0]= pmic_data[n].pmic_version[0];
8f618894:	e5038018 	str	r8, [r3, #-24]	; 0xffffffe8
						dt_entry_array[k].pmic_rev[1]= pmic_data[n].pmic_version[1];
8f618898:	e512800c 	ldr	r8, [r2, #-12]
						dt_entry_array[k].offset = (uint32_t)dtb;
8f61889c:	e503b008 	str	r11, [r3, #-8]
						dt_entry_array[k].size = dtb_size;
8f6188a0:	e503a004 	str	r10, [r3, #-4]
						dt_entry_array[k].pmic_rev[1]= pmic_data[n].pmic_version[1];
8f6188a4:	e5038014 	str	r8, [r3, #-20]	; 0xffffffec
						dt_entry_array[k].pmic_rev[2]= pmic_data[n].pmic_version[2];
8f6188a8:	e5128008 	ldr	r8, [r2, #-8]
8f6188ac:	e5038010 	str	r8, [r3, #-16]
						dt_entry_array[k].pmic_rev[3]= pmic_data[n].pmic_version[3];
8f6188b0:	e5128004 	ldr	r8, [r2, #-4]
					for (n = 0; n < pmic_data_count; n++) {
8f6188b4:	e1550002 	cmp	r5, r2
						dt_entry_array[k].pmic_rev[3]= pmic_data[n].pmic_version[3];
8f6188b8:	e503800c 	str	r8, [r3, #-12]
					for (n = 0; n < pmic_data_count; n++) {
8f6188bc:	1affffef 	bne	8f618880 <dev_tree_appended+0xb30>
						k++;
8f6188c0:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
8f6188c4:	e0877003 	add	r7, r7, r3
8f6188c8:	eaffffda 	b	8f618838 <dev_tree_appended+0xae8>
		for (i = 0; i < msm_data_count; i++) {
8f6188cc:	e59d305c 	ldr	r3, [r13, #92]	; 0x5c
8f6188d0:	e2899008 	add	r9, r9, #8
8f6188d4:	e59d2048 	ldr	r2, [r13, #72]	; 0x48
8f6188d8:	e2833001 	add	r3, r3, #1
8f6188dc:	e58d305c 	str	r3, [r13, #92]	; 0x5c
8f6188e0:	e1520003 	cmp	r2, r3
8f6188e4:	1affffab 	bne	8f618798 <dev_tree_appended+0xa48>
8f6188e8:	e59d707c 	ldr	r7, [r13, #124]	; 0x7c
		for (i=0 ;i < num_entries; i++) {
8f6188ec:	e59d3060 	ldr	r3, [r13, #96]	; 0x60
8f6188f0:	e3530000 	cmp	r3, #0
8f6188f4:	0a000050 	beq	8f618a3c <dev_tree_appended+0xcec>
			dprintf(SPEW, "Found an appended flattened device tree (%s - %u %u %u 0x%x)\n",
8f6188f8:	e3056aec 	movw	r6, #23276	; 0x5aec
				dprintf(SPEW, "Device tree's msm_id doesn't match the board: <%u %u %u 0x%x> != <%u %u %u 0x%x>\n",
8f6188fc:	e3053b74 	movw	r3, #23412	; 0x5b74
		for (i=0 ;i < num_entries; i++) {
8f618900:	e58d7048 	str	r7, [r13, #72]	; 0x48
				dprintf(SPEW, "Device tree's msm_id doesn't match the board: <%u %u %u 0x%x> != <%u %u %u 0x%x>\n",
8f618904:	e3483f70 	movt	r3, #36720	; 0x8f70
8f618908:	e59d4030 	ldr	r4, [r13, #48]	; 0x30
			dprintf(SPEW, "Found an appended flattened device tree (%s - %u %u %u 0x%x)\n",
8f61890c:	e3486f70 	movt	r6, #36720	; 0x8f70
		for (i=0 ;i < num_entries; i++) {
8f618910:	e59d7044 	ldr	r7, [r13, #68]	; 0x44
8f618914:	e3a05000 	mov	r5, #0
				dprintf(SPEW, "Device tree's msm_id doesn't match the board: <%u %u %u 0x%x> != <%u %u %u 0x%x>\n",
8f618918:	e58d3040 	str	r3, [r13, #64]	; 0x40
		for (i=0 ;i < num_entries; i++) {
8f61891c:	e58da05c 	str	r10, [r13, #92]	; 0x5c
8f618920:	ea000016 	b	8f618980 <dev_tree_appended+0xc30>
				dprintf(SPEW, "Device tree exact match the board: <%u %u %u 0x%x> == <%u %u %u 0x%x>\n",
8f618924:	ebffde28 	bl	8f6101cc <board_platform_id>
8f618928:	e1a08000 	mov	r8, r0
8f61892c:	ebffde4c 	bl	8f610264 <board_hardware_id>
8f618930:	e1a09000 	mov	r9, r0
8f618934:	ebffde5d 	bl	8f6102b0 <board_hardware_subtype>
8f618938:	e1a0a000 	mov	r10, r0
8f61893c:	ebffdeb4 	bl	8f610414 <board_soc_version>
8f618940:	e59d1024 	ldr	r1, [r13, #36]	; 0x24
8f618944:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f618948:	e59d202c 	ldr	r2, [r13, #44]	; 0x2c
8f61894c:	e58d1000 	str	r1, [r13]
8f618950:	e1a0100b 	mov	r1, r11
8f618954:	e58da00c 	str	r10, [r13, #12]
8f618958:	e1cd80f4 	strd	r8, [r13, #4]
8f61895c:	e58d0010 	str	r0, [r13, #16]
8f618960:	e3050b2c 	movw	r0, #23340	; 0x5b2c
8f618964:	e3480f70 	movt	r0, #36720	; 0x8f70
8f618968:	eb006801 	bl	8f632974 <_dprintf>
		for (i=0 ;i < num_entries; i++) {
8f61896c:	e59d3060 	ldr	r3, [r13, #96]	; 0x60
8f618970:	e2855001 	add	r5, r5, #1
8f618974:	e2844028 	add	r4, r4, #40	; 0x28
8f618978:	e1530005 	cmp	r3, r5
8f61897c:	0a00002c 	beq	8f618a34 <dev_tree_appended+0xce4>
			dprintf(SPEW, "Found an appended flattened device tree (%s - %u %u %u 0x%x)\n",
8f618980:	e3570000 	cmp	r7, #0
8f618984:	0a000028 	beq	8f618a2c <dev_tree_appended+0xcdc>
8f618988:	e5d73000 	ldrb	r3, [r7]
8f61898c:	e59d104c 	ldr	r1, [r13, #76]	; 0x4c
8f618990:	e3530000 	cmp	r3, #0
8f618994:	11a01007 	movne	r1, r7
8f618998:	e594300c 	ldr	r3, [r4, #12]
8f61899c:	e1a00006 	mov	r0, r6
8f6189a0:	e58d3004 	str	r3, [r13, #4]
8f6189a4:	e5943008 	ldr	r3, [r4, #8]
8f6189a8:	e58d3000 	str	r3, [r13]
8f6189ac:	e1c420d0 	ldrd	r2, [r4]
8f6189b0:	eb0067ef 	bl	8f632974 <_dprintf>
			if (platform_dt_absolute_match(&(dt_entry_array[i]), dtb_list)) {
8f6189b4:	e59d1054 	ldr	r1, [r13, #84]	; 0x54
8f6189b8:	e1a00004 	mov	r0, r4
8f6189bc:	ebfff9e3 	bl	8f617150 <platform_dt_absolute_match>
				dprintf(SPEW, "Device tree exact match the board: <%u %u %u 0x%x> == <%u %u %u 0x%x>\n",
8f6189c0:	e5942004 	ldr	r2, [r4, #4]
8f6189c4:	e594300c 	ldr	r3, [r4, #12]
8f6189c8:	e5941008 	ldr	r1, [r4, #8]
8f6189cc:	e594b000 	ldr	r11, [r4]
8f6189d0:	e58d202c 	str	r2, [r13, #44]	; 0x2c
8f6189d4:	e58d3028 	str	r3, [r13, #40]	; 0x28
8f6189d8:	e58d1024 	str	r1, [r13, #36]	; 0x24
			if (platform_dt_absolute_match(&(dt_entry_array[i]), dtb_list)) {
8f6189dc:	e3500000 	cmp	r0, #0
8f6189e0:	1affffcf 	bne	8f618924 <dev_tree_appended+0xbd4>
				dprintf(SPEW, "Device tree's msm_id doesn't match the board: <%u %u %u 0x%x> != <%u %u %u 0x%x>\n",
8f6189e4:	ebffddf8 	bl	8f6101cc <board_platform_id>
8f6189e8:	e1a08000 	mov	r8, r0
8f6189ec:	ebffde1c 	bl	8f610264 <board_hardware_id>
8f6189f0:	e1a09000 	mov	r9, r0
8f6189f4:	ebffde2d 	bl	8f6102b0 <board_hardware_subtype>
8f6189f8:	e1a0a000 	mov	r10, r0
8f6189fc:	ebffde84 	bl	8f610414 <board_soc_version>
8f618a00:	e59d1024 	ldr	r1, [r13, #36]	; 0x24
8f618a04:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f618a08:	e59d202c 	ldr	r2, [r13, #44]	; 0x2c
8f618a0c:	e58d1000 	str	r1, [r13]
8f618a10:	e1a0100b 	mov	r1, r11
8f618a14:	e58da00c 	str	r10, [r13, #12]
8f618a18:	e1cd80f4 	strd	r8, [r13, #4]
8f618a1c:	e58d0010 	str	r0, [r13, #16]
8f618a20:	e59d0040 	ldr	r0, [r13, #64]	; 0x40
8f618a24:	eb0067d2 	bl	8f632974 <_dprintf>
8f618a28:	eaffffcf 	b	8f61896c <dev_tree_appended+0xc1c>
			dprintf(SPEW, "Found an appended flattened device tree (%s - %u %u %u 0x%x)\n",
8f618a2c:	e59d104c 	ldr	r1, [r13, #76]	; 0x4c
8f618a30:	eaffffd8 	b	8f618998 <dev_tree_appended+0xc48>
8f618a34:	e59d7048 	ldr	r7, [r13, #72]	; 0x48
8f618a38:	e59da05c 	ldr	r10, [r13, #92]	; 0x5c
		free(board_data);
8f618a3c:	e59d0058 	ldr	r0, [r13, #88]	; 0x58
8f618a40:	eb006db1 	bl	8f63410c <free>
		free(platform_data);
8f618a44:	e59d0064 	ldr	r0, [r13, #100]	; 0x64
8f618a48:	eb006daf 	bl	8f63410c <free>
		if (pmic_data)
8f618a4c:	e59d303c 	ldr	r3, [r13, #60]	; 0x3c
8f618a50:	e3530000 	cmp	r3, #0
8f618a54:	0a000001 	beq	8f618a60 <dev_tree_appended+0xd10>
			free(pmic_data);
8f618a58:	e59d003c 	ldr	r0, [r13, #60]	; 0x3c
8f618a5c:	eb006daa 	bl	8f63410c <free>
		free(dt_entry_array);
8f618a60:	e59d0030 	ldr	r0, [r13, #48]	; 0x30
8f618a64:	eb006da8 	bl	8f63410c <free>
8f618a68:	eafffe02 	b	8f618278 <dev_tree_appended+0x528>
			pmic_data = (struct pmic_id *) malloc(sizeof(struct pmic_id) * (len_pmic_id / PMIC_ID_SIZE));
8f618a6c:	e59d3090 	ldr	r3, [r13, #144]	; 0x90
8f618a70:	e3530000 	cmp	r3, #0
8f618a74:	e2830007 	add	r0, r3, #7
8f618a78:	a1a00003 	movge	r0, r3
8f618a7c:	e1a001c0 	asr	r0, r0, #3
8f618a80:	e1a00200 	lsl	r0, r0, #4
8f618a84:	eb006d5c 	bl	8f633ffc <malloc>
			ASSERT(pmic_data);
8f618a88:	e2503000 	subs	r3, r0, #0
8f618a8c:	e58d303c 	str	r3, [r13, #60]	; 0x3c
8f618a90:	1afffd5e 	bne	8f618010 <dev_tree_appended+0x2c0>
8f618a94:	e59d0078 	ldr	r0, [r13, #120]	; 0x78
8f618a98:	e3053ad0 	movw	r3, #23248	; 0x5ad0
8f618a9c:	e3052754 	movw	r2, #22356	; 0x5754
8f618aa0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f618aa4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f618aa8:	e58d3000 	str	r3, [r13]
8f618aac:	e3001130 	movw	r1, #304	; 0x130
8f618ab0:	e3003376 	movw	r3, #886	; 0x376
8f618ab4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f618ab8:	eb0067ff 	bl	8f632abc <_panic>
8f618abc:	eafffd53 	b	8f618010 <dev_tree_appended+0x2c0>
		ASSERT(model);
8f618ac0:	e59d0078 	ldr	r0, [r13, #120]	; 0x78
8f618ac4:	e3052754 	movw	r2, #22356	; 0x5754
8f618ac8:	e3001130 	movw	r1, #304	; 0x130
8f618acc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f618ad0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f618ad4:	e3a03fbf 	mov	r3, #764	; 0x2fc
8f618ad8:	e58d6000 	str	r6, [r13]
8f618adc:	eb0067f6 	bl	8f632abc <_panic>
8f618ae0:	eafffe6e 	b	8f6184a0 <dev_tree_appended+0x750>
	dprintf(CRITICAL, "DTB offset is incorrect, kernel image does not have appended DTB\n");
8f618ae4:	e3050cac 	movw	r0, #23724	; 0x5cac
8f618ae8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f618aec:	eb0067a0 	bl	8f632974 <_dprintf>
	dprintf(INFO, "Device info 0x%08x/%08x/0x%08x/%u, pmic 0x%0x/0x%x/0x%x/0x%0x\n",
8f618af0:	ebffddb5 	bl	8f6101cc <board_platform_id>
8f618af4:	e1a06000 	mov	r6, r0
8f618af8:	ebffde45 	bl	8f610414 <board_soc_version>
8f618afc:	e1a07000 	mov	r7, r0
8f618b00:	ebffddc4 	bl	8f610218 <board_target_id>
8f618b04:	e1a08000 	mov	r8, r0
8f618b08:	ebffdde8 	bl	8f6102b0 <board_hardware_subtype>
8f618b0c:	e1a04000 	mov	r4, r0
8f618b10:	e1a00005 	mov	r0, r5
8f618b14:	ebffde0b 	bl	8f610348 <board_pmic_target>
8f618b18:	e1a09000 	mov	r9, r0
8f618b1c:	e3a00001 	mov	r0, #1
8f618b20:	ebffde08 	bl	8f610348 <board_pmic_target>
8f618b24:	e1a0a000 	mov	r10, r0
8f618b28:	e3a00002 	mov	r0, #2
8f618b2c:	ebffde05 	bl	8f610348 <board_pmic_target>
8f618b30:	e1a0b000 	mov	r11, r0
8f618b34:	e3a00003 	mov	r0, #3
8f618b38:	ebffde02 	bl	8f610348 <board_pmic_target>
8f618b3c:	e1a03008 	mov	r3, r8
8f618b40:	e1a02007 	mov	r2, r7
8f618b44:	e1a01006 	mov	r1, r6
8f618b48:	e58db00c 	str	r11, [r13, #12]
8f618b4c:	e98d0600 	stmib	r13, {r9, r10}
8f618b50:	e58d4000 	str	r4, [r13]
8f618b54:	e58d0010 	str	r0, [r13, #16]
8f618b58:	e3050cf0 	movw	r0, #23792	; 0x5cf0
8f618b5c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f618b60:	eb006783 	bl	8f632974 <_dprintf>
	return NULL;
8f618b64:	eafffe2f 	b	8f618428 <dev_tree_appended+0x6d8>
		ASSERT(board_data);
8f618b68:	e59d0078 	ldr	r0, [r13, #120]	; 0x78
8f618b6c:	e3053ab4 	movw	r3, #23220	; 0x5ab4
8f618b70:	e3052754 	movw	r2, #22356	; 0x5754
8f618b74:	e3483f70 	movt	r3, #36720	; 0x8f70
8f618b78:	e3482f70 	movt	r2, #36720	; 0x8f70
8f618b7c:	e58d3000 	str	r3, [r13]
8f618b80:	e3001130 	movw	r1, #304	; 0x130
8f618b84:	e3003371 	movw	r3, #881	; 0x371
8f618b88:	e3481f70 	movt	r1, #36720	; 0x8f70
8f618b8c:	eb0067ca 	bl	8f632abc <_panic>
8f618b90:	eafffd11 	b	8f617fdc <dev_tree_appended+0x28c>
		ASSERT(platform_data);
8f618b94:	e59d0078 	ldr	r0, [r13, #120]	; 0x78
8f618b98:	e3053ac0 	movw	r3, #23232	; 0x5ac0
8f618b9c:	e3052754 	movw	r2, #22356	; 0x5754
8f618ba0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f618ba4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f618ba8:	e58d3000 	str	r3, [r13]
8f618bac:	e3001130 	movw	r1, #304	; 0x130
8f618bb0:	e3003373 	movw	r3, #883	; 0x373
8f618bb4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f618bb8:	eb0067bf 	bl	8f632abc <_panic>
8f618bbc:	eafffd0f 	b	8f618000 <dev_tree_appended+0x2b0>
		dprintf(INFO, "Only one appended non-skales DTB, select it.\n");
8f618bc0:	e3050bc8 	movw	r0, #23496	; 0x5bc8
8f618bc4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f618bc8:	eb006769 	bl	8f632974 <_dprintf>
		bestmatch_tag = kernel + app_dtb_offset;
8f618bcc:	e59d306c 	ldr	r3, [r13, #108]	; 0x6c
8f618bd0:	e59d5080 	ldr	r5, [r13, #128]	; 0x80
8f618bd4:	e0835005 	add	r5, r3, r5
		bestmatch_tag_size = dtb - (kernel + app_dtb_offset);
8f618bd8:	e0473005 	sub	r3, r7, r5
8f618bdc:	e58d3074 	str	r3, [r13, #116]	; 0x74
8f618be0:	eafffdb9 	b	8f6182cc <dev_tree_appended+0x57c>
		ASSERT(dt_entry_array);
8f618be4:	e59d0078 	ldr	r0, [r13, #120]	; 0x78
8f618be8:	e3053adc 	movw	r3, #23260	; 0x5adc
8f618bec:	e3052754 	movw	r2, #22356	; 0x5754
8f618bf0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f618bf4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f618bf8:	e58d3000 	str	r3, [r13]
8f618bfc:	e3001130 	movw	r1, #304	; 0x130
8f618c00:	e3a03fee 	mov	r3, #952	; 0x3b8
8f618c04:	e3481f70 	movt	r1, #36720	; 0x8f70
8f618c08:	eb0067ab 	bl	8f632abc <_panic>
8f618c0c:	eafffed5 	b	8f618768 <dev_tree_appended+0xa18>
			dprintf(CRITICAL, "Out of memory\n");
8f618c10:	e30508b8 	movw	r0, #22712	; 0x58b8
8f618c14:	e3480f70 	movt	r0, #36720	; 0x8f70
8f618c18:	eb006755 	bl	8f632974 <_dprintf>
			return false;
8f618c1c:	eafffd9a 	b	8f61828c <dev_tree_appended+0x53c>
}
8f618c20:	eb0067e6 	bl	8f632bc0 <__stack_chk_fail>
		dprintf(CRITICAL, "Out of memory\n");
8f618c24:	e30508b8 	movw	r0, #22712	; 0x58b8
8f618c28:	e3480f70 	movt	r0, #36720	; 0x8f70
8f618c2c:	eb006750 	bl	8f632974 <_dprintf>
		return NULL;
8f618c30:	e59d5054 	ldr	r5, [r13, #84]	; 0x54
8f618c34:	eafffdfb 	b	8f618428 <dev_tree_appended+0x6d8>
8f618c38:	8f74221c 	.word	0x8f74221c

8f618c3c <dev_tree_validate>:
	if(table->magic != DEV_TREE_MAGIC) {
8f618c3c:	e590c000 	ldr	r12, [r0]
8f618c40:	e3043351 	movw	r3, #17233	; 0x4351
8f618c44:	e3453444 	movt	r3, #21572	; 0x5444
8f618c48:	e15c0003 	cmp	r12, r3
{
8f618c4c:	e59f30b4 	ldr	r3, [pc, #180]	; 8f618d08 <dev_tree_validate+0xcc>
8f618c50:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f618c54:	e24dd00c 	sub	r13, r13, #12
8f618c58:	e5933000 	ldr	r3, [r3]
8f618c5c:	e58d3004 	str	r3, [r13, #4]
8f618c60:	e3a03000 	mov	r3, #0
	if(table->magic != DEV_TREE_MAGIC) {
8f618c64:	1a00001b 	bne	8f618cd8 <dev_tree_validate+0x9c>
	if (table->version == DEV_TREE_VERSION_V1) {
8f618c68:	e5903004 	ldr	r3, [r0, #4]
8f618c6c:	e3530001 	cmp	r3, #1
8f618c70:	0a000016 	beq	8f618cd0 <dev_tree_validate+0x94>
	} else if (table->version == DEV_TREE_VERSION_V2) {
8f618c74:	e3530002 	cmp	r3, #2
8f618c78:	0a000012 	beq	8f618cc8 <dev_tree_validate+0x8c>
	} else if (table->version == DEV_TREE_VERSION_V3) {
8f618c7c:	e3530003 	cmp	r3, #3
8f618c80:	03a0c028 	moveq	r12, #40	; 0x28
8f618c84:	1a000018 	bne	8f618cec <dev_tree_validate+0xb0>
	hdr_size = (uint64_t)table->num_entries * dt_entry_size + DEV_TREE_HEADER_SIZE;
8f618c88:	e5903008 	ldr	r3, [r0, #8]
	hdr_size = ROUNDUP(hdr_size, page_size);
8f618c8c:	e281000b 	add	r0, r1, #11
8f618c90:	e2611000 	rsb	r1, r1, #0
	hdr_size = (uint64_t)table->num_entries * dt_entry_size + DEV_TREE_HEADER_SIZE;
8f618c94:	e08c3c93 	umull	r3, r12, r3, r12
	hdr_size = ROUNDUP(hdr_size, page_size);
8f618c98:	e0933000 	adds	r3, r3, r0
	return 0;
8f618c9c:	e3a00000 	mov	r0, #0
	hdr_size = ROUNDUP(hdr_size, page_size);
8f618ca0:	e0033001 	and	r3, r3, r1
		*dt_hdr_size = hdr_size & UINT_MAX;
8f618ca4:	e5823000 	str	r3, [r2]
}
8f618ca8:	e59f3058 	ldr	r3, [pc, #88]	; 8f618d08 <dev_tree_validate+0xcc>
8f618cac:	e5932000 	ldr	r2, [r3]
8f618cb0:	e59d3004 	ldr	r3, [r13, #4]
8f618cb4:	e0332002 	eors	r2, r3, r2
8f618cb8:	e3a03000 	mov	r3, #0
8f618cbc:	1a000010 	bne	8f618d04 <dev_tree_validate+0xc8>
8f618cc0:	e28dd00c 	add	r13, r13, #12
8f618cc4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f618cc8:	e3a0c018 	mov	r12, #24
8f618ccc:	eaffffed 	b	8f618c88 <dev_tree_validate+0x4c>
8f618cd0:	e3a0c014 	mov	r12, #20
8f618cd4:	eaffffeb 	b	8f618c88 <dev_tree_validate+0x4c>
		dprintf(CRITICAL, "ERROR: Bad magic in device tree table \n");
8f618cd8:	e3050d30 	movw	r0, #23856	; 0x5d30
8f618cdc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f618ce0:	eb006723 	bl	8f632974 <_dprintf>
		return -1;
8f618ce4:	e3e00000 	mvn	r0, #0
8f618ce8:	eaffffee 	b	8f618ca8 <dev_tree_validate+0x6c>
		dprintf(CRITICAL, "ERROR: Unsupported version (%d) in DT table \n",
8f618cec:	e1a01003 	mov	r1, r3
8f618cf0:	e3050d58 	movw	r0, #23896	; 0x5d58
8f618cf4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f618cf8:	eb00671d 	bl	8f632974 <_dprintf>
		return -1;
8f618cfc:	e3e00000 	mvn	r0, #0
8f618d00:	eaffffe8 	b	8f618ca8 <dev_tree_validate+0x6c>
}
8f618d04:	eb0067ad 	bl	8f632bc0 <__stack_chk_fail>
8f618d08:	8f74221c 	.word	0x8f74221c

8f618d0c <dev_tree_get_entry_info>:
 *  If a matching device tree is found, the information is returned in the
 *  "dt_entry_info" out parameter and a function value of 0 is returned, otherwise
 *  a non-zero function value is returned.
 */
int dev_tree_get_entry_info(struct dt_table *table, struct dt_entry *dt_entry_info)
{
8f618d0c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	struct dt_entry_node *dt_entry_queue = NULL;
	struct dt_entry_node *dt_node_tmp1 = NULL;
	struct dt_entry_node *dt_node_tmp2 = NULL;
	uint32_t found = 0;

	if (!dt_entry_info) {
8f618d10:	e2519000 	subs	r9, r1, #0
{
8f618d14:	e59f33f0 	ldr	r3, [pc, #1008]	; 8f61910c <dev_tree_get_entry_info+0x400>
8f618d18:	e24dd04c 	sub	r13, r13, #76	; 0x4c
8f618d1c:	e5933000 	ldr	r3, [r3]
8f618d20:	e58d3044 	str	r3, [r13, #68]	; 0x44
8f618d24:	e3a03000 	mov	r3, #0
	if (!dt_entry_info) {
8f618d28:	0a0000c2 	beq	8f619038 <dev_tree_get_entry_info+0x32c>
		dprintf(CRITICAL, "ERROR: Bad parameter passed to %s \n",
				__func__);
		return -1;
	}

	table_ptr = (unsigned char *)table + DEV_TREE_HEADER_SIZE;
8f618d2c:	e1a06000 	mov	r6, r0
	cur_dt_entry = &dt_entry_buf_1;
	best_match_dt_entry = NULL;
	dt_entry_queue = (struct dt_entry_node *)
				malloc(sizeof(struct dt_entry_node));
8f618d30:	e3a0000c 	mov	r0, #12
	table_ptr = (unsigned char *)table + DEV_TREE_HEADER_SIZE;
8f618d34:	e0864000 	add	r4, r6, r0
				malloc(sizeof(struct dt_entry_node));
8f618d38:	eb006caf 	bl	8f633ffc <malloc>

	if (!dt_entry_queue) {
8f618d3c:	e2507000 	subs	r7, r0, #0
8f618d40:	0a0000eb 	beq	8f6190f4 <dev_tree_get_entry_info+0x3e8>
		dprintf(CRITICAL, "Out of memory\n");
		return -1;
	}

	list_initialize(&dt_entry_queue->node);
	dprintf(INFO, "DTB Total entry: %d, DTB version: %d\n", table->num_entries, table->version);
8f618d44:	e5962004 	ldr	r2, [r6, #4]
8f618d48:	e3050dac 	movw	r0, #23980	; 0x5dac
8f618d4c:	e5961008 	ldr	r1, [r6, #8]
8f618d50:	e3480f70 	movt	r0, #36720	; 0x8f70
	list->prev = list->next = list;
8f618d54:	e5877004 	str	r7, [r7, #4]
8f618d58:	e5877000 	str	r7, [r7]
8f618d5c:	eb006704 	bl	8f632974 <_dprintf>
	for(i = 0; found == 0 && i < table->num_entries; i++)
8f618d60:	e5963008 	ldr	r3, [r6, #8]
8f618d64:	e3530000 	cmp	r3, #0
8f618d68:	13a08000 	movne	r8, #0
8f618d6c:	0a00003b 	beq	8f618e60 <dev_tree_get_entry_info+0x154>
	{
		memset(cur_dt_entry, 0, sizeof(struct dt_entry));
8f618d70:	e28d001c 	add	r0, r13, #28
8f618d74:	e3a02028 	mov	r2, #40	; 0x28
8f618d78:	e3a01000 	mov	r1, #0
8f618d7c:	eb006d50 	bl	8f6342c4 <memset>
		switch(table->version) {
8f618d80:	e5965004 	ldr	r5, [r6, #4]
8f618d84:	e3550002 	cmp	r5, #2
8f618d88:	0a000012 	beq	8f618dd8 <dev_tree_get_entry_info+0xcc>
8f618d8c:	e3550003 	cmp	r5, #3
8f618d90:	0a000084 	beq	8f618fa8 <dev_tree_get_entry_info+0x29c>
8f618d94:	e3550001 	cmp	r5, #1
8f618d98:	0a000068 	beq	8f618f40 <dev_tree_get_entry_info+0x234>
				cur_dt_entry->board_hw_subtype = (cur_dt_entry->variant_id >> 0x18);

			table_ptr += sizeof(struct dt_entry);
			break;
		default:
			dprintf(CRITICAL, "ERROR: Unsupported version (%d) in DT table \n",
8f618d9c:	e1a01005 	mov	r1, r5
8f618da0:	e3050d58 	movw	r0, #23896	; 0x5d58
8f618da4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f618da8:	eb0066f1 	bl	8f632974 <_dprintf>
					table->version);
			free(dt_entry_queue);
8f618dac:	e1a00007 	mov	r0, r7
8f618db0:	eb006cd5 	bl	8f63410c <free>
			return -1;
8f618db4:	e3e00000 	mvn	r0, #0
		dt_entry_list_delete(dt_node_tmp1);
		dt_node_tmp1 = dt_node_tmp2;
	}
	free(dt_entry_queue);
	return -1;
}
8f618db8:	e59f334c 	ldr	r3, [pc, #844]	; 8f61910c <dev_tree_get_entry_info+0x400>
8f618dbc:	e5932000 	ldr	r2, [r3]
8f618dc0:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f618dc4:	e0332002 	eors	r2, r3, r2
8f618dc8:	e3a03000 	mov	r3, #0
8f618dcc:	1a0000cd 	bne	8f619108 <dev_tree_get_entry_info+0x3fc>
8f618dd0:	e28dd04c 	add	r13, r13, #76	; 0x4c
8f618dd4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
			cur_dt_entry->platform_id = dt_entry_v2->platform_id;
8f618dd8:	e5942000 	ldr	r2, [r4]
			cur_dt_entry->pmic_rev[0] = board_pmic_target(0);
8f618ddc:	e3a00000 	mov	r0, #0
			if (dt_entry_v2->board_hw_subtype == 0)
8f618de0:	e5943008 	ldr	r3, [r4, #8]
			table_ptr += sizeof(struct dt_entry_v2);
8f618de4:	e2844018 	add	r4, r4, #24
			cur_dt_entry->soc_rev = dt_entry_v2->soc_rev;
8f618de8:	e514100c 	ldr	r1, [r4, #-12]
			cur_dt_entry->platform_id = dt_entry_v2->platform_id;
8f618dec:	e58d201c 	str	r2, [r13, #28]
			if (dt_entry_v2->board_hw_subtype == 0)
8f618df0:	e3530000 	cmp	r3, #0
			cur_dt_entry->variant_id = dt_entry_v2->variant_id;
8f618df4:	e5142014 	ldr	r2, [r4, #-20]	; 0xffffffec
			cur_dt_entry->soc_rev = dt_entry_v2->soc_rev;
8f618df8:	e58d1028 	str	r1, [r13, #40]	; 0x28
				cur_dt_entry->board_hw_subtype = (cur_dt_entry->variant_id >> 0x18);
8f618dfc:	01a03c22 	lsreq	r3, r2, #24
			cur_dt_entry->variant_id = dt_entry_v2->variant_id;
8f618e00:	e58d2020 	str	r2, [r13, #32]
				cur_dt_entry->board_hw_subtype = (cur_dt_entry->variant_id >> 0x18);
8f618e04:	e58d3024 	str	r3, [r13, #36]	; 0x24
			cur_dt_entry->pmic_rev[0] = board_pmic_target(0);
8f618e08:	ebffdd4e 	bl	8f610348 <board_pmic_target>
8f618e0c:	e58d002c 	str	r0, [r13, #44]	; 0x2c
			cur_dt_entry->pmic_rev[1] = board_pmic_target(1);
8f618e10:	e3a00001 	mov	r0, #1
8f618e14:	ebffdd4b 	bl	8f610348 <board_pmic_target>
8f618e18:	e58d0030 	str	r0, [r13, #48]	; 0x30
			cur_dt_entry->pmic_rev[2] = board_pmic_target(2);
8f618e1c:	e3a00002 	mov	r0, #2
8f618e20:	ebffdd48 	bl	8f610348 <board_pmic_target>
8f618e24:	e58d0034 	str	r0, [r13, #52]	; 0x34
			cur_dt_entry->pmic_rev[3] = board_pmic_target(3);
8f618e28:	e3a00003 	mov	r0, #3
8f618e2c:	ebffdd45 	bl	8f610348 <board_pmic_target>
			cur_dt_entry->offset = dt_entry_v2->offset;
8f618e30:	e5143008 	ldr	r3, [r4, #-8]
8f618e34:	e58d303c 	str	r3, [r13, #60]	; 0x3c
			cur_dt_entry->size = dt_entry_v2->size;
8f618e38:	e5143004 	ldr	r3, [r4, #-4]
8f618e3c:	e58d3040 	str	r3, [r13, #64]	; 0x40
			cur_dt_entry->pmic_rev[3] = board_pmic_target(3);
8f618e40:	e58d0038 	str	r0, [r13, #56]	; 0x38
		platform_dt_absolute_match(cur_dt_entry, dt_entry_queue);
8f618e44:	e28d001c 	add	r0, r13, #28
8f618e48:	e1a01007 	mov	r1, r7
8f618e4c:	ebfff8bf 	bl	8f617150 <platform_dt_absolute_match>
	for(i = 0; found == 0 && i < table->num_entries; i++)
8f618e50:	e5963008 	ldr	r3, [r6, #8]
8f618e54:	e2888001 	add	r8, r8, #1
8f618e58:	e1530008 	cmp	r3, r8
8f618e5c:	8affffc3 	bhi	8f618d70 <dev_tree_get_entry_info+0x64>
	best_match_dt_entry = platform_dt_match_best(dt_entry_queue);
8f618e60:	e1a00007 	mov	r0, r7
8f618e64:	ebfffb13 	bl	8f617ab8 <platform_dt_match_best>
	if (best_match_dt_entry) {
8f618e68:	e2504000 	subs	r4, r0, #0
8f618e6c:	0a000078 	beq	8f619054 <dev_tree_get_entry_info+0x348>
		*dt_entry_info = *best_match_dt_entry;
8f618e70:	e1a0c004 	mov	r12, r4
8f618e74:	e1a0e009 	mov	r14, r9
8f618e78:	e8bc000f 	ldm	r12!, {r0, r1, r2, r3}
8f618e7c:	e8ae000f 	stmia	r14!, {r0, r1, r2, r3}
		dprintf(INFO, "Using DTB entry 0x%08x/%08x/0x%08x/%u for device 0x%08x/%08x/0x%08x/%u\n",
8f618e80:	e1a06000 	mov	r6, r0
8f618e84:	e1a07003 	mov	r7, r3
8f618e88:	e1a08001 	mov	r8, r1
8f618e8c:	e1a05002 	mov	r5, r2
		*dt_entry_info = *best_match_dt_entry;
8f618e90:	e8bc000f 	ldm	r12!, {r0, r1, r2, r3}
8f618e94:	e8ae000f 	stmia	r14!, {r0, r1, r2, r3}
8f618e98:	e89c0003 	ldm	r12, {r0, r1}
8f618e9c:	e88e0003 	stm	r14, {r0, r1}
		dprintf(INFO, "Using DTB entry 0x%08x/%08x/0x%08x/%u for device 0x%08x/%08x/0x%08x/%u\n",
8f618ea0:	ebffdcc9 	bl	8f6101cc <board_platform_id>
8f618ea4:	e1a04000 	mov	r4, r0
8f618ea8:	ebffdd59 	bl	8f610414 <board_soc_version>
8f618eac:	e1a0a000 	mov	r10, r0
8f618eb0:	ebffdcd8 	bl	8f610218 <board_target_id>
8f618eb4:	e1a0b000 	mov	r11, r0
8f618eb8:	ebffdcfc 	bl	8f6102b0 <board_hardware_subtype>
8f618ebc:	e98d0410 	stmib	r13, {r4, r10}
8f618ec0:	e1a03008 	mov	r3, r8
8f618ec4:	e1a02007 	mov	r2, r7
8f618ec8:	e1a01006 	mov	r1, r6
8f618ecc:	e58db00c 	str	r11, [r13, #12]
8f618ed0:	e58d5000 	str	r5, [r13]
8f618ed4:	e58d0010 	str	r0, [r13, #16]
8f618ed8:	e3050e24 	movw	r0, #24100	; 0x5e24
8f618edc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f618ee0:	eb0066a3 	bl	8f632974 <_dprintf>
		if (dt_entry_info->pmic_rev[0] == 0 && dt_entry_info->pmic_rev[0] == 0 &&
8f618ee4:	e5994010 	ldr	r4, [r9, #16]
8f618ee8:	e3540000 	cmp	r4, #0
8f618eec:	1a000037 	bne	8f618fd0 <dev_tree_get_entry_info+0x2c4>
			dprintf(SPEW, "No maintain pmic info in DTB, device pmic info is 0x%0x/0x%x/0x%x/0x%0x\n",
8f618ef0:	e1a00004 	mov	r0, r4
8f618ef4:	ebffdd13 	bl	8f610348 <board_pmic_target>
8f618ef8:	e1a05000 	mov	r5, r0
8f618efc:	e3a00001 	mov	r0, #1
8f618f00:	ebffdd10 	bl	8f610348 <board_pmic_target>
8f618f04:	e1a06000 	mov	r6, r0
8f618f08:	e3a00002 	mov	r0, #2
8f618f0c:	ebffdd0d 	bl	8f610348 <board_pmic_target>
8f618f10:	e1a07000 	mov	r7, r0
8f618f14:	e3a00003 	mov	r0, #3
8f618f18:	ebffdd0a 	bl	8f610348 <board_pmic_target>
8f618f1c:	e1a03007 	mov	r3, r7
8f618f20:	e1a02006 	mov	r2, r6
8f618f24:	e1a01005 	mov	r1, r5
8f618f28:	e58d0000 	str	r0, [r13]
8f618f2c:	e3050e6c 	movw	r0, #24172	; 0x5e6c
8f618f30:	e3480f70 	movt	r0, #36720	; 0x8f70
8f618f34:	eb00668e 	bl	8f632974 <_dprintf>
		return 0;
8f618f38:	e1a00004 	mov	r0, r4
8f618f3c:	eaffff9d 	b	8f618db8 <dev_tree_get_entry_info+0xac>
			cur_dt_entry->variant_id = dt_entry_v1->variant_id;
8f618f40:	e5943004 	ldr	r3, [r4, #4]
			cur_dt_entry->pmic_rev[0] = board_pmic_target(0);
8f618f44:	e3a00000 	mov	r0, #0
			table_ptr += sizeof(struct dt_entry_v1);
8f618f48:	e2844014 	add	r4, r4, #20
			cur_dt_entry->variant_id = dt_entry_v1->variant_id;
8f618f4c:	e58d3020 	str	r3, [r13, #32]
			cur_dt_entry->board_hw_subtype = (dt_entry_v1->variant_id >> 0x18);
8f618f50:	e1a03c23 	lsr	r3, r3, #24
8f618f54:	e58d3024 	str	r3, [r13, #36]	; 0x24
			cur_dt_entry->platform_id = dt_entry_v1->platform_id;
8f618f58:	e5143014 	ldr	r3, [r4, #-20]	; 0xffffffec
8f618f5c:	e58d301c 	str	r3, [r13, #28]
			cur_dt_entry->soc_rev = dt_entry_v1->soc_rev;
8f618f60:	e514300c 	ldr	r3, [r4, #-12]
8f618f64:	e58d3028 	str	r3, [r13, #40]	; 0x28
			cur_dt_entry->pmic_rev[0] = board_pmic_target(0);
8f618f68:	ebffdcf6 	bl	8f610348 <board_pmic_target>
8f618f6c:	e58d002c 	str	r0, [r13, #44]	; 0x2c
			cur_dt_entry->pmic_rev[1] = board_pmic_target(1);
8f618f70:	e1a00005 	mov	r0, r5
8f618f74:	ebffdcf3 	bl	8f610348 <board_pmic_target>
8f618f78:	e58d0030 	str	r0, [r13, #48]	; 0x30
			cur_dt_entry->pmic_rev[2] = board_pmic_target(2);
8f618f7c:	e3a00002 	mov	r0, #2
8f618f80:	ebffdcf0 	bl	8f610348 <board_pmic_target>
8f618f84:	e58d0034 	str	r0, [r13, #52]	; 0x34
			cur_dt_entry->pmic_rev[3] = board_pmic_target(3);
8f618f88:	e3a00003 	mov	r0, #3
8f618f8c:	ebffdced 	bl	8f610348 <board_pmic_target>
			cur_dt_entry->offset = dt_entry_v1->offset;
8f618f90:	e5143008 	ldr	r3, [r4, #-8]
8f618f94:	e58d303c 	str	r3, [r13, #60]	; 0x3c
			cur_dt_entry->size = dt_entry_v1->size;
8f618f98:	e5143004 	ldr	r3, [r4, #-4]
8f618f9c:	e58d3040 	str	r3, [r13, #64]	; 0x40
			cur_dt_entry->pmic_rev[3] = board_pmic_target(3);
8f618fa0:	e58d0038 	str	r0, [r13, #56]	; 0x38
			break;
8f618fa4:	eaffffa6 	b	8f618e44 <dev_tree_get_entry_info+0x138>
			memcpy(cur_dt_entry, (struct dt_entry *)table_ptr,
8f618fa8:	e1a01004 	mov	r1, r4
8f618fac:	e28d001c 	add	r0, r13, #28
8f618fb0:	e3a02028 	mov	r2, #40	; 0x28
			table_ptr += sizeof(struct dt_entry);
8f618fb4:	e2844028 	add	r4, r4, #40	; 0x28
			memcpy(cur_dt_entry, (struct dt_entry *)table_ptr,
8f618fb8:	eb006c7e 	bl	8f6341b8 <memcpy>
			if (cur_dt_entry->board_hw_subtype == 0)
8f618fbc:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f618fc0:	e3530000 	cmp	r3, #0
				cur_dt_entry->board_hw_subtype = (cur_dt_entry->variant_id >> 0x18);
8f618fc4:	05dd3023 	ldrbeq	r3, [r13, #35]	; 0x23
8f618fc8:	058d3024 	streq	r3, [r13, #36]	; 0x24
			break;
8f618fcc:	eaffff9c 	b	8f618e44 <dev_tree_get_entry_info+0x138>
			dprintf(INFO, "Using pmic info 0x%0x/0x%x/0x%x/0x%0x for device 0x%0x/0x%x/0x%x/0x%0x\n",
8f618fd0:	e3a00000 	mov	r0, #0
8f618fd4:	e1c9a1d4 	ldrd	r10, [r9, #20]
8f618fd8:	e599801c 	ldr	r8, [r9, #28]
8f618fdc:	ebffdcd9 	bl	8f610348 <board_pmic_target>
8f618fe0:	e1a05000 	mov	r5, r0
8f618fe4:	e3a00001 	mov	r0, #1
8f618fe8:	ebffdcd6 	bl	8f610348 <board_pmic_target>
8f618fec:	e1a06000 	mov	r6, r0
8f618ff0:	e3a00002 	mov	r0, #2
8f618ff4:	ebffdcd3 	bl	8f610348 <board_pmic_target>
8f618ff8:	e1a07000 	mov	r7, r0
8f618ffc:	e3a00003 	mov	r0, #3
8f619000:	ebffdcd0 	bl	8f610348 <board_pmic_target>
8f619004:	e1a0300b 	mov	r3, r11
8f619008:	e1a0200a 	mov	r2, r10
8f61900c:	e1a01004 	mov	r1, r4
8f619010:	e58d700c 	str	r7, [r13, #12]
8f619014:	e58d6008 	str	r6, [r13, #8]
8f619018:	e58d5004 	str	r5, [r13, #4]
8f61901c:	e58d8000 	str	r8, [r13]
8f619020:	e58d0010 	str	r0, [r13, #16]
8f619024:	e3050c34 	movw	r0, #23604	; 0x5c34
8f619028:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61902c:	eb006650 	bl	8f632974 <_dprintf>
		return 0;
8f619030:	e3a00000 	mov	r0, #0
8f619034:	eaffff5f 	b	8f618db8 <dev_tree_get_entry_info+0xac>
		dprintf(CRITICAL, "ERROR: Bad parameter passed to %s \n",
8f619038:	e30614b0 	movw	r1, #25776	; 0x64b0
8f61903c:	e3050d88 	movw	r0, #23944	; 0x5d88
8f619040:	e3481f70 	movt	r1, #36720	; 0x8f70
8f619044:	e3480f70 	movt	r0, #36720	; 0x8f70
8f619048:	eb006649 	bl	8f632974 <_dprintf>
		return -1;
8f61904c:	e3e00000 	mvn	r0, #0
8f619050:	eaffff58 	b	8f618db8 <dev_tree_get_entry_info+0xac>
	dprintf(CRITICAL, "ERROR: Unable to find suitable device tree for device (%u/0x%08x/0x%08x/%u)\n",
8f619054:	ebffdc5c 	bl	8f6101cc <board_platform_id>
8f619058:	e1a05000 	mov	r5, r0
8f61905c:	ebffdcec 	bl	8f610414 <board_soc_version>
8f619060:	e1a06000 	mov	r6, r0
8f619064:	ebffdc6b 	bl	8f610218 <board_target_id>
8f619068:	e1a08000 	mov	r8, r0
8f61906c:	ebffdc8f 	bl	8f6102b0 <board_hardware_subtype>
8f619070:	e1a01005 	mov	r1, r5
8f619074:	e1a03008 	mov	r3, r8
8f619078:	e1a02006 	mov	r2, r6
8f61907c:	e58d0000 	str	r0, [r13]
8f619080:	e3050dd4 	movw	r0, #24020	; 0x5dd4
8f619084:	e3480f70 	movt	r0, #36720	; 0x8f70
8f619088:	eb006639 	bl	8f632974 <_dprintf>
	list_for_every_entry(&dt_entry_queue->node, dt_node_tmp1, dt_node, node) {
8f61908c:	e5975004 	ldr	r5, [r7, #4]
8f619090:	e1570005 	cmp	r7, r5
8f619094:	1a00000b 	bne	8f6190c8 <dev_tree_get_entry_info+0x3bc>
8f619098:	ea000011 	b	8f6190e4 <dev_tree_get_entry_info+0x3d8>
	item->next->prev = item->prev;
8f61909c:	e5836000 	str	r6, [r3]
			free(dt_node_member->dt_entry_m);
8f6190a0:	e5950008 	ldr	r0, [r5, #8]
	item->prev->next = item->next;
8f6190a4:	e5863004 	str	r3, [r6, #4]
	item->prev = item->next = 0;
8f6190a8:	e5854004 	str	r4, [r5, #4]
8f6190ac:	e5854000 	str	r4, [r5]
8f6190b0:	eb006c15 	bl	8f63410c <free>
			free(dt_node_member);
8f6190b4:	e1a00005 	mov	r0, r5
8f6190b8:	eb006c13 	bl	8f63410c <free>
	list_for_every_entry(&dt_entry_queue->node, dt_node_tmp1, dt_node, node) {
8f6190bc:	e5965004 	ldr	r5, [r6, #4]
8f6190c0:	e1570005 	cmp	r7, r5
8f6190c4:	0a000006 	beq	8f6190e4 <dev_tree_get_entry_info+0x3d8>
		dt_node_tmp2 = (struct dt_entry_node *) dt_node_tmp1->node.prev;
8f6190c8:	e5956000 	ldr	r6, [r5]
	if (item->prev == 0 && item->next == 0)
8f6190cc:	e5953004 	ldr	r3, [r5, #4]
8f6190d0:	e3560000 	cmp	r6, #0
8f6190d4:	1afffff0 	bne	8f61909c <dev_tree_get_entry_info+0x390>
8f6190d8:	e3530000 	cmp	r3, #0
8f6190dc:	1affffee 	bne	8f61909c <dev_tree_get_entry_info+0x390>
8f6190e0:	eafffff5 	b	8f6190bc <dev_tree_get_entry_info+0x3b0>
	free(dt_entry_queue);
8f6190e4:	e1a00007 	mov	r0, r7
8f6190e8:	eb006c07 	bl	8f63410c <free>
	return -1;
8f6190ec:	e3e00000 	mvn	r0, #0
8f6190f0:	eaffff30 	b	8f618db8 <dev_tree_get_entry_info+0xac>
		dprintf(CRITICAL, "Out of memory\n");
8f6190f4:	e30508b8 	movw	r0, #22712	; 0x58b8
8f6190f8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6190fc:	eb00661c 	bl	8f632974 <_dprintf>
		return -1;
8f619100:	e3e00000 	mvn	r0, #0
8f619104:	eaffff2b 	b	8f618db8 <dev_tree_get_entry_info+0xac>
}
8f619108:	eb0066ac 	bl	8f632bc0 <__stack_chk_fail>
8f61910c:	8f74221c 	.word	0x8f74221c

8f619110 <dev_tree_add_mem_info>:
	mem_node.size_cell_size = 1;
}

/* Function to add the subsequent RAM partition info to the device tree. */
int dev_tree_add_mem_info(void *fdt, uint32_t offset, uint64_t addr, uint64_t size)
{
8f619110:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f619114:	e1a0b003 	mov	r11, r3
8f619118:	e24dd014 	sub	r13, r13, #20
8f61911c:	e59f3418 	ldr	r3, [pc, #1048]	; 8f61953c <dev_tree_add_mem_info+0x42c>
8f619120:	e1a04001 	mov	r4, r1
8f619124:	e1a07000 	mov	r7, r0
8f619128:	e59d8038 	ldr	r8, [r13, #56]	; 0x38
8f61912c:	e5933000 	ldr	r3, [r3]
8f619130:	e58d300c 	str	r3, [r13, #12]
8f619134:	e3a03000 	mov	r3, #0
8f619138:	e59da03c 	ldr	r10, [r13, #60]	; 0x3c
8f61913c:	e1a06002 	mov	r6, r2
	int ret = 0;

	if(smem_get_ram_ptable_version() >= 1)
8f619140:	ebffa7ad 	bl	8f602ffc <smem_get_ram_ptable_version>
	mem_node->offset = mem_node_offset;
8f619144:	e30d5154 	movw	r5, #53588	; 0xd154
8f619148:	e3485f72 	movt	r5, #36722	; 0x8f72
8f61914c:	e5854000 	str	r4, [r5]
	if(smem_get_ram_ptable_version() >= 1)
8f619150:	e3500000 	cmp	r0, #0
8f619154:	1a00005f 	bne	8f6192d8 <dev_tree_add_mem_info+0x1c8>
	else
	{
		dev_tree_update_memory_node(offset);
	}

	if (!(mem_node.mem_info_cnt))
8f619158:	e5953004 	ldr	r3, [r5, #4]
8f61915c:	e28d9008 	add	r9, r13, #8
8f619160:	e3530000 	cmp	r3, #0
	mem_node.addr_cell_size = 1;
8f619164:	e3a03001 	mov	r3, #1
8f619168:	e5853008 	str	r3, [r5, #8]
	mem_node.size_cell_size = 1;
8f61916c:	e585300c 	str	r3, [r5, #12]
	if (!(mem_node.mem_info_cnt))
8f619170:	0a00002d 	beq	8f61922c <dev_tree_add_mem_info+0x11c>
8f619174:	e7e73456 	ubfx	r3, r6, #8, #8
8f619178:	e1a02c26 	lsr	r2, r6, #24
8f61917c:	e1822c06 	orr	r2, r2, r6, lsl #24
8f619180:	e7e76856 	ubfx	r6, r6, #16, #8
8f619184:	e1822803 	orr	r2, r2, r3, lsl #16
 */
static inline int fdt_appendprop_u32(void *fdt, int nodeoffset,
				     const char *name, uint32_t val)
{
	val = cpu_to_fdt32(val);
	return fdt_appendprop(fdt, nodeoffset, name, &val, sizeof(val));
8f619188:	e1a01004 	mov	r1, r4
8f61918c:	e1826406 	orr	r6, r2, r6, lsl #8
8f619190:	e3a03004 	mov	r3, #4
8f619194:	e3052eb8 	movw	r2, #24248	; 0x5eb8
8f619198:	e58d3000 	str	r3, [r13]
8f61919c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6191a0:	e1a03009 	mov	r3, r9
8f6191a4:	e1a00007 	mov	r0, r7
	val = cpu_to_fdt32(val);
8f6191a8:	e58d6008 	str	r6, [r13, #8]
	return fdt_appendprop(fdt, nodeoffset, name, &val, sizeof(val));
8f6191ac:	eb00745f 	bl	8f636330 <fdt_appendprop>
				return ret;
			}
		}

		ret = fdt_appendprop_u32(fdt, mem_node.offset, "reg", (uint32_t)addr);
		if(ret)
8f6191b0:	e2504000 	subs	r4, r0, #0
8f6191b4:	1a000043 	bne	8f6192c8 <dev_tree_add_mem_info+0x1b8>
			dprintf(CRITICAL, "ERROR: Could not append prop reg for memory node\n");
			return ret;
		}
	}

	if(mem_node.size_cell_size == 2)
8f6191b8:	e595300c 	ldr	r3, [r5, #12]
8f6191bc:	e3530002 	cmp	r3, #2
8f6191c0:	0a00002f 	beq	8f619284 <dev_tree_add_mem_info+0x174>
8f6191c4:	e7e72458 	ubfx	r2, r8, #8, #8
8f6191c8:	e1a0cc28 	lsr	r12, r8, #24
8f6191cc:	e18ccc08 	orr	r12, r12, r8, lsl #24
8f6191d0:	e7e78858 	ubfx	r8, r8, #16, #8
8f6191d4:	e18cc802 	orr	r12, r12, r2, lsl #16
8f6191d8:	e5951000 	ldr	r1, [r5]
8f6191dc:	e3a02004 	mov	r2, #4
8f6191e0:	e1a03009 	mov	r3, r9
8f6191e4:	e58d2000 	str	r2, [r13]
8f6191e8:	e1a00007 	mov	r0, r7
8f6191ec:	e3052eb8 	movw	r2, #24248	; 0x5eb8
8f6191f0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6191f4:	e18cc408 	orr	r12, r12, r8, lsl #8
	val = cpu_to_fdt32(val);
8f6191f8:	e58dc008 	str	r12, [r13, #8]
	return fdt_appendprop(fdt, nodeoffset, name, &val, sizeof(val));
8f6191fc:	eb00744b 	bl	8f636330 <fdt_appendprop>
		}
	}

	ret = fdt_appendprop_u32(fdt, mem_node.offset, "reg", (uint32_t)size);

	if (ret)
8f619200:	e2504000 	subs	r4, r0, #0
8f619204:	1a000090 	bne	8f61944c <dev_tree_add_mem_info+0x33c>
				ret);
		return ret;
	}

	return ret;
}
8f619208:	e59f332c 	ldr	r3, [pc, #812]	; 8f61953c <dev_tree_add_mem_info+0x42c>
8f61920c:	e5932000 	ldr	r2, [r3]
8f619210:	e59d300c 	ldr	r3, [r13, #12]
8f619214:	e0332002 	eors	r2, r3, r2
8f619218:	e3a03000 	mov	r3, #0
8f61921c:	1a0000c5 	bne	8f619538 <dev_tree_add_mem_info+0x428>
8f619220:	e1a00004 	mov	r0, r4
8f619224:	e28dd014 	add	r13, r13, #20
8f619228:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
8f61922c:	e7e72456 	ubfx	r2, r6, #8, #8
8f619230:	e1a03c26 	lsr	r3, r6, #24
8f619234:	e1833c06 	orr	r3, r3, r6, lsl #24
8f619238:	e7e76856 	ubfx	r6, r6, #16, #8
8f61923c:	e1833802 	orr	r3, r3, r2, lsl #16
	return fdt_setprop(fdt, nodeoffset, name, &val, sizeof(val));
8f619240:	e5951000 	ldr	r1, [r5]
8f619244:	e1836406 	orr	r6, r3, r6, lsl #8
8f619248:	e3052eb8 	movw	r2, #24248	; 0x5eb8
8f61924c:	e3a03004 	mov	r3, #4
8f619250:	e3482f70 	movt	r2, #36720	; 0x8f70
8f619254:	e58d3000 	str	r3, [r13]
8f619258:	e1a00007 	mov	r0, r7
8f61925c:	e1a03009 	mov	r3, r9
	val = cpu_to_fdt32(val);
8f619260:	e58d6008 	str	r6, [r13, #8]
	return fdt_setprop(fdt, nodeoffset, name, &val, sizeof(val));
8f619264:	eb0073e3 	bl	8f6361f8 <fdt_setprop>
			if(ret)
8f619268:	e2504000 	subs	r4, r0, #0
8f61926c:	1a000091 	bne	8f6194b8 <dev_tree_add_mem_info+0x3a8>
		mem_node.mem_info_cnt = 1;
8f619270:	e3a03001 	mov	r3, #1
8f619274:	e5853004 	str	r3, [r5, #4]
	if(mem_node.size_cell_size == 2)
8f619278:	e595300c 	ldr	r3, [r5, #12]
8f61927c:	e3530002 	cmp	r3, #2
8f619280:	1affffcf 	bne	8f6191c4 <dev_tree_add_mem_info+0xb4>
8f619284:	e7e7245a 	ubfx	r2, r10, #8, #8
8f619288:	e1a03c2a 	lsr	r3, r10, #24
8f61928c:	e1833c0a 	orr	r3, r3, r10, lsl #24
8f619290:	e7e7a85a 	ubfx	r10, r10, #16, #8
8f619294:	e1833802 	orr	r3, r3, r2, lsl #16
	return fdt_appendprop(fdt, nodeoffset, name, &val, sizeof(val));
8f619298:	e5951000 	ldr	r1, [r5]
8f61929c:	e183a40a 	orr	r10, r3, r10, lsl #8
8f6192a0:	e3052eb8 	movw	r2, #24248	; 0x5eb8
8f6192a4:	e3a03004 	mov	r3, #4
8f6192a8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6192ac:	e58d3000 	str	r3, [r13]
8f6192b0:	e1a00007 	mov	r0, r7
8f6192b4:	e1a03009 	mov	r3, r9
	val = cpu_to_fdt32(val);
8f6192b8:	e58da008 	str	r10, [r13, #8]
	return fdt_appendprop(fdt, nodeoffset, name, &val, sizeof(val));
8f6192bc:	eb00741b 	bl	8f636330 <fdt_appendprop>
		if(ret)
8f6192c0:	e2504000 	subs	r4, r0, #0
8f6192c4:	0affffbe 	beq	8f6191c4 <dev_tree_add_mem_info+0xb4>
			dprintf(CRITICAL, "ERROR: Could not append prop reg for memory node\n");
8f6192c8:	e3060068 	movw	r0, #24680	; 0x6068
8f6192cc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6192d0:	eb0065a7 	bl	8f632974 <_dprintf>
			return ret;
8f6192d4:	eaffffcb 	b	8f619208 <dev_tree_add_mem_info+0xf8>
	ret = fdt_path_offset(fdt, "/");
8f6192d8:	e30a1a5c 	movw	r1, #43612	; 0xaa5c
8f6192dc:	e1a00007 	mov	r0, r7
8f6192e0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6192e4:	eb00711a 	bl	8f635754 <fdt_path_offset>
	if (ret < 0)
8f6192e8:	e2504000 	subs	r4, r0, #0
8f6192ec:	ba000075 	blt	8f6194c8 <dev_tree_add_mem_info+0x3b8>
	valp = (uint32_t*)fdt_getprop(fdt, offset, "#address-cells", &len);
8f6192f0:	e28d9008 	add	r9, r13, #8
8f6192f4:	e3052f3c 	movw	r2, #24380	; 0x5f3c
8f6192f8:	e1a01004 	mov	r1, r4
8f6192fc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f619300:	e1a03009 	mov	r3, r9
8f619304:	e1a00007 	mov	r0, r7
8f619308:	eb007188 	bl	8f635930 <fdt_getprop>
	if (len <= 0 || !valp)
8f61930c:	e59d3008 	ldr	r3, [r13, #8]
8f619310:	e3530000 	cmp	r3, #0
8f619314:	da000044 	ble	8f61942c <dev_tree_add_mem_info+0x31c>
8f619318:	e3500000 	cmp	r0, #0
8f61931c:	0a000071 	beq	8f6194e8 <dev_tree_add_mem_info+0x3d8>
		mem_node->addr_cell_size = fdt32_to_cpu(*valp);
8f619320:	e5902000 	ldr	r2, [r0]
8f619324:	e7e70452 	ubfx	r0, r2, #8, #8
8f619328:	e7e71852 	ubfx	r1, r2, #16, #8
8f61932c:	e1a03c22 	lsr	r3, r2, #24
8f619330:	e1833c02 	orr	r3, r3, r2, lsl #24
8f619334:	e1833800 	orr	r3, r3, r0, lsl #16
8f619338:	e1833401 	orr	r3, r3, r1, lsl #8
8f61933c:	e5853008 	str	r3, [r5, #8]
	valp = (uint32_t*)fdt_getprop(fdt, offset, "#size-cells", &len);
8f619340:	e1a03009 	mov	r3, r9
8f619344:	e1a01004 	mov	r1, r4
8f619348:	e3052f9c 	movw	r2, #24476	; 0x5f9c
8f61934c:	e1a00007 	mov	r0, r7
8f619350:	e3482f70 	movt	r2, #36720	; 0x8f70
8f619354:	eb007175 	bl	8f635930 <fdt_getprop>
	if (len <= 0 || !valp)
8f619358:	e59d3008 	ldr	r3, [r13, #8]
8f61935c:	e3530000 	cmp	r3, #0
8f619360:	da000067 	ble	8f619504 <dev_tree_add_mem_info+0x3f4>
8f619364:	e3500000 	cmp	r0, #0
8f619368:	0a00006d 	beq	8f619524 <dev_tree_add_mem_info+0x414>
		mem_node->size_cell_size = fdt32_to_cpu(*valp);
8f61936c:	e5902000 	ldr	r2, [r0]
8f619370:	e7e70452 	ubfx	r0, r2, #8, #8
8f619374:	e7e71852 	ubfx	r1, r2, #16, #8
8f619378:	e1a03c22 	lsr	r3, r2, #24
8f61937c:	e1833c02 	orr	r3, r3, r2, lsl #24
8f619380:	e1833800 	orr	r3, r3, r0, lsl #16
8f619384:	e1833401 	orr	r3, r3, r1, lsl #8
8f619388:	e585300c 	str	r3, [r5, #12]
	if (!(mem_node.mem_info_cnt))
8f61938c:	e5953004 	ldr	r3, [r5, #4]
8f619390:	e3530000 	cmp	r3, #0
		if(mem_node.addr_cell_size == 2)
8f619394:	e5953008 	ldr	r3, [r5, #8]
	if (!(mem_node.mem_info_cnt))
8f619398:	1a000030 	bne	8f619460 <dev_tree_add_mem_info+0x350>
		if(mem_node.addr_cell_size == 2)
8f61939c:	e3530002 	cmp	r3, #2
8f6193a0:	1affffa1 	bne	8f61922c <dev_tree_add_mem_info+0x11c>
8f6193a4:	e7e7345b 	ubfx	r3, r11, #8, #8
8f6193a8:	e1a02c2b 	lsr	r2, r11, #24
8f6193ac:	e1822c0b 	orr	r2, r2, r11, lsl #24
8f6193b0:	e7e7b85b 	ubfx	r11, r11, #16, #8
8f6193b4:	e1822803 	orr	r2, r2, r3, lsl #16
	return fdt_setprop(fdt, nodeoffset, name, &val, sizeof(val));
8f6193b8:	e5951000 	ldr	r1, [r5]
8f6193bc:	e182b40b 	orr	r11, r2, r11, lsl #8
8f6193c0:	e1a03009 	mov	r3, r9
	val = cpu_to_fdt32(val);
8f6193c4:	e58db008 	str	r11, [r13, #8]
	return fdt_setprop(fdt, nodeoffset, name, &val, sizeof(val));
8f6193c8:	e3052eb8 	movw	r2, #24248	; 0x5eb8
8f6193cc:	e3a0b004 	mov	r11, #4
8f6193d0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6193d4:	e1a00007 	mov	r0, r7
8f6193d8:	e58db000 	str	r11, [r13]
8f6193dc:	eb007385 	bl	8f6361f8 <fdt_setprop>
			if(ret)
8f6193e0:	e2504000 	subs	r4, r0, #0
8f6193e4:	1a000033 	bne	8f6194b8 <dev_tree_add_mem_info+0x3a8>
8f6193e8:	e7e72456 	ubfx	r2, r6, #8, #8
8f6193ec:	e1a03c26 	lsr	r3, r6, #24
8f6193f0:	e1833c06 	orr	r3, r3, r6, lsl #24
8f6193f4:	e7e76856 	ubfx	r6, r6, #16, #8
8f6193f8:	e1833802 	orr	r3, r3, r2, lsl #16
	return fdt_appendprop(fdt, nodeoffset, name, &val, sizeof(val));
8f6193fc:	e5951000 	ldr	r1, [r5]
8f619400:	e1836406 	orr	r6, r3, r6, lsl #8
8f619404:	e3052eb8 	movw	r2, #24248	; 0x5eb8
8f619408:	e1a03009 	mov	r3, r9
8f61940c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f619410:	e1a00007 	mov	r0, r7
8f619414:	e58db000 	str	r11, [r13]
	val = cpu_to_fdt32(val);
8f619418:	e58d6008 	str	r6, [r13, #8]
	return fdt_appendprop(fdt, nodeoffset, name, &val, sizeof(val));
8f61941c:	eb0073c3 	bl	8f636330 <fdt_appendprop>
			if(ret)
8f619420:	e2504000 	subs	r4, r0, #0
8f619424:	0affff91 	beq	8f619270 <dev_tree_add_mem_info+0x160>
8f619428:	eaffffa6 	b	8f6192c8 <dev_tree_add_mem_info+0x1b8>
		if (len == -FDT_ERR_NOTFOUND)
8f61942c:	e3730001 	cmn	r3, #1
8f619430:	1a00002c 	bne	8f6194e8 <dev_tree_add_mem_info+0x3d8>
			mem_node->addr_cell_size = 2;
8f619434:	e3a01002 	mov	r1, #2
			dprintf(CRITICAL, "Using default #addr_cell_size: %u\n", mem_node->addr_cell_size);
8f619438:	e3050f4c 	movw	r0, #24396	; 0x5f4c
8f61943c:	e3480f70 	movt	r0, #36720	; 0x8f70
			mem_node->addr_cell_size = 2;
8f619440:	e5851008 	str	r1, [r5, #8]
			dprintf(CRITICAL, "Using default #addr_cell_size: %u\n", mem_node->addr_cell_size);
8f619444:	eb00654a 	bl	8f632974 <_dprintf>
8f619448:	eaffffbc 	b	8f619340 <dev_tree_add_mem_info+0x230>
		dprintf(CRITICAL, "Failed to add the memory information size: %d\n",
8f61944c:	e3050eec 	movw	r0, #24300	; 0x5eec
8f619450:	e1a01004 	mov	r1, r4
8f619454:	e3480f70 	movt	r0, #36720	; 0x8f70
8f619458:	eb006545 	bl	8f632974 <_dprintf>
		return ret;
8f61945c:	eaffff69 	b	8f619208 <dev_tree_add_mem_info+0xf8>
		if(mem_node.addr_cell_size == 2)
8f619460:	e3530002 	cmp	r3, #2
			ret = fdt_setprop_u32(fdt, mem_node.offset, "reg", (uint32_t)addr);
8f619464:	e5954000 	ldr	r4, [r5]
		if(mem_node.addr_cell_size == 2)
8f619468:	1affff41 	bne	8f619174 <dev_tree_add_mem_info+0x64>
8f61946c:	e7e7245b 	ubfx	r2, r11, #8, #8
8f619470:	e1a03c2b 	lsr	r3, r11, #24
8f619474:	e1833c0b 	orr	r3, r3, r11, lsl #24
8f619478:	e7e7b85b 	ubfx	r11, r11, #16, #8
8f61947c:	e1833802 	orr	r3, r3, r2, lsl #16
8f619480:	e1a01004 	mov	r1, r4
8f619484:	e183b40b 	orr	r11, r3, r11, lsl #8
8f619488:	e3052eb8 	movw	r2, #24248	; 0x5eb8
8f61948c:	e3a03004 	mov	r3, #4
8f619490:	e3482f70 	movt	r2, #36720	; 0x8f70
8f619494:	e58d3000 	str	r3, [r13]
8f619498:	e1a00007 	mov	r0, r7
8f61949c:	e1a03009 	mov	r3, r9
	val = cpu_to_fdt32(val);
8f6194a0:	e58db008 	str	r11, [r13, #8]
	return fdt_appendprop(fdt, nodeoffset, name, &val, sizeof(val));
8f6194a4:	eb0073a1 	bl	8f636330 <fdt_appendprop>
			if(ret)
8f6194a8:	e2504000 	subs	r4, r0, #0
8f6194ac:	1affff85 	bne	8f6192c8 <dev_tree_add_mem_info+0x1b8>
		ret = fdt_appendprop_u32(fdt, mem_node.offset, "reg", (uint32_t)addr);
8f6194b0:	e5954000 	ldr	r4, [r5]
8f6194b4:	eaffff2e 	b	8f619174 <dev_tree_add_mem_info+0x64>
				dprintf(CRITICAL, "ERROR: Could not set prop reg for memory node\n");
8f6194b8:	e3060038 	movw	r0, #24632	; 0x6038
8f6194bc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6194c0:	eb00652b 	bl	8f632974 <_dprintf>
				return ret;
8f6194c4:	eaffff4f 	b	8f619208 <dev_tree_add_mem_info+0xf8>
		dprintf(CRITICAL, "Could not find memory node.\n");
8f6194c8:	e3050f1c 	movw	r0, #24348	; 0x5f1c
8f6194cc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6194d0:	eb006527 	bl	8f632974 <_dprintf>
			dprintf(CRITICAL, "Could not find #address-cells and #size-cells properties: ret %d\n", ret);
8f6194d4:	e1a01004 	mov	r1, r4
8f6194d8:	e3050ff4 	movw	r0, #24564	; 0x5ff4
8f6194dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6194e0:	eb006523 	bl	8f632974 <_dprintf>
			return ret;
8f6194e4:	eaffff47 	b	8f619208 <dev_tree_add_mem_info+0xf8>
			dprintf(CRITICAL, "Error finding the #address-cells property\n");
8f6194e8:	e3050f70 	movw	r0, #24432	; 0x5f70
8f6194ec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6194f0:	eb00651f 	bl	8f632974 <_dprintf>
			return len;
8f6194f4:	e59d4008 	ldr	r4, [r13, #8]
		if (ret < 0)
8f6194f8:	e3540000 	cmp	r4, #0
8f6194fc:	aaffffa2 	bge	8f61938c <dev_tree_add_mem_info+0x27c>
8f619500:	eafffff3 	b	8f6194d4 <dev_tree_add_mem_info+0x3c4>
		if (len == -FDT_ERR_NOTFOUND)
8f619504:	e3730001 	cmn	r3, #1
8f619508:	1a000005 	bne	8f619524 <dev_tree_add_mem_info+0x414>
			mem_node->size_cell_size = 1;
8f61950c:	e3a01001 	mov	r1, #1
			dprintf(CRITICAL, "Using default #size_cell_size: %u\n", mem_node->size_cell_size);
8f619510:	e3050fa8 	movw	r0, #24488	; 0x5fa8
8f619514:	e3480f70 	movt	r0, #36720	; 0x8f70
			mem_node->size_cell_size = 1;
8f619518:	e585100c 	str	r1, [r5, #12]
			dprintf(CRITICAL, "Using default #size_cell_size: %u\n", mem_node->size_cell_size);
8f61951c:	eb006514 	bl	8f632974 <_dprintf>
		if (ret < 0)
8f619520:	eaffff99 	b	8f61938c <dev_tree_add_mem_info+0x27c>
			dprintf(CRITICAL, "Error finding the #size-cells property\n");
8f619524:	e3050fcc 	movw	r0, #24524	; 0x5fcc
8f619528:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61952c:	eb006510 	bl	8f632974 <_dprintf>
			return len;
8f619530:	e59d4008 	ldr	r4, [r13, #8]
8f619534:	eaffffef 	b	8f6194f8 <dev_tree_add_mem_info+0x3e8>
}
8f619538:	eb0065a0 	bl	8f632bc0 <__stack_chk_fail>
8f61953c:	8f74221c 	.word	0x8f74221c

8f619540 <update_device_tree>:

/* Top level function that updates the device tree. */
int update_device_tree(void *fdt, const char *cmdline,
					   void *ramdisk, uint32_t ramdisk_size, unsigned char* mac)
{
8f619540:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
#if ENABLE_KASLRSEED_SUPPORT
	uint64_t kaslrseed;
#endif
	uint32_t cmdline_len = 0;

	if (cmdline)
8f619544:	e2516000 	subs	r6, r1, #0
{
8f619548:	e24dd024 	sub	r13, r13, #36	; 0x24
8f61954c:	e1a08003 	mov	r8, r3
8f619550:	e59f3488 	ldr	r3, [pc, #1160]	; 8f6199e0 <update_device_tree+0x4a0>
8f619554:	e1a05000 	mov	r5, r0
8f619558:	e59da048 	ldr	r10, [r13, #72]	; 0x48
8f61955c:	e1a07002 	mov	r7, r2
8f619560:	e5933000 	ldr	r3, [r3]
8f619564:	e58d301c 	str	r3, [r13, #28]
8f619568:	e3a03000 	mov	r3, #0
	uint32_t cmdline_len = 0;
8f61956c:	01a09006 	moveq	r9, r6
	if (cmdline)
8f619570:	0a000002 	beq	8f619580 <update_device_tree+0x40>
		cmdline_len = strlen(cmdline);
8f619574:	e1a00006 	mov	r0, r6
8f619578:	eb006ca2 	bl	8f634808 <strlen>
8f61957c:	e1a09000 	mov	r9, r0

	/* Check the device tree header */
	ret = fdt_check_header(fdt) || fdt_check_header_ext(fdt);
8f619580:	e1a00005 	mov	r0, r5
8f619584:	eb006da0 	bl	8f634c0c <fdt_check_header>
8f619588:	e3500000 	cmp	r0, #0
8f61958c:	1a000003 	bne	8f6195a0 <update_device_tree+0x60>
8f619590:	e1a00005 	mov	r0, r5
8f619594:	ebfff999 	bl	8f617c00 <fdt_check_header_ext>
8f619598:	e2504000 	subs	r4, r0, #0
8f61959c:	0a00000c 	beq	8f6195d4 <update_device_tree+0x94>
	if (ret)
	{
		dprintf(CRITICAL, "Invalid device tree header \n");
8f6195a0:	e306009c 	movw	r0, #24732	; 0x609c
8f6195a4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6195a8:	eb0064f1 	bl	8f632974 <_dprintf>
	ret = fdt_check_header(fdt) || fdt_check_header_ext(fdt);
8f6195ac:	e3a04001 	mov	r4, #1
#if ENABLE_PARTIAL_GOODS_SUPPORT
	update_partial_goods_dtb_nodes(fdt);
#endif

	return ret;
}
8f6195b0:	e59f3428 	ldr	r3, [pc, #1064]	; 8f6199e0 <update_device_tree+0x4a0>
8f6195b4:	e5932000 	ldr	r2, [r3]
8f6195b8:	e59d301c 	ldr	r3, [r13, #28]
8f6195bc:	e0332002 	eors	r2, r3, r2
8f6195c0:	e3a03000 	mov	r3, #0
8f6195c4:	1a000104 	bne	8f6199dc <update_device_tree+0x49c>
8f6195c8:	e1a00004 	mov	r0, r4
8f6195cc:	e28dd024 	add	r13, r13, #36	; 0x24
8f6195d0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
				(fdt_totalsize(fdt) + DTB_PAD_SIZE + cmdline_len))) {
8f6195d4:	e5953004 	ldr	r3, [r5, #4]
	if (check_aboot_addr_range_overlap((uint32_t)fdt,
8f6195d8:	e1a00005 	mov	r0, r5
8f6195dc:	e7e7c453 	ubfx	r12, r3, #8, #8
8f6195e0:	e7e72853 	ubfx	r2, r3, #16, #8
8f6195e4:	e1a01c23 	lsr	r1, r3, #24
8f6195e8:	e1811c03 	orr	r1, r1, r3, lsl #24
8f6195ec:	e181180c 	orr	r1, r1, r12, lsl #16
8f6195f0:	e1811402 	orr	r1, r1, r2, lsl #8
8f6195f4:	e2811b02 	add	r1, r1, #2048	; 0x800
8f6195f8:	e0811009 	add	r1, r1, r9
8f6195fc:	eb00357d 	bl	8f626bf8 <check_aboot_addr_range_overlap>
8f619600:	e3500000 	cmp	r0, #0
8f619604:	1a00007a 	bne	8f6197f4 <update_device_tree+0x2b4>
	ret = fdt_open_into(fdt, fdt, fdt_totalsize(fdt) + DTB_PAD_SIZE + cmdline_len);
8f619608:	e5953004 	ldr	r3, [r5, #4]
8f61960c:	e1a01005 	mov	r1, r5
8f619610:	e1a00005 	mov	r0, r5
8f619614:	e7e7e453 	ubfx	r14, r3, #8, #8
8f619618:	e7e7c853 	ubfx	r12, r3, #16, #8
8f61961c:	e1a02c23 	lsr	r2, r3, #24
8f619620:	e1822c03 	orr	r2, r2, r3, lsl #24
8f619624:	e182280e 	orr	r2, r2, r14, lsl #16
8f619628:	e182240c 	orr	r2, r2, r12, lsl #8
8f61962c:	e2822b02 	add	r2, r2, #2048	; 0x800
8f619630:	e0822009 	add	r2, r2, r9
8f619634:	eb0073dc 	bl	8f6365ac <fdt_open_into>
	if (ret!= 0)
8f619638:	e2504000 	subs	r4, r0, #0
8f61963c:	1a000067 	bne	8f6197e0 <update_device_tree+0x2a0>
	ret = fdt_path_offset(fdt, "/memory");
8f619640:	e3061118 	movw	r1, #24856	; 0x6118
8f619644:	e1a00005 	mov	r0, r5
8f619648:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61964c:	eb007040 	bl	8f635754 <fdt_path_offset>
	if (ret < 0)
8f619650:	e2504000 	subs	r4, r0, #0
8f619654:	ba00006c 	blt	8f61980c <update_device_tree+0x2cc>
	ret = target_dev_tree_mem(fdt, offset);
8f619658:	e1a01004 	mov	r1, r4
8f61965c:	e1a00005 	mov	r0, r5
8f619660:	ebff9ef8 	bl	8f601248 <target_dev_tree_mem>
	if(ret)
8f619664:	e2504000 	subs	r4, r0, #0
8f619668:	1a00006b 	bne	8f61981c <update_device_tree+0x2dc>
	ret = fdt_path_offset(fdt, "/chosen");
8f61966c:	e3061144 	movw	r1, #24900	; 0x6144
8f619670:	e1a00005 	mov	r0, r5
8f619674:	e3481f70 	movt	r1, #36720	; 0x8f70
8f619678:	eb007035 	bl	8f635754 <fdt_path_offset>
	if (ret < 0)
8f61967c:	e250b000 	subs	r11, r0, #0
8f619680:	ba00008b 	blt	8f6198b4 <update_device_tree+0x374>
	if (cmdline)
8f619684:	e3560000 	cmp	r6, #0
8f619688:	0a00005d 	beq	8f619804 <update_device_tree+0x2c4>
		ret = fdt_appendprop_string(fdt, offset, (const char*)"bootargs", (const void*)cmdline);
8f61968c:	e1a00006 	mov	r0, r6
8f619690:	eb006c5c 	bl	8f634808 <strlen>
8f619694:	e1a03006 	mov	r3, r6
8f619698:	e306216c 	movw	r2, #24940	; 0x616c
8f61969c:	e1a0100b 	mov	r1, r11
8f6196a0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6196a4:	e2800001 	add	r0, r0, #1
8f6196a8:	e58d0000 	str	r0, [r13]
8f6196ac:	e1a00005 	mov	r0, r5
8f6196b0:	eb00736c 	bl	8f636468 <fdt_appendprop_str>
		if (ret)
8f6196b4:	e2504000 	subs	r4, r0, #0
8f6196b8:	1a000086 	bne	8f6198d8 <update_device_tree+0x398>
	if (ramdisk_size) {
8f6196bc:	e3580000 	cmp	r8, #0
8f6196c0:	0a000017 	beq	8f619724 <update_device_tree+0x1e4>
	return fdt_setprop(fdt, nodeoffset, name, &val, sizeof(val));
8f6196c4:	e28d3010 	add	r3, r13, #16
8f6196c8:	e3a09004 	mov	r9, #4
8f6196cc:	e30621a8 	movw	r2, #25000	; 0x61a8
8f6196d0:	e1a0100b 	mov	r1, r11
8f6196d4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6196d8:	e1a00005 	mov	r0, r5
8f6196dc:	e58d9000 	str	r9, [r13]
8f6196e0:	e6bfcf37 	rev	r12, r7
	val = cpu_to_fdt32(val);
8f6196e4:	e58dc010 	str	r12, [r13, #16]
	return fdt_setprop(fdt, nodeoffset, name, &val, sizeof(val));
8f6196e8:	eb0072c2 	bl	8f6361f8 <fdt_setprop>
		if (ret)
8f6196ec:	e2504000 	subs	r4, r0, #0
8f6196f0:	1a000074 	bne	8f6198c8 <update_device_tree+0x388>
		ret = fdt_setprop_u32(fdt, offset, "linux,initrd-end",
8f6196f4:	e0877008 	add	r7, r7, r8
8f6196f8:	e28d3010 	add	r3, r13, #16
8f6196fc:	e1a0100b 	mov	r1, r11
8f619700:	e30621f4 	movw	r2, #25076	; 0x61f4
8f619704:	e1a00005 	mov	r0, r5
8f619708:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61970c:	e58d9000 	str	r9, [r13]
8f619710:	e6bf7f37 	rev	r7, r7
	val = cpu_to_fdt32(val);
8f619714:	e58d7010 	str	r7, [r13, #16]
	return fdt_setprop(fdt, nodeoffset, name, &val, sizeof(val));
8f619718:	eb0072b6 	bl	8f6361f8 <fdt_setprop>
		if (ret)
8f61971c:	e2504000 	subs	r4, r0, #0
8f619720:	1a00008f 	bne	8f619964 <update_device_tree+0x424>
	offset = fdt_node_offset_by_compatible(fdt, -1, "qcom,wcnss-wlan");
8f619724:	e3062240 	movw	r2, #25152	; 0x6240
8f619728:	e3e01000 	mvn	r1, #0
8f61972c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f619730:	e1a00005 	mov	r0, r5
8f619734:	eb0070db 	bl	8f635aa8 <fdt_node_offset_by_compatible>
	if (mac != NULL && offset != -FDT_ERR_NOTFOUND)
8f619738:	e35a0000 	cmp	r10, #0
8f61973c:	13700001 	cmnne	r0, #1
	offset = fdt_node_offset_by_compatible(fdt, -1, "qcom,wcnss-wlan");
8f619740:	e1a07000 	mov	r7, r0
	if (mac != NULL && offset != -FDT_ERR_NOTFOUND)
8f619744:	0a000007 	beq	8f619768 <update_device_tree+0x228>
		if (fdt_getprop(fdt, offset, "local-mac-address", NULL) == NULL)
8f619748:	e1a01000 	mov	r1, r0
8f61974c:	e3a03000 	mov	r3, #0
8f619750:	e3062250 	movw	r2, #25168	; 0x6250
8f619754:	e1a00005 	mov	r0, r5
8f619758:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61975c:	eb007073 	bl	8f635930 <fdt_getprop>
8f619760:	e3500000 	cmp	r0, #0
8f619764:	0a000082 	beq	8f619974 <update_device_tree+0x434>
	offset = fdt_node_offset_by_compatible(fdt, -1, "qcom,wcnss-bt");
8f619768:	e30622e0 	movw	r2, #25312	; 0x62e0
8f61976c:	e3e01000 	mvn	r1, #0
8f619770:	e3482f70 	movt	r2, #36720	; 0x8f70
8f619774:	e1a00005 	mov	r0, r5
8f619778:	eb0070ca 	bl	8f635aa8 <fdt_node_offset_by_compatible>
	if (offset != -FDT_ERR_NOTFOUND)
8f61977c:	e3700001 	cmn	r0, #1
	offset = fdt_node_offset_by_compatible(fdt, -1, "qcom,wcnss-bt");
8f619780:	e1a07000 	mov	r7, r0
	if (offset != -FDT_ERR_NOTFOUND)
8f619784:	0a00000f 	beq	8f6197c8 <update_device_tree+0x288>
		if (fdt_getprop(fdt, offset, "local-bd-address", NULL) == NULL)
8f619788:	e1a01000 	mov	r1, r0
8f61978c:	e3a03000 	mov	r3, #0
8f619790:	e30622f0 	movw	r2, #25328	; 0x62f0
8f619794:	e1a00005 	mov	r0, r5
8f619798:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61979c:	eb007063 	bl	8f635930 <fdt_getprop>
8f6197a0:	e3500000 	cmp	r0, #0
8f6197a4:	0a000020 	beq	8f61982c <update_device_tree+0x2ec>
		if (fdt_getprop(fdt, offset, "local-mac-address", NULL) == NULL)
8f6197a8:	e3a03000 	mov	r3, #0
8f6197ac:	e3062250 	movw	r2, #25168	; 0x6250
8f6197b0:	e1a01007 	mov	r1, r7
8f6197b4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6197b8:	e1a00005 	mov	r0, r5
8f6197bc:	eb00705b 	bl	8f635930 <fdt_getprop>
8f6197c0:	e3500000 	cmp	r0, #0
8f6197c4:	0a000047 	beq	8f6198e8 <update_device_tree+0x3a8>
	lk2nd_update_device_tree(fdt, cmdline);
8f6197c8:	e1a00005 	mov	r0, r5
8f6197cc:	e1a01006 	mov	r1, r6
8f6197d0:	eb00532e 	bl	8f62e490 <lk2nd_update_device_tree>
	fdt_pack(fdt);
8f6197d4:	e1a00005 	mov	r0, r5
8f6197d8:	eb007420 	bl	8f636860 <fdt_pack>
	return ret;
8f6197dc:	eaffff73 	b	8f6195b0 <update_device_tree+0x70>
		dprintf(CRITICAL, "Failed to move/resize dtb buffer: %d\n", ret);
8f6197e0:	e1a01004 	mov	r1, r4
8f6197e4:	e30600f0 	movw	r0, #24816	; 0x60f0
8f6197e8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6197ec:	eb006460 	bl	8f632974 <_dprintf>
		return ret;
8f6197f0:	eaffff6e 	b	8f6195b0 <update_device_tree+0x70>
		dprintf(CRITICAL, "Error: Fdt addresses overlap with aboot addresses.\n");
8f6197f4:	e30600bc 	movw	r0, #24764	; 0x60bc
8f6197f8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6197fc:	eb00645c 	bl	8f632974 <_dprintf>
		return ret;
8f619800:	eaffff6a 	b	8f6195b0 <update_device_tree+0x70>
8f619804:	e1a0400b 	mov	r4, r11
8f619808:	eaffffab 	b	8f6196bc <update_device_tree+0x17c>
		dprintf(CRITICAL, "Could not find memory node.\n");
8f61980c:	e3050f1c 	movw	r0, #24348	; 0x5f1c
8f619810:	e3480f70 	movt	r0, #36720	; 0x8f70
8f619814:	eb006456 	bl	8f632974 <_dprintf>
		return ret;
8f619818:	eaffff64 	b	8f6195b0 <update_device_tree+0x70>
		dprintf(CRITICAL, "ERROR: Cannot update memory node\n");
8f61981c:	e3060120 	movw	r0, #24864	; 0x6120
8f619820:	e3480f70 	movt	r0, #36720	; 0x8f70
8f619824:	eb006452 	bl	8f632974 <_dprintf>
		return ret;
8f619828:	eaffff60 	b	8f6195b0 <update_device_tree+0x70>
8f61982c:	e28a3006 	add	r3, r10, #6
8f619830:	e28d2014 	add	r2, r13, #20
				bdaddr[i] = mac[sizeof(bdaddr) - 1 - i];
8f619834:	e5731001 	ldrb	r1, [r3, #-1]!
			for (i = 0; i < sizeof(bdaddr); i++)
8f619838:	e153000a 	cmp	r3, r10
				bdaddr[i] = mac[sizeof(bdaddr) - 1 - i];
8f61983c:	e4c21001 	strb	r1, [r2], #1
			for (i = 0; i < sizeof(bdaddr); i++)
8f619840:	1afffffb 	bne	8f619834 <update_device_tree+0x2f4>
			dprintf(INFO, "Setting Bluetooth BD address in DT:"
8f619844:	e5dd3015 	ldrb	r3, [r13, #21]
8f619848:	e3060304 	movw	r0, #25348	; 0x6304
8f61984c:	e5dd2018 	ldrb	r2, [r13, #24]
8f619850:	e3480f70 	movt	r0, #36720	; 0x8f70
8f619854:	e5dd1019 	ldrb	r1, [r13, #25]
8f619858:	e58d3004 	str	r3, [r13, #4]
8f61985c:	e5dd3016 	ldrb	r3, [r13, #22]
8f619860:	e58d3000 	str	r3, [r13]
			bdaddr[0] ^= 0x01;
8f619864:	e5dd3014 	ldrb	r3, [r13, #20]
8f619868:	e2233001 	eor	r3, r3, #1
			dprintf(INFO, "Setting Bluetooth BD address in DT:"
8f61986c:	e58d3008 	str	r3, [r13, #8]
			bdaddr[0] ^= 0x01;
8f619870:	e5cd3014 	strb	r3, [r13, #20]
			dprintf(INFO, "Setting Bluetooth BD address in DT:"
8f619874:	e5dd3017 	ldrb	r3, [r13, #23]
8f619878:	eb00643d 	bl	8f632974 <_dprintf>
			ret = fdt_setprop(fdt, offset, "local-bd-address", bdaddr, 6);
8f61987c:	e3a02006 	mov	r2, #6
8f619880:	e28d3014 	add	r3, r13, #20
8f619884:	e58d2000 	str	r2, [r13]
8f619888:	e1a01007 	mov	r1, r7
8f61988c:	e30622f0 	movw	r2, #25328	; 0x62f0
8f619890:	e1a00005 	mov	r0, r5
8f619894:	e3482f70 	movt	r2, #36720	; 0x8f70
8f619898:	eb007256 	bl	8f6361f8 <fdt_setprop>
			if (ret) {
8f61989c:	e2504000 	subs	r4, r0, #0
8f6198a0:	0affffc0 	beq	8f6197a8 <update_device_tree+0x268>
				dprintf(CRITICAL, "ERROR: cannot set local-bd-address for \"qcom,wcnss-bt\"\n");
8f6198a4:	e3060348 	movw	r0, #25416	; 0x6348
8f6198a8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6198ac:	eb006430 	bl	8f632974 <_dprintf>
				return ret;
8f6198b0:	eaffff3e 	b	8f6195b0 <update_device_tree+0x70>
		dprintf(CRITICAL, "Could not find chosen node.\n");
8f6198b4:	e306014c 	movw	r0, #24908	; 0x614c
8f6198b8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6198bc:	eb00642c 	bl	8f632974 <_dprintf>
		return ret;
8f6198c0:	e1a0400b 	mov	r4, r11
8f6198c4:	eaffff39 	b	8f6195b0 <update_device_tree+0x70>
			dprintf(CRITICAL, "ERROR: Cannot update chosen node [linux,initrd-start]\n");
8f6198c8:	e30601bc 	movw	r0, #25020	; 0x61bc
8f6198cc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6198d0:	eb006427 	bl	8f632974 <_dprintf>
			return ret;
8f6198d4:	eaffff35 	b	8f6195b0 <update_device_tree+0x70>
			dprintf(CRITICAL, "ERROR: Cannot update chosen node [bootargs]\n");
8f6198d8:	e3060178 	movw	r0, #24952	; 0x6178
8f6198dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6198e0:	eb006423 	bl	8f632974 <_dprintf>
			return ret;
8f6198e4:	eaffff31 	b	8f6195b0 <update_device_tree+0x70>
			dprintf(INFO, "Setting BT mac address in DT: %02X:%02X:%02X:%02X:%02X:%02X\n",
8f6198e8:	e5da2004 	ldrb	r2, [r10, #4]
8f6198ec:	e3060380 	movw	r0, #25472	; 0x6380
			mac[5] = (mac[5] & 0xFE) | ((mac[5] ^ 0x1) & 0x1);
8f6198f0:	e5da3005 	ldrb	r3, [r10, #5]
			dprintf(INFO, "Setting BT mac address in DT: %02X:%02X:%02X:%02X:%02X:%02X\n",
8f6198f4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6198f8:	e58d2004 	str	r2, [r13, #4]
8f6198fc:	e5da2003 	ldrb	r2, [r10, #3]
8f619900:	e58d2000 	str	r2, [r13]
			mac[5] = (mac[5] & 0xFE) | ((mac[5] ^ 0x1) & 0x1);
8f619904:	e3c32001 	bic	r2, r3, #1
8f619908:	e1e03003 	mvn	r3, r3
8f61990c:	e2033001 	and	r3, r3, #1
8f619910:	e1833002 	orr	r3, r3, r2
8f619914:	e5ca3005 	strb	r3, [r10, #5]
			dprintf(INFO, "Setting BT mac address in DT: %02X:%02X:%02X:%02X:%02X:%02X\n",
8f619918:	e58d3008 	str	r3, [r13, #8]
8f61991c:	e5da3002 	ldrb	r3, [r10, #2]
8f619920:	e5da2001 	ldrb	r2, [r10, #1]
8f619924:	e5da1000 	ldrb	r1, [r10]
8f619928:	eb006411 	bl	8f632974 <_dprintf>
			ret = fdt_setprop(fdt, offset, "local-mac-address", mac, 6);
8f61992c:	e3a02006 	mov	r2, #6
8f619930:	e1a0300a 	mov	r3, r10
8f619934:	e58d2000 	str	r2, [r13]
8f619938:	e1a01007 	mov	r1, r7
8f61993c:	e3062250 	movw	r2, #25168	; 0x6250
8f619940:	e1a00005 	mov	r0, r5
8f619944:	e3482f70 	movt	r2, #36720	; 0x8f70
8f619948:	eb00722a 	bl	8f6361f8 <fdt_setprop>
			if (ret)
8f61994c:	e2504000 	subs	r4, r0, #0
8f619950:	0affff9c 	beq	8f6197c8 <update_device_tree+0x288>
				dprintf(CRITICAL, "ERROR: cannot set local-mac-address for \"qcom,wcnss-bt\"\n");
8f619954:	e30603c0 	movw	r0, #25536	; 0x63c0
8f619958:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61995c:	eb006404 	bl	8f632974 <_dprintf>
				return ret;
8f619960:	eaffff12 	b	8f6195b0 <update_device_tree+0x70>
			dprintf(CRITICAL, "ERROR: Cannot update chosen node [linux,initrd-end]\n");
8f619964:	e3060208 	movw	r0, #25096	; 0x6208
8f619968:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61996c:	eb006400 	bl	8f632974 <_dprintf>
			return ret;
8f619970:	eaffff0e 	b	8f6195b0 <update_device_tree+0x70>
			dprintf(INFO, "Setting WLAN mac address in DT: %02X:%02X:%02X:%02X:%02X:%02X\n",
8f619974:	e5da3005 	ldrb	r3, [r10, #5]
8f619978:	e3060264 	movw	r0, #25188	; 0x6264
8f61997c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f619980:	e58d3008 	str	r3, [r13, #8]
8f619984:	e5da3004 	ldrb	r3, [r10, #4]
8f619988:	e58d3004 	str	r3, [r13, #4]
8f61998c:	e5da3003 	ldrb	r3, [r10, #3]
8f619990:	e58d3000 	str	r3, [r13]
8f619994:	e5da3002 	ldrb	r3, [r10, #2]
8f619998:	e5da2001 	ldrb	r2, [r10, #1]
8f61999c:	e5da1000 	ldrb	r1, [r10]
8f6199a0:	eb0063f3 	bl	8f632974 <_dprintf>
			ret = fdt_setprop(fdt, offset, "local-mac-address", mac, 6);
8f6199a4:	e3a03006 	mov	r3, #6
8f6199a8:	e1a01007 	mov	r1, r7
8f6199ac:	e58d3000 	str	r3, [r13]
8f6199b0:	e3062250 	movw	r2, #25168	; 0x6250
8f6199b4:	e1a0300a 	mov	r3, r10
8f6199b8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6199bc:	e1a00005 	mov	r0, r5
8f6199c0:	eb00720c 	bl	8f6361f8 <fdt_setprop>
			if (ret)
8f6199c4:	e2504000 	subs	r4, r0, #0
8f6199c8:	0affff66 	beq	8f619768 <update_device_tree+0x228>
				dprintf(CRITICAL, "ERROR: cannot set local-mac-address for \"qcom,wcnss-wlan\"\n");
8f6199cc:	e30602a4 	movw	r0, #25252	; 0x62a4
8f6199d0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6199d4:	eb0063e6 	bl	8f632974 <_dprintf>
				return ret;
8f6199d8:	eafffef4 	b	8f6195b0 <update_device_tree+0x70>
}
8f6199dc:	eb006477 	bl	8f632bc0 <__stack_chk_fail>
8f6199e0:	8f74221c 	.word	0x8f74221c

8f6199e4 <dev_tree_check_header>:
        return ret;
}
#endif

int dev_tree_check_header(const void *fdt)
{
8f6199e4:	e59f305c 	ldr	r3, [pc, #92]	; 8f619a48 <dev_tree_check_header+0x64>
8f6199e8:	e92d4010 	push	{r4, r14}
8f6199ec:	e24dd008 	sub	r13, r13, #8
8f6199f0:	e5933000 	ldr	r3, [r3]
8f6199f4:	e58d3004 	str	r3, [r13, #4]
8f6199f8:	e3a03000 	mov	r3, #0
8f6199fc:	e1a04000 	mov	r4, r0
	return fdt_check_header(fdt) || fdt_check_header_ext(fdt);
8f619a00:	eb006c81 	bl	8f634c0c <fdt_check_header>
8f619a04:	e3500000 	cmp	r0, #0
8f619a08:	13a00001 	movne	r0, #1
8f619a0c:	0a000007 	beq	8f619a30 <dev_tree_check_header+0x4c>
}
8f619a10:	e59f3030 	ldr	r3, [pc, #48]	; 8f619a48 <dev_tree_check_header+0x64>
8f619a14:	e5932000 	ldr	r2, [r3]
8f619a18:	e59d3004 	ldr	r3, [r13, #4]
8f619a1c:	e0332002 	eors	r2, r3, r2
8f619a20:	e3a03000 	mov	r3, #0
8f619a24:	1a000006 	bne	8f619a44 <dev_tree_check_header+0x60>
8f619a28:	e28dd008 	add	r13, r13, #8
8f619a2c:	e8bd8010 	pop	{r4, r15}
	return fdt_check_header(fdt) || fdt_check_header_ext(fdt);
8f619a30:	e1a00004 	mov	r0, r4
8f619a34:	ebfff871 	bl	8f617c00 <fdt_check_header_ext>
8f619a38:	e2500000 	subs	r0, r0, #0
8f619a3c:	13a00001 	movne	r0, #1
8f619a40:	eafffff2 	b	8f619a10 <dev_tree_check_header+0x2c>
}
8f619a44:	eb00645d 	bl	8f632bc0 <__stack_chk_fail>
8f619a48:	8f74221c 	.word	0x8f74221c

8f619a4c <dev_tree_get_boot_args>:

const char *dev_tree_get_boot_args(const void *fdt)
{
8f619a4c:	e59f30e8 	ldr	r3, [pc, #232]	; 8f619b3c <dev_tree_get_boot_args+0xf0>
	int offset, len;
	const char *prop;
	char *bootargs = NULL;

	offset = fdt_path_offset(fdt, "/chosen");
8f619a50:	e3061144 	movw	r1, #24900	; 0x6144
{
8f619a54:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	offset = fdt_path_offset(fdt, "/chosen");
8f619a58:	e3481f70 	movt	r1, #36720	; 0x8f70
{
8f619a5c:	e24dd014 	sub	r13, r13, #20
8f619a60:	e1a0600e 	mov	r6, r14
8f619a64:	e5933000 	ldr	r3, [r3]
8f619a68:	e58d300c 	str	r3, [r13, #12]
8f619a6c:	e3a03000 	mov	r3, #0
8f619a70:	e1a04000 	mov	r4, r0
	offset = fdt_path_offset(fdt, "/chosen");
8f619a74:	eb006f36 	bl	8f635754 <fdt_path_offset>
	if (offset < 0) {
8f619a78:	e2501000 	subs	r1, r0, #0
8f619a7c:	ba000028 	blt	8f619b24 <dev_tree_get_boot_args+0xd8>
		dprintf(INFO, "Could not find chosen node in device tree: %d\n", offset);
		return NULL;
	}

	prop = fdt_getprop(fdt, offset, "bootargs", &len);
8f619a80:	e306716c 	movw	r7, #24940	; 0x616c
8f619a84:	e3487f70 	movt	r7, #36720	; 0x8f70
8f619a88:	e28d3008 	add	r3, r13, #8
8f619a8c:	e1a00004 	mov	r0, r4
8f619a90:	e1a02007 	mov	r2, r7
8f619a94:	eb006fa5 	bl	8f635930 <fdt_getprop>
	if (prop && len > 0) {
8f619a98:	e2505000 	subs	r5, r0, #0
8f619a9c:	0a000012 	beq	8f619aec <dev_tree_get_boot_args+0xa0>
8f619aa0:	e59d0008 	ldr	r0, [r13, #8]
8f619aa4:	e3500000 	cmp	r0, #0
8f619aa8:	da00000f 	ble	8f619aec <dev_tree_get_boot_args+0xa0>
		bootargs = (char*) malloc(sizeof(char) * len);
8f619aac:	eb006952 	bl	8f633ffc <malloc>
		ASSERT(bootargs);
8f619ab0:	e2504000 	subs	r4, r0, #0
8f619ab4:	0a000011 	beq	8f619b00 <dev_tree_get_boot_args+0xb4>
		strlcpy(bootargs, prop, len);
8f619ab8:	e59d2008 	ldr	r2, [r13, #8]
8f619abc:	e1a01005 	mov	r1, r5
8f619ac0:	e1a00004 	mov	r0, r4
8f619ac4:	eb006b19 	bl	8f634730 <strlcpy>
	} else {
		dprintf(INFO, "Boot arguments do not exist in device tree\n");
	}
	return bootargs;
}
8f619ac8:	e59f306c 	ldr	r3, [pc, #108]	; 8f619b3c <dev_tree_get_boot_args+0xf0>
8f619acc:	e5932000 	ldr	r2, [r3]
8f619ad0:	e59d300c 	ldr	r3, [r13, #12]
8f619ad4:	e0332002 	eors	r2, r3, r2
8f619ad8:	e3a03000 	mov	r3, #0
8f619adc:	1a000015 	bne	8f619b38 <dev_tree_get_boot_args+0xec>
8f619ae0:	e1a00004 	mov	r0, r4
8f619ae4:	e28dd014 	add	r13, r13, #20
8f619ae8:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		dprintf(INFO, "Boot arguments do not exist in device tree\n");
8f619aec:	e306042c 	movw	r0, #25644	; 0x642c
8f619af0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f619af4:	eb00639e 	bl	8f632974 <_dprintf>
	char *bootargs = NULL;
8f619af8:	e3a04000 	mov	r4, #0
8f619afc:	eafffff1 	b	8f619ac8 <dev_tree_get_boot_args+0x7c>
		ASSERT(bootargs);
8f619b00:	e3052754 	movw	r2, #22356	; 0x5754
8f619b04:	e300390e 	movw	r3, #2318	; 0x90e
8f619b08:	e3482f70 	movt	r2, #36720	; 0x8f70
8f619b0c:	e1a00006 	mov	r0, r6
8f619b10:	e3001130 	movw	r1, #304	; 0x130
8f619b14:	e58d7000 	str	r7, [r13]
8f619b18:	e3481f70 	movt	r1, #36720	; 0x8f70
8f619b1c:	eb0063e6 	bl	8f632abc <_panic>
8f619b20:	eaffffe4 	b	8f619ab8 <dev_tree_get_boot_args+0x6c>
		dprintf(INFO, "Could not find chosen node in device tree: %d\n", offset);
8f619b24:	e30603fc 	movw	r0, #25596	; 0x63fc
8f619b28:	e3480f70 	movt	r0, #36720	; 0x8f70
		return NULL;
8f619b2c:	e3a04000 	mov	r4, #0
		dprintf(INFO, "Could not find chosen node in device tree: %d\n", offset);
8f619b30:	eb00638f 	bl	8f632974 <_dprintf>
		return NULL;
8f619b34:	eaffffe3 	b	8f619ac8 <dev_tree_get_boot_args+0x7c>
}
8f619b38:	eb006420 	bl	8f632bc0 <__stack_chk_fail>
8f619b3c:	8f74221c 	.word	0x8f74221c

8f619b40 <dev_tree_get_board_id>:

int dev_tree_get_board_id(const void *fdt, struct board_id *board_id)
{
8f619b40:	e59f30e4 	ldr	r3, [pc, #228]	; 8f619c2c <dev_tree_get_board_id+0xec>
8f619b44:	e92d4030 	push	{r4, r5, r14}
8f619b48:	e1a04001 	mov	r4, r1
8f619b4c:	e24dd00c 	sub	r13, r13, #12
	int offset, len;
	const struct board_id *board_prop;

	offset = fdt_path_offset(fdt, "/");
8f619b50:	e30a1a5c 	movw	r1, #43612	; 0xaa5c
8f619b54:	e3481f70 	movt	r1, #36720	; 0x8f70
{
8f619b58:	e5933000 	ldr	r3, [r3]
8f619b5c:	e58d3004 	str	r3, [r13, #4]
8f619b60:	e3a03000 	mov	r3, #0
8f619b64:	e1a05000 	mov	r5, r0
	offset = fdt_path_offset(fdt, "/");
8f619b68:	eb006ef9 	bl	8f635754 <fdt_path_offset>
	if (offset < 0) {
8f619b6c:	e2501000 	subs	r1, r0, #0
8f619b70:	ba000027 	blt	8f619c14 <dev_tree_get_board_id+0xd4>
		dprintf(INFO, "Could not find root node in device tree: %d\n", offset);
		return 1;
	}

	board_prop = (const struct board_id*) fdt_getprop(fdt, offset, "qcom,board-id", &len);
8f619b74:	e1a0300d 	mov	r3, r13
8f619b78:	e30524f0 	movw	r2, #21744	; 0x54f0
8f619b7c:	e1a00005 	mov	r0, r5
8f619b80:	e3482f70 	movt	r2, #36720	; 0x8f70
8f619b84:	eb006f69 	bl	8f635930 <fdt_getprop>
	if (!board_prop || len < BOARD_ID_SIZE) {
8f619b88:	e3500000 	cmp	r0, #0
8f619b8c:	0a00001b 	beq	8f619c00 <dev_tree_get_board_id+0xc0>
8f619b90:	e59d3000 	ldr	r3, [r13]
8f619b94:	e3530007 	cmp	r3, #7
8f619b98:	da000018 	ble	8f619c00 <dev_tree_get_board_id+0xc0>
		dprintf(INFO, "No valid qcom,board-id in device tree\n");
		return 1;
	}

	board_id->variant_id = fdt32_to_cpu(board_prop->variant_id);
8f619b9c:	e5903000 	ldr	r3, [r0]
	board_id->platform_subtype = fdt32_to_cpu(board_prop->platform_subtype);
8f619ba0:	e5901004 	ldr	r1, [r0, #4]
8f619ba4:	e7e7c453 	ubfx	r12, r3, #8, #8
8f619ba8:	e7e70853 	ubfx	r0, r3, #16, #8
8f619bac:	e1a02c23 	lsr	r2, r3, #24
8f619bb0:	e1822c03 	orr	r2, r2, r3, lsl #24
8f619bb4:	e1a03c21 	lsr	r3, r1, #24
8f619bb8:	e182280c 	orr	r2, r2, r12, lsl #16
8f619bbc:	e1833c01 	orr	r3, r3, r1, lsl #24
8f619bc0:	e1822400 	orr	r2, r2, r0, lsl #8
	board_id->variant_id = fdt32_to_cpu(board_prop->variant_id);
8f619bc4:	e5842000 	str	r2, [r4]
8f619bc8:	e7e72451 	ubfx	r2, r1, #8, #8
8f619bcc:	e7e71851 	ubfx	r1, r1, #16, #8
	return 0;
8f619bd0:	e3a00000 	mov	r0, #0
8f619bd4:	e1833802 	orr	r3, r3, r2, lsl #16
8f619bd8:	e1833401 	orr	r3, r3, r1, lsl #8
	board_id->platform_subtype = fdt32_to_cpu(board_prop->platform_subtype);
8f619bdc:	e5843004 	str	r3, [r4, #4]
}
8f619be0:	e59f3044 	ldr	r3, [pc, #68]	; 8f619c2c <dev_tree_get_board_id+0xec>
8f619be4:	e5932000 	ldr	r2, [r3]
8f619be8:	e59d3004 	ldr	r3, [r13, #4]
8f619bec:	e0332002 	eors	r2, r3, r2
8f619bf0:	e3a03000 	mov	r3, #0
8f619bf4:	1a00000b 	bne	8f619c28 <dev_tree_get_board_id+0xe8>
8f619bf8:	e28dd00c 	add	r13, r13, #12
8f619bfc:	e8bd8030 	pop	{r4, r5, r15}
		dprintf(INFO, "No valid qcom,board-id in device tree\n");
8f619c00:	e3060488 	movw	r0, #25736	; 0x6488
8f619c04:	e3480f70 	movt	r0, #36720	; 0x8f70
8f619c08:	eb006359 	bl	8f632974 <_dprintf>
		return 1;
8f619c0c:	e3a00001 	mov	r0, #1
8f619c10:	eafffff2 	b	8f619be0 <dev_tree_get_board_id+0xa0>
		dprintf(INFO, "Could not find root node in device tree: %d\n", offset);
8f619c14:	e3060458 	movw	r0, #25688	; 0x6458
8f619c18:	e3480f70 	movt	r0, #36720	; 0x8f70
8f619c1c:	eb006354 	bl	8f632974 <_dprintf>
		return 1;
8f619c20:	e3a00001 	mov	r0, #1
8f619c24:	eaffffed 	b	8f619be0 <dev_tree_get_board_id+0xa0>
}
8f619c28:	eb0063e4 	bl	8f632bc0 <__stack_chk_fail>
8f619c2c:	8f74221c 	.word	0x8f74221c

8f619c30 <tlmm_set_hdrive_ctrl>:

	writel(reg_val, cfg->reg);
}

void tlmm_set_hdrive_ctrl(struct tlmm_cfgs *hdrv_cfgs, uint8_t sz)
{
8f619c30:	e59f3090 	ldr	r3, [pc, #144]	; 8f619cc8 <tlmm_set_hdrive_ctrl+0x98>
	uint8_t i;

	for (i = 0; i < sz; i++)
8f619c34:	e3510000 	cmp	r1, #0
{
8f619c38:	e92d4030 	push	{r4, r5, r14}
8f619c3c:	e24dd00c 	sub	r13, r13, #12
8f619c40:	e5933000 	ldr	r3, [r3]
8f619c44:	e58d3004 	str	r3, [r13, #4]
8f619c48:	e3a03000 	mov	r3, #0
	for (i = 0; i < sz; i++)
8f619c4c:	0a000014 	beq	8f619ca4 <tlmm_set_hdrive_ctrl+0x74>
8f619c50:	e2411001 	sub	r1, r1, #1
8f619c54:	e280300c 	add	r3, r0, #12
8f619c58:	e3a0400c 	mov	r4, #12
		cfg->reg = SDC1_HDRV_PULL_CTL;
8f619c5c:	e3a05a0a 	mov	r5, #40960	; 0xa000
8f619c60:	e6ef1071 	uxtb	r1, r1
8f619c64:	e3405110 	movt	r5, #272	; 0x110
8f619c68:	e1043184 	smlabb	r4, r4, r1, r3
	if (!cfg->reg)
8f619c6c:	e5902008 	ldr	r2, [r0, #8]
	reg_val &= ~(cfg->mask << cfg->off);
8f619c70:	e5d0e005 	ldrb	r14, [r0, #5]
	for (i = 0; i < sz; i++)
8f619c74:	e280000c 	add	r0, r0, #12
	if (!cfg->reg)
8f619c78:	e3520000 	cmp	r2, #0
	reg_val &= ~(cfg->mask << cfg->off);
8f619c7c:	e510100c 	ldr	r1, [r0, #-12]
		cfg->reg = SDC1_HDRV_PULL_CTL;
8f619c80:	05005004 	streq	r5, [r0, #-4]
8f619c84:	01a02005 	moveq	r2, r5
	reg_val |= (cfg->val << cfg->off);
8f619c88:	e550c008 	ldrb	r12, [r0, #-8]
	reg_val = readl(cfg->reg);
8f619c8c:	e5923000 	ldr	r3, [r2]
	for (i = 0; i < sz; i++)
8f619c90:	e1500004 	cmp	r0, r4
	reg_val &= ~(cfg->mask << cfg->off);
8f619c94:	e1c3311e 	bic	r3, r3, r14, lsl r1
	reg_val |= (cfg->val << cfg->off);
8f619c98:	e183311c 	orr	r3, r3, r12, lsl r1
	writel(reg_val, cfg->reg);
8f619c9c:	e5823000 	str	r3, [r2]
	for (i = 0; i < sz; i++)
8f619ca0:	1afffff1 	bne	8f619c6c <tlmm_set_hdrive_ctrl+0x3c>
		tlmm_set_pins(&hdrv_cfgs[i]);
}
8f619ca4:	e59f301c 	ldr	r3, [pc, #28]	; 8f619cc8 <tlmm_set_hdrive_ctrl+0x98>
8f619ca8:	e5932000 	ldr	r2, [r3]
8f619cac:	e59d3004 	ldr	r3, [r13, #4]
8f619cb0:	e0332002 	eors	r2, r3, r2
8f619cb4:	e3a03000 	mov	r3, #0
8f619cb8:	1a000001 	bne	8f619cc4 <tlmm_set_hdrive_ctrl+0x94>
8f619cbc:	e28dd00c 	add	r13, r13, #12
8f619cc0:	e8bd8030 	pop	{r4, r5, r15}
8f619cc4:	eb0063bd 	bl	8f632bc0 <__stack_chk_fail>
8f619cc8:	8f74221c 	.word	0x8f74221c

8f619ccc <tlmm_set_pull_ctrl>:
8f619ccc:	e59f3090 	ldr	r3, [pc, #144]	; 8f619d64 <tlmm_set_pull_ctrl+0x98>
8f619cd0:	e3510000 	cmp	r1, #0
8f619cd4:	e92d4030 	push	{r4, r5, r14}
8f619cd8:	e24dd00c 	sub	r13, r13, #12
8f619cdc:	e5933000 	ldr	r3, [r3]
8f619ce0:	e58d3004 	str	r3, [r13, #4]
8f619ce4:	e3a03000 	mov	r3, #0
8f619ce8:	0a000014 	beq	8f619d40 <tlmm_set_pull_ctrl+0x74>
8f619cec:	e2411001 	sub	r1, r1, #1
8f619cf0:	e280300c 	add	r3, r0, #12
8f619cf4:	e3a0400c 	mov	r4, #12
8f619cf8:	e3a05a0a 	mov	r5, #40960	; 0xa000
8f619cfc:	e6ef1071 	uxtb	r1, r1
8f619d00:	e3405110 	movt	r5, #272	; 0x110
8f619d04:	e1043184 	smlabb	r4, r4, r1, r3
8f619d08:	e5902008 	ldr	r2, [r0, #8]
8f619d0c:	e5d0e005 	ldrb	r14, [r0, #5]
8f619d10:	e280000c 	add	r0, r0, #12
8f619d14:	e3520000 	cmp	r2, #0
8f619d18:	e510100c 	ldr	r1, [r0, #-12]
8f619d1c:	05005004 	streq	r5, [r0, #-4]
8f619d20:	01a02005 	moveq	r2, r5
8f619d24:	e550c008 	ldrb	r12, [r0, #-8]
8f619d28:	e5923000 	ldr	r3, [r2]
8f619d2c:	e1500004 	cmp	r0, r4
8f619d30:	e1c3311e 	bic	r3, r3, r14, lsl r1
8f619d34:	e183311c 	orr	r3, r3, r12, lsl r1
8f619d38:	e5823000 	str	r3, [r2]
8f619d3c:	1afffff1 	bne	8f619d08 <tlmm_set_pull_ctrl+0x3c>
8f619d40:	e59f301c 	ldr	r3, [pc, #28]	; 8f619d64 <tlmm_set_pull_ctrl+0x98>
8f619d44:	e5932000 	ldr	r2, [r3]
8f619d48:	e59d3004 	ldr	r3, [r13, #4]
8f619d4c:	e0332002 	eors	r2, r3, r2
8f619d50:	e3a03000 	mov	r3, #0
8f619d54:	1a000001 	bne	8f619d60 <tlmm_set_pull_ctrl+0x94>
8f619d58:	e28dd00c 	add	r13, r13, #12
8f619d5c:	e8bd8030 	pop	{r4, r5, r15}
8f619d60:	eb006396 	bl	8f632bc0 <__stack_chk_fail>
8f619d64:	8f74221c 	.word	0x8f74221c

8f619d68 <long_press_pwrkey_timer_func>:
 * Shutdown the device if power key is release before
 * (PWRKEY_LONG_PRESS_COUNT/MPM_SLEEP_TIMETICK_COUNT) seconds.
 */
static enum handler_return long_press_pwrkey_timer_func(struct timer *p_timer,
	void *arg)
{
8f619d68:	e59f3090 	ldr	r3, [pc, #144]	; 8f619e00 <long_press_pwrkey_timer_func+0x98>
8f619d6c:	e92d4010 	push	{r4, r14}
8f619d70:	e24dd008 	sub	r13, r13, #8
8f619d74:	e5933000 	ldr	r3, [r3]
8f619d78:	e58d3004 	str	r3, [r13, #4]
8f619d7c:	e3a03000 	mov	r3, #0
8f619d80:	e1a04000 	mov	r4, r0
	uint32_t sclk_count = platform_get_sclk_count();
8f619d84:	ebff9dfa 	bl	8f601574 <platform_get_sclk_count>
	/*
	 * The following condition is treated as the power key
	 * is pressed long enough.
	 * 1. if the power key is pressed last for PWRKEY_LONG_PRESS_COUNT.
	 */
	if (sclk_count > PWRKEY_LONG_PRESS_COUNT) {
8f619d88:	e3500901 	cmp	r0, #16384	; 0x4000
8f619d8c:	9a00000e 	bls	8f619dcc <long_press_pwrkey_timer_func+0x64>
		timer_cancel(p_timer);
8f619d90:	e1a00004 	mov	r0, r4
8f619d94:	eb002cf5 	bl	8f625170 <timer_cancel>
		pon_timer_complete = 1;
8f619d98:	e30d3180 	movw	r3, #53632	; 0xd180
8f619d9c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f619da0:	e3a02001 	mov	r2, #1
8f619da4:	e5832000 	str	r2, [r3]
			shutdown_device();
		}
	}

	return INT_RESCHEDULE;
}
8f619da8:	e59f3050 	ldr	r3, [pc, #80]	; 8f619e00 <long_press_pwrkey_timer_func+0x98>
8f619dac:	e5932000 	ldr	r2, [r3]
8f619db0:	e59d3004 	ldr	r3, [r13, #4]
8f619db4:	e0332002 	eors	r2, r3, r2
8f619db8:	e3a03000 	mov	r3, #0
8f619dbc:	1a00000e 	bne	8f619dfc <long_press_pwrkey_timer_func+0x94>
8f619dc0:	e3a00001 	mov	r0, #1
8f619dc4:	e28dd008 	add	r13, r13, #8
8f619dc8:	e8bd8010 	pop	{r4, r15}
		if (pm8x41_get_pwrkey_is_pressed()) {
8f619dcc:	eb005c44 	bl	8f630ee4 <pm8x41_get_pwrkey_is_pressed>
8f619dd0:	e3500000 	cmp	r0, #0
8f619dd4:	0a000006 	beq	8f619df4 <long_press_pwrkey_timer_func+0x8c>
			timer_set_oneshot(p_timer, PWRKEY_DETECT_FREQUENCY,
8f619dd8:	e3a03000 	mov	r3, #0
8f619ddc:	e3092d68 	movw	r2, #40296	; 0x9d68
8f619de0:	e3a01032 	mov	r1, #50	; 0x32
8f619de4:	e3482f61 	movt	r2, #36705	; 0x8f61
8f619de8:	e1a00004 	mov	r0, r4
8f619dec:	eb002cc8 	bl	8f625114 <timer_set_oneshot>
8f619df0:	eaffffec 	b	8f619da8 <long_press_pwrkey_timer_func+0x40>
			shutdown_device();
8f619df4:	eb001985 	bl	8f620410 <shutdown_device>
8f619df8:	eaffffea 	b	8f619da8 <long_press_pwrkey_timer_func+0x40>
}
8f619dfc:	eb00636f 	bl	8f632bc0 <__stack_chk_fail>
8f619e00:	8f74221c 	.word	0x8f74221c

8f619e04 <shutdown_detect>:
 * 1. it is triggered by power key &&
 * 2. the power key is released before
 * (PWRKEY_LONG_PRESS_COUNT/MPM_SLEEP_TIMETICK_COUNT) seconds.
 */
void shutdown_detect()
{
8f619e04:	e59f30e0 	ldr	r3, [pc, #224]	; 8f619eec <shutdown_detect+0xe8>
8f619e08:	e92d4010 	push	{r4, r14}
8f619e0c:	e24dd008 	sub	r13, r13, #8
8f619e10:	e5933000 	ldr	r3, [r3]
8f619e14:	e58d3004 	str	r3, [r13, #4]
8f619e18:	e3a03000 	mov	r3, #0
	return target_is_pwrkey_pon_reason();
8f619e1c:	ebff9a49 	bl	8f600748 <target_is_pwrkey_pon_reason>
	/*
	 * If it is booted by power key tirigger.
	 * Initialize pon_timer and call long_press_pwrkey_timer_func
	 * function to check if the power key is last press long enough.
	 */
	if (is_pwrkey_pon_reason()) {
8f619e20:	e3500000 	cmp	r0, #0
8f619e24:	1a000007 	bne	8f619e48 <shutdown_detect+0x44>
		 * after the splash screen displayed. But it can be moved the
		 * wait here if the boot time is much more considered.
		 */
		wait_for_long_pwrkey_pressed();
	}
}
8f619e28:	e59f30bc 	ldr	r3, [pc, #188]	; 8f619eec <shutdown_detect+0xe8>
8f619e2c:	e5932000 	ldr	r2, [r3]
8f619e30:	e59d3004 	ldr	r3, [r13, #4]
8f619e34:	e0332002 	eors	r2, r3, r2
8f619e38:	e3a03000 	mov	r3, #0
8f619e3c:	1a000029 	bne	8f619ee8 <shutdown_detect+0xe4>
8f619e40:	e28dd008 	add	r13, r13, #8
8f619e44:	e8bd8010 	pop	{r4, r15}
		if(!pm8x41_get_pwrkey_is_pressed()){
8f619e48:	eb005c25 	bl	8f630ee4 <pm8x41_get_pwrkey_is_pressed>
8f619e4c:	e3500000 	cmp	r0, #0
8f619e50:	0a000022 	beq	8f619ee0 <shutdown_detect+0xdc>
		timer_initialize(&pon_timer);
8f619e54:	e30d0164 	movw	r0, #53604	; 0xd164
8f619e58:	e3480f72 	movt	r0, #36722	; 0x8f72
8f619e5c:	eb002c93 	bl	8f6250b0 <timer_initialize>
	while (!pon_timer_complete) {
8f619e60:	e30d4180 	movw	r4, #53632	; 0xd180
		timer_set_oneshot(&pon_timer, 0,(timer_callback)long_press_pwrkey_timer_func, NULL);
8f619e64:	e3a03000 	mov	r3, #0
	while (!pon_timer_complete) {
8f619e68:	e3484f72 	movt	r4, #36722	; 0x8f72
		timer_set_oneshot(&pon_timer, 0,(timer_callback)long_press_pwrkey_timer_func, NULL);
8f619e6c:	e1a01003 	mov	r1, r3
8f619e70:	e3092d68 	movw	r2, #40296	; 0x9d68
8f619e74:	e30d0164 	movw	r0, #53604	; 0xd164
8f619e78:	e3482f61 	movt	r2, #36705	; 0x8f61
8f619e7c:	e3480f72 	movt	r0, #36722	; 0x8f72
8f619e80:	eb002ca3 	bl	8f625114 <timer_set_oneshot>
	while (!pon_timer_complete) {
8f619e84:	e5943000 	ldr	r3, [r4]
8f619e88:	e3530000 	cmp	r3, #0
8f619e8c:	0a000005 	beq	8f619ea8 <shutdown_detect+0xa4>
8f619e90:	eaffffe4 	b	8f619e28 <shutdown_detect+0x24>
		thread_sleep(1);
8f619e94:	e3a00001 	mov	r0, #1
8f619e98:	eb0028fa 	bl	8f624288 <thread_sleep>
	while (!pon_timer_complete) {
8f619e9c:	e5943000 	ldr	r3, [r4]
8f619ea0:	e3530000 	cmp	r3, #0
8f619ea4:	1affffdf 	bne	8f619e28 <shutdown_detect+0x24>
		sclk_count = platform_get_sclk_count();
8f619ea8:	ebff9db1 	bl	8f601574 <platform_get_sclk_count>
		if (sclk_count > PWRKEY_LONG_PRESS_COUNT) {
8f619eac:	e3500901 	cmp	r0, #16384	; 0x4000
8f619eb0:	9afffff7 	bls	8f619e94 <shutdown_detect+0x90>
			timer_cancel(&pon_timer);
8f619eb4:	e59f3030 	ldr	r3, [pc, #48]	; 8f619eec <shutdown_detect+0xe8>
8f619eb8:	e5932000 	ldr	r2, [r3]
8f619ebc:	e59d3004 	ldr	r3, [r13, #4]
8f619ec0:	e0332002 	eors	r2, r3, r2
8f619ec4:	e3a03000 	mov	r3, #0
8f619ec8:	1a000006 	bne	8f619ee8 <shutdown_detect+0xe4>
8f619ecc:	e30d0164 	movw	r0, #53604	; 0xd164
8f619ed0:	e3480f72 	movt	r0, #36722	; 0x8f72
}
8f619ed4:	e28dd008 	add	r13, r13, #8
8f619ed8:	e8bd4010 	pop	{r4, r14}
			timer_cancel(&pon_timer);
8f619edc:	ea002ca3 	b	8f625170 <timer_cancel>
			shutdown_device();
8f619ee0:	eb00194a 	bl	8f620410 <shutdown_device>
8f619ee4:	eaffffda 	b	8f619e54 <shutdown_detect+0x50>
}
8f619ee8:	eb006334 	bl	8f632bc0 <__stack_chk_fail>
8f619eec:	8f74221c 	.word	0x8f74221c

8f619ef0 <target_override_pll>:
	{0x1B8, 0x1F}, /* QSERDES_COM_CMN_MISC2 */
};
#endif

__WEAK uint32_t target_override_pll()
{
8f619ef0:	e59f3038 	ldr	r3, [pc, #56]	; 8f619f30 <target_override_pll+0x40>
8f619ef4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f619ef8:	e24dd00c 	sub	r13, r13, #12
8f619efc:	e5933000 	ldr	r3, [r3]
8f619f00:	e58d3004 	str	r3, [r13, #4]
8f619f04:	e3a03000 	mov	r3, #0
	return 0;
}
8f619f08:	e59f3020 	ldr	r3, [pc, #32]	; 8f619f30 <target_override_pll+0x40>
8f619f0c:	e5932000 	ldr	r2, [r3]
8f619f10:	e59d3004 	ldr	r3, [r13, #4]
8f619f14:	e0332002 	eors	r2, r3, r2
8f619f18:	e3a03000 	mov	r3, #0
8f619f1c:	1a000002 	bne	8f619f2c <target_override_pll+0x3c>
8f619f20:	e3a00000 	mov	r0, #0
8f619f24:	e28dd00c 	add	r13, r13, #12
8f619f28:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f619f2c:	eb006323 	bl	8f632bc0 <__stack_chk_fail>
8f619f30:	8f74221c 	.word	0x8f74221c

8f619f34 <usb30_qmp_phy_reset>:
	writel(val, MSM_USB30_QSCRATCH_BASE + HS_PHY_COMMON_CTRL);
}

/* USB3.0 QMP phy reset */
void usb30_qmp_phy_reset(void)
{
8f619f34:	e59f3038 	ldr	r3, [pc, #56]	; 8f619f74 <usb30_qmp_phy_reset+0x40>
8f619f38:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f619f3c:	e24dd00c 	sub	r13, r13, #12
8f619f40:	e5933000 	ldr	r3, [r3]
8f619f44:	e58d3004 	str	r3, [r13, #4]
8f619f48:	e3a03000 	mov	r3, #0
#if USB_RESET_FROM_CLK
	clock_reset_usb_phy();
8f619f4c:	e59f3020 	ldr	r3, [pc, #32]	; 8f619f74 <usb30_qmp_phy_reset+0x40>
8f619f50:	e5932000 	ldr	r2, [r3]
8f619f54:	e59d3004 	ldr	r3, [r13, #4]
8f619f58:	e0332002 	eors	r2, r3, r2
8f619f5c:	e3a03000 	mov	r3, #0
8f619f60:	1a000002 	bne	8f619f70 <usb30_qmp_phy_reset+0x3c>
#else
	qmp_phy_qmp_reset();
#endif
}
8f619f64:	e28dd00c 	add	r13, r13, #12
8f619f68:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	clock_reset_usb_phy();
8f619f6c:	eaffa0eb 	b	8f602320 <clock_reset_usb_phy>
8f619f70:	eb006312 	bl	8f632bc0 <__stack_chk_fail>
8f619f74:	8f74221c 	.word	0x8f74221c

8f619f78 <usb30_qmp_phy_init>:

/* USB 3.0 phy init: HPG for QMP phy*/
void usb30_qmp_phy_init()
{
8f619f78:	e59f32bc 	ldr	r3, [pc, #700]	; 8f61a23c <usb30_qmp_phy_init+0x2c4>
8f619f7c:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f619f80:	e24dd00c 	sub	r13, r13, #12
8f619f84:	e5933000 	ldr	r3, [r3]
8f619f88:	e58d3004 	str	r3, [r13, #4]
8f619f8c:	e3a03000 	mov	r3, #0
	uint32_t i;


#if USE_TARGET_QMP_SETTINGS
	struct qmp_reg *target_qmp_settings = NULL;
	qmp_reg_size = target_get_qmp_regsize();
8f619f90:	ebff9c9b 	bl	8f601204 <target_get_qmp_regsize>
8f619f94:	e1a06000 	mov	r6, r0
	target_qmp_settings = target_get_qmp_settings();
8f619f98:	ebff9c87 	bl	8f6011bc <target_get_qmp_settings>
	if (qmp_reg_size && target_qmp_settings)
8f619f9c:	e3560000 	cmp	r6, #0
8f619fa0:	13500000 	cmpne	r0, #0
8f619fa4:	0a00000e 	beq	8f619fe4 <usb30_qmp_phy_init+0x6c>
8f619fa8:	e2807004 	add	r7, r0, #4
8f619fac:	e1a05000 	mov	r5, r0
	{
		for (i = 0 ; i < qmp_reg_size; i++)
8f619fb0:	e3a04000 	mov	r4, #0
		{
			/* As per the hw document we need to add a delay of 1 ms after setting
			 * QSERDES_COM_RESETSM_CNTRL2 and before setting QSERDES_COM_CMN_CONFIG */
			if (i == 7)
				mdelay(1);
			writel(target_qmp_settings[i].val, QMP_PHY_BASE + target_qmp_settings[i].off);
8f619fb4:	e7953184 	ldr	r3, [r5, r4, lsl #3]
8f619fb8:	e7972184 	ldr	r2, [r7, r4, lsl #3]
		for (i = 0 ; i < qmp_reg_size; i++)
8f619fbc:	e2844001 	add	r4, r4, #1
			writel(target_qmp_settings[i].val, QMP_PHY_BASE + target_qmp_settings[i].off);
8f619fc0:	e283391e 	add	r3, r3, #491520	; 0x78000
		for (i = 0 ; i < qmp_reg_size; i++)
8f619fc4:	e1560004 	cmp	r6, r4
			writel(target_qmp_settings[i].val, QMP_PHY_BASE + target_qmp_settings[i].off);
8f619fc8:	e5832000 	str	r2, [r3]
		for (i = 0 ; i < qmp_reg_size; i++)
8f619fcc:	9a000017 	bls	8f61a030 <usb30_qmp_phy_init+0xb8>
			if (i == 7)
8f619fd0:	e3540007 	cmp	r4, #7
8f619fd4:	1afffff6 	bne	8f619fb4 <usb30_qmp_phy_init+0x3c>
				mdelay(1);
8f619fd8:	e3a00001 	mov	r0, #1
8f619fdc:	ebffd346 	bl	8f60ecfc <mdelay>
8f619fe0:	eafffff3 	b	8f619fb4 <usb30_qmp_phy_init+0x3c>
		}
	goto phy_status;
	}
#endif

	uint32_t rev_id = platform_get_qmp_rev();
8f619fe4:	ebff9e4b 	bl	8f601918 <platform_get_qmp_rev>

	/* Sequence as per HPG */
	writel(0x01, QMP_PHY_BASE + PCIE_USB3_PHY_POWER_DOWN_CONTROL);
8f619fe8:	e3a0491e 	mov	r4, #491520	; 0x78000
8f619fec:	e3a03001 	mov	r3, #1
8f619ff0:	e5843604 	str	r3, [r4, #1540]	; 0x604

	if (rev_id >= 0x20000000)
8f619ff4:	e370021e 	cmn	r0, #-536870911	; 0xe0000001
8f619ff8:	9a00002a 	bls	8f61a0a8 <usb30_qmp_phy_init+0x130>
8f619ffc:	e30133a4 	movw	r3, #5028	; 0x13a4
8f61a000:	e3483f71 	movt	r3, #36721	; 0x8f71
8f61a004:	e2830f72 	add	r0, r3, #456	; 0x1c8
	{
		qmp_reg_size = sizeof(qmp_settings_rev2) / sizeof(struct qmp_reg);
		for (i = 0 ; i < qmp_reg_size; i++)
			writel(qmp_settings_rev2[i].val, QMP_PHY_BASE + qmp_settings_rev2[i].off);
8f61a008:	e5932000 	ldr	r2, [r3]
		for (i = 0 ; i < qmp_reg_size; i++)
8f61a00c:	e2833008 	add	r3, r3, #8
			writel(qmp_settings_rev2[i].val, QMP_PHY_BASE + qmp_settings_rev2[i].off);
8f61a010:	e5131004 	ldr	r1, [r3, #-4]
		for (i = 0 ; i < qmp_reg_size; i++)
8f61a014:	e1530000 	cmp	r3, r0
			writel(qmp_settings_rev2[i].val, QMP_PHY_BASE + qmp_settings_rev2[i].off);
8f61a018:	e282291e 	add	r2, r2, #491520	; 0x78000
8f61a01c:	e5821000 	str	r1, [r2]
		for (i = 0 ; i < qmp_reg_size; i++)
8f61a020:	1afffff8 	bne	8f61a008 <usb30_qmp_phy_init+0x90>
#if PLATFORM_USE_QMP_MISC
		if (platform_use_qmp_misc_settings())
			for (i = 0; i < ARRAY_SIZE(qmp_misc_settings_rev2); i++)
				writel(qmp_misc_settings_rev2[i].val, QMP_PHY_BASE + qmp_misc_settings_rev2[i].off);
#endif
		if (target_override_pll())
8f61a024:	ebffffb1 	bl	8f619ef0 <target_override_pll>
8f61a028:	e3500000 	cmp	r0, #0
8f61a02c:	1a000012 	bne	8f61a07c <usb30_qmp_phy_init+0x104>
		for (i = 0 ; i < qmp_reg_size; i++)
8f61a030:	e3a04ffa 	mov	r4, #1000	; 0x3e8
		phy_status = QMP_PHY_BASE + 0x77c;
	else
		phy_status = QMP_PHY_BASE + 0x728;
#endif

	while ((readl(phy_status) & PHYSTATUS))
8f61a034:	e3a0591e 	mov	r5, #491520	; 0x78000
8f61a038:	ea000003 	b	8f61a04c <usb30_qmp_phy_init+0xd4>
	{
		udelay(1);
8f61a03c:	e3a00001 	mov	r0, #1
8f61a040:	ebffd345 	bl	8f60ed5c <udelay>
		timeout--;
		if (!timeout)
8f61a044:	e2544001 	subs	r4, r4, #1
8f61a048:	0a00006b 	beq	8f61a1fc <usb30_qmp_phy_init+0x284>
	while ((readl(phy_status) & PHYSTATUS))
8f61a04c:	e5953974 	ldr	r3, [r5, #2420]	; 0x974
8f61a050:	e3130040 	tst	r3, #64	; 0x40
8f61a054:	1afffff8 	bne	8f61a03c <usb30_qmp_phy_init+0xc4>
			hsonly_mode = true;
			return;
		}
	}

	clock_bumpup_pipe3_clk();
8f61a058:	e59f31dc 	ldr	r3, [pc, #476]	; 8f61a23c <usb30_qmp_phy_init+0x2c4>
8f61a05c:	e5932000 	ldr	r2, [r3]
8f61a060:	e59d3004 	ldr	r3, [r13, #4]
8f61a064:	e0332002 	eors	r2, r3, r2
8f61a068:	e3a03000 	mov	r3, #0
8f61a06c:	1a000071 	bne	8f61a238 <usb30_qmp_phy_init+0x2c0>
}
8f61a070:	e28dd00c 	add	r13, r13, #12
8f61a074:	e8bd40f0 	pop	{r4, r5, r6, r7, r14}
	clock_bumpup_pipe3_clk();
8f61a078:	eaff9f79 	b	8f601e64 <clock_bumpup_pipe3_clk>
8f61a07c:	e3013384 	movw	r3, #4996	; 0x1384
8f61a080:	e3483f71 	movt	r3, #36721	; 0x8f71
8f61a084:	e2830020 	add	r0, r3, #32
				writel(qmp_override_pll_rev2[i].val, QMP_PHY_BASE + qmp_override_pll_rev2[i].off);
8f61a088:	e5932000 	ldr	r2, [r3]
			for (i = 0 ; i < qmp_reg_size; i++)
8f61a08c:	e2833008 	add	r3, r3, #8
				writel(qmp_override_pll_rev2[i].val, QMP_PHY_BASE + qmp_override_pll_rev2[i].off);
8f61a090:	e5131004 	ldr	r1, [r3, #-4]
			for (i = 0 ; i < qmp_reg_size; i++)
8f61a094:	e1500003 	cmp	r0, r3
				writel(qmp_override_pll_rev2[i].val, QMP_PHY_BASE + qmp_override_pll_rev2[i].off);
8f61a098:	e282291e 	add	r2, r2, #491520	; 0x78000
8f61a09c:	e5821000 	str	r1, [r2]
			for (i = 0 ; i < qmp_reg_size; i++)
8f61a0a0:	1afffff8 	bne	8f61a088 <usb30_qmp_phy_init+0x110>
8f61a0a4:	eaffffe1 	b	8f61a030 <usb30_qmp_phy_init+0xb8>
		writel(0x08, QMP_PHY_BASE + QSERDES_COM_SYSCLK_EN_SEL_TXBAND);
8f61a0a8:	e3a03008 	mov	r3, #8
8f61a0ac:	e5843048 	str	r3, [r4, #72]	; 0x48
		if (target_override_pll())
8f61a0b0:	ebffff8e 	bl	8f619ef0 <target_override_pll>
		writel(0x01, QMP_PHY_BASE + QSERDES_COM_PLLLOCK_CMP_EN);
8f61a0b4:	e3a02001 	mov	r2, #1
		writel(0x03, QMP_PHY_BASE + QSERDES_COM_DEC_START2);
8f61a0b8:	e3a01003 	mov	r1, #3
		if (target_override_pll())
8f61a0bc:	e3500000 	cmp	r0, #0
		writel(0x82, QMP_PHY_BASE + QSERDES_COM_DEC_START1);
8f61a0c0:	e3a00082 	mov	r0, #130	; 0x82
			writel(0xE1, QMP_PHY_BASE + QSERDES_COM_PLL_VCOTAIL_EN);
8f61a0c4:	13a030e1 	movne	r3, #225	; 0xe1
8f61a0c8:	15843004 	strne	r3, [r4, #4]
		writel(0x82, QMP_PHY_BASE + QSERDES_COM_DEC_START1);
8f61a0cc:	e3a0491e 	mov	r4, #491520	; 0x78000
		writel(0x0F, QMP_PHY_BASE + QSERDES_COM_PLL_CP_SETP);
8f61a0d0:	e3a0300f 	mov	r3, #15
		writel(0x82, QMP_PHY_BASE + QSERDES_COM_DEC_START1);
8f61a0d4:	e58400a4 	str	r0, [r4, #164]	; 0xa4
		writel(0xD5, QMP_PHY_BASE + QSERDES_COM_DIV_FRAC_START1);
8f61a0d8:	e3a000d5 	mov	r0, #213	; 0xd5
		writel(0x03, QMP_PHY_BASE + QSERDES_COM_DEC_START2);
8f61a0dc:	e5841104 	str	r1, [r4, #260]	; 0x104
		writel(0xAA, QMP_PHY_BASE + QSERDES_COM_DIV_FRAC_START2);
8f61a0e0:	e3a010aa 	mov	r1, #170	; 0xaa
		writel(0xD5, QMP_PHY_BASE + QSERDES_COM_DIV_FRAC_START1);
8f61a0e4:	e58400f8 	str	r0, [r4, #248]	; 0xf8
		writel(0x4D, QMP_PHY_BASE + QSERDES_COM_DIV_FRAC_START3);
8f61a0e8:	e3a0004d 	mov	r0, #77	; 0x4d
		writel(0xAA, QMP_PHY_BASE + QSERDES_COM_DIV_FRAC_START2);
8f61a0ec:	e58410fc 	str	r1, [r4, #252]	; 0xfc
		writel(0x2B, QMP_PHY_BASE + QSERDES_COM_PLLLOCK_CMP1);
8f61a0f0:	e3a0102b 	mov	r1, #43	; 0x2b
		writel(0x4D, QMP_PHY_BASE + QSERDES_COM_DIV_FRAC_START3);
8f61a0f4:	e5840100 	str	r0, [r4, #256]	; 0x100
		writel(0x68, QMP_PHY_BASE + QSERDES_COM_PLLLOCK_CMP2);
8f61a0f8:	e3a00068 	mov	r0, #104	; 0x68
		writel(0x01, QMP_PHY_BASE + QSERDES_COM_PLLLOCK_CMP_EN);
8f61a0fc:	e5842094 	str	r2, [r4, #148]	; 0x94
		writel(0x2B, QMP_PHY_BASE + QSERDES_COM_PLLLOCK_CMP1);
8f61a100:	e5841088 	str	r1, [r4, #136]	; 0x88
		writel(0x7C, QMP_PHY_BASE + QSERDES_COM_PLL_CRCTRL);
8f61a104:	e3a0107c 	mov	r1, #124	; 0x7c
		writel(0x68, QMP_PHY_BASE + QSERDES_COM_PLLLOCK_CMP2);
8f61a108:	e584008c 	str	r0, [r4, #140]	; 0x8c
		writel(0x02, QMP_PHY_BASE + QSERDES_COM_PLL_CP_SETI);
8f61a10c:	e3a00002 	mov	r0, #2
		writel(0x7C, QMP_PHY_BASE + QSERDES_COM_PLL_CRCTRL);
8f61a110:	e584110c 	str	r1, [r4, #268]	; 0x10c
		writel(0x1F, QMP_PHY_BASE + QSERDES_COM_PLL_IP_SETP);
8f61a114:	e3a0101f 	mov	r1, #31
		writel(0x02, QMP_PHY_BASE + QSERDES_COM_PLL_CP_SETI);
8f61a118:	e5840034 	str	r0, [r4, #52]	; 0x34
		writel(0x46, QMP_PHY_BASE + QSERDES_COM_PLL_CNTRL);
8f61a11c:	e3a00046 	mov	r0, #70	; 0x46
		writel(0x1F, QMP_PHY_BASE + QSERDES_COM_PLL_IP_SETP);
8f61a120:	e5841038 	str	r1, [r4, #56]	; 0x38
		writel(0xDA, QMP_PHY_BASE + QSERDES_RX_CDR_CONTROL1);
8f61a124:	e3a010da 	mov	r1, #218	; 0xda
		writel(0x0F, QMP_PHY_BASE + QSERDES_COM_PLL_CP_SETP);
8f61a128:	e584303c 	str	r3, [r4, #60]	; 0x3c
		writel(0x01, QMP_PHY_BASE + QSERDES_COM_PLL_IP_SETI);
8f61a12c:	e5842024 	str	r2, [r4, #36]	; 0x24
		writel(0x42, QMP_PHY_BASE + QSERDES_RX_CDR_CONTROL2);
8f61a130:	e3a02042 	mov	r2, #66	; 0x42
		writel(0x0F, QMP_PHY_BASE + QSERDES_COM_IE_TRIM);
8f61a134:	e584300c 	str	r3, [r4, #12]
		writel(0x0F, QMP_PHY_BASE + QSERDES_COM_IP_TRIM);
8f61a138:	e5843010 	str	r3, [r4, #16]
		writel(0x90, QMP_PHY_BASE + QSERDES_COM_RESETSM_CNTRL);
8f61a13c:	e3a03090 	mov	r3, #144	; 0x90
		writel(0x46, QMP_PHY_BASE + QSERDES_COM_PLL_CNTRL);
8f61a140:	e5840014 	str	r0, [r4, #20]
		writel(0xDA, QMP_PHY_BASE + QSERDES_RX_CDR_CONTROL1);
8f61a144:	e5841400 	str	r1, [r4, #1024]	; 0x400
		writel(0x42, QMP_PHY_BASE + QSERDES_RX_CDR_CONTROL2);
8f61a148:	e5842404 	str	r2, [r4, #1028]	; 0x404
		writel(0x90, QMP_PHY_BASE + QSERDES_COM_RESETSM_CNTRL);
8f61a14c:	e584304c 	str	r3, [r4, #76]	; 0x4c
		if (target_override_pll())
8f61a150:	ebffff66 	bl	8f619ef0 <target_override_pll>
		writel(0x02, QMP_PHY_BASE + QSERDES_RX_RX_EQU_ADAPTOR_CNTRL2);
8f61a154:	e3a0c002 	mov	r12, #2
		writel(0x03, QMP_PHY_BASE + QSERDES_TX_RCV_DETECT_LVL);
8f61a158:	e3a02003 	mov	r2, #3
		writel(0x20, QMP_PHY_BASE + QSERDES_COM_RES_CODE_START_SEG1);
8f61a15c:	e3a01020 	mov	r1, #32
		writel(0x31, QMP_PHY_BASE + QSERDES_COM_SSC_PER1);
8f61a160:	e3a0e031 	mov	r14, #49	; 0x31
		if (target_override_pll())
8f61a164:	e3500000 	cmp	r0, #0
		writel(0x01, QMP_PHY_BASE + QSERDES_COM_SSC_EN_CENTER);
8f61a168:	e3a00001 	mov	r0, #1
			writel(0x07, QMP_PHY_BASE + QSERDES_COM_RESETSM_CNTRL2);
8f61a16c:	13a03007 	movne	r3, #7
			writel(0x05, QMP_PHY_BASE + QSERDES_COM_RESETSM_CNTRL2);
8f61a170:	03a03005 	moveq	r3, #5
8f61a174:	e5843050 	str	r3, [r4, #80]	; 0x50
		writel(0x20, QMP_PHY_BASE + QSERDES_COM_RES_CODE_START_SEG1);
8f61a178:	e3a0391e 	mov	r3, #491520	; 0x78000
8f61a17c:	e58310d8 	str	r1, [r3, #216]	; 0xd8
		writel(0x77, QMP_PHY_BASE + QSERDES_COM_RES_CODE_CAL_CSR);
8f61a180:	e3a01077 	mov	r1, #119	; 0x77
8f61a184:	e58310e0 	str	r1, [r3, #224]	; 0xe0
		writel(0x15, QMP_PHY_BASE + QSERDES_COM_RES_TRIM_CONTROL);
8f61a188:	e3a01015 	mov	r1, #21
8f61a18c:	e58310e8 	str	r1, [r3, #232]	; 0xe8
		writel(0x6C, QMP_PHY_BASE + QSERDES_RX_RX_EQU_ADAPTOR_CNTRL3);
8f61a190:	e3a0106c 	mov	r1, #108	; 0x6c
		writel(0x03, QMP_PHY_BASE + QSERDES_TX_RCV_DETECT_LVL);
8f61a194:	e5832268 	str	r2, [r3, #616]	; 0x268
		writel(0x02, QMP_PHY_BASE + QSERDES_RX_RX_EQU_ADAPTOR_CNTRL2);
8f61a198:	e583c4bc 	str	r12, [r3, #1212]	; 0x4bc
		writel(0x6C, QMP_PHY_BASE + QSERDES_RX_RX_EQU_ADAPTOR_CNTRL3);
8f61a19c:	e58314c0 	str	r1, [r3, #1216]	; 0x4c0
		writel(0xC7, QMP_PHY_BASE + QSERDES_RX_RX_EQU_ADAPTOR_CNTRL4);
8f61a1a0:	e3a010c7 	mov	r1, #199	; 0xc7
8f61a1a4:	e58314c4 	str	r1, [r3, #1220]	; 0x4c4
		writel(0x40, QMP_PHY_BASE + QSERDES_RX_SIGDET_ENABLES);
8f61a1a8:	e3a01040 	mov	r1, #64	; 0x40
8f61a1ac:	e58314f8 	str	r1, [r3, #1272]	; 0x4f8
		writel(0x73, QMP_PHY_BASE + QSERDES_RX_SIGDET_CNTRL);
8f61a1b0:	e3a01073 	mov	r1, #115	; 0x73
8f61a1b4:	e5831500 	str	r1, [r3, #1280]	; 0x500
		writel(0x06, QMP_PHY_BASE + QSERDES_RX_SIGDET_DEGLITCH_CNTRL);
8f61a1b8:	e3a01006 	mov	r1, #6
8f61a1bc:	e5831504 	str	r1, [r3, #1284]	; 0x504
		writel(0x48, QMP_PHY_BASE + PCIE_USB3_PHY_RX_IDLE_DTCT_CNTRL);
8f61a1c0:	e3a01048 	mov	r1, #72	; 0x48
8f61a1c4:	e583164c 	str	r1, [r3, #1612]	; 0x64c
		writel(0x19, QMP_PHY_BASE + QSERDES_COM_SSC_STEP_SIZE1);
8f61a1c8:	e3a01019 	mov	r1, #25
		writel(0x01, QMP_PHY_BASE + QSERDES_COM_SSC_EN_CENTER);
8f61a1cc:	e58300ac 	str	r0, [r3, #172]	; 0xac
		writel(0x02, QMP_PHY_BASE + QSERDES_COM_SSC_ADJ_PER1);
8f61a1d0:	e583c0b0 	str	r12, [r3, #176]	; 0xb0
		writel(0x08, QMP_PHY_BASE + PCIE_USB3_PHY_POWER_STATE_CONFIG2);
8f61a1d4:	e3a0c008 	mov	r12, #8
		writel(0x31, QMP_PHY_BASE + QSERDES_COM_SSC_PER1);
8f61a1d8:	e583e0b8 	str	r14, [r3, #184]	; 0xb8
		writel(0x01, QMP_PHY_BASE + QSERDES_COM_SSC_PER2);
8f61a1dc:	e58300bc 	str	r0, [r3, #188]	; 0xbc
		writel(0x19, QMP_PHY_BASE + QSERDES_COM_SSC_STEP_SIZE1);
8f61a1e0:	e58310c0 	str	r1, [r3, #192]	; 0xc0
		writel(0x19, QMP_PHY_BASE + QSERDES_COM_SSC_STEP_SIZE2);
8f61a1e4:	e58310c4 	str	r1, [r3, #196]	; 0xc4
		writel(0x00, QMP_PHY_BASE + PCIE_USB3_PHY_SW_RESET);
8f61a1e8:	e3a01000 	mov	r1, #0
		writel(0x08, QMP_PHY_BASE + PCIE_USB3_PHY_POWER_STATE_CONFIG2);
8f61a1ec:	e583c654 	str	r12, [r3, #1620]	; 0x654
		writel(0x00, QMP_PHY_BASE + PCIE_USB3_PHY_SW_RESET);
8f61a1f0:	e5831600 	str	r1, [r3, #1536]	; 0x600
		writel(0x03, QMP_PHY_BASE + PCIE_USB3_PHY_START);
8f61a1f4:	e5832608 	str	r2, [r3, #1544]	; 0x608
8f61a1f8:	eaffff8c 	b	8f61a030 <usb30_qmp_phy_init+0xb8>
			dprintf(CRITICAL, "QMP phy initialization failed, fallback to HighSpeed only mode\n");
8f61a1fc:	e30604e0 	movw	r0, #25824	; 0x64e0
8f61a200:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61a204:	eb0061da 	bl	8f632974 <_dprintf>
			hsonly_mode = true;
8f61a208:	e30d3184 	movw	r3, #53636	; 0xd184
8f61a20c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f61a210:	e3a02001 	mov	r2, #1
8f61a214:	e5832000 	str	r2, [r3]
}
8f61a218:	e59f301c 	ldr	r3, [pc, #28]	; 8f61a23c <usb30_qmp_phy_init+0x2c4>
8f61a21c:	e5932000 	ldr	r2, [r3]
8f61a220:	e59d3004 	ldr	r3, [r13, #4]
8f61a224:	e0332002 	eors	r2, r3, r2
8f61a228:	e3a03000 	mov	r3, #0
8f61a22c:	1a000001 	bne	8f61a238 <usb30_qmp_phy_init+0x2c0>
8f61a230:	e28dd00c 	add	r13, r13, #12
8f61a234:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
8f61a238:	eb006260 	bl	8f632bc0 <__stack_chk_fail>
8f61a23c:	8f74221c 	.word	0x8f74221c

8f61a240 <use_hsonly_mode>:

bool use_hsonly_mode()
{
	return hsonly_mode;
8f61a240:	e30d3184 	movw	r3, #53636	; 0xd184
8f61a244:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f61a248:	e59f2038 	ldr	r2, [pc, #56]	; 8f61a288 <use_hsonly_mode+0x48>
8f61a24c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61a250:	e24dd00c 	sub	r13, r13, #12
	return hsonly_mode;
8f61a254:	e5930000 	ldr	r0, [r3]
{
8f61a258:	e5922000 	ldr	r2, [r2]
8f61a25c:	e58d2004 	str	r2, [r13, #4]
8f61a260:	e3a02000 	mov	r2, #0
}
8f61a264:	e59f301c 	ldr	r3, [pc, #28]	; 8f61a288 <use_hsonly_mode+0x48>
8f61a268:	e5932000 	ldr	r2, [r3]
8f61a26c:	e59d3004 	ldr	r3, [r13, #4]
8f61a270:	e0332002 	eors	r2, r3, r2
8f61a274:	e3a03000 	mov	r3, #0
8f61a278:	1a000001 	bne	8f61a284 <use_hsonly_mode+0x44>
8f61a27c:	e28dd00c 	add	r13, r13, #12
8f61a280:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61a284:	eb00624d 	bl	8f632bc0 <__stack_chk_fail>
8f61a288:	8f74221c 	.word	0x8f74221c

8f61a28c <platform_is_msm8994>:
8f61a28c:	e59f3038 	ldr	r3, [pc, #56]	; 8f61a2cc <platform_is_msm8994+0x40>
8f61a290:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61a294:	e24dd00c 	sub	r13, r13, #12
8f61a298:	e5933000 	ldr	r3, [r3]
8f61a29c:	e58d3004 	str	r3, [r13, #4]
8f61a2a0:	e3a03000 	mov	r3, #0
8f61a2a4:	e59f3020 	ldr	r3, [pc, #32]	; 8f61a2cc <platform_is_msm8994+0x40>
8f61a2a8:	e5932000 	ldr	r2, [r3]
8f61a2ac:	e59d3004 	ldr	r3, [r13, #4]
8f61a2b0:	e0332002 	eors	r2, r3, r2
8f61a2b4:	e3a03000 	mov	r3, #0
8f61a2b8:	1a000002 	bne	8f61a2c8 <platform_is_msm8994+0x3c>
8f61a2bc:	e3a00000 	mov	r0, #0
8f61a2c0:	e28dd00c 	add	r13, r13, #12
8f61a2c4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61a2c8:	eb00623c 	bl	8f632bc0 <__stack_chk_fail>
8f61a2cc:	8f74221c 	.word	0x8f74221c

8f61a2d0 <platform_is_msm8996>:
8f61a2d0:	e59f3038 	ldr	r3, [pc, #56]	; 8f61a310 <platform_is_msm8996+0x40>
8f61a2d4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61a2d8:	e24dd00c 	sub	r13, r13, #12
8f61a2dc:	e5933000 	ldr	r3, [r3]
8f61a2e0:	e58d3004 	str	r3, [r13, #4]
8f61a2e4:	e3a03000 	mov	r3, #0
8f61a2e8:	e59f3020 	ldr	r3, [pc, #32]	; 8f61a310 <platform_is_msm8996+0x40>
8f61a2ec:	e5932000 	ldr	r2, [r3]
8f61a2f0:	e59d3004 	ldr	r3, [r13, #4]
8f61a2f4:	e0332002 	eors	r2, r3, r2
8f61a2f8:	e3a03000 	mov	r3, #0
8f61a2fc:	1a000002 	bne	8f61a30c <platform_is_msm8996+0x3c>
8f61a300:	e3a00000 	mov	r0, #0
8f61a304:	e28dd00c 	add	r13, r13, #12
8f61a308:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61a30c:	eb00622b 	bl	8f632bc0 <__stack_chk_fail>
8f61a310:	8f74221c 	.word	0x8f74221c

8f61a314 <platform_is_msm8996sg>:
8f61a314:	e59f3038 	ldr	r3, [pc, #56]	; 8f61a354 <platform_is_msm8996sg+0x40>
8f61a318:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61a31c:	e24dd00c 	sub	r13, r13, #12
8f61a320:	e5933000 	ldr	r3, [r3]
8f61a324:	e58d3004 	str	r3, [r13, #4]
8f61a328:	e3a03000 	mov	r3, #0
8f61a32c:	e59f3020 	ldr	r3, [pc, #32]	; 8f61a354 <platform_is_msm8996sg+0x40>
8f61a330:	e5932000 	ldr	r2, [r3]
8f61a334:	e59d3004 	ldr	r3, [r13, #4]
8f61a338:	e0332002 	eors	r2, r3, r2
8f61a33c:	e3a03000 	mov	r3, #0
8f61a340:	1a000002 	bne	8f61a350 <platform_is_msm8996sg+0x3c>
8f61a344:	e3a00000 	mov	r0, #0
8f61a348:	e28dd00c 	add	r13, r13, #12
8f61a34c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61a350:	eb00621a 	bl	8f632bc0 <__stack_chk_fail>
8f61a354:	8f74221c 	.word	0x8f74221c

8f61a358 <platform_is_mdm9650>:
8f61a358:	e59f3038 	ldr	r3, [pc, #56]	; 8f61a398 <platform_is_mdm9650+0x40>
8f61a35c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61a360:	e24dd00c 	sub	r13, r13, #12
8f61a364:	e5933000 	ldr	r3, [r3]
8f61a368:	e58d3004 	str	r3, [r13, #4]
8f61a36c:	e3a03000 	mov	r3, #0
8f61a370:	e59f3020 	ldr	r3, [pc, #32]	; 8f61a398 <platform_is_mdm9650+0x40>
8f61a374:	e5932000 	ldr	r2, [r3]
8f61a378:	e59d3004 	ldr	r3, [r13, #4]
8f61a37c:	e0332002 	eors	r2, r3, r2
8f61a380:	e3a03000 	mov	r3, #0
8f61a384:	1a000002 	bne	8f61a394 <platform_is_mdm9650+0x3c>
8f61a388:	e3a00000 	mov	r0, #0
8f61a38c:	e28dd00c 	add	r13, r13, #12
8f61a390:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61a394:	eb006209 	bl	8f632bc0 <__stack_chk_fail>
8f61a398:	8f74221c 	.word	0x8f74221c

8f61a39c <platform_is_sdx20>:
8f61a39c:	e59f3038 	ldr	r3, [pc, #56]	; 8f61a3dc <platform_is_sdx20+0x40>
8f61a3a0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61a3a4:	e24dd00c 	sub	r13, r13, #12
8f61a3a8:	e5933000 	ldr	r3, [r3]
8f61a3ac:	e58d3004 	str	r3, [r13, #4]
8f61a3b0:	e3a03000 	mov	r3, #0
8f61a3b4:	e59f3020 	ldr	r3, [pc, #32]	; 8f61a3dc <platform_is_sdx20+0x40>
8f61a3b8:	e5932000 	ldr	r2, [r3]
8f61a3bc:	e59d3004 	ldr	r3, [r13, #4]
8f61a3c0:	e0332002 	eors	r2, r3, r2
8f61a3c4:	e3a03000 	mov	r3, #0
8f61a3c8:	1a000002 	bne	8f61a3d8 <platform_is_sdx20+0x3c>
8f61a3cc:	e3a00000 	mov	r0, #0
8f61a3d0:	e28dd00c 	add	r13, r13, #12
8f61a3d4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61a3d8:	eb0061f8 	bl	8f632bc0 <__stack_chk_fail>
8f61a3dc:	8f74221c 	.word	0x8f74221c

8f61a3e0 <qusb2_phy_reset>:
{
	return 0;
}

void qusb2_phy_reset(void)
{
8f61a3e0:	e59f32b4 	ldr	r3, [pc, #692]	; 8f61a69c <qusb2_phy_reset+0x2bc>
	dmb();
#endif
	/* Block Reset */
	val = readl(GCC_QUSB2_PHY_BCR) | BIT(0);
	writel(val, GCC_QUSB2_PHY_BCR);
	udelay(10);
8f61a3e4:	e3a0000a 	mov	r0, #10
{
8f61a3e8:	e92d4030 	push	{r4, r5, r14}
8f61a3ec:	e24dd00c 	sub	r13, r13, #12
8f61a3f0:	e5933000 	ldr	r3, [r3]
8f61a3f4:	e58d3004 	str	r3, [r13, #4]
8f61a3f8:	e3a03000 	mov	r3, #0
	val = readl(GCC_QUSB2_PHY_BCR) | BIT(0);
8f61a3fc:	e3a04a01 	mov	r4, #4096	; 0x1000
8f61a400:	e3404184 	movt	r4, #388	; 0x184
8f61a404:	e594503c 	ldr	r5, [r4, #60]	; 0x3c
8f61a408:	e3853001 	orr	r3, r5, #1
	writel(val, GCC_QUSB2_PHY_BCR);
8f61a40c:	e584303c 	str	r3, [r4, #60]	; 0x3c
	udelay(10);
8f61a410:	ebffd251 	bl	8f60ed5c <udelay>
	writel(val & ~BIT(0), GCC_QUSB2_PHY_BCR);

	/* configure the abh2 phy to wait state */
	writel(0x11, PERIPH_SS_AHB2PHY_TOP_CFG);
8f61a414:	e3a03a7e 	mov	r3, #516096	; 0x7e000
8f61a418:	e3c55001 	bic	r5, r5, #1
8f61a41c:	e3a02011 	mov	r2, #17
	writel(val & ~BIT(0), GCC_QUSB2_PHY_BCR);
8f61a420:	e584503c 	str	r5, [r4, #60]	; 0x3c
	writel(0x11, PERIPH_SS_AHB2PHY_TOP_CFG);
8f61a424:	e5832010 	str	r2, [r3, #16]
	dmb();
8f61a428:	f57ff05f 	dmb	sy

	/* set CLAMP_N_EN and stay with disabled USB PHY */
	if(platform_is_sdx20())
8f61a42c:	ebffffda 	bl	8f61a39c <platform_is_sdx20>
		writel(0x23, QUSB2PHY_PWR_CTRL1_SDX20);
8f61a430:	e3a03a79 	mov	r3, #495616	; 0x79000
8f61a434:	e3a02023 	mov	r2, #35	; 0x23
	if(platform_is_sdx20())
8f61a438:	e3500000 	cmp	r0, #0
		writel(0x23, QUSB2PHY_PWR_CTRL1_SDX20);
8f61a43c:	15832210 	strne	r2, [r3, #528]	; 0x210
	else
		writel(0x23, QUSB2PHY_PORT_POWERDOWN);
8f61a440:	058320b4 	streq	r2, [r3, #180]	; 0xb4
	/* TCSR register bit 0 indicates whether single ended clock
	 * or differential clock configuration is enabled. Based on the
	 * configuration set the PLL_TEST register.
	 */
#if TCSR_PHY_CLK_SCHEME_SEL
	se_clock = readl(TCSR_PHY_CLK_SCHEME_SEL) & 0x1;
8f61a444:	e3a03a0f 	mov	r3, #61440	; 0xf000
8f61a448:	e3403193 	movt	r3, #403	; 0x193
8f61a44c:	e5935044 	ldr	r5, [r3, #68]	; 0x44
#endif
	if (platform_is_msm8996() || platform_is_mdm9650() || platform_is_msm8953())
8f61a450:	ebffff9e 	bl	8f61a2d0 <platform_is_msm8996>
	se_clock = readl(TCSR_PHY_CLK_SCHEME_SEL) & 0x1;
8f61a454:	e2055001 	and	r5, r5, #1
	if (platform_is_msm8996() || platform_is_mdm9650() || platform_is_msm8953())
8f61a458:	e3500000 	cmp	r0, #0
8f61a45c:	1a000002 	bne	8f61a46c <qusb2_phy_reset+0x8c>
8f61a460:	ebffffbc 	bl	8f61a358 <platform_is_mdm9650>
8f61a464:	e3500000 	cmp	r0, #0
8f61a468:	0a000057 	beq	8f61a5cc <qusb2_phy_reset+0x1ec>
	{
		if(platform_is_msm8996sg())
8f61a46c:	ebffffa8 	bl	8f61a314 <platform_is_msm8996sg>
8f61a470:	e3500000 	cmp	r0, #0
8f61a474:	1a00004a 	bne	8f61a5a4 <qusb2_phy_reset+0x1c4>
			writel(0xD0, QUSB2PHY_PORT_TUNE1);
		else
			writel(0xF8, QUSB2PHY_PORT_TUNE1);
8f61a478:	e3a03a79 	mov	r3, #495616	; 0x79000
8f61a47c:	e3a020f8 	mov	r2, #248	; 0xf8
8f61a480:	e5832080 	str	r2, [r3, #128]	; 0x80
		 * otherwise use the default value
		 */
		if (fuse_val)
			tune2 = (tune2 & 0x0f) | (fuse_val << 4);
#endif
		writel(tune2, QUSB2PHY_PORT_TUNE2);
8f61a484:	e3a04a79 	mov	r4, #495616	; 0x79000
		writel(0x83, QUSB2PHY_PORT_TUNE3);
8f61a488:	e3a02083 	mov	r2, #131	; 0x83
		writel(tune2, QUSB2PHY_PORT_TUNE2);
8f61a48c:	e3a030b3 	mov	r3, #179	; 0xb3
8f61a490:	e5843084 	str	r3, [r4, #132]	; 0x84
		writel(0xC0, QUSB2PHY_PORT_TUNE4);
8f61a494:	e3a030c0 	mov	r3, #192	; 0xc0
		writel(0x83, QUSB2PHY_PORT_TUNE3);
8f61a498:	e5842088 	str	r2, [r4, #136]	; 0x88
		writel(0xC0, QUSB2PHY_PORT_TUNE4);
8f61a49c:	e584308c 	str	r3, [r4, #140]	; 0x8c
		if(platform_is_msm8996sg())
8f61a4a0:	ebffff9b 	bl	8f61a314 <platform_is_msm8996sg>
			writel(0x02, QUSB2PHY_PORT_TUNE5);
		writel(0x30, QUSB2PHY_PLL_TUNE);
8f61a4a4:	e3a01030 	mov	r1, #48	; 0x30
		writel(0x79, QUSB2PHY_PLL_USER_CTL1);
8f61a4a8:	e3a02079 	mov	r2, #121	; 0x79
		if(platform_is_msm8996sg())
8f61a4ac:	e3500000 	cmp	r0, #0
			writel(0x02, QUSB2PHY_PORT_TUNE5);
8f61a4b0:	13a03002 	movne	r3, #2
8f61a4b4:	15843090 	strne	r3, [r4, #144]	; 0x90
		writel(0x30, QUSB2PHY_PLL_TUNE);
8f61a4b8:	e3a03a79 	mov	r3, #495616	; 0x79000
8f61a4bc:	e5831008 	str	r1, [r3, #8]
		writel(0x21, QUSB2PHY_PLL_USER_CTL2);
8f61a4c0:	e3a01021 	mov	r1, #33	; 0x21
		writel(0x79, QUSB2PHY_PLL_USER_CTL1);
8f61a4c4:	e583200c 	str	r2, [r3, #12]
		writel(0x14, QUSB2PHY_PORT_TEST2);
8f61a4c8:	e3a02014 	mov	r2, #20
		writel(0x21, QUSB2PHY_PLL_USER_CTL2);
8f61a4cc:	e5831010 	str	r1, [r3, #16]
		writel(0x9F, QUSB2PHY_PLL_AUTOPGM_CTL1);
8f61a4d0:	e3a0109f 	mov	r1, #159	; 0x9f
		writel(0x14, QUSB2PHY_PORT_TEST2);
8f61a4d4:	e583209c 	str	r2, [r3, #156]	; 0x9c
		writel(0x00, QUSB2PHY_PLL_PWR_CTL);
8f61a4d8:	e3a02000 	mov	r2, #0
		writel(0x9F, QUSB2PHY_PLL_AUTOPGM_CTL1);
8f61a4dc:	e583101c 	str	r1, [r3, #28]
		writel(0x00, QUSB2PHY_PLL_PWR_CTL);
8f61a4e0:	e5832018 	str	r2, [r3, #24]

		writel(0x85, QUSB2PHY_PORT_TUNE4);
	}

	/* Enable ULPI mode */
	if (platform_is_msm8994())
8f61a4e4:	ebffff68 	bl	8f61a28c <platform_is_msm8994>
8f61a4e8:	e3500000 	cmp	r0, #0
		writel(0x0,  QUSB2PHY_PORT_UTMI_CTRL2);
8f61a4ec:	13a03a79 	movne	r3, #495616	; 0x79000
8f61a4f0:	13a02000 	movne	r2, #0
8f61a4f4:	158320c4 	strne	r2, [r3, #196]	; 0xc4

	/* set CLAMP_N_EN and USB PHY is enabled*/
	if (platform_is_sdx20()){
8f61a4f8:	ebffffa7 	bl	8f61a39c <platform_is_sdx20>
		writel(0x22, QUSB2PHY_PWR_CTRL1_SDX20);
8f61a4fc:	e3a03a79 	mov	r3, #495616	; 0x79000
	if (platform_is_sdx20()){
8f61a500:	e3500000 	cmp	r0, #0
		writel(0x22, QUSB2PHY_PWR_CTRL1_SDX20);
8f61a504:	13a01022 	movne	r1, #34	; 0x22
		writel(0x04, QUSB2PHY_DEBUG_CTRL2_SDX20);
8f61a508:	13a02004 	movne	r2, #4
		udelay(88);
	}
	else{
		writel(0x22, QUSB2PHY_PORT_POWERDOWN);
8f61a50c:	03a02022 	moveq	r2, #34	; 0x22
		writel(0x22, QUSB2PHY_PWR_CTRL1_SDX20);
8f61a510:	15831210 	strne	r1, [r3, #528]	; 0x210
		udelay(88);
8f61a514:	13a00058 	movne	r0, #88	; 0x58
		udelay(150);
8f61a518:	03a00096 	moveq	r0, #150	; 0x96
		writel(0x04, QUSB2PHY_DEBUG_CTRL2_SDX20);
8f61a51c:	15832278 	strne	r2, [r3, #632]	; 0x278
		writel(0x22, QUSB2PHY_PORT_POWERDOWN);
8f61a520:	058320b4 	streq	r2, [r3, #180]	; 0xb4
		udelay(150);
8f61a524:	ebffd20c 	bl	8f60ed5c <udelay>
	}

	/* By default consider differential clock configuration and if TCSR
	 * register bit 0 is not set then use single ended setting
	 */
	if (se_clock)
8f61a528:	e3550000 	cmp	r5, #0
8f61a52c:	1a000020 	bne	8f61a5b4 <qusb2_phy_reset+0x1d4>
#if GCC_RX2_USB2_CLKREF_EN
		writel((readl(GCC_RX2_USB2_CLKREF_EN) | 0x1), GCC_RX2_USB2_CLKREF_EN);
		dmb();
#endif
	}
	udelay(100);
8f61a530:	e3a00064 	mov	r0, #100	; 0x64

	/* Check PLL status */
	if (platform_is_sdx20()){
8f61a534:	e3095298 	movw	r5, #37528	; 0x9298
	udelay(100);
8f61a538:	ebffd207 	bl	8f60ed5c <udelay>
	if (platform_is_sdx20()){
8f61a53c:	e3405007 	movt	r5, #7
8f61a540:	ebffff95 	bl	8f61a39c <platform_is_sdx20>
8f61a544:	e3093038 	movw	r3, #36920	; 0x9038
8f61a548:	e3403007 	movt	r3, #7
8f61a54c:	e3500000 	cmp	r0, #0
8f61a550:	01a05003 	moveq	r5, r3
	}
	else{
		status_reg = QUSB2PHY_PLL_STATUS;
	}

	while (!(readl(status_reg) & QUSB2PHY_PLL_LOCK))
8f61a554:	e5953000 	ldr	r3, [r5]
8f61a558:	e3130020 	tst	r3, #32
8f61a55c:	03a04063 	moveq	r4, #99	; 0x63
8f61a560:	0a000002 	beq	8f61a570 <qusb2_phy_reset+0x190>
8f61a564:	ea000006 	b	8f61a584 <qusb2_phy_reset+0x1a4>
	{
		retry--;
		if (!retry)
8f61a568:	e2544001 	subs	r4, r4, #1
8f61a56c:	0a000033 	beq	8f61a640 <qusb2_phy_reset+0x260>
		{
			dprintf(CRITICAL, "QUSB2PHY failed to lock: %d", readl(QUSB2PHY_PLL_STATUS));
			break;
		}
		/* As per recommendation form hw team wait for 5 us before reading the status */
		udelay(5);
8f61a570:	e3a00005 	mov	r0, #5
8f61a574:	ebffd1f8 	bl	8f60ed5c <udelay>
	while (!(readl(status_reg) & QUSB2PHY_PLL_LOCK))
8f61a578:	e5953000 	ldr	r3, [r5]
8f61a57c:	e3130020 	tst	r3, #32
8f61a580:	0afffff8 	beq	8f61a568 <qusb2_phy_reset+0x188>
	}
}
8f61a584:	e59f3110 	ldr	r3, [pc, #272]	; 8f61a69c <qusb2_phy_reset+0x2bc>
8f61a588:	e5932000 	ldr	r2, [r3]
8f61a58c:	e59d3004 	ldr	r3, [r13, #4]
8f61a590:	e0332002 	eors	r2, r3, r2
8f61a594:	e3a03000 	mov	r3, #0
8f61a598:	1a00003e 	bne	8f61a698 <qusb2_phy_reset+0x2b8>
8f61a59c:	e28dd00c 	add	r13, r13, #12
8f61a5a0:	e8bd8030 	pop	{r4, r5, r15}
			writel(0xD0, QUSB2PHY_PORT_TUNE1);
8f61a5a4:	e3a03a79 	mov	r3, #495616	; 0x79000
8f61a5a8:	e3a020d0 	mov	r2, #208	; 0xd0
8f61a5ac:	e5832080 	str	r2, [r3, #128]	; 0x80
8f61a5b0:	eaffffb3 	b	8f61a484 <qusb2_phy_reset+0xa4>
		if(!platform_is_sdx20())
8f61a5b4:	ebffff78 	bl	8f61a39c <platform_is_sdx20>
8f61a5b8:	e3500000 	cmp	r0, #0
			writel(0x80, QUSB2PHY_PLL_TEST);
8f61a5bc:	03a03a79 	moveq	r3, #495616	; 0x79000
8f61a5c0:	03a02080 	moveq	r2, #128	; 0x80
8f61a5c4:	05832004 	streq	r2, [r3, #4]
8f61a5c8:	eaffffd8 	b	8f61a530 <qusb2_phy_reset+0x150>
	if (platform_is_msm8996() || platform_is_mdm9650() || platform_is_msm8953())
8f61a5cc:	ebff9cae 	bl	8f60188c <platform_is_msm8953>
8f61a5d0:	e3500000 	cmp	r0, #0
8f61a5d4:	1affffa4 	bne	8f61a46c <qusb2_phy_reset+0x8c>
	else if (platform_is_sdx20())
8f61a5d8:	ebffff6f 	bl	8f61a39c <platform_is_sdx20>
			writel(0x03, QUSB2PHY_PLL_ANALOG_CONTROLS_TWO_SDX20);
8f61a5dc:	e3a03a79 	mov	r3, #495616	; 0x79000
	else if (platform_is_sdx20())
8f61a5e0:	e3500000 	cmp	r0, #0
8f61a5e4:	0a000022 	beq	8f61a674 <qusb2_phy_reset+0x294>
		if (se_clock)
8f61a5e8:	e3550000 	cmp	r5, #0
		writel(0x7C, QUSB2PHY_PLL_CLOCK_INVERTERS_SDX20);
8f61a5ec:	e3a0107c 	mov	r1, #124	; 0x7c
			writel(0x03, QUSB2PHY_PLL_ANALOG_CONTROLS_TWO_SDX20);
8f61a5f0:	13a02003 	movne	r2, #3
			writel(0x13, QUSB2PHY_PLL_ANALOG_CONTROLS_TWO_SDX20);
8f61a5f4:	03a02013 	moveq	r2, #19
8f61a5f8:	e5832004 	str	r2, [r3, #4]
		writel(0x7C, QUSB2PHY_PLL_CLOCK_INVERTERS_SDX20);
8f61a5fc:	e3a03a79 	mov	r3, #495616	; 0x79000
8f61a600:	e583118c 	str	r1, [r3, #396]	; 0x18c
		writel(0x80, QUSB2PHY_PLL_CMODE_SDX20);
8f61a604:	e3a02080 	mov	r2, #128	; 0x80
		writel(0x0a, QUSB2PHY_PLL_LOCK_DELAY_SDX20);
8f61a608:	e3a0100a 	mov	r1, #10
		writel(0x80, QUSB2PHY_PLL_CMODE_SDX20);
8f61a60c:	e583202c 	str	r2, [r3, #44]	; 0x2c
		writel(0x0a, QUSB2PHY_PLL_LOCK_DELAY_SDX20);
8f61a610:	e5831090 	str	r1, [r3, #144]	; 0x90
		writel(0x19, QUSB2PHY_PLL_DIGITAL_TIMERS_TWO_SDX20);
8f61a614:	e3a02019 	mov	r2, #25
		writel(0xa5, QUSB2PHY_TUNE1_SDX20);
8f61a618:	e3a010a5 	mov	r1, #165	; 0xa5
		writel(0x19, QUSB2PHY_PLL_DIGITAL_TIMERS_TWO_SDX20);
8f61a61c:	e58320b4 	str	r2, [r3, #180]	; 0xb4
		writel(0xa5, QUSB2PHY_TUNE1_SDX20);
8f61a620:	e583123c 	str	r1, [r3, #572]	; 0x23c
		writel(0x09, QUSB2PHY_TUNE2_SDX20);
8f61a624:	e3a02009 	mov	r2, #9
		writel(0x00, QUSB2PHY_IMP_CTRL1_SDX20);
8f61a628:	e3a01000 	mov	r1, #0
		writel(0x09, QUSB2PHY_TUNE2_SDX20);
8f61a62c:	e5832240 	str	r2, [r3, #576]	; 0x240
		writel(0x22, QUSB2PHY_PWR_CTRL1_SDX20);
8f61a630:	e3a02022 	mov	r2, #34	; 0x22
		writel(0x00, QUSB2PHY_IMP_CTRL1_SDX20);
8f61a634:	e583121c 	str	r1, [r3, #540]	; 0x21c
		writel(0x22, QUSB2PHY_PWR_CTRL1_SDX20);
8f61a638:	e5832210 	str	r2, [r3, #528]	; 0x210
8f61a63c:	eaffffa8 	b	8f61a4e4 <qusb2_phy_reset+0x104>
			dprintf(CRITICAL, "QUSB2PHY failed to lock: %d", readl(QUSB2PHY_PLL_STATUS));
8f61a640:	e3a03a79 	mov	r3, #495616	; 0x79000
8f61a644:	e5931038 	ldr	r1, [r3, #56]	; 0x38
8f61a648:	e59f304c 	ldr	r3, [pc, #76]	; 8f61a69c <qusb2_phy_reset+0x2bc>
8f61a64c:	e5932000 	ldr	r2, [r3]
8f61a650:	e59d3004 	ldr	r3, [r13, #4]
8f61a654:	e0332002 	eors	r2, r3, r2
8f61a658:	e3a03000 	mov	r3, #0
8f61a65c:	1a00000d 	bne	8f61a698 <qusb2_phy_reset+0x2b8>
8f61a660:	e3060520 	movw	r0, #25888	; 0x6520
8f61a664:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f61a668:	e28dd00c 	add	r13, r13, #12
8f61a66c:	e8bd4030 	pop	{r4, r5, r14}
			dprintf(CRITICAL, "QUSB2PHY failed to lock: %d", readl(QUSB2PHY_PLL_STATUS));
8f61a670:	ea0060bf 	b	8f632974 <_dprintf>
		writel(0xA0, QUSB2PHY_PORT_TUNE1);
8f61a674:	e3a010a0 	mov	r1, #160	; 0xa0
		writel(0xA5, QUSB2PHY_PORT_TUNE2);
8f61a678:	e3a020a5 	mov	r2, #165	; 0xa5
		writel(0xA0, QUSB2PHY_PORT_TUNE1);
8f61a67c:	e5831080 	str	r1, [r3, #128]	; 0x80
		writel(0x81, QUSB2PHY_PORT_TUNE3);
8f61a680:	e3a01081 	mov	r1, #129	; 0x81
		writel(0xA5, QUSB2PHY_PORT_TUNE2);
8f61a684:	e5832084 	str	r2, [r3, #132]	; 0x84
		writel(0x85, QUSB2PHY_PORT_TUNE4);
8f61a688:	e3a02085 	mov	r2, #133	; 0x85
		writel(0x81, QUSB2PHY_PORT_TUNE3);
8f61a68c:	e5831088 	str	r1, [r3, #136]	; 0x88
		writel(0x85, QUSB2PHY_PORT_TUNE4);
8f61a690:	e583208c 	str	r2, [r3, #140]	; 0x8c
8f61a694:	eaffff92 	b	8f61a4e4 <qusb2_phy_reset+0x104>
}
8f61a698:	eb006148 	bl	8f632bc0 <__stack_chk_fail>
8f61a69c:	8f74221c 	.word	0x8f74221c

8f61a6a0 <crypto_initialized>:
 * with the authentication logic in image_verify.c
 */
static struct crypto_dev dev;

#ifdef DISABLE_CRYPTO
bool crypto_initialized() { return false; }
8f61a6a0:	e59f3038 	ldr	r3, [pc, #56]	; 8f61a6e0 <crypto_initialized+0x40>
8f61a6a4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61a6a8:	e24dd00c 	sub	r13, r13, #12
8f61a6ac:	e5933000 	ldr	r3, [r3]
8f61a6b0:	e58d3004 	str	r3, [r13, #4]
8f61a6b4:	e3a03000 	mov	r3, #0
8f61a6b8:	e59f3020 	ldr	r3, [pc, #32]	; 8f61a6e0 <crypto_initialized+0x40>
8f61a6bc:	e5932000 	ldr	r2, [r3]
8f61a6c0:	e59d3004 	ldr	r3, [r13, #4]
8f61a6c4:	e0332002 	eors	r2, r3, r2
8f61a6c8:	e3a03000 	mov	r3, #0
8f61a6cc:	1a000002 	bne	8f61a6dc <crypto_initialized+0x3c>
8f61a6d0:	e3a00000 	mov	r0, #0
8f61a6d4:	e28dd00c 	add	r13, r13, #12
8f61a6d8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61a6dc:	eb006137 	bl	8f632bc0 <__stack_chk_fail>
8f61a6e0:	8f74221c 	.word	0x8f74221c

8f61a6e4 <crypto_init_params>:
8f61a6e4:	e59f3034 	ldr	r3, [pc, #52]	; 8f61a720 <crypto_init_params+0x3c>
8f61a6e8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61a6ec:	e24dd00c 	sub	r13, r13, #12
8f61a6f0:	e5933000 	ldr	r3, [r3]
8f61a6f4:	e58d3004 	str	r3, [r13, #4]
8f61a6f8:	e3a03000 	mov	r3, #0
8f61a6fc:	e59f301c 	ldr	r3, [pc, #28]	; 8f61a720 <crypto_init_params+0x3c>
8f61a700:	e5932000 	ldr	r2, [r3]
8f61a704:	e59d3004 	ldr	r3, [r13, #4]
8f61a708:	e0332002 	eors	r2, r3, r2
8f61a70c:	e3a03000 	mov	r3, #0
8f61a710:	1a000001 	bne	8f61a71c <crypto_init_params+0x38>
8f61a714:	e28dd00c 	add	r13, r13, #12
8f61a718:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61a71c:	eb006127 	bl	8f632bc0 <__stack_chk_fail>
8f61a720:	8f74221c 	.word	0x8f74221c

8f61a724 <crypto_eng_cleanup>:
8f61a724:	e59f3034 	ldr	r3, [pc, #52]	; 8f61a760 <crypto_eng_cleanup+0x3c>
8f61a728:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61a72c:	e24dd00c 	sub	r13, r13, #12
8f61a730:	e5933000 	ldr	r3, [r3]
8f61a734:	e58d3004 	str	r3, [r13, #4]
8f61a738:	e3a03000 	mov	r3, #0
8f61a73c:	e59f301c 	ldr	r3, [pc, #28]	; 8f61a760 <crypto_eng_cleanup+0x3c>
8f61a740:	e5932000 	ldr	r2, [r3]
8f61a744:	e59d3004 	ldr	r3, [r13, #4]
8f61a748:	e0332002 	eors	r2, r3, r2
8f61a74c:	e3a03000 	mov	r3, #0
8f61a750:	1a000001 	bne	8f61a75c <crypto_eng_cleanup+0x38>
8f61a754:	e28dd00c 	add	r13, r13, #12
8f61a758:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61a75c:	eb006117 	bl	8f632bc0 <__stack_chk_fail>
8f61a760:	8f74221c 	.word	0x8f74221c

8f61a764 <mdss_mdp_set_flush>:
	}
}

static void mdss_mdp_set_flush(struct msm_panel_info *pinfo,
				uint32_t *ctl0_reg_val, uint32_t *ctl1_reg_val)
{
8f61a764:	e92d4010 	push	{r4, r14}
8f61a768:	e24dd008 	sub	r13, r13, #8
	uint32_t mdss_mdp_rev = readl(MDP_HW_REV);
	bool dual_pipe_single_ctl = pinfo->lcdc.dual_pipe &&
		!pinfo->mipi.dual_dsi && !pinfo->lcdc.split_display;
8f61a76c:	e5d0c094 	ldrb	r12, [r0, #148]	; 0x94
	uint32_t mdss_mdp_rev = readl(MDP_HW_REV);
8f61a770:	e3a03a01 	mov	r3, #4096	; 0x1000
{
8f61a774:	e59fe1f8 	ldr	r14, [pc, #504]	; 8f61a974 <mdss_mdp_set_flush+0x210>
	uint32_t mdss_mdp_rev = readl(MDP_HW_REV);
8f61a778:	e34031a0 	movt	r3, #416	; 0x1a0
		!pinfo->mipi.dual_dsi && !pinfo->lcdc.split_display;
8f61a77c:	e35c0000 	cmp	r12, #0
{
8f61a780:	e59ee000 	ldr	r14, [r14]
8f61a784:	e58de004 	str	r14, [r13, #4]
8f61a788:	e3a0e000 	mov	r14, #0
	uint32_t mdss_mdp_rev = readl(MDP_HW_REV);
8f61a78c:	e5933000 	ldr	r3, [r3]
		!pinfo->mipi.dual_dsi && !pinfo->lcdc.split_display;
8f61a790:	0a000002 	beq	8f61a7a0 <mdss_mdp_set_flush+0x3c>
	bool dual_pipe_single_ctl = pinfo->lcdc.dual_pipe &&
8f61a794:	e5d0c28b 	ldrb	r12, [r0, #651]	; 0x28b
8f61a798:	e35c0000 	cmp	r12, #0
8f61a79c:	0a00004a 	beq	8f61a8cc <mdss_mdp_set_flush+0x168>
	switch (pinfo->pipe_type) {
8f61a7a0:	e590c024 	ldr	r12, [r0, #36]	; 0x24
8f61a7a4:	e35c0001 	cmp	r12, #1
8f61a7a8:	0a000052 	beq	8f61a8f8 <mdss_mdp_set_flush+0x194>
8f61a7ac:	e35c0002 	cmp	r12, #2
8f61a7b0:	0a00005c 	beq	8f61a928 <mdss_mdp_set_flush+0x1c4>
8f61a7b4:	e302c041 	movw	r12, #8257	; 0x2041
8f61a7b8:	e340c002 	movt	r12, #2
8f61a7bc:	e581c000 	str	r12, [r1]
		default:
			if (dual_pipe_single_ctl)
				*ctl0_reg_val = 0x220C3;
			else
				*ctl0_reg_val = 0x22041;
			*ctl1_reg_val = 0x24082;
8f61a7c0:	e304c082 	movw	r12, #16514	; 0x4082
8f61a7c4:	e340c002 	movt	r12, #2
8f61a7c8:	e582c000 	str	r12, [r2]
			if (pinfo->lcdc.dst_split)
8f61a7cc:	e5d0c097 	ldrb	r12, [r0, #151]	; 0x97
8f61a7d0:	e35c0000 	cmp	r12, #0
				*ctl0_reg_val |= BIT(1);
8f61a7d4:	1591c000 	ldrne	r12, [r1]
8f61a7d8:	138cc002 	orrne	r12, r12, #2
8f61a7dc:	1581c000 	strne	r12, [r1]
			break;
	}
	/* For targets from MDP v1.5, MDP INTF registers are double buffered */
	if ((mdss_mdp_rev == MDSS_MDP_HW_REV_106) ||
		(mdss_mdp_rev == MDSS_MDP_HW_REV_108) ||
8f61a7e0:	e3c34701 	bic	r4, r3, #262144	; 0x40000
	if ((mdss_mdp_rev == MDSS_MDP_HW_REV_106) ||
8f61a7e4:	e3a0e000 	mov	r14, #0
		(mdss_mdp_rev == MDSS_MDP_HW_REV_108) ||
8f61a7e8:	e3a0c000 	mov	r12, #0
	if ((mdss_mdp_rev == MDSS_MDP_HW_REV_106) ||
8f61a7ec:	e341e006 	movt	r14, #4102	; 0x1006
		(mdss_mdp_rev == MDSS_MDP_HW_REV_108) ||
8f61a7f0:	e341c008 	movt	r12, #4104	; 0x1008
	if ((mdss_mdp_rev == MDSS_MDP_HW_REV_106) ||
8f61a7f4:	e154000c 	cmp	r4, r12
8f61a7f8:	1153000e 	cmpne	r3, r14
8f61a7fc:	0a000003 	beq	8f61a810 <mdss_mdp_set_flush+0xac>
		(mdss_mdp_rev == MDSS_MDP_HW_REV_111) ||
8f61a800:	e3a0c000 	mov	r12, #0
8f61a804:	e341c00b 	movt	r12, #4107	; 0x100b
8f61a808:	e153000c 	cmp	r3, r12
8f61a80c:	1a000013 	bne	8f61a860 <mdss_mdp_set_flush+0xfc>
		(mdss_mdp_rev == MDSS_MDP_HW_REV_112)) {
		if (pinfo->dest == DISPLAY_2) {
8f61a810:	e590301c 	ldr	r3, [r0, #28]
8f61a814:	e3530002 	cmp	r3, #2
			*ctl0_reg_val |= BIT(31);
8f61a818:	e5913000 	ldr	r3, [r1]
8f61a81c:	03833102 	orreq	r3, r3, #-2147483648	; 0x80000000
			*ctl1_reg_val |= BIT(30);
		} else {
			*ctl0_reg_val |= BIT(30);
8f61a820:	13833101 	orrne	r3, r3, #1073741824	; 0x40000000
			*ctl0_reg_val |= BIT(31);
8f61a824:	05813000 	streq	r3, [r1]
			*ctl0_reg_val |= BIT(30);
8f61a828:	15813000 	strne	r3, [r1]
			*ctl1_reg_val |= BIT(30);
8f61a82c:	05923000 	ldreq	r3, [r2]
			*ctl1_reg_val |= BIT(31);
8f61a830:	15923000 	ldrne	r3, [r2]
			*ctl1_reg_val |= BIT(30);
8f61a834:	03833101 	orreq	r3, r3, #1073741824	; 0x40000000
			*ctl1_reg_val |= BIT(31);
8f61a838:	13833102 	orrne	r3, r3, #-2147483648	; 0x80000000
8f61a83c:	e5823000 	str	r3, [r2]
		} else {
			*ctl0_reg_val |= BIT(30);
			*ctl1_reg_val |= BIT(29);
		}
	}
}
8f61a840:	e59f312c 	ldr	r3, [pc, #300]	; 8f61a974 <mdss_mdp_set_flush+0x210>
8f61a844:	e5932000 	ldr	r2, [r3]
8f61a848:	e59d3004 	ldr	r3, [r13, #4]
8f61a84c:	e0332002 	eors	r2, r3, r2
8f61a850:	e3a03000 	mov	r3, #0
8f61a854:	1a00003f 	bne	8f61a958 <mdss_mdp_set_flush+0x1f4>
8f61a858:	e28dd008 	add	r13, r13, #8
8f61a85c:	e8bd8010 	pop	{r4, r15}
	} else if ((mdss_mdp_rev == MDSS_MDP_HW_REV_105) ||
8f61a860:	e283c4ef 	add	r12, r3, #-285212672	; 0xef000000
8f61a864:	e28ce8fb 	add	r14, r12, #16449536	; 0xfb0000
8f61a868:	e3dee701 	bics	r14, r14, #262144	; 0x40000
8f61a86c:	0a000009 	beq	8f61a898 <mdss_mdp_set_flush+0x134>
		(mdss_mdp_rev == MDSS_MDP_HW_REV_109) ||
8f61a870:	e301e007 	movw	r14, #4103	; 0x1007
8f61a874:	e15e0823 	cmp	r14, r3, lsr #16
8f61a878:	0a000006 	beq	8f61a898 <mdss_mdp_set_flush+0x134>
		(mdss_mdp_rev == MDSS_MDP_HW_REV_115) ||
8f61a87c:	e28cc8f1 	add	r12, r12, #15794176	; 0xf10000
		(mdss_mdp_rev == MDSS_MDP_HW_REV_110)) {
8f61a880:	e3a03000 	mov	r3, #0
		(mdss_mdp_rev == MDSS_MDP_HW_REV_115) ||
8f61a884:	e3ccc801 	bic	r12, r12, #65536	; 0x10000
		(mdss_mdp_rev == MDSS_MDP_HW_REV_110)) {
8f61a888:	e341300a 	movt	r3, #4106	; 0x100a
		(mdss_mdp_rev == MDSS_MDP_HW_REV_115) ||
8f61a88c:	e35c0000 	cmp	r12, #0
8f61a890:	11540003 	cmpne	r4, r3
8f61a894:	1affffe9 	bne	8f61a840 <mdss_mdp_set_flush+0xdc>
		if (pinfo->dest == DISPLAY_2) {
8f61a898:	e590301c 	ldr	r3, [r0, #28]
8f61a89c:	e3530002 	cmp	r3, #2
			*ctl0_reg_val |= BIT(29);
8f61a8a0:	e5913000 	ldr	r3, [r1]
8f61a8a4:	03833202 	orreq	r3, r3, #536870912	; 0x20000000
			*ctl0_reg_val |= BIT(30);
8f61a8a8:	13833101 	orrne	r3, r3, #1073741824	; 0x40000000
			*ctl0_reg_val |= BIT(29);
8f61a8ac:	05813000 	streq	r3, [r1]
			*ctl0_reg_val |= BIT(30);
8f61a8b0:	15813000 	strne	r3, [r1]
			*ctl1_reg_val |= BIT(30);
8f61a8b4:	05923000 	ldreq	r3, [r2]
			*ctl1_reg_val |= BIT(29);
8f61a8b8:	15923000 	ldrne	r3, [r2]
			*ctl1_reg_val |= BIT(30);
8f61a8bc:	03833101 	orreq	r3, r3, #1073741824	; 0x40000000
			*ctl1_reg_val |= BIT(29);
8f61a8c0:	13833202 	orrne	r3, r3, #536870912	; 0x20000000
8f61a8c4:	e5823000 	str	r3, [r2]
}
8f61a8c8:	eaffffdc 	b	8f61a840 <mdss_mdp_set_flush+0xdc>
		!pinfo->mipi.dual_dsi && !pinfo->lcdc.split_display;
8f61a8cc:	e5d0c095 	ldrb	r12, [r0, #149]	; 0x95
8f61a8d0:	e35c0000 	cmp	r12, #0
8f61a8d4:	1affffb1 	bne	8f61a7a0 <mdss_mdp_set_flush+0x3c>
	switch (pinfo->pipe_type) {
8f61a8d8:	e590c024 	ldr	r12, [r0, #36]	; 0x24
8f61a8dc:	e35c0001 	cmp	r12, #1
8f61a8e0:	0a000020 	beq	8f61a968 <mdss_mdp_set_flush+0x204>
8f61a8e4:	e35c0002 	cmp	r12, #2
8f61a8e8:	0a00001b 	beq	8f61a95c <mdss_mdp_set_flush+0x1f8>
8f61a8ec:	e302c0c3 	movw	r12, #8387	; 0x20c3
8f61a8f0:	e340c002 	movt	r12, #2
8f61a8f4:	eaffffb0 	b	8f61a7bc <mdss_mdp_set_flush+0x58>
8f61a8f8:	e302c048 	movw	r12, #8264	; 0x2048
8f61a8fc:	e340c002 	movt	r12, #2
8f61a900:	e581c000 	str	r12, [r1]
			*ctl1_reg_val = 0x24090;
8f61a904:	e304c090 	movw	r12, #16528	; 0x4090
8f61a908:	e340c002 	movt	r12, #2
8f61a90c:	e582c000 	str	r12, [r2]
			if (pinfo->lcdc.dst_split)
8f61a910:	e5d0c097 	ldrb	r12, [r0, #151]	; 0x97
8f61a914:	e35c0000 	cmp	r12, #0
				*ctl0_reg_val |= BIT(4);
8f61a918:	1591c000 	ldrne	r12, [r1]
8f61a91c:	138cc010 	orrne	r12, r12, #16
8f61a920:	1581c000 	strne	r12, [r1]
8f61a924:	eaffffad 	b	8f61a7e0 <mdss_mdp_set_flush+0x7c>
	switch (pinfo->pipe_type) {
8f61a928:	e3a0cda1 	mov	r12, #10304	; 0x2840
8f61a92c:	e340c002 	movt	r12, #2
8f61a930:	e581c000 	str	r12, [r1]
			*ctl1_reg_val = 0x25080;
8f61a934:	e305c080 	movw	r12, #20608	; 0x5080
8f61a938:	e340c002 	movt	r12, #2
8f61a93c:	e582c000 	str	r12, [r2]
			if (pinfo->lcdc.dst_split)
8f61a940:	e5d0c097 	ldrb	r12, [r0, #151]	; 0x97
8f61a944:	e35c0000 	cmp	r12, #0
				*ctl0_reg_val |= BIT(12);
8f61a948:	1591c000 	ldrne	r12, [r1]
8f61a94c:	138cca01 	orrne	r12, r12, #4096	; 0x1000
8f61a950:	1581c000 	strne	r12, [r1]
8f61a954:	eaffffa1 	b	8f61a7e0 <mdss_mdp_set_flush+0x7c>
}
8f61a958:	eb006098 	bl	8f632bc0 <__stack_chk_fail>
	switch (pinfo->pipe_type) {
8f61a95c:	e3a0cde3 	mov	r12, #14528	; 0x38c0
8f61a960:	e340c002 	movt	r12, #2
8f61a964:	eafffff1 	b	8f61a930 <mdss_mdp_set_flush+0x1cc>
8f61a968:	e302c0d8 	movw	r12, #8408	; 0x20d8
8f61a96c:	e340c002 	movt	r12, #2
8f61a970:	eaffffe2 	b	8f61a900 <mdss_mdp_set_flush+0x19c>
8f61a974:	8f74221c 	.word	0x8f74221c

8f61a978 <mdp_dma_on>:
			MDP_REG_PP_1_AUTOREFRESH_CONFIG);
	dsb();
}

int mdp_dma_on(struct msm_panel_info *pinfo)
{
8f61a978:	e92d4070 	push	{r4, r5, r6, r14}
8f61a97c:	e24dd010 	sub	r13, r13, #16
8f61a980:	e59f3194 	ldr	r3, [pc, #404]	; 8f61ab1c <mdp_dma_on+0x1a4>
	uint32_t ctl0_reg_val, ctl1_reg_val;
	mdss_mdp_set_flush(pinfo, &ctl0_reg_val, &ctl1_reg_val);
8f61a984:	e28d2008 	add	r2, r13, #8
8f61a988:	e28d1004 	add	r1, r13, #4
{
8f61a98c:	e1a04000 	mov	r4, r0
8f61a990:	e5933000 	ldr	r3, [r3]
8f61a994:	e58d300c 	str	r3, [r13, #12]
8f61a998:	e3a03000 	mov	r3, #0
	mdss_mdp_set_flush(pinfo, &ctl0_reg_val, &ctl1_reg_val);
8f61a99c:	ebffff70 	bl	8f61a764 <mdss_mdp_set_flush>
	writel(ctl0_reg_val, MDP_CTL_0_BASE + CTL_FLUSH);
8f61a9a0:	e59d2004 	ldr	r2, [r13, #4]
8f61a9a4:	e3a03a02 	mov	r3, #8192	; 0x2000
8f61a9a8:	e34031a0 	movt	r3, #416	; 0x1a0
8f61a9ac:	e5832018 	str	r2, [r3, #24]
	if (pinfo->lcdc.dual_pipe && !pinfo->lcdc.dst_split)
8f61a9b0:	e5d45094 	ldrb	r5, [r4, #148]	; 0x94
8f61a9b4:	e3550000 	cmp	r5, #0
8f61a9b8:	0a000002 	beq	8f61a9c8 <mdp_dma_on+0x50>
8f61a9bc:	e5d42097 	ldrb	r2, [r4, #151]	; 0x97
8f61a9c0:	e3520000 	cmp	r2, #0
8f61a9c4:	0a00000f 	beq	8f61aa08 <mdp_dma_on+0x90>
		writel(ctl1_reg_val, MDP_CTL_1_BASE + CTL_FLUSH);

        if (pinfo->autorefresh_enable)
8f61a9c8:	e5d43530 	ldrb	r3, [r4, #1328]	; 0x530
8f61a9cc:	e3530000 	cmp	r3, #0
8f61a9d0:	1a000011 	bne	8f61aa1c <mdp_dma_on+0xa4>
		mdp_set_cmd_autorefresh_mode(pinfo);
	writel(0x01, MDP_CTL_0_BASE + CTL_START);
8f61a9d4:	e3a03a02 	mov	r3, #8192	; 0x2000
8f61a9d8:	e34031a0 	movt	r3, #416	; 0x1a0
8f61a9dc:	e3a02001 	mov	r2, #1
8f61a9e0:	e583201c 	str	r2, [r3, #28]

        return NO_ERROR;
}
8f61a9e4:	e59f3130 	ldr	r3, [pc, #304]	; 8f61ab1c <mdp_dma_on+0x1a4>
8f61a9e8:	e5932000 	ldr	r2, [r3]
8f61a9ec:	e59d300c 	ldr	r3, [r13, #12]
8f61a9f0:	e0332002 	eors	r2, r3, r2
8f61a9f4:	e3a03000 	mov	r3, #0
8f61a9f8:	1a000046 	bne	8f61ab18 <mdp_dma_on+0x1a0>
8f61a9fc:	e3a00000 	mov	r0, #0
8f61aa00:	e28dd010 	add	r13, r13, #16
8f61aa04:	e8bd8070 	pop	{r4, r5, r6, r15}
		writel(ctl1_reg_val, MDP_CTL_1_BASE + CTL_FLUSH);
8f61aa08:	e59d2008 	ldr	r2, [r13, #8]
8f61aa0c:	e5832218 	str	r2, [r3, #536]	; 0x218
        if (pinfo->autorefresh_enable)
8f61aa10:	e5d43530 	ldrb	r3, [r4, #1328]	; 0x530
8f61aa14:	e3530000 	cmp	r3, #0
8f61aa18:	0affffed 	beq	8f61a9d4 <mdp_dma_on+0x5c>
	if (!pinfo || (pinfo->type != MIPI_CMD_PANEL) ||
8f61aa1c:	e594300c 	ldr	r3, [r4, #12]
8f61aa20:	e3530009 	cmp	r3, #9
8f61aa24:	1affffea 	bne	8f61a9d4 <mdp_dma_on+0x5c>
	total_lines = pinfo->lcdc.v_front_porch +
8f61aa28:	e5942074 	ldr	r2, [r4, #116]	; 0x74
8f61aa2c:	e5941078 	ldr	r1, [r4, #120]	; 0x78
			pinfo->lcdc.v_back_porch +
8f61aa30:	e594307c 	ldr	r3, [r4, #124]	; 0x7c
	total_lines = pinfo->lcdc.v_front_porch +
8f61aa34:	e0811002 	add	r1, r1, r2
	total_lines *= pinfo->mipi.frame_rate;
8f61aa38:	e5d4627b 	ldrb	r6, [r4, #635]	; 0x27b
			pinfo->lcdc.v_back_porch +
8f61aa3c:	e0811003 	add	r1, r1, r3
			pinfo->border_top + pinfo->border_bottom +
8f61aa40:	e1c422dc 	ldrd	r2, [r4, #44]	; 0x2c
			pinfo->lcdc.v_pulse_width +
8f61aa44:	e0811002 	add	r1, r1, r2
			pinfo->border_top + pinfo->border_bottom +
8f61aa48:	e0811003 	add	r1, r1, r3
	total_lines = pinfo->lcdc.v_front_porch +
8f61aa4c:	e5943004 	ldr	r3, [r4, #4]
8f61aa50:	e0811003 	add	r1, r1, r3
	total_lines *= pinfo->mipi.frame_rate;
8f61aa54:	e0010196 	mul	r1, r6, r1
	vclks_line = (total_lines) ? 19200000 / total_lines : 0;
8f61aa58:	e3510000 	cmp	r1, #0
8f61aa5c:	03a03702 	moveq	r3, #524288	; 0x80000
8f61aa60:	0a00000a 	beq	8f61aa90 <mdp_dma_on+0x118>
8f61aa64:	e3a00b3e 	mov	r0, #63488	; 0xf800
8f61aa68:	e3400124 	movt	r0, #292	; 0x124
8f61aa6c:	fa008859 	blx	8f63cbd8 <__udivsi3>
	vclks_line = vclks_line * pinfo->mipi.frame_rate * 100 / 6000;
8f61aa70:	e3a01064 	mov	r1, #100	; 0x64
8f61aa74:	e30129f1 	movw	r2, #6641	; 0x19f1
8f61aa78:	e3402576 	movt	r2, #1398	; 0x576
8f61aa7c:	e0030096 	mul	r3, r6, r0
8f61aa80:	e0030391 	mul	r3, r1, r3
8f61aa84:	e0832392 	umull	r2, r3, r2, r3
8f61aa88:	e1a033a3 	lsr	r3, r3, #7
	cfg = BIT(19) | vclks_line;
8f61aa8c:	e3833702 	orr	r3, r3, #524288	; 0x80000
	writel(cfg, MDP_REG_PP_0_SYNC_CONFIG_VSYNC);
8f61aa90:	e3a02a01 	mov	r2, #4096	; 0x1000
8f61aa94:	e34021a7 	movt	r2, #423	; 0x1a7
8f61aa98:	e5823004 	str	r3, [r2, #4]
	if (pinfo->lcdc.dst_split)
8f61aa9c:	e5d42097 	ldrb	r2, [r4, #151]	; 0x97
8f61aaa0:	e3520000 	cmp	r2, #0
		writel(cfg, MDP_REG_PP_SLAVE_SYNC_CONFIG_VSYNC);
8f61aaa4:	13a02a03 	movne	r2, #12288	; 0x3000
8f61aaa8:	134021a7 	movtne	r2, #423	; 0x1a7
8f61aaac:	15823004 	strne	r3, [r2, #4]
	if (pinfo->lcdc.dual_pipe)
8f61aab0:	e3550000 	cmp	r5, #0
		writel(cfg, MDP_REG_PP_1_SYNC_CONFIG_VSYNC);
8f61aab4:	13a02a01 	movne	r2, #4096	; 0x1000
8f61aab8:	134021a7 	movtne	r2, #423	; 0x1a7
8f61aabc:	15823804 	strne	r3, [r2, #2052]	; 0x804
	dsb();
8f61aac0:	f57ff04f 	dsb	sy
	writel((BIT(31) | pinfo->autorefresh_framenum),
8f61aac4:	e3a02a01 	mov	r2, #4096	; 0x1000
8f61aac8:	e5943534 	ldr	r3, [r4, #1332]	; 0x534
8f61aacc:	e34021a7 	movt	r2, #423	; 0x1a7
8f61aad0:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
8f61aad4:	e5823030 	str	r3, [r2, #48]	; 0x30
	if (pinfo->lcdc.dst_split)
8f61aad8:	e5d43097 	ldrb	r3, [r4, #151]	; 0x97
8f61aadc:	e3530000 	cmp	r3, #0
		writel((BIT(31) | pinfo->autorefresh_framenum),
8f61aae0:	15943534 	ldrne	r3, [r4, #1332]	; 0x534
8f61aae4:	13a02a03 	movne	r2, #12288	; 0x3000
8f61aae8:	134021a7 	movtne	r2, #423	; 0x1a7
8f61aaec:	13833102 	orrne	r3, r3, #-2147483648	; 0x80000000
8f61aaf0:	15823030 	strne	r3, [r2, #48]	; 0x30
	if (pinfo->lcdc.dual_pipe)
8f61aaf4:	e5d43094 	ldrb	r3, [r4, #148]	; 0x94
8f61aaf8:	e3530000 	cmp	r3, #0
		writel((BIT(31) | pinfo->autorefresh_framenum),
8f61aafc:	15943534 	ldrne	r3, [r4, #1332]	; 0x534
8f61ab00:	13a02a01 	movne	r2, #4096	; 0x1000
8f61ab04:	134021a7 	movtne	r2, #423	; 0x1a7
8f61ab08:	13833102 	orrne	r3, r3, #-2147483648	; 0x80000000
8f61ab0c:	15823830 	strne	r3, [r2, #2096]	; 0x830
	dsb();
8f61ab10:	f57ff04f 	dsb	sy
8f61ab14:	eaffffae 	b	8f61a9d4 <mdp_dma_on+0x5c>
}
8f61ab18:	eb006028 	bl	8f632bc0 <__stack_chk_fail>
8f61ab1c:	8f74221c 	.word	0x8f74221c

8f61ab20 <dwc_ep_bulk_state_inactive_enter>:
	dev->ctrl_state = EP_FSM_SETUP;
}

/* entry function into inactive state for data transfer fsm */
static void dwc_ep_bulk_state_inactive_enter(dwc_dev_t *dev, uint8_t ep_phy_num)
{
8f61ab20:	e59f30ec 	ldr	r3, [pc, #236]	; 8f61ac14 <dwc_ep_bulk_state_inactive_enter+0xf4>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61ab24:	e3510007 	cmp	r1, #7
{
8f61ab28:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f61ab2c:	e24dd014 	sub	r13, r13, #20
8f61ab30:	e5933000 	ldr	r3, [r3]
8f61ab34:	e58d300c 	str	r3, [r13, #12]
8f61ab38:	e3a03000 	mov	r3, #0
8f61ab3c:	e1a06001 	mov	r6, r1
8f61ab40:	e1a0700e 	mov	r7, r14
8f61ab44:	e1a04000 	mov	r4, r0
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61ab48:	8a00001a 	bhi	8f61abb8 <dwc_ep_bulk_state_inactive_enter+0x98>
	dwc_ep_t *ep = &dev->ep[DWC_EP_PHY_TO_INDEX(ep_phy_num)];
8f61ab4c:	e3a05f8e 	mov	r5, #568	; 0x238
8f61ab50:	e0050695 	mul	r5, r5, r6
8f61ab54:	e2853008 	add	r3, r5, #8
	ASSERT(ep != NULL);
8f61ab58:	e1740003 	cmn	r4, r3
8f61ab5c:	0a000020 	beq	8f61abe4 <dwc_ep_bulk_state_inactive_enter+0xc4>

	/* queue request to receive the first setup pkt from host */
	ep->req.data     = NULL;
8f61ab60:	e3a01f8e 	mov	r1, #568	; 0x238
8f61ab64:	e0845005 	add	r5, r4, r5
8f61ab68:	e0214691 	mla	r1, r1, r6, r4
8f61ab6c:	e3a03000 	mov	r3, #0
	ep->req.trbctl   = 0;
	ep->req.callback = NULL;
	ep->req.context  = NULL;

	/* inactive state */
	ep->state = EP_STATE_INACTIVE;
8f61ab70:	e3a02001 	mov	r2, #1
	ep->req.data     = NULL;
8f61ab74:	e5813228 	str	r3, [r1, #552]	; 0x228
	ep->req.len      = 0;
8f61ab78:	e581322c 	str	r3, [r1, #556]	; 0x22c
	ep->req.trbctl   = 0;
8f61ab7c:	e5c13230 	strb	r3, [r1, #560]	; 0x230
	ep->req.callback = NULL;
8f61ab80:	e5853238 	str	r3, [r5, #568]	; 0x238
	ep->req.context  = NULL;
8f61ab84:	e5813234 	str	r3, [r1, #564]	; 0x234
	ep->state = EP_STATE_INACTIVE;
8f61ab88:	e5c5223c 	strb	r2, [r5, #572]	; 0x23c

	/* reset the resource index, trb and bytes queued */
	ep->resource_idx = 0;
8f61ab8c:	e5c13216 	strb	r3, [r1, #534]	; 0x216
	ep->trb_queued   = 0;
8f61ab90:	e5813220 	str	r3, [r1, #544]	; 0x220
	ep->bytes_queued = 0;
8f61ab94:	e5813224 	str	r3, [r1, #548]	; 0x224
}
8f61ab98:	e59f3074 	ldr	r3, [pc, #116]	; 8f61ac14 <dwc_ep_bulk_state_inactive_enter+0xf4>
8f61ab9c:	e5932000 	ldr	r2, [r3]
8f61aba0:	e59d300c 	ldr	r3, [r13, #12]
8f61aba4:	e0332002 	eors	r2, r3, r2
8f61aba8:	e3a03000 	mov	r3, #0
8f61abac:	1a000017 	bne	8f61ac10 <dwc_ep_bulk_state_inactive_enter+0xf0>
8f61abb0:	e28dd014 	add	r13, r13, #20
8f61abb4:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61abb8:	e306155c 	movw	r1, #25948	; 0x655c
8f61abbc:	e306253c 	movw	r2, #25916	; 0x653c
8f61abc0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61abc4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61abc8:	e58d1000 	str	r1, [r13]
8f61abcc:	e300360a 	movw	r3, #1546	; 0x60a
8f61abd0:	e3001130 	movw	r1, #304	; 0x130
8f61abd4:	e1a0000e 	mov	r0, r14
8f61abd8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61abdc:	eb005fb6 	bl	8f632abc <_panic>
8f61abe0:	eaffffd9 	b	8f61ab4c <dwc_ep_bulk_state_inactive_enter+0x2c>
	ASSERT(ep != NULL);
8f61abe4:	e3063590 	movw	r3, #26000	; 0x6590
8f61abe8:	e1a00007 	mov	r0, r7
8f61abec:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61abf0:	e306253c 	movw	r2, #25916	; 0x653c
8f61abf4:	e58d3000 	str	r3, [r13]
8f61abf8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61abfc:	e300360c 	movw	r3, #1548	; 0x60c
8f61ac00:	e3001130 	movw	r1, #304	; 0x130
8f61ac04:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61ac08:	eb005fab 	bl	8f632abc <_panic>
8f61ac0c:	eaffffd3 	b	8f61ab60 <dwc_ep_bulk_state_inactive_enter+0x40>
}
8f61ac10:	eb005fea 	bl	8f632bc0 <__stack_chk_fail>
8f61ac14:	8f74221c 	.word	0x8f74221c

8f61ac18 <dwc_print_current_state>:
{
8f61ac18:	e59f3164 	ldr	r3, [pc, #356]	; 8f61ad84 <dwc_print_current_state+0x16c>
8f61ac1c:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f61ac20:	e1a04000 	mov	r4, r0
8f61ac24:	e24dd00c 	sub	r13, r13, #12
	ERR("\n");
8f61ac28:	e3030778 	movw	r0, #14200	; 0x3778
8f61ac2c:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f61ac30:	e5933000 	ldr	r3, [r3]
8f61ac34:	e58d3004 	str	r3, [r13, #4]
8f61ac38:	e3a03000 	mov	r3, #0
	ERR("\n");
8f61ac3c:	eb005f4c 	bl	8f632974 <_dprintf>
	ERR("dwc core = 0x%x\n", dev->core_id);
8f61ac40:	e5941004 	ldr	r1, [r4, #4]
8f61ac44:	e306059c 	movw	r0, #26012	; 0x659c
8f61ac48:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61ac4c:	eb005f48 	bl	8f632974 <_dprintf>
	ERR("ctrl_state = %d, %s\n", dev->ctrl_state, dev_ctrl_state_lookup[dev->ctrl_state]);
8f61ac50:	e2842a01 	add	r2, r4, #4096	; 0x1000
8f61ac54:	e3023c64 	movw	r3, #11364	; 0x2c64
8f61ac58:	e3483f74 	movt	r3, #36724	; 0x8f74
8f61ac5c:	e5d211d4 	ldrb	r1, [r2, #468]	; 0x1d4
8f61ac60:	e30605b0 	movw	r0, #26032	; 0x65b0
8f61ac64:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61ac68:	e3029b24 	movw	r9, #11044	; 0x2b24
	ERR("\n");
8f61ac6c:	e3036778 	movw	r6, #14200	; 0x3778
	ERR("EP ( index = %d) status: \n", ep_index);
8f61ac70:	e30685c8 	movw	r8, #26056	; 0x65c8
	ERR("ctrl_state = %d, %s\n", dev->ctrl_state, dev_ctrl_state_lookup[dev->ctrl_state]);
8f61ac74:	e7932101 	ldr	r2, [r3, r1, lsl #2]
	ERR("phy_num      = %d \n", dev->ep[ep_index].phy_num);
8f61ac78:	e30675e4 	movw	r7, #26084	; 0x65e4
	ERR("ctrl_state = %d, %s\n", dev->ctrl_state, dev_ctrl_state_lookup[dev->ctrl_state]);
8f61ac7c:	eb005f3c 	bl	8f632974 <_dprintf>
	for (i = 0; i < DWC_MAX_NUM_OF_EP; i++)
8f61ac80:	e3489f74 	movt	r9, #36724	; 0x8f74
	ERR("\n");
8f61ac84:	e3486f70 	movt	r6, #36720	; 0x8f70
	ERR("EP ( index = %d) status: \n", ep_index);
8f61ac88:	e3488f70 	movt	r8, #36720	; 0x8f70
	ERR("phy_num      = %d \n", dev->ep[ep_index].phy_num);
8f61ac8c:	e3487f70 	movt	r7, #36720	; 0x8f70
	ERR("ctrl_state = %d, %s\n", dev->ctrl_state, dev_ctrl_state_lookup[dev->ctrl_state]);
8f61ac90:	e3a05000 	mov	r5, #0
	for (i = 0; i < DWC_MAX_NUM_OF_EP; i++)
8f61ac94:	e2844f8e 	add	r4, r4, #568	; 0x238
	ERR("\n");
8f61ac98:	e1a00006 	mov	r0, r6
8f61ac9c:	eb005f34 	bl	8f632974 <_dprintf>
	ERR("EP ( index = %d) status: \n", ep_index);
8f61aca0:	e1a01005 	mov	r1, r5
8f61aca4:	e1a00008 	mov	r0, r8
	for (i = 0; i < DWC_MAX_NUM_OF_EP; i++)
8f61aca8:	e2855001 	add	r5, r5, #1
	ERR("EP ( index = %d) status: \n", ep_index);
8f61acac:	eb005f30 	bl	8f632974 <_dprintf>
	ERR("phy_num      = %d \n", dev->ep[ep_index].phy_num);
8f61acb0:	e5541224 	ldrb	r1, [r4, #-548]	; 0xfffffddc
8f61acb4:	e1a00007 	mov	r0, r7
8f61acb8:	eb005f2d 	bl	8f632974 <_dprintf>
	ERR("usb ep num   = %d \n", dev->ep[ep_index].number);
8f61acbc:	e5541230 	ldrb	r1, [r4, #-560]	; 0xfffffdd0
8f61acc0:	e30605f8 	movw	r0, #26104	; 0x65f8
8f61acc4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61acc8:	eb005f29 	bl	8f632974 <_dprintf>
	ERR("dir          = %d \n", dev->ep[ep_index].dir);
8f61accc:	e554122f 	ldrb	r1, [r4, #-559]	; 0xfffffdd1
8f61acd0:	e306060c 	movw	r0, #26124	; 0x660c
8f61acd4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61acd8:	eb005f25 	bl	8f632974 <_dprintf>
	ERR("type         = %d \n", dev->ep[ep_index].type);
8f61acdc:	e554122e 	ldrb	r1, [r4, #-558]	; 0xfffffdd2
8f61ace0:	e3060620 	movw	r0, #26144	; 0x6620
8f61ace4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61ace8:	eb005f21 	bl	8f632974 <_dprintf>
	ERR("resource_idx = %d \n", dev->ep[ep_index].resource_idx);
8f61acec:	e5541022 	ldrb	r1, [r4, #-34]	; 0xffffffde
8f61acf0:	e3060634 	movw	r0, #26164	; 0x6634
8f61acf4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61acf8:	eb005f1d 	bl	8f632974 <_dprintf>
	ERR("trb_queued   = %d \n", dev->ep[ep_index].trb_queued);
8f61acfc:	e5141018 	ldr	r1, [r4, #-24]	; 0xffffffe8
8f61ad00:	e3060648 	movw	r0, #26184	; 0x6648
8f61ad04:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61ad08:	eb005f19 	bl	8f632974 <_dprintf>
	ERR("bytes_queued = %d \n", dev->ep[ep_index].bytes_queued);
8f61ad0c:	e5141014 	ldr	r1, [r4, #-20]	; 0xffffffec
8f61ad10:	e306065c 	movw	r0, #26204	; 0x665c
8f61ad14:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61ad18:	eb005f15 	bl	8f632974 <_dprintf>
	ERR("state        = %d, %s \n", dev->ep[ep_index].state, ep_state_lookup[dev->ep[ep_index].state]);
8f61ad1c:	e5d41004 	ldrb	r1, [r4, #4]
8f61ad20:	e3060670 	movw	r0, #26224	; 0x6670
8f61ad24:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61ad28:	e7992101 	ldr	r2, [r9, r1, lsl #2]
8f61ad2c:	eb005f10 	bl	8f632974 <_dprintf>
	ERR("ep req len   = %d trbctl = %d\n", dev->ep[ep_index].req.len, dev->ep[ep_index].req.trbctl);
8f61ad30:	e5542008 	ldrb	r2, [r4, #-8]
8f61ad34:	e514100c 	ldr	r1, [r4, #-12]
8f61ad38:	e3060688 	movw	r0, #26248	; 0x6688
8f61ad3c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61ad40:	eb005f0b 	bl	8f632974 <_dprintf>
	ERR("\n");
8f61ad44:	e1a00006 	mov	r0, r6
8f61ad48:	eb005f09 	bl	8f632974 <_dprintf>
	for (i = 0; i < DWC_MAX_NUM_OF_EP; i++)
8f61ad4c:	e3550008 	cmp	r5, #8
8f61ad50:	1affffcf 	bne	8f61ac94 <dwc_print_current_state+0x7c>
	ERR("\n");
8f61ad54:	e59f3028 	ldr	r3, [pc, #40]	; 8f61ad84 <dwc_print_current_state+0x16c>
8f61ad58:	e5932000 	ldr	r2, [r3]
8f61ad5c:	e59d3004 	ldr	r3, [r13, #4]
8f61ad60:	e0332002 	eors	r2, r3, r2
8f61ad64:	e3a03000 	mov	r3, #0
8f61ad68:	1a000004 	bne	8f61ad80 <dwc_print_current_state+0x168>
8f61ad6c:	e3030778 	movw	r0, #14200	; 0x3778
8f61ad70:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f61ad74:	e28dd00c 	add	r13, r13, #12
8f61ad78:	e8bd43f0 	pop	{r4, r5, r6, r7, r8, r9, r14}
	ERR("\n");
8f61ad7c:	ea005efc 	b	8f632974 <_dprintf>
8f61ad80:	eb005f8e 	bl	8f632bc0 <__stack_chk_fail>
8f61ad84:	8f74221c 	.word	0x8f74221c

8f61ad88 <dwc_request_queue>:

/* Enqueue new data transfer request on an endpoint. */
static int dwc_request_queue(dwc_dev_t     *dev,
							 uint8_t        ep_phy_num,
							 dwc_request_t *req)
{
8f61ad88:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61ad8c:	e3510007 	cmp	r1, #7
{
8f61ad90:	e24dd034 	sub	r13, r13, #52	; 0x34
8f61ad94:	e59f3530 	ldr	r3, [pc, #1328]	; 8f61b2cc <dwc_request_queue+0x544>
8f61ad98:	e1a09001 	mov	r9, r1
8f61ad9c:	e1a08000 	mov	r8, r0
8f61ada0:	e58de010 	str	r14, [r13, #16]
8f61ada4:	e58d200c 	str	r2, [r13, #12]
8f61ada8:	e5933000 	ldr	r3, [r3]
8f61adac:	e58d302c 	str	r3, [r13, #44]	; 0x2c
8f61adb0:	e3a03000 	mov	r3, #0
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61adb4:	8a00012b 	bhi	8f61b268 <dwc_request_queue+0x4e0>
	dwc_ep_t *ep = &dev->ep[DWC_EP_PHY_TO_INDEX(ep_phy_num)];
8f61adb8:	e3a03f8e 	mov	r3, #568	; 0x238
8f61adbc:	e0030993 	mul	r3, r3, r9
8f61adc0:	e58d3018 	str	r3, [r13, #24]
8f61adc4:	e2833008 	add	r3, r3, #8
	ASSERT(ep != NULL);
8f61adc8:	e1780003 	cmn	r8, r3
8f61adcc:	0a00011a 	beq	8f61b23c <dwc_request_queue+0x4b4>

	dwc_trb_t *trb          = ep->trb;
8f61add0:	e59d2018 	ldr	r2, [r13, #24]
8f61add4:	e3a03f8e 	mov	r3, #568	; 0x238
	uint8_t *data_ptr       = req->data;
8f61add8:	e59d100c 	ldr	r1, [r13, #12]
8f61addc:	e0882002 	add	r2, r8, r2
8f61ade0:	e58d2014 	str	r2, [r13, #20]
	dwc_trb_t *trb          = ep->trb;
8f61ade4:	e0238993 	mla	r3, r3, r9, r8
	uint32_t transfer_len   = req->len;
	dwc_trb_trbctl_t trbctl = req->trbctl;

	uint32_t pad_len;

	if(ep->state != EP_STATE_INACTIVE)
8f61ade8:	e5d2223c 	ldrb	r2, [r2, #572]	; 0x23c
	uint8_t *data_ptr       = req->data;
8f61adec:	e5917000 	ldr	r7, [r1]
	if(ep->state != EP_STATE_INACTIVE)
8f61adf0:	e3520001 	cmp	r2, #1
	dwc_trb_trbctl_t trbctl = req->trbctl;
8f61adf4:	e5d12008 	ldrb	r2, [r1, #8]
	uint32_t transfer_len   = req->len;
8f61adf8:	e5916004 	ldr	r6, [r1, #4]
	dwc_trb_t *trb          = ep->trb;
8f61adfc:	e5934218 	ldr	r4, [r3, #536]	; 0x218
	dwc_trb_trbctl_t trbctl = req->trbctl;
8f61ae00:	e58d201c 	str	r2, [r13, #28]
	if(ep->state != EP_STATE_INACTIVE)
8f61ae04:	1a00012d 	bne	8f61b2c0 <dwc_request_queue+0x538>
			ep_phy_num, ep_state_lookup[ep->state]);
		return -1;
	}

	/* trb queued must be 0 at this time. */
	ASSERT(ep->trb_queued == 0);
8f61ae08:	e5933220 	ldr	r3, [r3, #544]	; 0x220
8f61ae0c:	e3530000 	cmp	r3, #0
8f61ae10:	1a00011f 	bne	8f61b294 <dwc_request_queue+0x50c>

	/* save the original request for this ep */
	ep->req = *req;
8f61ae14:	e59de00c 	ldr	r14, [r13, #12]
8f61ae18:	e3a05f8e 	mov	r5, #568	; 0x238
8f61ae1c:	e0258995 	mla	r5, r5, r9, r8

	ep->bytes_queued = 0;
8f61ae20:	e3a0a000 	mov	r10, #0
	ep->req = *req;
8f61ae24:	e8be000f 	ldm	r14!, {r0, r1, r2, r3}
8f61ae28:	e285cf8a 	add	r12, r5, #552	; 0x228
8f61ae2c:	e8ac000f 	stmia	r12!, {r0, r1, r2, r3}
8f61ae30:	e59e3000 	ldr	r3, [r14]
8f61ae34:	e58c3000 	str	r3, [r12]

	if (ep->type == EP_TYPE_CONTROL || ep->type == EP_TYPE_INTERRUPT)
8f61ae38:	e5d5300a 	ldrb	r3, [r5, #10]
	ep->bytes_queued = 0;
8f61ae3c:	e585a224 	str	r10, [r5, #548]	; 0x224
	if (ep->type == EP_TYPE_CONTROL || ep->type == EP_TYPE_INTERRUPT)
8f61ae40:	e3530003 	cmp	r3, #3
8f61ae44:	1153000a 	cmpne	r3, r10
8f61ae48:	03a02001 	moveq	r2, #1
8f61ae4c:	13a02000 	movne	r2, #0
8f61ae50:	0a0000c9 	beq	8f61b17c <dwc_request_queue+0x3f4>
		/* increment the queued trb count */
		ep->trb_queued++;
		ep->bytes_queued += transfer_len;
		data_ptr += transfer_len;
	}
	else if (ep->type == EP_TYPE_BULK)
8f61ae54:	e3530002 	cmp	r3, #2
8f61ae58:	1a00003d 	bne	8f61af54 <dwc_request_queue+0x1cc>
	{
		/* reserve 1 trb for pad/zero-length pkt */
		uint32_t trb_available = ep->trb_count - 1;
8f61ae5c:	e595a21c 	ldr	r10, [r5, #540]	; 0x21c
		 */

		/* align default MAX_BYTES_PER_TRB to DWC_MASTER_BUS_WIDTH */
		max_bytes_per_trb = ROUNDDOWN(DWC_MAX_BYTES_PER_TRB, DWC_MASTER_BUS_WIDTH);

		while (trb_available && transfer_len)
8f61ae60:	e35a0001 	cmp	r10, #1
8f61ae64:	13560000 	cmpne	r6, #0
8f61ae68:	0a00007c 	beq	8f61b060 <dwc_request_queue+0x2d8>
			REG_WRITE_FIELD_LOCAL(&trb->f2, TRB_F2, PTR_HIGH, 0x0);
			REG_WRITE_FIELD_LOCAL(&trb->f3, TRB_F3, BUFSIZ,   trb_len);
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, LST,      0x0);
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, CHN,      0x1);
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, CSP,      0x0);
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, TRBCTL,   trbctl);
8f61ae6c:	e59d301c 	ldr	r3, [r13, #28]
				trb_len = (transfer_len <= max_bytes_per_trb) ?
8f61ae70:	e30fbff8 	movw	r11, #65528	; 0xfff8
8f61ae74:	e340b0ff 	movt	r11, #255	; 0xff
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, TRBCTL,   trbctl);
8f61ae78:	e58d8020 	str	r8, [r13, #32]
8f61ae7c:	e58d9024 	str	r9, [r13, #36]	; 0x24
8f61ae80:	e24aa002 	sub	r10, r10, #2
8f61ae84:	e1a03203 	lsl	r3, r3, #4
8f61ae88:	e1a0900b 	mov	r9, r11
8f61ae8c:	e1a08002 	mov	r8, r2
8f61ae90:	e1a0b003 	mov	r11, r3
8f61ae94:	ea00001e 	b	8f61af14 <dwc_request_queue+0x18c>
									transfer_len : (max_bytes_per_trb - offset);
8f61ae98:	e1560009 	cmp	r6, r9
8f61ae9c:	9a00006a 	bls	8f61b04c <dwc_request_queue+0x2c4>
				offset = ((uint32_t) data_ptr) & (DWC_MASTER_BUS_WIDTH - 1);
8f61aea0:	e2070007 	and	r0, r7, #7
8f61aea4:	e25a2000 	subs	r2, r10, #0
			ep->trb_queued++;
			ep->bytes_queued += trb_len;
			data_ptr += trb_len;

			/* remaining transfer len */
			transfer_len -= trb_len;
8f61aea8:	e280c4ff 	add	r12, r0, #-16777216	; 0xff000000
									transfer_len : (max_bytes_per_trb - offset);
8f61aeac:	e0490000 	sub	r0, r9, r0
			transfer_len -= trb_len;
8f61aeb0:	e28cc008 	add	r12, r12, #8
8f61aeb4:	13a02001 	movne	r2, #1
8f61aeb8:	e086600c 	add	r6, r6, r12
		while (trb_available && transfer_len)
8f61aebc:	e3520000 	cmp	r2, #0
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, HWO,      0x1);
8f61aec0:	e594200c 	ldr	r2, [r4, #12]
			REG_WRITE_FIELD_LOCAL(&trb->f2, TRB_F2, PTR_HIGH, 0x0);
8f61aec4:	e8840180 	stm	r4, {r7, r8}
			ep->trb_queued++;
8f61aec8:	e2811001 	add	r1, r1, #1
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, HWO,      0x1);
8f61aecc:	e3c22ffe 	bic	r2, r2, #1016	; 0x3f8
			data_ptr += trb_len;
8f61aed0:	e0877000 	add	r7, r7, r0
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, HWO,      0x1);
8f61aed4:	e3c22002 	bic	r2, r2, #2
		while (trb_available && transfer_len)
8f61aed8:	e24aa001 	sub	r10, r10, #1
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, HWO,      0x1);
8f61aedc:	e182200b 	orr	r2, r2, r11

			/* remaining trb */
			trb_available--;

			/* point to the next trb */
			trb++;
8f61aee0:	e2844010 	add	r4, r4, #16
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, HWO,      0x1);
8f61aee4:	e3c22b02 	bic	r2, r2, #2048	; 0x800
8f61aee8:	e3822005 	orr	r2, r2, #5
8f61aeec:	e5042004 	str	r2, [r4, #-4]
			REG_WRITE_FIELD_LOCAL(&trb->f3, TRB_F3, BUFSIZ,   trb_len);
8f61aef0:	e5142008 	ldr	r2, [r4, #-8]
8f61aef4:	e20224ff 	and	r2, r2, #-16777216	; 0xff000000
8f61aef8:	e1822000 	orr	r2, r2, r0
8f61aefc:	e5042008 	str	r2, [r4, #-8]
			ep->bytes_queued += trb_len;
8f61af00:	e5952224 	ldr	r2, [r5, #548]	; 0x224
			ep->trb_queued++;
8f61af04:	e5851220 	str	r1, [r5, #544]	; 0x220
			ep->bytes_queued += trb_len;
8f61af08:	e0820000 	add	r0, r2, r0
8f61af0c:	e5850224 	str	r0, [r5, #548]	; 0x224
		while (trb_available && transfer_len)
8f61af10:	0a000051 	beq	8f61b05c <dwc_request_queue+0x2d4>
			memset(trb, 0, sizeof(dwc_trb_t));
8f61af14:	e3a01000 	mov	r1, #0
8f61af18:	e3a02010 	mov	r2, #16
8f61af1c:	e1a00004 	mov	r0, r4
8f61af20:	eb0064e7 	bl	8f6342c4 <memset>
			if (ep->trb_queued == 0)
8f61af24:	e5951220 	ldr	r1, [r5, #544]	; 0x220
8f61af28:	e3510000 	cmp	r1, #0
8f61af2c:	0affffd9 	beq	8f61ae98 <dwc_request_queue+0x110>
				trb_len = (transfer_len <= max_bytes_per_trb) ?
8f61af30:	e1560009 	cmp	r6, r9
8f61af34:	31a00006 	movcc	r0, r6
8f61af38:	21a00009 	movcs	r0, r9
		while (trb_available && transfer_len)
8f61af3c:	e35a0000 	cmp	r10, #0
8f61af40:	11560009 	cmpne	r6, r9
8f61af44:	e0466000 	sub	r6, r6, r0
8f61af48:	83a02001 	movhi	r2, #1
8f61af4c:	93a02000 	movls	r2, #0
8f61af50:	eaffffd9 	b	8f61aebc <dwc_request_queue+0x134>
		}
	}
	else
	{
		/* invalid EP type */
		ASSERT(0);
8f61af54:	e3073f64 	movw	r3, #32612	; 0x7f64
8f61af58:	e306253c 	movw	r2, #25916	; 0x653c
8f61af5c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61af60:	e3001130 	movw	r1, #304	; 0x130
8f61af64:	e58d3000 	str	r3, [r13]
8f61af68:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61af6c:	e59d0010 	ldr	r0, [r13, #16]
8f61af70:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61af74:	e3003769 	movw	r3, #1897	; 0x769
8f61af78:	eb005ecf 	bl	8f632abc <_panic>
	}

	/* flush the trb data to main memory */
	arch_clean_invalidate_cache_range((addr_t) ep->trb,
									  ROUNDUP(sizeof(dwc_trb_t)*ep->trb_queued, CACHE_LINE));
8f61af7c:	e3a03f8e 	mov	r3, #568	; 0x238
	critical_section_count++;
8f61af80:	e3014acc 	movw	r4, #6860	; 0x1acc
8f61af84:	e0238993 	mla	r3, r3, r9, r8
8f61af88:	e3484f71 	movt	r4, #36721	; 0x8f71
8f61af8c:	e5931220 	ldr	r1, [r3, #544]	; 0x220
	arch_clean_invalidate_cache_range((addr_t) ep->trb,
8f61af90:	e5930218 	ldr	r0, [r3, #536]	; 0x218
									  ROUNDUP(sizeof(dwc_trb_t)*ep->trb_queued, CACHE_LINE));
8f61af94:	e1a01201 	lsl	r1, r1, #4
8f61af98:	e281103f 	add	r1, r1, #63	; 0x3f
	arch_clean_invalidate_cache_range((addr_t) ep->trb,
8f61af9c:	e3c1103f 	bic	r1, r1, #63	; 0x3f
8f61afa0:	eb0017fe 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
8f61afa4:	e5943000 	ldr	r3, [r4]
8f61afa8:	e2833001 	add	r3, r3, #1
8f61afac:	e5843000 	str	r3, [r4]
	if (critical_section_count == 1)
8f61afb0:	e3530001 	cmp	r3, #1
8f61afb4:	0a000087 	beq	8f61b1d8 <dwc_request_queue+0x450>
	 * outside of interrupt context. Use critical section to make sure all
	 * states are updated properly before we handle other interrupts.
	 */
	enter_critical_section();

	if(ep->state == EP_STATE_INACTIVE)
8f61afb8:	e59d3014 	ldr	r3, [r13, #20]
8f61afbc:	e5d3323c 	ldrb	r3, [r3, #572]	; 0x23c
8f61afc0:	e3530001 	cmp	r3, #1
8f61afc4:	0a00005f 	beq	8f61b148 <dwc_request_queue+0x3c0>
			ep->state = EP_STATE_XFER_IN_PROG;
		}
	}
	else
	{
		ERR("\n Attempting START_TRANSFER in invalid state: %s. .......\n",
8f61afc8:	e3022b24 	movw	r2, #11044	; 0x2b24
8f61afcc:	e3482f74 	movt	r2, #36724	; 0x8f74
8f61afd0:	e306074c 	movw	r0, #26444	; 0x674c
8f61afd4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61afd8:	e7921103 	ldr	r1, [r2, r3, lsl #2]
8f61afdc:	eb005e64 	bl	8f632974 <_dprintf>
			ep_state_lookup[ep->state]);
		dwc_print_current_state(dev);
8f61afe0:	e1a00008 	mov	r0, r8
8f61afe4:	ebffff0b 	bl	8f61ac18 <dwc_print_current_state>
		ASSERT(0);
8f61afe8:	e307cf64 	movw	r12, #32612	; 0x7f64
8f61afec:	e306253c 	movw	r2, #25916	; 0x653c
8f61aff0:	e348cf70 	movt	r12, #36720	; 0x8f70
8f61aff4:	e3001130 	movw	r1, #304	; 0x130
8f61aff8:	e59d0010 	ldr	r0, [r13, #16]
8f61affc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61b000:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61b004:	e300378e 	movw	r3, #1934	; 0x78e
8f61b008:	e58dc000 	str	r12, [r13]
8f61b00c:	eb005eaa 	bl	8f632abc <_panic>
	critical_section_count--;
8f61b010:	e5945000 	ldr	r5, [r4]
8f61b014:	e2455001 	sub	r5, r5, #1
8f61b018:	e5845000 	str	r5, [r4]
	if (critical_section_count == 0)
8f61b01c:	e3550000 	cmp	r5, #0
	}

	exit_critical_section();

	return 0;
8f61b020:	13a05000 	movne	r5, #0
8f61b024:	0a000052 	beq	8f61b174 <dwc_request_queue+0x3ec>
}
8f61b028:	e59f329c 	ldr	r3, [pc, #668]	; 8f61b2cc <dwc_request_queue+0x544>
8f61b02c:	e5932000 	ldr	r2, [r3]
8f61b030:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
8f61b034:	e0332002 	eors	r2, r3, r2
8f61b038:	e3a03000 	mov	r3, #0
8f61b03c:	1a0000a1 	bne	8f61b2c8 <dwc_request_queue+0x540>
8f61b040:	e1a00005 	mov	r0, r5
8f61b044:	e28dd034 	add	r13, r13, #52	; 0x34
8f61b048:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
8f61b04c:	e1a00006 	mov	r0, r6
8f61b050:	e1a02001 	mov	r2, r1
8f61b054:	e1a06001 	mov	r6, r1
8f61b058:	eaffff97 	b	8f61aebc <dwc_request_queue+0x134>
8f61b05c:	e1cd82d0 	ldrd	r8, [r13, #32]
		if (transfer_len)
8f61b060:	e3560000 	cmp	r6, #0
8f61b064:	1a00005d 	bne	8f61b1e0 <dwc_request_queue+0x458>
		if ( (ep->dir == DWC_EP_DIRECTION_OUT) &&
8f61b068:	e3a05f8e 	mov	r5, #568	; 0x238
8f61b06c:	e0258995 	mla	r5, r5, r9, r8
8f61b070:	e5d53009 	ldrb	r3, [r5, #9]
8f61b074:	e3530000 	cmp	r3, #0
8f61b078:	1a00002c 	bne	8f61b130 <dwc_request_queue+0x3a8>
		uint32_t roundup = req->len % ep->max_pkt_size;
8f61b07c:	e59d300c 	ldr	r3, [r13, #12]
8f61b080:	e1d560bc 	ldrh	r6, [r5, #12]
8f61b084:	e5930004 	ldr	r0, [r3, #4]
8f61b088:	e1a01006 	mov	r1, r6
8f61b08c:	fa008768 	blx	8f63ce34 <__aeabi_uidivmod>
		if ( (ep->dir == DWC_EP_DIRECTION_OUT) &&
8f61b090:	e3510000 	cmp	r1, #0
8f61b094:	0a000022 	beq	8f61b124 <dwc_request_queue+0x39c>
				pad_len = ep->max_pkt_size - roundup;
8f61b098:	e0466001 	sub	r6, r6, r1
			memset(trb, 0, sizeof(dwc_trb_t));
8f61b09c:	e3a02010 	mov	r2, #16
8f61b0a0:	e3a01000 	mov	r1, #0
8f61b0a4:	e1a00004 	mov	r0, r4
8f61b0a8:	eb006485 	bl	8f6342c4 <memset>
			memset(ep->zlp_buf, 0, DWC_ZLP_BUF_SIZE);
8f61b0ac:	e59d3018 	ldr	r3, [r13, #24]
8f61b0b0:	e3a02c02 	mov	r2, #512	; 0x200
8f61b0b4:	e3a01000 	mov	r1, #0
8f61b0b8:	e2835016 	add	r5, r3, #22
8f61b0bc:	e0885005 	add	r5, r8, r5
8f61b0c0:	e1a00005 	mov	r0, r5
8f61b0c4:	eb00647e 	bl	8f6342c4 <memset>
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, HWO,      0x1);
8f61b0c8:	e594300c 	ldr	r3, [r4, #12]
8f61b0cc:	e59d101c 	ldr	r1, [r13, #28]
			ep->trb_queued++;
8f61b0d0:	e3a02f8e 	mov	r2, #568	; 0x238
8f61b0d4:	e0228992 	mla	r2, r2, r9, r8
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, HWO,      0x1);
8f61b0d8:	e3c33fff 	bic	r3, r3, #1020	; 0x3fc
8f61b0dc:	e1833201 	orr	r3, r3, r1, lsl #4
			REG_WRITE_FIELD_LOCAL(&trb->f1, TRB_F1, PTR_LOW,  (uint32_t) ep->zlp_buf);
8f61b0e0:	e5845000 	str	r5, [r4]
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, HWO,      0x1);
8f61b0e4:	e3833b02 	orr	r3, r3, #2048	; 0x800
8f61b0e8:	e3833003 	orr	r3, r3, #3
8f61b0ec:	e584300c 	str	r3, [r4, #12]
			REG_WRITE_FIELD_LOCAL(&trb->f3, TRB_F3, BUFSIZ,   pad_len);
8f61b0f0:	e5943008 	ldr	r3, [r4, #8]
			ep->trb_queued++;
8f61b0f4:	e5921220 	ldr	r1, [r2, #544]	; 0x220
			REG_WRITE_FIELD_LOCAL(&trb->f3, TRB_F3, BUFSIZ,   pad_len);
8f61b0f8:	e20334ff 	and	r3, r3, #-16777216	; 0xff000000
8f61b0fc:	e1833006 	orr	r3, r3, r6
8f61b100:	e5843008 	str	r3, [r4, #8]
			ep->bytes_queued += pad_len;
8f61b104:	e5923224 	ldr	r3, [r2, #548]	; 0x224
			ep->trb_queued++;
8f61b108:	e2811001 	add	r1, r1, #1
			ep->bytes_queued += pad_len;
8f61b10c:	e0836006 	add	r6, r3, r6
			REG_WRITE_FIELD_LOCAL(&trb->f2, TRB_F2, PTR_HIGH, 0x0);
8f61b110:	e3a03000 	mov	r3, #0
8f61b114:	e5843004 	str	r3, [r4, #4]
			ep->trb_queued++;
8f61b118:	e5821220 	str	r1, [r2, #544]	; 0x220
			ep->bytes_queued += pad_len;
8f61b11c:	e5826224 	str	r6, [r2, #548]	; 0x224
8f61b120:	eaffff95 	b	8f61af7c <dwc_request_queue+0x1f4>
			 (roundup || ep->zlp))
8f61b124:	e5d5300e 	ldrb	r3, [r5, #14]
8f61b128:	e3530000 	cmp	r3, #0
8f61b12c:	1affffda 	bne	8f61b09c <dwc_request_queue+0x314>
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, CHN, 0x0);
8f61b130:	e5143004 	ldr	r3, [r4, #-4]
8f61b134:	e3c33004 	bic	r3, r3, #4
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, IOC, 0x1);
8f61b138:	e3833b02 	orr	r3, r3, #2048	; 0x800
8f61b13c:	e3833002 	orr	r3, r3, #2
8f61b140:	e5043004 	str	r3, [r4, #-4]
8f61b144:	eaffff8c 	b	8f61af7c <dwc_request_queue+0x1f4>
		dwc_ep_cmd_start_transfer(dev, ep_phy_num);
8f61b148:	e1a01009 	mov	r1, r9
8f61b14c:	e1a00008 	mov	r0, r8
8f61b150:	eb00084a 	bl	8f61d280 <dwc_ep_cmd_start_transfer>
		if(dwc_device_run_status(dev))
8f61b154:	e1a00008 	mov	r0, r8
8f61b158:	eb0009a1 	bl	8f61d7e4 <dwc_device_run_status>
			ep->state = EP_STATE_XFER_IN_PROG;
8f61b15c:	e59d2014 	ldr	r2, [r13, #20]
		if(dwc_device_run_status(dev))
8f61b160:	e3500000 	cmp	r0, #0
			ep->state = EP_STATE_START_TRANSFER;
8f61b164:	13a03002 	movne	r3, #2
			ep->state = EP_STATE_XFER_IN_PROG;
8f61b168:	03a03003 	moveq	r3, #3
8f61b16c:	e5c2323c 	strb	r3, [r2, #572]	; 0x23c
8f61b170:	eaffffa6 	b	8f61b010 <dwc_request_queue+0x288>
		arch_enable_ints();
8f61b174:	eb0017a3 	bl	8f621008 <arch_enable_ints>
8f61b178:	eaffffaa 	b	8f61b028 <dwc_request_queue+0x2a0>
		memset(trb, 0, sizeof(dwc_trb_t));
8f61b17c:	e3a02010 	mov	r2, #16
8f61b180:	e1a0100a 	mov	r1, r10
8f61b184:	e1a00004 	mov	r0, r4
8f61b188:	eb00644d 	bl	8f6342c4 <memset>
		REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, HWO,      0x1);
8f61b18c:	e594300c 	ldr	r3, [r4, #12]
8f61b190:	e59d201c 	ldr	r2, [r13, #28]
8f61b194:	e3c33fff 	bic	r3, r3, #1020	; 0x3fc
		REG_WRITE_FIELD_LOCAL(&trb->f2, TRB_F2, PTR_HIGH, 0x0);
8f61b198:	e8840480 	stm	r4, {r7, r10}
		REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, HWO,      0x1);
8f61b19c:	e1833202 	orr	r3, r3, r2, lsl #4
8f61b1a0:	e3833b02 	orr	r3, r3, #2048	; 0x800
8f61b1a4:	e3833003 	orr	r3, r3, #3
8f61b1a8:	e584300c 	str	r3, [r4, #12]
		REG_WRITE_FIELD_LOCAL(&trb->f3, TRB_F3, BUFSIZ,   transfer_len);
8f61b1ac:	e5943008 	ldr	r3, [r4, #8]
8f61b1b0:	e20334ff 	and	r3, r3, #-16777216	; 0xff000000
8f61b1b4:	e1833006 	orr	r3, r3, r6
8f61b1b8:	e5843008 	str	r3, [r4, #8]
		ep->trb_queued++;
8f61b1bc:	e5953220 	ldr	r3, [r5, #544]	; 0x220
8f61b1c0:	e2833001 	add	r3, r3, #1
8f61b1c4:	e5853220 	str	r3, [r5, #544]	; 0x220
		ep->bytes_queued += transfer_len;
8f61b1c8:	e5953224 	ldr	r3, [r5, #548]	; 0x224
8f61b1cc:	e0836006 	add	r6, r3, r6
8f61b1d0:	e5856224 	str	r6, [r5, #548]	; 0x224
		data_ptr += transfer_len;
8f61b1d4:	eaffff68 	b	8f61af7c <dwc_request_queue+0x1f4>
		arch_disable_ints();
8f61b1d8:	eb00178e 	bl	8f621018 <arch_disable_ints>
8f61b1dc:	eaffff75 	b	8f61afb8 <dwc_request_queue+0x230>
			ERR("\n ERROR: Enough TRBs are not available to setup transfer\n");
8f61b1e0:	e30606bc 	movw	r0, #26300	; 0x66bc
8f61b1e4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b1e8:	eb005de1 	bl	8f632974 <_dprintf>
			ERR("\n ERROR: Increase TRB chain for the ep.\n");
8f61b1ec:	e30606f8 	movw	r0, #26360	; 0x66f8
8f61b1f0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b1f4:	eb005dde 	bl	8f632974 <_dprintf>
			ERR("\n ERROR: phy_ep_num = %d xfer len = %d\n", ep_phy_num, req->len);
8f61b1f8:	e59d300c 	ldr	r3, [r13, #12]
8f61b1fc:	e1a01009 	mov	r1, r9
8f61b200:	e3060724 	movw	r0, #26404	; 0x6724
8f61b204:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b208:	e5932004 	ldr	r2, [r3, #4]
8f61b20c:	eb005dd8 	bl	8f632974 <_dprintf>
			ASSERT(0);
8f61b210:	e59d0010 	ldr	r0, [r13, #16]
8f61b214:	e3073f64 	movw	r3, #32612	; 0x7f64
8f61b218:	e306253c 	movw	r2, #25916	; 0x653c
8f61b21c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61b220:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61b224:	e58d3000 	str	r3, [r13]
8f61b228:	e3001130 	movw	r1, #304	; 0x130
8f61b22c:	e3003729 	movw	r3, #1833	; 0x729
8f61b230:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61b234:	eb005e20 	bl	8f632abc <_panic>
8f61b238:	eaffff8a 	b	8f61b068 <dwc_request_queue+0x2e0>
	ASSERT(ep != NULL);
8f61b23c:	e59d0010 	ldr	r0, [r13, #16]
8f61b240:	e3063590 	movw	r3, #26000	; 0x6590
8f61b244:	e306253c 	movw	r2, #25916	; 0x653c
8f61b248:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61b24c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61b250:	e58d3000 	str	r3, [r13]
8f61b254:	e3001130 	movw	r1, #304	; 0x130
8f61b258:	e30036b7 	movw	r3, #1719	; 0x6b7
8f61b25c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61b260:	eb005e15 	bl	8f632abc <_panic>
8f61b264:	eafffed9 	b	8f61add0 <dwc_request_queue+0x48>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61b268:	e306355c 	movw	r3, #25948	; 0x655c
8f61b26c:	e306253c 	movw	r2, #25916	; 0x653c
8f61b270:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61b274:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61b278:	e58d3000 	str	r3, [r13]
8f61b27c:	e3001130 	movw	r1, #304	; 0x130
8f61b280:	e30036b5 	movw	r3, #1717	; 0x6b5
8f61b284:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61b288:	e1a0000e 	mov	r0, r14
8f61b28c:	eb005e0a 	bl	8f632abc <_panic>
8f61b290:	eafffec8 	b	8f61adb8 <dwc_request_queue+0x30>
	ASSERT(ep->trb_queued == 0);
8f61b294:	e59d0010 	ldr	r0, [r13, #16]
8f61b298:	e30636a8 	movw	r3, #26280	; 0x66a8
8f61b29c:	e306253c 	movw	r2, #25916	; 0x653c
8f61b2a0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61b2a4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61b2a8:	e58d3000 	str	r3, [r13]
8f61b2ac:	e3001130 	movw	r1, #304	; 0x130
8f61b2b0:	e30036c8 	movw	r3, #1736	; 0x6c8
8f61b2b4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61b2b8:	eb005dff 	bl	8f632abc <_panic>
8f61b2bc:	eafffed4 	b	8f61ae14 <dwc_request_queue+0x8c>
		return -1;
8f61b2c0:	e3e05000 	mvn	r5, #0
8f61b2c4:	eaffff57 	b	8f61b028 <dwc_request_queue+0x2a0>
}
8f61b2c8:	eb005e3c 	bl	8f632bc0 <__stack_chk_fail>
8f61b2cc:	8f74221c 	.word	0x8f74221c

8f61b2d0 <dwc_ep_ctrl_state_setup_enter>:
{
8f61b2d0:	e92d4030 	push	{r4, r5, r14}
	memset(dev->setup_pkt, 0, DWC_SETUP_PKT_LEN);
8f61b2d4:	e2804a01 	add	r4, r0, #4096	; 0x1000
{
8f61b2d8:	e59f3084 	ldr	r3, [pc, #132]	; 8f61b364 <dwc_ep_ctrl_state_setup_enter+0x94>
8f61b2dc:	e24dd01c 	sub	r13, r13, #28
	memset(dev->setup_pkt, 0, DWC_SETUP_PKT_LEN);
8f61b2e0:	e3a02008 	mov	r2, #8
{
8f61b2e4:	e1a05000 	mov	r5, r0
	memset(dev->setup_pkt, 0, DWC_SETUP_PKT_LEN);
8f61b2e8:	e3a01000 	mov	r1, #0
8f61b2ec:	e59401d8 	ldr	r0, [r4, #472]	; 0x1d8
{
8f61b2f0:	e5933000 	ldr	r3, [r3]
8f61b2f4:	e58d3014 	str	r3, [r13, #20]
8f61b2f8:	e3a03000 	mov	r3, #0
	memset(dev->setup_pkt, 0, DWC_SETUP_PKT_LEN);
8f61b2fc:	eb0063f0 	bl	8f6342c4 <memset>
	arch_clean_invalidate_cache_range((addr_t) dev->setup_pkt, DWC_SETUP_PKT_LEN);
8f61b300:	e59401d8 	ldr	r0, [r4, #472]	; 0x1d8
8f61b304:	e3a01008 	mov	r1, #8
8f61b308:	eb001724 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	req.data     = dev->setup_pkt;
8f61b30c:	e59431d8 	ldr	r3, [r4, #472]	; 0x1d8
	req.callback = NULL;
8f61b310:	e3a01000 	mov	r1, #0
	dwc_request_queue(dev, 0, &req);
8f61b314:	e1a0200d 	mov	r2, r13
8f61b318:	e1a00005 	mov	r0, r5
	req.len      = DWC_SETUP_PKT_LEN;
8f61b31c:	e3a0c008 	mov	r12, #8
	req.callback = NULL;
8f61b320:	e58d1010 	str	r1, [r13, #16]
	req.data     = dev->setup_pkt;
8f61b324:	e88d1008 	stm	r13, {r3, r12}
	req.trbctl   = TRBCTL_CONTROL_SETUP;
8f61b328:	e3a03002 	mov	r3, #2
	req.context  = NULL;
8f61b32c:	e58d100c 	str	r1, [r13, #12]
	req.trbctl   = TRBCTL_CONTROL_SETUP;
8f61b330:	e5cd3008 	strb	r3, [r13, #8]
	dwc_request_queue(dev, 0, &req);
8f61b334:	ebfffe93 	bl	8f61ad88 <dwc_request_queue>
	dev->ctrl_state = EP_FSM_SETUP;
8f61b338:	e3a03001 	mov	r3, #1
8f61b33c:	e5c431d4 	strb	r3, [r4, #468]	; 0x1d4
}
8f61b340:	e59f301c 	ldr	r3, [pc, #28]	; 8f61b364 <dwc_ep_ctrl_state_setup_enter+0x94>
8f61b344:	e5932000 	ldr	r2, [r3]
8f61b348:	e59d3014 	ldr	r3, [r13, #20]
8f61b34c:	e0332002 	eors	r2, r3, r2
8f61b350:	e3a03000 	mov	r3, #0
8f61b354:	1a000001 	bne	8f61b360 <dwc_ep_ctrl_state_setup_enter+0x90>
8f61b358:	e28dd01c 	add	r13, r13, #28
8f61b35c:	e8bd8030 	pop	{r4, r5, r15}
8f61b360:	eb005e16 	bl	8f632bc0 <__stack_chk_fail>
8f61b364:	8f74221c 	.word	0x8f74221c

8f61b368 <dwc_print_ep_event_details.constprop.0>:
static void dwc_print_ep_event_details(dwc_dev_t *dev, uint32_t *event)
8f61b368:	e92d4070 	push	{r4, r5, r6, r14}
8f61b36c:	e1a05000 	mov	r5, r0
8f61b370:	e59f30f8 	ldr	r3, [pc, #248]	; 8f61b470 <dwc_print_ep_event_details.constprop.0+0x108>
8f61b374:	e24dd008 	sub	r13, r13, #8
	dwc_event_ep_event_id_t event_id   = DWC_EVENT_EP_EVENT_ID(*event);
8f61b378:	e5954000 	ldr	r4, [r5]
	ERR("\n\n");
8f61b37c:	e3060788 	movw	r0, #26504	; 0x6788
8f61b380:	e3480f70 	movt	r0, #36720	; 0x8f70
static void dwc_print_ep_event_details(dwc_dev_t *dev, uint32_t *event)
8f61b384:	e5933000 	ldr	r3, [r3]
8f61b388:	e58d3004 	str	r3, [r13, #4]
8f61b38c:	e3a03000 	mov	r3, #0
	ERR("\n\n");
8f61b390:	eb005d77 	bl	8f632974 <_dprintf>
	ERR("EP event (0x%x) details\n", *event);
8f61b394:	e5951000 	ldr	r1, [r5]
8f61b398:	e306078c 	movw	r0, #26508	; 0x678c
8f61b39c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b3a0:	eb005d73 	bl	8f632974 <_dprintf>
	ERR("event_id         = %d, %s\n", event_id, event_lookup_ep[event_id]);
8f61b3a4:	e7e31354 	ubfx	r1, r4, #6, #4
8f61b3a8:	e3023b74 	movw	r3, #11124	; 0x2b74
8f61b3ac:	e3483f74 	movt	r3, #36724	; 0x8f74
8f61b3b0:	e30607a8 	movw	r0, #26536	; 0x67a8
8f61b3b4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b3b8:	e7932101 	ldr	r2, [r3, r1, lsl #2]
	uint8_t  event_ctrl_stage          = DWC_EVENT_EP_EVENT_CTRL_STAGE(*event);
8f61b3bc:	e7e76654 	ubfx	r6, r4, #12, #8
	ERR("event_id         = %d, %s\n", event_id, event_lookup_ep[event_id]);
8f61b3c0:	eb005d6b 	bl	8f632974 <_dprintf>
	ERR("ep_phy_num       = %d\n", ep_phy_num);
8f61b3c4:	e7e410d4 	ubfx	r1, r4, #1, #5
8f61b3c8:	e30607c4 	movw	r0, #26564	; 0x67c4
8f61b3cc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b3d0:	eb005d67 	bl	8f632974 <_dprintf>
	ERR("event_ctrl_stage = %d, %s\n", event_ctrl_stage, dev_ctrl_state_lookup[event_ctrl_stage]);
8f61b3d4:	e2061003 	and	r1, r6, #3
8f61b3d8:	e3023c64 	movw	r3, #11364	; 0x2c64
8f61b3dc:	e3483f74 	movt	r3, #36724	; 0x8f74
8f61b3e0:	e30607dc 	movw	r0, #26588	; 0x67dc
8f61b3e4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b3e8:	e7932101 	ldr	r2, [r3, r1, lsl #2]
	uint8_t  xfer_res_idx              = DWC_EVENT_EP_EVENT_XFER_RES_IDX(*event);
8f61b3ec:	e1a05824 	lsr	r5, r4, #16
	ERR("event_ctrl_stage = %d, %s\n", event_ctrl_stage, dev_ctrl_state_lookup[event_ctrl_stage]);
8f61b3f0:	eb005d5f 	bl	8f632974 <_dprintf>
	ERR("event_status     = %d\n", event_status);
8f61b3f4:	e206100f 	and	r1, r6, #15
8f61b3f8:	e30607f8 	movw	r0, #26616	; 0x67f8
8f61b3fc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b400:	eb005d5b 	bl	8f632974 <_dprintf>
	ERR("xfer_res_idx     = %d\n", xfer_res_idx);
8f61b404:	e205107f 	and	r1, r5, #127	; 0x7f
8f61b408:	e3060810 	movw	r0, #26640	; 0x6810
8f61b40c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b410:	eb005d57 	bl	8f632974 <_dprintf>
	ERR("event_param      = %d\n", event_param);
8f61b414:	e1a01005 	mov	r1, r5
8f61b418:	e3060828 	movw	r0, #26664	; 0x6828
8f61b41c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b420:	eb005d53 	bl	8f632974 <_dprintf>
	ERR("event_cmd_type   = %d, %s\n", cmd, cmd_lookup[cmd]);
8f61b424:	e7e31c54 	ubfx	r1, r4, #24, #4
8f61b428:	e3023bc4 	movw	r3, #11204	; 0x2bc4
8f61b42c:	e3483f74 	movt	r3, #36724	; 0x8f74
8f61b430:	e3060840 	movw	r0, #26688	; 0x6840
8f61b434:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b438:	e7932101 	ldr	r2, [r3, r1, lsl #2]
8f61b43c:	eb005d4c 	bl	8f632974 <_dprintf>
	ERR("\n");
8f61b440:	e59f3028 	ldr	r3, [pc, #40]	; 8f61b470 <dwc_print_ep_event_details.constprop.0+0x108>
8f61b444:	e5932000 	ldr	r2, [r3]
8f61b448:	e59d3004 	ldr	r3, [r13, #4]
8f61b44c:	e0332002 	eors	r2, r3, r2
8f61b450:	e3a03000 	mov	r3, #0
8f61b454:	1a000004 	bne	8f61b46c <dwc_print_ep_event_details.constprop.0+0x104>
8f61b458:	e3030778 	movw	r0, #14200	; 0x3778
8f61b45c:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f61b460:	e28dd008 	add	r13, r13, #8
8f61b464:	e8bd4070 	pop	{r4, r5, r6, r14}
	ERR("\n");
8f61b468:	ea005d41 	b	8f632974 <_dprintf>
8f61b46c:	eb005dd3 	bl	8f632bc0 <__stack_chk_fail>
8f61b470:	8f74221c 	.word	0x8f74221c

8f61b474 <dwc_debug_lookup_init>:
{
8f61b474:	e92d4010 	push	{r4, r14}
	event_lookup_ep[DWC_EVENT_EP_CMD_COMPLETE]     = "DWC_EVENT_EP_CMD_COMPLETE    ";
8f61b478:	e3021b74 	movw	r1, #11124	; 0x2b74
{
8f61b47c:	e59fe348 	ldr	r14, [pc, #840]	; 8f61b7cc <dwc_debug_lookup_init+0x358>
	event_lookup_ep[DWC_EVENT_EP_CMD_COMPLETE]     = "DWC_EVENT_EP_CMD_COMPLETE    ";
8f61b480:	e3481f74 	movt	r1, #36724	; 0x8f74
{
8f61b484:	e24dd008 	sub	r13, r13, #8
	event_lookup_device[DWC_EVENT_DEVICE_EVENT_ID_VENDOR_DEVICE_TEST_LMP] = "DWC_EVENT_DEVICE_EVENT_ID_VENDOR_DEVICE_TEST_LMP";
8f61b488:	e3023a34 	movw	r3, #10804	; 0x2a34
{
8f61b48c:	e59ee000 	ldr	r14, [r14]
8f61b490:	e58de004 	str	r14, [r13, #4]
8f61b494:	e3a0e000 	mov	r14, #0
	event_lookup_device[DWC_EVENT_DEVICE_EVENT_ID_VENDOR_DEVICE_TEST_LMP] = "DWC_EVENT_DEVICE_EVENT_ID_VENDOR_DEVICE_TEST_LMP";
8f61b498:	e3483f74 	movt	r3, #36724	; 0x8f74
	dev_ctrl_state_lookup[EP_FSM_INIT]            = "EP_FSM_INIT           ";
8f61b49c:	e3022c64 	movw	r2, #11364	; 0x2c64
	ep_state_lookup[EP_STATE_INIT]                = "EP_STATE_INIT";
8f61b4a0:	e302cb24 	movw	r12, #11044	; 0x2b24
	dev_ctrl_state_lookup[EP_FSM_INIT]            = "EP_FSM_INIT           ";
8f61b4a4:	e3482f74 	movt	r2, #36724	; 0x8f74
	ep_state_lookup[EP_STATE_INIT]                = "EP_STATE_INIT";
8f61b4a8:	e348cf74 	movt	r12, #36724	; 0x8f74
	event_lookup_ep[DWC_EVENT_EP_CMD_COMPLETE]     = "DWC_EVENT_EP_CMD_COMPLETE    ";
8f61b4ac:	e306085c 	movw	r0, #26716	; 0x685c
8f61b4b0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b4b4:	e581001c 	str	r0, [r1, #28]
	event_lookup_ep[DWC_EVENT_EP_XFER_NOT_READY]   = "DWC_EVENT_EP_XFER_NOT_READY  ";
8f61b4b8:	e306087c 	movw	r0, #26748	; 0x687c
8f61b4bc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b4c0:	e581000c 	str	r0, [r1, #12]
	event_lookup_ep[DWC_EVENT_EP_XFER_IN_PROGRESS] = "DWC_EVENT_EP_XFER_IN_PROGRESS";
8f61b4c4:	e306089c 	movw	r0, #26780	; 0x689c
8f61b4c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b4cc:	e5810008 	str	r0, [r1, #8]
	event_lookup_ep[DWC_EVENT_EP_XFER_COMPLETE]    = "DWC_EVENT_EP_XFER_COMPLETE   ";
8f61b4d0:	e30608bc 	movw	r0, #26812	; 0x68bc
8f61b4d4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b4d8:	e5810004 	str	r0, [r1, #4]
	hs_link_state_lookup[ON]            = "ON           ";
8f61b4dc:	e3021a84 	movw	r1, #10884	; 0x2a84
8f61b4e0:	e3481f74 	movt	r1, #36724	; 0x8f74
	event_lookup_device[DWC_EVENT_DEVICE_EVENT_ID_VENDOR_DEVICE_TEST_LMP] = "DWC_EVENT_DEVICE_EVENT_ID_VENDOR_DEVICE_TEST_LMP";
8f61b4e4:	e30608dc 	movw	r0, #26844	; 0x68dc
8f61b4e8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b4ec:	e5830030 	str	r0, [r3, #48]	; 0x30
	event_lookup_device[DWC_EVENT_DEVICE_EVENT_ID_BUFFER_OVERFLOW]        = "DWC_EVENT_DEVICE_EVENT_ID_BUFFER_OVERFLOW       ";
8f61b4f0:	e3060910 	movw	r0, #26896	; 0x6910
8f61b4f4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b4f8:	e583002c 	str	r0, [r3, #44]	; 0x2c
	event_lookup_device[DWC_EVENT_DEVICE_EVENT_ID_GENERIC_CMD_COMPLETE]   = "DWC_EVENT_DEVICE_EVENT_ID_GENERIC_CMD_COMPLETE  ";
8f61b4fc:	e3060944 	movw	r0, #26948	; 0x6944
8f61b500:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b504:	e5830028 	str	r0, [r3, #40]	; 0x28
	event_lookup_device[DWC_EVENT_DEVICE_EVENT_ID_ERRATIC_ERROR]          = "DWC_EVENT_DEVICE_EVENT_ID_ERRATIC_ERROR         ";
8f61b508:	e3060978 	movw	r0, #27000	; 0x6978
8f61b50c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b510:	e5830024 	str	r0, [r3, #36]	; 0x24
	event_lookup_device[DWC_EVENT_DEVICE_EVENT_ID_SOF]                    = "DWC_EVENT_DEVICE_EVENT_ID_SOF                   ";
8f61b514:	e30609ac 	movw	r0, #27052	; 0x69ac
8f61b518:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b51c:	e583001c 	str	r0, [r3, #28]
	event_lookup_device[DWC_EVENT_DEVICE_EVENT_ID_SUSPEND_ENTRY]          = "DWC_EVENT_DEVICE_EVENT_ID_SUSPEND_ENTRY         ";
8f61b520:	e30609e0 	movw	r0, #27104	; 0x69e0
8f61b524:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b528:	e5830018 	str	r0, [r3, #24]
	event_lookup_device[DWC_EVENT_DEVICE_EVENT_ID_HIBER]                  = "DWC_EVENT_DEVICE_EVENT_ID_HIBER                 ";
8f61b52c:	e3060a14 	movw	r0, #27156	; 0x6a14
8f61b530:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b534:	e5830014 	str	r0, [r3, #20]
	event_lookup_device[DWC_EVENT_DEVICE_EVENT_ID_WAKEUP]                 = "DWC_EVENT_DEVICE_EVENT_ID_WAKEUP                ";
8f61b538:	e3060a48 	movw	r0, #27208	; 0x6a48
8f61b53c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b540:	e5830010 	str	r0, [r3, #16]
	event_lookup_device[DWC_EVENT_DEVICE_EVENT_ID_USB_LINK_STATUS_CHANGE] = "DWC_EVENT_DEVICE_EVENT_ID_USB_LINK_STATUS_CHANGE";
8f61b544:	e3060a7c 	movw	r0, #27260	; 0x6a7c
8f61b548:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b54c:	e583000c 	str	r0, [r3, #12]
	event_lookup_device[DWC_EVENT_DEVICE_EVENT_ID_CONNECT_DONE]           = "DWC_EVENT_DEVICE_EVENT_ID_CONNECT_DONE          ";
8f61b550:	e3060ab0 	movw	r0, #27312	; 0x6ab0
8f61b554:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b558:	e5830008 	str	r0, [r3, #8]
	event_lookup_device[DWC_EVENT_DEVICE_EVENT_ID_USB_RESET]              = "DWC_EVENT_DEVICE_EVENT_ID_USB_RESET             ";
8f61b55c:	e3060ae4 	movw	r0, #27364	; 0x6ae4
8f61b560:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b564:	e5830004 	str	r0, [r3, #4]
	event_lookup_device[DWC_EVENT_DEVICE_EVENT_ID_DISCONNECT]             = "DWC_EVENT_DEVICE_EVENT_ID_DISCONNECT            ";
8f61b568:	e3060b18 	movw	r0, #27416	; 0x6b18
8f61b56c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b570:	e5830000 	str	r0, [r3]
	ss_link_state_lookup[U0]            = "U0          ";
8f61b574:	e3023ad4 	movw	r3, #10964	; 0x2ad4
	dev_ctrl_state_lookup[EP_FSM_INIT]            = "EP_FSM_INIT           ";
8f61b578:	e3060b4c 	movw	r0, #27468	; 0x6b4c
	ss_link_state_lookup[U0]            = "U0          ";
8f61b57c:	e3483f74 	movt	r3, #36724	; 0x8f74
	dev_ctrl_state_lookup[EP_FSM_INIT]            = "EP_FSM_INIT           ";
8f61b580:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b584:	e5820000 	str	r0, [r2]
	dev_ctrl_state_lookup[EP_FSM_SETUP]           = "EP_FSM_SETUP          ";
8f61b588:	e3060b64 	movw	r0, #27492	; 0x6b64
8f61b58c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b590:	e5820004 	str	r0, [r2, #4]
	dev_ctrl_state_lookup[EP_FSM_CTRL_DATA]       = "EP_FSM_CTRL_DATA      ";
8f61b594:	e3060b7c 	movw	r0, #27516	; 0x6b7c
8f61b598:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b59c:	e5820008 	str	r0, [r2, #8]
	dev_ctrl_state_lookup[EP_FSM_WAIT_FOR_HOST_2] = "EP_FSM_WAIT_FOR_HOST_2";
8f61b5a0:	e3060b94 	movw	r0, #27540	; 0x6b94
8f61b5a4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b5a8:	e582000c 	str	r0, [r2, #12]
	dev_ctrl_state_lookup[EP_FSM_WAIT_FOR_HOST_3] = "EP_FSM_WAIT_FOR_HOST_3";
8f61b5ac:	e3060bac 	movw	r0, #27564	; 0x6bac
8f61b5b0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b5b4:	e5820010 	str	r0, [r2, #16]
	dev_ctrl_state_lookup[EP_FSM_STATUS_2]        = "EP_FSM_STATUS_2       ";
8f61b5b8:	e3060bc4 	movw	r0, #27588	; 0x6bc4
8f61b5bc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b5c0:	e5820014 	str	r0, [r2, #20]
	dev_ctrl_state_lookup[EP_FSM_STATUS_3]        = "EP_FSM_STATUS_3       ";
8f61b5c4:	e3060bdc 	movw	r0, #27612	; 0x6bdc
8f61b5c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b5cc:	e5820018 	str	r0, [r2, #24]
	dev_ctrl_state_lookup[EP_FSM_STALL]           = "EP_FSM_STALL          ";
8f61b5d0:	e3060bf4 	movw	r0, #27636	; 0x6bf4
8f61b5d4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61b5d8:	e582001c 	str	r0, [r2, #28]
	speed_lookup[DSTS_CONNECTSPD_HS]  = "DSTS_CONNECTSPD_HS ";
8f61b5dc:	e3020c14 	movw	r0, #11284	; 0x2c14
	ep_state_lookup[EP_STATE_INIT]                = "EP_STATE_INIT";
8f61b5e0:	e3062c0c 	movw	r2, #27660	; 0x6c0c
	speed_lookup[DSTS_CONNECTSPD_HS]  = "DSTS_CONNECTSPD_HS ";
8f61b5e4:	e3480f74 	movt	r0, #36724	; 0x8f74
	ep_state_lookup[EP_STATE_INIT]                = "EP_STATE_INIT";
8f61b5e8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61b5ec:	e58c2000 	str	r2, [r12]
	ep_state_lookup[EP_STATE_INACTIVE]            = "EP_STATE_INACTIVE";
8f61b5f0:	e3062c1c 	movw	r2, #27676	; 0x6c1c
8f61b5f4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61b5f8:	e58c2004 	str	r2, [r12, #4]
	ep_state_lookup[EP_STATE_START_TRANSFER]      = "EP_STATE_START_TRANSFER";
8f61b5fc:	e3062c30 	movw	r2, #27696	; 0x6c30
8f61b600:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61b604:	e58c2008 	str	r2, [r12, #8]
	ep_state_lookup[EP_STATE_XFER_IN_PROG]        = "EP_STATE_XFER_IN_PROG";
8f61b608:	e3062c48 	movw	r2, #27720	; 0x6c48
8f61b60c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61b610:	e58c200c 	str	r2, [r12, #12]
	hs_link_state_lookup[ON]            = "ON           ";
8f61b614:	e306cc60 	movw	r12, #27744	; 0x6c60
	hs_link_state_lookup[L1]            = "L1           ";
8f61b618:	e3062c70 	movw	r2, #27760	; 0x6c70
	hs_link_state_lookup[ON]            = "ON           ";
8f61b61c:	e348cf70 	movt	r12, #36720	; 0x8f70
	hs_link_state_lookup[L1]            = "L1           ";
8f61b620:	e3482f70 	movt	r2, #36720	; 0x8f70
	hs_link_state_lookup[ON]            = "ON           ";
8f61b624:	e581c000 	str	r12, [r1]
	ss_link_state_lookup[U0]            = "U0          ";
8f61b628:	e306ecd0 	movw	r14, #27856	; 0x6cd0
	hs_link_state_lookup[L1]            = "L1           ";
8f61b62c:	e5812008 	str	r2, [r1, #8]
	hs_link_state_lookup[DISCONNECTED]  = "DISCONNECTED ";
8f61b630:	e3062c90 	movw	r2, #27792	; 0x6c90
8f61b634:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61b638:	e5812010 	str	r2, [r1, #16]
	hs_link_state_lookup[RESET]         = "RESET        ";
8f61b63c:	e3062cb0 	movw	r2, #27824	; 0x6cb0
8f61b640:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61b644:	e5812038 	str	r2, [r1, #56]	; 0x38
	hs_link_state_lookup[RESUME]        = "RESUME       ";
8f61b648:	e3062cc0 	movw	r2, #27840	; 0x6cc0
8f61b64c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61b650:	e581203c 	str	r2, [r1, #60]	; 0x3c
	cmd_lookup[DEPCMD_CMD_SET_EP_CONF]     = "DEPCMD_CMD_SET_EP_CONF    ";
8f61b654:	e3022bc4 	movw	r2, #11204	; 0x2bc4
8f61b658:	e3482f74 	movt	r2, #36724	; 0x8f74
	ss_link_state_lookup[U0]            = "U0          ";
8f61b65c:	e348ef70 	movt	r14, #36720	; 0x8f70
	hs_link_state_lookup[L2]            = "L2           ";
8f61b660:	e306cc80 	movw	r12, #27776	; 0x6c80
	ss_link_state_lookup[U0]            = "U0          ";
8f61b664:	e583e000 	str	r14, [r3]
	hs_link_state_lookup[L2]            = "L2           ";
8f61b668:	e348cf70 	movt	r12, #36720	; 0x8f70
8f61b66c:	e581c00c 	str	r12, [r1, #12]
	hs_link_state_lookup[EARLY_SUSPEND] = "EARLY_SUSPEND";
8f61b670:	e306cca0 	movw	r12, #27808	; 0x6ca0
8f61b674:	e348cf70 	movt	r12, #36720	; 0x8f70
8f61b678:	e581c014 	str	r12, [r1, #20]
	ss_link_state_lookup[U1]            = "U1          ";
8f61b67c:	e306cce0 	movw	r12, #27872	; 0x6ce0
	ss_link_state_lookup[U2]            = "U2          ";
8f61b680:	e3061cf0 	movw	r1, #27888	; 0x6cf0
	ss_link_state_lookup[U1]            = "U1          ";
8f61b684:	e348cf70 	movt	r12, #36720	; 0x8f70
	ss_link_state_lookup[U2]            = "U2          ";
8f61b688:	e3481f70 	movt	r1, #36720	; 0x8f70
	ss_link_state_lookup[U1]            = "U1          ";
8f61b68c:	e583c004 	str	r12, [r3, #4]
	ss_link_state_lookup[U3]            = "U3          ";
8f61b690:	e306cd00 	movw	r12, #27904	; 0x6d00
	ss_link_state_lookup[U2]            = "U2          ";
8f61b694:	e5831008 	str	r1, [r3, #8]
	ss_link_state_lookup[U3]            = "U3          ";
8f61b698:	e348cf70 	movt	r12, #36720	; 0x8f70
	ss_link_state_lookup[SS_DIS]        = "SS_DIS      ";
8f61b69c:	e3061d10 	movw	r1, #27920	; 0x6d10
	ss_link_state_lookup[U3]            = "U3          ";
8f61b6a0:	e583c00c 	str	r12, [r3, #12]
	ss_link_state_lookup[SS_DIS]        = "SS_DIS      ";
8f61b6a4:	e3481f70 	movt	r1, #36720	; 0x8f70
	ss_link_state_lookup[RX_DET]        = "RX_DET      ";
8f61b6a8:	e306cd20 	movw	r12, #27936	; 0x6d20
	ss_link_state_lookup[SS_DIS]        = "SS_DIS      ";
8f61b6ac:	e5831010 	str	r1, [r3, #16]
	ss_link_state_lookup[RX_DET]        = "RX_DET      ";
8f61b6b0:	e348cf70 	movt	r12, #36720	; 0x8f70
	ss_link_state_lookup[SS_INACT]      = "SS_INACT    ";
8f61b6b4:	e3061d30 	movw	r1, #27952	; 0x6d30
	ss_link_state_lookup[RX_DET]        = "RX_DET      ";
8f61b6b8:	e583c014 	str	r12, [r3, #20]
	ss_link_state_lookup[SS_INACT]      = "SS_INACT    ";
8f61b6bc:	e3481f70 	movt	r1, #36720	; 0x8f70
	ss_link_state_lookup[POLL]          = "POLL        ";
8f61b6c0:	e306cd40 	movw	r12, #27968	; 0x6d40
	ss_link_state_lookup[SS_INACT]      = "SS_INACT    ";
8f61b6c4:	e5831018 	str	r1, [r3, #24]
	ss_link_state_lookup[POLL]          = "POLL        ";
8f61b6c8:	e348cf70 	movt	r12, #36720	; 0x8f70
	ss_link_state_lookup[RECOV]         = "RECOV       ";
8f61b6cc:	e3061d50 	movw	r1, #27984	; 0x6d50
	ss_link_state_lookup[POLL]          = "POLL        ";
8f61b6d0:	e583c01c 	str	r12, [r3, #28]
	ss_link_state_lookup[RECOV]         = "RECOV       ";
8f61b6d4:	e3481f70 	movt	r1, #36720	; 0x8f70
	ss_link_state_lookup[HRESET]        = "HRESET      ";
8f61b6d8:	e306cd60 	movw	r12, #28000	; 0x6d60
	ss_link_state_lookup[RECOV]         = "RECOV       ";
8f61b6dc:	e5831020 	str	r1, [r3, #32]
	ss_link_state_lookup[HRESET]        = "HRESET      ";
8f61b6e0:	e348cf70 	movt	r12, #36720	; 0x8f70
	ss_link_state_lookup[CMPLY]         = "CMPLY       ";
8f61b6e4:	e3061d70 	movw	r1, #28016	; 0x6d70
	ss_link_state_lookup[HRESET]        = "HRESET      ";
8f61b6e8:	e583c024 	str	r12, [r3, #36]	; 0x24
	ss_link_state_lookup[CMPLY]         = "CMPLY       ";
8f61b6ec:	e3481f70 	movt	r1, #36720	; 0x8f70
	ss_link_state_lookup[LPBK]          = "LPBK        ";
8f61b6f0:	e306cd80 	movw	r12, #28032	; 0x6d80
	ss_link_state_lookup[CMPLY]         = "CMPLY       ";
8f61b6f4:	e5831028 	str	r1, [r3, #40]	; 0x28
	ss_link_state_lookup[LPBK]          = "LPBK        ";
8f61b6f8:	e348cf70 	movt	r12, #36720	; 0x8f70
	ss_link_state_lookup[RESUME_RESET]  = "RESUME_RESET";
8f61b6fc:	e3061d90 	movw	r1, #28048	; 0x6d90
	ss_link_state_lookup[LPBK]          = "LPBK        ";
8f61b700:	e583c02c 	str	r12, [r3, #44]	; 0x2c
	ss_link_state_lookup[RESUME_RESET]  = "RESUME_RESET";
8f61b704:	e3481f70 	movt	r1, #36720	; 0x8f70
	speed_lookup[DSTS_CONNECTSPD_HS]  = "DSTS_CONNECTSPD_HS ";
8f61b708:	e306cda0 	movw	r12, #28064	; 0x6da0
	ss_link_state_lookup[RESUME_RESET]  = "RESUME_RESET";
8f61b70c:	e583103c 	str	r1, [r3, #60]	; 0x3c
	speed_lookup[DSTS_CONNECTSPD_HS]  = "DSTS_CONNECTSPD_HS ";
8f61b710:	e348cf70 	movt	r12, #36720	; 0x8f70
	speed_lookup[DSTS_CONNECTSPD_FS1] = "DSTS_CONNECTSPD_FS1";
8f61b714:	e3063db4 	movw	r3, #28084	; 0x6db4
	speed_lookup[DSTS_CONNECTSPD_HS]  = "DSTS_CONNECTSPD_HS ";
8f61b718:	e580c000 	str	r12, [r0]
	speed_lookup[DSTS_CONNECTSPD_FS1] = "DSTS_CONNECTSPD_FS1";
8f61b71c:	e3483f70 	movt	r3, #36720	; 0x8f70
	speed_lookup[DSTS_CONNECTSPD_LS]  = "DSTS_CONNECTSPD_LS ";
8f61b720:	e3061dc8 	movw	r1, #28104	; 0x6dc8
	speed_lookup[DSTS_CONNECTSPD_FS1] = "DSTS_CONNECTSPD_FS1";
8f61b724:	e5803004 	str	r3, [r0, #4]
	speed_lookup[DSTS_CONNECTSPD_LS]  = "DSTS_CONNECTSPD_LS ";
8f61b728:	e3481f70 	movt	r1, #36720	; 0x8f70
	speed_lookup[DSTS_CONNECTSPD_FS2] = "DSTS_CONNECTSPD_FS1";
8f61b72c:	e580300c 	str	r3, [r0, #12]
	cmd_lookup[DEPCMD_CMD_SET_EP_CONF]     = "DEPCMD_CMD_SET_EP_CONF    ";
8f61b730:	e306cdf0 	movw	r12, #28144	; 0x6df0
	speed_lookup[DSTS_CONNECTSPD_LS]  = "DSTS_CONNECTSPD_LS ";
8f61b734:	e5801008 	str	r1, [r0, #8]
	cmd_lookup[DEPCMD_CMD_SET_EP_CONF]     = "DEPCMD_CMD_SET_EP_CONF    ";
8f61b738:	e348cf70 	movt	r12, #36720	; 0x8f70
	speed_lookup[DSTS_CONNECTSPD_SS]  = "DSTS_CONNECTSPD_SS ";
8f61b73c:	e3061ddc 	movw	r1, #28124	; 0x6ddc
	cmd_lookup[DEPCMD_CMD_SET_EP_CONF]     = "DEPCMD_CMD_SET_EP_CONF    ";
8f61b740:	e582c004 	str	r12, [r2, #4]
	speed_lookup[DSTS_CONNECTSPD_SS]  = "DSTS_CONNECTSPD_SS ";
8f61b744:	e3481f70 	movt	r1, #36720	; 0x8f70
	cmd_lookup[DEPCMD_CMD_SET_TR_CONF]     = "DEPCMD_CMD_SET_TR_CONF    ";
8f61b748:	e3063e0c 	movw	r3, #28172	; 0x6e0c
	speed_lookup[DSTS_CONNECTSPD_SS]  = "DSTS_CONNECTSPD_SS ";
8f61b74c:	e5801010 	str	r1, [r0, #16]
	cmd_lookup[DEPCMD_CMD_SET_TR_CONF]     = "DEPCMD_CMD_SET_TR_CONF    ";
8f61b750:	e3483f70 	movt	r3, #36720	; 0x8f70
	cmd_lookup[DEPCMD_CMD_GET_EP_STATE]    = "DEPCMD_CMD_GET_EP_STATE   ";
8f61b754:	e3060e28 	movw	r0, #28200	; 0x6e28
	cmd_lookup[DEPCMD_CMD_SET_TR_CONF]     = "DEPCMD_CMD_SET_TR_CONF    ";
8f61b758:	e5823008 	str	r3, [r2, #8]
	cmd_lookup[DEPCMD_CMD_GET_EP_STATE]    = "DEPCMD_CMD_GET_EP_STATE   ";
8f61b75c:	e3480f70 	movt	r0, #36720	; 0x8f70
	cmd_lookup[DEPCMD_CMD_SET_STALL]       = "DEPCMD_CMD_SET_STALL      ";
8f61b760:	e3061e44 	movw	r1, #28228	; 0x6e44
	cmd_lookup[DEPCMD_CMD_CLEAR_STALL]     = "DEPCMD_CMD_CLEAR_STALL    ";
8f61b764:	e306ce60 	movw	r12, #28256	; 0x6e60
	cmd_lookup[DEPCMD_CMD_SET_STALL]       = "DEPCMD_CMD_SET_STALL      ";
8f61b768:	e3481f70 	movt	r1, #36720	; 0x8f70
	cmd_lookup[DEPCMD_CMD_CLEAR_STALL]     = "DEPCMD_CMD_CLEAR_STALL    ";
8f61b76c:	e348cf70 	movt	r12, #36720	; 0x8f70
	cmd_lookup[DEPCMD_CMD_SET_STALL]       = "DEPCMD_CMD_SET_STALL      ";
8f61b770:	e1c200fc 	strd	r0, [r2, #12]
	cmd_lookup[DEPCMD_CMD_CLEAR_STALL]     = "DEPCMD_CMD_CLEAR_STALL    ";
8f61b774:	e582c014 	str	r12, [r2, #20]
	cmd_lookup[DEPCMD_CMD_START_TRANSFER]  = "DEPCMD_CMD_START_TRANSFER ";
8f61b778:	e3063e7c 	movw	r3, #28284	; 0x6e7c
	cmd_lookup[DEPCMD_CMD_UPDATE_TRANSFER] = "DEPCMD_CMD_UPDATE_TRANSFER";
8f61b77c:	e3060e98 	movw	r0, #28312	; 0x6e98
	cmd_lookup[DEPCMD_CMD_START_TRANSFER]  = "DEPCMD_CMD_START_TRANSFER ";
8f61b780:	e3483f70 	movt	r3, #36720	; 0x8f70
	cmd_lookup[DEPCMD_CMD_UPDATE_TRANSFER] = "DEPCMD_CMD_UPDATE_TRANSFER";
8f61b784:	e3480f70 	movt	r0, #36720	; 0x8f70
	cmd_lookup[DEPCMD_CMD_START_TRANSFER]  = "DEPCMD_CMD_START_TRANSFER ";
8f61b788:	e5823018 	str	r3, [r2, #24]
	cmd_lookup[DEPCMD_CMD_UPDATE_TRANSFER] = "DEPCMD_CMD_UPDATE_TRANSFER";
8f61b78c:	e582001c 	str	r0, [r2, #28]
	cmd_lookup[DEPCMD_CMD_END_TRANSFER]    = "DEPCMD_CMD_END_TRANSFER   ";
8f61b790:	e3061eb4 	movw	r1, #28340	; 0x6eb4
	cmd_lookup[DEPCMD_CMD_START_NEW_CONF]  = "DEPCMD_CMD_START_NEW_CONF ";
8f61b794:	e3063ed0 	movw	r3, #28368	; 0x6ed0
	cmd_lookup[DEPCMD_CMD_END_TRANSFER]    = "DEPCMD_CMD_END_TRANSFER   ";
8f61b798:	e3481f70 	movt	r1, #36720	; 0x8f70
	cmd_lookup[DEPCMD_CMD_START_NEW_CONF]  = "DEPCMD_CMD_START_NEW_CONF ";
8f61b79c:	e3483f70 	movt	r3, #36720	; 0x8f70
	cmd_lookup[DEPCMD_CMD_END_TRANSFER]    = "DEPCMD_CMD_END_TRANSFER   ";
8f61b7a0:	e5821020 	str	r1, [r2, #32]
	cmd_lookup[DEPCMD_CMD_START_NEW_CONF]  = "DEPCMD_CMD_START_NEW_CONF ";
8f61b7a4:	e5823024 	str	r3, [r2, #36]	; 0x24
}
8f61b7a8:	e59f301c 	ldr	r3, [pc, #28]	; 8f61b7cc <dwc_debug_lookup_init+0x358>
8f61b7ac:	e5932000 	ldr	r2, [r3]
8f61b7b0:	e59d3004 	ldr	r3, [r13, #4]
8f61b7b4:	e0332002 	eors	r2, r3, r2
8f61b7b8:	e3a03000 	mov	r3, #0
8f61b7bc:	1a000001 	bne	8f61b7c8 <dwc_debug_lookup_init+0x354>
8f61b7c0:	e28dd008 	add	r13, r13, #8
8f61b7c4:	e8bd8010 	pop	{r4, r15}
8f61b7c8:	eb005cfc 	bl	8f632bc0 <__stack_chk_fail>
8f61b7cc:	8f74221c 	.word	0x8f74221c

8f61b7d0 <dwc_init>:
{
8f61b7d0:	e59f3150 	ldr	r3, [pc, #336]	; 8f61b928 <dwc_init+0x158>
8f61b7d4:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f61b7d8:	e1a06000 	mov	r6, r0
8f61b7dc:	e24dd010 	sub	r13, r13, #16
	dwc_dev_t *dev = (dwc_dev_t*) malloc(sizeof(dwc_dev_t));
8f61b7e0:	e30101f4 	movw	r0, #4596	; 0x11f4
{
8f61b7e4:	e5933000 	ldr	r3, [r3]
8f61b7e8:	e58d300c 	str	r3, [r13, #12]
8f61b7ec:	e3a03000 	mov	r3, #0
	dwc_dev_t *dev = (dwc_dev_t*) malloc(sizeof(dwc_dev_t));
8f61b7f0:	e1a0700e 	mov	r7, r14
8f61b7f4:	eb006200 	bl	8f633ffc <malloc>
	ASSERT(dev);
8f61b7f8:	e2504000 	subs	r4, r0, #0
8f61b7fc:	0a000032 	beq	8f61b8cc <dwc_init+0xfc>
	memset(dev, 0, sizeof(dwc_dev_t));
8f61b800:	e30121f4 	movw	r2, #4596	; 0x11f4
8f61b804:	e3a01000 	mov	r1, #0
8f61b808:	e1a00004 	mov	r0, r4
	dev->event_buf.buf       = config->event_buf;
8f61b80c:	e2845a01 	add	r5, r4, #4096	; 0x1000
	memset(dev, 0, sizeof(dwc_dev_t));
8f61b810:	eb0062ab 	bl	8f6342c4 <memset>
	dev->base                = config->base;
8f61b814:	e5963000 	ldr	r3, [r6]
	dev->notify_context      = config->notify_context;
8f61b818:	e596000c 	ldr	r0, [r6, #12]
	dev->event_buf.buf_size  = config->event_buf_size;
8f61b81c:	e2851f73 	add	r1, r5, #460	; 0x1cc
	dev->notify              = config->notify;
8f61b820:	e5962010 	ldr	r2, [r6, #16]
	dev->event_buf.index     = 0;
8f61b824:	e285ee1d 	add	r14, r5, #464	; 0x1d0
	dev->base                = config->base;
8f61b828:	e5843000 	str	r3, [r4]
	dev->event_buf.max_index = (config->event_buf_size)/4 - 1; /* (max num of 4 byte events) - 1 */
8f61b82c:	e300c1ce 	movw	r12, #462	; 0x1ce
	dev->event_buf.buf       = config->event_buf;
8f61b830:	e5963004 	ldr	r3, [r6, #4]
	dev->event_buf.index     = 0;
8f61b834:	e3a08000 	mov	r8, #0
	dev->event_buf.buf       = config->event_buf;
8f61b838:	e58531c8 	str	r3, [r5, #456]	; 0x1c8
	dev->event_buf.buf_size  = config->event_buf_size;
8f61b83c:	e1d630b8 	ldrh	r3, [r6, #8]
8f61b840:	e1c130b0 	strh	r3, [r1]
	dev->setup_pkt           =  memalign(CACHE_LINE, ROUNDUP(DWC_SETUP_PKT_LEN, CACHE_LINE));
8f61b844:	e3a01040 	mov	r1, #64	; 0x40
	dev->event_buf.max_index = (config->event_buf_size)/4 - 1; /* (max num of 4 byte events) - 1 */
8f61b848:	e1a03123 	lsr	r3, r3, #2
	dev->event_buf.index     = 0;
8f61b84c:	e1ce80b0 	strh	r8, [r14]
	dev->event_buf.max_index = (config->event_buf_size)/4 - 1; /* (max num of 4 byte events) - 1 */
8f61b850:	e2433001 	sub	r3, r3, #1
8f61b854:	e18530bc 	strh	r3, [r5, r12]
	dev->notify_context      = config->notify_context;
8f61b858:	e58501dc 	str	r0, [r5, #476]	; 0x1dc
	dev->setup_pkt           =  memalign(CACHE_LINE, ROUNDUP(DWC_SETUP_PKT_LEN, CACHE_LINE));
8f61b85c:	e1a00001 	mov	r0, r1
	dev->notify              = config->notify;
8f61b860:	e58521e0 	str	r2, [r5, #480]	; 0x1e0
	dev->setup_pkt           =  memalign(CACHE_LINE, ROUNDUP(DWC_SETUP_PKT_LEN, CACHE_LINE));
8f61b864:	eb0061f6 	bl	8f634044 <memalign>
	ASSERT(dev->setup_pkt);
8f61b868:	e1500008 	cmp	r0, r8
	dev->setup_pkt           =  memalign(CACHE_LINE, ROUNDUP(DWC_SETUP_PKT_LEN, CACHE_LINE));
8f61b86c:	e58501d8 	str	r0, [r5, #472]	; 0x1d8
	ASSERT(dev->setup_pkt);
8f61b870:	0a000020 	beq	8f61b8f8 <dwc_init+0x128>
	dev->setup_handler       = config->setup_handler;
8f61b874:	e1c621d4 	ldrd	r2, [r6, #20]
	dev->core_id = dwc_coreid(dev);
8f61b878:	e1a00004 	mov	r0, r4
	dev->setup_context       = config->setup_context;
8f61b87c:	e58521e4 	str	r2, [r5, #484]	; 0x1e4
	dev->setup_handler       = config->setup_handler;
8f61b880:	e58531e8 	str	r3, [r5, #488]	; 0x1e8
	dev->core_id = dwc_coreid(dev);
8f61b884:	eb000977 	bl	8f61de68 <dwc_coreid>
	register_int_handler(USB30_EE1_IRQ, dwc_irq_handler_ee1, dev);
8f61b888:	e1a02004 	mov	r2, r4
8f61b88c:	e30b1af0 	movw	r1, #47856	; 0xbaf0
8f61b890:	e3481f61 	movt	r1, #36705	; 0x8f61
	dev->core_id = dwc_coreid(dev);
8f61b894:	e1a03000 	mov	r3, r0
	register_int_handler(USB30_EE1_IRQ, dwc_irq_handler_ee1, dev);
8f61b898:	e3a000ac 	mov	r0, #172	; 0xac
	dev->core_id = dwc_coreid(dev);
8f61b89c:	e5843004 	str	r3, [r4, #4]
	register_int_handler(USB30_EE1_IRQ, dwc_irq_handler_ee1, dev);
8f61b8a0:	ebffce79 	bl	8f60f28c <register_int_handler>
	dwc_debug_lookup_init();
8f61b8a4:	ebfffef2 	bl	8f61b474 <dwc_debug_lookup_init>
}
8f61b8a8:	e59f3078 	ldr	r3, [pc, #120]	; 8f61b928 <dwc_init+0x158>
8f61b8ac:	e5932000 	ldr	r2, [r3]
8f61b8b0:	e59d300c 	ldr	r3, [r13, #12]
8f61b8b4:	e0332002 	eors	r2, r3, r2
8f61b8b8:	e3a03000 	mov	r3, #0
8f61b8bc:	1a000018 	bne	8f61b924 <dwc_init+0x154>
8f61b8c0:	e1a00004 	mov	r0, r4
8f61b8c4:	e28dd010 	add	r13, r13, #16
8f61b8c8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
	ASSERT(dev);
8f61b8cc:	e3071228 	movw	r1, #29224	; 0x7228
8f61b8d0:	e306253c 	movw	r2, #25916	; 0x653c
8f61b8d4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61b8d8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61b8dc:	e58d1000 	str	r1, [r13]
8f61b8e0:	e3a030d4 	mov	r3, #212	; 0xd4
8f61b8e4:	e3001130 	movw	r1, #304	; 0x130
8f61b8e8:	e1a00007 	mov	r0, r7
8f61b8ec:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61b8f0:	eb005c71 	bl	8f632abc <_panic>
8f61b8f4:	eaffffc1 	b	8f61b800 <dwc_init+0x30>
	ASSERT(dev->setup_pkt);
8f61b8f8:	e3063eec 	movw	r3, #28396	; 0x6eec
8f61b8fc:	e1a00007 	mov	r0, r7
8f61b900:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61b904:	e306253c 	movw	r2, #25916	; 0x653c
8f61b908:	e58d3000 	str	r3, [r13]
8f61b90c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61b910:	e3a030e4 	mov	r3, #228	; 0xe4
8f61b914:	e3001130 	movw	r1, #304	; 0x130
8f61b918:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61b91c:	eb005c66 	bl	8f632abc <_panic>
8f61b920:	eaffffd3 	b	8f61b874 <dwc_init+0xa4>
}
8f61b924:	eb005ca5 	bl	8f632bc0 <__stack_chk_fail>
8f61b928:	8f74221c 	.word	0x8f74221c

8f61b92c <dwc_event_check_trb_status>:
{
8f61b92c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
	ASSERT(index < DWC_MAX_NUM_OF_EP);
8f61b930:	e3520007 	cmp	r2, #7
	uint8_t event_status  = DWC_EVENT_EP_EVENT_STATUS(*event);
8f61b934:	e591a000 	ldr	r10, [r1]
{
8f61b938:	e1a09003 	mov	r9, r3
8f61b93c:	e59f31a8 	ldr	r3, [pc, #424]	; 8f61baec <dwc_event_check_trb_status+0x1c0>
8f61b940:	e24dd010 	sub	r13, r13, #16
	uint8_t event_status  = DWC_EVENT_EP_EVENT_STATUS(*event);
8f61b944:	e7e7a65a 	ubfx	r10, r10, #12, #8
{
8f61b948:	e1a07002 	mov	r7, r2
8f61b94c:	e5933000 	ldr	r3, [r3]
8f61b950:	e58d300c 	str	r3, [r13, #12]
8f61b954:	e3a03000 	mov	r3, #0
	ASSERT(index < DWC_MAX_NUM_OF_EP);
8f61b958:	e1a0600e 	mov	r6, r14
{
8f61b95c:	e1a08000 	mov	r8, r0
	ASSERT(index < DWC_MAX_NUM_OF_EP);
8f61b960:	8a000047 	bhi	8f61ba84 <dwc_event_check_trb_status+0x158>
	dwc_ep_t *ep          = &dev->ep[index];
8f61b964:	e3a03f8e 	mov	r3, #568	; 0x238
8f61b968:	e0238793 	mla	r3, r3, r7, r8
	ASSERT(ep != NULL);
8f61b96c:	e3730008 	cmn	r3, #8
8f61b970:	0a000051 	beq	8f61babc <dwc_event_check_trb_status+0x190>
	dwc_trb_t *trb        = ep->trb;
8f61b974:	e3a03f8e 	mov	r3, #568	; 0x238
8f61b978:	e0238793 	mla	r3, r3, r7, r8
	uint32_t num_of_trb   = ep->trb_queued;
8f61b97c:	e5935220 	ldr	r5, [r3, #544]	; 0x220
	dwc_trb_t *trb        = ep->trb;
8f61b980:	e5934218 	ldr	r4, [r3, #536]	; 0x218
	ASSERT(num_of_trb);
8f61b984:	e3550000 	cmp	r5, #0
8f61b988:	0a00002d 	beq	8f61ba44 <dwc_event_check_trb_status+0x118>
	arch_invalidate_cache_range((addr_t) trb, ROUNDUP(sizeof(dwc_trb_t)*num_of_trb, CACHE_LINE));
8f61b98c:	e1a01205 	lsl	r1, r5, #4
8f61b990:	e3a06000 	mov	r6, #0
8f61b994:	e281103f 	add	r1, r1, #63	; 0x3f
8f61b998:	e1a00004 	mov	r0, r4
8f61b99c:	e3c1103f 	bic	r1, r1, #63	; 0x3f
8f61b9a0:	eb001588 	bl	8f620fc8 <arch_invalidate_cache_range>
	while (num_of_trb)
8f61b9a4:	e20a2002 	and	r2, r10, #2
	arch_invalidate_cache_range((addr_t) trb, ROUNDUP(sizeof(dwc_trb_t)*num_of_trb, CACHE_LINE));
8f61b9a8:	e1a00006 	mov	r0, r6
8f61b9ac:	e1a0a006 	mov	r10, r6
		bytes_remaining += REG_READ_FIELD_LOCAL(&trb->f3, TRB_F3, BUFSIZ);
8f61b9b0:	e5941008 	ldr	r1, [r4, #8]
		if (!status)
8f61b9b4:	e35a0000 	cmp	r10, #0
		bytes_remaining += REG_READ_FIELD_LOCAL(&trb->f3, TRB_F3, BUFSIZ);
8f61b9b8:	e3c1c4ff 	bic	r12, r1, #-16777216	; 0xff000000
			status  = REG_READ_FIELD_LOCAL(&trb->f3, TRB_F3, TRBSTS);
8f61b9bc:	01a0ae21 	lsreq	r10, r1, #28
		if ((event_status & DWC_XFER_COMPLETE_EVT_STATUS_SHORT_PKT) &&
8f61b9c0:	e3520000 	cmp	r2, #0
		bytes_remaining += REG_READ_FIELD_LOCAL(&trb->f3, TRB_F3, BUFSIZ);
8f61b9c4:	e086600c 	add	r6, r6, r12
		if ((event_status & DWC_XFER_COMPLETE_EVT_STATUS_SHORT_PKT) &&
8f61b9c8:	0a000004 	beq	8f61b9e0 <dwc_event_check_trb_status+0xb4>
			(REG_READ_FIELD_LOCAL(&trb->f4, TRB_F4, HWO)))
8f61b9cc:	e594300c 	ldr	r3, [r4, #12]
		if ((event_status & DWC_XFER_COMPLETE_EVT_STATUS_SHORT_PKT) &&
8f61b9d0:	e3130001 	tst	r3, #1
			REG_WRITE_FIELD_LOCAL(&trb->f4, TRB_F4, HWO, 0x0);
8f61b9d4:	13c33001 	bicne	r3, r3, #1
8f61b9d8:	1584300c 	strne	r3, [r4, #12]
			trb_updated = 1;
8f61b9dc:	13a00001 	movne	r0, #1
	while (num_of_trb)
8f61b9e0:	e2555001 	subs	r5, r5, #1
		trb++;
8f61b9e4:	e2844010 	add	r4, r4, #16
	while (num_of_trb)
8f61b9e8:	1afffff0 	bne	8f61b9b0 <dwc_event_check_trb_status+0x84>
	if (trb_updated)
8f61b9ec:	e3500000 	cmp	r0, #0
8f61b9f0:	0a000005 	beq	8f61ba0c <dwc_event_check_trb_status+0xe0>
										  sizeof(dwc_trb_t)*ep->trb_queued);
8f61b9f4:	e3a03f8e 	mov	r3, #568	; 0x238
8f61b9f8:	e0238793 	mla	r3, r3, r7, r8
		arch_clean_invalidate_cache_range((addr_t) ep->trb,
8f61b9fc:	e5931220 	ldr	r1, [r3, #544]	; 0x220
8f61ba00:	e5930218 	ldr	r0, [r3, #536]	; 0x218
8f61ba04:	e1a01201 	lsl	r1, r1, #4
8f61ba08:	eb001564 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	ep->trb_queued = 0;
8f61ba0c:	e3a02f8e 	mov	r2, #568	; 0x238
8f61ba10:	e3a03000 	mov	r3, #0
8f61ba14:	e0278792 	mla	r7, r2, r7, r8
8f61ba18:	e5873220 	str	r3, [r7, #544]	; 0x220
}
8f61ba1c:	e59f30c8 	ldr	r3, [pc, #200]	; 8f61baec <dwc_event_check_trb_status+0x1c0>
	*bytes_in_buf = bytes_remaining;
8f61ba20:	e5896000 	str	r6, [r9]
}
8f61ba24:	e5932000 	ldr	r2, [r3]
8f61ba28:	e59d300c 	ldr	r3, [r13, #12]
8f61ba2c:	e0332002 	eors	r2, r3, r2
8f61ba30:	e3a03000 	mov	r3, #0
8f61ba34:	1a00002b 	bne	8f61bae8 <dwc_event_check_trb_status+0x1bc>
8f61ba38:	e1a0000a 	mov	r0, r10
8f61ba3c:	e28dd010 	add	r13, r13, #16
8f61ba40:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
	ASSERT(num_of_trb);
8f61ba44:	e1a00006 	mov	r0, r6
8f61ba48:	e300324b 	movw	r3, #587	; 0x24b
8f61ba4c:	e3062f18 	movw	r2, #28440	; 0x6f18
8f61ba50:	e3001130 	movw	r1, #304	; 0x130
8f61ba54:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61ba58:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61ba5c:	e58d2000 	str	r2, [r13]
8f61ba60:	e306253c 	movw	r2, #25916	; 0x653c
8f61ba64:	e3482f70 	movt	r2, #36720	; 0x8f70
	uint32_t bytes_remaining = 0;
8f61ba68:	e1a06005 	mov	r6, r5
	ASSERT(num_of_trb);
8f61ba6c:	eb005c12 	bl	8f632abc <_panic>
	arch_invalidate_cache_range((addr_t) trb, ROUNDUP(sizeof(dwc_trb_t)*num_of_trb, CACHE_LINE));
8f61ba70:	e1a01005 	mov	r1, r5
8f61ba74:	e1a00004 	mov	r0, r4
	uint8_t status        = 0;
8f61ba78:	e1a0a005 	mov	r10, r5
	arch_invalidate_cache_range((addr_t) trb, ROUNDUP(sizeof(dwc_trb_t)*num_of_trb, CACHE_LINE));
8f61ba7c:	eb001551 	bl	8f620fc8 <arch_invalidate_cache_range>
	if (trb_updated)
8f61ba80:	eaffffe1 	b	8f61ba0c <dwc_event_check_trb_status+0xe0>
	ASSERT(index < DWC_MAX_NUM_OF_EP);
8f61ba84:	e3063efc 	movw	r3, #28412	; 0x6efc
8f61ba88:	e306253c 	movw	r2, #25916	; 0x653c
8f61ba8c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61ba90:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61ba94:	e58d3000 	str	r3, [r13]
8f61ba98:	e3001130 	movw	r1, #304	; 0x130
8f61ba9c:	e3003242 	movw	r3, #578	; 0x242
8f61baa0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61baa4:	e1a0000e 	mov	r0, r14
8f61baa8:	eb005c03 	bl	8f632abc <_panic>
	dwc_ep_t *ep          = &dev->ep[index];
8f61baac:	e3a03f8e 	mov	r3, #568	; 0x238
8f61bab0:	e0238793 	mla	r3, r3, r7, r8
	ASSERT(ep != NULL);
8f61bab4:	e3730008 	cmn	r3, #8
8f61bab8:	1affffad 	bne	8f61b974 <dwc_event_check_trb_status+0x48>
8f61babc:	e3063590 	movw	r3, #26000	; 0x6590
8f61bac0:	e306253c 	movw	r2, #25916	; 0x653c
8f61bac4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61bac8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61bacc:	e58d3000 	str	r3, [r13]
8f61bad0:	e3001130 	movw	r1, #304	; 0x130
8f61bad4:	e3a03f91 	mov	r3, #580	; 0x244
8f61bad8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61badc:	e1a00006 	mov	r0, r6
8f61bae0:	eb005bf5 	bl	8f632abc <_panic>
8f61bae4:	eaffffa2 	b	8f61b974 <dwc_event_check_trb_status+0x48>
}
8f61bae8:	eb005c34 	bl	8f632bc0 <__stack_chk_fail>
8f61baec:	8f74221c 	.word	0x8f74221c

8f61baf0 <dwc_irq_handler_ee1>:
{
8f61baf0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f61baf4:	e24dd044 	sub	r13, r13, #68	; 0x44
		ERR("\n Ignore the unexpected EP event: %s\n", event_lookup_ep[event_id]);
8f61baf8:	e3022b74 	movw	r2, #11124	; 0x2b74
8f61bafc:	e3482f74 	movt	r2, #36724	; 0x8f74
8f61bb00:	e58d200c 	str	r2, [r13, #12]
8f61bb04:	e1a0800e 	mov	r8, r14
{
8f61bb08:	e59f2fd4 	ldr	r2, [pc, #4052]	; 8f61cae4 <dwc_irq_handler_ee1+0xff4>
8f61bb0c:	e1a05000 	mov	r5, r0
	uint32_t   event[3] = {0x0, 0x0, 0x0};
8f61bb10:	e3a03000 	mov	r3, #0
		ERR("\n Ignore the unexpected EP event: %s\n", event_lookup_ep[event_id]);
8f61bb14:	e306bfb8 	movw	r11, #28600	; 0x6fb8
{
8f61bb18:	e5922000 	ldr	r2, [r2]
8f61bb1c:	e58d203c 	str	r2, [r13, #60]	; 0x3c
8f61bb20:	e3a02000 	mov	r2, #0
		ERR("\n Ignore the unexpected EP event: %s\n", event_lookup_ep[event_id]);
8f61bb24:	e348bf70 	movt	r11, #36720	; 0x8f70
	uint32_t   event[3] = {0x0, 0x0, 0x0};
8f61bb28:	e58d3030 	str	r3, [r13, #48]	; 0x30
8f61bb2c:	e58d3034 	str	r3, [r13, #52]	; 0x34
8f61bb30:	e58d3038 	str	r3, [r13, #56]	; 0x38
	ASSERT(ep != NULL);
8f61bb34:	e3063590 	movw	r3, #26000	; 0x6590
8f61bb38:	e58db010 	str	r11, [r13, #16]
8f61bb3c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61bb40:	e58d3014 	str	r3, [r13, #20]
	while((event_size = dwc_event_get_next(dev, event)))
8f61bb44:	e28d1030 	add	r1, r13, #48	; 0x30
8f61bb48:	e1a00005 	mov	r0, r5
8f61bb4c:	eb0007d7 	bl	8f61dab0 <dwc_event_get_next>
8f61bb50:	e2504000 	subs	r4, r0, #0
8f61bb54:	0a0000aa 	beq	8f61be04 <dwc_irq_handler_ee1+0x314>
		if(DWC_EVENT_IS_DEVICE_EVENT(*event))
8f61bb58:	e59d6030 	ldr	r6, [r13, #48]	; 0x30
8f61bb5c:	e3160001 	tst	r6, #1
8f61bb60:	1a000035 	bne	8f61bc3c <dwc_irq_handler_ee1+0x14c>
			uint8_t ep_phy_num = DWC_EVENT_EP_EVENT_EP_NUM(*event);
8f61bb64:	e7e770d6 	ubfx	r7, r6, #1, #8
			if ((ep_phy_num == 0) ||
8f61bb68:	e317001e 	tst	r7, #30
8f61bb6c:	1a00000c 	bne	8f61bba4 <dwc_irq_handler_ee1+0xb4>
	switch (dev->ctrl_state)
8f61bb70:	e2859a01 	add	r9, r5, #4096	; 0x1000
8f61bb74:	e5d911d4 	ldrb	r1, [r9, #468]	; 0x1d4
8f61bb78:	e2413001 	sub	r3, r1, #1
8f61bb7c:	e3530006 	cmp	r3, #6
8f61bb80:	979ff103 	ldrls	r15, [r15, r3, lsl #2]
8f61bb84:	ea000404 	b	8f61cb9c <dwc_irq_handler_ee1+0x10ac>
8f61bb88:	8f61c10c 	.word	0x8f61c10c
8f61bb8c:	8f61c0c0 	.word	0x8f61c0c0
8f61bb90:	8f61c0a8 	.word	0x8f61c0a8
8f61bb94:	8f61c074 	.word	0x8f61c074
8f61bb98:	8f61bff8 	.word	0x8f61bff8
8f61bb9c:	8f61bf7c 	.word	0x8f61bf7c
8f61bba0:	8f61bf18 	.word	0x8f61bf18
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61bba4:	e3170018 	tst	r7, #24
	uint8_t                 ep_phy_num   = DWC_EVENT_EP_EVENT_EP_NUM(*event);
8f61bba8:	e207701f 	and	r7, r7, #31
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61bbac:	1a00017d 	bne	8f61c1a8 <dwc_irq_handler_ee1+0x6b8>
	dwc_ep_t *ep = &dev->ep[DWC_EP_PHY_TO_INDEX(ep_phy_num)];
8f61bbb0:	e3a03f8e 	mov	r3, #568	; 0x238
8f61bbb4:	e0235793 	mla	r3, r3, r7, r5
	ASSERT(ep != NULL);
8f61bbb8:	e3730008 	cmn	r3, #8
8f61bbbc:	0a00016f 	beq	8f61c180 <dwc_irq_handler_ee1+0x690>
	switch (ep->state)
8f61bbc0:	e3a0bf8e 	mov	r11, #568	; 0x238
8f61bbc4:	e027bb97 	mla	r7, r7, r11, r11
8f61bbc8:	e0857007 	add	r7, r5, r7
8f61bbcc:	e5d73004 	ldrb	r3, [r7, #4]
8f61bbd0:	e3530002 	cmp	r3, #2
8f61bbd4:	0a0000b4 	beq	8f61beac <dwc_irq_handler_ee1+0x3bc>
8f61bbd8:	e3530003 	cmp	r3, #3
8f61bbdc:	0a00009f 	beq	8f61be60 <dwc_irq_handler_ee1+0x370>
8f61bbe0:	e3530001 	cmp	r3, #1
8f61bbe4:	0a00008e 	beq	8f61be24 <dwc_irq_handler_ee1+0x334>
		ERR("\n EP state is invalid. Asserting...\n");
8f61bbe8:	e3070084 	movw	r0, #28804	; 0x7084
8f61bbec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61bbf0:	eb005b5f 	bl	8f632974 <_dprintf>
		dwc_print_ep_event_details(dev, event);
8f61bbf4:	e28d0030 	add	r0, r13, #48	; 0x30
8f61bbf8:	ebfffdda 	bl	8f61b368 <dwc_print_ep_event_details.constprop.0>
		dwc_print_current_state(dev);
8f61bbfc:	e1a00005 	mov	r0, r5
8f61bc00:	ebfffc04 	bl	8f61ac18 <dwc_print_current_state>
		ASSERT(0);
8f61bc04:	e3073f64 	movw	r3, #32612	; 0x7f64
8f61bc08:	e306253c 	movw	r2, #25916	; 0x653c
8f61bc0c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61bc10:	e3001130 	movw	r1, #304	; 0x130
8f61bc14:	e58d3000 	str	r3, [r13]
8f61bc18:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61bc1c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61bc20:	e3003594 	movw	r3, #1428	; 0x594
8f61bc24:	e1a00008 	mov	r0, r8
8f61bc28:	eb005ba3 	bl	8f632abc <_panic>
		dwc_event_processed(dev, event_size);
8f61bc2c:	e1a01004 	mov	r1, r4
8f61bc30:	e1a00005 	mov	r0, r5
8f61bc34:	eb000801 	bl	8f61dc40 <dwc_event_processed>
8f61bc38:	eaffffc1 	b	8f61bb44 <dwc_irq_handler_ee1+0x54>
	dwc_event_device_event_id_t event_id = DWC_EVENT_DEVICE_EVENT_ID(*event);
8f61bc3c:	e7e36456 	ubfx	r6, r6, #8, #4
	switch (event_id)
8f61bc40:	e356000c 	cmp	r6, #12
8f61bc44:	979ff106 	ldrls	r15, [r15, r6, lsl #2]
8f61bc48:	ea000055 	b	8f61bda4 <dwc_irq_handler_ee1+0x2b4>
8f61bc4c:	8f61bd84 	.word	0x8f61bd84
8f61bc50:	8f61bcf8 	.word	0x8f61bcf8
8f61bc54:	8f61bc80 	.word	0x8f61bc80
8f61bc58:	8f61bc2c 	.word	0x8f61bc2c
8f61bc5c:	8f61bc2c 	.word	0x8f61bc2c
8f61bc60:	8f61bc2c 	.word	0x8f61bc2c
8f61bc64:	8f61bc2c 	.word	0x8f61bc2c
8f61bc68:	8f61bc2c 	.word	0x8f61bc2c
8f61bc6c:	8f61bda4 	.word	0x8f61bda4
8f61bc70:	8f61bc2c 	.word	0x8f61bc2c
8f61bc74:	8f61bc2c 	.word	0x8f61bc2c
8f61bc78:	8f61bc2c 	.word	0x8f61bc2c
8f61bc7c:	8f61bc2c 	.word	0x8f61bc2c
	speed = dwc_connectspeed(dev);
8f61bc80:	e1a00005 	mov	r0, r5
8f61bc84:	eb00088a 	bl	8f61deb4 <dwc_connectspeed>
	switch (speed)
8f61bc88:	e3500004 	cmp	r0, #4
8f61bc8c:	8a00018c 	bhi	8f61c2c4 <dwc_irq_handler_ee1+0x7d4>
8f61bc90:	e1a02080 	lsl	r2, r0, #1
8f61bc94:	e30730c8 	movw	r3, #28872	; 0x70c8
8f61bc98:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61bc9c:	e19330b2 	ldrh	r3, [r3, r2]
8f61bca0:	e30720d4 	movw	r2, #28884	; 0x70d4
8f61bca4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61bca8:	e7d26000 	ldrb	r6, [r2, r0]
	dev->ep[1].max_pkt_size = max_pkt_size;
8f61bcac:	e2852f91 	add	r2, r5, #580	; 0x244
	dev->ep[0].max_pkt_size = max_pkt_size;
8f61bcb0:	e1c530bc 	strh	r3, [r5, #12]
	dwc_ep_cmd_set_config(dev, 0, SET_CONFIG_ACTION_MODIFY);
8f61bcb4:	e3a01000 	mov	r1, #0
8f61bcb8:	e1a00005 	mov	r0, r5
	dev->ep[1].max_pkt_size = max_pkt_size;
8f61bcbc:	e1c230b0 	strh	r3, [r2]
	dwc_ep_cmd_set_config(dev, 0, SET_CONFIG_ACTION_MODIFY);
8f61bcc0:	e3a02002 	mov	r2, #2
8f61bcc4:	eb0005ce 	bl	8f61d404 <dwc_ep_cmd_set_config>
	dwc_ep_cmd_set_config(dev, 1, SET_CONFIG_ACTION_MODIFY);
8f61bcc8:	e3a02002 	mov	r2, #2
8f61bccc:	e3a01001 	mov	r1, #1
8f61bcd0:	e1a00005 	mov	r0, r5
8f61bcd4:	eb0005ca 	bl	8f61d404 <dwc_ep_cmd_set_config>
	if (dev->notify)
8f61bcd8:	e2852a01 	add	r2, r5, #4096	; 0x1000
8f61bcdc:	e59231e0 	ldr	r3, [r2, #480]	; 0x1e0
8f61bce0:	e3530000 	cmp	r3, #0
8f61bce4:	0affffd0 	beq	8f61bc2c <dwc_irq_handler_ee1+0x13c>
		dev->notify(dev->notify_context, dwc_event);
8f61bce8:	e59201dc 	ldr	r0, [r2, #476]	; 0x1dc
8f61bcec:	e1a01006 	mov	r1, r6
8f61bcf0:	e12fff33 	blx	r3
8f61bcf4:	eaffffcc 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
	dwc_device_set_addr(dev, 0x0);
8f61bcf8:	e2856e47 	add	r6, r5, #1136	; 0x470
8f61bcfc:	e2857d47 	add	r7, r5, #4544	; 0x11c0
8f61bd00:	e3a01000 	mov	r1, #0
8f61bd04:	e1a00005 	mov	r0, r5
		ASSERT(ep != NULL);
8f61bd08:	e306a53c 	movw	r10, #25916	; 0x653c
8f61bd0c:	e3009130 	movw	r9, #304	; 0x130
	dwc_device_set_addr(dev, 0x0);
8f61bd10:	eb00066f 	bl	8f61d6d4 <dwc_device_set_addr>
	for (uint8_t ep_index = 2; ep_index < DWC_MAX_NUM_OF_EP; ep_index++)
8f61bd14:	e2866008 	add	r6, r6, #8
8f61bd18:	e2877008 	add	r7, r7, #8
		ASSERT(ep != NULL);
8f61bd1c:	e348af70 	movt	r10, #36720	; 0x8f70
8f61bd20:	e3489f70 	movt	r9, #36720	; 0x8f70
8f61bd24:	ea000002 	b	8f61bd34 <dwc_irq_handler_ee1+0x244>
	for (uint8_t ep_index = 2; ep_index < DWC_MAX_NUM_OF_EP; ep_index++)
8f61bd28:	e2866f8e 	add	r6, r6, #568	; 0x238
8f61bd2c:	e1570006 	cmp	r7, r6
8f61bd30:	0a00000b 	beq	8f61bd64 <dwc_irq_handler_ee1+0x274>
		ASSERT(ep != NULL);
8f61bd34:	e3560000 	cmp	r6, #0
8f61bd38:	0a000108 	beq	8f61c160 <dwc_irq_handler_ee1+0x670>
		if ((ep->state == EP_STATE_START_TRANSFER) ||
8f61bd3c:	e5d63234 	ldrb	r3, [r6, #564]	; 0x234
8f61bd40:	e2433002 	sub	r3, r3, #2
8f61bd44:	e3530001 	cmp	r3, #1
8f61bd48:	8afffff6 	bhi	8f61bd28 <dwc_irq_handler_ee1+0x238>
			dwc_ep_cmd_end_transfer(dev, ep->phy_num);
8f61bd4c:	e5d6100c 	ldrb	r1, [r6, #12]
8f61bd50:	e1a00005 	mov	r0, r5
	for (uint8_t ep_index = 2; ep_index < DWC_MAX_NUM_OF_EP; ep_index++)
8f61bd54:	e2866f8e 	add	r6, r6, #568	; 0x238
			dwc_ep_cmd_end_transfer(dev, ep->phy_num);
8f61bd58:	eb000574 	bl	8f61d330 <dwc_ep_cmd_end_transfer>
	for (uint8_t ep_index = 2; ep_index < DWC_MAX_NUM_OF_EP; ep_index++)
8f61bd5c:	e1570006 	cmp	r7, r6
8f61bd60:	1afffff3 	bne	8f61bd34 <dwc_irq_handler_ee1+0x244>
	if (dev->notify)
8f61bd64:	e2852a01 	add	r2, r5, #4096	; 0x1000
8f61bd68:	e59231e0 	ldr	r3, [r2, #480]	; 0x1e0
8f61bd6c:	e3530000 	cmp	r3, #0
8f61bd70:	0affffad 	beq	8f61bc2c <dwc_irq_handler_ee1+0x13c>
		dev->notify(dev->notify_context, DWC_NOTIFY_EVENT_OFFLINE);
8f61bd74:	e59201dc 	ldr	r0, [r2, #476]	; 0x1dc
8f61bd78:	e3a01000 	mov	r1, #0
8f61bd7c:	e12fff33 	blx	r3
8f61bd80:	eaffffa9 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
	if (dev->notify)
8f61bd84:	e2852a01 	add	r2, r5, #4096	; 0x1000
8f61bd88:	e59231e0 	ldr	r3, [r2, #480]	; 0x1e0
8f61bd8c:	e3530000 	cmp	r3, #0
8f61bd90:	0affffa5 	beq	8f61bc2c <dwc_irq_handler_ee1+0x13c>
		dev->notify(dev->notify_context, DWC_NOTIFY_EVENT_DISCONNECTED);
8f61bd94:	e59201dc 	ldr	r0, [r2, #476]	; 0x1dc
8f61bd98:	e3a01005 	mov	r1, #5
8f61bd9c:	e12fff33 	blx	r3
8f61bda0:	eaffffa1 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
		ERR("\nUnhandled DEVICE_EVENT: %s in %s \n",
8f61bda4:	e2853a01 	add	r3, r5, #4096	; 0x1000
8f61bda8:	e3060f24 	movw	r0, #28452	; 0x6f24
8f61bdac:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61bdb0:	e5d321d4 	ldrb	r2, [r3, #468]	; 0x1d4
8f61bdb4:	e3023c64 	movw	r3, #11364	; 0x2c64
8f61bdb8:	e3483f74 	movt	r3, #36724	; 0x8f74
8f61bdbc:	e7932102 	ldr	r2, [r3, r2, lsl #2]
8f61bdc0:	e3023a34 	movw	r3, #10804	; 0x2a34
8f61bdc4:	e3483f74 	movt	r3, #36724	; 0x8f74
8f61bdc8:	e7931106 	ldr	r1, [r3, r6, lsl #2]
8f61bdcc:	eb005ae8 	bl	8f632974 <_dprintf>
		dwc_print_current_state(dev);
8f61bdd0:	e1a00005 	mov	r0, r5
8f61bdd4:	ebfffb8f 	bl	8f61ac18 <dwc_print_current_state>
		ASSERT(0);
8f61bdd8:	e3073f64 	movw	r3, #32612	; 0x7f64
8f61bddc:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61bde0:	e58d3000 	str	r3, [r13]
8f61bde4:	e3003151 	movw	r3, #337	; 0x151
		ASSERT(0);
8f61bde8:	e306253c 	movw	r2, #25916	; 0x653c
8f61bdec:	e3001130 	movw	r1, #304	; 0x130
8f61bdf0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61bdf4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61bdf8:	e1a00008 	mov	r0, r8
8f61bdfc:	eb005b2e 	bl	8f632abc <_panic>
8f61be00:	eaffff89 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
}
8f61be04:	e59f3cd8 	ldr	r3, [pc, #3288]	; 8f61cae4 <dwc_irq_handler_ee1+0xff4>
8f61be08:	e5932000 	ldr	r2, [r3]
8f61be0c:	e59d303c 	ldr	r3, [r13, #60]	; 0x3c
8f61be10:	e0332002 	eors	r2, r3, r2
8f61be14:	e3a03000 	mov	r3, #0
8f61be18:	1a00035e 	bne	8f61cb98 <dwc_irq_handler_ee1+0x10a8>
8f61be1c:	e28dd044 	add	r13, r13, #68	; 0x44
8f61be20:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	dwc_event_ep_event_id_t event_id   = DWC_EVENT_EP_EVENT_ID(*event);
8f61be24:	e59d3030 	ldr	r3, [r13, #48]	; 0x30
8f61be28:	e7e72353 	ubfx	r2, r3, #6, #8
8f61be2c:	e7e33353 	ubfx	r3, r3, #6, #4
	switch (event_id)
8f61be30:	e202200b 	and	r2, r2, #11
8f61be34:	e3520003 	cmp	r2, #3
8f61be38:	0affff7b 	beq	8f61bc2c <dwc_irq_handler_ee1+0x13c>
		ERR("\n Ignore the unexpected EP event: %s\n", event_lookup_ep[event_id]);
8f61be3c:	e59d200c 	ldr	r2, [r13, #12]
8f61be40:	e7921103 	ldr	r1, [r2, r3, lsl #2]
8f61be44:	e59d0010 	ldr	r0, [r13, #16]
8f61be48:	eb005ac9 	bl	8f632974 <_dprintf>
		dwc_print_ep_event_details(dev, event);
8f61be4c:	e28d0030 	add	r0, r13, #48	; 0x30
8f61be50:	ebfffd44 	bl	8f61b368 <dwc_print_ep_event_details.constprop.0>
		dwc_print_current_state(dev);
8f61be54:	e1a00005 	mov	r0, r5
8f61be58:	ebfffb6e 	bl	8f61ac18 <dwc_print_current_state>
8f61be5c:	eaffff72 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
	uint8_t ep_phy_num                 = DWC_EVENT_EP_EVENT_EP_NUM(*event);
8f61be60:	e59d6030 	ldr	r6, [r13, #48]	; 0x30
8f61be64:	e7e730d6 	ubfx	r3, r6, #1, #8
8f61be68:	e7e470d6 	ubfx	r7, r6, #1, #5
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61be6c:	e3130018 	tst	r3, #24
	dwc_event_ep_event_id_t event_id   = DWC_EVENT_EP_EVENT_ID(*event);
8f61be70:	e7e36356 	ubfx	r6, r6, #6, #4
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61be74:	1a0001bf 	bne	8f61c578 <dwc_irq_handler_ee1+0xa88>
	dwc_ep_t *ep = &dev->ep[DWC_EP_PHY_TO_INDEX(ep_phy_num)];
8f61be78:	e3a03f8e 	mov	r3, #568	; 0x238
8f61be7c:	e0235793 	mla	r3, r3, r7, r5
	ASSERT(ep != NULL);
8f61be80:	e3730008 	cmn	r3, #8
8f61be84:	0a0001c6 	beq	8f61c5a4 <dwc_irq_handler_ee1+0xab4>
	switch (event_id)
8f61be88:	e3560003 	cmp	r6, #3
8f61be8c:	0affff66 	beq	8f61bc2c <dwc_irq_handler_ee1+0x13c>
8f61be90:	e3560007 	cmp	r6, #7
8f61be94:	0a0000e4 	beq	8f61c22c <dwc_irq_handler_ee1+0x73c>
8f61be98:	e3560001 	cmp	r6, #1
8f61be9c:	0a0000f1 	beq	8f61c268 <dwc_irq_handler_ee1+0x778>
		ERR("\n Ignore the unexpected EP event: %s\n", event_lookup_ep[event_id]);
8f61bea0:	e59d300c 	ldr	r3, [r13, #12]
8f61bea4:	e7931106 	ldr	r1, [r3, r6, lsl #2]
8f61bea8:	eaffffe5 	b	8f61be44 <dwc_irq_handler_ee1+0x354>
	uint8_t ep_phy_num                 = DWC_EVENT_EP_EVENT_EP_NUM(*event);
8f61beac:	e59d6030 	ldr	r6, [r13, #48]	; 0x30
8f61beb0:	e7e730d6 	ubfx	r3, r6, #1, #8
8f61beb4:	e7e490d6 	ubfx	r9, r6, #1, #5
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61beb8:	e3130018 	tst	r3, #24
	dwc_event_ep_event_id_t event_id   = DWC_EVENT_EP_EVENT_ID(*event);
8f61bebc:	e7e37356 	ubfx	r7, r6, #6, #4
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61bec0:	1a000197 	bne	8f61c524 <dwc_irq_handler_ee1+0xa34>
	dwc_ep_t *ep = &dev->ep[DWC_EP_PHY_TO_INDEX(ep_phy_num)];
8f61bec4:	e3a03f8e 	mov	r3, #568	; 0x238
8f61bec8:	e0235993 	mla	r3, r3, r9, r5
	ASSERT(ep != NULL);
8f61becc:	e3730008 	cmn	r3, #8
8f61bed0:	0a00019e 	beq	8f61c550 <dwc_irq_handler_ee1+0xa60>
	switch (event_id)
8f61bed4:	e3570007 	cmp	r7, #7
8f61bed8:	1a00009d 	bne	8f61c154 <dwc_irq_handler_ee1+0x664>
			dwc_dep_cmd_id_t cmd = DWC_EVENT_EP_EVENT_CMD_TYPE(*event);
8f61bedc:	e59d3030 	ldr	r3, [r13, #48]	; 0x30
			if (cmd == DEPCMD_CMD_START_TRANSFER)
8f61bee0:	e7e32c53 	ubfx	r2, r3, #24, #4
8f61bee4:	e3520006 	cmp	r2, #6
8f61bee8:	1affff4f 	bne	8f61bc2c <dwc_irq_handler_ee1+0x13c>
				if (event_status == 0)
8f61beec:	e3160a0f 	tst	r6, #61440	; 0xf000
8f61bef0:	1a0001b5 	bne	8f61c5cc <dwc_irq_handler_ee1+0xadc>
					ep->state        = EP_STATE_XFER_IN_PROG;
8f61bef4:	e3a02f8e 	mov	r2, #568	; 0x238
					ep->resource_idx = DWC_EVENT_EP_EVENT_XFER_RES_IDX(*event);
8f61bef8:	e7e63853 	ubfx	r3, r3, #16, #7
					ep->state        = EP_STATE_XFER_IN_PROG;
8f61befc:	e0212299 	mla	r1, r9, r2, r2
8f61bf00:	e3a00003 	mov	r0, #3
					ep->resource_idx = DWC_EVENT_EP_EVENT_XFER_RES_IDX(*event);
8f61bf04:	e0225992 	mla	r2, r2, r9, r5
					ep->state        = EP_STATE_XFER_IN_PROG;
8f61bf08:	e0851001 	add	r1, r5, r1
8f61bf0c:	e5c10004 	strb	r0, [r1, #4]
					ep->resource_idx = DWC_EVENT_EP_EVENT_XFER_RES_IDX(*event);
8f61bf10:	e5c23216 	strb	r3, [r2, #534]	; 0x216
8f61bf14:	eaffff44 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61bf18:	e3170018 	tst	r7, #24
	dwc_event_ep_event_id_t event_id   = DWC_EVENT_EP_EVENT_ID(*event);
8f61bf1c:	e7e36356 	ubfx	r6, r6, #6, #4
	uint8_t ep_phy_num                 = DWC_EVENT_EP_EVENT_EP_NUM(*event);
8f61bf20:	e207701f 	and	r7, r7, #31
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61bf24:	1a000222 	bne	8f61c7b4 <dwc_irq_handler_ee1+0xcc4>
	dwc_ep_t *ep = &dev->ep[DWC_EP_PHY_TO_INDEX(ep_phy_num)];
8f61bf28:	e3a03f8e 	mov	r3, #568	; 0x238
8f61bf2c:	e0235793 	mla	r3, r3, r7, r5
	ASSERT(ep != NULL);
8f61bf30:	e3730008 	cmn	r3, #8
8f61bf34:	0a00023d 	beq	8f61c830 <dwc_irq_handler_ee1+0xd40>
	switch (event_id)
8f61bf38:	e3560007 	cmp	r6, #7
8f61bf3c:	1affff3a 	bne	8f61bc2c <dwc_irq_handler_ee1+0x13c>
			dwc_dep_cmd_id_t cmd = DWC_EVENT_EP_EVENT_CMD_TYPE(*event);
8f61bf40:	e5dd3033 	ldrb	r3, [r13, #51]	; 0x33
8f61bf44:	e203300f 	and	r3, r3, #15
			if (cmd == DEPCMD_CMD_SET_STALL)
8f61bf48:	e3530004 	cmp	r3, #4
8f61bf4c:	0a0000fd 	beq	8f61c348 <dwc_irq_handler_ee1+0x858>
			else if (cmd == DEPCMD_CMD_END_TRANSFER)
8f61bf50:	e3530008 	cmp	r3, #8
8f61bf54:	1affff34 	bne	8f61bc2c <dwc_irq_handler_ee1+0x13c>
				ep->state        = EP_STATE_INACTIVE;
8f61bf58:	e3a02f8e 	mov	r2, #568	; 0x238
8f61bf5c:	e3a01001 	mov	r1, #1
8f61bf60:	e0232297 	mla	r3, r7, r2, r2
				ep->resource_idx = 0;
8f61bf64:	e0275792 	mla	r7, r2, r7, r5
				ep->state        = EP_STATE_INACTIVE;
8f61bf68:	e0853003 	add	r3, r5, r3
8f61bf6c:	e5c31004 	strb	r1, [r3, #4]
				ep->resource_idx = 0;
8f61bf70:	e3a03000 	mov	r3, #0
8f61bf74:	e5c73216 	strb	r3, [r7, #534]	; 0x216
8f61bf78:	eaffff2b 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61bf7c:	e3170018 	tst	r7, #24
	dwc_event_ep_event_id_t event_id   = DWC_EVENT_EP_EVENT_ID(*event);
8f61bf80:	e7e3b356 	ubfx	r11, r6, #6, #4
	uint8_t ep_phy_num                 = DWC_EVENT_EP_EVENT_EP_NUM(*event);
8f61bf84:	e207701f 	and	r7, r7, #31
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61bf88:	1a000247 	bne	8f61c8ac <dwc_irq_handler_ee1+0xdbc>
	dwc_ep_t *ep = &dev->ep[DWC_EP_PHY_TO_INDEX(ep_phy_num)];
8f61bf8c:	e3a0af8e 	mov	r10, #568	; 0x238
8f61bf90:	e00a079a 	mul	r10, r10, r7
8f61bf94:	e28a3008 	add	r3, r10, #8
	ASSERT(ep != NULL);
8f61bf98:	e1750003 	cmn	r5, r3
8f61bf9c:	0a00024d 	beq	8f61c8d8 <dwc_irq_handler_ee1+0xde8>
	switch (event_id)
8f61bfa0:	e35b0001 	cmp	r11, #1
8f61bfa4:	0a00008a 	beq	8f61c1d4 <dwc_irq_handler_ee1+0x6e4>
8f61bfa8:	e35b0007 	cmp	r11, #7
8f61bfac:	1a000065 	bne	8f61c148 <dwc_irq_handler_ee1+0x658>
		dwc_dep_cmd_id_t cmd = DWC_EVENT_EP_EVENT_CMD_TYPE(*event);
8f61bfb0:	e5dd3033 	ldrb	r3, [r13, #51]	; 0x33
		if (cmd == DEPCMD_CMD_START_TRANSFER)
8f61bfb4:	e203300f 	and	r3, r3, #15
8f61bfb8:	e3530006 	cmp	r3, #6
8f61bfbc:	1affff1a 	bne	8f61bc2c <dwc_irq_handler_ee1+0x13c>
			ASSERT(ep->state == EP_STATE_START_TRANSFER);
8f61bfc0:	e085a00a 	add	r10, r5, r10
8f61bfc4:	e5da323c 	ldrb	r3, [r10, #572]	; 0x23c
8f61bfc8:	e3530002 	cmp	r3, #2
8f61bfcc:	1a0002ae 	bne	8f61ca8c <dwc_irq_handler_ee1+0xf9c>
			ASSERT(event_status == 0);
8f61bfd0:	e3160a0f 	tst	r6, #61440	; 0xf000
8f61bfd4:	1a0002a1 	bne	8f61ca60 <dwc_irq_handler_ee1+0xf70>
			ep->resource_idx = DWC_EVENT_EP_EVENT_XFER_RES_IDX(*event);
8f61bfd8:	e3a03f8e 	mov	r3, #568	; 0x238
			ep->state        = EP_STATE_XFER_IN_PROG;
8f61bfdc:	e3a02003 	mov	r2, #3
			ep->resource_idx = DWC_EVENT_EP_EVENT_XFER_RES_IDX(*event);
8f61bfe0:	e0275793 	mla	r7, r3, r7, r5
8f61bfe4:	e1dd33b2 	ldrh	r3, [r13, #50]	; 0x32
			ep->state        = EP_STATE_XFER_IN_PROG;
8f61bfe8:	e5ca223c 	strb	r2, [r10, #572]	; 0x23c
			ep->resource_idx = DWC_EVENT_EP_EVENT_XFER_RES_IDX(*event);
8f61bfec:	e203307f 	and	r3, r3, #127	; 0x7f
8f61bff0:	e5c73216 	strb	r3, [r7, #534]	; 0x216
8f61bff4:	eaffff0c 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61bff8:	e3170018 	tst	r7, #24
	uint8_t ep_phy_num                 = DWC_EVENT_EP_EVENT_EP_NUM(*event);
8f61bffc:	e207b01f 	and	r11, r7, #31
	dwc_event_ep_event_id_t event_id   = DWC_EVENT_EP_EVENT_ID(*event);
8f61c000:	e7e3a356 	ubfx	r10, r6, #6, #4
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c004:	1a0001bf 	bne	8f61c708 <dwc_irq_handler_ee1+0xc18>
	dwc_ep_t *ep = &dev->ep[DWC_EP_PHY_TO_INDEX(ep_phy_num)];
8f61c008:	e3a07f8e 	mov	r7, #568	; 0x238
8f61c00c:	e0070b97 	mul	r7, r7, r11
8f61c010:	e2873008 	add	r3, r7, #8
	ASSERT(ep != NULL);
8f61c014:	e1750003 	cmn	r5, r3
8f61c018:	0a0001f0 	beq	8f61c7e0 <dwc_irq_handler_ee1+0xcf0>
	switch (event_id)
8f61c01c:	e35a0001 	cmp	r10, #1
8f61c020:	0a0000cb 	beq	8f61c354 <dwc_irq_handler_ee1+0x864>
8f61c024:	e35a0007 	cmp	r10, #7
8f61c028:	1a000034 	bne	8f61c100 <dwc_irq_handler_ee1+0x610>
			dwc_dep_cmd_id_t cmd = DWC_EVENT_EP_EVENT_CMD_TYPE(*event);
8f61c02c:	e5dd3033 	ldrb	r3, [r13, #51]	; 0x33
			if (cmd == DEPCMD_CMD_START_TRANSFER)
8f61c030:	e203300f 	and	r3, r3, #15
8f61c034:	e3530006 	cmp	r3, #6
8f61c038:	1afffefb 	bne	8f61bc2c <dwc_irq_handler_ee1+0x13c>
				ASSERT(ep->state == EP_STATE_START_TRANSFER);
8f61c03c:	e0857007 	add	r7, r5, r7
8f61c040:	e5d7323c 	ldrb	r3, [r7, #572]	; 0x23c
8f61c044:	e3530002 	cmp	r3, #2
8f61c048:	1a0002a6 	bne	8f61cae8 <dwc_irq_handler_ee1+0xff8>
				ASSERT(event_status == 0);
8f61c04c:	e3160a0f 	tst	r6, #61440	; 0xf000
8f61c050:	1a000298 	bne	8f61cab8 <dwc_irq_handler_ee1+0xfc8>
				ep->resource_idx = DWC_EVENT_EP_EVENT_XFER_RES_IDX(*event);
8f61c054:	e3a03f8e 	mov	r3, #568	; 0x238
				ep->state        = EP_STATE_XFER_IN_PROG;
8f61c058:	e3a02003 	mov	r2, #3
				ep->resource_idx = DWC_EVENT_EP_EVENT_XFER_RES_IDX(*event);
8f61c05c:	e02b5b93 	mla	r11, r3, r11, r5
8f61c060:	e1dd33b2 	ldrh	r3, [r13, #50]	; 0x32
				ep->state        = EP_STATE_XFER_IN_PROG;
8f61c064:	e5c7223c 	strb	r2, [r7, #572]	; 0x23c
				ep->resource_idx = DWC_EVENT_EP_EVENT_XFER_RES_IDX(*event);
8f61c068:	e203307f 	and	r3, r3, #127	; 0x7f
8f61c06c:	e5cb3216 	strb	r3, [r11, #534]	; 0x216
8f61c070:	eafffeed 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c074:	e3170018 	tst	r7, #24
	dwc_event_ep_event_id_t event_id   = DWC_EVENT_EP_EVENT_ID(*event);
8f61c078:	e7e3a356 	ubfx	r10, r6, #6, #4
	uint8_t ep_phy_num                 = DWC_EVENT_EP_EVENT_EP_NUM(*event);
8f61c07c:	e207701f 	and	r7, r7, #31
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c080:	1a0001ab 	bne	8f61c734 <dwc_irq_handler_ee1+0xc44>
	dwc_ep_t *ep = &dev->ep[DWC_EP_PHY_TO_INDEX(ep_phy_num)];
8f61c084:	e3a03f8e 	mov	r3, #568	; 0x238
8f61c088:	e0235793 	mla	r3, r3, r7, r5
	ASSERT(ep != NULL);
8f61c08c:	e3730008 	cmn	r3, #8
8f61c090:	0a0001dc 	beq	8f61c808 <dwc_irq_handler_ee1+0xd18>
	switch (event_id)
8f61c094:	e35a0003 	cmp	r10, #3
8f61c098:	0a0000bc 	beq	8f61c390 <dwc_irq_handler_ee1+0x8a0>
8f61c09c:	e35a0007 	cmp	r10, #7
8f61c0a0:	0afffee1 	beq	8f61bc2c <dwc_irq_handler_ee1+0x13c>
8f61c0a4:	ea000015 	b	8f61c100 <dwc_irq_handler_ee1+0x610>
	dwc_event_ep_event_id_t event_id   = DWC_EVENT_EP_EVENT_ID(*event);
8f61c0a8:	e7e33356 	ubfx	r3, r6, #6, #4
	switch (event_id)
8f61c0ac:	e3530003 	cmp	r3, #3
8f61c0b0:	0a0000c0 	beq	8f61c3b8 <dwc_irq_handler_ee1+0x8c8>
8f61c0b4:	e3530007 	cmp	r3, #7
8f61c0b8:	0afffedb 	beq	8f61bc2c <dwc_irq_handler_ee1+0x13c>
8f61c0bc:	eaffff5e 	b	8f61be3c <dwc_irq_handler_ee1+0x34c>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c0c0:	e3170018 	tst	r7, #24
	dwc_event_ep_event_id_t event_id   = DWC_EVENT_EP_EVENT_ID(*event);
8f61c0c4:	e7e3a356 	ubfx	r10, r6, #6, #4
	uint8_t ep_phy_num                 = DWC_EVENT_EP_EVENT_EP_NUM(*event);
8f61c0c8:	e207701f 	and	r7, r7, #31
	uint8_t event_ctrl_stage           = DWC_EVENT_EP_EVENT_CTRL_STAGE(*event);
8f61c0cc:	e7e7b656 	ubfx	r11, r6, #12, #8
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c0d0:	1a0001ac 	bne	8f61c788 <dwc_irq_handler_ee1+0xc98>
	dwc_ep_t *ep = &dev->ep[DWC_EP_PHY_TO_INDEX(ep_phy_num)];
8f61c0d4:	e3a06f8e 	mov	r6, #568	; 0x238
8f61c0d8:	e0060796 	mul	r6, r6, r7
8f61c0dc:	e2863008 	add	r3, r6, #8
	ASSERT(ep != NULL);
8f61c0e0:	e1750003 	cmn	r5, r3
8f61c0e4:	0a00019d 	beq	8f61c760 <dwc_irq_handler_ee1+0xc70>
	switch (event_id)
8f61c0e8:	e35a0003 	cmp	r10, #3
8f61c0ec:	0a0000c7 	beq	8f61c410 <dwc_irq_handler_ee1+0x920>
8f61c0f0:	e35a0007 	cmp	r10, #7
8f61c0f4:	0a0000e3 	beq	8f61c488 <dwc_irq_handler_ee1+0x998>
8f61c0f8:	e35a0001 	cmp	r10, #1
8f61c0fc:	0a0000d3 	beq	8f61c450 <dwc_irq_handler_ee1+0x960>
		ERR("\n Ignore the unexpected EP event: %s\n", event_lookup_ep[event_id]);
8f61c100:	e59d300c 	ldr	r3, [r13, #12]
8f61c104:	e793110a 	ldr	r1, [r3, r10, lsl #2]
8f61c108:	eaffff4d 	b	8f61be44 <dwc_irq_handler_ee1+0x354>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c10c:	e3170018 	tst	r7, #24
	dwc_event_ep_event_id_t event_id   = DWC_EVENT_EP_EVENT_ID(*event);
8f61c110:	e7e3b356 	ubfx	r11, r6, #6, #4
	uint8_t ep_phy_num                 = DWC_EVENT_EP_EVENT_EP_NUM(*event);
8f61c114:	e207701f 	and	r7, r7, #31
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c118:	1a0001ce 	bne	8f61c858 <dwc_irq_handler_ee1+0xd68>
	dwc_ep_t *ep = &dev->ep[DWC_EP_PHY_TO_INDEX(ep_phy_num)];
8f61c11c:	e3a0af8e 	mov	r10, #568	; 0x238
8f61c120:	e00a079a 	mul	r10, r10, r7
8f61c124:	e28a3008 	add	r3, r10, #8
	ASSERT(ep != NULL);
8f61c128:	e1750003 	cmn	r5, r3
8f61c12c:	0a0001d4 	beq	8f61c884 <dwc_irq_handler_ee1+0xd94>
	switch (event_id)
8f61c130:	e35b0003 	cmp	r11, #3
8f61c134:	0a000036 	beq	8f61c214 <dwc_irq_handler_ee1+0x724>
8f61c138:	e35b0007 	cmp	r11, #7
8f61c13c:	0a0000e3 	beq	8f61c4d0 <dwc_irq_handler_ee1+0x9e0>
8f61c140:	e35b0001 	cmp	r11, #1
8f61c144:	0a00006b 	beq	8f61c2f8 <dwc_irq_handler_ee1+0x808>
		ERR("\n Ignore the unexpected EP event: %s\n", event_lookup_ep[event_id]);
8f61c148:	e59d300c 	ldr	r3, [r13, #12]
8f61c14c:	e793110b 	ldr	r1, [r3, r11, lsl #2]
8f61c150:	eaffff3b 	b	8f61be44 <dwc_irq_handler_ee1+0x354>
		ERR("\n Ignore the unexpected EP event: %s\n", event_lookup_ep[event_id]);
8f61c154:	e59d300c 	ldr	r3, [r13, #12]
8f61c158:	e7931107 	ldr	r1, [r3, r7, lsl #2]
8f61c15c:	eaffff38 	b	8f61be44 <dwc_irq_handler_ee1+0x354>
		ASSERT(ep != NULL);
8f61c160:	e59d3014 	ldr	r3, [r13, #20]
8f61c164:	e1a0200a 	mov	r2, r10
8f61c168:	e1a01009 	mov	r1, r9
8f61c16c:	e1a00008 	mov	r0, r8
8f61c170:	e58d3000 	str	r3, [r13]
8f61c174:	e30031cb 	movw	r3, #459	; 0x1cb
8f61c178:	eb005a4f 	bl	8f632abc <_panic>
8f61c17c:	eafffeee 	b	8f61bd3c <dwc_irq_handler_ee1+0x24c>
	ASSERT(ep != NULL);
8f61c180:	e59d3014 	ldr	r3, [r13, #20]
8f61c184:	e306253c 	movw	r2, #25916	; 0x653c
8f61c188:	e3001130 	movw	r1, #304	; 0x130
8f61c18c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c190:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c194:	e1a00008 	mov	r0, r8
8f61c198:	e58d3000 	str	r3, [r13]
8f61c19c:	e3003572 	movw	r3, #1394	; 0x572
8f61c1a0:	eb005a45 	bl	8f632abc <_panic>
8f61c1a4:	eafffe85 	b	8f61bbc0 <dwc_irq_handler_ee1+0xd0>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c1a8:	e306355c 	movw	r3, #25948	; 0x655c
8f61c1ac:	e306253c 	movw	r2, #25916	; 0x653c
8f61c1b0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c1b4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c1b8:	e58d3000 	str	r3, [r13]
8f61c1bc:	e3001130 	movw	r1, #304	; 0x130
8f61c1c0:	e3a03e57 	mov	r3, #1392	; 0x570
8f61c1c4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c1c8:	e1a00008 	mov	r0, r8
8f61c1cc:	eb005a3a 	bl	8f632abc <_panic>
8f61c1d0:	eafffe76 	b	8f61bbb0 <dwc_irq_handler_ee1+0xc0>
			ASSERT(ep->state == EP_STATE_XFER_IN_PROG);
8f61c1d4:	e085a00a 	add	r10, r5, r10
8f61c1d8:	e5da323c 	ldrb	r3, [r10, #572]	; 0x23c
8f61c1dc:	e3530003 	cmp	r3, #3
8f61c1e0:	1a0001dc 	bne	8f61c958 <dwc_irq_handler_ee1+0xe68>
			ep->state = EP_STATE_INACTIVE;
8f61c1e4:	e3a02001 	mov	r2, #1
			status = dwc_event_check_trb_status(dev,
8f61c1e8:	e28d301c 	add	r3, r13, #28
			ep->state = EP_STATE_INACTIVE;
8f61c1ec:	e5ca223c 	strb	r2, [r10, #572]	; 0x23c
			status = dwc_event_check_trb_status(dev,
8f61c1f0:	e28d1030 	add	r1, r13, #48	; 0x30
8f61c1f4:	e1a02007 	mov	r2, r7
8f61c1f8:	e1a00005 	mov	r0, r5
8f61c1fc:	ebfffdca 	bl	8f61b92c <dwc_event_check_trb_status>
			if (status || bytes_remaining)
8f61c200:	e3500000 	cmp	r0, #0
8f61c204:	1a000002 	bne	8f61c214 <dwc_irq_handler_ee1+0x724>
8f61c208:	e59d301c 	ldr	r3, [r13, #28]
8f61c20c:	e3530000 	cmp	r3, #0
8f61c210:	0a00004c 	beq	8f61c348 <dwc_irq_handler_ee1+0x858>
				dwc_ep_cmd_stall(dev, ep_phy_num);
8f61c214:	e1a01007 	mov	r1, r7
8f61c218:	e1a00005 	mov	r0, r5
8f61c21c:	eb0004a4 	bl	8f61d4b4 <dwc_ep_cmd_stall>
				dev->ctrl_state  = EP_FSM_STALL;
8f61c220:	e3a03007 	mov	r3, #7
8f61c224:	e5c931d4 	strb	r3, [r9, #468]	; 0x1d4
8f61c228:	eafffe7f 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
			dwc_dep_cmd_id_t cmd = DWC_EVENT_EP_EVENT_CMD_TYPE(*event);
8f61c22c:	e5dd3033 	ldrb	r3, [r13, #51]	; 0x33
			if (cmd == DEPCMD_CMD_END_TRANSFER)
8f61c230:	e203300f 	and	r3, r3, #15
8f61c234:	e3530008 	cmp	r3, #8
8f61c238:	1afffe7b 	bne	8f61bc2c <dwc_irq_handler_ee1+0x13c>
				if (ep->req.callback)
8f61c23c:	e3a03f8e 	mov	r3, #568	; 0x238
8f61c240:	e0223397 	mla	r2, r7, r3, r3
8f61c244:	e7956002 	ldr	r6, [r5, r2]
8f61c248:	e3560000 	cmp	r6, #0
8f61c24c:	0a000018 	beq	8f61c2b4 <dwc_irq_handler_ee1+0x7c4>
					ep->req.callback(ep->req.context, 0, -1);
8f61c250:	e0235793 	mla	r3, r3, r7, r5
8f61c254:	e3e02000 	mvn	r2, #0
8f61c258:	e3a01000 	mov	r1, #0
8f61c25c:	e5930234 	ldr	r0, [r3, #564]	; 0x234
8f61c260:	e12fff36 	blx	r6
				dwc_ep_bulk_state_inactive_enter(dev, ep_phy_num);
8f61c264:	ea000012 	b	8f61c2b4 <dwc_irq_handler_ee1+0x7c4>
			status = dwc_event_check_trb_status(dev,
8f61c268:	e28d301c 	add	r3, r13, #28
8f61c26c:	e1a02007 	mov	r2, r7
8f61c270:	e28d1030 	add	r1, r13, #48	; 0x30
8f61c274:	e1a00005 	mov	r0, r5
8f61c278:	ebfffdab 	bl	8f61b92c <dwc_event_check_trb_status>
			if (ep->req.callback)
8f61c27c:	e3a03f8e 	mov	r3, #568	; 0x238
8f61c280:	e0223397 	mla	r2, r7, r3, r3
8f61c284:	e7956002 	ldr	r6, [r5, r2]
8f61c288:	e3560000 	cmp	r6, #0
8f61c28c:	0a000008 	beq	8f61c2b4 <dwc_irq_handler_ee1+0x7c4>
								 ep->bytes_queued - bytes_remaining,
8f61c290:	e0235793 	mla	r3, r3, r7, r5
				ep->req.callback(ep->req.context,
8f61c294:	e2500000 	subs	r0, r0, #0
8f61c298:	e59d101c 	ldr	r1, [r13, #28]
8f61c29c:	13a00001 	movne	r0, #1
8f61c2a0:	e2602000 	rsb	r2, r0, #0
8f61c2a4:	e5930224 	ldr	r0, [r3, #548]	; 0x224
8f61c2a8:	e0401001 	sub	r1, r0, r1
8f61c2ac:	e5930234 	ldr	r0, [r3, #564]	; 0x234
8f61c2b0:	e12fff36 	blx	r6
			dwc_ep_bulk_state_inactive_enter(dev, ep_phy_num);
8f61c2b4:	e1a01007 	mov	r1, r7
8f61c2b8:	e1a00005 	mov	r0, r5
8f61c2bc:	ebfffa17 	bl	8f61ab20 <dwc_ep_bulk_state_inactive_enter>
		break;
8f61c2c0:	eafffe59 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
		ASSERT(0);
8f61c2c4:	e3073f64 	movw	r3, #32612	; 0x7f64
8f61c2c8:	e306253c 	movw	r2, #25916	; 0x653c
8f61c2cc:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c2d0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c2d4:	e58d3000 	str	r3, [r13]
8f61c2d8:	e3001130 	movw	r1, #304	; 0x130
8f61c2dc:	e3a03f66 	mov	r3, #408	; 0x198
8f61c2e0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c2e4:	e1a00008 	mov	r0, r8
	dwc_notify_event_t dwc_event = DWC_NOTIFY_EVENT_DISCONNECTED;
8f61c2e8:	e3a06005 	mov	r6, #5
		ASSERT(0);
8f61c2ec:	eb0059f2 	bl	8f632abc <_panic>
	uint16_t max_pkt_size = 0;
8f61c2f0:	e3a03000 	mov	r3, #0
8f61c2f4:	eafffe6c 	b	8f61bcac <dwc_irq_handler_ee1+0x1bc>
			ASSERT(ep_phy_num == 0);
8f61c2f8:	e3570000 	cmp	r7, #0
			uint32_t bytes_remaining = 0;
8f61c2fc:	e3a03000 	mov	r3, #0
8f61c300:	e58d301c 	str	r3, [r13, #28]
			ASSERT(ep_phy_num == 0);
8f61c304:	1a0001b4 	bne	8f61c9dc <dwc_irq_handler_ee1+0xeec>
			ASSERT(ep->state == EP_STATE_XFER_IN_PROG);
8f61c308:	e085a00a 	add	r10, r5, r10
8f61c30c:	e5da323c 	ldrb	r3, [r10, #572]	; 0x23c
8f61c310:	e3530003 	cmp	r3, #3
8f61c314:	1a00019a 	bne	8f61c984 <dwc_irq_handler_ee1+0xe94>
			ep->state = EP_STATE_INACTIVE;
8f61c318:	e3a02001 	mov	r2, #1
			status = dwc_event_check_trb_status(dev,
8f61c31c:	e28d301c 	add	r3, r13, #28
			ep->state = EP_STATE_INACTIVE;
8f61c320:	e5ca223c 	strb	r2, [r10, #572]	; 0x23c
			status = dwc_event_check_trb_status(dev,
8f61c324:	e28d1030 	add	r1, r13, #48	; 0x30
8f61c328:	e1a02007 	mov	r2, r7
8f61c32c:	e1a00005 	mov	r0, r5
8f61c330:	ebfffd7d 	bl	8f61b92c <dwc_event_check_trb_status>
			if (status || bytes_remaining)
8f61c334:	e3500000 	cmp	r0, #0
8f61c338:	1a000002 	bne	8f61c348 <dwc_irq_handler_ee1+0x858>
8f61c33c:	e59d301c 	ldr	r3, [r13, #28]
8f61c340:	e3530000 	cmp	r3, #0
8f61c344:	0a0000cb 	beq	8f61c678 <dwc_irq_handler_ee1+0xb88>
				dwc_ep_ctrl_state_setup_enter(dev);
8f61c348:	e1a00005 	mov	r0, r5
8f61c34c:	ebfffbdf 	bl	8f61b2d0 <dwc_ep_ctrl_state_setup_enter>
8f61c350:	eafffe35 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
			ASSERT(ep_phy_num == 1);
8f61c354:	e35b0001 	cmp	r11, #1
8f61c358:	1a000173 	bne	8f61c92c <dwc_irq_handler_ee1+0xe3c>
			ASSERT(ep->state == EP_STATE_XFER_IN_PROG);
8f61c35c:	e0857007 	add	r7, r5, r7
8f61c360:	e5d7323c 	ldrb	r3, [r7, #572]	; 0x23c
8f61c364:	e3530003 	cmp	r3, #3
8f61c368:	1a000164 	bne	8f61c900 <dwc_irq_handler_ee1+0xe10>
			if (dev->is_test_mode)
8f61c36c:	e59931ec 	ldr	r3, [r9, #492]	; 0x1ec
8f61c370:	e3530000 	cmp	r3, #0
8f61c374:	0a0000a2 	beq	8f61c604 <dwc_irq_handler_ee1+0xb14>
				dwc_device_enter_test_mode(dev);
8f61c378:	e1a00005 	mov	r0, r5
8f61c37c:	eb00052c 	bl	8f61d834 <dwc_device_enter_test_mode>
				dprintf(INFO, "Device entered test mode, please reset the device once testing is finished\n");
8f61c380:	e307001c 	movw	r0, #28700	; 0x701c
8f61c384:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61c388:	eb005979 	bl	8f632974 <_dprintf>
				break;
8f61c38c:	eafffe26 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
	uint8_t event_ctrl_stage           = DWC_EVENT_EP_EVENT_CTRL_STAGE(*event);
8f61c390:	e7e16656 	ubfx	r6, r6, #12, #2
			if (event_ctrl_stage == CONTROL_DATA_REQUEST)/* data request */
8f61c394:	e3560001 	cmp	r6, #1
8f61c398:	0a0000c7 	beq	8f61c6bc <dwc_irq_handler_ee1+0xbcc>
			else if (event_ctrl_stage ==  CONTROL_STATUS_REQUEST)/* stat req */
8f61c39c:	e3560002 	cmp	r6, #2
8f61c3a0:	0a0000a6 	beq	8f61c640 <dwc_irq_handler_ee1+0xb50>
				ASSERT(0);
8f61c3a4:	e3073f64 	movw	r3, #32612	; 0x7f64
8f61c3a8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c3ac:	e58d3000 	str	r3, [r13]
8f61c3b0:	e30033e6 	movw	r3, #998	; 0x3e6
8f61c3b4:	eafffe8b 	b	8f61bde8 <dwc_irq_handler_ee1+0x2f8>
	uint8_t event_ctrl_stage           = DWC_EVENT_EP_EVENT_CTRL_STAGE(*event);
8f61c3b8:	e7e16656 	ubfx	r6, r6, #12, #2
	uint8_t ep_phy_num                 = DWC_EVENT_EP_EVENT_EP_NUM(*event);
8f61c3bc:	e207701f 	and	r7, r7, #31
			if (event_ctrl_stage == CONTROL_DATA_REQUEST)
8f61c3c0:	e3560001 	cmp	r6, #1
8f61c3c4:	0affff92 	beq	8f61c214 <dwc_irq_handler_ee1+0x724>
			else if (event_ctrl_stage == CONTROL_STATUS_REQUEST)
8f61c3c8:	e3560002 	cmp	r6, #2
8f61c3cc:	1a000096 	bne	8f61c62c <dwc_irq_handler_ee1+0xb3c>
				ASSERT(ep_phy_num == 1);
8f61c3d0:	e3570001 	cmp	r7, #1
8f61c3d4:	1a000196 	bne	8f61ca34 <dwc_irq_handler_ee1+0xf44>
				dwc_request_queue(dev, ep_phy_num, &req);
8f61c3d8:	e28d201c 	add	r2, r13, #28
8f61c3dc:	e1a01007 	mov	r1, r7
8f61c3e0:	e1a00005 	mov	r0, r5
				req.callback = 0x0;
8f61c3e4:	e3a03000 	mov	r3, #0
8f61c3e8:	e58d302c 	str	r3, [r13, #44]	; 0x2c
				req.context  = 0x0;
8f61c3ec:	e58d3028 	str	r3, [r13, #40]	; 0x28
				req.data     = 0x0;
8f61c3f0:	e58d301c 	str	r3, [r13, #28]
				req.len      = 0x0;
8f61c3f4:	e58d3020 	str	r3, [r13, #32]
				req.trbctl   = TRBCTL_CONTROL_STATUS_2;
8f61c3f8:	e3a03003 	mov	r3, #3
8f61c3fc:	e5cd3024 	strb	r3, [r13, #36]	; 0x24
				dwc_request_queue(dev, ep_phy_num, &req);
8f61c400:	ebfffa60 	bl	8f61ad88 <dwc_request_queue>
				dev->ctrl_state = EP_FSM_STATUS_2;
8f61c404:	e3a03005 	mov	r3, #5
8f61c408:	e5c931d4 	strb	r3, [r9, #468]	; 0x1d4
8f61c40c:	eafffe06 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
			ASSERT(event_ctrl_stage == CONTROL_DATA_REQUEST);
8f61c410:	e20b6003 	and	r6, r11, #3
8f61c414:	e3560001 	cmp	r6, #1
8f61c418:	1a00017a 	bne	8f61ca08 <dwc_irq_handler_ee1+0xf18>
			if((ep->state == EP_STATE_START_TRANSFER) ||
8f61c41c:	e3a03f8e 	mov	r3, #568	; 0x238
8f61c420:	e0233397 	mla	r3, r7, r3, r3
8f61c424:	e0853003 	add	r3, r5, r3
8f61c428:	e5d33004 	ldrb	r3, [r3, #4]
8f61c42c:	e2433002 	sub	r3, r3, #2
8f61c430:	e3530001 	cmp	r3, #1
8f61c434:	9afffdfc 	bls	8f61bc2c <dwc_irq_handler_ee1+0x13c>
				end_ep_phy_num = (ep_phy_num == 0) ? 1 : 0;
8f61c438:	e16f7f17 	clz	r7, r7
				dwc_ep_cmd_end_transfer(dev, end_ep_phy_num);
8f61c43c:	e1a00005 	mov	r0, r5
				end_ep_phy_num = (ep_phy_num == 0) ? 1 : 0;
8f61c440:	e1a072a7 	lsr	r7, r7, #5
				dwc_ep_cmd_end_transfer(dev, end_ep_phy_num);
8f61c444:	e1a01007 	mov	r1, r7
8f61c448:	eb0003b8 	bl	8f61d330 <dwc_ep_cmd_end_transfer>
				dwc_ep_cmd_stall(dev, end_ep_phy_num);
8f61c44c:	eaffff70 	b	8f61c214 <dwc_irq_handler_ee1+0x724>
			ASSERT(ep->state == EP_STATE_XFER_IN_PROG);
8f61c450:	e0856006 	add	r6, r5, r6
8f61c454:	e5d6323c 	ldrb	r3, [r6, #572]	; 0x23c
8f61c458:	e3530003 	cmp	r3, #3
8f61c45c:	1a000153 	bne	8f61c9b0 <dwc_irq_handler_ee1+0xec0>
			status = dwc_event_check_trb_status(dev,
8f61c460:	e28d301c 	add	r3, r13, #28
			ep->state = EP_STATE_INACTIVE;
8f61c464:	e3a01001 	mov	r1, #1
			status = dwc_event_check_trb_status(dev,
8f61c468:	e1a02007 	mov	r2, r7
			ep->state = EP_STATE_INACTIVE;
8f61c46c:	e5c6123c 	strb	r1, [r6, #572]	; 0x23c
			status = dwc_event_check_trb_status(dev,
8f61c470:	e1a00005 	mov	r0, r5
8f61c474:	e28d1030 	add	r1, r13, #48	; 0x30
8f61c478:	ebfffd2b 	bl	8f61b92c <dwc_event_check_trb_status>
			dev->ctrl_state = EP_FSM_WAIT_FOR_HOST_3;
8f61c47c:	e3a03004 	mov	r3, #4
8f61c480:	e5c931d4 	strb	r3, [r9, #468]	; 0x1d4
		break;
8f61c484:	eafffde8 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
			dwc_dep_cmd_id_t cmd = DWC_EVENT_EP_EVENT_CMD_TYPE(*event);
8f61c488:	e5dd3033 	ldrb	r3, [r13, #51]	; 0x33
			if (cmd == DEPCMD_CMD_START_TRANSFER)
8f61c48c:	e203300f 	and	r3, r3, #15
8f61c490:	e3530006 	cmp	r3, #6
8f61c494:	1afffde4 	bne	8f61bc2c <dwc_irq_handler_ee1+0x13c>
				ASSERT(ep->state == EP_STATE_START_TRANSFER);
8f61c498:	e0856006 	add	r6, r5, r6
8f61c49c:	e5d6323c 	ldrb	r3, [r6, #572]	; 0x23c
8f61c4a0:	e3530002 	cmp	r3, #2
8f61c4a4:	1a0001b0 	bne	8f61cb6c <dwc_irq_handler_ee1+0x107c>
				ASSERT(event_status == 0);
8f61c4a8:	e31b000f 	tst	r11, #15
8f61c4ac:	1a0001a3 	bne	8f61cb40 <dwc_irq_handler_ee1+0x1050>
				ep->resource_idx = DWC_EVENT_EP_EVENT_XFER_RES_IDX(*event);
8f61c4b0:	e3a03f8e 	mov	r3, #568	; 0x238
				ep->state        = EP_STATE_XFER_IN_PROG;
8f61c4b4:	e3a02003 	mov	r2, #3
				ep->resource_idx = DWC_EVENT_EP_EVENT_XFER_RES_IDX(*event);
8f61c4b8:	e0275793 	mla	r7, r3, r7, r5
8f61c4bc:	e1dd33b2 	ldrh	r3, [r13, #50]	; 0x32
				ep->state        = EP_STATE_XFER_IN_PROG;
8f61c4c0:	e5c6223c 	strb	r2, [r6, #572]	; 0x23c
				ep->resource_idx = DWC_EVENT_EP_EVENT_XFER_RES_IDX(*event);
8f61c4c4:	e203307f 	and	r3, r3, #127	; 0x7f
8f61c4c8:	e5c73216 	strb	r3, [r7, #534]	; 0x216
8f61c4cc:	eafffdd6 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
			dwc_dep_cmd_id_t cmd = DWC_EVENT_EP_EVENT_CMD_TYPE(*event);
8f61c4d0:	e5dd3033 	ldrb	r3, [r13, #51]	; 0x33
			if (cmd == DEPCMD_CMD_START_TRANSFER)
8f61c4d4:	e203300f 	and	r3, r3, #15
8f61c4d8:	e3530006 	cmp	r3, #6
8f61c4dc:	1afffdd2 	bne	8f61bc2c <dwc_irq_handler_ee1+0x13c>
				ASSERT(ep->state == EP_STATE_START_TRANSFER);
8f61c4e0:	e085a00a 	add	r10, r5, r10
8f61c4e4:	e5da323c 	ldrb	r3, [r10, #572]	; 0x23c
8f61c4e8:	e3530002 	cmp	r3, #2
8f61c4ec:	1a000188 	bne	8f61cb14 <dwc_irq_handler_ee1+0x1024>
				ASSERT(event_status == 0);
8f61c4f0:	e3160a0f 	tst	r6, #61440	; 0xf000
8f61c4f4:	0afffeb7 	beq	8f61bfd8 <dwc_irq_handler_ee1+0x4e8>
8f61c4f8:	e3063f70 	movw	r3, #28528	; 0x6f70
8f61c4fc:	e306253c 	movw	r2, #25916	; 0x653c
8f61c500:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c504:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c508:	e58d3000 	str	r3, [r13]
8f61c50c:	e3001130 	movw	r1, #304	; 0x130
8f61c510:	e3003297 	movw	r3, #663	; 0x297
8f61c514:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c518:	e1a00008 	mov	r0, r8
8f61c51c:	eb005966 	bl	8f632abc <_panic>
8f61c520:	eafffeac 	b	8f61bfd8 <dwc_irq_handler_ee1+0x4e8>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c524:	e306355c 	movw	r3, #25948	; 0x655c
8f61c528:	e306253c 	movw	r2, #25916	; 0x653c
8f61c52c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c530:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c534:	e58d3000 	str	r3, [r13]
8f61c538:	e3001130 	movw	r1, #304	; 0x130
8f61c53c:	e30034ea 	movw	r3, #1258	; 0x4ea
8f61c540:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c544:	e1a00008 	mov	r0, r8
8f61c548:	eb00595b 	bl	8f632abc <_panic>
8f61c54c:	eafffe5c 	b	8f61bec4 <dwc_irq_handler_ee1+0x3d4>
	ASSERT(ep != NULL);
8f61c550:	e59d3014 	ldr	r3, [r13, #20]
8f61c554:	e306253c 	movw	r2, #25916	; 0x653c
8f61c558:	e3001130 	movw	r1, #304	; 0x130
8f61c55c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c560:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c564:	e1a00008 	mov	r0, r8
8f61c568:	e58d3000 	str	r3, [r13]
8f61c56c:	e30034ec 	movw	r3, #1260	; 0x4ec
8f61c570:	eb005951 	bl	8f632abc <_panic>
8f61c574:	eafffe56 	b	8f61bed4 <dwc_irq_handler_ee1+0x3e4>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c578:	e306355c 	movw	r3, #25948	; 0x655c
8f61c57c:	e306253c 	movw	r2, #25916	; 0x653c
8f61c580:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c584:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c588:	e58d3000 	str	r3, [r13]
8f61c58c:	e3001130 	movw	r1, #304	; 0x130
8f61c590:	e300351c 	movw	r3, #1308	; 0x51c
8f61c594:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c598:	e1a00008 	mov	r0, r8
8f61c59c:	eb005946 	bl	8f632abc <_panic>
8f61c5a0:	eafffe34 	b	8f61be78 <dwc_irq_handler_ee1+0x388>
	ASSERT(ep != NULL);
8f61c5a4:	e59d3014 	ldr	r3, [r13, #20]
8f61c5a8:	e306253c 	movw	r2, #25916	; 0x653c
8f61c5ac:	e3001130 	movw	r1, #304	; 0x130
8f61c5b0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c5b4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c5b8:	e1a00008 	mov	r0, r8
8f61c5bc:	e58d3000 	str	r3, [r13]
8f61c5c0:	e300351e 	movw	r3, #1310	; 0x51e
8f61c5c4:	eb00593c 	bl	8f632abc <_panic>
8f61c5c8:	eafffe2e 	b	8f61be88 <dwc_irq_handler_ee1+0x398>
					if (ep->req.callback)
8f61c5cc:	e3a03f8e 	mov	r3, #568	; 0x238
8f61c5d0:	e0223399 	mla	r2, r9, r3, r3
8f61c5d4:	e7956002 	ldr	r6, [r5, r2]
8f61c5d8:	e3560000 	cmp	r6, #0
8f61c5dc:	0a000004 	beq	8f61c5f4 <dwc_irq_handler_ee1+0xb04>
						ep->req.callback(ep->req.context, 0, -1);
8f61c5e0:	e0235993 	mla	r3, r3, r9, r5
8f61c5e4:	e3e02000 	mvn	r2, #0
8f61c5e8:	e3a01000 	mov	r1, #0
8f61c5ec:	e5930234 	ldr	r0, [r3, #564]	; 0x234
8f61c5f0:	e12fff36 	blx	r6
					dwc_ep_bulk_state_inactive_enter(dev, ep_phy_num);
8f61c5f4:	e1a01009 	mov	r1, r9
8f61c5f8:	e1a00005 	mov	r0, r5
8f61c5fc:	ebfff947 	bl	8f61ab20 <dwc_ep_bulk_state_inactive_enter>
8f61c600:	eafffd89 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
			status = dwc_event_check_trb_status(dev,
8f61c604:	e28d301c 	add	r3, r13, #28
8f61c608:	e1a0200b 	mov	r2, r11
			ep->state = EP_STATE_INACTIVE;
8f61c60c:	e3a01001 	mov	r1, #1
			status = dwc_event_check_trb_status(dev,
8f61c610:	e1a00005 	mov	r0, r5
			ep->state = EP_STATE_INACTIVE;
8f61c614:	e5c7123c 	strb	r1, [r7, #572]	; 0x23c
			status = dwc_event_check_trb_status(dev,
8f61c618:	e28d1030 	add	r1, r13, #48	; 0x30
8f61c61c:	ebfffcc2 	bl	8f61b92c <dwc_event_check_trb_status>
			dwc_ep_ctrl_state_setup_enter(dev);
8f61c620:	e1a00005 	mov	r0, r5
8f61c624:	ebfffb29 	bl	8f61b2d0 <dwc_ep_ctrl_state_setup_enter>
		break;
8f61c628:	eafffd7f 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
				ASSERT(0);
8f61c62c:	e3073f64 	movw	r3, #32612	; 0x7f64
8f61c630:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c634:	e58d3000 	str	r3, [r13]
8f61c638:	e3003395 	movw	r3, #917	; 0x395
8f61c63c:	eafffde9 	b	8f61bde8 <dwc_irq_handler_ee1+0x2f8>
				dwc_request_queue(dev, ep_phy_num, &req);
8f61c640:	e28d201c 	add	r2, r13, #28
8f61c644:	e1a01007 	mov	r1, r7
8f61c648:	e1a00005 	mov	r0, r5
				req.callback = 0x0;
8f61c64c:	e3a03000 	mov	r3, #0
8f61c650:	e58d302c 	str	r3, [r13, #44]	; 0x2c
				req.context  = 0x0;
8f61c654:	e58d3028 	str	r3, [r13, #40]	; 0x28
				req.data     = 0x0;
8f61c658:	e58d301c 	str	r3, [r13, #28]
				req.len      = 0x0;
8f61c65c:	e58d3020 	str	r3, [r13, #32]
				req.trbctl   = TRBCTL_CONTROL_STATUS_3;
8f61c660:	e3a03004 	mov	r3, #4
8f61c664:	e5cd3024 	strb	r3, [r13, #36]	; 0x24
				dwc_request_queue(dev, ep_phy_num, &req);
8f61c668:	ebfff9c6 	bl	8f61ad88 <dwc_request_queue>
				dev->ctrl_state = EP_FSM_STATUS_3;
8f61c66c:	e3a03006 	mov	r3, #6
8f61c670:	e5c931d4 	strb	r3, [r9, #468]	; 0x1d4
8f61c674:	eafffd6c 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
				uint8_t *data = dev->setup_pkt; /* setup pkt data */
8f61c678:	e59961d8 	ldr	r6, [r9, #472]	; 0x1d8
				arch_invalidate_cache_range((addr_t) data, ROUNDUP(DWC_SETUP_PKT_LEN, CACHE_LINE));
8f61c67c:	e3a01040 	mov	r1, #64	; 0x40
8f61c680:	e1a00006 	mov	r0, r6
8f61c684:	eb00124f 	bl	8f620fc8 <arch_invalidate_cache_range>
				ret = dev->setup_handler(dev->setup_context, data);
8f61c688:	e59931e8 	ldr	r3, [r9, #488]	; 0x1e8
8f61c68c:	e59901e4 	ldr	r0, [r9, #484]	; 0x1e4
8f61c690:	e1a01006 	mov	r1, r6
8f61c694:	e12fff33 	blx	r3
				if (ret == DWC_SETUP_2_STAGE)
8f61c698:	e3500002 	cmp	r0, #2
					dev->ctrl_state = EP_FSM_WAIT_FOR_HOST_2;
8f61c69c:	03a03003 	moveq	r3, #3
8f61c6a0:	05c931d4 	strbeq	r3, [r9, #468]	; 0x1d4
				if (ret == DWC_SETUP_2_STAGE)
8f61c6a4:	0afffd60 	beq	8f61bc2c <dwc_irq_handler_ee1+0x13c>
				else if (ret == DWC_SETUP_3_STAGE)
8f61c6a8:	e3500003 	cmp	r0, #3
8f61c6ac:	1afffed8 	bne	8f61c214 <dwc_irq_handler_ee1+0x724>
					dev->ctrl_state = EP_FSM_CTRL_DATA;
8f61c6b0:	e3a03002 	mov	r3, #2
8f61c6b4:	e5c931d4 	strb	r3, [r9, #468]	; 0x1d4
8f61c6b8:	eafffd5b 	b	8f61bc2c <dwc_irq_handler_ee1+0x13c>
				if (ep->state == EP_STATE_START_TRANSFER ||
8f61c6bc:	e3a03f8e 	mov	r3, #568	; 0x238
					dwc_request_queue(dev, ep_phy_num, &req);
8f61c6c0:	e1a01007 	mov	r1, r7
				if (ep->state == EP_STATE_START_TRANSFER ||
8f61c6c4:	e0233397 	mla	r3, r7, r3, r3
8f61c6c8:	e0853003 	add	r3, r5, r3
8f61c6cc:	e5d33004 	ldrb	r3, [r3, #4]
8f61c6d0:	e2433002 	sub	r3, r3, #2
8f61c6d4:	e3530001 	cmp	r3, #1
8f61c6d8:	8afffece 	bhi	8f61c218 <dwc_irq_handler_ee1+0x728>
					dwc_request_queue(dev, ep_phy_num, &req);
8f61c6dc:	e28d201c 	add	r2, r13, #28
8f61c6e0:	e1a00005 	mov	r0, r5
					req.callback = 0x0;
8f61c6e4:	e3a03000 	mov	r3, #0
8f61c6e8:	e58d302c 	str	r3, [r13, #44]	; 0x2c
					req.context  = 0x0;
8f61c6ec:	e58d3028 	str	r3, [r13, #40]	; 0x28
					req.data     = 0x0;
8f61c6f0:	e58d301c 	str	r3, [r13, #28]
					req.len      = 0x0;
8f61c6f4:	e58d3020 	str	r3, [r13, #32]
					req.trbctl   = TRBCTL_CONTROL_DATA;
8f61c6f8:	e3a03005 	mov	r3, #5
8f61c6fc:	e5cd3024 	strb	r3, [r13, #36]	; 0x24
					dwc_request_queue(dev, ep_phy_num, &req);
8f61c700:	ebfff9a0 	bl	8f61ad88 <dwc_request_queue>
8f61c704:	eaffffe9 	b	8f61c6b0 <dwc_irq_handler_ee1+0xbc0>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c708:	e306355c 	movw	r3, #25948	; 0x655c
8f61c70c:	e306253c 	movw	r2, #25916	; 0x653c
8f61c710:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c714:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c718:	e58d3000 	str	r3, [r13]
8f61c71c:	e3001130 	movw	r1, #304	; 0x130
8f61c720:	e30033fd 	movw	r3, #1021	; 0x3fd
8f61c724:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c728:	e1a00008 	mov	r0, r8
8f61c72c:	eb0058e2 	bl	8f632abc <_panic>
8f61c730:	eafffe34 	b	8f61c008 <dwc_irq_handler_ee1+0x518>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c734:	e306355c 	movw	r3, #25948	; 0x655c
8f61c738:	e306253c 	movw	r2, #25916	; 0x653c
8f61c73c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c740:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c744:	e58d3000 	str	r3, [r13]
8f61c748:	e3001130 	movw	r1, #304	; 0x130
8f61c74c:	e30033ab 	movw	r3, #939	; 0x3ab
8f61c750:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c754:	e1a00008 	mov	r0, r8
8f61c758:	eb0058d7 	bl	8f632abc <_panic>
8f61c75c:	eafffe48 	b	8f61c084 <dwc_irq_handler_ee1+0x594>
	ASSERT(ep != NULL);
8f61c760:	e59d3014 	ldr	r3, [r13, #20]
8f61c764:	e306253c 	movw	r2, #25916	; 0x653c
8f61c768:	e3001130 	movw	r1, #304	; 0x130
8f61c76c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c770:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c774:	e1a00008 	mov	r0, r8
8f61c778:	e58d3000 	str	r3, [r13]
8f61c77c:	e30032fe 	movw	r3, #766	; 0x2fe
8f61c780:	eb0058cd 	bl	8f632abc <_panic>
8f61c784:	eafffe57 	b	8f61c0e8 <dwc_irq_handler_ee1+0x5f8>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c788:	e306355c 	movw	r3, #25948	; 0x655c
8f61c78c:	e306253c 	movw	r2, #25916	; 0x653c
8f61c790:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c794:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c798:	e58d3000 	str	r3, [r13]
8f61c79c:	e3001130 	movw	r1, #304	; 0x130
8f61c7a0:	e3a03fbf 	mov	r3, #764	; 0x2fc
8f61c7a4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c7a8:	e1a00008 	mov	r0, r8
8f61c7ac:	eb0058c2 	bl	8f632abc <_panic>
8f61c7b0:	eafffe47 	b	8f61c0d4 <dwc_irq_handler_ee1+0x5e4>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c7b4:	e306355c 	movw	r3, #25948	; 0x655c
8f61c7b8:	e306253c 	movw	r2, #25916	; 0x653c
8f61c7bc:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c7c0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c7c4:	e58d3000 	str	r3, [r13]
8f61c7c8:	e3001130 	movw	r1, #304	; 0x130
8f61c7cc:	e300349d 	movw	r3, #1181	; 0x49d
8f61c7d0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c7d4:	e1a00008 	mov	r0, r8
8f61c7d8:	eb0058b7 	bl	8f632abc <_panic>
8f61c7dc:	eafffdd1 	b	8f61bf28 <dwc_irq_handler_ee1+0x438>
	ASSERT(ep != NULL);
8f61c7e0:	e59d3014 	ldr	r3, [r13, #20]
8f61c7e4:	e306253c 	movw	r2, #25916	; 0x653c
8f61c7e8:	e3001130 	movw	r1, #304	; 0x130
8f61c7ec:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c7f0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c7f4:	e1a00008 	mov	r0, r8
8f61c7f8:	e58d3000 	str	r3, [r13]
8f61c7fc:	e30033ff 	movw	r3, #1023	; 0x3ff
8f61c800:	eb0058ad 	bl	8f632abc <_panic>
8f61c804:	eafffe04 	b	8f61c01c <dwc_irq_handler_ee1+0x52c>
	ASSERT(ep != NULL);
8f61c808:	e59d3014 	ldr	r3, [r13, #20]
8f61c80c:	e306253c 	movw	r2, #25916	; 0x653c
8f61c810:	e3001130 	movw	r1, #304	; 0x130
8f61c814:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c818:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c81c:	e1a00008 	mov	r0, r8
8f61c820:	e58d3000 	str	r3, [r13]
8f61c824:	e30033ad 	movw	r3, #941	; 0x3ad
8f61c828:	eb0058a3 	bl	8f632abc <_panic>
8f61c82c:	eafffe18 	b	8f61c094 <dwc_irq_handler_ee1+0x5a4>
	ASSERT(ep != NULL);
8f61c830:	e59d3014 	ldr	r3, [r13, #20]
8f61c834:	e306253c 	movw	r2, #25916	; 0x653c
8f61c838:	e3001130 	movw	r1, #304	; 0x130
8f61c83c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c840:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c844:	e1a00008 	mov	r0, r8
8f61c848:	e58d3000 	str	r3, [r13]
8f61c84c:	e300349f 	movw	r3, #1183	; 0x49f
8f61c850:	eb005899 	bl	8f632abc <_panic>
8f61c854:	eafffdb7 	b	8f61bf38 <dwc_irq_handler_ee1+0x448>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c858:	e306355c 	movw	r3, #25948	; 0x655c
8f61c85c:	e306253c 	movw	r2, #25916	; 0x653c
8f61c860:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c864:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c868:	e58d3000 	str	r3, [r13]
8f61c86c:	e3001130 	movw	r1, #304	; 0x130
8f61c870:	e3003289 	movw	r3, #649	; 0x289
8f61c874:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c878:	e1a00008 	mov	r0, r8
8f61c87c:	eb00588e 	bl	8f632abc <_panic>
8f61c880:	eafffe25 	b	8f61c11c <dwc_irq_handler_ee1+0x62c>
	ASSERT(ep != NULL);
8f61c884:	e59d3014 	ldr	r3, [r13, #20]
8f61c888:	e306253c 	movw	r2, #25916	; 0x653c
8f61c88c:	e3001130 	movw	r1, #304	; 0x130
8f61c890:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c894:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c898:	e1a00008 	mov	r0, r8
8f61c89c:	e58d3000 	str	r3, [r13]
8f61c8a0:	e300328b 	movw	r3, #651	; 0x28b
8f61c8a4:	eb005884 	bl	8f632abc <_panic>
8f61c8a8:	eafffe20 	b	8f61c130 <dwc_irq_handler_ee1+0x640>
	ASSERT(DWC_EP_PHY_TO_INDEX(ep_phy_num) < DWC_MAX_NUM_OF_EP);
8f61c8ac:	e306355c 	movw	r3, #25948	; 0x655c
8f61c8b0:	e306253c 	movw	r2, #25916	; 0x653c
8f61c8b4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c8b8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c8bc:	e58d3000 	str	r3, [r13]
8f61c8c0:	e3001130 	movw	r1, #304	; 0x130
8f61c8c4:	e300344e 	movw	r3, #1102	; 0x44e
8f61c8c8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c8cc:	e1a00008 	mov	r0, r8
8f61c8d0:	eb005879 	bl	8f632abc <_panic>
8f61c8d4:	eafffdac 	b	8f61bf8c <dwc_irq_handler_ee1+0x49c>
	ASSERT(ep != NULL);
8f61c8d8:	e59d3014 	ldr	r3, [r13, #20]
8f61c8dc:	e306253c 	movw	r2, #25916	; 0x653c
8f61c8e0:	e3001130 	movw	r1, #304	; 0x130
8f61c8e4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c8e8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c8ec:	e1a00008 	mov	r0, r8
8f61c8f0:	e58d3000 	str	r3, [r13]
8f61c8f4:	e3a03e45 	mov	r3, #1104	; 0x450
8f61c8f8:	eb00586f 	bl	8f632abc <_panic>
8f61c8fc:	eafffda7 	b	8f61bfa0 <dwc_irq_handler_ee1+0x4b0>
			ASSERT(ep->state == EP_STATE_XFER_IN_PROG);
8f61c900:	e3063f94 	movw	r3, #28564	; 0x6f94
8f61c904:	e306253c 	movw	r2, #25916	; 0x653c
8f61c908:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c90c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c910:	e58d3000 	str	r3, [r13]
8f61c914:	e3001130 	movw	r1, #304	; 0x130
8f61c918:	e3003422 	movw	r3, #1058	; 0x422
8f61c91c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c920:	e1a00008 	mov	r0, r8
8f61c924:	eb005864 	bl	8f632abc <_panic>
8f61c928:	eafffe8f 	b	8f61c36c <dwc_irq_handler_ee1+0x87c>
			ASSERT(ep_phy_num == 1);
8f61c92c:	e307300c 	movw	r3, #28684	; 0x700c
8f61c930:	e306253c 	movw	r2, #25916	; 0x653c
8f61c934:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c938:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c93c:	e58d3000 	str	r3, [r13]
8f61c940:	e3001130 	movw	r1, #304	; 0x130
8f61c944:	e300341d 	movw	r3, #1053	; 0x41d
8f61c948:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c94c:	e1a00008 	mov	r0, r8
8f61c950:	eb005859 	bl	8f632abc <_panic>
8f61c954:	eafffe80 	b	8f61c35c <dwc_irq_handler_ee1+0x86c>
			ASSERT(ep->state == EP_STATE_XFER_IN_PROG);
8f61c958:	e3063f94 	movw	r3, #28564	; 0x6f94
8f61c95c:	e306253c 	movw	r2, #25916	; 0x653c
8f61c960:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c964:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c968:	e58d3000 	str	r3, [r13]
8f61c96c:	e3001130 	movw	r1, #304	; 0x130
8f61c970:	e3003471 	movw	r3, #1137	; 0x471
8f61c974:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c978:	e1a00008 	mov	r0, r8
8f61c97c:	eb00584e 	bl	8f632abc <_panic>
8f61c980:	eafffe17 	b	8f61c1e4 <dwc_irq_handler_ee1+0x6f4>
			ASSERT(ep->state == EP_STATE_XFER_IN_PROG);
8f61c984:	e3063f94 	movw	r3, #28564	; 0x6f94
8f61c988:	e306253c 	movw	r2, #25916	; 0x653c
8f61c98c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c990:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c994:	e58d3000 	str	r3, [r13]
8f61c998:	e3001130 	movw	r1, #304	; 0x130
8f61c99c:	e30032b9 	movw	r3, #697	; 0x2b9
8f61c9a0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c9a4:	e1a00008 	mov	r0, r8
8f61c9a8:	eb005843 	bl	8f632abc <_panic>
8f61c9ac:	eafffe59 	b	8f61c318 <dwc_irq_handler_ee1+0x828>
			ASSERT(ep->state == EP_STATE_XFER_IN_PROG);
8f61c9b0:	e3063f94 	movw	r3, #28564	; 0x6f94
8f61c9b4:	e306253c 	movw	r2, #25916	; 0x653c
8f61c9b8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c9bc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c9c0:	e58d3000 	str	r3, [r13]
8f61c9c4:	e3001130 	movw	r1, #304	; 0x130
8f61c9c8:	e3003347 	movw	r3, #839	; 0x347
8f61c9cc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c9d0:	e1a00008 	mov	r0, r8
8f61c9d4:	eb005838 	bl	8f632abc <_panic>
8f61c9d8:	eafffea0 	b	8f61c460 <dwc_irq_handler_ee1+0x970>
			ASSERT(ep_phy_num == 0);
8f61c9dc:	e3063f84 	movw	r3, #28548	; 0x6f84
8f61c9e0:	e306253c 	movw	r2, #25916	; 0x653c
8f61c9e4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61c9e8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61c9ec:	e58d3000 	str	r3, [r13]
8f61c9f0:	e3001130 	movw	r1, #304	; 0x130
8f61c9f4:	e30032b6 	movw	r3, #694	; 0x2b6
8f61c9f8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61c9fc:	e1a00008 	mov	r0, r8
8f61ca00:	eb00582d 	bl	8f632abc <_panic>
8f61ca04:	eafffe3f 	b	8f61c308 <dwc_irq_handler_ee1+0x818>
			ASSERT(event_ctrl_stage == CONTROL_DATA_REQUEST);
8f61ca08:	e3063fe0 	movw	r3, #28640	; 0x6fe0
8f61ca0c:	e306253c 	movw	r2, #25916	; 0x653c
8f61ca10:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61ca14:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61ca18:	e58d3000 	str	r3, [r13]
8f61ca1c:	e3001130 	movw	r1, #304	; 0x130
8f61ca20:	e300331e 	movw	r3, #798	; 0x31e
8f61ca24:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61ca28:	e1a00008 	mov	r0, r8
8f61ca2c:	eb005822 	bl	8f632abc <_panic>
8f61ca30:	eafffe79 	b	8f61c41c <dwc_irq_handler_ee1+0x92c>
				ASSERT(ep_phy_num == 1);
8f61ca34:	e307300c 	movw	r3, #28684	; 0x700c
8f61ca38:	e306253c 	movw	r2, #25916	; 0x653c
8f61ca3c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61ca40:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61ca44:	e58d3000 	str	r3, [r13]
8f61ca48:	e3001130 	movw	r1, #304	; 0x130
8f61ca4c:	e3003385 	movw	r3, #901	; 0x385
8f61ca50:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61ca54:	e1a00008 	mov	r0, r8
8f61ca58:	eb005817 	bl	8f632abc <_panic>
8f61ca5c:	eafffe5d 	b	8f61c3d8 <dwc_irq_handler_ee1+0x8e8>
			ASSERT(event_status == 0);
8f61ca60:	e3063f70 	movw	r3, #28528	; 0x6f70
8f61ca64:	e306253c 	movw	r2, #25916	; 0x653c
8f61ca68:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61ca6c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61ca70:	e58d3000 	str	r3, [r13]
8f61ca74:	e3001130 	movw	r1, #304	; 0x130
8f61ca78:	e300345d 	movw	r3, #1117	; 0x45d
8f61ca7c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61ca80:	e1a00008 	mov	r0, r8
8f61ca84:	eb00580c 	bl	8f632abc <_panic>
8f61ca88:	eafffd52 	b	8f61bfd8 <dwc_irq_handler_ee1+0x4e8>
			ASSERT(ep->state == EP_STATE_START_TRANSFER);
8f61ca8c:	e3063f48 	movw	r3, #28488	; 0x6f48
8f61ca90:	e306253c 	movw	r2, #25916	; 0x653c
8f61ca94:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61ca98:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61ca9c:	e58d3000 	str	r3, [r13]
8f61caa0:	e3001130 	movw	r1, #304	; 0x130
8f61caa4:	e300345b 	movw	r3, #1115	; 0x45b
8f61caa8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61caac:	e1a00008 	mov	r0, r8
8f61cab0:	eb005801 	bl	8f632abc <_panic>
8f61cab4:	eafffd45 	b	8f61bfd0 <dwc_irq_handler_ee1+0x4e0>
				ASSERT(event_status == 0);
8f61cab8:	e3063f70 	movw	r3, #28528	; 0x6f70
8f61cabc:	e306253c 	movw	r2, #25916	; 0x653c
8f61cac0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61cac4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61cac8:	e58d3000 	str	r3, [r13]
8f61cacc:	e3001130 	movw	r1, #304	; 0x130
8f61cad0:	e300340b 	movw	r3, #1035	; 0x40b
8f61cad4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61cad8:	e1a00008 	mov	r0, r8
8f61cadc:	eb0057f6 	bl	8f632abc <_panic>
8f61cae0:	eafffd5b 	b	8f61c054 <dwc_irq_handler_ee1+0x564>
8f61cae4:	8f74221c 	.word	0x8f74221c
				ASSERT(ep->state == EP_STATE_START_TRANSFER);
8f61cae8:	e3063f48 	movw	r3, #28488	; 0x6f48
8f61caec:	e306253c 	movw	r2, #25916	; 0x653c
8f61caf0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61caf4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61caf8:	e58d3000 	str	r3, [r13]
8f61cafc:	e3001130 	movw	r1, #304	; 0x130
8f61cb00:	e3003409 	movw	r3, #1033	; 0x409
8f61cb04:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61cb08:	e1a00008 	mov	r0, r8
8f61cb0c:	eb0057ea 	bl	8f632abc <_panic>
8f61cb10:	eafffd4d 	b	8f61c04c <dwc_irq_handler_ee1+0x55c>
				ASSERT(ep->state == EP_STATE_START_TRANSFER);
8f61cb14:	e3063f48 	movw	r3, #28488	; 0x6f48
8f61cb18:	e306253c 	movw	r2, #25916	; 0x653c
8f61cb1c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61cb20:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61cb24:	e58d3000 	str	r3, [r13]
8f61cb28:	e3001130 	movw	r1, #304	; 0x130
8f61cb2c:	e3003295 	movw	r3, #661	; 0x295
8f61cb30:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61cb34:	e1a00008 	mov	r0, r8
8f61cb38:	eb0057df 	bl	8f632abc <_panic>
8f61cb3c:	eafffe6b 	b	8f61c4f0 <dwc_irq_handler_ee1+0xa00>
				ASSERT(event_status == 0);
8f61cb40:	e3063f70 	movw	r3, #28528	; 0x6f70
8f61cb44:	e306253c 	movw	r2, #25916	; 0x653c
8f61cb48:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61cb4c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61cb50:	e58d3000 	str	r3, [r13]
8f61cb54:	e3001130 	movw	r1, #304	; 0x130
8f61cb58:	e300330a 	movw	r3, #778	; 0x30a
8f61cb5c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61cb60:	e1a00008 	mov	r0, r8
8f61cb64:	eb0057d4 	bl	8f632abc <_panic>
8f61cb68:	eafffe50 	b	8f61c4b0 <dwc_irq_handler_ee1+0x9c0>
				ASSERT(ep->state == EP_STATE_START_TRANSFER);
8f61cb6c:	e3063f48 	movw	r3, #28488	; 0x6f48
8f61cb70:	e306253c 	movw	r2, #25916	; 0x653c
8f61cb74:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61cb78:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61cb7c:	e58d3000 	str	r3, [r13]
8f61cb80:	e3001130 	movw	r1, #304	; 0x130
8f61cb84:	e3a03fc2 	mov	r3, #776	; 0x308
8f61cb88:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61cb8c:	e1a00008 	mov	r0, r8
8f61cb90:	eb0057c9 	bl	8f632abc <_panic>
8f61cb94:	eafffe43 	b	8f61c4a8 <dwc_irq_handler_ee1+0x9b8>
}
8f61cb98:	eb005808 	bl	8f632bc0 <__stack_chk_fail>
		ERR("Invalid ctrl_state = %d\n", dev->ctrl_state);
8f61cb9c:	e3070068 	movw	r0, #28776	; 0x7068
8f61cba0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61cba4:	eb005772 	bl	8f632974 <_dprintf>
		dwc_print_ep_event_details(dev, event);
8f61cba8:	e28d0030 	add	r0, r13, #48	; 0x30
8f61cbac:	ebfff9ed 	bl	8f61b368 <dwc_print_ep_event_details.constprop.0>
		dwc_print_current_state(dev);
8f61cbb0:	e1a00005 	mov	r0, r5
8f61cbb4:	ebfff817 	bl	8f61ac18 <dwc_print_current_state>
		ASSERT(0);
8f61cbb8:	e3073f64 	movw	r3, #32612	; 0x7f64
8f61cbbc:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61cbc0:	e58d3000 	str	r3, [r13]
8f61cbc4:	e3003227 	movw	r3, #551	; 0x227
8f61cbc8:	eafffc86 	b	8f61bde8 <dwc_irq_handler_ee1+0x2f8>

8f61cbcc <dwc_device_init>:
{
8f61cbcc:	e59f3214 	ldr	r3, [pc, #532]	; 8f61cde8 <dwc_device_init+0x21c>
8f61cbd0:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f61cbd4:	e1a04000 	mov	r4, r0
8f61cbd8:	e24dd014 	sub	r13, r13, #20
8f61cbdc:	e1a0500e 	mov	r5, r14
8f61cbe0:	e5933000 	ldr	r3, [r3]
8f61cbe4:	e58d300c 	str	r3, [r13, #12]
8f61cbe8:	e3a03000 	mov	r3, #0
	dwc_device_reset(dev);
8f61cbec:	eb0002ce 	bl	8f61d72c <dwc_device_reset>
	dwc_gctl_init(dev);
8f61cbf0:	e1a00004 	mov	r0, r4
8f61cbf4:	eb000505 	bl	8f61e010 <dwc_gctl_init>
	dwc_axi_master_config(dev);
8f61cbf8:	e1a00004 	mov	r0, r4
8f61cbfc:	eb00047e 	bl	8f61ddfc <dwc_axi_master_config>
	dwc_event_init(dev);
8f61cc00:	e1a00004 	mov	r0, r4
8f61cc04:	eb00038e 	bl	8f61da44 <dwc_event_init>
	dwc_event_device_enable(dev, BIT(DWC_EVENT_DEVICE_EVENT_ID_DISCONNECT)   |
8f61cc08:	e3a01047 	mov	r1, #71	; 0x47
8f61cc0c:	e1a00004 	mov	r0, r4
8f61cc10:	eb00041d 	bl	8f61dc8c <dwc_event_device_enable>
	dwc_ep_cmd_start_new_config(dev, 0, 0);
8f61cc14:	e3a02000 	mov	r2, #0
8f61cc18:	e1a01002 	mov	r1, r2
8f61cc1c:	e1a00004 	mov	r0, r4
8f61cc20:	eb000253 	bl	8f61d574 <dwc_ep_cmd_start_new_config>
	dev->ep[index].number            = 0;
8f61cc24:	e3a03000 	mov	r3, #0
	dev->ep[index].trb               = memalign(lcm(CACHE_LINE, 16),
8f61cc28:	e3a01010 	mov	r1, #16
	dev->ep[index].max_pkt_size      = 512;
8f61cc2c:	e3a02c02 	mov	r2, #512	; 0x200
	dev->ep[index].number            = 0;
8f61cc30:	e1c430b8 	strh	r3, [r4, #8]
	dev->ep[index].trb               = memalign(lcm(CACHE_LINE, 16),
8f61cc34:	e3a00040 	mov	r0, #64	; 0x40
	dev->ep[index].type              = EP_TYPE_CONTROL;
8f61cc38:	e5c4300a 	strb	r3, [r4, #10]
	dev->ep[index].state             = EP_STATE_INIT;
8f61cc3c:	e5c4323c 	strb	r3, [r4, #572]	; 0x23c
	dev->ep[index].max_pkt_size      = 512;
8f61cc40:	e1c420bc 	strh	r2, [r4, #12]
	dev->ep[index].trb_count         = 1;
8f61cc44:	e3a02001 	mov	r2, #1
	dev->ep[index].burst_size        = 0;
8f61cc48:	e5843010 	str	r3, [r4, #16]
	dev->ep[index].phy_num           = 0;
8f61cc4c:	e1c431b4 	strh	r3, [r4, #20]
	dev->ep[index].zlp               = 0;
8f61cc50:	e5c4300e 	strb	r3, [r4, #14]
	dev->ep[index].trb_count         = 1;
8f61cc54:	e584221c 	str	r2, [r4, #540]	; 0x21c
	dev->ep[index].trb               = memalign(lcm(CACHE_LINE, 16),
8f61cc58:	eb005a43 	bl	8f63356c <lcm>
												ROUNDUP(dev->ep[index].trb_count*sizeof(dwc_trb_t), CACHE_LINE));
8f61cc5c:	e594121c 	ldr	r1, [r4, #540]	; 0x21c
8f61cc60:	e1a01201 	lsl	r1, r1, #4
8f61cc64:	e281103f 	add	r1, r1, #63	; 0x3f
	dev->ep[index].trb               = memalign(lcm(CACHE_LINE, 16),
8f61cc68:	e3c1103f 	bic	r1, r1, #63	; 0x3f
8f61cc6c:	eb005cf4 	bl	8f634044 <memalign>
	ASSERT(dev->ep[index].trb);
8f61cc70:	e3500000 	cmp	r0, #0
	dev->ep[index].trb               = memalign(lcm(CACHE_LINE, 16),
8f61cc74:	e5840218 	str	r0, [r4, #536]	; 0x218
	ASSERT(dev->ep[index].trb);
8f61cc78:	0a000043 	beq	8f61cd8c <dwc_device_init+0x1c0>
	dev->ep[index].phy_num           = 1;
8f61cc7c:	e2842f93 	add	r2, r4, #588	; 0x24c
	dev->ep[index].number            = 0;
8f61cc80:	e284cd09 	add	r12, r4, #576	; 0x240
	dev->ep[index].max_pkt_size      = 512;
8f61cc84:	e2840f91 	add	r0, r4, #580	; 0x244
	dev->ep[index].trb_queued        = 0;
8f61cc88:	e3a03000 	mov	r3, #0
	dev->ep[index].phy_num           = 1;
8f61cc8c:	e3a0e001 	mov	r14, #1
	dev->ep[index].trb_queued        = 0;
8f61cc90:	e5843220 	str	r3, [r4, #544]	; 0x220
	dev->ep[index].bytes_queued      = 0;
8f61cc94:	e5843224 	str	r3, [r4, #548]	; 0x224
	dev->ep[index].trb               = memalign(lcm(CACHE_LINE, 16),
8f61cc98:	e3a01010 	mov	r1, #16
	dev->ep[index].number            = 0;
8f61cc9c:	e3a06c01 	mov	r6, #256	; 0x100
8f61cca0:	e1cc60b0 	strh	r6, [r12]
	dev->ep[index].type              = EP_TYPE_CONTROL;
8f61cca4:	e5c43242 	strb	r3, [r4, #578]	; 0x242
	dev->ep[index].max_pkt_size      = 512;
8f61cca8:	e3a0cc02 	mov	r12, #512	; 0x200
	dev->ep[index].state             = EP_STATE_INIT;
8f61ccac:	e5c43474 	strb	r3, [r4, #1140]	; 0x474
	dev->ep[index].max_pkt_size      = 512;
8f61ccb0:	e1c0c0b0 	strh	r12, [r0]
	dev->ep[index].trb               = memalign(lcm(CACHE_LINE, 16),
8f61ccb4:	e3a00040 	mov	r0, #64	; 0x40
	dev->ep[index].burst_size        = 0;
8f61ccb8:	e5843248 	str	r3, [r4, #584]	; 0x248
	dev->ep[index].phy_num           = 1;
8f61ccbc:	e1c2e0b0 	strh	r14, [r2]
	dev->ep[index].zlp               = 0;
8f61ccc0:	e5c43246 	strb	r3, [r4, #582]	; 0x246
	dev->ep[index].trb_count         = 1;
8f61ccc4:	e584e454 	str	r14, [r4, #1108]	; 0x454
	dev->ep[index].trb               = memalign(lcm(CACHE_LINE, 16),
8f61ccc8:	eb005a27 	bl	8f63356c <lcm>
												ROUNDUP(dev->ep[index].trb_count*sizeof(dwc_trb_t), CACHE_LINE));
8f61cccc:	e5941454 	ldr	r1, [r4, #1108]	; 0x454
8f61ccd0:	e1a01201 	lsl	r1, r1, #4
8f61ccd4:	e281103f 	add	r1, r1, #63	; 0x3f
	dev->ep[index].trb               = memalign(lcm(CACHE_LINE, 16),
8f61ccd8:	e3c1103f 	bic	r1, r1, #63	; 0x3f
8f61ccdc:	eb005cd8 	bl	8f634044 <memalign>
	ASSERT(dev->ep[index].trb);
8f61cce0:	e3500000 	cmp	r0, #0
	dev->ep[index].trb               = memalign(lcm(CACHE_LINE, 16),
8f61cce4:	e5840450 	str	r0, [r4, #1104]	; 0x450
	ASSERT(dev->ep[index].trb);
8f61cce8:	0a000032 	beq	8f61cdb8 <dwc_device_init+0x1ec>
	uint8_t ep_phy_num = dev->ep[index].phy_num;
8f61ccec:	e5d47014 	ldrb	r7, [r4, #20]
	dev->ep[index].trb_queued        = 0;
8f61ccf0:	e3a05000 	mov	r5, #0
	dwc_ep_cmd_set_config(dev, index, SET_CONFIG_ACTION_INIT);
8f61ccf4:	e1a02005 	mov	r2, r5
8f61ccf8:	e1a01005 	mov	r1, r5
8f61ccfc:	e1a00004 	mov	r0, r4
	dev->ep[index].trb_queued        = 0;
8f61cd00:	e5845458 	str	r5, [r4, #1112]	; 0x458
	dev->ep[index].bytes_queued      = 0;
8f61cd04:	e584545c 	str	r5, [r4, #1116]	; 0x45c
	dev->ep[index].state = EP_STATE_INACTIVE;
8f61cd08:	e3a06001 	mov	r6, #1
	dwc_ep_cmd_set_config(dev, index, SET_CONFIG_ACTION_INIT);
8f61cd0c:	eb0001bc 	bl	8f61d404 <dwc_ep_cmd_set_config>
	dwc_ep_cmd_set_transfer_resource(dev, ep_phy_num);
8f61cd10:	e1a01007 	mov	r1, r7
8f61cd14:	e1a00004 	mov	r0, r4
	dev->ep[index].state = EP_STATE_INACTIVE;
8f61cd18:	e5c4623c 	strb	r6, [r4, #572]	; 0x23c
	dwc_ep_cmd_set_transfer_resource(dev, ep_phy_num);
8f61cd1c:	eb00019f 	bl	8f61d3a0 <dwc_ep_cmd_set_transfer_resource>
	dwc_ep_enable(dev, ep_phy_num);
8f61cd20:	e1a01007 	mov	r1, r7
8f61cd24:	e1a00004 	mov	r0, r4
8f61cd28:	eb00048a 	bl	8f61df58 <dwc_ep_enable>
	uint8_t ep_phy_num = dev->ep[index].phy_num;
8f61cd2c:	e5d4724c 	ldrb	r7, [r4, #588]	; 0x24c
	dwc_ep_cmd_set_config(dev, index, SET_CONFIG_ACTION_INIT);
8f61cd30:	e1a02005 	mov	r2, r5
8f61cd34:	e1a01006 	mov	r1, r6
8f61cd38:	e1a00004 	mov	r0, r4
8f61cd3c:	eb0001b0 	bl	8f61d404 <dwc_ep_cmd_set_config>
	dwc_ep_cmd_set_transfer_resource(dev, ep_phy_num);
8f61cd40:	e1a01007 	mov	r1, r7
8f61cd44:	e1a00004 	mov	r0, r4
	dev->ep[index].state = EP_STATE_INACTIVE;
8f61cd48:	e5c46474 	strb	r6, [r4, #1140]	; 0x474
	dwc_ep_cmd_set_transfer_resource(dev, ep_phy_num);
8f61cd4c:	eb000193 	bl	8f61d3a0 <dwc_ep_cmd_set_transfer_resource>
	dwc_ep_enable(dev, ep_phy_num);
8f61cd50:	e1a01007 	mov	r1, r7
8f61cd54:	e1a00004 	mov	r0, r4
8f61cd58:	eb00047e 	bl	8f61df58 <dwc_ep_enable>
	unmask_interrupt(USB30_EE1_IRQ);
8f61cd5c:	e3a000ac 	mov	r0, #172	; 0xac
8f61cd60:	ebffc938 	bl	8f60f248 <unmask_interrupt>
	dwc_ep_ctrl_state_setup_enter(dev);
8f61cd64:	e59f307c 	ldr	r3, [pc, #124]	; 8f61cde8 <dwc_device_init+0x21c>
8f61cd68:	e5932000 	ldr	r2, [r3]
8f61cd6c:	e59d300c 	ldr	r3, [r13, #12]
8f61cd70:	e0332002 	eors	r2, r3, r2
8f61cd74:	e3a03000 	mov	r3, #0
8f61cd78:	1a000019 	bne	8f61cde4 <dwc_device_init+0x218>
8f61cd7c:	e1a00004 	mov	r0, r4
}
8f61cd80:	e28dd014 	add	r13, r13, #20
8f61cd84:	e8bd40f0 	pop	{r4, r5, r6, r7, r14}
	dwc_ep_ctrl_state_setup_enter(dev);
8f61cd88:	eafff950 	b	8f61b2d0 <dwc_ep_ctrl_state_setup_enter>
	ASSERT(dev->ep[index].trb);
8f61cd8c:	e30700ac 	movw	r0, #28844	; 0x70ac
8f61cd90:	e306253c 	movw	r2, #25916	; 0x653c
8f61cd94:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61cd98:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61cd9c:	e58d0000 	str	r0, [r13]
8f61cda0:	e3001130 	movw	r1, #304	; 0x130
8f61cda4:	e30035d2 	movw	r3, #1490	; 0x5d2
8f61cda8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61cdac:	e1a00005 	mov	r0, r5
8f61cdb0:	eb005741 	bl	8f632abc <_panic>
8f61cdb4:	eaffffb0 	b	8f61cc7c <dwc_device_init+0xb0>
	ASSERT(dev->ep[index].trb);
8f61cdb8:	e307c0ac 	movw	r12, #28844	; 0x70ac
8f61cdbc:	e306253c 	movw	r2, #25916	; 0x653c
8f61cdc0:	e348cf70 	movt	r12, #36720	; 0x8f70
8f61cdc4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61cdc8:	e3001130 	movw	r1, #304	; 0x130
8f61cdcc:	e30035e6 	movw	r3, #1510	; 0x5e6
8f61cdd0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61cdd4:	e1a00005 	mov	r0, r5
8f61cdd8:	e58dc000 	str	r12, [r13]
8f61cddc:	eb005736 	bl	8f632abc <_panic>
8f61cde0:	eaffffc1 	b	8f61ccec <dwc_device_init+0x120>
	dwc_ep_ctrl_state_setup_enter(dev);
8f61cde4:	eb005775 	bl	8f632bc0 <__stack_chk_fail>
8f61cde8:	8f74221c 	.word	0x8f74221c

8f61cdec <dwc_device_add_ep>:
{
8f61cdec:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f61cdf0:	e24dd010 	sub	r13, r13, #16
	uint8_t index = DWC_EP_INDEX(new_ep->number, new_ep->dir);
8f61cdf4:	e5d13000 	ldrb	r3, [r1]
{
8f61cdf8:	e1a04001 	mov	r4, r1
	uint8_t index = DWC_EP_INDEX(new_ep->number, new_ep->dir);
8f61cdfc:	e5d16001 	ldrb	r6, [r1, #1]
8f61ce00:	e1a0800e 	mov	r8, r14
{
8f61ce04:	e59f21a0 	ldr	r2, [pc, #416]	; 8f61cfac <dwc_device_add_ep+0x1c0>
8f61ce08:	e1a07000 	mov	r7, r0
	uint8_t index = DWC_EP_INDEX(new_ep->number, new_ep->dir);
8f61ce0c:	e1866083 	orr	r6, r6, r3, lsl #1
{
8f61ce10:	e5922000 	ldr	r2, [r2]
8f61ce14:	e58d200c 	str	r2, [r13, #12]
8f61ce18:	e3a02000 	mov	r2, #0
	uint8_t index = DWC_EP_INDEX(new_ep->number, new_ep->dir);
8f61ce1c:	e6ef6076 	uxtb	r6, r6
	ASSERT(index < DWC_MAX_NUM_OF_EP);
8f61ce20:	e3560007 	cmp	r6, #7
8f61ce24:	8a00003a 	bhi	8f61cf14 <dwc_device_add_ep+0x128>
	dwc_ep_t *ep = &dev->ep[index];
8f61ce28:	e3a00f8e 	mov	r0, #568	; 0x238
8f61ce2c:	e0207690 	mla	r0, r0, r6, r7
	ASSERT(ep != NULL);
8f61ce30:	e2905008 	adds	r5, r0, #8
8f61ce34:	0a000044 	beq	8f61cf4c <dwc_device_add_ep+0x160>
	memset(ep, 0, sizeof(ep));
8f61ce38:	e1a00005 	mov	r0, r5
	ep->number        = new_ep->number;
8f61ce3c:	e3a05f8e 	mov	r5, #568	; 0x238
8f61ce40:	e0257695 	mla	r5, r5, r6, r7
	memset(ep, 0, sizeof(ep));
8f61ce44:	e3a02004 	mov	r2, #4
8f61ce48:	e3a01000 	mov	r1, #0
8f61ce4c:	eb005d1c 	bl	8f6342c4 <memset>
	ep->number        = new_ep->number;
8f61ce50:	e5d43000 	ldrb	r3, [r4]
8f61ce54:	e5c53008 	strb	r3, [r5, #8]
	ep->dir           = new_ep->dir;
8f61ce58:	e5d43001 	ldrb	r3, [r4, #1]
8f61ce5c:	e5c53009 	strb	r3, [r5, #9]
	ep->type          = new_ep->type;
8f61ce60:	e5d43002 	ldrb	r3, [r4, #2]
8f61ce64:	e5c5300a 	strb	r3, [r5, #10]
	ep->max_pkt_size  = new_ep->max_pkt_size;
8f61ce68:	e1d430b4 	ldrh	r3, [r4, #4]
8f61ce6c:	e1c530bc 	strh	r3, [r5, #12]
	ep->burst_size    = new_ep->burst_size;
8f61ce70:	e5943008 	ldr	r3, [r4, #8]
8f61ce74:	e5853010 	str	r3, [r5, #16]
	ep->zlp           = new_ep->zlp;
8f61ce78:	e5d43006 	ldrb	r3, [r4, #6]
8f61ce7c:	e5c5300e 	strb	r3, [r5, #14]
	ep->trb_count     = new_ep->trb_count;
8f61ce80:	e5943214 	ldr	r3, [r4, #532]	; 0x214
8f61ce84:	e585321c 	str	r3, [r5, #540]	; 0x21c
	ep->trb           = new_ep->trb;
8f61ce88:	e5940210 	ldr	r0, [r4, #528]	; 0x210
	ASSERT(ep->trb);
8f61ce8c:	e3500000 	cmp	r0, #0
	ep->trb           = new_ep->trb;
8f61ce90:	e5850218 	str	r0, [r5, #536]	; 0x218
	ASSERT(ep->trb);
8f61ce94:	0a000037 	beq	8f61cf78 <dwc_device_add_ep+0x18c>
	memset(ep->trb, 0, (ep->trb_count)*sizeof(ep->trb));
8f61ce98:	e3a05f8e 	mov	r5, #568	; 0x238
8f61ce9c:	e3a01000 	mov	r1, #0
8f61cea0:	e0247695 	mla	r4, r5, r6, r7
	ep->state         = EP_STATE_INIT;
8f61cea4:	e0255596 	mla	r5, r6, r5, r5
	memset(ep->trb, 0, (ep->trb_count)*sizeof(ep->trb));
8f61cea8:	e594221c 	ldr	r2, [r4, #540]	; 0x21c
	ep->state         = EP_STATE_INIT;
8f61ceac:	e0877005 	add	r7, r7, r5
	memset(ep->trb, 0, (ep->trb_count)*sizeof(ep->trb));
8f61ceb0:	e1a02102 	lsl	r2, r2, #2
8f61ceb4:	eb005d02 	bl	8f6342c4 <memset>
	arch_clean_invalidate_cache_range((addr_t) ep->trb,
8f61ceb8:	e594121c 	ldr	r1, [r4, #540]	; 0x21c
8f61cebc:	e5940218 	ldr	r0, [r4, #536]	; 0x218
8f61cec0:	e1a01101 	lsl	r1, r1, #2
8f61cec4:	eb001035 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	if (ep->dir == DWC_EP_DIRECTION_IN)
8f61cec8:	e5d43009 	ldrb	r3, [r4, #9]
	ep->phy_num = index;
8f61cecc:	e5c46014 	strb	r6, [r4, #20]
	if (ep->dir == DWC_EP_DIRECTION_IN)
8f61ced0:	e2433001 	sub	r3, r3, #1
8f61ced4:	e16f3f13 	clz	r3, r3
8f61ced8:	e1a032a3 	lsr	r3, r3, #5
8f61cedc:	e5c43015 	strb	r3, [r4, #21]
	ep->trb_queued    = 0;
8f61cee0:	e3a03000 	mov	r3, #0
8f61cee4:	e5843220 	str	r3, [r4, #544]	; 0x220
	ep->bytes_queued  = 0;
8f61cee8:	e5843224 	str	r3, [r4, #548]	; 0x224
	ep->resource_idx  = 0;
8f61ceec:	e5c43216 	strb	r3, [r4, #534]	; 0x216
	ep->state         = EP_STATE_INIT;
8f61cef0:	e5c73004 	strb	r3, [r7, #4]
}
8f61cef4:	e59f30b0 	ldr	r3, [pc, #176]	; 8f61cfac <dwc_device_add_ep+0x1c0>
8f61cef8:	e5932000 	ldr	r2, [r3]
8f61cefc:	e59d300c 	ldr	r3, [r13, #12]
8f61cf00:	e0332002 	eors	r2, r3, r2
8f61cf04:	e3a03000 	mov	r3, #0
8f61cf08:	1a000026 	bne	8f61cfa8 <dwc_device_add_ep+0x1bc>
8f61cf0c:	e28dd010 	add	r13, r13, #16
8f61cf10:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
	ASSERT(index < DWC_MAX_NUM_OF_EP);
8f61cf14:	e1a0000e 	mov	r0, r14
8f61cf18:	e3063efc 	movw	r3, #28412	; 0x6efc
8f61cf1c:	e306253c 	movw	r2, #25916	; 0x653c
8f61cf20:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61cf24:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61cf28:	e58d3000 	str	r3, [r13]
8f61cf2c:	e3001130 	movw	r1, #304	; 0x130
8f61cf30:	e300365d 	movw	r3, #1629	; 0x65d
8f61cf34:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61cf38:	eb0056df 	bl	8f632abc <_panic>
	dwc_ep_t *ep = &dev->ep[index];
8f61cf3c:	e3a00f8e 	mov	r0, #568	; 0x238
8f61cf40:	e0207690 	mla	r0, r0, r6, r7
	ASSERT(ep != NULL);
8f61cf44:	e2905008 	adds	r5, r0, #8
8f61cf48:	1affffba 	bne	8f61ce38 <dwc_device_add_ep+0x4c>
8f61cf4c:	e3063590 	movw	r3, #26000	; 0x6590
8f61cf50:	e306253c 	movw	r2, #25916	; 0x653c
8f61cf54:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61cf58:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61cf5c:	e58d3000 	str	r3, [r13]
8f61cf60:	e3001130 	movw	r1, #304	; 0x130
8f61cf64:	e300365f 	movw	r3, #1631	; 0x65f
8f61cf68:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61cf6c:	e1a00008 	mov	r0, r8
8f61cf70:	eb0056d1 	bl	8f632abc <_panic>
8f61cf74:	eaffffaf 	b	8f61ce38 <dwc_device_add_ep+0x4c>
	ASSERT(ep->trb);
8f61cf78:	e1a00008 	mov	r0, r8
8f61cf7c:	e30730c0 	movw	r3, #28864	; 0x70c0
8f61cf80:	e306253c 	movw	r2, #25916	; 0x653c
8f61cf84:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61cf88:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61cf8c:	e58d3000 	str	r3, [r13]
8f61cf90:	e3001130 	movw	r1, #304	; 0x130
8f61cf94:	e300366e 	movw	r3, #1646	; 0x66e
8f61cf98:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61cf9c:	eb0056c6 	bl	8f632abc <_panic>
	memset(ep->trb, 0, (ep->trb_count)*sizeof(ep->trb));
8f61cfa0:	e5950218 	ldr	r0, [r5, #536]	; 0x218
8f61cfa4:	eaffffbb 	b	8f61ce98 <dwc_device_add_ep+0xac>
}
8f61cfa8:	eb005704 	bl	8f632bc0 <__stack_chk_fail>
8f61cfac:	8f74221c 	.word	0x8f74221c

8f61cfb0 <dwc_device_set_configuration>:
{
8f61cfb0:	e59f30c8 	ldr	r3, [pc, #200]	; 8f61d080 <dwc_device_set_configuration+0xd0>
8f61cfb4:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f61cfb8:	e1a07000 	mov	r7, r0
8f61cfbc:	e24dd00c 	sub	r13, r13, #12
8f61cfc0:	e2878ed5 	add	r8, r7, #3408	; 0xd50
8f61cfc4:	e5933000 	ldr	r3, [r3]
8f61cfc8:	e58d3004 	str	r3, [r13, #4]
8f61cfcc:	e3a03000 	mov	r3, #0
	dwc_ep_disable_non_control(dev);
8f61cfd0:	eb0003cb 	bl	8f61df04 <dwc_ep_disable_non_control>
	dwc_ep_cmd_set_config(dev, 1, SET_CONFIG_ACTION_MODIFY);
8f61cfd4:	e3a02002 	mov	r2, #2
8f61cfd8:	e3a01001 	mov	r1, #1
8f61cfdc:	e1a00007 	mov	r0, r7
8f61cfe0:	e1a04007 	mov	r4, r7
8f61cfe4:	eb000106 	bl	8f61d404 <dwc_ep_cmd_set_config>
	dwc_ep_cmd_start_new_config(dev, 0, 2);
8f61cfe8:	e3a02002 	mov	r2, #2
8f61cfec:	e3a01000 	mov	r1, #0
8f61cff0:	e1a00007 	mov	r0, r7
8f61cff4:	eb00015e 	bl	8f61d574 <dwc_ep_cmd_start_new_config>
8f61cff8:	e3a05002 	mov	r5, #2
	dev->ep[index].state = EP_STATE_INACTIVE;
8f61cffc:	e3a09001 	mov	r9, #1
8f61d000:	ea000003 	b	8f61d014 <dwc_device_set_configuration+0x64>
	for (uint8_t ep_index = 2; ep_index < DWC_MAX_NUM_OF_EP; ep_index++)
8f61d004:	e2844f8e 	add	r4, r4, #568	; 0x238
8f61d008:	e2855001 	add	r5, r5, #1
8f61d00c:	e1580004 	cmp	r8, r4
8f61d010:	0a000011 	beq	8f61d05c <dwc_device_set_configuration+0xac>
		if (dev->ep[ep_index].phy_num)
8f61d014:	e5d46484 	ldrb	r6, [r4, #1156]	; 0x484
8f61d018:	e6ef1075 	uxtb	r1, r5
8f61d01c:	e3560000 	cmp	r6, #0
8f61d020:	0afffff7 	beq	8f61d004 <dwc_device_set_configuration+0x54>
	dwc_ep_cmd_set_config(dev, index, SET_CONFIG_ACTION_INIT);
8f61d024:	e3a02000 	mov	r2, #0
8f61d028:	e1a00007 	mov	r0, r7
8f61d02c:	eb0000f4 	bl	8f61d404 <dwc_ep_cmd_set_config>
	dev->ep[index].state = EP_STATE_INACTIVE;
8f61d030:	e5c496ac 	strb	r9, [r4, #1708]	; 0x6ac
	dwc_ep_cmd_set_transfer_resource(dev, ep_phy_num);
8f61d034:	e1a01006 	mov	r1, r6
8f61d038:	e1a00007 	mov	r0, r7
8f61d03c:	eb0000d7 	bl	8f61d3a0 <dwc_ep_cmd_set_transfer_resource>
	for (uint8_t ep_index = 2; ep_index < DWC_MAX_NUM_OF_EP; ep_index++)
8f61d040:	e2844f8e 	add	r4, r4, #568	; 0x238
	dwc_ep_enable(dev, ep_phy_num);
8f61d044:	e1a01006 	mov	r1, r6
8f61d048:	e1a00007 	mov	r0, r7
8f61d04c:	eb0003c1 	bl	8f61df58 <dwc_ep_enable>
	for (uint8_t ep_index = 2; ep_index < DWC_MAX_NUM_OF_EP; ep_index++)
8f61d050:	e1580004 	cmp	r8, r4
8f61d054:	e2855001 	add	r5, r5, #1
8f61d058:	1affffed 	bne	8f61d014 <dwc_device_set_configuration+0x64>
}
8f61d05c:	e59f301c 	ldr	r3, [pc, #28]	; 8f61d080 <dwc_device_set_configuration+0xd0>
8f61d060:	e5932000 	ldr	r2, [r3]
8f61d064:	e59d3004 	ldr	r3, [r13, #4]
8f61d068:	e0332002 	eors	r2, r3, r2
8f61d06c:	e3a03000 	mov	r3, #0
8f61d070:	1a000001 	bne	8f61d07c <dwc_device_set_configuration+0xcc>
8f61d074:	e28dd00c 	add	r13, r13, #12
8f61d078:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
8f61d07c:	eb0056cf 	bl	8f632bc0 <__stack_chk_fail>
8f61d080:	8f74221c 	.word	0x8f74221c

8f61d084 <dwc_transfer_request>:
						 dwc_ep_direction_t       dir,
						 void                    *buf,
						 uint32_t                 len,
						 dwc_transfer_callback_t  callback,
						 void                    *callback_context)
{
8f61d084:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61d088:	e24dd01c 	sub	r13, r13, #28
		/* control EP always has CONTROL_DATA trb */
		req.trbctl = TRBCTL_CONTROL_DATA;
	}
	else
	{
		req.trbctl = TRBCTL_NORMAL;
8f61d08c:	e3510000 	cmp	r1, #0
{
8f61d090:	e59dc020 	ldr	r12, [r13, #32]
	req.data     = buf;
8f61d094:	e58d3000 	str	r3, [r13]
{
8f61d098:	e59f305c 	ldr	r3, [pc, #92]	; 8f61d0fc <dwc_transfer_request+0x78>
	req.len      = len;
8f61d09c:	e58dc004 	str	r12, [r13, #4]
	ep_phy_num = DWC_EP_PHY_NUM(usb_ep, dir);
8f61d0a0:	e182c081 	orr	r12, r2, r1, lsl #1
{
8f61d0a4:	e5933000 	ldr	r3, [r3]
8f61d0a8:	e58d3014 	str	r3, [r13, #20]
8f61d0ac:	e3a03000 	mov	r3, #0
8f61d0b0:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
	}

	return dwc_request_queue(dwc, ep_phy_num, &req);
8f61d0b4:	e6ef107c 	uxtb	r1, r12
8f61d0b8:	e1a0200d 	mov	r2, r13
		req.trbctl = TRBCTL_NORMAL;
8f61d0bc:	03a0c005 	moveq	r12, #5
8f61d0c0:	13a0c001 	movne	r12, #1
	req.callback = callback;
8f61d0c4:	e58d3010 	str	r3, [r13, #16]
{
8f61d0c8:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f61d0cc:	e5cdc008 	strb	r12, [r13, #8]
	req.context  = callback_context;
8f61d0d0:	e58d300c 	str	r3, [r13, #12]
	return dwc_request_queue(dwc, ep_phy_num, &req);
8f61d0d4:	ebfff72b 	bl	8f61ad88 <dwc_request_queue>
}
8f61d0d8:	e59f301c 	ldr	r3, [pc, #28]	; 8f61d0fc <dwc_transfer_request+0x78>
8f61d0dc:	e5932000 	ldr	r2, [r3]
8f61d0e0:	e59d3014 	ldr	r3, [r13, #20]
8f61d0e4:	e0332002 	eors	r2, r3, r2
8f61d0e8:	e3a03000 	mov	r3, #0
8f61d0ec:	1a000001 	bne	8f61d0f8 <dwc_transfer_request+0x74>
8f61d0f0:	e28dd01c 	add	r13, r13, #28
8f61d0f4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61d0f8:	eb0056b0 	bl	8f632bc0 <__stack_chk_fail>
8f61d0fc:	8f74221c 	.word	0x8f74221c

8f61d100 <dwc_ep_cmd.constprop.0>:
 * does not maintain any soft states. It programs the h/w as requested by the
 * APIs.
 */

/* generic api to send endpoint command */
static void dwc_ep_cmd(dwc_dev_t *dev, uint8_t ep_phy_num, dwc_ep_cmd_t *ep_cmd)
8f61d100:	e59f3130 	ldr	r3, [pc, #304]	; 8f61d238 <dwc_ep_cmd.constprop.0+0x138>
{
	if(REG_READ_FIELDI(dev, GUSB2PHYCFG, 0, SUSPENDUSB20))
8f61d104:	e590c000 	ldr	r12, [r0]
static void dwc_ep_cmd(dwc_dev_t *dev, uint8_t ep_phy_num, dwc_ep_cmd_t *ep_cmd)
8f61d108:	e92d4070 	push	{r4, r5, r6, r14}
8f61d10c:	e24dd010 	sub	r13, r13, #16
8f61d110:	e5933000 	ldr	r3, [r3]
8f61d114:	e58d300c 	str	r3, [r13, #12]
8f61d118:	e3a03000 	mov	r3, #0
8f61d11c:	e1a05002 	mov	r5, r2
	if(REG_READ_FIELDI(dev, GUSB2PHYCFG, 0, SUSPENDUSB20))
8f61d120:	e28c2903 	add	r2, r12, #49152	; 0xc000
static void dwc_ep_cmd(dwc_dev_t *dev, uint8_t ep_phy_num, dwc_ep_cmd_t *ep_cmd)
8f61d124:	e1a04001 	mov	r4, r1
	if(REG_READ_FIELDI(dev, GUSB2PHYCFG, 0, SUSPENDUSB20))
8f61d128:	e5923200 	ldr	r3, [r2, #512]	; 0x200
8f61d12c:	e3130040 	tst	r3, #64	; 0x40
8f61d130:	1a000031 	bne	8f61d1fc <dwc_ep_cmd.constprop.0+0xfc>
		/* this must be 0. see snps 6.3.2.5.8 */
		ASSERT(0);
	}

	/* wait until previous command is in-active */
	while( REG_READ_FIELDI(dev, DEPCMD, ep_phy_num, CMDACT) == 1);
8f61d134:	e3a03010 	mov	r3, #16
8f61d138:	e021c493 	mla	r1, r3, r4, r12
8f61d13c:	e1600384 	smulbb	r0, r4, r3
8f61d140:	e2811b32 	add	r1, r1, #51200	; 0xc800
8f61d144:	e281100c 	add	r1, r1, #12
8f61d148:	e5913000 	ldr	r3, [r1]
8f61d14c:	e2133b01 	ands	r3, r3, #1024	; 0x400
8f61d150:	1afffffc 	bne	8f61d148 <dwc_ep_cmd.constprop.0+0x48>

	/* clear cmd reg */
	REG_WRITEI(dev, DEPCMD, ep_phy_num, 0);
8f61d154:	e5813000 	str	r3, [r1]

	/* write the command parameters */
	REG_WRITEI(dev, DEPCMDPAR2, ep_phy_num, ep_cmd->param2);
8f61d158:	e2803b32 	add	r3, r0, #51200	; 0xc800
8f61d15c:	e595e008 	ldr	r14, [r5, #8]
8f61d160:	e78ce003 	str	r14, [r12, r3]
	REG_WRITEI(dev, DEPCMDPAR1, ep_phy_num, ep_cmd->param1);
8f61d164:	e283e004 	add	r14, r3, #4
8f61d168:	e595000c 	ldr	r0, [r5, #12]
	REG_WRITEI(dev, DEPCMDPAR0, ep_phy_num, ep_cmd->param0);
8f61d16c:	e2833008 	add	r3, r3, #8
	REG_WRITEI(dev, DEPCMDPAR1, ep_phy_num, ep_cmd->param1);
8f61d170:	e78c000e 	str	r0, [r12, r14]
	REG_WRITEI(dev, DEPCMDPAR0, ep_phy_num, ep_cmd->param0);
8f61d174:	e5950010 	ldr	r0, [r5, #16]
8f61d178:	e78c0003 	str	r0, [r12, r3]

	/* command */
	REG_WRITE_FIELDI(dev, DEPCMD, ep_phy_num, CMDTYP, ep_cmd->cmd);
8f61d17c:	e5913000 	ldr	r3, [r1]
8f61d180:	e5950000 	ldr	r0, [r5]
8f61d184:	e3c3300f 	bic	r3, r3, #15
8f61d188:	e1833000 	orr	r3, r3, r0
8f61d18c:	e5813000 	str	r3, [r1]

	if ((ep_cmd->cmd == DEPCMD_CMD_UPDATE_TRANSFER) ||
		(ep_cmd->cmd == DEPCMD_CMD_END_TRANSFER) ||
8f61d190:	e5953000 	ldr	r3, [r5]
8f61d194:	e2433007 	sub	r3, r3, #7
	if ((ep_cmd->cmd == DEPCMD_CMD_UPDATE_TRANSFER) ||
8f61d198:	e3530002 	cmp	r3, #2
		(ep_cmd->cmd == DEPCMD_CMD_START_NEW_CONF))
	{
		/* set the transfer resource index */
		REG_WRITE_FIELDI(dev,
8f61d19c:	95913000 	ldrls	r3, [r1]
8f61d1a0:	95d50004 	ldrbls	r0, [r5, #4]
8f61d1a4:	96ff3073 	uxthls	r3, r3
8f61d1a8:	91833800 	orrls	r3, r3, r0, lsl #16
8f61d1ac:	95813000 	strls	r3, [r1]
}

/* is device running? */
uint8_t dwc_device_run_status(dwc_dev_t *dev)
{
	return REG_READ_FIELD(dev, DCTL, RUN_STOP);
8f61d1b0:	e5923704 	ldr	r3, [r2, #1796]	; 0x704
	if(dwc_device_run_status(dev))
8f61d1b4:	e3530000 	cmp	r3, #0
			REG_WRITE_FIELDI(dev, DEPCMD, ep_phy_num, CMDIOC, 1);
8f61d1b8:	b5913000 	ldrlt	r3, [r1]
8f61d1bc:	b3833c01 	orrlt	r3, r3, #256	; 0x100
8f61d1c0:	b5813000 	strlt	r3, [r1]
	REG_WRITE_FIELDI(dev, DEPCMD, ep_phy_num, CMDACT, 1);
8f61d1c4:	e5913000 	ldr	r3, [r1]
8f61d1c8:	e3833b01 	orr	r3, r3, #1024	; 0x400
8f61d1cc:	e5813000 	str	r3, [r1]
	while( REG_READ_FIELDI(dev, DEPCMD, ep_phy_num, CMDACT) == 1);
8f61d1d0:	e5913000 	ldr	r3, [r1]
8f61d1d4:	e3130b01 	tst	r3, #1024	; 0x400
8f61d1d8:	1afffffc 	bne	8f61d1d0 <dwc_ep_cmd.constprop.0+0xd0>
}
8f61d1dc:	e59f3054 	ldr	r3, [pc, #84]	; 8f61d238 <dwc_ep_cmd.constprop.0+0x138>
8f61d1e0:	e5932000 	ldr	r2, [r3]
8f61d1e4:	e59d300c 	ldr	r3, [r13, #12]
8f61d1e8:	e0332002 	eors	r2, r3, r2
8f61d1ec:	e3a03000 	mov	r3, #0
8f61d1f0:	1a00000f 	bne	8f61d234 <dwc_ep_cmd.constprop.0+0x134>
8f61d1f4:	e28dd010 	add	r13, r13, #16
8f61d1f8:	e8bd8070 	pop	{r4, r5, r6, r15}
8f61d1fc:	e1a06000 	mov	r6, r0
		ASSERT(0);
8f61d200:	e3073f64 	movw	r3, #32612	; 0x7f64
8f61d204:	e1a0000e 	mov	r0, r14
8f61d208:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61d20c:	e30720dc 	movw	r2, #28892	; 0x70dc
8f61d210:	e58d3000 	str	r3, [r13]
8f61d214:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61d218:	e3a03051 	mov	r3, #81	; 0x51
8f61d21c:	e3001130 	movw	r1, #304	; 0x130
8f61d220:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61d224:	eb005624 	bl	8f632abc <_panic>
	while( REG_READ_FIELDI(dev, DEPCMD, ep_phy_num, CMDACT) == 1);
8f61d228:	e596c000 	ldr	r12, [r6]
8f61d22c:	e28c2903 	add	r2, r12, #49152	; 0xc000
8f61d230:	eaffffbf 	b	8f61d134 <dwc_ep_cmd.constprop.0+0x34>
}
8f61d234:	eb005661 	bl	8f632bc0 <__stack_chk_fail>
8f61d238:	8f74221c 	.word	0x8f74221c

8f61d23c <platform_is_8974>:
{
8f61d23c:	e59f3038 	ldr	r3, [pc, #56]	; 8f61d27c <platform_is_8974+0x40>
8f61d240:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61d244:	e24dd00c 	sub	r13, r13, #12
8f61d248:	e5933000 	ldr	r3, [r3]
8f61d24c:	e58d3004 	str	r3, [r13, #4]
8f61d250:	e3a03000 	mov	r3, #0
}
8f61d254:	e59f3020 	ldr	r3, [pc, #32]	; 8f61d27c <platform_is_8974+0x40>
8f61d258:	e5932000 	ldr	r2, [r3]
8f61d25c:	e59d3004 	ldr	r3, [r13, #4]
8f61d260:	e0332002 	eors	r2, r3, r2
8f61d264:	e3a03000 	mov	r3, #0
8f61d268:	1a000002 	bne	8f61d278 <platform_is_8974+0x3c>
8f61d26c:	e3a00000 	mov	r0, #0
8f61d270:	e28dd00c 	add	r13, r13, #12
8f61d274:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61d278:	eb005650 	bl	8f632bc0 <__stack_chk_fail>
8f61d27c:	8f74221c 	.word	0x8f74221c

8f61d280 <dwc_ep_cmd_start_transfer>:
	uint32_t td_addr_low  = (uint32_t) ep->trb;
8f61d280:	e3a03f8e 	mov	r3, #568	; 0x238
{
8f61d284:	e59f20a0 	ldr	r2, [pc, #160]	; 8f61d32c <dwc_ep_cmd_start_transfer+0xac>
	uint32_t td_addr_low  = (uint32_t) ep->trb;
8f61d288:	e0230193 	mla	r3, r3, r1, r0
{
8f61d28c:	e92d4070 	push	{r4, r5, r6, r14}
8f61d290:	e24dd020 	sub	r13, r13, #32
8f61d294:	e5922000 	ldr	r2, [r2]
8f61d298:	e58d201c 	str	r2, [r13, #28]
8f61d29c:	e3a02000 	mov	r2, #0
8f61d2a0:	e1a04000 	mov	r4, r0
8f61d2a4:	e1a05001 	mov	r5, r1
	uint32_t td_addr_low  = (uint32_t) ep->trb;
8f61d2a8:	e5936218 	ldr	r6, [r3, #536]	; 0x218
	ASSERT((td_addr_low  & 0xF) == 0);
8f61d2ac:	e316000f 	tst	r6, #15
8f61d2b0:	1a000011 	bne	8f61d2fc <dwc_ep_cmd_start_transfer+0x7c>
	dwc_ep_cmd(dev, ep_phy_num, &ep_cmd);
8f61d2b4:	e28d2008 	add	r2, r13, #8
8f61d2b8:	e1a01005 	mov	r1, r5
8f61d2bc:	e1a00004 	mov	r0, r4
	ep_cmd.param2 = 0;
8f61d2c0:	e3a03000 	mov	r3, #0
	ep_cmd.cmd = DEPCMD_CMD_START_TRANSFER;
8f61d2c4:	e3a0c006 	mov	r12, #6
	ep_cmd.param2 = 0;
8f61d2c8:	e58d3010 	str	r3, [r13, #16]
	ep_cmd.param0 = td_addr_high;
8f61d2cc:	e58d3018 	str	r3, [r13, #24]
	ep_cmd.param1 = td_addr_low;
8f61d2d0:	e58d6014 	str	r6, [r13, #20]
	ep_cmd.cmd = DEPCMD_CMD_START_TRANSFER;
8f61d2d4:	e58dc008 	str	r12, [r13, #8]
	dwc_ep_cmd(dev, ep_phy_num, &ep_cmd);
8f61d2d8:	ebffff88 	bl	8f61d100 <dwc_ep_cmd.constprop.0>
}
8f61d2dc:	e59f3048 	ldr	r3, [pc, #72]	; 8f61d32c <dwc_ep_cmd_start_transfer+0xac>
8f61d2e0:	e5932000 	ldr	r2, [r3]
8f61d2e4:	e59d301c 	ldr	r3, [r13, #28]
8f61d2e8:	e0332002 	eors	r2, r3, r2
8f61d2ec:	e3a03000 	mov	r3, #0
8f61d2f0:	1a00000c 	bne	8f61d328 <dwc_ep_cmd_start_transfer+0xa8>
8f61d2f4:	e28dd020 	add	r13, r13, #32
8f61d2f8:	e8bd8070 	pop	{r4, r5, r6, r15}
	ASSERT((td_addr_low  & 0xF) == 0);
8f61d2fc:	e3073100 	movw	r3, #28928	; 0x7100
8f61d300:	e1a0000e 	mov	r0, r14
8f61d304:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61d308:	e30720dc 	movw	r2, #28892	; 0x70dc
8f61d30c:	e58d3000 	str	r3, [r13]
8f61d310:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61d314:	e3a03093 	mov	r3, #147	; 0x93
8f61d318:	e3001130 	movw	r1, #304	; 0x130
8f61d31c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61d320:	eb0055e5 	bl	8f632abc <_panic>
8f61d324:	eaffffe2 	b	8f61d2b4 <dwc_ep_cmd_start_transfer+0x34>
}
8f61d328:	eb005624 	bl	8f632bc0 <__stack_chk_fail>
8f61d32c:	8f74221c 	.word	0x8f74221c

8f61d330 <dwc_ep_cmd_end_transfer>:
{
8f61d330:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61d334:	e24dd01c 	sub	r13, r13, #28
8f61d338:	e59f205c 	ldr	r2, [pc, #92]	; 8f61d39c <dwc_ep_cmd_end_transfer+0x6c>
	ep_cmd.cmd                 = DEPCMD_CMD_END_TRANSFER;
8f61d33c:	e3a03008 	mov	r3, #8
	ep_cmd.param2 = 0;
8f61d340:	e3a0c000 	mov	r12, #0
{
8f61d344:	e5922000 	ldr	r2, [r2]
8f61d348:	e58d2014 	str	r2, [r13, #20]
8f61d34c:	e3a02000 	mov	r2, #0
	ep_cmd.cmd                 = DEPCMD_CMD_END_TRANSFER;
8f61d350:	e58d3000 	str	r3, [r13]
	ep_cmd.xfer_resource_index = ep->resource_idx;
8f61d354:	e3a03f8e 	mov	r3, #568	; 0x238
	dwc_ep_cmd(dev, ep_phy_num, &ep_cmd);
8f61d358:	e1a0200d 	mov	r2, r13
	ep_cmd.xfer_resource_index = ep->resource_idx;
8f61d35c:	e0230193 	mla	r3, r3, r1, r0
	ep_cmd.param2 = 0;
8f61d360:	e58dc008 	str	r12, [r13, #8]
	ep_cmd.param1 = 0;
8f61d364:	e58dc00c 	str	r12, [r13, #12]
	ep_cmd.param0 = 0;
8f61d368:	e58dc010 	str	r12, [r13, #16]
	ep_cmd.xfer_resource_index = ep->resource_idx;
8f61d36c:	e5d33216 	ldrb	r3, [r3, #534]	; 0x216
8f61d370:	e5cd3004 	strb	r3, [r13, #4]
	dwc_ep_cmd(dev, ep_phy_num, &ep_cmd);
8f61d374:	ebffff61 	bl	8f61d100 <dwc_ep_cmd.constprop.0>
}
8f61d378:	e59f301c 	ldr	r3, [pc, #28]	; 8f61d39c <dwc_ep_cmd_end_transfer+0x6c>
8f61d37c:	e5932000 	ldr	r2, [r3]
8f61d380:	e59d3014 	ldr	r3, [r13, #20]
8f61d384:	e0332002 	eors	r2, r3, r2
8f61d388:	e3a03000 	mov	r3, #0
8f61d38c:	1a000001 	bne	8f61d398 <dwc_ep_cmd_end_transfer+0x68>
8f61d390:	e28dd01c 	add	r13, r13, #28
8f61d394:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61d398:	eb005608 	bl	8f632bc0 <__stack_chk_fail>
8f61d39c:	8f74221c 	.word	0x8f74221c

8f61d3a0 <dwc_ep_cmd_set_transfer_resource>:
{
8f61d3a0:	e92d4010 	push	{r4, r14}
8f61d3a4:	e24dd018 	sub	r13, r13, #24
8f61d3a8:	e59fe050 	ldr	r14, [pc, #80]	; 8f61d400 <dwc_ep_cmd_set_transfer_resource+0x60>
	ep_cmd.param2 = 0;
8f61d3ac:	e3a03000 	mov	r3, #0
	dwc_ep_cmd(dev, ep_phy_num, &ep_cmd);
8f61d3b0:	e1a0200d 	mov	r2, r13
	ep_cmd.cmd = DEPCMD_CMD_SET_TR_CONF;
8f61d3b4:	e3a0c002 	mov	r12, #2
{
8f61d3b8:	e59ee000 	ldr	r14, [r14]
8f61d3bc:	e58de014 	str	r14, [r13, #20]
8f61d3c0:	e3a0e000 	mov	r14, #0
	ep_cmd.cmd = DEPCMD_CMD_SET_TR_CONF;
8f61d3c4:	e58dc000 	str	r12, [r13]
	ep_cmd.param2 = 0;
8f61d3c8:	e58d3008 	str	r3, [r13, #8]
	ep_cmd.param0 = 1; /* number of transfer resources: always set to 1 */
8f61d3cc:	e3a0c001 	mov	r12, #1
	ep_cmd.param1 = 0;
8f61d3d0:	e58d300c 	str	r3, [r13, #12]
	ep_cmd.param0 = 1; /* number of transfer resources: always set to 1 */
8f61d3d4:	e58dc010 	str	r12, [r13, #16]
	dwc_ep_cmd(dev, ep_phy_num, &ep_cmd);
8f61d3d8:	ebffff48 	bl	8f61d100 <dwc_ep_cmd.constprop.0>
}
8f61d3dc:	e59f301c 	ldr	r3, [pc, #28]	; 8f61d400 <dwc_ep_cmd_set_transfer_resource+0x60>
8f61d3e0:	e5932000 	ldr	r2, [r3]
8f61d3e4:	e59d3014 	ldr	r3, [r13, #20]
8f61d3e8:	e0332002 	eors	r2, r3, r2
8f61d3ec:	e3a03000 	mov	r3, #0
8f61d3f0:	1a000001 	bne	8f61d3fc <dwc_ep_cmd_set_transfer_resource+0x5c>
8f61d3f4:	e28dd018 	add	r13, r13, #24
8f61d3f8:	e8bd8010 	pop	{r4, r15}
8f61d3fc:	eb0055ef 	bl	8f632bc0 <__stack_chk_fail>
8f61d400:	8f74221c 	.word	0x8f74221c

8f61d404 <dwc_ep_cmd_set_config>:
	ep = dev->ep[index];
8f61d404:	e3a0cf8e 	mov	r12, #568	; 0x238
{
8f61d408:	e59f30a0 	ldr	r3, [pc, #160]	; 8f61d4b0 <dwc_ep_cmd_set_config+0xac>
	ep = dev->ep[index];
8f61d40c:	e001019c 	mul	r1, r12, r1
{
8f61d410:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61d414:	e24dd01c 	sub	r13, r13, #28
	ep = dev->ep[index];
8f61d418:	e080e001 	add	r14, r0, r1
{
8f61d41c:	e5933000 	ldr	r3, [r3]
8f61d420:	e58d3014 	str	r3, [r13, #20]
8f61d424:	e3a03000 	mov	r3, #0
	ep = dev->ep[index];
8f61d428:	e2811008 	add	r1, r1, #8
8f61d42c:	e59e3010 	ldr	r3, [r14, #16]
8f61d430:	e080c001 	add	r12, r0, r1
8f61d434:	e5dc1001 	ldrb	r1, [r12, #1]
	ep_cmd.param0 |= (burst_size << DEPCMDPAR0_BURST_SIZE_BIT);
8f61d438:	e1a03b03 	lsl	r3, r3, #22
	ep = dev->ep[index];
8f61d43c:	e5dcc002 	ldrb	r12, [r12, #2]
	ep_cmd.param0 |= max_pkt_size << DEPCMDPAR0_MAX_PKT_SIZE_BIT;
8f61d440:	e1833f02 	orr	r3, r3, r2, lsl #30
	ep = dev->ep[index];
8f61d444:	e5de2015 	ldrb	r2, [r14, #21]
	ep_cmd.param1 |= ep_direction << DEPCMDPAR1_USB_EP_DIR_BIT;
8f61d448:	e1a01c81 	lsl	r1, r1, #25
	ep_cmd.param0 |= max_pkt_size << DEPCMDPAR0_MAX_PKT_SIZE_BIT;
8f61d44c:	e1833882 	orr	r3, r3, r2, lsl #17
	ep = dev->ep[index];
8f61d450:	e5de2008 	ldrb	r2, [r14, #8]
	ep_cmd.param1 |= ep_direction << DEPCMDPAR1_USB_EP_DIR_BIT;
8f61d454:	e1811d02 	orr	r1, r1, r2, lsl #26
	ep = dev->ep[index];
8f61d458:	e1de20bc 	ldrh	r2, [r14, #12]
	ep_cmd.param1 |= BIT(DEPCMDPAR2_XFER_COMPLETE_BIT);
8f61d45c:	e3811c05 	orr	r1, r1, #1280	; 0x500
8f61d460:	e58d100c 	str	r1, [r13, #12]
	dwc_ep_cmd(dev, ep_phy_num, &ep_cmd);
8f61d464:	e5de1014 	ldrb	r1, [r14, #20]
	ep_cmd.param0 |= max_pkt_size << DEPCMDPAR0_MAX_PKT_SIZE_BIT;
8f61d468:	e1833182 	orr	r3, r3, r2, lsl #3
	dwc_ep_cmd(dev, ep_phy_num, &ep_cmd);
8f61d46c:	e1a0200d 	mov	r2, r13
	ep_cmd.param0 |= max_pkt_size << DEPCMDPAR0_MAX_PKT_SIZE_BIT;
8f61d470:	e183308c 	orr	r3, r3, r12, lsl #1
	ep_cmd.cmd    = DEPCMD_CMD_SET_EP_CONF;
8f61d474:	e3a0c001 	mov	r12, #1
	ep_cmd.param0 |= max_pkt_size << DEPCMDPAR0_MAX_PKT_SIZE_BIT;
8f61d478:	e58d3010 	str	r3, [r13, #16]
	ep_cmd.param2 = 0x0;
8f61d47c:	e3a03000 	mov	r3, #0
	ep_cmd.cmd    = DEPCMD_CMD_SET_EP_CONF;
8f61d480:	e58dc000 	str	r12, [r13]
	ep_cmd.param2 = 0x0;
8f61d484:	e58d3008 	str	r3, [r13, #8]
	dwc_ep_cmd(dev, ep_phy_num, &ep_cmd);
8f61d488:	ebffff1c 	bl	8f61d100 <dwc_ep_cmd.constprop.0>
}
8f61d48c:	e59f301c 	ldr	r3, [pc, #28]	; 8f61d4b0 <dwc_ep_cmd_set_config+0xac>
8f61d490:	e5932000 	ldr	r2, [r3]
8f61d494:	e59d3014 	ldr	r3, [r13, #20]
8f61d498:	e0332002 	eors	r2, r3, r2
8f61d49c:	e3a03000 	mov	r3, #0
8f61d4a0:	1a000001 	bne	8f61d4ac <dwc_ep_cmd_set_config+0xa8>
8f61d4a4:	e28dd01c 	add	r13, r13, #28
8f61d4a8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61d4ac:	eb0055c3 	bl	8f632bc0 <__stack_chk_fail>
8f61d4b0:	8f74221c 	.word	0x8f74221c

8f61d4b4 <dwc_ep_cmd_stall>:
{
8f61d4b4:	e92d4010 	push	{r4, r14}
8f61d4b8:	e24dd018 	sub	r13, r13, #24
8f61d4bc:	e59fe04c 	ldr	r14, [pc, #76]	; 8f61d510 <dwc_ep_cmd_stall+0x5c>
	ep_cmd.param2 = 0;
8f61d4c0:	e3a03000 	mov	r3, #0
	dwc_ep_cmd(dev, ep_phy_num, &ep_cmd);
8f61d4c4:	e1a0200d 	mov	r2, r13
	ep_cmd.cmd = DEPCMD_CMD_SET_STALL;
8f61d4c8:	e3a0c004 	mov	r12, #4
{
8f61d4cc:	e59ee000 	ldr	r14, [r14]
8f61d4d0:	e58de014 	str	r14, [r13, #20]
8f61d4d4:	e3a0e000 	mov	r14, #0
	ep_cmd.param2 = 0;
8f61d4d8:	e58d3008 	str	r3, [r13, #8]
	ep_cmd.param1 = 0;
8f61d4dc:	e58d300c 	str	r3, [r13, #12]
	ep_cmd.param0 = 0;
8f61d4e0:	e58d3010 	str	r3, [r13, #16]
	ep_cmd.cmd = DEPCMD_CMD_SET_STALL;
8f61d4e4:	e58dc000 	str	r12, [r13]
	dwc_ep_cmd(dev, ep_phy_num, &ep_cmd);
8f61d4e8:	ebffff04 	bl	8f61d100 <dwc_ep_cmd.constprop.0>
}
8f61d4ec:	e59f301c 	ldr	r3, [pc, #28]	; 8f61d510 <dwc_ep_cmd_stall+0x5c>
8f61d4f0:	e5932000 	ldr	r2, [r3]
8f61d4f4:	e59d3014 	ldr	r3, [r13, #20]
8f61d4f8:	e0332002 	eors	r2, r3, r2
8f61d4fc:	e3a03000 	mov	r3, #0
8f61d500:	1a000001 	bne	8f61d50c <dwc_ep_cmd_stall+0x58>
8f61d504:	e28dd018 	add	r13, r13, #24
8f61d508:	e8bd8010 	pop	{r4, r15}
8f61d50c:	eb0055ab 	bl	8f632bc0 <__stack_chk_fail>
8f61d510:	8f74221c 	.word	0x8f74221c

8f61d514 <dwc_ep_cmd_clear_stall>:
{
8f61d514:	e92d4010 	push	{r4, r14}
8f61d518:	e24dd018 	sub	r13, r13, #24
8f61d51c:	e59fe04c 	ldr	r14, [pc, #76]	; 8f61d570 <dwc_ep_cmd_clear_stall+0x5c>
	ep_cmd.param2 = 0;
8f61d520:	e3a03000 	mov	r3, #0
	dwc_ep_cmd(dev, ep_phy_num, &ep_cmd);
8f61d524:	e1a0200d 	mov	r2, r13
	ep_cmd.cmd = DEPCMD_CMD_CLEAR_STALL;
8f61d528:	e3a0c005 	mov	r12, #5
{
8f61d52c:	e59ee000 	ldr	r14, [r14]
8f61d530:	e58de014 	str	r14, [r13, #20]
8f61d534:	e3a0e000 	mov	r14, #0
	ep_cmd.param2 = 0;
8f61d538:	e58d3008 	str	r3, [r13, #8]
	ep_cmd.param1 = 0;
8f61d53c:	e58d300c 	str	r3, [r13, #12]
	ep_cmd.param0 = 0;
8f61d540:	e58d3010 	str	r3, [r13, #16]
	ep_cmd.cmd = DEPCMD_CMD_CLEAR_STALL;
8f61d544:	e58dc000 	str	r12, [r13]
	dwc_ep_cmd(dev, ep_phy_num, &ep_cmd);
8f61d548:	ebfffeec 	bl	8f61d100 <dwc_ep_cmd.constprop.0>
}
8f61d54c:	e59f301c 	ldr	r3, [pc, #28]	; 8f61d570 <dwc_ep_cmd_clear_stall+0x5c>
8f61d550:	e5932000 	ldr	r2, [r3]
8f61d554:	e59d3014 	ldr	r3, [r13, #20]
8f61d558:	e0332002 	eors	r2, r3, r2
8f61d55c:	e3a03000 	mov	r3, #0
8f61d560:	1a000001 	bne	8f61d56c <dwc_ep_cmd_clear_stall+0x58>
8f61d564:	e28dd018 	add	r13, r13, #24
8f61d568:	e8bd8010 	pop	{r4, r15}
8f61d56c:	eb005593 	bl	8f632bc0 <__stack_chk_fail>
8f61d570:	8f74221c 	.word	0x8f74221c

8f61d574 <dwc_ep_cmd_start_new_config>:
{
8f61d574:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61d578:	e24dd01c 	sub	r13, r13, #28
	ep_cmd.cmd                 = DEPCMD_CMD_START_NEW_CONF;
8f61d57c:	e3a0c009 	mov	r12, #9
{
8f61d580:	e1a0e002 	mov	r14, r2
	ep_cmd.cmd                 = DEPCMD_CMD_START_NEW_CONF;
8f61d584:	e58dc000 	str	r12, [r13]
	dwc_ep_cmd(dev, ep_phy_num, &ep_cmd);
8f61d588:	e1a0200d 	mov	r2, r13
{
8f61d58c:	e59fc044 	ldr	r12, [pc, #68]	; 8f61d5d8 <dwc_ep_cmd_start_new_config+0x64>
	ep_cmd.param2 = 0;
8f61d590:	e3a03000 	mov	r3, #0
	ep_cmd.xfer_resource_index = resource_idx;
8f61d594:	e5cde004 	strb	r14, [r13, #4]
{
8f61d598:	e59cc000 	ldr	r12, [r12]
8f61d59c:	e58dc014 	str	r12, [r13, #20]
8f61d5a0:	e3a0c000 	mov	r12, #0
	ep_cmd.param2 = 0;
8f61d5a4:	e58d3008 	str	r3, [r13, #8]
	ep_cmd.param1 = 0;
8f61d5a8:	e58d300c 	str	r3, [r13, #12]
	ep_cmd.param0 = 0;
8f61d5ac:	e58d3010 	str	r3, [r13, #16]
	dwc_ep_cmd(dev, ep_phy_num, &ep_cmd);
8f61d5b0:	ebfffed2 	bl	8f61d100 <dwc_ep_cmd.constprop.0>
}
8f61d5b4:	e59f301c 	ldr	r3, [pc, #28]	; 8f61d5d8 <dwc_ep_cmd_start_new_config+0x64>
8f61d5b8:	e5932000 	ldr	r2, [r3]
8f61d5bc:	e59d3014 	ldr	r3, [r13, #20]
8f61d5c0:	e0332002 	eors	r2, r3, r2
8f61d5c4:	e3a03000 	mov	r3, #0
8f61d5c8:	1a000001 	bne	8f61d5d4 <dwc_ep_cmd_start_new_config+0x60>
8f61d5cc:	e28dd01c 	add	r13, r13, #28
8f61d5d0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61d5d4:	eb005579 	bl	8f632bc0 <__stack_chk_fail>
8f61d5d8:	8f74221c 	.word	0x8f74221c

8f61d5dc <dwc_device_set_periodic_param>:
{
8f61d5dc:	e59f30ec 	ldr	r3, [pc, #236]	; 8f61d6d0 <dwc_device_set_periodic_param+0xf4>
	uint8_t active = REG_READ_FIELD(dev, DGCMD, CMDACT);
8f61d5e0:	e5902000 	ldr	r2, [r0]
{
8f61d5e4:	e92d4070 	push	{r4, r5, r6, r14}
8f61d5e8:	e24dd010 	sub	r13, r13, #16
8f61d5ec:	e5933000 	ldr	r3, [r3]
8f61d5f0:	e58d300c 	str	r3, [r13, #12]
8f61d5f4:	e3a03000 	mov	r3, #0
	uint8_t active = REG_READ_FIELD(dev, DGCMD, CMDACT);
8f61d5f8:	e2822903 	add	r2, r2, #49152	; 0xc000
8f61d5fc:	e1a0500e 	mov	r5, r14
{
8f61d600:	e1a06001 	mov	r6, r1
	uint8_t active = REG_READ_FIELD(dev, DGCMD, CMDACT);
8f61d604:	e5923714 	ldr	r3, [r2, #1812]	; 0x714
	ASSERT(active);
8f61d608:	e3130b01 	tst	r3, #1024	; 0x400
8f61d60c:	0a000020 	beq	8f61d694 <dwc_device_set_periodic_param+0xb8>
	REG_WRITE(dev, DGCMDPAR, cmd->param);
8f61d610:	e5826710 	str	r6, [r2, #1808]	; 0x710
	REG_WRITE_FIELD(dev, DGCMD, CMDTYP, cmd->cmd);
8f61d614:	e5923714 	ldr	r3, [r2, #1812]	; 0x714
8f61d618:	e3c330ff 	bic	r3, r3, #255	; 0xff
8f61d61c:	e3833002 	orr	r3, r3, #2
8f61d620:	e5823714 	str	r3, [r2, #1812]	; 0x714
	while(!REG_READ_FIELD(dev, DGCMD, CMDACT));
8f61d624:	e5923714 	ldr	r3, [r2, #1812]	; 0x714
8f61d628:	e3130b01 	tst	r3, #1024	; 0x400
8f61d62c:	0afffffc 	beq	8f61d624 <dwc_device_set_periodic_param+0x48>
	if(REG_READ_FIELD(dev, DGCMD, CMDSTATUS))
8f61d630:	e5923714 	ldr	r3, [r2, #1812]	; 0x714
8f61d634:	e3130a0f 	tst	r3, #61440	; 0xf000
8f61d638:	1a000007 	bne	8f61d65c <dwc_device_set_periodic_param+0x80>
}
8f61d63c:	e59f308c 	ldr	r3, [pc, #140]	; 8f61d6d0 <dwc_device_set_periodic_param+0xf4>
8f61d640:	e5932000 	ldr	r2, [r3]
8f61d644:	e59d300c 	ldr	r3, [r13, #12]
8f61d648:	e0332002 	eors	r2, r3, r2
8f61d64c:	e3a03000 	mov	r3, #0
8f61d650:	1a00001d 	bne	8f61d6cc <dwc_device_set_periodic_param+0xf0>
8f61d654:	e28dd010 	add	r13, r13, #16
8f61d658:	e8bd8070 	pop	{r4, r5, r6, r15}
		ERR("\n\n device command failed. \n\n");
8f61d65c:	e307011c 	movw	r0, #28956	; 0x711c
8f61d660:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61d664:	eb0054c2 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f61d668:	e307cf64 	movw	r12, #32612	; 0x7f64
8f61d66c:	e30720dc 	movw	r2, #28892	; 0x70dc
8f61d670:	e348cf70 	movt	r12, #36720	; 0x8f70
8f61d674:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61d678:	e3001130 	movw	r1, #304	; 0x130
8f61d67c:	e3003156 	movw	r3, #342	; 0x156
8f61d680:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61d684:	e1a00005 	mov	r0, r5
8f61d688:	e58dc000 	str	r12, [r13]
8f61d68c:	eb00550a 	bl	8f632abc <_panic>
}
8f61d690:	eaffffe9 	b	8f61d63c <dwc_device_set_periodic_param+0x60>
8f61d694:	e1a04000 	mov	r4, r0
	ASSERT(active);
8f61d698:	e30822d4 	movw	r2, #33492	; 0x82d4
8f61d69c:	e300314b 	movw	r3, #331	; 0x14b
8f61d6a0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61d6a4:	e3001130 	movw	r1, #304	; 0x130
8f61d6a8:	e58d2000 	str	r2, [r13]
8f61d6ac:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61d6b0:	e30720dc 	movw	r2, #28892	; 0x70dc
8f61d6b4:	e1a0000e 	mov	r0, r14
8f61d6b8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61d6bc:	eb0054fe 	bl	8f632abc <_panic>
	REG_WRITE(dev, DGCMDPAR, cmd->param);
8f61d6c0:	e5942000 	ldr	r2, [r4]
8f61d6c4:	e2822903 	add	r2, r2, #49152	; 0xc000
8f61d6c8:	eaffffd0 	b	8f61d610 <dwc_device_set_periodic_param+0x34>
}
8f61d6cc:	eb00553b 	bl	8f632bc0 <__stack_chk_fail>
8f61d6d0:	8f74221c 	.word	0x8f74221c

8f61d6d4 <dwc_device_set_addr>:
{
8f61d6d4:	e59f304c 	ldr	r3, [pc, #76]	; 8f61d728 <dwc_device_set_addr+0x54>
	REG_WRITE_FIELD(dev, DCFG, DEVADDR, addr);
8f61d6d8:	e5902000 	ldr	r2, [r0]
{
8f61d6dc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61d6e0:	e24dd00c 	sub	r13, r13, #12
8f61d6e4:	e5933000 	ldr	r3, [r3]
8f61d6e8:	e58d3004 	str	r3, [r13, #4]
8f61d6ec:	e3a03000 	mov	r3, #0
	REG_WRITE_FIELD(dev, DCFG, DEVADDR, addr);
8f61d6f0:	e2822903 	add	r2, r2, #49152	; 0xc000
8f61d6f4:	e5923700 	ldr	r3, [r2, #1792]	; 0x700
8f61d6f8:	e3c33ffe 	bic	r3, r3, #1016	; 0x3f8
8f61d6fc:	e1833181 	orr	r3, r3, r1, lsl #3
8f61d700:	e5823700 	str	r3, [r2, #1792]	; 0x700
}
8f61d704:	e59f301c 	ldr	r3, [pc, #28]	; 8f61d728 <dwc_device_set_addr+0x54>
8f61d708:	e5932000 	ldr	r2, [r3]
8f61d70c:	e59d3004 	ldr	r3, [r13, #4]
8f61d710:	e0332002 	eors	r2, r3, r2
8f61d714:	e3a03000 	mov	r3, #0
8f61d718:	1a000001 	bne	8f61d724 <dwc_device_set_addr+0x50>
8f61d71c:	e28dd00c 	add	r13, r13, #12
8f61d720:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61d724:	eb005525 	bl	8f632bc0 <__stack_chk_fail>
8f61d728:	8f74221c 	.word	0x8f74221c

8f61d72c <dwc_device_reset>:
{
8f61d72c:	e59f3054 	ldr	r3, [pc, #84]	; 8f61d788 <dwc_device_reset+0x5c>
	REG_WRITE_FIELD(dev, DCTL, CSFTRST, 1);
8f61d730:	e5902000 	ldr	r2, [r0]
{
8f61d734:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61d738:	e24dd00c 	sub	r13, r13, #12
8f61d73c:	e5933000 	ldr	r3, [r3]
8f61d740:	e58d3004 	str	r3, [r13, #4]
8f61d744:	e3a03000 	mov	r3, #0
	REG_WRITE_FIELD(dev, DCTL, CSFTRST, 1);
8f61d748:	e2822903 	add	r2, r2, #49152	; 0xc000
8f61d74c:	e5923704 	ldr	r3, [r2, #1796]	; 0x704
8f61d750:	e3833101 	orr	r3, r3, #1073741824	; 0x40000000
8f61d754:	e5823704 	str	r3, [r2, #1796]	; 0x704
	while(REG_READ_FIELD(dev, DCTL, CSFTRST));
8f61d758:	e5923704 	ldr	r3, [r2, #1796]	; 0x704
8f61d75c:	e3130101 	tst	r3, #1073741824	; 0x40000000
8f61d760:	1afffffc 	bne	8f61d758 <dwc_device_reset+0x2c>
}
8f61d764:	e59f301c 	ldr	r3, [pc, #28]	; 8f61d788 <dwc_device_reset+0x5c>
8f61d768:	e5932000 	ldr	r2, [r3]
8f61d76c:	e59d3004 	ldr	r3, [r13, #4]
8f61d770:	e0332002 	eors	r2, r3, r2
8f61d774:	e3a03000 	mov	r3, #0
8f61d778:	1a000001 	bne	8f61d784 <dwc_device_reset+0x58>
8f61d77c:	e28dd00c 	add	r13, r13, #12
8f61d780:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61d784:	eb00550d 	bl	8f632bc0 <__stack_chk_fail>
8f61d788:	8f74221c 	.word	0x8f74221c

8f61d78c <dwc_device_run>:
{
8f61d78c:	e59f304c 	ldr	r3, [pc, #76]	; 8f61d7e0 <dwc_device_run+0x54>
	REG_WRITE_FIELD(dev, DCTL, RUN_STOP, run);
8f61d790:	e5902000 	ldr	r2, [r0]
{
8f61d794:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61d798:	e24dd00c 	sub	r13, r13, #12
8f61d79c:	e5933000 	ldr	r3, [r3]
8f61d7a0:	e58d3004 	str	r3, [r13, #4]
8f61d7a4:	e3a03000 	mov	r3, #0
	REG_WRITE_FIELD(dev, DCTL, RUN_STOP, run);
8f61d7a8:	e2822903 	add	r2, r2, #49152	; 0xc000
8f61d7ac:	e5923704 	ldr	r3, [r2, #1796]	; 0x704
8f61d7b0:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
8f61d7b4:	e1833f81 	orr	r3, r3, r1, lsl #31
8f61d7b8:	e5823704 	str	r3, [r2, #1796]	; 0x704
}
8f61d7bc:	e59f301c 	ldr	r3, [pc, #28]	; 8f61d7e0 <dwc_device_run+0x54>
8f61d7c0:	e5932000 	ldr	r2, [r3]
8f61d7c4:	e59d3004 	ldr	r3, [r13, #4]
8f61d7c8:	e0332002 	eors	r2, r3, r2
8f61d7cc:	e3a03000 	mov	r3, #0
8f61d7d0:	1a000001 	bne	8f61d7dc <dwc_device_run+0x50>
8f61d7d4:	e28dd00c 	add	r13, r13, #12
8f61d7d8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61d7dc:	eb0054f7 	bl	8f632bc0 <__stack_chk_fail>
8f61d7e0:	8f74221c 	.word	0x8f74221c

8f61d7e4 <dwc_device_run_status>:
{
8f61d7e4:	e59f3044 	ldr	r3, [pc, #68]	; 8f61d830 <dwc_device_run_status+0x4c>
8f61d7e8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61d7ec:	e24dd00c 	sub	r13, r13, #12
8f61d7f0:	e5933000 	ldr	r3, [r3]
8f61d7f4:	e58d3004 	str	r3, [r13, #4]
8f61d7f8:	e3a03000 	mov	r3, #0
	return REG_READ_FIELD(dev, DCTL, RUN_STOP);
8f61d7fc:	e5903000 	ldr	r3, [r0]
8f61d800:	e2833903 	add	r3, r3, #49152	; 0xc000
8f61d804:	e5930704 	ldr	r0, [r3, #1796]	; 0x704
}
8f61d808:	e59f3020 	ldr	r3, [pc, #32]	; 8f61d830 <dwc_device_run_status+0x4c>
8f61d80c:	e5932000 	ldr	r2, [r3]
8f61d810:	e59d3004 	ldr	r3, [r13, #4]
8f61d814:	e0332002 	eors	r2, r3, r2
8f61d818:	e3a03000 	mov	r3, #0
8f61d81c:	1a000002 	bne	8f61d82c <dwc_device_run_status+0x48>
8f61d820:	e1a00fa0 	lsr	r0, r0, #31
8f61d824:	e28dd00c 	add	r13, r13, #12
8f61d828:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61d82c:	eb0054e3 	bl	8f632bc0 <__stack_chk_fail>
8f61d830:	8f74221c 	.word	0x8f74221c

8f61d834 <dwc_device_enter_test_mode>:

void dwc_device_enter_test_mode(dwc_dev_t *dev)
{
8f61d834:	e59f3054 	ldr	r3, [pc, #84]	; 8f61d890 <dwc_device_enter_test_mode+0x5c>
	REG_WRITE_FIELD(dev, DCTL, TSTCTL, dev->test_mode);
8f61d838:	e5902000 	ldr	r2, [r0]
{
8f61d83c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61d840:	e24dd00c 	sub	r13, r13, #12
8f61d844:	e5933000 	ldr	r3, [r3]
8f61d848:	e58d3004 	str	r3, [r13, #4]
8f61d84c:	e3a03000 	mov	r3, #0
	REG_WRITE_FIELD(dev, DCTL, TSTCTL, dev->test_mode);
8f61d850:	e2822903 	add	r2, r2, #49152	; 0xc000
8f61d854:	e2803d47 	add	r3, r0, #4544	; 0x11c0
8f61d858:	e1d313b0 	ldrh	r1, [r3, #48]	; 0x30
8f61d85c:	e5923704 	ldr	r3, [r2, #1796]	; 0x704
8f61d860:	e3c3301e 	bic	r3, r3, #30
8f61d864:	e1833081 	orr	r3, r3, r1, lsl #1
8f61d868:	e5823704 	str	r3, [r2, #1796]	; 0x704
}
8f61d86c:	e59f301c 	ldr	r3, [pc, #28]	; 8f61d890 <dwc_device_enter_test_mode+0x5c>
8f61d870:	e5932000 	ldr	r2, [r3]
8f61d874:	e59d3004 	ldr	r3, [r13, #4]
8f61d878:	e0332002 	eors	r2, r3, r2
8f61d87c:	e3a03000 	mov	r3, #0
8f61d880:	1a000001 	bne	8f61d88c <dwc_device_enter_test_mode+0x58>
8f61d884:	e28dd00c 	add	r13, r13, #12
8f61d888:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61d88c:	eb0054cb 	bl	8f632bc0 <__stack_chk_fail>
8f61d890:	8f74221c 	.word	0x8f74221c

8f61d894 <dwc_device_enable_u1>:

void dwc_device_enable_u1(dwc_dev_t *dev, uint8_t val)
{
8f61d894:	e59f304c 	ldr	r3, [pc, #76]	; 8f61d8e8 <dwc_device_enable_u1+0x54>
	REG_WRITE_FIELD(dev, DCTL, INITU1ENA, val);
8f61d898:	e5902000 	ldr	r2, [r0]
{
8f61d89c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61d8a0:	e24dd00c 	sub	r13, r13, #12
8f61d8a4:	e5933000 	ldr	r3, [r3]
8f61d8a8:	e58d3004 	str	r3, [r13, #4]
8f61d8ac:	e3a03000 	mov	r3, #0
	REG_WRITE_FIELD(dev, DCTL, INITU1ENA, val);
8f61d8b0:	e2822903 	add	r2, r2, #49152	; 0xc000
8f61d8b4:	e5923704 	ldr	r3, [r2, #1796]	; 0x704
8f61d8b8:	e3c33b01 	bic	r3, r3, #1024	; 0x400
8f61d8bc:	e1833501 	orr	r3, r3, r1, lsl #10
8f61d8c0:	e5823704 	str	r3, [r2, #1796]	; 0x704
}
8f61d8c4:	e59f301c 	ldr	r3, [pc, #28]	; 8f61d8e8 <dwc_device_enable_u1+0x54>
8f61d8c8:	e5932000 	ldr	r2, [r3]
8f61d8cc:	e59d3004 	ldr	r3, [r13, #4]
8f61d8d0:	e0332002 	eors	r2, r3, r2
8f61d8d4:	e3a03000 	mov	r3, #0
8f61d8d8:	1a000001 	bne	8f61d8e4 <dwc_device_enable_u1+0x50>
8f61d8dc:	e28dd00c 	add	r13, r13, #12
8f61d8e0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61d8e4:	eb0054b5 	bl	8f632bc0 <__stack_chk_fail>
8f61d8e8:	8f74221c 	.word	0x8f74221c

8f61d8ec <dwc_device_enable_u2>:

void dwc_device_enable_u2(dwc_dev_t *dev, uint8_t val)
{
8f61d8ec:	e59f304c 	ldr	r3, [pc, #76]	; 8f61d940 <dwc_device_enable_u2+0x54>
	REG_WRITE_FIELD(dev, DCTL, INITU2ENA, val);
8f61d8f0:	e5902000 	ldr	r2, [r0]
{
8f61d8f4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61d8f8:	e24dd00c 	sub	r13, r13, #12
8f61d8fc:	e5933000 	ldr	r3, [r3]
8f61d900:	e58d3004 	str	r3, [r13, #4]
8f61d904:	e3a03000 	mov	r3, #0
	REG_WRITE_FIELD(dev, DCTL, INITU2ENA, val);
8f61d908:	e2822903 	add	r2, r2, #49152	; 0xc000
8f61d90c:	e5923704 	ldr	r3, [r2, #1796]	; 0x704
8f61d910:	e3c33a01 	bic	r3, r3, #4096	; 0x1000
8f61d914:	e1833601 	orr	r3, r3, r1, lsl #12
8f61d918:	e5823704 	str	r3, [r2, #1796]	; 0x704
}
8f61d91c:	e59f301c 	ldr	r3, [pc, #28]	; 8f61d940 <dwc_device_enable_u2+0x54>
8f61d920:	e5932000 	ldr	r2, [r3]
8f61d924:	e59d3004 	ldr	r3, [r13, #4]
8f61d928:	e0332002 	eors	r2, r3, r2
8f61d92c:	e3a03000 	mov	r3, #0
8f61d930:	1a000001 	bne	8f61d93c <dwc_device_enable_u2+0x50>
8f61d934:	e28dd00c 	add	r13, r13, #12
8f61d938:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61d93c:	eb00549f 	bl	8f632bc0 <__stack_chk_fail>
8f61d940:	8f74221c 	.word	0x8f74221c

8f61d944 <dwc_device_accept_u1u2>:

void dwc_device_accept_u1u2(dwc_dev_t *dev)
{
8f61d944:	e59f3054 	ldr	r3, [pc, #84]	; 8f61d9a0 <dwc_device_accept_u1u2+0x5c>
8f61d948:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61d94c:	e24dd00c 	sub	r13, r13, #12
8f61d950:	e5933000 	ldr	r3, [r3]
8f61d954:	e58d3004 	str	r3, [r13, #4]
8f61d958:	e3a03000 	mov	r3, #0
	REG_WRITE_FIELD(dev, DCTL, ACCEPTU1ENA, 1);
8f61d95c:	e5903000 	ldr	r3, [r0]
8f61d960:	e2833903 	add	r3, r3, #49152	; 0xc000
8f61d964:	e5932704 	ldr	r2, [r3, #1796]	; 0x704
8f61d968:	e3822c02 	orr	r2, r2, #512	; 0x200
8f61d96c:	e5832704 	str	r2, [r3, #1796]	; 0x704
	REG_WRITE_FIELD(dev, DCTL, ACCEPTU2ENA, 1);
8f61d970:	e5932704 	ldr	r2, [r3, #1796]	; 0x704
8f61d974:	e3822b02 	orr	r2, r2, #2048	; 0x800
8f61d978:	e5832704 	str	r2, [r3, #1796]	; 0x704
}
8f61d97c:	e59f301c 	ldr	r3, [pc, #28]	; 8f61d9a0 <dwc_device_accept_u1u2+0x5c>
8f61d980:	e5932000 	ldr	r2, [r3]
8f61d984:	e59d3004 	ldr	r3, [r13, #4]
8f61d988:	e0332002 	eors	r2, r3, r2
8f61d98c:	e3a03000 	mov	r3, #0
8f61d990:	1a000001 	bne	8f61d99c <dwc_device_accept_u1u2+0x58>
8f61d994:	e28dd00c 	add	r13, r13, #12
8f61d998:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61d99c:	eb005487 	bl	8f632bc0 <__stack_chk_fail>
8f61d9a0:	8f74221c 	.word	0x8f74221c

8f61d9a4 <dwc_device_u1_enabled>:

bool dwc_device_u1_enabled(dwc_dev_t *dev)
{
8f61d9a4:	e59f3044 	ldr	r3, [pc, #68]	; 8f61d9f0 <dwc_device_u1_enabled+0x4c>
8f61d9a8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61d9ac:	e24dd00c 	sub	r13, r13, #12
8f61d9b0:	e5933000 	ldr	r3, [r3]
8f61d9b4:	e58d3004 	str	r3, [r13, #4]
8f61d9b8:	e3a03000 	mov	r3, #0
	uint32_t val;

	val = REG_READ(dev, DCTL);
8f61d9bc:	e5903000 	ldr	r3, [r0]
8f61d9c0:	e2833903 	add	r3, r3, #49152	; 0xc000
8f61d9c4:	e5930704 	ldr	r0, [r3, #1796]	; 0x704

	return val & (1 << 10) ? true : false;
}
8f61d9c8:	e59f3020 	ldr	r3, [pc, #32]	; 8f61d9f0 <dwc_device_u1_enabled+0x4c>
	return val & (1 << 10) ? true : false;
8f61d9cc:	e7e00550 	ubfx	r0, r0, #10, #1
}
8f61d9d0:	e5932000 	ldr	r2, [r3]
8f61d9d4:	e59d3004 	ldr	r3, [r13, #4]
8f61d9d8:	e0332002 	eors	r2, r3, r2
8f61d9dc:	e3a03000 	mov	r3, #0
8f61d9e0:	1a000001 	bne	8f61d9ec <dwc_device_u1_enabled+0x48>
8f61d9e4:	e28dd00c 	add	r13, r13, #12
8f61d9e8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61d9ec:	eb005473 	bl	8f632bc0 <__stack_chk_fail>
8f61d9f0:	8f74221c 	.word	0x8f74221c

8f61d9f4 <dwc_device_u2_enabled>:

bool dwc_device_u2_enabled(dwc_dev_t *dev)
{
8f61d9f4:	e59f3044 	ldr	r3, [pc, #68]	; 8f61da40 <dwc_device_u2_enabled+0x4c>
8f61d9f8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61d9fc:	e24dd00c 	sub	r13, r13, #12
8f61da00:	e5933000 	ldr	r3, [r3]
8f61da04:	e58d3004 	str	r3, [r13, #4]
8f61da08:	e3a03000 	mov	r3, #0
	uint32_t val;

	val = REG_READ(dev, DCTL);
8f61da0c:	e5903000 	ldr	r3, [r0]
8f61da10:	e2833903 	add	r3, r3, #49152	; 0xc000
8f61da14:	e5930704 	ldr	r0, [r3, #1796]	; 0x704

	return val & (1 << 12) ? true : false;
}
8f61da18:	e59f3020 	ldr	r3, [pc, #32]	; 8f61da40 <dwc_device_u2_enabled+0x4c>
	return val & (1 << 12) ? true : false;
8f61da1c:	e7e00650 	ubfx	r0, r0, #12, #1
}
8f61da20:	e5932000 	ldr	r2, [r3]
8f61da24:	e59d3004 	ldr	r3, [r13, #4]
8f61da28:	e0332002 	eors	r2, r3, r2
8f61da2c:	e3a03000 	mov	r3, #0
8f61da30:	1a000001 	bne	8f61da3c <dwc_device_u2_enabled+0x48>
8f61da34:	e28dd00c 	add	r13, r13, #12
8f61da38:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61da3c:	eb00545f 	bl	8f632bc0 <__stack_chk_fail>
8f61da40:	8f74221c 	.word	0x8f74221c

8f61da44 <dwc_event_init>:
void dwc_event_init(dwc_dev_t *dev)
{
	/* snps 8.2.2 */

	/* event buffer address */
	REG_WRITEI(dev, GEVNTADRLO, 0, (uint32_t) dev->event_buf.buf);
8f61da44:	e2802a01 	add	r2, r0, #4096	; 0x1000
{
8f61da48:	e59f305c 	ldr	r3, [pc, #92]	; 8f61daac <dwc_event_init+0x68>
8f61da4c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	REG_WRITEI(dev, GEVNTADRHI, 0, 0x0);

	/* set buffer size. assuming interrupt is always needed on new event,
	 * bit 31 is not set.
	 */
	REG_WRITEI(dev, GEVNTSIZ, 0, dev->event_buf.buf_size);
8f61da50:	e2821f73 	add	r1, r2, #460	; 0x1cc
{
8f61da54:	e24dd00c 	sub	r13, r13, #12
8f61da58:	e5933000 	ldr	r3, [r3]
8f61da5c:	e58d3004 	str	r3, [r13, #4]
8f61da60:	e3a03000 	mov	r3, #0
	REG_WRITEI(dev, GEVNTADRLO, 0, (uint32_t) dev->event_buf.buf);
8f61da64:	e5903000 	ldr	r3, [r0]
	REG_WRITEI(dev, GEVNTSIZ, 0, dev->event_buf.buf_size);
8f61da68:	e1d110b0 	ldrh	r1, [r1]
	REG_WRITEI(dev, GEVNTADRLO, 0, (uint32_t) dev->event_buf.buf);
8f61da6c:	e59201c8 	ldr	r0, [r2, #456]	; 0x1c8
8f61da70:	e2833903 	add	r3, r3, #49152	; 0xc000
	REG_WRITEI(dev, GEVNTADRHI, 0, 0x0);
8f61da74:	e3a02000 	mov	r2, #0
	REG_WRITEI(dev, GEVNTADRLO, 0, (uint32_t) dev->event_buf.buf);
8f61da78:	e5830400 	str	r0, [r3, #1024]	; 0x400
	REG_WRITEI(dev, GEVNTADRHI, 0, 0x0);
8f61da7c:	e5832404 	str	r2, [r3, #1028]	; 0x404
	REG_WRITEI(dev, GEVNTSIZ, 0, dev->event_buf.buf_size);
8f61da80:	e5831408 	str	r1, [r3, #1032]	; 0x408

	/* reset count */
	REG_WRITEI(dev, GEVNTCOUNT, 0, 0x0);
8f61da84:	e583240c 	str	r2, [r3, #1036]	; 0x40c
}
8f61da88:	e59f301c 	ldr	r3, [pc, #28]	; 8f61daac <dwc_event_init+0x68>
8f61da8c:	e5932000 	ldr	r2, [r3]
8f61da90:	e59d3004 	ldr	r3, [r13, #4]
8f61da94:	e0332002 	eors	r2, r3, r2
8f61da98:	e3a03000 	mov	r3, #0
8f61da9c:	1a000001 	bne	8f61daa8 <dwc_event_init+0x64>
8f61daa0:	e28dd00c 	add	r13, r13, #12
8f61daa4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61daa8:	eb005444 	bl	8f632bc0 <__stack_chk_fail>
8f61daac:	8f74221c 	.word	0x8f74221c

8f61dab0 <dwc_event_get_next>:
 * Most events are 4 byte long
 * Note: caller must provide at least 12 bytes buffer in case the
 * next event is the special 12 byte event.
 */
uint16_t dwc_event_get_next(dwc_dev_t *dev, uint32_t *event)
{
8f61dab0:	e59f3184 	ldr	r3, [pc, #388]	; 8f61dc3c <dwc_event_get_next+0x18c>
8f61dab4:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f61dab8:	e24dd014 	sub	r13, r13, #20
8f61dabc:	e5933000 	ldr	r3, [r3]
8f61dac0:	e58d300c 	str	r3, [r13, #12]
8f61dac4:	e3a03000 	mov	r3, #0
	uint16_t count;
	uint16_t event_size = 0;
	uint32_t *buf;

	/* read the number of valid event data in event buffer. */
	count = REG_READI(dev, GEVNTCOUNT, 0);
8f61dac8:	e5903000 	ldr	r3, [r0]
{
8f61dacc:	e1a04000 	mov	r4, r0
	count = REG_READI(dev, GEVNTCOUNT, 0);
8f61dad0:	e2833903 	add	r3, r3, #49152	; 0xc000
8f61dad4:	e593340c 	ldr	r3, [r3, #1036]	; 0x40c
8f61dad8:	e6ff0073 	uxth	r0, r3

	if(count == 0)
8f61dadc:	e3500000 	cmp	r0, #0
8f61dae0:	0a000031 	beq	8f61dbac <dwc_event_get_next+0xfc>
	}

	/* each event is at least 4 bytes long.
	 * make sure there is at least one event to read.
	 */
	ASSERT(count >= 4);
8f61dae4:	e3500003 	cmp	r0, #3
8f61dae8:	e1a0600e 	mov	r6, r14
8f61daec:	e1a05001 	mov	r5, r1
8f61daf0:	9a000045 	bls	8f61dc0c <dwc_event_get_next+0x15c>

	/* get event buffer for this device */
	buf = dev->event_buf.buf;
8f61daf4:	e2844a01 	add	r4, r4, #4096	; 0x1000

	arch_invalidate_cache_range((addr_t)buf, dev->event_buf.buf_size);
8f61daf8:	e2843f73 	add	r3, r4, #460	; 0x1cc
	buf = dev->event_buf.buf;
8f61dafc:	e59471c8 	ldr	r7, [r4, #456]	; 0x1c8
	arch_invalidate_cache_range((addr_t)buf, dev->event_buf.buf_size);
8f61db00:	e1d310b0 	ldrh	r1, [r3]
8f61db04:	e1a00007 	mov	r0, r7
8f61db08:	eb000d2e 	bl	8f620fc8 <arch_invalidate_cache_range>
	/* read next event */
	*event = readl(buf + dev->event_buf.index);
8f61db0c:	e2843e1d 	add	r3, r4, #464	; 0x1d0
	event_size += 4;
	dwc_event_update_index(&dev->event_buf.index, dev->event_buf.max_index);
8f61db10:	e30021ce 	movw	r2, #462	; 0x1ce
8f61db14:	e2840e1d 	add	r0, r4, #464	; 0x1d0
	*event = readl(buf + dev->event_buf.index);
8f61db18:	e1d330b0 	ldrh	r3, [r3]
	if(*index == max_count)
8f61db1c:	e19420b2 	ldrh	r2, [r4, r2]
8f61db20:	e1520003 	cmp	r2, r3
	*event = readl(buf + dev->event_buf.index);
8f61db24:	e7972103 	ldr	r2, [r7, r3, lsl #2]
		*index += 1;
8f61db28:	12833001 	addne	r3, r3, #1


	/* is this buffer overflow event? */
	if((DWC_EVENT_DEVICE_EVENT_ID(*event) == DWC_EVENT_DEVICE_EVENT_ID_BUFFER_OVERFLOW))
8f61db2c:	e7e31452 	ubfx	r1, r2, #8, #4
		*index = 0;
8f61db30:	03a03000 	moveq	r3, #0
		*index += 1;
8f61db34:	16ff3073 	uxthne	r3, r3
	if((DWC_EVENT_DEVICE_EVENT_ID(*event) == DWC_EVENT_DEVICE_EVENT_ID_BUFFER_OVERFLOW))
8f61db38:	e351000b 	cmp	r1, #11
	*event = readl(buf + dev->event_buf.index);
8f61db3c:	e5852000 	str	r2, [r5]
		*index += 1;
8f61db40:	e1c030b0 	strh	r3, [r0]
	if((DWC_EVENT_DEVICE_EVENT_ID(*event) == DWC_EVENT_DEVICE_EVENT_ID_BUFFER_OVERFLOW))
8f61db44:	0a000020 	beq	8f61dbcc <dwc_event_get_next+0x11c>
		ERR("\n Event buffer is full. Need to increase size.\n");
		ASSERT(0);
	}

	/* check for that special 12 byte event */
	if( DWC_EVENT_IS_DEVICE_EVENT(*event) &
8f61db48:	e351000c 	cmp	r1, #12
8f61db4c:	13a02000 	movne	r2, #0
8f61db50:	02022001 	andeq	r2, r2, #1
8f61db54:	e3520000 	cmp	r2, #0
	event_size += 4;
8f61db58:	03a00004 	moveq	r0, #4
	if( DWC_EVENT_IS_DEVICE_EVENT(*event) &
8f61db5c:	0a000012 	beq	8f61dbac <dwc_event_get_next+0xfc>
		(DWC_EVENT_DEVICE_EVENT_ID(*event) == DWC_EVENT_DEVICE_EVENT_ID_VENDOR_DEVICE_TEST_LMP))
	{
		*(event + 1) = readl(buf + dev->event_buf.index);
8f61db60:	e2843e1d 	add	r3, r4, #464	; 0x1d0
		event_size += 4;
		dwc_event_update_index(&dev->event_buf.index, dev->event_buf.buf_size);

		*(event + 1) = readl(buf + dev->event_buf.index);
		event_size += 4;
8f61db64:	e3a0000c 	mov	r0, #12
		*(event + 1) = readl(buf + dev->event_buf.index);
8f61db68:	e1d330b0 	ldrh	r3, [r3]
8f61db6c:	e7972103 	ldr	r2, [r7, r3, lsl #2]
8f61db70:	e5852004 	str	r2, [r5, #4]
		dwc_event_update_index(&dev->event_buf.index, dev->event_buf.buf_size);
8f61db74:	e2842f73 	add	r2, r4, #460	; 0x1cc
		*index = 0;
8f61db78:	e2844e1d 	add	r4, r4, #464	; 0x1d0
		dwc_event_update_index(&dev->event_buf.index, dev->event_buf.buf_size);
8f61db7c:	e1d220b0 	ldrh	r2, [r2]
	if(*index == max_count)
8f61db80:	e1530002 	cmp	r3, r2
		*index += 1;
8f61db84:	12833001 	addne	r3, r3, #1
		*index = 0;
8f61db88:	03a03000 	moveq	r3, #0
		*index += 1;
8f61db8c:	16ff3073 	uxthne	r3, r3
		*(event + 1) = readl(buf + dev->event_buf.index);
8f61db90:	10877103 	addne	r7, r7, r3, lsl #2
	if(*index == max_count)
8f61db94:	e1530002 	cmp	r3, r2
		*index += 1;
8f61db98:	12833001 	addne	r3, r3, #1
		*(event + 1) = readl(buf + dev->event_buf.index);
8f61db9c:	e5971000 	ldr	r1, [r7]
		*index = 0;
8f61dba0:	03a03000 	moveq	r3, #0
		*(event + 1) = readl(buf + dev->event_buf.index);
8f61dba4:	e5851004 	str	r1, [r5, #4]
		*index += 1;
8f61dba8:	e1c430b0 	strh	r3, [r4]
		dwc_event_update_index(&dev->event_buf.index, dev->event_buf.buf_size);
	}

	return event_size;
}
8f61dbac:	e59f3088 	ldr	r3, [pc, #136]	; 8f61dc3c <dwc_event_get_next+0x18c>
8f61dbb0:	e5932000 	ldr	r2, [r3]
8f61dbb4:	e59d300c 	ldr	r3, [r13, #12]
8f61dbb8:	e0332002 	eors	r2, r3, r2
8f61dbbc:	e3a03000 	mov	r3, #0
8f61dbc0:	1a00001c 	bne	8f61dc38 <dwc_event_get_next+0x188>
8f61dbc4:	e28dd014 	add	r13, r13, #20
8f61dbc8:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		ERR("\n Event buffer is full. Need to increase size.\n");
8f61dbcc:	e3070148 	movw	r0, #29000	; 0x7148
8f61dbd0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61dbd4:	eb005366 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f61dbd8:	e3073f64 	movw	r3, #32612	; 0x7f64
8f61dbdc:	e1a00006 	mov	r0, r6
8f61dbe0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61dbe4:	e30720dc 	movw	r2, #28892	; 0x70dc
8f61dbe8:	e58d3000 	str	r3, [r13]
8f61dbec:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61dbf0:	e30031f9 	movw	r3, #505	; 0x1f9
8f61dbf4:	e3001130 	movw	r1, #304	; 0x130
8f61dbf8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61dbfc:	eb0053ae 	bl	8f632abc <_panic>
	if( DWC_EVENT_IS_DEVICE_EVENT(*event) &
8f61dc00:	e5952000 	ldr	r2, [r5]
		(DWC_EVENT_DEVICE_EVENT_ID(*event) == DWC_EVENT_DEVICE_EVENT_ID_VENDOR_DEVICE_TEST_LMP))
8f61dc04:	e7e31452 	ubfx	r1, r2, #8, #4
8f61dc08:	eaffffce 	b	8f61db48 <dwc_event_get_next+0x98>
	ASSERT(count >= 4);
8f61dc0c:	e307113c 	movw	r1, #28988	; 0x713c
8f61dc10:	e30720dc 	movw	r2, #28892	; 0x70dc
8f61dc14:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61dc18:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61dc1c:	e58d1000 	str	r1, [r13]
8f61dc20:	e3a03f7a 	mov	r3, #488	; 0x1e8
8f61dc24:	e3001130 	movw	r1, #304	; 0x130
8f61dc28:	e1a0000e 	mov	r0, r14
8f61dc2c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61dc30:	eb0053a1 	bl	8f632abc <_panic>
8f61dc34:	eaffffae 	b	8f61daf4 <dwc_event_get_next+0x44>
}
8f61dc38:	eb0053e0 	bl	8f632bc0 <__stack_chk_fail>
8f61dc3c:	8f74221c 	.word	0x8f74221c

8f61dc40 <dwc_event_processed>:
 * and it can use that space for new events.
 * This must be done only after the event is processed.
 */
void dwc_event_processed(dwc_dev_t *dev, uint16_t count)
{
	REG_WRITEI(dev, GEVNTCOUNT, 0, count);
8f61dc40:	e5903000 	ldr	r3, [r0]
{
8f61dc44:	e59f203c 	ldr	r2, [pc, #60]	; 8f61dc88 <dwc_event_processed+0x48>
	REG_WRITEI(dev, GEVNTCOUNT, 0, count);
8f61dc48:	e2833903 	add	r3, r3, #49152	; 0xc000
{
8f61dc4c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61dc50:	e24dd00c 	sub	r13, r13, #12
8f61dc54:	e5922000 	ldr	r2, [r2]
8f61dc58:	e58d2004 	str	r2, [r13, #4]
8f61dc5c:	e3a02000 	mov	r2, #0
	REG_WRITEI(dev, GEVNTCOUNT, 0, count);
8f61dc60:	e583140c 	str	r1, [r3, #1036]	; 0x40c
}
8f61dc64:	e59f301c 	ldr	r3, [pc, #28]	; 8f61dc88 <dwc_event_processed+0x48>
8f61dc68:	e5932000 	ldr	r2, [r3]
8f61dc6c:	e59d3004 	ldr	r3, [r13, #4]
8f61dc70:	e0332002 	eors	r2, r3, r2
8f61dc74:	e3a03000 	mov	r3, #0
8f61dc78:	1a000001 	bne	8f61dc84 <dwc_event_processed+0x44>
8f61dc7c:	e28dd00c 	add	r13, r13, #12
8f61dc80:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61dc84:	eb0053cd 	bl	8f632bc0 <__stack_chk_fail>
8f61dc88:	8f74221c 	.word	0x8f74221c

8f61dc8c <dwc_event_device_enable>:
/* enable device event generation:
 * events - bit map of events defined in dwc_event_device_event_id_t
 */
void dwc_event_device_enable(dwc_dev_t *dev, uint32_t events)
{
	REG_WRITE(dev, DEVTEN, events);
8f61dc8c:	e5903000 	ldr	r3, [r0]
{
8f61dc90:	e59f203c 	ldr	r2, [pc, #60]	; 8f61dcd4 <dwc_event_device_enable+0x48>
	REG_WRITE(dev, DEVTEN, events);
8f61dc94:	e2833903 	add	r3, r3, #49152	; 0xc000
{
8f61dc98:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61dc9c:	e24dd00c 	sub	r13, r13, #12
8f61dca0:	e5922000 	ldr	r2, [r2]
8f61dca4:	e58d2004 	str	r2, [r13, #4]
8f61dca8:	e3a02000 	mov	r2, #0
	REG_WRITE(dev, DEVTEN, events);
8f61dcac:	e5831708 	str	r1, [r3, #1800]	; 0x708
}
8f61dcb0:	e59f301c 	ldr	r3, [pc, #28]	; 8f61dcd4 <dwc_event_device_enable+0x48>
8f61dcb4:	e5932000 	ldr	r2, [r3]
8f61dcb8:	e59d3004 	ldr	r3, [r13, #4]
8f61dcbc:	e0332002 	eors	r2, r3, r2
8f61dcc0:	e3a03000 	mov	r3, #0
8f61dcc4:	1a000001 	bne	8f61dcd0 <dwc_event_device_enable+0x44>
8f61dcc8:	e28dd00c 	add	r13, r13, #12
8f61dccc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61dcd0:	eb0053ba 	bl	8f632bc0 <__stack_chk_fail>
8f61dcd4:	8f74221c 	.word	0x8f74221c

8f61dcd8 <dwc_phy_digital_reset>:

/*************** Generic APIs affecting overall controller ********************/

/* reset HS and SS PHY's digital interface: UTMI + PIPE3 */
void dwc_phy_digital_reset(dwc_dev_t *dev)
{
8f61dcd8:	e59f30a8 	ldr	r3, [pc, #168]	; 8f61dd88 <dwc_phy_digital_reset+0xb0>
8f61dcdc:	e92d4010 	push	{r4, r14}
8f61dce0:	e24dd008 	sub	r13, r13, #8
8f61dce4:	e5933000 	ldr	r3, [r3]
8f61dce8:	e58d3004 	str	r3, [r13, #4]
8f61dcec:	e3a03000 	mov	r3, #0
	REG_WRITE_FIELDI(dev, GUSB2PHYCFG,  0, PHYSOFTRST, 1);
8f61dcf0:	e5903000 	ldr	r3, [r0]
{
8f61dcf4:	e1a04000 	mov	r4, r0
	REG_WRITE_FIELDI(dev, GUSB2PHYCFG,  0, PHYSOFTRST, 1);
8f61dcf8:	e2833903 	add	r3, r3, #49152	; 0xc000
8f61dcfc:	e5932200 	ldr	r2, [r3, #512]	; 0x200
8f61dd00:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
8f61dd04:	e5832200 	str	r2, [r3, #512]	; 0x200
	if (!use_hsonly_mode())
8f61dd08:	ebfff14c 	bl	8f61a240 <use_hsonly_mode>
8f61dd0c:	e3500000 	cmp	r0, #0
		REG_WRITE_FIELDI(dev, GUSB3PIPECTL, 0, PHYSOFTRST, 1);

	/* per HPG */
	udelay(100);
8f61dd10:	e3a00064 	mov	r0, #100	; 0x64
		REG_WRITE_FIELDI(dev, GUSB3PIPECTL, 0, PHYSOFTRST, 1);
8f61dd14:	05943000 	ldreq	r3, [r4]
8f61dd18:	02833903 	addeq	r3, r3, #49152	; 0xc000
8f61dd1c:	059322c0 	ldreq	r2, [r3, #704]	; 0x2c0
8f61dd20:	03822102 	orreq	r2, r2, #-2147483648	; 0x80000000
8f61dd24:	058322c0 	streq	r2, [r3, #704]	; 0x2c0
	udelay(100);
8f61dd28:	ebffc40b 	bl	8f60ed5c <udelay>

	REG_WRITE_FIELDI(dev, GUSB2PHYCFG,  0, PHYSOFTRST, 0);
8f61dd2c:	e5943000 	ldr	r3, [r4]
8f61dd30:	e2833903 	add	r3, r3, #49152	; 0xc000
8f61dd34:	e5932200 	ldr	r2, [r3, #512]	; 0x200
8f61dd38:	e3c22102 	bic	r2, r2, #-2147483648	; 0x80000000
8f61dd3c:	e5832200 	str	r2, [r3, #512]	; 0x200
	if (!use_hsonly_mode())
8f61dd40:	ebfff13e 	bl	8f61a240 <use_hsonly_mode>
8f61dd44:	e3500000 	cmp	r0, #0
		REG_WRITE_FIELDI(dev, GUSB3PIPECTL, 0, PHYSOFTRST, 0);
8f61dd48:	05943000 	ldreq	r3, [r4]
8f61dd4c:	02833903 	addeq	r3, r3, #49152	; 0xc000
8f61dd50:	059322c0 	ldreq	r2, [r3, #704]	; 0x2c0
8f61dd54:	03c22102 	biceq	r2, r2, #-2147483648	; 0x80000000
8f61dd58:	058322c0 	streq	r2, [r3, #704]	; 0x2c0

	/* per HPG */
	udelay(100);
8f61dd5c:	e59f3024 	ldr	r3, [pc, #36]	; 8f61dd88 <dwc_phy_digital_reset+0xb0>
8f61dd60:	e5932000 	ldr	r2, [r3]
8f61dd64:	e59d3004 	ldr	r3, [r13, #4]
8f61dd68:	e0332002 	eors	r2, r3, r2
8f61dd6c:	e3a03000 	mov	r3, #0
8f61dd70:	1a000003 	bne	8f61dd84 <dwc_phy_digital_reset+0xac>
8f61dd74:	e3a00064 	mov	r0, #100	; 0x64
}
8f61dd78:	e28dd008 	add	r13, r13, #8
8f61dd7c:	e8bd4010 	pop	{r4, r14}
	udelay(100);
8f61dd80:	eaffc3f5 	b	8f60ed5c <udelay>
8f61dd84:	eb00538d 	bl	8f632bc0 <__stack_chk_fail>
8f61dd88:	8f74221c 	.word	0x8f74221c

8f61dd8c <dwc_ss_phy_workaround_12>:
	udelay(100);
}

/* workaround_12 as described in HPG */
void dwc_ss_phy_workaround_12(dwc_dev_t *dev)
{
8f61dd8c:	e59f3064 	ldr	r3, [pc, #100]	; 8f61ddf8 <dwc_ss_phy_workaround_12+0x6c>
8f61dd90:	e92d4010 	push	{r4, r14}
8f61dd94:	e24dd008 	sub	r13, r13, #8
8f61dd98:	e5933000 	ldr	r3, [r3]
8f61dd9c:	e58d3004 	str	r3, [r13, #4]
8f61dda0:	e3a03000 	mov	r3, #0
8f61dda4:	e1a04000 	mov	r4, r0
	/* 12. */
	if ( platform_is_8974() &&
8f61dda8:	ebfffd23 	bl	8f61d23c <platform_is_8974>
8f61ddac:	e3500000 	cmp	r0, #0
8f61ddb0:	1a000007 	bne	8f61ddd4 <dwc_ss_phy_workaround_12+0x48>
		 (board_soc_version() < BOARD_SOC_VERSION2))
	{
		REG_WRITEI(dev, GUSB3PIPECTL, 0, 0x30C0003);
	}
}
8f61ddb4:	e59f303c 	ldr	r3, [pc, #60]	; 8f61ddf8 <dwc_ss_phy_workaround_12+0x6c>
8f61ddb8:	e5932000 	ldr	r2, [r3]
8f61ddbc:	e59d3004 	ldr	r3, [r13, #4]
8f61ddc0:	e0332002 	eors	r2, r3, r2
8f61ddc4:	e3a03000 	mov	r3, #0
8f61ddc8:	1a000009 	bne	8f61ddf4 <dwc_ss_phy_workaround_12+0x68>
8f61ddcc:	e28dd008 	add	r13, r13, #8
8f61ddd0:	e8bd8010 	pop	{r4, r15}
		 (board_soc_version() < BOARD_SOC_VERSION2))
8f61ddd4:	ebffc98e 	bl	8f610414 <board_soc_version>
	if ( platform_is_8974() &&
8f61ddd8:	e3500802 	cmp	r0, #131072	; 0x20000
		REG_WRITEI(dev, GUSB3PIPECTL, 0, 0x30C0003);
8f61dddc:	35943000 	ldrcc	r3, [r4]
8f61dde0:	33a02003 	movcc	r2, #3
8f61dde4:	3340230c 	movtcc	r2, #780	; 0x30c
8f61dde8:	32833903 	addcc	r3, r3, #49152	; 0xc000
8f61ddec:	358322c0 	strcc	r2, [r3, #704]	; 0x2c0
}
8f61ddf0:	eaffffef 	b	8f61ddb4 <dwc_ss_phy_workaround_12+0x28>
8f61ddf4:	eb005371 	bl	8f632bc0 <__stack_chk_fail>
8f61ddf8:	8f74221c 	.word	0x8f74221c

8f61ddfc <dwc_axi_master_config>:

/*  AXI master config */
void dwc_axi_master_config(dwc_dev_t *dev)
{
8f61ddfc:	e59f3060 	ldr	r3, [pc, #96]	; 8f61de64 <dwc_axi_master_config+0x68>
8f61de00:	e92d4010 	push	{r4, r14}
8f61de04:	e24dd008 	sub	r13, r13, #8
8f61de08:	e5933000 	ldr	r3, [r3]
8f61de0c:	e58d3004 	str	r3, [r13, #4]
8f61de10:	e3a03000 	mov	r3, #0
8f61de14:	e1a04000 	mov	r4, r0
	uint32_t reg = 0;

	/* 17. */
	if ( platform_is_8974() &&
8f61de18:	ebfffd07 	bl	8f61d23c <platform_is_8974>
8f61de1c:	e3500000 	cmp	r0, #0
8f61de20:	1a000007 	bne	8f61de44 <dwc_axi_master_config+0x48>
			   DWC_GSBUSCFG0_INCR8BRSTENA_BMSK |
			   DWC_GSBUSCFG0_INCR16BRSTENA_BMSK);

		REG_WRITE(dev, GSBUSCFG0, reg);
	}
}
8f61de24:	e59f3038 	ldr	r3, [pc, #56]	; 8f61de64 <dwc_axi_master_config+0x68>
8f61de28:	e5932000 	ldr	r2, [r3]
8f61de2c:	e59d3004 	ldr	r3, [r13, #4]
8f61de30:	e0332002 	eors	r2, r3, r2
8f61de34:	e3a03000 	mov	r3, #0
8f61de38:	1a000008 	bne	8f61de60 <dwc_axi_master_config+0x64>
8f61de3c:	e28dd008 	add	r13, r13, #8
8f61de40:	e8bd8010 	pop	{r4, r15}
		 (board_soc_version() < BOARD_SOC_VERSION2))
8f61de44:	ebffc972 	bl	8f610414 <board_soc_version>
	if ( platform_is_8974() &&
8f61de48:	e3500802 	cmp	r0, #131072	; 0x20000
		REG_WRITE(dev, GSBUSCFG0, reg);
8f61de4c:	35943000 	ldrcc	r3, [r4]
8f61de50:	33a0200e 	movcc	r2, #14
8f61de54:	32833903 	addcc	r3, r3, #49152	; 0xc000
8f61de58:	35832100 	strcc	r2, [r3, #256]	; 0x100
}
8f61de5c:	eafffff0 	b	8f61de24 <dwc_axi_master_config+0x28>
8f61de60:	eb005356 	bl	8f632bc0 <__stack_chk_fail>
8f61de64:	8f74221c 	.word	0x8f74221c

8f61de68 <dwc_coreid>:

/* read the controller id and version information */
uint32_t dwc_coreid(dwc_dev_t *dev)
{
8f61de68:	e59f3040 	ldr	r3, [pc, #64]	; 8f61deb0 <dwc_coreid+0x48>
8f61de6c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61de70:	e24dd00c 	sub	r13, r13, #12
8f61de74:	e5933000 	ldr	r3, [r3]
8f61de78:	e58d3004 	str	r3, [r13, #4]
8f61de7c:	e3a03000 	mov	r3, #0
	return REG_READ(dev, GSNPSID);
8f61de80:	e5903000 	ldr	r3, [r0]
8f61de84:	e2833903 	add	r3, r3, #49152	; 0xc000
8f61de88:	e5930120 	ldr	r0, [r3, #288]	; 0x120
}
8f61de8c:	e59f301c 	ldr	r3, [pc, #28]	; 8f61deb0 <dwc_coreid+0x48>
8f61de90:	e5932000 	ldr	r2, [r3]
8f61de94:	e59d3004 	ldr	r3, [r13, #4]
8f61de98:	e0332002 	eors	r2, r3, r2
8f61de9c:	e3a03000 	mov	r3, #0
8f61dea0:	1a000001 	bne	8f61deac <dwc_coreid+0x44>
8f61dea4:	e28dd00c 	add	r13, r13, #12
8f61dea8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61deac:	eb005343 	bl	8f632bc0 <__stack_chk_fail>
8f61deb0:	8f74221c 	.word	0x8f74221c

8f61deb4 <dwc_connectspeed>:

/* read the current connection speed. */
uint8_t dwc_connectspeed(dwc_dev_t *dev)
{
8f61deb4:	e59f3044 	ldr	r3, [pc, #68]	; 8f61df00 <dwc_connectspeed+0x4c>
8f61deb8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61debc:	e24dd00c 	sub	r13, r13, #12
8f61dec0:	e5933000 	ldr	r3, [r3]
8f61dec4:	e58d3004 	str	r3, [r13, #4]
8f61dec8:	e3a03000 	mov	r3, #0
	return REG_READ_FIELD(dev, DSTS, CONNECTSPD);
8f61decc:	e5903000 	ldr	r3, [r0]
8f61ded0:	e2833903 	add	r3, r3, #49152	; 0xc000
8f61ded4:	e593070c 	ldr	r0, [r3, #1804]	; 0x70c
}
8f61ded8:	e59f3020 	ldr	r3, [pc, #32]	; 8f61df00 <dwc_connectspeed+0x4c>
8f61dedc:	e5932000 	ldr	r2, [r3]
8f61dee0:	e59d3004 	ldr	r3, [r13, #4]
8f61dee4:	e0332002 	eors	r2, r3, r2
8f61dee8:	e3a03000 	mov	r3, #0
8f61deec:	1a000002 	bne	8f61defc <dwc_connectspeed+0x48>
8f61def0:	e2000007 	and	r0, r0, #7
8f61def4:	e28dd00c 	add	r13, r13, #12
8f61def8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61defc:	eb00532f 	bl	8f632bc0 <__stack_chk_fail>
8f61df00:	8f74221c 	.word	0x8f74221c

8f61df04 <dwc_ep_disable_non_control>:

/* disable all non-control EPs */
void dwc_ep_disable_non_control(dwc_dev_t *dev)
{
8f61df04:	e59f3048 	ldr	r3, [pc, #72]	; 8f61df54 <dwc_ep_disable_non_control+0x50>
8f61df08:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61df0c:	e24dd00c 	sub	r13, r13, #12
8f61df10:	e5933000 	ldr	r3, [r3]
8f61df14:	e58d3004 	str	r3, [r13, #4]
8f61df18:	e3a03000 	mov	r3, #0
	uint32_t reg = REG_READ(dev, DALEPENA);
8f61df1c:	e5903000 	ldr	r3, [r0]
8f61df20:	e2833903 	add	r3, r3, #49152	; 0xc000
8f61df24:	e5932720 	ldr	r2, [r3, #1824]	; 0x720

	/* clear all except the control IN and OUT ep */
	reg &= 0x3;
8f61df28:	e2022003 	and	r2, r2, #3

	REG_WRITE(dev, DALEPENA, reg);
8f61df2c:	e5832720 	str	r2, [r3, #1824]	; 0x720
}
8f61df30:	e59f301c 	ldr	r3, [pc, #28]	; 8f61df54 <dwc_ep_disable_non_control+0x50>
8f61df34:	e5932000 	ldr	r2, [r3]
8f61df38:	e59d3004 	ldr	r3, [r13, #4]
8f61df3c:	e0332002 	eors	r2, r3, r2
8f61df40:	e3a03000 	mov	r3, #0
8f61df44:	1a000001 	bne	8f61df50 <dwc_ep_disable_non_control+0x4c>
8f61df48:	e28dd00c 	add	r13, r13, #12
8f61df4c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61df50:	eb00531a 	bl	8f632bc0 <__stack_chk_fail>
8f61df54:	8f74221c 	.word	0x8f74221c

8f61df58 <dwc_ep_enable>:
	REG_WRITE(dev, DALEPENA, reg);
}

/* enable a specific ep */
void dwc_ep_enable(dwc_dev_t *dev, uint8_t ep_phy_num)
{
8f61df58:	e59f304c 	ldr	r3, [pc, #76]	; 8f61dfac <dwc_ep_enable+0x54>
8f61df5c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61df60:	e24dd00c 	sub	r13, r13, #12
8f61df64:	e5933000 	ldr	r3, [r3]
8f61df68:	e58d3004 	str	r3, [r13, #4]
8f61df6c:	e3a03000 	mov	r3, #0
	uint32_t reg = REG_READ(dev, DALEPENA);
8f61df70:	e5903000 	ldr	r3, [r0]

	reg |= BIT(ep_phy_num);
8f61df74:	e3a00001 	mov	r0, #1
	uint32_t reg = REG_READ(dev, DALEPENA);
8f61df78:	e2833903 	add	r3, r3, #49152	; 0xc000
8f61df7c:	e5932720 	ldr	r2, [r3, #1824]	; 0x720
	reg |= BIT(ep_phy_num);
8f61df80:	e1822110 	orr	r2, r2, r0, lsl r1

	REG_WRITE(dev, DALEPENA, reg);
8f61df84:	e5832720 	str	r2, [r3, #1824]	; 0x720
}
8f61df88:	e59f301c 	ldr	r3, [pc, #28]	; 8f61dfac <dwc_ep_enable+0x54>
8f61df8c:	e5932000 	ldr	r2, [r3]
8f61df90:	e59d3004 	ldr	r3, [r13, #4]
8f61df94:	e0332002 	eors	r2, r3, r2
8f61df98:	e3a03000 	mov	r3, #0
8f61df9c:	1a000001 	bne	8f61dfa8 <dwc_ep_enable+0x50>
8f61dfa0:	e28dd00c 	add	r13, r13, #12
8f61dfa4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61dfa8:	eb005304 	bl	8f632bc0 <__stack_chk_fail>
8f61dfac:	8f74221c 	.word	0x8f74221c

8f61dfb0 <dwc_reset>:

/* global reset of controller.
 * 1 == put in reset. 0 == out of reset
 */
void dwc_reset(dwc_dev_t *dev, uint8_t reset)
{
8f61dfb0:	e59f3054 	ldr	r3, [pc, #84]	; 8f61e00c <dwc_reset+0x5c>
	/* snps databook table 6-11 indicates this field to be used only for debug
	 * purpose. use dctl.softreset instead for devide mode.
	 * but hpg 4.4.2. 8.a says use this.
	 */
	REG_WRITE_FIELD(dev, GCTL, CORESOFTRESET, reset);
8f61dfb4:	e5902000 	ldr	r2, [r0]
{
8f61dfb8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61dfbc:	e24dd00c 	sub	r13, r13, #12
8f61dfc0:	e5933000 	ldr	r3, [r3]
8f61dfc4:	e58d3004 	str	r3, [r13, #4]
8f61dfc8:	e3a03000 	mov	r3, #0
	REG_WRITE_FIELD(dev, GCTL, CORESOFTRESET, reset);
8f61dfcc:	e2822903 	add	r2, r2, #49152	; 0xc000
8f61dfd0:	e5923110 	ldr	r3, [r2, #272]	; 0x110
8f61dfd4:	e3c33b02 	bic	r3, r3, #2048	; 0x800
8f61dfd8:	e1833581 	orr	r3, r3, r1, lsl #11
8f61dfdc:	e5823110 	str	r3, [r2, #272]	; 0x110

	/* per HPG */
	udelay(100);
8f61dfe0:	e59f3024 	ldr	r3, [pc, #36]	; 8f61e00c <dwc_reset+0x5c>
8f61dfe4:	e5932000 	ldr	r2, [r3]
8f61dfe8:	e59d3004 	ldr	r3, [r13, #4]
8f61dfec:	e0332002 	eors	r2, r3, r2
8f61dff0:	e3a03000 	mov	r3, #0
8f61dff4:	1a000003 	bne	8f61e008 <dwc_reset+0x58>
8f61dff8:	e3a00064 	mov	r0, #100	; 0x64
}
8f61dffc:	e28dd00c 	add	r13, r13, #12
8f61e000:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	udelay(100);
8f61e004:	eaffc354 	b	8f60ed5c <udelay>
8f61e008:	eb0052ec 	bl	8f632bc0 <__stack_chk_fail>
8f61e00c:	8f74221c 	.word	0x8f74221c

8f61e010 <dwc_gctl_init>:

/* initialize global control reg for device mode operation.
 * sequence numbers are as described in HPG.
 */
void dwc_gctl_init(dwc_dev_t *dev)
{
8f61e010:	e59f3098 	ldr	r3, [pc, #152]	; 8f61e0b0 <dwc_gctl_init+0xa0>
8f61e014:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61e018:	e24dd00c 	sub	r13, r13, #12
8f61e01c:	e5933000 	ldr	r3, [r3]
8f61e020:	e58d3004 	str	r3, [r13, #4]
8f61e024:	e3a03000 	mov	r3, #0
	/* 16. */
	/* a. default value is good for RAM clock */
	/* b. default value is good for Disable Debug Attach */
	REG_WRITE_FIELD(dev, GCTL, DEBUGATTACH, 0);
8f61e028:	e5903000 	ldr	r3, [r0]
8f61e02c:	e2833903 	add	r3, r3, #49152	; 0xc000
8f61e030:	e5932110 	ldr	r2, [r3, #272]	; 0x110
8f61e034:	e3c22c01 	bic	r2, r2, #256	; 0x100
8f61e038:	e5832110 	str	r2, [r3, #272]	; 0x110
	/* c & d: disable loopback/local loopback
	 * TODO: possibly for older version. no such fields in GCTL
	 */

	/* e. no soft reset. */
	REG_WRITE_FIELD(dev, GCTL, CORESOFTRESET, 0);
8f61e03c:	e5932110 	ldr	r2, [r3, #272]	; 0x110
8f61e040:	e3c22b02 	bic	r2, r2, #2048	; 0x800
8f61e044:	e5832110 	str	r2, [r3, #272]	; 0x110

	/* f. set port capability direction: device */
	REG_WRITE_FIELD(dev, GCTL, PRTCAPDIR, 0x2);
8f61e048:	e5932110 	ldr	r2, [r3, #272]	; 0x110
8f61e04c:	e3c22a03 	bic	r2, r2, #12288	; 0x3000
8f61e050:	e3822a02 	orr	r2, r2, #8192	; 0x2000
8f61e054:	e5832110 	str	r2, [r3, #272]	; 0x110

	/* g. set scale down value */
	REG_WRITE_FIELD(dev, GCTL, FRMSCLDWN, 0x0);
8f61e058:	e5932110 	ldr	r2, [r3, #272]	; 0x110
8f61e05c:	e3c22903 	bic	r2, r2, #49152	; 0xc000
8f61e060:	e5832110 	str	r2, [r3, #272]	; 0x110

	/* h. enable multiple attempts for SS connection */
	REG_WRITE_FIELD(dev, GCTL, U2RSTECN, 1);
8f61e064:	e5932110 	ldr	r2, [r3, #272]	; 0x110
8f61e068:	e3822801 	orr	r2, r2, #65536	; 0x10000
8f61e06c:	e5832110 	str	r2, [r3, #272]	; 0x110

	/* i. set power down scale of snps phy */
	REG_WRITE_FIELD(dev, GCTL, PWRDNSCALE, 0x2);
8f61e070:	e5932110 	ldr	r2, [r3, #272]	; 0x110
8f61e074:	e7f22052 	ubfx	r2, r2, #0, #19
8f61e078:	e3822601 	orr	r2, r2, #1048576	; 0x100000
8f61e07c:	e5832110 	str	r2, [r3, #272]	; 0x110

	/* j. clear SOFITPSYNC bit */
	REG_WRITE_FIELD(dev, GCTL, SOFITPSYNC, 0);
8f61e080:	e5932110 	ldr	r2, [r3, #272]	; 0x110
8f61e084:	e3c22b01 	bic	r2, r2, #1024	; 0x400
8f61e088:	e5832110 	str	r2, [r3, #272]	; 0x110
}
8f61e08c:	e59f301c 	ldr	r3, [pc, #28]	; 8f61e0b0 <dwc_gctl_init+0xa0>
8f61e090:	e5932000 	ldr	r2, [r3]
8f61e094:	e59d3004 	ldr	r3, [r13, #4]
8f61e098:	e0332002 	eors	r2, r3, r2
8f61e09c:	e3a03000 	mov	r3, #0
8f61e0a0:	1a000001 	bne	8f61e0ac <dwc_gctl_init+0x9c>
8f61e0a4:	e28dd00c 	add	r13, r13, #12
8f61e0a8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61e0ac:	eb0052c3 	bl	8f632bc0 <__stack_chk_fail>
8f61e0b0:	8f74221c 	.word	0x8f74221c

8f61e0b4 <udc_request_complete>:

/* Callback function called by DWC layer when a request to transfer data
 * on non-control EP is completed.
 */
void udc_request_complete(void *context, uint32_t actual, int status)
{
8f61e0b4:	e1a03000 	mov	r3, r0
8f61e0b8:	e59f0070 	ldr	r0, [pc, #112]	; 8f61e130 <udc_request_complete+0x7c>
8f61e0bc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61e0c0:	e24dd00c 	sub	r13, r13, #12
8f61e0c4:	e5900000 	ldr	r0, [r0]
8f61e0c8:	e58d0004 	str	r0, [r13, #4]
8f61e0cc:	e3a00000 	mov	r0, #0
	struct udc_request *req = ((udc_t *) context)->queued_req;
8f61e0d0:	e5930028 	ldr	r0, [r3, #40]	; 0x28

	DBG("\n UDC: udc_request_callback: xferred %d bytes status = %d\n",
		actual, status);

	/* clear the queued request. */
	((udc_t *) context)->queued_req = NULL;
8f61e0d4:	e3a0c000 	mov	r12, #0
8f61e0d8:	e583c028 	str	r12, [r3, #40]	; 0x28

	if (req->complete)
8f61e0dc:	e5903008 	ldr	r3, [r0, #8]
8f61e0e0:	e153000c 	cmp	r3, r12
8f61e0e4:	0a000008 	beq	8f61e10c <udc_request_complete+0x58>
	{
		req->complete(req, actual, status);
8f61e0e8:	e59fc040 	ldr	r12, [pc, #64]	; 8f61e130 <udc_request_complete+0x7c>
8f61e0ec:	e59ce000 	ldr	r14, [r12]
8f61e0f0:	e59dc004 	ldr	r12, [r13, #4]
8f61e0f4:	e03ce00e 	eors	r14, r12, r14
8f61e0f8:	e3a0c000 	mov	r12, #0
8f61e0fc:	1a00000a 	bne	8f61e12c <udc_request_complete+0x78>
	}

	DBG("\n UDC: udc_request_callback: done fastboot callback\n");
}
8f61e100:	e28dd00c 	add	r13, r13, #12
8f61e104:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		req->complete(req, actual, status);
8f61e108:	e12fff13 	bx	r3
}
8f61e10c:	e59f301c 	ldr	r3, [pc, #28]	; 8f61e130 <udc_request_complete+0x7c>
8f61e110:	e5932000 	ldr	r2, [r3]
8f61e114:	e59d3004 	ldr	r3, [r13, #4]
8f61e118:	e0332002 	eors	r2, r3, r2
8f61e11c:	e3a03000 	mov	r3, #0
8f61e120:	1a000001 	bne	8f61e12c <udc_request_complete+0x78>
8f61e124:	e28dd00c 	add	r13, r13, #12
8f61e128:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61e12c:	eb0052a3 	bl	8f632bc0 <__stack_chk_fail>
8f61e130:	8f74221c 	.word	0x8f74221c

8f61e134 <udc_update_ep_desc>:
	 * as the max packet size. As per SS spec the max packet
	 * size for bulk is 1024. Some hosts treat the descriptor
	 * as invalid if the packet size is < 1024. Update the
	 * descriptors once we are notifed with SS connect event
	 */
	for (desc = udc->desc_list; desc; desc = desc->next)
8f61e134:	e590300c 	ldr	r3, [r0, #12]
{
8f61e138:	e59f2084 	ldr	r2, [pc, #132]	; 8f61e1c4 <udc_update_ep_desc+0x90>
	for (desc = udc->desc_list; desc; desc = desc->next)
8f61e13c:	e3530000 	cmp	r3, #0
{
8f61e140:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61e144:	e24dd00c 	sub	r13, r13, #12
8f61e148:	e5922000 	ldr	r2, [r2]
8f61e14c:	e58d2004 	str	r2, [r13, #4]
8f61e150:	e3a02000 	mov	r2, #0
	{
		if (desc->data[EP_BULK_IN_INDEX] == EP_TYPE_BULK)
		{
			desc->data[EP_BULK_IN_INDEX + 1] = max_pkt_sz_bulk;
			desc->data[EP_BULK_IN_INDEX + 2]  = max_pkt_sz_bulk >> 8;
8f61e154:	11a0c421 	lsrne	r12, r1, #8
	for (desc = udc->desc_list; desc; desc = desc->next)
8f61e158:	0a000009 	beq	8f61e184 <udc_update_ep_desc+0x50>
		if (desc->data[EP_BULK_IN_INDEX] == EP_TYPE_BULK)
8f61e15c:	e5d3201e 	ldrb	r2, [r3, #30]
8f61e160:	e3520002 	cmp	r2, #2
		}

		if (desc->data[EP_BULK_OUT_INDEX] == EP_TYPE_BULK)
8f61e164:	e5d3202b 	ldrb	r2, [r3, #43]	; 0x2b
			desc->data[EP_BULK_IN_INDEX + 1] = max_pkt_sz_bulk;
8f61e168:	05c3101f 	strbeq	r1, [r3, #31]
			desc->data[EP_BULK_IN_INDEX + 2]  = max_pkt_sz_bulk >> 8;
8f61e16c:	05c3c020 	strbeq	r12, [r3, #32]
		if (desc->data[EP_BULK_OUT_INDEX] == EP_TYPE_BULK)
8f61e170:	e3520002 	cmp	r2, #2
		{
			desc->data[EP_BULK_OUT_INDEX + 1] = max_pkt_sz_bulk;
8f61e174:	01c312bc 	strheq	r1, [r3, #44]	; 0x2c
	for (desc = udc->desc_list; desc; desc = desc->next)
8f61e178:	e5933000 	ldr	r3, [r3]
8f61e17c:	e3530000 	cmp	r3, #0
8f61e180:	1afffff5 	bne	8f61e15c <udc_update_ep_desc+0x28>
			desc->data[EP_BULK_OUT_INDEX + 2]  = max_pkt_sz_bulk >> 8;
		}
	}

	for (ept = udc->ept_list; ept; ept = ept->next)
8f61e184:	e5903010 	ldr	r3, [r0, #16]
8f61e188:	e3530000 	cmp	r3, #0
8f61e18c:	0a000003 	beq	8f61e1a0 <udc_update_ep_desc+0x6c>
	{
		ept->maxpkt = max_pkt_sz_bulk;
8f61e190:	e1c310b8 	strh	r1, [r3, #8]
	for (ept = udc->ept_list; ept; ept = ept->next)
8f61e194:	e5933000 	ldr	r3, [r3]
8f61e198:	e3530000 	cmp	r3, #0
8f61e19c:	1afffffb 	bne	8f61e190 <udc_update_ep_desc+0x5c>
	}
}
8f61e1a0:	e59f301c 	ldr	r3, [pc, #28]	; 8f61e1c4 <udc_update_ep_desc+0x90>
8f61e1a4:	e5932000 	ldr	r2, [r3]
8f61e1a8:	e59d3004 	ldr	r3, [r13, #4]
8f61e1ac:	e0332002 	eors	r2, r3, r2
8f61e1b0:	e3a03000 	mov	r3, #0
8f61e1b4:	1a000001 	bne	8f61e1c0 <udc_update_ep_desc+0x8c>
8f61e1b8:	e28dd00c 	add	r13, r13, #12
8f61e1bc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61e1c0:	eb00527e 	bl	8f632bc0 <__stack_chk_fail>
8f61e1c4:	8f74221c 	.word	0x8f74221c

8f61e1c8 <udc_descriptor_alloc>:

static struct udc_descriptor *udc_descriptor_alloc(uint32_t type,
												   uint32_t num,
												   uint32_t len,
												   udc_desc_spec_t spec)
{
8f61e1c8:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f61e1cc:	e1a08003 	mov	r8, r3
8f61e1d0:	e59f30f8 	ldr	r3, [pc, #248]	; 8f61e2d0 <udc_descriptor_alloc+0x108>
8f61e1d4:	e24dd014 	sub	r13, r13, #20
8f61e1d8:	e1a05002 	mov	r5, r2
8f61e1dc:	e1a0900e 	mov	r9, r14
8f61e1e0:	e5933000 	ldr	r3, [r3]
8f61e1e4:	e58d300c 	str	r3, [r13, #12]
8f61e1e8:	e3a03000 	mov	r3, #0
	struct udc_descriptor *desc;
	if ((len > 255) || (len < 2) || (num > 255) || (type > 255))
8f61e1ec:	e2423002 	sub	r3, r2, #2
8f61e1f0:	e35300fd 	cmp	r3, #253	; 0xfd
{
8f61e1f4:	e1a07000 	mov	r7, r0
8f61e1f8:	e1a06001 	mov	r6, r1
	if ((len > 255) || (len < 2) || (num > 255) || (type > 255))
8f61e1fc:	8a000016 	bhi	8f61e25c <udc_descriptor_alloc+0x94>
8f61e200:	e35100ff 	cmp	r1, #255	; 0xff
8f61e204:	8a000014 	bhi	8f61e25c <udc_descriptor_alloc+0x94>
	{
		dprintf(CRITICAL, "Invalid parameters for descriptor allocation\n");
		ASSERT(0);
	}

	desc = malloc(sizeof(struct udc_descriptor) + len);
8f61e208:	e285000c 	add	r0, r5, #12
8f61e20c:	eb00577a 	bl	8f633ffc <malloc>
	ASSERT(desc);
8f61e210:	e2504000 	subs	r4, r0, #0
8f61e214:	0a000021 	beq	8f61e2a0 <udc_descriptor_alloc+0xd8>

	desc->next    = 0;
8f61e218:	e3a03000 	mov	r3, #0
8f61e21c:	e5843000 	str	r3, [r4]
	/* descriptor data */
	desc->data[0] = len;
	desc->data[1] = type;

	return desc;
}
8f61e220:	e59f30a8 	ldr	r3, [pc, #168]	; 8f61e2d0 <udc_descriptor_alloc+0x108>
	desc->tag     = (type << 8) | num;
8f61e224:	e1861407 	orr	r1, r6, r7, lsl #8
	desc->spec    = spec;
8f61e228:	e5c48008 	strb	r8, [r4, #8]
	desc->tag     = (type << 8) | num;
8f61e22c:	e1c410b4 	strh	r1, [r4, #4]
	desc->len     = len;
8f61e230:	e1c450b6 	strh	r5, [r4, #6]
	desc->data[0] = len;
8f61e234:	e5c45009 	strb	r5, [r4, #9]
	desc->data[1] = type;
8f61e238:	e5c4700a 	strb	r7, [r4, #10]
}
8f61e23c:	e5932000 	ldr	r2, [r3]
8f61e240:	e59d300c 	ldr	r3, [r13, #12]
8f61e244:	e0332002 	eors	r2, r3, r2
8f61e248:	e3a03000 	mov	r3, #0
8f61e24c:	1a00001e 	bne	8f61e2cc <udc_descriptor_alloc+0x104>
8f61e250:	e1a00004 	mov	r0, r4
8f61e254:	e28dd014 	add	r13, r13, #20
8f61e258:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
		dprintf(CRITICAL, "Invalid parameters for descriptor allocation\n");
8f61e25c:	e3010468 	movw	r0, #5224	; 0x1468
8f61e260:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61e264:	eb0051c2 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f61e268:	e1a00009 	mov	r0, r9
8f61e26c:	e3073f64 	movw	r3, #32612	; 0x7f64
8f61e270:	e3072178 	movw	r2, #29048	; 0x7178
8f61e274:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61e278:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61e27c:	e58d3000 	str	r3, [r13]
8f61e280:	e3001130 	movw	r1, #304	; 0x130
8f61e284:	e3003569 	movw	r3, #1385	; 0x569
8f61e288:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61e28c:	eb00520a 	bl	8f632abc <_panic>
	desc = malloc(sizeof(struct udc_descriptor) + len);
8f61e290:	e285000c 	add	r0, r5, #12
8f61e294:	eb005758 	bl	8f633ffc <malloc>
	ASSERT(desc);
8f61e298:	e2504000 	subs	r4, r0, #0
8f61e29c:	1affffdd 	bne	8f61e218 <udc_descriptor_alloc+0x50>
8f61e2a0:	e1a00009 	mov	r0, r9
8f61e2a4:	e30134b4 	movw	r3, #5300	; 0x14b4
8f61e2a8:	e3072178 	movw	r2, #29048	; 0x7178
8f61e2ac:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61e2b0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61e2b4:	e58d3000 	str	r3, [r13]
8f61e2b8:	e3001130 	movw	r1, #304	; 0x130
8f61e2bc:	e300356d 	movw	r3, #1389	; 0x56d
8f61e2c0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61e2c4:	eb0051fc 	bl	8f632abc <_panic>
8f61e2c8:	eaffffd2 	b	8f61e218 <udc_descriptor_alloc+0x50>
}
8f61e2cc:	eb00523b 	bl	8f632bc0 <__stack_chk_fail>
8f61e2d0:	8f74221c 	.word	0x8f74221c

8f61e2d4 <udc_string_desc_alloc>:
{
8f61e2d4:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f61e2d8:	e24dd008 	sub	r13, r13, #8
	if (udc->next_string_id > 255)
8f61e2dc:	e5908018 	ldr	r8, [r0, #24]
{
8f61e2e0:	e59f30c8 	ldr	r3, [pc, #200]	; 8f61e3b0 <udc_string_desc_alloc+0xdc>
	if (udc->next_string_id > 255)
8f61e2e4:	e35800ff 	cmp	r8, #255	; 0xff
{
8f61e2e8:	e5933000 	ldr	r3, [r3]
8f61e2ec:	e58d3004 	str	r3, [r13, #4]
8f61e2f0:	e3a03000 	mov	r3, #0
	if (udc->next_string_id > 255)
8f61e2f4:	93a05000 	movls	r5, #0
8f61e2f8:	83a05001 	movhi	r5, #1
	if (!str)
8f61e2fc:	e3510000 	cmp	r1, #0
8f61e300:	03855001 	orreq	r5, r5, #1
8f61e304:	e3550000 	cmp	r5, #0
8f61e308:	0a000008 	beq	8f61e330 <udc_string_desc_alloc+0x5c>
		return 0;
8f61e30c:	e3a00000 	mov	r0, #0
}
8f61e310:	e59f3098 	ldr	r3, [pc, #152]	; 8f61e3b0 <udc_string_desc_alloc+0xdc>
8f61e314:	e5932000 	ldr	r2, [r3]
8f61e318:	e59d3004 	ldr	r3, [r13, #4]
8f61e31c:	e0332002 	eors	r2, r3, r2
8f61e320:	e3a03000 	mov	r3, #0
8f61e324:	1a000020 	bne	8f61e3ac <udc_string_desc_alloc+0xd8>
8f61e328:	e28dd008 	add	r13, r13, #8
8f61e32c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
	len = strlen(str);
8f61e330:	e1a07000 	mov	r7, r0
8f61e334:	e1a00001 	mov	r0, r1
8f61e338:	e1a04001 	mov	r4, r1
8f61e33c:	eb005931 	bl	8f634808 <strlen>
	desc = udc_descriptor_alloc(TYPE_STRING,
8f61e340:	e3a03003 	mov	r3, #3
8f61e344:	e1a01008 	mov	r1, r8
								len * 2 + 2,
8f61e348:	e2802001 	add	r2, r0, #1
	len = strlen(str);
8f61e34c:	e1a06000 	mov	r6, r0
	desc = udc_descriptor_alloc(TYPE_STRING,
8f61e350:	e1a00003 	mov	r0, r3
8f61e354:	e1a02082 	lsl	r2, r2, #1
8f61e358:	ebffff9a 	bl	8f61e1c8 <udc_descriptor_alloc>
	if (!desc)
8f61e35c:	e250c000 	subs	r12, r0, #0
8f61e360:	0affffe9 	beq	8f61e30c <udc_string_desc_alloc+0x38>
	udc->next_string_id++;
8f61e364:	e5973018 	ldr	r3, [r7, #24]
	while (len-- > 0) {
8f61e368:	e3560000 	cmp	r6, #0
	udc->next_string_id++;
8f61e36c:	e2833001 	add	r3, r3, #1
8f61e370:	e5873018 	str	r3, [r7, #24]
	while (len-- > 0) {
8f61e374:	0a000007 	beq	8f61e398 <udc_string_desc_alloc+0xc4>
8f61e378:	e0841006 	add	r1, r4, r6
8f61e37c:	e28c300d 	add	r3, r12, #13
		*data++ = *str++;
8f61e380:	e4d42001 	ldrb	r2, [r4], #1
	while (len-- > 0) {
8f61e384:	e2833002 	add	r3, r3, #2
		*data++ = 0;
8f61e388:	e5435003 	strb	r5, [r3, #-3]
	while (len-- > 0) {
8f61e38c:	e1540001 	cmp	r4, r1
		*data++ = *str++;
8f61e390:	e5432004 	strb	r2, [r3, #-4]
	while (len-- > 0) {
8f61e394:	1afffff9 	bne	8f61e380 <udc_string_desc_alloc+0xac>

static void udc_descriptor_register(udc_t *udc, struct udc_descriptor *desc)
{
	desc->next     = udc->desc_list;
8f61e398:	e597300c 	ldr	r3, [r7, #12]
	return desc->tag & 0xff;
8f61e39c:	e5dc0004 	ldrb	r0, [r12, #4]
	desc->next     = udc->desc_list;
8f61e3a0:	e58c3000 	str	r3, [r12]
	udc->desc_list = desc;
8f61e3a4:	e587c00c 	str	r12, [r7, #12]
	return desc->tag & 0xff;
8f61e3a8:	eaffffd8 	b	8f61e310 <udc_string_desc_alloc+0x3c>
}
8f61e3ac:	eb005203 	bl	8f632bc0 <__stack_chk_fail>
8f61e3b0:	8f74221c 	.word	0x8f74221c

8f61e3b4 <udc_register_config_desc_usb20>:
{
8f61e3b4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	ASSERT(udc);
8f61e3b8:	e2508000 	subs	r8, r0, #0
{
8f61e3bc:	e59f3218 	ldr	r3, [pc, #536]	; 8f61e5dc <udc_register_config_desc_usb20+0x228>
8f61e3c0:	e24dd01c 	sub	r13, r13, #28
8f61e3c4:	e1a0400e 	mov	r4, r14
8f61e3c8:	e1a05001 	mov	r5, r1
8f61e3cc:	e5933000 	ldr	r3, [r3]
8f61e3d0:	e58d3014 	str	r3, [r13, #20]
8f61e3d4:	e3a03000 	mov	r3, #0
8f61e3d8:	e1a07002 	mov	r7, r2
	ASSERT(udc);
8f61e3dc:	0a000066 	beq	8f61e57c <udc_register_config_desc_usb20+0x1c8>
	ASSERT(gadget);
8f61e3e0:	e3550000 	cmp	r5, #0
8f61e3e4:	0a000070 	beq	8f61e5ac <udc_register_config_desc_usb20+0x1f8>
		   UDC_DESC_SIZE_INTERFACE +
8f61e3e8:	e5d5400b 	ldrb	r4, [r5, #11]
	desc = udc_descriptor_alloc(type, 0, size, UDC_DESC_SPEC_20);
8f61e3ec:	e3a01000 	mov	r1, #0
8f61e3f0:	e3a03001 	mov	r3, #1
8f61e3f4:	e1a00007 	mov	r0, r7
	data[6] = 0x00;     /* configuration string */
8f61e3f8:	e1a09001 	mov	r9, r1
		   UDC_DESC_SIZE_INTERFACE +
8f61e3fc:	e0644184 	rsb	r4, r4, r4, lsl #3
8f61e400:	e2844012 	add	r4, r4, #18
8f61e404:	e6bf4074 	sxth	r4, r4
	desc = udc_descriptor_alloc(type, 0, size, UDC_DESC_SPEC_20);
8f61e408:	e1a02004 	mov	r2, r4
8f61e40c:	ebffff6d 	bl	8f61e1c8 <udc_descriptor_alloc>
	data[0] = 0x09;
8f61e410:	e3a03009 	mov	r3, #9
	data[2] = size;
8f61e414:	e5c0400b 	strb	r4, [r0, #11]
	data[3] = size >> 8;
8f61e418:	e7e74454 	ubfx	r4, r4, #8, #8
	data[0] = 0x09;
8f61e41c:	e5c03009 	strb	r3, [r0, #9]
	desc = udc_descriptor_alloc(type, 0, size, UDC_DESC_SPEC_20);
8f61e420:	e1a06000 	mov	r6, r0
	data[0] = 0x09;
8f61e424:	e5c03012 	strb	r3, [r0, #18]
	data[4] = 0x01;     /* number of interfaces */
8f61e428:	e3a03001 	mov	r3, #1
	data[1] = type;
8f61e42c:	e5c0700a 	strb	r7, [r0, #10]
	data[4] = 0x01;     /* number of interfaces */
8f61e430:	e5c0300d 	strb	r3, [r0, #13]
	data[5] = 0x01;     /* configuration value */
8f61e434:	e5c0300e 	strb	r3, [r0, #14]
	data[7] = 0xC0;     /* attributes: reserved and self-powered set */
8f61e438:	e3e0303f 	mvn	r3, #63	; 0x3f
	data[6] = 0x00;     /* configuration string */
8f61e43c:	e5c0900f 	strb	r9, [r0, #15]
	data[7] = 0xC0;     /* attributes: reserved and self-powered set */
8f61e440:	e5c03010 	strb	r3, [r0, #16]
	data[1] = TYPE_INTERFACE;
8f61e444:	e3a03004 	mov	r3, #4
	data[8] = 0x00;     /* max power: 0ma since we are self powered */
8f61e448:	e5c09011 	strb	r9, [r0, #17]
	data[2] = 0x00;     /* ifc number */
8f61e44c:	e5c09014 	strb	r9, [r0, #20]
	data[3] = 0x00;     /* alt number */
8f61e450:	e5c09015 	strb	r9, [r0, #21]
	data[3] = size >> 8;
8f61e454:	e5c0400c 	strb	r4, [r0, #12]
	data[1] = TYPE_INTERFACE;
8f61e458:	e5c03013 	strb	r3, [r0, #19]
	data[4] = gadget->ifc_endpoints;
8f61e45c:	e5d5300b 	ldrb	r3, [r5, #11]
8f61e460:	e5c03016 	strb	r3, [r0, #22]
	data[5] = gadget->ifc_class;
8f61e464:	e5d53008 	ldrb	r3, [r5, #8]
8f61e468:	e5c03017 	strb	r3, [r0, #23]
	data[6] = gadget->ifc_subclass;
8f61e46c:	e5d53009 	ldrb	r3, [r5, #9]
8f61e470:	e5c03018 	strb	r3, [r0, #24]
	data[7] = gadget->ifc_protocol;
8f61e474:	e5d5300a 	ldrb	r3, [r5, #10]
8f61e478:	e5c03019 	strb	r3, [r0, #25]
	data[8] = udc_string_desc_alloc(udc, gadget->ifc_string);
8f61e47c:	e1a00008 	mov	r0, r8
8f61e480:	e595100c 	ldr	r1, [r5, #12]
8f61e484:	ebffff92 	bl	8f61e2d4 <udc_string_desc_alloc>
8f61e488:	e5c6001a 	strb	r0, [r6, #26]
	for (uint8_t n = 0; n < gadget->ifc_endpoints; n++) {
8f61e48c:	e5d5300b 	ldrb	r3, [r5, #11]
8f61e490:	e1530009 	cmp	r3, r9
8f61e494:	0a00002d 	beq	8f61e550 <udc_register_config_desc_usb20+0x19c>
	if (type == TYPE_OTHER_SPEED_CONFIG && udc_dev->speed != UDC_SPEED_SS)
8f61e498:	e30d318c 	movw	r3, #53644	; 0xd18c
8f61e49c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f61e4a0:	e1a0e009 	mov	r14, r9
8f61e4a4:	e1a02009 	mov	r2, r9
8f61e4a8:	e5933000 	ldr	r3, [r3]
	data[0] = 7;
8f61e4ac:	e3a0b007 	mov	r11, #7
	data[1] = TYPE_ENDPOINT;
8f61e4b0:	e3a0a005 	mov	r10, #5
	data[3] = 0x02; /* bulk -- the only kind we support */
8f61e4b4:	e3a09002 	mov	r9, #2
	data[6] = 0; /* bInterval: must be 0 for bulk. */
8f61e4b8:	e1a0000e 	mov	r0, r14
	if (type == TYPE_OTHER_SPEED_CONFIG && udc_dev->speed != UDC_SPEED_SS)
8f61e4bc:	e58d300c 	str	r3, [r13, #12]
8f61e4c0:	e2863022 	add	r3, r6, #34	; 0x22
8f61e4c4:	ea000013 	b	8f61e518 <udc_register_config_desc_usb20+0x164>
		max_pkt_sz = ept->maxpkt;
8f61e4c8:	e1d120b8 	ldrh	r2, [r1, #8]
	data[4] = max_pkt_sz;
8f61e4cc:	e6ef4072 	uxtb	r4, r2
	data[5] = max_pkt_sz >> 8;
8f61e4d0:	e1a02422 	lsr	r2, r2, #8
	data[0] = 7;
8f61e4d4:	e543b007 	strb	r11, [r3, #-7]
	for (uint8_t n = 0; n < gadget->ifc_endpoints; n++) {
8f61e4d8:	e28ee001 	add	r14, r14, #1
	data[1] = TYPE_ENDPOINT;
8f61e4dc:	e543a006 	strb	r10, [r3, #-6]
	for (uint8_t n = 0; n < gadget->ifc_endpoints; n++) {
8f61e4e0:	e2833007 	add	r3, r3, #7
	data[2] = ept->num | (ept->in ? 0x80 : 0x00);
8f61e4e4:	e5d1c006 	ldrb	r12, [r1, #6]
8f61e4e8:	e5d11004 	ldrb	r1, [r1, #4]
8f61e4ec:	e35c0000 	cmp	r12, #0
	data[5] = max_pkt_sz >> 8;
8f61e4f0:	e5432009 	strb	r2, [r3, #-9]
	data[2] = ept->num | (ept->in ? 0x80 : 0x00);
8f61e4f4:	13811080 	orrne	r1, r1, #128	; 0x80
	data[3] = 0x02; /* bulk -- the only kind we support */
8f61e4f8:	e543900b 	strb	r9, [r3, #-11]
	data[2] = ept->num | (ept->in ? 0x80 : 0x00);
8f61e4fc:	e543100c 	strb	r1, [r3, #-12]
	for (uint8_t n = 0; n < gadget->ifc_endpoints; n++) {
8f61e500:	e6ef207e 	uxtb	r2, r14
	data[4] = max_pkt_sz;
8f61e504:	e543400a 	strb	r4, [r3, #-10]
	data[6] = 0; /* bInterval: must be 0 for bulk. */
8f61e508:	e5430008 	strb	r0, [r3, #-8]
	for (uint8_t n = 0; n < gadget->ifc_endpoints; n++) {
8f61e50c:	e5d5100b 	ldrb	r1, [r5, #11]
8f61e510:	e1510002 	cmp	r1, r2
8f61e514:	9a00000d 	bls	8f61e550 <udc_register_config_desc_usb20+0x19c>
		udc_ept_desc_fill(gadget->ept[n], data, type);
8f61e518:	e5951014 	ldr	r1, [r5, #20]
	if (type == TYPE_OTHER_SPEED_CONFIG && udc_dev->speed != UDC_SPEED_SS)
8f61e51c:	e3570007 	cmp	r7, #7
		udc_ept_desc_fill(gadget->ept[n], data, type);
8f61e520:	e7911102 	ldr	r1, [r1, r2, lsl #2]
	if (type == TYPE_OTHER_SPEED_CONFIG && udc_dev->speed != UDC_SPEED_SS)
8f61e524:	1affffe7 	bne	8f61e4c8 <udc_register_config_desc_usb20+0x114>
8f61e528:	e59d200c 	ldr	r2, [r13, #12]
8f61e52c:	e5d22024 	ldrb	r2, [r2, #36]	; 0x24
8f61e530:	e3520003 	cmp	r2, #3
8f61e534:	0affffe3 	beq	8f61e4c8 <udc_register_config_desc_usb20+0x114>
		max_pkt_sz = (udc_dev->speed == UDC_SPEED_FS) ? 512 : 64;
8f61e538:	e3520001 	cmp	r2, #1
8f61e53c:	03a02002 	moveq	r2, #2
8f61e540:	13a02000 	movne	r2, #0
8f61e544:	03a04000 	moveq	r4, #0
8f61e548:	13a04040 	movne	r4, #64	; 0x40
8f61e54c:	eaffffe0 	b	8f61e4d4 <udc_register_config_desc_usb20+0x120>
	desc->next     = udc->desc_list;
8f61e550:	e598300c 	ldr	r3, [r8, #12]
8f61e554:	e5863000 	str	r3, [r6]
}
8f61e558:	e59f307c 	ldr	r3, [pc, #124]	; 8f61e5dc <udc_register_config_desc_usb20+0x228>
	udc->desc_list = desc;
8f61e55c:	e588600c 	str	r6, [r8, #12]
}
8f61e560:	e5932000 	ldr	r2, [r3]
8f61e564:	e59d3014 	ldr	r3, [r13, #20]
8f61e568:	e0332002 	eors	r2, r3, r2
8f61e56c:	e3a03000 	mov	r3, #0
8f61e570:	1a000018 	bne	8f61e5d8 <udc_register_config_desc_usb20+0x224>
8f61e574:	e28dd01c 	add	r13, r13, #28
8f61e578:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	ASSERT(udc);
8f61e57c:	e3073198 	movw	r3, #29080	; 0x7198
8f61e580:	e3072178 	movw	r2, #29048	; 0x7178
8f61e584:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61e588:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61e58c:	e58d3000 	str	r3, [r13]
8f61e590:	e3001130 	movw	r1, #304	; 0x130
8f61e594:	e3a03d11 	mov	r3, #1088	; 0x440
8f61e598:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61e59c:	e1a0000e 	mov	r0, r14
8f61e5a0:	eb005145 	bl	8f632abc <_panic>
	ASSERT(gadget);
8f61e5a4:	e3550000 	cmp	r5, #0
8f61e5a8:	1affff8e 	bne	8f61e3e8 <udc_register_config_desc_usb20+0x34>
8f61e5ac:	e307319c 	movw	r3, #29084	; 0x719c
8f61e5b0:	e1a00004 	mov	r0, r4
8f61e5b4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61e5b8:	e3072178 	movw	r2, #29048	; 0x7178
8f61e5bc:	e58d3000 	str	r3, [r13]
8f61e5c0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61e5c4:	e3003441 	movw	r3, #1089	; 0x441
8f61e5c8:	e3001130 	movw	r1, #304	; 0x130
8f61e5cc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61e5d0:	eb005139 	bl	8f632abc <_panic>
8f61e5d4:	eaffff83 	b	8f61e3e8 <udc_register_config_desc_usb20+0x34>
}
8f61e5d8:	eb005178 	bl	8f632bc0 <__stack_chk_fail>
8f61e5dc:	8f74221c 	.word	0x8f74221c

8f61e5e0 <udc_handle_setup>:
{
8f61e5e0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	ASSERT(udc);
8f61e5e4:	e2504000 	subs	r4, r0, #0
{
8f61e5e8:	e59f3800 	ldr	r3, [pc, #2048]	; 8f61edf0 <udc_handle_setup+0x810>
8f61e5ec:	e24dd024 	sub	r13, r13, #36	; 0x24
8f61e5f0:	e1a0500e 	mov	r5, r14
8f61e5f4:	e1a08001 	mov	r8, r1
8f61e5f8:	e5933000 	ldr	r3, [r3]
8f61e5fc:	e58d301c 	str	r3, [r13, #28]
8f61e600:	e3a03000 	mov	r3, #0
	ASSERT(udc);
8f61e604:	0a0000ff 	beq	8f61ea08 <udc_handle_setup+0x428>
	dwc_dev_t *dwc = udc->dwc;
8f61e608:	e5947004 	ldr	r7, [r4, #4]
	ASSERT(dwc);
8f61e60c:	e3570000 	cmp	r7, #0
8f61e610:	0a000109 	beq	8f61ea3c <udc_handle_setup+0x45c>
	struct setup_packet s = *((struct setup_packet*) data);
8f61e614:	e1d830b0 	ldrh	r3, [r8]
8f61e618:	e1d820b4 	ldrh	r2, [r8, #4]
8f61e61c:	e6bf3fb3 	rev16	r3, r3
8f61e620:	e5d8b000 	ldrb	r11, [r8]
8f61e624:	e5d89001 	ldrb	r9, [r8, #1]
8f61e628:	e6ff3073 	uxth	r3, r3
8f61e62c:	e1d860b2 	ldrh	r6, [r8, #2]
	switch (SETUP(s.type, s.request))
8f61e630:	e3530031 	cmp	r3, #49	; 0x31
	struct setup_packet s = *((struct setup_packet*) data);
8f61e634:	e1d8a0b6 	ldrh	r10, [r8, #6]
8f61e638:	e6ff8072 	uxth	r8, r2
	switch (SETUP(s.type, s.request))
8f61e63c:	0a0000ef 	beq	8f61ea00 <udc_handle_setup+0x420>
8f61e640:	da000063 	ble	8f61e7d4 <udc_handle_setup+0x1f4>
8f61e644:	e3002203 	movw	r2, #515	; 0x203
8f61e648:	e1530002 	cmp	r3, r2
8f61e64c:	0a000134 	beq	8f61eb24 <udc_handle_setup+0x544>
8f61e650:	e3530f81 	cmp	r3, #516	; 0x204
8f61e654:	ba00004d 	blt	8f61e790 <udc_handle_setup+0x1b0>
8f61e658:	e3082008 	movw	r2, #32776	; 0x8008
8f61e65c:	e1530002 	cmp	r3, r2
8f61e660:	0a000100 	beq	8f61ea68 <udc_handle_setup+0x488>
8f61e664:	da00001b 	ble	8f61e6d8 <udc_handle_setup+0xf8>
8f61e668:	e2833c7f 	add	r3, r3, #32512	; 0x7f00
8f61e66c:	e3c33c01 	bic	r3, r3, #256	; 0x100
8f61e670:	e6ff3073 	uxth	r3, r3
8f61e674:	e3530000 	cmp	r3, #0
8f61e678:	0a00010f 	beq	8f61eabc <udc_handle_setup+0x4dc>
	switch (r) {
8f61e67c:	e3590030 	cmp	r9, #48	; 0x30
	ERR("\nSTALL. Unsupported setup req: %s %d %d %d %d %d\n",
8f61e680:	e1a0200b 	mov	r2, r11
8f61e684:	e30701f0 	movw	r0, #29168	; 0x71f0
8f61e688:	e58da008 	str	r10, [r13, #8]
8f61e68c:	930732b4 	movwls	r3, #29364	; 0x72b4
8f61e690:	93483f70 	movtls	r3, #36720	; 0x8f70
8f61e694:	830114c4 	movwhi	r1, #5316	; 0x14c4
8f61e698:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61e69c:	97931109 	ldrls	r1, [r3, r9, lsl #2]
8f61e6a0:	83481f70 	movthi	r1, #36720	; 0x8f70
8f61e6a4:	e1a03009 	mov	r3, r9
8f61e6a8:	e58d8004 	str	r8, [r13, #4]
8f61e6ac:	e58d6000 	str	r6, [r13]
8f61e6b0:	eb0050af 	bl	8f632974 <_dprintf>
	return DWC_SETUP_ERROR;
8f61e6b4:	e3e00000 	mvn	r0, #0
}
8f61e6b8:	e59f3730 	ldr	r3, [pc, #1840]	; 8f61edf0 <udc_handle_setup+0x810>
8f61e6bc:	e5932000 	ldr	r2, [r3]
8f61e6c0:	e59d301c 	ldr	r3, [r13, #28]
8f61e6c4:	e0332002 	eors	r2, r3, r2
8f61e6c8:	e3a03000 	mov	r3, #0
8f61e6cc:	1a0001bc 	bne	8f61edc4 <udc_handle_setup+0x7e4>
8f61e6d0:	e28dd024 	add	r13, r13, #36	; 0x24
8f61e6d4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	switch (SETUP(s.type, s.request))
8f61e6d8:	e3530902 	cmp	r3, #32768	; 0x8000
8f61e6dc:	0a0000f6 	beq	8f61eabc <udc_handle_setup+0x4dc>
8f61e6e0:	e3082006 	movw	r2, #32774	; 0x8006
8f61e6e4:	e1530002 	cmp	r3, r2
8f61e6e8:	1affffe3 	bne	8f61e67c <udc_handle_setup+0x9c>
			if (((s.value >> 8) == TYPE_DEVICE_QUALIFIER) && (udc->speed != UDC_SPEED_SS))
8f61e6ec:	e1a03426 	lsr	r3, r6, #8
8f61e6f0:	e3530006 	cmp	r3, #6
8f61e6f4:	0a00011c 	beq	8f61eb6c <udc_handle_setup+0x58c>
			if (((s.value >> 8) == TYPE_OTHER_SPEED_CONFIG) && (udc->speed != UDC_SPEED_SS)) /* Other speed config */
8f61e6f8:	e3530007 	cmp	r3, #7
8f61e6fc:	0a00016d 	beq	8f61ecb8 <udc_handle_setup+0x6d8>
			for (desc = udc->desc_list; desc; desc = desc->next)
8f61e700:	e594100c 	ldr	r1, [r4, #12]
8f61e704:	e3510000 	cmp	r1, #0
8f61e708:	1a000003 	bne	8f61e71c <udc_handle_setup+0x13c>
8f61e70c:	eaffffda 	b	8f61e67c <udc_handle_setup+0x9c>
8f61e710:	e5911000 	ldr	r1, [r1]
8f61e714:	e3510000 	cmp	r1, #0
8f61e718:	0affffd7 	beq	8f61e67c <udc_handle_setup+0x9c>
				if ((desc->tag == s.value) &&
8f61e71c:	e1d130b4 	ldrh	r3, [r1, #4]
8f61e720:	e1530006 	cmp	r3, r6
8f61e724:	1afffff9 	bne	8f61e710 <udc_handle_setup+0x130>
8f61e728:	e5d43024 	ldrb	r3, [r4, #36]	; 0x24
8f61e72c:	e3530003 	cmp	r3, #3
					(((udc->speed == UDC_SPEED_SS) && (desc->spec & UDC_DESC_SPEC_30)) ||
8f61e730:	e5d13008 	ldrb	r3, [r1, #8]
				if ((desc->tag == s.value) &&
8f61e734:	0a00015c 	beq	8f61ecac <udc_handle_setup+0x6cc>
					  ((udc->speed != UDC_SPEED_SS) && (desc->spec & UDC_DESC_SPEC_20)))
8f61e738:	e3130001 	tst	r3, #1
8f61e73c:	0afffff3 	beq	8f61e710 <udc_handle_setup+0x130>
					if (desc->len > s.length)
8f61e740:	e1d130b6 	ldrh	r3, [r1, #6]
					memcpy(udc->ctrl_tx_buf, desc->data, len);
8f61e744:	e2811009 	add	r1, r1, #9
8f61e748:	e5940020 	ldr	r0, [r4, #32]
						len = s.length;
8f61e74c:	e15a0003 	cmp	r10, r3
8f61e750:	21a0a003 	movcs	r10, r3
					memcpy(udc->ctrl_tx_buf, desc->data, len);
8f61e754:	e1a0200a 	mov	r2, r10
8f61e758:	eb005696 	bl	8f6341b8 <memcpy>
					arch_clean_invalidate_cache_range((addr_t) udc->ctrl_tx_buf, len);
8f61e75c:	e5940020 	ldr	r0, [r4, #32]
8f61e760:	e1a0100a 	mov	r1, r10
8f61e764:	eb000a0d 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
					dwc_transfer_request(udc->dwc,
8f61e768:	e5943020 	ldr	r3, [r4, #32]
8f61e76c:	e5940004 	ldr	r0, [r4, #4]
8f61e770:	e3a01000 	mov	r1, #0
8f61e774:	e3a02001 	mov	r2, #1
8f61e778:	e58d1008 	str	r1, [r13, #8]
8f61e77c:	e58d1004 	str	r1, [r13, #4]
8f61e780:	e58da000 	str	r10, [r13]
8f61e784:	ebfffa3e 	bl	8f61d084 <dwc_transfer_request>
					return DWC_SETUP_3_STAGE;
8f61e788:	e3a00003 	mov	r0, #3
8f61e78c:	eaffffc9 	b	8f61e6b8 <udc_handle_setup+0xd8>
	switch (SETUP(s.type, s.request))
8f61e790:	e3002103 	movw	r2, #259	; 0x103
8f61e794:	e1530002 	cmp	r3, r2
8f61e798:	0a000093 	beq	8f61e9ec <udc_handle_setup+0x40c>
8f61e79c:	e3002201 	movw	r2, #513	; 0x201
8f61e7a0:	e1530002 	cmp	r3, r2
8f61e7a4:	1affffb4 	bne	8f61e67c <udc_handle_setup+0x9c>
			dwc_ep_cmd_clear_stall(dwc, DWC_EP_PHY_NUM(usb_epnum, dir));
8f61e7a8:	e208100f 	and	r1, r8, #15
			dir = ((s.index & USB_EP_DIR_MASK) == USB_EP_DIR_IN) ? 0x1 : 0x0;
8f61e7ac:	e7e083d8 	ubfx	r8, r8, #7, #1
			dwc_ep_cmd_clear_stall(dwc, DWC_EP_PHY_NUM(usb_epnum, dir));
8f61e7b0:	e1a00007 	mov	r0, r7
8f61e7b4:	e1881081 	orr	r1, r8, r1, lsl #1
8f61e7b8:	ebfffb55 	bl	8f61d514 <dwc_ep_cmd_clear_stall>
			stall_ep = false;
8f61e7bc:	e30d3188 	movw	r3, #53640	; 0xd188
8f61e7c0:	e3483f72 	movt	r3, #36722	; 0x8f72
8f61e7c4:	e3a02000 	mov	r2, #0
			return DWC_SETUP_2_STAGE;
8f61e7c8:	e3a00002 	mov	r0, #2
			stall_ep = false;
8f61e7cc:	e5832000 	str	r2, [r3]
			return DWC_SETUP_2_STAGE;
8f61e7d0:	eaffffb8 	b	8f61e6b8 <udc_handle_setup+0xd8>
	switch (SETUP(s.type, s.request))
8f61e7d4:	e3530009 	cmp	r3, #9
8f61e7d8:	ca00000e 	bgt	8f61e818 <udc_handle_setup+0x238>
8f61e7dc:	e3530000 	cmp	r3, #0
8f61e7e0:	0affffa5 	beq	8f61e67c <udc_handle_setup+0x9c>
8f61e7e4:	e2433001 	sub	r3, r3, #1
8f61e7e8:	e3530008 	cmp	r3, #8
8f61e7ec:	979ff103 	ldrls	r15, [r15, r3, lsl #2]
8f61e7f0:	eaffffa1 	b	8f61e67c <udc_handle_setup+0x9c>
8f61e7f4:	8f61e950 	.word	0x8f61e950
8f61e7f8:	8f61e67c 	.word	0x8f61e67c
8f61e7fc:	8f61e98c 	.word	0x8f61e98c
8f61e800:	8f61e67c 	.word	0x8f61e67c
8f61e804:	8f61e9d0 	.word	0x8f61e9d0
8f61e808:	8f61e67c 	.word	0x8f61e67c
8f61e80c:	8f61e67c 	.word	0x8f61e67c
8f61e810:	8f61e67c 	.word	0x8f61e67c
8f61e814:	8f61e85c 	.word	0x8f61e85c
8f61e818:	e3530030 	cmp	r3, #48	; 0x30
8f61e81c:	1affff96 	bne	8f61e67c <udc_handle_setup+0x9c>
			if (s.length > 0) {
8f61e820:	e35a0000 	cmp	r10, #0
8f61e824:	0a000115 	beq	8f61ec80 <udc_handle_setup+0x6a0>
				dwc_transfer_request(udc->dwc,
8f61e828:	e3a02000 	mov	r2, #0
8f61e82c:	e594301c 	ldr	r3, [r4, #28]
8f61e830:	e5940004 	ldr	r0, [r4, #4]
8f61e834:	e3a0cc02 	mov	r12, #512	; 0x200
8f61e838:	e30e1df4 	movw	r1, #60916	; 0xedf4
8f61e83c:	e58d4008 	str	r4, [r13, #8]
8f61e840:	e3481f61 	movt	r1, #36705	; 0x8f61
8f61e844:	e58dc000 	str	r12, [r13]
8f61e848:	e58d1004 	str	r1, [r13, #4]
8f61e84c:	e1a01002 	mov	r1, r2
8f61e850:	ebfffa0b 	bl	8f61d084 <dwc_transfer_request>
				return DWC_SETUP_3_STAGE;
8f61e854:	e3a00003 	mov	r0, #3
8f61e858:	eaffff96 	b	8f61e6b8 <udc_handle_setup+0xd8>
			if (s.value) {
8f61e85c:	e3560000 	cmp	r6, #0
8f61e860:	0a0000bc 	beq	8f61eb58 <udc_handle_setup+0x578>
				for (ept = udc->ept_list; ept; ept = ept->next) {
8f61e864:	e5946010 	ldr	r6, [r4, #16]
8f61e868:	e3560000 	cmp	r6, #0
8f61e86c:	0a000024 	beq	8f61e904 <udc_handle_setup+0x324>
							dprintf(CRITICAL, "udc_handle_setup: DEVICE_WRITE : SET_CONFIGURATION malloc failed for ep\n");
8f61e870:	e307b1a4 	movw	r11, #29092	; 0x71a4
							ASSERT(0);
8f61e874:	e307af64 	movw	r10, #32612	; 0x7f64
8f61e878:	e3079178 	movw	r9, #29048	; 0x7178
							dprintf(CRITICAL, "udc_handle_setup: DEVICE_WRITE : SET_CONFIGURATION malloc failed for ep\n");
8f61e87c:	e348bf70 	movt	r11, #36720	; 0x8f70
							ASSERT(0);
8f61e880:	e348af70 	movt	r10, #36720	; 0x8f70
8f61e884:	e3489f70 	movt	r9, #36720	; 0x8f70
					if (ept->num == 0)
8f61e888:	e5d63004 	ldrb	r3, [r6, #4]
8f61e88c:	e3530000 	cmp	r3, #0
8f61e890:	0a000018 	beq	8f61e8f8 <udc_handle_setup+0x318>
						dwc_ep_t *ep = (dwc_ep_t *) malloc(sizeof(dwc_ep_t));
8f61e894:	e3a00f8e 	mov	r0, #568	; 0x238
8f61e898:	eb0055d7 	bl	8f633ffc <malloc>
						if(!ep)
8f61e89c:	e2508000 	subs	r8, r0, #0
8f61e8a0:	0a000148 	beq	8f61edc8 <udc_handle_setup+0x7e8>
						ep->number        = ept->num;
8f61e8a4:	e5d63004 	ldrb	r3, [r6, #4]
						ep->zlp           = 0;
8f61e8a8:	e3a02000 	mov	r2, #0
						dwc_device_add_ep(dwc, ep);
8f61e8ac:	e1a00007 	mov	r0, r7
8f61e8b0:	e1a01008 	mov	r1, r8
						ep->number        = ept->num;
8f61e8b4:	e5c83000 	strb	r3, [r8]
						ep->dir           = ept->in;
8f61e8b8:	e5d63006 	ldrb	r3, [r6, #6]
8f61e8bc:	e5c83001 	strb	r3, [r8, #1]
						ep->type          = ept->type;
8f61e8c0:	e5d63005 	ldrb	r3, [r6, #5]
8f61e8c4:	e5c83002 	strb	r3, [r8, #2]
						ep->max_pkt_size  = ept->maxpkt;
8f61e8c8:	e1d630b8 	ldrh	r3, [r6, #8]
8f61e8cc:	e1c830b4 	strh	r3, [r8, #4]
						ep->burst_size    = ept->maxburst;
8f61e8d0:	e596300c 	ldr	r3, [r6, #12]
						ep->zlp           = 0;
8f61e8d4:	e5c82006 	strb	r2, [r8, #6]
						ep->burst_size    = ept->maxburst;
8f61e8d8:	e5883008 	str	r3, [r8, #8]
						ep->trb_count     = ept->trb_count;
8f61e8dc:	e5963014 	ldr	r3, [r6, #20]
8f61e8e0:	e5883214 	str	r3, [r8, #532]	; 0x214
						ep->trb           = ept->trb;
8f61e8e4:	e5963010 	ldr	r3, [r6, #16]
8f61e8e8:	e5883210 	str	r3, [r8, #528]	; 0x210
						dwc_device_add_ep(dwc, ep);
8f61e8ec:	ebfff93e 	bl	8f61cdec <dwc_device_add_ep>
							free(ep);
8f61e8f0:	e1a00008 	mov	r0, r8
8f61e8f4:	eb005604 	bl	8f63410c <free>
				for (ept = udc->ept_list; ept; ept = ept->next) {
8f61e8f8:	e5966000 	ldr	r6, [r6]
8f61e8fc:	e3560000 	cmp	r6, #0
8f61e900:	1affffe0 	bne	8f61e888 <udc_handle_setup+0x2a8>
				dwc_device_set_configuration(dwc);
8f61e904:	e1a00007 	mov	r0, r7
8f61e908:	ebfff9a8 	bl	8f61cfb0 <dwc_device_set_configuration>
				if (udc->speed == UDC_SPEED_SS)
8f61e90c:	e5d43024 	ldrb	r3, [r4, #36]	; 0x24
8f61e910:	e3530003 	cmp	r3, #3
8f61e914:	0a00011d 	beq	8f61ed90 <udc_handle_setup+0x7b0>
				udc->gadget->notify(udc_dev->gadget, UDC_EVENT_ONLINE);
8f61e918:	e30d318c 	movw	r3, #53644	; 0xd18c
8f61e91c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f61e920:	e5940008 	ldr	r0, [r4, #8]
8f61e924:	e3a01001 	mov	r1, #1
8f61e928:	e5932000 	ldr	r2, [r3]
8f61e92c:	e5903000 	ldr	r3, [r0]
8f61e930:	e5920008 	ldr	r0, [r2, #8]
8f61e934:	e12fff33 	blx	r3
				udc->usb_state = UDC_CONFIGURED_STATE;
8f61e938:	e3a03002 	mov	r3, #2
				udc->config_selected = 1;
8f61e93c:	e3a02001 	mov	r2, #1
				return DWC_SETUP_2_STAGE;
8f61e940:	e1a00003 	mov	r0, r3
				udc->config_selected = 1;
8f61e944:	e5c42025 	strb	r2, [r4, #37]	; 0x25
				udc->usb_state = UDC_CONFIGURED_STATE;
8f61e948:	e5c4302c 	strb	r3, [r4, #44]	; 0x2c
				return DWC_SETUP_2_STAGE;
8f61e94c:	eaffff59 	b	8f61e6b8 <udc_handle_setup+0xd8>
			if (udc->usb_state == UDC_CONFIGURED_STATE && udc->speed == UDC_SPEED_SS)
8f61e950:	e5d4502c 	ldrb	r5, [r4, #44]	; 0x2c
8f61e954:	e3550002 	cmp	r5, #2
8f61e958:	1affff47 	bne	8f61e67c <udc_handle_setup+0x9c>
8f61e95c:	e5d43024 	ldrb	r3, [r4, #36]	; 0x24
8f61e960:	e3530003 	cmp	r3, #3
8f61e964:	1affff44 	bne	8f61e67c <udc_handle_setup+0x9c>
				if (s.value == U1_ENABLE)
8f61e968:	e3560030 	cmp	r6, #48	; 0x30
8f61e96c:	0a00010a 	beq	8f61ed9c <udc_handle_setup+0x7bc>
				if (s.value == U2_ENABLE)
8f61e970:	e3560031 	cmp	r6, #49	; 0x31
8f61e974:	1affff40 	bne	8f61e67c <udc_handle_setup+0x9c>
					dwc_device_enable_u2(dwc, 0);
8f61e978:	e1a00007 	mov	r0, r7
8f61e97c:	e3a01000 	mov	r1, #0
8f61e980:	ebfffbd9 	bl	8f61d8ec <dwc_device_enable_u2>
					return DWC_SETUP_2_STAGE;
8f61e984:	e1a00005 	mov	r0, r5
8f61e988:	eaffff4a 	b	8f61e6b8 <udc_handle_setup+0xd8>
			if (s.value == TEST_MODE)
8f61e98c:	e3560002 	cmp	r6, #2
8f61e990:	0a0000e8 	beq	8f61ed38 <udc_handle_setup+0x758>
			if (udc->usb_state == UDC_CONFIGURED_STATE && udc->speed == UDC_SPEED_SS)
8f61e994:	e5d4502c 	ldrb	r5, [r4, #44]	; 0x2c
8f61e998:	e3550002 	cmp	r5, #2
8f61e99c:	1affff36 	bne	8f61e67c <udc_handle_setup+0x9c>
8f61e9a0:	e5d43024 	ldrb	r3, [r4, #36]	; 0x24
8f61e9a4:	e3530003 	cmp	r3, #3
8f61e9a8:	1affff33 	bne	8f61e67c <udc_handle_setup+0x9c>
				if (s.value == U1_ENABLE)
8f61e9ac:	e3560030 	cmp	r6, #48	; 0x30
8f61e9b0:	0a0000fe 	beq	8f61edb0 <udc_handle_setup+0x7d0>
				if (s.value == U2_ENABLE)
8f61e9b4:	e3560031 	cmp	r6, #49	; 0x31
8f61e9b8:	1affff2f 	bne	8f61e67c <udc_handle_setup+0x9c>
					dwc_device_enable_u2(dwc, 1);
8f61e9bc:	e1a00007 	mov	r0, r7
8f61e9c0:	e3a01001 	mov	r1, #1
8f61e9c4:	ebfffbc8 	bl	8f61d8ec <dwc_device_enable_u2>
					return DWC_SETUP_2_STAGE;
8f61e9c8:	e1a00005 	mov	r0, r5
8f61e9cc:	eaffff39 	b	8f61e6b8 <udc_handle_setup+0xd8>
			dwc_device_set_addr(dwc, s.value);
8f61e9d0:	e1a00007 	mov	r0, r7
8f61e9d4:	e1a01006 	mov	r1, r6
8f61e9d8:	ebfffb3d 	bl	8f61d6d4 <dwc_device_set_addr>
			udc->usb_state = UDC_ADDRESSED_STATE;
8f61e9dc:	e3a03001 	mov	r3, #1
			return DWC_SETUP_2_STAGE;
8f61e9e0:	e3a00002 	mov	r0, #2
			udc->usb_state = UDC_ADDRESSED_STATE;
8f61e9e4:	e5c4302c 	strb	r3, [r4, #44]	; 0x2c
			return DWC_SETUP_2_STAGE;
8f61e9e8:	eaffff32 	b	8f61e6b8 <udc_handle_setup+0xd8>
			if (s.value == FUNCTION_SUSPEND && udc->speed == UDC_SPEED_SS)
8f61e9ec:	e3560000 	cmp	r6, #0
8f61e9f0:	1affff21 	bne	8f61e67c <udc_handle_setup+0x9c>
8f61e9f4:	e5d43024 	ldrb	r3, [r4, #36]	; 0x24
8f61e9f8:	e3530003 	cmp	r3, #3
8f61e9fc:	1affff1e 	bne	8f61e67c <udc_handle_setup+0x9c>
				return DWC_SETUP_2_STAGE;
8f61ea00:	e3a00002 	mov	r0, #2
8f61ea04:	eaffff2b 	b	8f61e6b8 <udc_handle_setup+0xd8>
	ASSERT(udc);
8f61ea08:	e3071198 	movw	r1, #29080	; 0x7198
8f61ea0c:	e3072178 	movw	r2, #29048	; 0x7178
8f61ea10:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61ea14:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61ea18:	e58d1000 	str	r1, [r13]
8f61ea1c:	e3a03f6b 	mov	r3, #428	; 0x1ac
8f61ea20:	e3001130 	movw	r1, #304	; 0x130
8f61ea24:	e1a0000e 	mov	r0, r14
8f61ea28:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61ea2c:	eb005022 	bl	8f632abc <_panic>
	dwc_dev_t *dwc = udc->dwc;
8f61ea30:	e5947004 	ldr	r7, [r4, #4]
	ASSERT(dwc);
8f61ea34:	e3570000 	cmp	r7, #0
8f61ea38:	1afffef5 	bne	8f61e614 <udc_handle_setup+0x34>
8f61ea3c:	e3003258 	movw	r3, #600	; 0x258
8f61ea40:	e3072178 	movw	r2, #29048	; 0x7178
8f61ea44:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61ea48:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61ea4c:	e58d3000 	str	r3, [r13]
8f61ea50:	e3001130 	movw	r1, #304	; 0x130
8f61ea54:	e30031af 	movw	r3, #431	; 0x1af
8f61ea58:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61ea5c:	e1a00005 	mov	r0, r5
8f61ea60:	eb005015 	bl	8f632abc <_panic>
8f61ea64:	eafffeea 	b	8f61e614 <udc_handle_setup+0x34>
			if ((s.value == 0) && (s.index == 0) && (s.length == 1)) {
8f61ea68:	e1863008 	orr	r3, r6, r8
8f61ea6c:	e35a0001 	cmp	r10, #1
8f61ea70:	03530000 	cmpeq	r3, #0
8f61ea74:	1a00009e 	bne	8f61ecf4 <udc_handle_setup+0x714>
				memcpy(udc->ctrl_tx_buf, &udc->config_selected, len);
8f61ea78:	e3a02001 	mov	r2, #1
8f61ea7c:	e2841025 	add	r1, r4, #37	; 0x25
8f61ea80:	e5940020 	ldr	r0, [r4, #32]
8f61ea84:	eb0055cb 	bl	8f6341b8 <memcpy>
				arch_clean_invalidate_cache_range((addr_t) udc->ctrl_tx_buf, len);
8f61ea88:	e5940020 	ldr	r0, [r4, #32]
8f61ea8c:	e3a01001 	mov	r1, #1
8f61ea90:	eb000942 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
				dwc_transfer_request(udc->dwc,
8f61ea94:	e5943020 	ldr	r3, [r4, #32]
8f61ea98:	e5940004 	ldr	r0, [r4, #4]
8f61ea9c:	e3a01000 	mov	r1, #0
8f61eaa0:	e3a02001 	mov	r2, #1
8f61eaa4:	e58d1008 	str	r1, [r13, #8]
8f61eaa8:	e58d1004 	str	r1, [r13, #4]
8f61eaac:	e58d2000 	str	r2, [r13]
8f61eab0:	ebfff973 	bl	8f61d084 <dwc_transfer_request>
				return DWC_SETUP_3_STAGE;
8f61eab4:	e3a00003 	mov	r0, #3
8f61eab8:	eafffefe 	b	8f61e6b8 <udc_handle_setup+0xd8>
			if (s.length == 2) {
8f61eabc:	e35a0002 	cmp	r10, #2
8f61eac0:	1afffeed 	bne	8f61e67c <udc_handle_setup+0x9c>
				if (s.type == DEVICE_READ || (s.type == ENDPOINT_READ && stall_ep == true))
8f61eac4:	e35b0080 	cmp	r11, #128	; 0x80
				uint16_t status = 0;
8f61eac8:	e3a03000 	mov	r3, #0
8f61eacc:	e1cd31b0 	strh	r3, [r13, #16]
				if (s.type == DEVICE_READ || (s.type == ENDPOINT_READ && stall_ep == true))
8f61ead0:	0a000054 	beq	8f61ec28 <udc_handle_setup+0x648>
8f61ead4:	e35b0082 	cmp	r11, #130	; 0x82
8f61ead8:	0a000090 	beq	8f61ed20 <udc_handle_setup+0x740>
				memcpy(udc->ctrl_tx_buf, &status, len);
8f61eadc:	e3a02002 	mov	r2, #2
8f61eae0:	e28d1010 	add	r1, r13, #16
8f61eae4:	e5940020 	ldr	r0, [r4, #32]
8f61eae8:	eb0055b2 	bl	8f6341b8 <memcpy>
				arch_clean_invalidate_cache_range((addr_t) udc->ctrl_tx_buf, len);
8f61eaec:	e5940020 	ldr	r0, [r4, #32]
8f61eaf0:	e3a01002 	mov	r1, #2
8f61eaf4:	eb000929 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
				dwc_transfer_request(udc->dwc,
8f61eaf8:	e5943020 	ldr	r3, [r4, #32]
8f61eafc:	e5940004 	ldr	r0, [r4, #4]
8f61eb00:	e3a01000 	mov	r1, #0
8f61eb04:	e3a0c002 	mov	r12, #2
8f61eb08:	e3a02001 	mov	r2, #1
8f61eb0c:	e58d1008 	str	r1, [r13, #8]
8f61eb10:	e58d1004 	str	r1, [r13, #4]
8f61eb14:	e58dc000 	str	r12, [r13]
8f61eb18:	ebfff959 	bl	8f61d084 <dwc_transfer_request>
				return DWC_SETUP_3_STAGE;
8f61eb1c:	e3a00003 	mov	r0, #3
8f61eb20:	eafffee4 	b	8f61e6b8 <udc_handle_setup+0xd8>
			if (s.value == ENDPOINT_HALT)
8f61eb24:	e3560000 	cmp	r6, #0
8f61eb28:	1afffed3 	bne	8f61e67c <udc_handle_setup+0x9c>
				dwc_ep_cmd_stall(dwc, DWC_EP_PHY_NUM(usb_epnum, dir));
8f61eb2c:	e208100f 	and	r1, r8, #15
				dir = ((s.index & USB_EP_DIR_MASK) == USB_EP_DIR_IN) ? 0x1 : 0x0;
8f61eb30:	e7e083d8 	ubfx	r8, r8, #7, #1
				dwc_ep_cmd_stall(dwc, DWC_EP_PHY_NUM(usb_epnum, dir));
8f61eb34:	e1a00007 	mov	r0, r7
8f61eb38:	e1881081 	orr	r1, r8, r1, lsl #1
8f61eb3c:	ebfffa5c 	bl	8f61d4b4 <dwc_ep_cmd_stall>
				stall_ep = true;
8f61eb40:	e30d3188 	movw	r3, #53640	; 0xd188
8f61eb44:	e3483f72 	movt	r3, #36722	; 0x8f72
8f61eb48:	e3a02001 	mov	r2, #1
				return DWC_SETUP_2_STAGE;
8f61eb4c:	e3a00002 	mov	r0, #2
				stall_ep = true;
8f61eb50:	e5832000 	str	r2, [r3]
				return DWC_SETUP_2_STAGE;
8f61eb54:	eafffed7 	b	8f61e6b8 <udc_handle_setup+0xd8>
				udc->usb_state = UDC_ADDRESSED_STATE;
8f61eb58:	e3a03001 	mov	r3, #1
				return DWC_SETUP_2_STAGE;
8f61eb5c:	e3a00002 	mov	r0, #2
				udc->config_selected = 0;
8f61eb60:	e5c46025 	strb	r6, [r4, #37]	; 0x25
				udc->usb_state = UDC_ADDRESSED_STATE;
8f61eb64:	e5c4302c 	strb	r3, [r4, #44]	; 0x2c
				return DWC_SETUP_2_STAGE;
8f61eb68:	eafffed2 	b	8f61e6b8 <udc_handle_setup+0xd8>
			if (((s.value >> 8) == TYPE_DEVICE_QUALIFIER) && (udc->speed != UDC_SPEED_SS))
8f61eb6c:	e5d43024 	ldrb	r3, [r4, #36]	; 0x24
8f61eb70:	e3530003 	cmp	r3, #3
8f61eb74:	0afffee1 	beq	8f61e700 <udc_handle_setup+0x120>
				qual.bDeviceClass = udc_dev->gadget->ifc_class;
8f61eb78:	e30d318c 	movw	r3, #53644	; 0xd18c
8f61eb7c:	e3483f72 	movt	r3, #36722	; 0x8f72
				qual.bLength = sizeof(qual);
8f61eb80:	e3a0000a 	mov	r0, #10
				qual.bDescriptorType = TYPE_DEVICE_QUALIFIER;
8f61eb84:	e3a01006 	mov	r1, #6
				qual.bDeviceClass = udc_dev->gadget->ifc_class;
8f61eb88:	e5932000 	ldr	r2, [r3]
				qual.bcdUSB = 0x0200; /* USB2.0 version */
8f61eb8c:	e3a03c02 	mov	r3, #512	; 0x200
				qual.bLength = sizeof(qual);
8f61eb90:	e5cd0010 	strb	r0, [r13, #16]
				struct usb_qualifier_desc qual = {0};
8f61eb94:	e3a05000 	mov	r5, #0
				qual.bDescriptorType = TYPE_DEVICE_QUALIFIER;
8f61eb98:	e5cd1011 	strb	r1, [r13, #17]
				memcpy(udc->ctrl_tx_buf, (void *)&qual, len);
8f61eb9c:	e28d1010 	add	r1, r13, #16
				qual.bcdUSB = 0x0200; /* USB2.0 version */
8f61eba0:	e1cd31b2 	strh	r3, [r13, #18]
				qual.bNumConfigurations = 1;
8f61eba4:	e3a06001 	mov	r6, #1
				qual.bDeviceClass = udc_dev->gadget->ifc_class;
8f61eba8:	e5923008 	ldr	r3, [r2, #8]
				struct usb_qualifier_desc qual = {0};
8f61ebac:	e5cd5019 	strb	r5, [r13, #25]
				memcpy(udc->ctrl_tx_buf, (void *)&qual, len);
8f61ebb0:	e5940020 	ldr	r0, [r4, #32]
				qual.bDeviceClass = udc_dev->gadget->ifc_class;
8f61ebb4:	e5d3c008 	ldrb	r12, [r3, #8]
8f61ebb8:	e5cdc014 	strb	r12, [r13, #20]
				qual.bDeviceSubClass = udc_dev->gadget->ifc_subclass;
8f61ebbc:	e5d3c009 	ldrb	r12, [r3, #9]
8f61ebc0:	e5cdc015 	strb	r12, [r13, #21]
				qual.bDeviceProtocol = udc_dev->gadget->ifc_protocol;
8f61ebc4:	e5d3300a 	ldrb	r3, [r3, #10]
8f61ebc8:	e5cd3016 	strb	r3, [r13, #22]
				qual.bMaxPacketSize0 = (udc_dev->speed == UDC_SPEED_HS) ? 64 : 512;
8f61ebcc:	e5d23024 	ldrb	r3, [r2, #36]	; 0x24
				qual.bNumConfigurations = 1;
8f61ebd0:	e5cd6018 	strb	r6, [r13, #24]
				qual.bMaxPacketSize0 = (udc_dev->speed == UDC_SPEED_HS) ? 64 : 512;
8f61ebd4:	e3530002 	cmp	r3, #2
8f61ebd8:	03a03040 	moveq	r3, #64	; 0x40
8f61ebdc:	11a03005 	movne	r3, r5
				if (sizeof(qual) > s.length)
8f61ebe0:	e35a000a 	cmp	r10, #10
				qual.bMaxPacketSize0 = (udc_dev->speed == UDC_SPEED_HS) ? 64 : 512;
8f61ebe4:	e5cd3017 	strb	r3, [r13, #23]
				if (sizeof(qual) > s.length)
8f61ebe8:	23a0a00a 	movcs	r10, #10
				memcpy(udc->ctrl_tx_buf, (void *)&qual, len);
8f61ebec:	e1a0200a 	mov	r2, r10
8f61ebf0:	eb005570 	bl	8f6341b8 <memcpy>
				arch_clean_invalidate_cache_range((addr_t) udc->ctrl_tx_buf, len);
8f61ebf4:	e5940020 	ldr	r0, [r4, #32]
8f61ebf8:	e1a0100a 	mov	r1, r10
8f61ebfc:	eb0008e7 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
				dwc_transfer_request(udc->dwc,
8f61ec00:	e5943020 	ldr	r3, [r4, #32]
8f61ec04:	e5940004 	ldr	r0, [r4, #4]
8f61ec08:	e1a02006 	mov	r2, r6
8f61ec0c:	e1a01005 	mov	r1, r5
8f61ec10:	e58d5008 	str	r5, [r13, #8]
8f61ec14:	e58d5004 	str	r5, [r13, #4]
8f61ec18:	e58da000 	str	r10, [r13]
8f61ec1c:	ebfff918 	bl	8f61d084 <dwc_transfer_request>
				return DWC_SETUP_3_STAGE;
8f61ec20:	e3a00003 	mov	r0, #3
8f61ec24:	eafffea3 	b	8f61e6b8 <udc_handle_setup+0xd8>
				if (udc->usb_state == UDC_CONFIGURED_STATE && udc->speed == UDC_SPEED_SS)
8f61ec28:	e5d4302c 	ldrb	r3, [r4, #44]	; 0x2c
					status = 1; /* Self-powered is set for device read and Halt bit set for end point read */
8f61ec2c:	e3a02001 	mov	r2, #1
8f61ec30:	e1cd21b0 	strh	r2, [r13, #16]
				if (udc->usb_state == UDC_CONFIGURED_STATE && udc->speed == UDC_SPEED_SS)
8f61ec34:	e3530002 	cmp	r3, #2
8f61ec38:	1affffa7 	bne	8f61eadc <udc_handle_setup+0x4fc>
					if (s.type == DEVICE_READ && dwc_device_u1_enabled(dwc))
8f61ec3c:	e5d43024 	ldrb	r3, [r4, #36]	; 0x24
8f61ec40:	e3530003 	cmp	r3, #3
8f61ec44:	1affffa4 	bne	8f61eadc <udc_handle_setup+0x4fc>
8f61ec48:	e1a00007 	mov	r0, r7
8f61ec4c:	ebfffb54 	bl	8f61d9a4 <dwc_device_u1_enabled>
8f61ec50:	e3500000 	cmp	r0, #0
						status |= (1 << 2); /* Set D2 to indicate U1 is enabled */
8f61ec54:	11dd31b0 	ldrhne	r3, [r13, #16]
8f61ec58:	13833004 	orrne	r3, r3, #4
8f61ec5c:	11cd31b0 	strhne	r3, [r13, #16]
					if (s.type == DEVICE_READ && dwc_device_u2_enabled(dwc))
8f61ec60:	e1a00007 	mov	r0, r7
8f61ec64:	ebfffb62 	bl	8f61d9f4 <dwc_device_u2_enabled>
8f61ec68:	e3500000 	cmp	r0, #0
8f61ec6c:	0affff9a 	beq	8f61eadc <udc_handle_setup+0x4fc>
						status |= (1 << 3); /* Set D3 to indicate U3 is enabled */
8f61ec70:	e1dd31b0 	ldrh	r3, [r13, #16]
8f61ec74:	e3833008 	orr	r3, r3, #8
8f61ec78:	e1cd31b0 	strh	r3, [r13, #16]
8f61ec7c:	eaffff96 	b	8f61eadc <udc_handle_setup+0x4fc>
				ASSERT(0);
8f61ec80:	e1a00005 	mov	r0, r5
8f61ec84:	e3073f64 	movw	r3, #32612	; 0x7f64
8f61ec88:	e3072178 	movw	r2, #29048	; 0x7178
8f61ec8c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61ec90:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61ec94:	e58d3000 	str	r3, [r13]
8f61ec98:	e3001130 	movw	r1, #304	; 0x130
8f61ec9c:	e3003339 	movw	r3, #825	; 0x339
8f61eca0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61eca4:	eb004f84 	bl	8f632abc <_panic>
		break;
8f61eca8:	eafffe73 	b	8f61e67c <udc_handle_setup+0x9c>
					(((udc->speed == UDC_SPEED_SS) && (desc->spec & UDC_DESC_SPEC_30)) ||
8f61ecac:	e3130002 	tst	r3, #2
8f61ecb0:	0afffe96 	beq	8f61e710 <udc_handle_setup+0x130>
8f61ecb4:	eafffea1 	b	8f61e740 <udc_handle_setup+0x160>
			if (((s.value >> 8) == TYPE_OTHER_SPEED_CONFIG) && (udc->speed != UDC_SPEED_SS)) /* Other speed config */
8f61ecb8:	e5d43024 	ldrb	r3, [r4, #36]	; 0x24
8f61ecbc:	e3530003 	cmp	r3, #3
8f61ecc0:	0afffe8e 	beq	8f61e700 <udc_handle_setup+0x120>
				if (!udc_other_speed_cfg)
8f61ecc4:	e30d5190 	movw	r5, #53648	; 0xd190
8f61ecc8:	e3485f72 	movt	r5, #36722	; 0x8f72
8f61eccc:	e5953000 	ldr	r3, [r5]
8f61ecd0:	e3530000 	cmp	r3, #0
8f61ecd4:	1afffe89 	bne	8f61e700 <udc_handle_setup+0x120>
					udc_register_config_desc_usb20(udc, udc->gadget, TYPE_OTHER_SPEED_CONFIG);
8f61ecd8:	e5941008 	ldr	r1, [r4, #8]
8f61ecdc:	e3a02007 	mov	r2, #7
8f61ece0:	e1a00004 	mov	r0, r4
8f61ece4:	ebfffdb2 	bl	8f61e3b4 <udc_register_config_desc_usb20>
					udc_other_speed_cfg = true;
8f61ece8:	e3a03001 	mov	r3, #1
8f61ecec:	e5853000 	str	r3, [r5]
8f61ecf0:	eafffe82 	b	8f61e700 <udc_handle_setup+0x120>
				ASSERT(0);
8f61ecf4:	e1a00005 	mov	r0, r5
8f61ecf8:	e3073f64 	movw	r3, #32612	; 0x7f64
8f61ecfc:	e3072178 	movw	r2, #29048	; 0x7178
8f61ed00:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61ed04:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61ed08:	e58d3000 	str	r3, [r13]
8f61ed0c:	e3001130 	movw	r1, #304	; 0x130
8f61ed10:	e300324f 	movw	r3, #591	; 0x24f
8f61ed14:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61ed18:	eb004f67 	bl	8f632abc <_panic>
		break;
8f61ed1c:	eafffe56 	b	8f61e67c <udc_handle_setup+0x9c>
				if (s.type == DEVICE_READ || (s.type == ENDPOINT_READ && stall_ep == true))
8f61ed20:	e30d3188 	movw	r3, #53640	; 0xd188
8f61ed24:	e3483f72 	movt	r3, #36722	; 0x8f72
8f61ed28:	e5933000 	ldr	r3, [r3]
8f61ed2c:	e3530001 	cmp	r3, #1
8f61ed30:	1affff69 	bne	8f61eadc <udc_handle_setup+0x4fc>
8f61ed34:	eaffffcf 	b	8f61ec78 <udc_handle_setup+0x698>
				switch(dwc->test_mode)
8f61ed38:	e3580c03 	cmp	r8, #768	; 0x300
8f61ed3c:	0a00000b 	beq	8f61ed70 <udc_handle_setup+0x790>
8f61ed40:	8a000007 	bhi	8f61ed64 <udc_handle_setup+0x784>
8f61ed44:	e2483c01 	sub	r3, r8, #256	; 0x100
8f61ed48:	e3c33c01 	bic	r3, r3, #256	; 0x100
8f61ed4c:	e6ff3073 	uxth	r3, r3
8f61ed50:	e3530000 	cmp	r3, #0
8f61ed54:	0a000005 	beq	8f61ed70 <udc_handle_setup+0x790>
				dwc->test_mode = s.index;
8f61ed58:	e2877d47 	add	r7, r7, #4544	; 0x11c0
8f61ed5c:	e1c723b0 	strh	r2, [r7, #48]	; 0x30
8f61ed60:	eaffff26 	b	8f61ea00 <udc_handle_setup+0x420>
8f61ed64:	e3c83c01 	bic	r3, r8, #256	; 0x100
8f61ed68:	e3530b01 	cmp	r3, #1024	; 0x400
8f61ed6c:	1afffff9 	bne	8f61ed58 <udc_handle_setup+0x778>
					dwc->test_mode >>= 8;
8f61ed70:	e2877a01 	add	r7, r7, #4096	; 0x1000
8f61ed74:	e1a08428 	lsr	r8, r8, #8
8f61ed78:	e2872e1f 	add	r2, r7, #496	; 0x1f0
					dwc->is_test_mode = true;
8f61ed7c:	e3a03001 	mov	r3, #1
				return DWC_SETUP_2_STAGE;
8f61ed80:	e3a00002 	mov	r0, #2
					dwc->test_mode >>= 8;
8f61ed84:	e1c280b0 	strh	r8, [r2]
					dwc->is_test_mode = true;
8f61ed88:	e58731ec 	str	r3, [r7, #492]	; 0x1ec
					break;
8f61ed8c:	eafffe49 	b	8f61e6b8 <udc_handle_setup+0xd8>
					dwc_device_accept_u1u2(dwc);
8f61ed90:	e1a00007 	mov	r0, r7
8f61ed94:	ebfffaea 	bl	8f61d944 <dwc_device_accept_u1u2>
8f61ed98:	eafffede 	b	8f61e918 <udc_handle_setup+0x338>
					dwc_device_enable_u1(dwc, 0);
8f61ed9c:	e1a00007 	mov	r0, r7
8f61eda0:	e3a01000 	mov	r1, #0
8f61eda4:	ebfffaba 	bl	8f61d894 <dwc_device_enable_u1>
					return DWC_SETUP_2_STAGE;
8f61eda8:	e1a00005 	mov	r0, r5
8f61edac:	eafffe41 	b	8f61e6b8 <udc_handle_setup+0xd8>
					dwc_device_enable_u1(dwc, 1);
8f61edb0:	e1a00007 	mov	r0, r7
8f61edb4:	e3a01001 	mov	r1, #1
8f61edb8:	ebfffab5 	bl	8f61d894 <dwc_device_enable_u1>
					return DWC_SETUP_2_STAGE;
8f61edbc:	e1a00005 	mov	r0, r5
8f61edc0:	eafffe3c 	b	8f61e6b8 <udc_handle_setup+0xd8>
}
8f61edc4:	eb004f7d 	bl	8f632bc0 <__stack_chk_fail>
							dprintf(CRITICAL, "udc_handle_setup: DEVICE_WRITE : SET_CONFIGURATION malloc failed for ep\n");
8f61edc8:	e1a0000b 	mov	r0, r11
8f61edcc:	eb004ee8 	bl	8f632974 <_dprintf>
							ASSERT(0);
8f61edd0:	e3001130 	movw	r1, #304	; 0x130
8f61edd4:	e3003269 	movw	r3, #617	; 0x269
8f61edd8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61eddc:	e1a02009 	mov	r2, r9
8f61ede0:	e1a00005 	mov	r0, r5
8f61ede4:	e58da000 	str	r10, [r13]
8f61ede8:	eb004f33 	bl	8f632abc <_panic>
8f61edec:	eafffeac 	b	8f61e8a4 <udc_handle_setup+0x2c4>
8f61edf0:	8f74221c 	.word	0x8f74221c

8f61edf4 <udc_control_rx_callback>:
{
8f61edf4:	e59f304c 	ldr	r3, [pc, #76]	; 8f61ee48 <udc_control_rx_callback+0x54>
8f61edf8:	e92d4010 	push	{r4, r14}
8f61edfc:	e1a04000 	mov	r4, r0
8f61ee00:	e24dd008 	sub	r13, r13, #8
	arch_invalidate_cache_range((addr_t) udc->ctrl_rx_buf, actual);
8f61ee04:	e590001c 	ldr	r0, [r0, #28]
{
8f61ee08:	e5933000 	ldr	r3, [r3]
8f61ee0c:	e58d3004 	str	r3, [r13, #4]
8f61ee10:	e3a03000 	mov	r3, #0
	arch_invalidate_cache_range((addr_t) udc->ctrl_rx_buf, actual);
8f61ee14:	eb00086b 	bl	8f620fc8 <arch_invalidate_cache_range>
	dwc_device_set_periodic_param(udc->dwc, 0x65);
8f61ee18:	e59f3028 	ldr	r3, [pc, #40]	; 8f61ee48 <udc_control_rx_callback+0x54>
8f61ee1c:	e5932000 	ldr	r2, [r3]
8f61ee20:	e59d3004 	ldr	r3, [r13, #4]
8f61ee24:	e0332002 	eors	r2, r3, r2
8f61ee28:	e3a03000 	mov	r3, #0
8f61ee2c:	1a000004 	bne	8f61ee44 <udc_control_rx_callback+0x50>
8f61ee30:	e5940004 	ldr	r0, [r4, #4]
8f61ee34:	e3a01065 	mov	r1, #101	; 0x65
}
8f61ee38:	e28dd008 	add	r13, r13, #8
8f61ee3c:	e8bd4010 	pop	{r4, r14}
	dwc_device_set_periodic_param(udc->dwc, 0x65);
8f61ee40:	eafff9e5 	b	8f61d5dc <dwc_device_set_periodic_param>
8f61ee44:	eb004f5d 	bl	8f632bc0 <__stack_chk_fail>
8f61ee48:	8f74221c 	.word	0x8f74221c

8f61ee4c <udc_dwc_notify>:
{
8f61ee4c:	e59f31d8 	ldr	r3, [pc, #472]	; 8f61f02c <udc_dwc_notify+0x1e0>
8f61ee50:	e92d4010 	push	{r4, r14}
8f61ee54:	e24dd010 	sub	r13, r13, #16
8f61ee58:	e5933000 	ldr	r3, [r3]
8f61ee5c:	e58d300c 	str	r3, [r13, #12]
8f61ee60:	e3a03000 	mov	r3, #0
8f61ee64:	e1a04000 	mov	r4, r0
	switch (event)
8f61ee68:	e3510005 	cmp	r1, #5
8f61ee6c:	979ff101 	ldrls	r15, [r15, r1, lsl #2]
8f61ee70:	ea000062 	b	8f61f000 <udc_dwc_notify+0x1b4>
8f61ee74:	8f61ee8c 	.word	0x8f61ee8c
8f61ee78:	8f61eed4 	.word	0x8f61eed4
8f61ee7c:	8f61ef5c 	.word	0x8f61ef5c
8f61ee80:	8f61eefc 	.word	0x8f61eefc
8f61ee84:	8f61efbc 	.word	0x8f61efbc
8f61ee88:	8f61ee8c 	.word	0x8f61ee8c
		if (udc->gadget && udc->gadget->notify)
8f61ee8c:	e5900008 	ldr	r0, [r0, #8]
		udc->config_selected = 0;
8f61ee90:	e3a03000 	mov	r3, #0
8f61ee94:	e5c43025 	strb	r3, [r4, #37]	; 0x25
		if (udc->gadget && udc->gadget->notify)
8f61ee98:	e1500003 	cmp	r0, r3
8f61ee9c:	0a00000e 	beq	8f61eedc <udc_dwc_notify+0x90>
8f61eea0:	e5903000 	ldr	r3, [r0]
8f61eea4:	e3530000 	cmp	r3, #0
8f61eea8:	0a00000b 	beq	8f61eedc <udc_dwc_notify+0x90>
			udc->gadget->notify(udc->gadget, UDC_EVENT_OFFLINE);
8f61eeac:	e59f2178 	ldr	r2, [pc, #376]	; 8f61f02c <udc_dwc_notify+0x1e0>
8f61eeb0:	e5921000 	ldr	r1, [r2]
8f61eeb4:	e59d200c 	ldr	r2, [r13, #12]
8f61eeb8:	e0321001 	eors	r1, r2, r1
8f61eebc:	e3a02000 	mov	r2, #0
8f61eec0:	1a00004d 	bne	8f61effc <udc_dwc_notify+0x1b0>
8f61eec4:	e3a01002 	mov	r1, #2
}
8f61eec8:	e28dd010 	add	r13, r13, #16
8f61eecc:	e8bd4010 	pop	{r4, r14}
			udc->gadget->notify(udc->gadget, UDC_EVENT_OFFLINE);
8f61eed0:	e12fff13 	bx	r3
		udc->speed = UDC_SPEED_LS;
8f61eed4:	e3a03000 	mov	r3, #0
8f61eed8:	e5c03024 	strb	r3, [r0, #36]	; 0x24
}
8f61eedc:	e59f3148 	ldr	r3, [pc, #328]	; 8f61f02c <udc_dwc_notify+0x1e0>
8f61eee0:	e5932000 	ldr	r2, [r3]
8f61eee4:	e59d300c 	ldr	r3, [r13, #12]
8f61eee8:	e0332002 	eors	r2, r3, r2
8f61eeec:	e3a03000 	mov	r3, #0
8f61eef0:	1a000041 	bne	8f61effc <udc_dwc_notify+0x1b0>
8f61eef4:	e28dd010 	add	r13, r13, #16
8f61eef8:	e8bd8010 	pop	{r4, r15}
		udc->speed = UDC_SPEED_HS;
8f61eefc:	e3a03002 	mov	r3, #2
		udc_update_ep_desc(udc, max_pkt_size);
8f61ef00:	e3a01c02 	mov	r1, #512	; 0x200
		udc->speed = UDC_SPEED_HS;
8f61ef04:	e5c03024 	strb	r3, [r0, #36]	; 0x24
		udc_update_ep_desc(udc, max_pkt_size);
8f61ef08:	ebfffc89 	bl	8f61e134 <udc_update_ep_desc>
	if (udc_ss_capable)
8f61ef0c:	e30d3194 	movw	r3, #53652	; 0xd194
8f61ef10:	e3483f72 	movt	r3, #36722	; 0x8f72
8f61ef14:	e593c000 	ldr	r12, [r3]
8f61ef18:	e35c0000 	cmp	r12, #0
8f61ef1c:	1affffee 	bne	8f61eedc <udc_dwc_notify+0x90>
8f61ef20:	e594300c 	ldr	r3, [r4, #12]
	for (desc = udc->desc_list; desc; desc = desc->next)
8f61ef24:	e3530000 	cmp	r3, #0
8f61ef28:	0affffeb 	beq	8f61eedc <udc_dwc_notify+0x90>
		if (desc->spec == UDC_DESC_SPEC_20 && desc->data[1] == TYPE_DEVICE)
8f61ef2c:	e3a000ff 	mov	r0, #255	; 0xff
8f61ef30:	e3a01001 	mov	r1, #1
8f61ef34:	e34000ff 	movt	r0, #255	; 0xff
8f61ef38:	e3401001 	movt	r1, #1
8f61ef3c:	e5932008 	ldr	r2, [r3, #8]
8f61ef40:	e0022000 	and	r2, r2, r0
8f61ef44:	e1520001 	cmp	r2, r1
			desc->data[2] = 0x00; /* usb spec minor rev */
8f61ef48:	05c3c00b 	strbeq	r12, [r3, #11]
	for (desc = udc->desc_list; desc; desc = desc->next)
8f61ef4c:	e5933000 	ldr	r3, [r3]
8f61ef50:	e3530000 	cmp	r3, #0
8f61ef54:	1afffff8 	bne	8f61ef3c <udc_dwc_notify+0xf0>
8f61ef58:	eaffffdf 	b	8f61eedc <udc_dwc_notify+0x90>
		udc->speed = UDC_SPEED_FS;
8f61ef5c:	e3a03001 	mov	r3, #1
		udc_update_ep_desc(udc, max_pkt_size);
8f61ef60:	e3a01040 	mov	r1, #64	; 0x40
		udc->speed = UDC_SPEED_FS;
8f61ef64:	e5c03024 	strb	r3, [r0, #36]	; 0x24
		udc_update_ep_desc(udc, max_pkt_size);
8f61ef68:	ebfffc71 	bl	8f61e134 <udc_update_ep_desc>
	if (udc_ss_capable)
8f61ef6c:	e30d3194 	movw	r3, #53652	; 0xd194
8f61ef70:	e3483f72 	movt	r3, #36722	; 0x8f72
8f61ef74:	e593c000 	ldr	r12, [r3]
8f61ef78:	e35c0000 	cmp	r12, #0
8f61ef7c:	1affffd6 	bne	8f61eedc <udc_dwc_notify+0x90>
8f61ef80:	e594300c 	ldr	r3, [r4, #12]
	for (desc = udc->desc_list; desc; desc = desc->next)
8f61ef84:	e3530000 	cmp	r3, #0
8f61ef88:	0affffd3 	beq	8f61eedc <udc_dwc_notify+0x90>
		if (desc->spec == UDC_DESC_SPEC_20 && desc->data[1] == TYPE_DEVICE)
8f61ef8c:	e3a000ff 	mov	r0, #255	; 0xff
8f61ef90:	e3a01001 	mov	r1, #1
8f61ef94:	e34000ff 	movt	r0, #255	; 0xff
8f61ef98:	e3401001 	movt	r1, #1
8f61ef9c:	e5932008 	ldr	r2, [r3, #8]
8f61efa0:	e0022000 	and	r2, r2, r0
8f61efa4:	e1520001 	cmp	r2, r1
			desc->data[2] = 0x00; /* usb spec minor rev */
8f61efa8:	05c3c00b 	strbeq	r12, [r3, #11]
	for (desc = udc->desc_list; desc; desc = desc->next)
8f61efac:	e5933000 	ldr	r3, [r3]
8f61efb0:	e3530000 	cmp	r3, #0
8f61efb4:	1afffff8 	bne	8f61ef9c <udc_dwc_notify+0x150>
8f61efb8:	eaffffc7 	b	8f61eedc <udc_dwc_notify+0x90>
		udc_ss_capable = true;
8f61efbc:	e30d3194 	movw	r3, #53652	; 0xd194
8f61efc0:	e3483f72 	movt	r3, #36722	; 0x8f72
8f61efc4:	e3a02001 	mov	r2, #1
		udc->speed = UDC_SPEED_SS;
8f61efc8:	e3a01003 	mov	r1, #3
		udc_ss_capable = true;
8f61efcc:	e5832000 	str	r2, [r3]
		udc_update_ep_desc(udc, max_pkt_size);
8f61efd0:	e59f3054 	ldr	r3, [pc, #84]	; 8f61f02c <udc_dwc_notify+0x1e0>
		udc->speed = UDC_SPEED_SS;
8f61efd4:	e5c01024 	strb	r1, [r0, #36]	; 0x24
		udc_update_ep_desc(udc, max_pkt_size);
8f61efd8:	e5932000 	ldr	r2, [r3]
8f61efdc:	e59d300c 	ldr	r3, [r13, #12]
8f61efe0:	e0332002 	eors	r2, r3, r2
8f61efe4:	e3a03000 	mov	r3, #0
8f61efe8:	1a000003 	bne	8f61effc <udc_dwc_notify+0x1b0>
8f61efec:	e3a01b01 	mov	r1, #1024	; 0x400
}
8f61eff0:	e28dd010 	add	r13, r13, #16
8f61eff4:	e8bd4010 	pop	{r4, r14}
		udc_update_ep_desc(udc, max_pkt_size);
8f61eff8:	eafffc4d 	b	8f61e134 <udc_update_ep_desc>
}
8f61effc:	eb004eef 	bl	8f632bc0 <__stack_chk_fail>
		ASSERT(0);
8f61f000:	e307cf64 	movw	r12, #32612	; 0x7f64
8f61f004:	e3072178 	movw	r2, #29048	; 0x7178
8f61f008:	e348cf70 	movt	r12, #36720	; 0x8f70
8f61f00c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61f010:	e3001130 	movw	r1, #304	; 0x130
8f61f014:	e30033f1 	movw	r3, #1009	; 0x3f1
8f61f018:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61f01c:	e1a0000e 	mov	r0, r14
8f61f020:	e58dc000 	str	r12, [r13]
8f61f024:	eb004ea4 	bl	8f632abc <_panic>
}
8f61f028:	eaffffab 	b	8f61eedc <udc_dwc_notify+0x90>
8f61f02c:	8f74221c 	.word	0x8f74221c

8f61f030 <platform_is_8974Pro>:
8f61f030:	e59f3038 	ldr	r3, [pc, #56]	; 8f61f070 <platform_is_8974Pro+0x40>
8f61f034:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61f038:	e24dd00c 	sub	r13, r13, #12
8f61f03c:	e5933000 	ldr	r3, [r3]
8f61f040:	e58d3004 	str	r3, [r13, #4]
8f61f044:	e3a03000 	mov	r3, #0
8f61f048:	e59f3020 	ldr	r3, [pc, #32]	; 8f61f070 <platform_is_8974Pro+0x40>
8f61f04c:	e5932000 	ldr	r2, [r3]
8f61f050:	e59d3004 	ldr	r3, [r13, #4]
8f61f054:	e0332002 	eors	r2, r3, r2
8f61f058:	e3a03000 	mov	r3, #0
8f61f05c:	1a000002 	bne	8f61f06c <platform_is_8974Pro+0x3c>
8f61f060:	e3a00000 	mov	r0, #0
8f61f064:	e28dd00c 	add	r13, r13, #12
8f61f068:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61f06c:	eb004ed3 	bl	8f632bc0 <__stack_chk_fail>
8f61f070:	8f74221c 	.word	0x8f74221c

8f61f074 <usb30_udc_init>:
{
8f61f074:	e59f35e4 	ldr	r3, [pc, #1508]	; 8f61f660 <usb30_udc_init+0x5ec>
8f61f078:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f61f07c:	e1a06000 	mov	r6, r0
8f61f080:	e24dd03c 	sub	r13, r13, #60	; 0x3c
	udc_dev = (udc_t*) malloc(sizeof(udc_t));
8f61f084:	e3a00030 	mov	r0, #48	; 0x30
{
8f61f088:	e5933000 	ldr	r3, [r3]
8f61f08c:	e58d3034 	str	r3, [r13, #52]	; 0x34
8f61f090:	e3a03000 	mov	r3, #0
	udc_dev = (udc_t*) malloc(sizeof(udc_t));
8f61f094:	e1a0800e 	mov	r8, r14
8f61f098:	eb0053d7 	bl	8f633ffc <malloc>
8f61f09c:	e30d718c 	movw	r7, #53644	; 0xd18c
8f61f0a0:	e3487f72 	movt	r7, #36722	; 0x8f72
	ASSERT(udc_dev);
8f61f0a4:	e3500000 	cmp	r0, #0
	udc_dev = (udc_t*) malloc(sizeof(udc_t));
8f61f0a8:	e5870000 	str	r0, [r7]
	ASSERT(udc_dev);
8f61f0ac:	0a000146 	beq	8f61f5cc <usb30_udc_init+0x558>
	memset(udc_dev, 0 , sizeof(udc_t));
8f61f0b0:	e3a02030 	mov	r2, #48	; 0x30
8f61f0b4:	e3a01000 	mov	r1, #0
8f61f0b8:	eb005481 	bl	8f6342c4 <memset>
	udc_dev->ctrl_rx_buf = memalign(CACHE_LINE, ROUNDUP(UDC_CONTROL_RX_BUF_SIZE, CACHE_LINE));
8f61f0bc:	e3a01c02 	mov	r1, #512	; 0x200
8f61f0c0:	e3a00040 	mov	r0, #64	; 0x40
8f61f0c4:	e5974000 	ldr	r4, [r7]
8f61f0c8:	eb0053dd 	bl	8f634044 <memalign>
8f61f0cc:	e584001c 	str	r0, [r4, #28]
	ASSERT(udc_dev->ctrl_rx_buf);
8f61f0d0:	e5974000 	ldr	r4, [r7]
8f61f0d4:	e594301c 	ldr	r3, [r4, #28]
8f61f0d8:	e3530000 	cmp	r3, #0
8f61f0dc:	0a000146 	beq	8f61f5fc <usb30_udc_init+0x588>
	udc_dev->ctrl_tx_buf = memalign(CACHE_LINE, ROUNDUP(UDC_CONTROL_TX_BUF_SIZE, CACHE_LINE));
8f61f0e0:	e3a01c02 	mov	r1, #512	; 0x200
8f61f0e4:	e3a00040 	mov	r0, #64	; 0x40
8f61f0e8:	eb0053d5 	bl	8f634044 <memalign>
	ASSERT(udc_dev->ctrl_tx_buf);
8f61f0ec:	e5973000 	ldr	r3, [r7]
	udc_dev->ctrl_tx_buf = memalign(CACHE_LINE, ROUNDUP(UDC_CONTROL_TX_BUF_SIZE, CACHE_LINE));
8f61f0f0:	e5840020 	str	r0, [r4, #32]
	ASSERT(udc_dev->ctrl_tx_buf);
8f61f0f4:	e5932020 	ldr	r2, [r3, #32]
8f61f0f8:	e3520000 	cmp	r2, #0
8f61f0fc:	0a00014a 	beq	8f61f62c <usb30_udc_init+0x5b8>
	udc_dev->next_string_id  = 1;
8f61f100:	e3a02001 	mov	r2, #1
8f61f104:	e5832018 	str	r2, [r3, #24]
	udc_dev->ept_alloc_table = EPT_TX(0) | EPT_RX(0);
8f61f108:	e3402001 	movt	r2, #1
8f61f10c:	e5832014 	str	r2, [r3, #20]
	udc_dev->ept_list        = NULL;
8f61f110:	e3a02000 	mov	r2, #0
8f61f114:	e5832010 	str	r2, [r3, #16]
	if (dev_info->t_usb_if->clock_init)
8f61f118:	e5963014 	ldr	r3, [r6, #20]
8f61f11c:	e593300c 	ldr	r3, [r3, #12]
8f61f120:	e1530002 	cmp	r3, r2
8f61f124:	0a000000 	beq	8f61f12c <usb30_udc_init+0xb8>
		dev_info->t_usb_if->clock_init();
8f61f128:	e12fff33 	blx	r3
	wrapper = usb_wrapper_init(&wrapper_config);
8f61f12c:	e28d0014 	add	r0, r13, #20
	wrapper_config.qscratch_base = (void*) MSM_USB30_QSCRATCH_BASE;
8f61f130:	e3a03b22 	mov	r3, #34816	; 0x8800
8f61f134:	e340370f 	movt	r3, #1807	; 0x70f
8f61f138:	e58d3014 	str	r3, [r13, #20]
	wrapper = usb_wrapper_init(&wrapper_config);
8f61f13c:	eb0003fe 	bl	8f62013c <usb_wrapper_init>
	ASSERT(wrapper);
8f61f140:	e2504000 	subs	r4, r0, #0
8f61f144:	0a00010a 	beq	8f61f574 <usb30_udc_init+0x500>
	udc_dev->wrapper_dev = wrapper;
8f61f148:	e5973000 	ldr	r3, [r7]
	dwc_config.event_buf      = memalign(lcm(CACHE_LINE, UDC_DWC_EVENT_BUF_SIZE),
8f61f14c:	e3a01a01 	mov	r1, #4096	; 0x1000
8f61f150:	e3a00040 	mov	r0, #64	; 0x40
	udc_dev->wrapper_dev = wrapper;
8f61f154:	e5834000 	str	r4, [r3]
	dwc_config.base           = (void*) MSM_USB30_BASE;
8f61f158:	e3a03407 	mov	r3, #117440512	; 0x7000000
8f61f15c:	e58d3018 	str	r3, [r13, #24]
	dwc_config.event_buf      = memalign(lcm(CACHE_LINE, UDC_DWC_EVENT_BUF_SIZE),
8f61f160:	eb005101 	bl	8f63356c <lcm>
8f61f164:	e3a01a01 	mov	r1, #4096	; 0x1000
8f61f168:	eb0053b5 	bl	8f634044 <memalign>
	ASSERT(dwc_config.event_buf);
8f61f16c:	e3500000 	cmp	r0, #0
	dwc_config.event_buf      = memalign(lcm(CACHE_LINE, UDC_DWC_EVENT_BUF_SIZE),
8f61f170:	e58d001c 	str	r0, [r13, #28]
	ASSERT(dwc_config.event_buf);
8f61f174:	0a000109 	beq	8f61f5a0 <usb30_udc_init+0x52c>
	dwc_config.event_buf_size = UDC_DWC_EVENT_BUF_SIZE;
8f61f178:	e3a03a01 	mov	r3, #4096	; 0x1000
8f61f17c:	e1cd32b0 	strh	r3, [r13, #32]
	dwc_config.notify_context = udc_dev;
8f61f180:	e5973000 	ldr	r3, [r7]
	dwc = dwc_init(&dwc_config);
8f61f184:	e28d0018 	add	r0, r13, #24
	dwc_config.notify_context = udc_dev;
8f61f188:	e58d3024 	str	r3, [r13, #36]	; 0x24
	dwc_config.setup_context = udc_dev;
8f61f18c:	e58d302c 	str	r3, [r13, #44]	; 0x2c
	dwc_config.setup_handler = udc_handle_setup;
8f61f190:	e30e35e0 	movw	r3, #58848	; 0xe5e0
8f61f194:	e3483f61 	movt	r3, #36705	; 0x8f61
8f61f198:	e58d3030 	str	r3, [r13, #48]	; 0x30
	dwc_config.notify         = udc_dwc_notify;
8f61f19c:	e30e3e4c 	movw	r3, #61004	; 0xee4c
8f61f1a0:	e3483f61 	movt	r3, #36705	; 0x8f61
8f61f1a4:	e58d3028 	str	r3, [r13, #40]	; 0x28
	dwc = dwc_init(&dwc_config);
8f61f1a8:	ebfff188 	bl	8f61b7d0 <dwc_init>
	ASSERT(dwc);
8f61f1ac:	e2505000 	subs	r5, r0, #0
8f61f1b0:	0a0000e4 	beq	8f61f548 <usb30_udc_init+0x4d4>
	udc_dev->dwc = dwc;
8f61f1b4:	e5973000 	ldr	r3, [r7]
	usb_wrapper_dbm_mode(wrapper, DBM_MODE_BYPASS);
8f61f1b8:	e3a01000 	mov	r1, #0
8f61f1bc:	e1a00004 	mov	r0, r4
	udc_dev->dwc = dwc;
8f61f1c0:	e5835004 	str	r5, [r3, #4]
	usb_wrapper_dbm_mode(wrapper, DBM_MODE_BYPASS);
8f61f1c4:	eb0002d2 	bl	8f61fd14 <usb_wrapper_dbm_mode>
	usb_wrapper_ram_configure(wrapper);
8f61f1c8:	e1a00004 	mov	r0, r4
8f61f1cc:	eb0002e6 	bl	8f61fd6c <usb_wrapper_ram_configure>
	dwc_reset(dwc, 1);
8f61f1d0:	e3a01001 	mov	r1, #1
8f61f1d4:	e1a00005 	mov	r0, r5
8f61f1d8:	ebfffb74 	bl	8f61dfb0 <dwc_reset>
	if (platform_is_8974() || platform_is_8974Pro())
8f61f1dc:	ebfff816 	bl	8f61d23c <platform_is_8974>
8f61f1e0:	e3500000 	cmp	r0, #0
8f61f1e4:	1a000002 	bne	8f61f1f4 <usb30_udc_init+0x180>
8f61f1e8:	ebffff90 	bl	8f61f030 <platform_is_8974Pro>
8f61f1ec:	e3500000 	cmp	r0, #0
8f61f1f0:	0a0000bf 	beq	8f61f4f4 <usb30_udc_init+0x480>
		usb_wrapper_ss_phy_reset(wrapper);
8f61f1f4:	e1a00004 	mov	r0, r4
8f61f1f8:	eb0002ee 	bl	8f61fdb8 <usb_wrapper_ss_phy_reset>
	if (dev_info->t_usb_if->mux_config)
8f61f1fc:	e5963014 	ldr	r3, [r6, #20]
8f61f200:	e5933000 	ldr	r3, [r3]
8f61f204:	e3530000 	cmp	r3, #0
8f61f208:	0a000000 	beq	8f61f210 <usb30_udc_init+0x19c>
		dev_info->t_usb_if->mux_config();
8f61f20c:	e12fff33 	blx	r3
	if (!use_hsonly_mode())
8f61f210:	ebffec0a 	bl	8f61a240 <use_hsonly_mode>
8f61f214:	e3500000 	cmp	r0, #0
8f61f218:	0a0000c7 	beq	8f61f53c <usb30_udc_init+0x4c8>
	usb_wrapper_hs_phy_init(wrapper);
8f61f21c:	e1a00004 	mov	r0, r4
8f61f220:	eb000337 	bl	8f61ff04 <usb_wrapper_hs_phy_init>
	usb_wrapper_hs_phy_configure(wrapper);
8f61f224:	e1a00004 	mov	r0, r4
8f61f228:	eb00034c 	bl	8f61ff60 <usb_wrapper_hs_phy_configure>
	dwc_phy_digital_reset(dwc);
8f61f22c:	e1a00005 	mov	r0, r5
8f61f230:	ebfffaa8 	bl	8f61dcd8 <dwc_phy_digital_reset>
	dwc_reset(dwc, 0);
8f61f234:	e3a01000 	mov	r1, #0
8f61f238:	e1a00005 	mov	r0, r5
8f61f23c:	ebfffb5b 	bl	8f61dfb0 <dwc_reset>
	usb_wrapper_ss_phy_electrical_config(wrapper);
8f61f240:	e1a00004 	mov	r0, r4
8f61f244:	eb00031e 	bl	8f61fec4 <usb_wrapper_ss_phy_electrical_config>
	if (dev_info->t_usb_if->phy_init)
8f61f248:	e5963014 	ldr	r3, [r6, #20]
8f61f24c:	e5933008 	ldr	r3, [r3, #8]
8f61f250:	e3530000 	cmp	r3, #0
8f61f254:	0a000000 	beq	8f61f25c <usb30_udc_init+0x1e8>
		dev_info->t_usb_if->phy_init();
8f61f258:	e12fff33 	blx	r3
	if (use_hsonly_mode())
8f61f25c:	ebffebf7 	bl	8f61a240 <use_hsonly_mode>
8f61f260:	e3500000 	cmp	r0, #0
8f61f264:	1a0000b1 	bne	8f61f530 <usb30_udc_init+0x4bc>
	usb_wrapper_workaround_10(wrapper);
8f61f268:	e1a00004 	mov	r0, r4
8f61f26c:	eb00034f 	bl	8f61ffb0 <usb_wrapper_workaround_10>
	usb_wrapper_workaround_11(wrapper);
8f61f270:	e1a00004 	mov	r0, r4
8f61f274:	eb000367 	bl	8f620018 <usb_wrapper_workaround_11>
	dwc_ss_phy_workaround_12(dwc);
8f61f278:	e1a00005 	mov	r0, r5
8f61f27c:	ebfffac2 	bl	8f61dd8c <dwc_ss_phy_workaround_12>
	usb_wrapper_workaround_13(wrapper);
8f61f280:	e1a00004 	mov	r0, r4
8f61f284:	eb000373 	bl	8f620058 <usb_wrapper_workaround_13>
	if (dev_info->t_usb_if->vbus_override)
8f61f288:	e5963014 	ldr	r3, [r6, #20]
8f61f28c:	e5d33010 	ldrb	r3, [r3, #16]
8f61f290:	e3530000 	cmp	r3, #0
8f61f294:	1a0000a1 	bne	8f61f520 <usb30_udc_init+0x4ac>
	dwc_device_init(dwc);
8f61f298:	e1a00005 	mov	r0, r5
	desc->data[2] = 0x09;
8f61f29c:	e3a0a009 	mov	r10, #9
	dwc_device_init(dwc);
8f61f2a0:	ebfff649 	bl	8f61cbcc <dwc_device_init>
	struct udc_descriptor *desc = udc_descriptor_alloc(TYPE_STRING,
8f61f2a4:	e3a03003 	mov	r3, #3
8f61f2a8:	e3a02004 	mov	r2, #4
8f61f2ac:	e3a01000 	mov	r1, #0
8f61f2b0:	e1a00003 	mov	r0, r3
	udc_register_language_desc(udc_dev);
8f61f2b4:	e5974000 	ldr	r4, [r7]
	struct udc_descriptor *desc = udc_descriptor_alloc(TYPE_STRING,
8f61f2b8:	ebfffbc2 	bl	8f61e1c8 <udc_descriptor_alloc>
	desc->data[3] = 0x04;
8f61f2bc:	e3a03004 	mov	r3, #4
	desc = udc_descriptor_alloc(TYPE_DEVICE, 0, 18, UDC_DESC_SPEC_20);
8f61f2c0:	e3a02012 	mov	r2, #18
8f61f2c4:	e3a01000 	mov	r1, #0
	udc_register_device_desc_usb_20(udc_dev, dev_info);
8f61f2c8:	e5975000 	ldr	r5, [r7]
	data[3] = 0x02; /* usb spec major rev */
8f61f2cc:	e3a0b002 	mov	r11, #2
	memcpy(data + 10, &dev_info->product_id, sizeof(short));
8f61f2d0:	e086900b 	add	r9, r6, r11
	desc->data[2] = 0x09;
8f61f2d4:	e5c0a00b 	strb	r10, [r0, #11]
	desc->data[3] = 0x04;
8f61f2d8:	e5c0300c 	strb	r3, [r0, #12]
	desc->next     = udc->desc_list;
8f61f2dc:	e594300c 	ldr	r3, [r4, #12]
8f61f2e0:	e5803000 	str	r3, [r0]
	desc = udc_descriptor_alloc(TYPE_DEVICE, 0, 18, UDC_DESC_SPEC_20);
8f61f2e4:	e3a03001 	mov	r3, #1
	udc->desc_list = desc;
8f61f2e8:	e584000c 	str	r0, [r4, #12]
	desc = udc_descriptor_alloc(TYPE_DEVICE, 0, 18, UDC_DESC_SPEC_20);
8f61f2ec:	e1a00003 	mov	r0, r3
8f61f2f0:	ebfffbb4 	bl	8f61e1c8 <udc_descriptor_alloc>
	data[4] = 0x00; /* class */
8f61f2f4:	e3a04000 	mov	r4, #0
	data[7] = 0x40; /* max packet size on ept 0 */
8f61f2f8:	e3a0c040 	mov	r12, #64	; 0x40
	data[2] = 0x10; /* usb spec minor rev */
8f61f2fc:	e3a03010 	mov	r3, #16
	memcpy(data + 8,  &dev_info->vendor_id,  sizeof(short));
8f61f300:	e1a01006 	mov	r1, r6
8f61f304:	e1a0200b 	mov	r2, r11
	desc = udc_descriptor_alloc(TYPE_DEVICE, 0, 18, UDC_DESC_SPEC_20);
8f61f308:	e1a08000 	mov	r8, r0
	data[2] = 0x10; /* usb spec minor rev */
8f61f30c:	e5c0300b 	strb	r3, [r0, #11]
	data[3] = 0x02; /* usb spec major rev */
8f61f310:	e5c0b00c 	strb	r11, [r0, #12]
	memcpy(data + 8,  &dev_info->vendor_id,  sizeof(short));
8f61f314:	e2800011 	add	r0, r0, #17
	data[4] = 0x00; /* class */
8f61f318:	e5404004 	strb	r4, [r0, #-4]
	data[5] = 0x00; /* subclass */
8f61f31c:	e5404003 	strb	r4, [r0, #-3]
	data[6] = 0x00; /* protocol */
8f61f320:	e5404002 	strb	r4, [r0, #-2]
	data[7] = 0x40; /* max packet size on ept 0 */
8f61f324:	e5c8c010 	strb	r12, [r8, #16]
	memcpy(data + 8,  &dev_info->vendor_id,  sizeof(short));
8f61f328:	eb0053a2 	bl	8f6341b8 <memcpy>
	memcpy(data + 10, &dev_info->product_id, sizeof(short));
8f61f32c:	e1a01009 	mov	r1, r9
8f61f330:	e2880013 	add	r0, r8, #19
8f61f334:	e1a0200b 	mov	r2, r11
8f61f338:	e58d900c 	str	r9, [r13, #12]
8f61f33c:	eb00539d 	bl	8f6341b8 <memcpy>
	memcpy(data + 12, &dev_info->version_id, sizeof(short));
8f61f340:	e1a0200b 	mov	r2, r11
8f61f344:	e2861004 	add	r1, r6, #4
8f61f348:	e2880015 	add	r0, r8, #21
	data[17] = 1; /* number of configurations */
8f61f34c:	e3a09001 	mov	r9, #1
	memcpy(data + 12, &dev_info->version_id, sizeof(short));
8f61f350:	eb005398 	bl	8f6341b8 <memcpy>
	data[14] = udc_string_desc_alloc(udc, dev_info->manufacturer);
8f61f354:	e5961008 	ldr	r1, [r6, #8]
8f61f358:	e1a00005 	mov	r0, r5
8f61f35c:	ebfffbdc 	bl	8f61e2d4 <udc_string_desc_alloc>
8f61f360:	e5c80017 	strb	r0, [r8, #23]
	data[15] = udc_string_desc_alloc(udc, dev_info->product);
8f61f364:	e1a00005 	mov	r0, r5
8f61f368:	e596100c 	ldr	r1, [r6, #12]
8f61f36c:	ebfffbd8 	bl	8f61e2d4 <udc_string_desc_alloc>
8f61f370:	e5c80018 	strb	r0, [r8, #24]
	data[16] = udc_string_desc_alloc(udc, dev_info->serialno);
8f61f374:	e1a00005 	mov	r0, r5
8f61f378:	e5961010 	ldr	r1, [r6, #16]
8f61f37c:	ebfffbd4 	bl	8f61e2d4 <udc_string_desc_alloc>
	data[17] = 1; /* number of configurations */
8f61f380:	e5c8901a 	strb	r9, [r8, #26]
	desc = udc_descriptor_alloc(TYPE_DEVICE, 0, 18, UDC_DESC_SPEC_30);
8f61f384:	e1a0300b 	mov	r3, r11
8f61f388:	e1a01004 	mov	r1, r4
	data[16] = udc_string_desc_alloc(udc, dev_info->serialno);
8f61f38c:	e5c80019 	strb	r0, [r8, #25]
	desc = udc_descriptor_alloc(TYPE_DEVICE, 0, 18, UDC_DESC_SPEC_30);
8f61f390:	e1a00009 	mov	r0, r9
	desc->next     = udc->desc_list;
8f61f394:	e595200c 	ldr	r2, [r5, #12]
8f61f398:	e5882000 	str	r2, [r8]
	desc = udc_descriptor_alloc(TYPE_DEVICE, 0, 18, UDC_DESC_SPEC_30);
8f61f39c:	e3a02012 	mov	r2, #18
	udc->desc_list = desc;
8f61f3a0:	e585800c 	str	r8, [r5, #12]
	udc_register_device_desc_usb_30(udc_dev, dev_info);
8f61f3a4:	e5978000 	ldr	r8, [r7]
	desc = udc_descriptor_alloc(TYPE_DEVICE, 0, 18, UDC_DESC_SPEC_30);
8f61f3a8:	ebfffb86 	bl	8f61e1c8 <udc_descriptor_alloc>
	memcpy(data +  8, &dev_info->vendor_id,  sizeof(short));
8f61f3ac:	e1a01006 	mov	r1, r6
8f61f3b0:	e1a0200b 	mov	r2, r11
	desc = udc_descriptor_alloc(TYPE_DEVICE, 0, 18, UDC_DESC_SPEC_30);
8f61f3b4:	e1a05000 	mov	r5, r0
	data[7] = 0x09; /* max packet size on ept 0 */
8f61f3b8:	e5c0a010 	strb	r10, [r0, #16]
	data[2] = 0x00; /* usb spec minor rev */
8f61f3bc:	e5c0400b 	strb	r4, [r0, #11]
	data[3] = 0x03; /* usb spec major rev */
8f61f3c0:	e3a0a003 	mov	r10, #3
	data[4] = 0x00; /* class */
8f61f3c4:	e5c0400d 	strb	r4, [r0, #13]
	memcpy(data +  8, &dev_info->vendor_id,  sizeof(short));
8f61f3c8:	e2800011 	add	r0, r0, #17
	data[5] = 0x00; /* subclass */
8f61f3cc:	e5404003 	strb	r4, [r0, #-3]
	data[6] = 0x00; /* protocol */
8f61f3d0:	e5404002 	strb	r4, [r0, #-2]
	data[3] = 0x03; /* usb spec major rev */
8f61f3d4:	e540a005 	strb	r10, [r0, #-5]
	memcpy(data +  8, &dev_info->vendor_id,  sizeof(short));
8f61f3d8:	eb005376 	bl	8f6341b8 <memcpy>
	memcpy(data + 10, &dev_info->product_id, sizeof(short));
8f61f3dc:	e59d100c 	ldr	r1, [r13, #12]
8f61f3e0:	e1a0200b 	mov	r2, r11
8f61f3e4:	e2850013 	add	r0, r5, #19
8f61f3e8:	eb005372 	bl	8f6341b8 <memcpy>
	memcpy(data + 12, &dev_info->version_id, sizeof(short));
8f61f3ec:	e1a0200b 	mov	r2, r11
8f61f3f0:	e2861004 	add	r1, r6, #4
8f61f3f4:	e2850015 	add	r0, r5, #21
8f61f3f8:	eb00536e 	bl	8f6341b8 <memcpy>
	data[14] = udc_string_desc_alloc(udc, dev_info->manufacturer);
8f61f3fc:	e5961008 	ldr	r1, [r6, #8]
8f61f400:	e1a00008 	mov	r0, r8
8f61f404:	ebfffbb2 	bl	8f61e2d4 <udc_string_desc_alloc>
8f61f408:	e5c50017 	strb	r0, [r5, #23]
	data[15] = udc_string_desc_alloc(udc, dev_info->product);
8f61f40c:	e1a00008 	mov	r0, r8
8f61f410:	e596100c 	ldr	r1, [r6, #12]
8f61f414:	ebfffbae 	bl	8f61e2d4 <udc_string_desc_alloc>
8f61f418:	e5c50018 	strb	r0, [r5, #24]
	data[16] = udc_string_desc_alloc(udc, dev_info->serialno);
8f61f41c:	e1a00008 	mov	r0, r8
8f61f420:	e5961010 	ldr	r1, [r6, #16]
8f61f424:	ebfffbaa 	bl	8f61e2d4 <udc_string_desc_alloc>
	data[17] = 1; /* number of configurations */
8f61f428:	e5c5901a 	strb	r9, [r5, #26]
	desc = udc_descriptor_alloc(TYPE_BOS, 0, 0x16, UDC_DESC_SPEC_30); /* 22 is total length of bos + other descriptors inside it */
8f61f42c:	e1a0300b 	mov	r3, r11
8f61f430:	e1a01004 	mov	r1, r4
	udc_register_bos_desc(udc_dev);
8f61f434:	e5976000 	ldr	r6, [r7]
	data[16] = udc_string_desc_alloc(udc, dev_info->serialno);
8f61f438:	e5c50019 	strb	r0, [r5, #25]
	desc = udc_descriptor_alloc(TYPE_BOS, 0, 0x16, UDC_DESC_SPEC_30); /* 22 is total length of bos + other descriptors inside it */
8f61f43c:	e3a0000f 	mov	r0, #15
	desc->next     = udc->desc_list;
8f61f440:	e598200c 	ldr	r2, [r8, #12]
8f61f444:	e5852000 	str	r2, [r5]
	desc = udc_descriptor_alloc(TYPE_BOS, 0, 0x16, UDC_DESC_SPEC_30); /* 22 is total length of bos + other descriptors inside it */
8f61f448:	e3a02016 	mov	r2, #22
	udc->desc_list = desc;
8f61f44c:	e588500c 	str	r5, [r8, #12]
	desc = udc_descriptor_alloc(TYPE_BOS, 0, 0x16, UDC_DESC_SPEC_30); /* 22 is total length of bos + other descriptors inside it */
8f61f450:	ebfffb5c 	bl	8f61e1c8 <udc_descriptor_alloc>
	data[6]  = 0x10;    /* Device capability desc */
8f61f454:	e3a03010 	mov	r3, #16
	data[2] = 0x16;     /* total len of bos desc and its sub desc */
8f61f458:	e3a02016 	mov	r2, #22
	data[6]  = 0x10;    /* Device capability desc */
8f61f45c:	e5c0300f 	strb	r3, [r0, #15]
	data[13]  = 0x10;    /* Device Capability desc */
8f61f460:	e5c03016 	strb	r3, [r0, #22]
	data[12]  = 0x0A;    /* desc len */
8f61f464:	e3a0300a 	mov	r3, #10
	data[14]  = 0x03;    /* 3 == SuperSpeed capable */
8f61f468:	e5c0a017 	strb	r10, [r0, #23]
	data[12]  = 0x0A;    /* desc len */
8f61f46c:	e5c03015 	strb	r3, [r0, #21]
	data[1] = TYPE_BOS; /* BOS desc type */
8f61f470:	e3a0300f 	mov	r3, #15
	data[18] = 0x01;    /* lowest supported speed with full functionality: FS */
8f61f474:	e5c0901b 	strb	r9, [r0, #27]
	data[1] = TYPE_BOS; /* BOS desc type */
8f61f478:	e5c0300a 	strb	r3, [r0, #10]
	data[16]  = 0x0F;    /* Supported Speeds (bit mask): LS, FS, HS, SS */
8f61f47c:	e5c03019 	strb	r3, [r0, #25]
	data[5]  = 0x07;    /* Size of USB2.0 extension desc */
8f61f480:	e3a03007 	mov	r3, #7
	data[3] = 0x00;     /* total len of bos desc and its sub desc */
8f61f484:	e5c0400c 	strb	r4, [r0, #12]
	data[5]  = 0x07;    /* Size of USB2.0 extension desc */
8f61f488:	e5c0300e 	strb	r3, [r0, #14]
	data[0] = 0x05;     /* BOS desc len */
8f61f48c:	e3a03005 	mov	r3, #5
	data[4] = 0x02;     /* num of sub desc inside bos */
8f61f490:	e5c0b00d 	strb	r11, [r0, #13]
	data[7]  = 0x02;    /* USB2.0 extension descriptor */
8f61f494:	e5c0b010 	strb	r11, [r0, #16]
	data[8]  = 0x02;    /* LPM mode */
8f61f498:	e5c0b011 	strb	r11, [r0, #17]
	data[9]  = 0x00;    /* Reserved */
8f61f49c:	e5c04012 	strb	r4, [r0, #18]
	data[10] = 0x00;    /* Reserved */
8f61f4a0:	e5c04013 	strb	r4, [r0, #19]
	data[11] = 0x00;    /* Reserved */
8f61f4a4:	e5c04014 	strb	r4, [r0, #20]
	data[15]  = 0x00;    /* Attribute: latency tolerance msg: No */
8f61f4a8:	e5c04018 	strb	r4, [r0, #24]
	data[17] = 0x00;    /* Reserved part of supported wSupportedSpeeds */
8f61f4ac:	e5c0401a 	strb	r4, [r0, #26]
	data[19] = 0x00;    /* U1 device exit latency */
8f61f4b0:	e5c0401c 	strb	r4, [r0, #28]
	data[20] = 0x00;    /* U2 device exit latency (lsb) */
8f61f4b4:	e5c0401d 	strb	r4, [r0, #29]
	data[21] = 0x00;    /* U2 device exit latency (msb) */
8f61f4b8:	e5c0401e 	strb	r4, [r0, #30]
	data[2] = 0x16;     /* total len of bos desc and its sub desc */
8f61f4bc:	e5c0200b 	strb	r2, [r0, #11]
	data[0] = 0x05;     /* BOS desc len */
8f61f4c0:	e5c03009 	strb	r3, [r0, #9]
	desc->next     = udc->desc_list;
8f61f4c4:	e596300c 	ldr	r3, [r6, #12]
8f61f4c8:	e5803000 	str	r3, [r0]
}
8f61f4cc:	e59f318c 	ldr	r3, [pc, #396]	; 8f61f660 <usb30_udc_init+0x5ec>
	udc->desc_list = desc;
8f61f4d0:	e586000c 	str	r0, [r6, #12]
}
8f61f4d4:	e5932000 	ldr	r2, [r3]
8f61f4d8:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f61f4dc:	e0332002 	eors	r2, r3, r2
8f61f4e0:	e3a03000 	mov	r3, #0
8f61f4e4:	1a00005c 	bne	8f61f65c <usb30_udc_init+0x5e8>
8f61f4e8:	e1a00004 	mov	r0, r4
8f61f4ec:	e28dd03c 	add	r13, r13, #60	; 0x3c
8f61f4f0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		if (dev_info->t_usb_if->phy_reset)
8f61f4f4:	e5963014 	ldr	r3, [r6, #20]
8f61f4f8:	e5933004 	ldr	r3, [r3, #4]
8f61f4fc:	e3530000 	cmp	r3, #0
8f61f500:	0a000000 	beq	8f61f508 <usb30_udc_init+0x494>
			dev_info->t_usb_if->phy_reset();
8f61f504:	e12fff33 	blx	r3
		if (board_platform_id() == APQ8084)
8f61f508:	ebffc32f 	bl	8f6101cc <board_platform_id>
8f61f50c:	e35000b2 	cmp	r0, #178	; 0xb2
8f61f510:	1affff39 	bne	8f61f1fc <usb30_udc_init+0x188>
			usb_wrapper_hs_phy_ctrl_force_write(wrapper);
8f61f514:	e1a00004 	mov	r0, r4
8f61f518:	eb000330 	bl	8f6201e0 <usb_wrapper_hs_phy_ctrl_force_write>
8f61f51c:	eaffff36 	b	8f61f1fc <usb30_udc_init+0x188>
	usb_wrapper_vbus_override(dev->wrapper_dev);
8f61f520:	e5973000 	ldr	r3, [r7]
8f61f524:	e5930000 	ldr	r0, [r3]
8f61f528:	eb0002df 	bl	8f6200ac <usb_wrapper_vbus_override>
}
8f61f52c:	eaffff59 	b	8f61f298 <usb30_udc_init+0x224>
		usb_wrapper_hsonly_mode(wrapper);
8f61f530:	e1a00004 	mov	r0, r4
8f61f534:	eb00033c 	bl	8f62022c <usb_wrapper_hsonly_mode>
8f61f538:	eaffff4a 	b	8f61f268 <usb30_udc_init+0x1f4>
		usb_wrapper_ss_phy_configure(wrapper);
8f61f53c:	e1a00004 	mov	r0, r4
8f61f540:	eb000237 	bl	8f61fe24 <usb_wrapper_ss_phy_configure>
8f61f544:	eaffff34 	b	8f61f21c <usb30_udc_init+0x1a8>
	ASSERT(dwc);
8f61f548:	e1a00008 	mov	r0, r8
8f61f54c:	e3003258 	movw	r3, #600	; 0x258
8f61f550:	e3072178 	movw	r2, #29048	; 0x7178
8f61f554:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61f558:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61f55c:	e58d3000 	str	r3, [r13]
8f61f560:	e3001130 	movw	r1, #304	; 0x130
8f61f564:	e3a030d9 	mov	r3, #217	; 0xd9
8f61f568:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61f56c:	eb004d52 	bl	8f632abc <_panic>
8f61f570:	eaffff0f 	b	8f61f1b4 <usb30_udc_init+0x140>
	ASSERT(wrapper);
8f61f574:	e307325c 	movw	r3, #29276	; 0x725c
8f61f578:	e3072178 	movw	r2, #29048	; 0x7178
8f61f57c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61f580:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61f584:	e58d3000 	str	r3, [r13]
8f61f588:	e3001130 	movw	r1, #304	; 0x130
8f61f58c:	e3a030c1 	mov	r3, #193	; 0xc1
8f61f590:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61f594:	e1a00008 	mov	r0, r8
8f61f598:	eb004d47 	bl	8f632abc <_panic>
8f61f59c:	eafffee9 	b	8f61f148 <usb30_udc_init+0xd4>
	ASSERT(dwc_config.event_buf);
8f61f5a0:	e3073264 	movw	r3, #29284	; 0x7264
8f61f5a4:	e3072178 	movw	r2, #29048	; 0x7178
8f61f5a8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61f5ac:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61f5b0:	e58d3000 	str	r3, [r13]
8f61f5b4:	e3001130 	movw	r1, #304	; 0x130
8f61f5b8:	e3a030cc 	mov	r3, #204	; 0xcc
8f61f5bc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61f5c0:	e1a00008 	mov	r0, r8
8f61f5c4:	eb004d3c 	bl	8f632abc <_panic>
8f61f5c8:	eafffeea 	b	8f61f178 <usb30_udc_init+0x104>
	ASSERT(udc_dev);
8f61f5cc:	e1a00008 	mov	r0, r8
8f61f5d0:	e3072224 	movw	r2, #29220	; 0x7224
8f61f5d4:	e300312e 	movw	r3, #302	; 0x12e
8f61f5d8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61f5dc:	e3001130 	movw	r1, #304	; 0x130
8f61f5e0:	e58d2000 	str	r2, [r13]
8f61f5e4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61f5e8:	e3072178 	movw	r2, #29048	; 0x7178
8f61f5ec:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61f5f0:	eb004d31 	bl	8f632abc <_panic>
	memset(udc_dev, 0 , sizeof(udc_t));
8f61f5f4:	e5970000 	ldr	r0, [r7]
8f61f5f8:	eafffeac 	b	8f61f0b0 <usb30_udc_init+0x3c>
	ASSERT(udc_dev->ctrl_rx_buf);
8f61f5fc:	e307222c 	movw	r2, #29228	; 0x722c
8f61f600:	e3003135 	movw	r3, #309	; 0x135
8f61f604:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61f608:	e3001130 	movw	r1, #304	; 0x130
8f61f60c:	e58d2000 	str	r2, [r13]
8f61f610:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61f614:	e3072178 	movw	r2, #29048	; 0x7178
8f61f618:	e1a00008 	mov	r0, r8
8f61f61c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61f620:	eb004d25 	bl	8f632abc <_panic>
	udc_dev->ctrl_tx_buf = memalign(CACHE_LINE, ROUNDUP(UDC_CONTROL_TX_BUF_SIZE, CACHE_LINE));
8f61f624:	e5974000 	ldr	r4, [r7]
8f61f628:	eafffeac 	b	8f61f0e0 <usb30_udc_init+0x6c>
	ASSERT(udc_dev->ctrl_tx_buf);
8f61f62c:	e3a03f4e 	mov	r3, #312	; 0x138
8f61f630:	e3072244 	movw	r2, #29252	; 0x7244
8f61f634:	e3001130 	movw	r1, #304	; 0x130
8f61f638:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61f63c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61f640:	e58d2000 	str	r2, [r13]
8f61f644:	e1a00008 	mov	r0, r8
8f61f648:	e3072178 	movw	r2, #29048	; 0x7178
8f61f64c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61f650:	eb004d19 	bl	8f632abc <_panic>
	udc_dev->next_string_id  = 1;
8f61f654:	e5973000 	ldr	r3, [r7]
8f61f658:	eafffea8 	b	8f61f100 <usb30_udc_init+0x8c>
}
8f61f65c:	eb004d57 	bl	8f632bc0 <__stack_chk_fail>
8f61f660:	8f74221c 	.word	0x8f74221c

8f61f664 <usb30_udc_register_gadget>:
{
8f61f664:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	ASSERT(gadget);
8f61f668:	e2504000 	subs	r4, r0, #0
{
8f61f66c:	e59f3284 	ldr	r3, [pc, #644]	; 8f61f8f8 <usb30_udc_register_gadget+0x294>
8f61f670:	e24dd01c 	sub	r13, r13, #28
8f61f674:	e1a0500e 	mov	r5, r14
8f61f678:	e5933000 	ldr	r3, [r3]
8f61f67c:	e58d3014 	str	r3, [r13, #20]
8f61f680:	e3a03000 	mov	r3, #0
	ASSERT(gadget);
8f61f684:	0a000074 	beq	8f61f85c <usb30_udc_register_gadget+0x1f8>
	if (udc_dev->gadget)
8f61f688:	e30d318c 	movw	r3, #53644	; 0xd18c
8f61f68c:	e3483f72 	movt	r3, #36722	; 0x8f72
8f61f690:	e58d3008 	str	r3, [r13, #8]
8f61f694:	e5930000 	ldr	r0, [r3]
8f61f698:	e5903008 	ldr	r3, [r0, #8]
8f61f69c:	e3530000 	cmp	r3, #0
8f61f6a0:	1a00008e 	bne	8f61f8e0 <usb30_udc_register_gadget+0x27c>
	udc_register_config_desc_usb20(udc_dev, gadget, TYPE_CONFIGURATION);
8f61f6a4:	e3a02002 	mov	r2, #2
8f61f6a8:	e1a01004 	mov	r1, r4
8f61f6ac:	ebfffb40 	bl	8f61e3b4 <udc_register_config_desc_usb20>
	udc_register_config_desc_usb30(udc_dev, gadget);
8f61f6b0:	e59d3008 	ldr	r3, [r13, #8]
8f61f6b4:	e5933000 	ldr	r3, [r3]
	ASSERT(udc);
8f61f6b8:	e3530000 	cmp	r3, #0
	udc_register_config_desc_usb30(udc_dev, gadget);
8f61f6bc:	e58d300c 	str	r3, [r13, #12]
	ASSERT(udc);
8f61f6c0:	0a000070 	beq	8f61f888 <usb30_udc_register_gadget+0x224>
	ASSERT(gadget);
8f61f6c4:	e3540000 	cmp	r4, #0
8f61f6c8:	0a000079 	beq	8f61f8b4 <usb30_udc_register_gadget+0x250>
		   UDC_DESC_SIZE_INTERFACE +
8f61f6cc:	e5d4500b 	ldrb	r5, [r4, #11]
	desc = udc_descriptor_alloc(TYPE_CONFIGURATION, 0, size, UDC_DESC_SPEC_30);
8f61f6d0:	e3a03002 	mov	r3, #2
8f61f6d4:	e3a01000 	mov	r1, #0
8f61f6d8:	e1a00003 	mov	r0, r3
	data[6] = 0x00;     /* configuration string */
8f61f6dc:	e1a08001 	mov	r8, r1
	data[1] = TYPE_CONFIGURATION;
8f61f6e0:	e3a07002 	mov	r7, #2
		   UDC_DESC_SIZE_INTERFACE +
8f61f6e4:	e0852085 	add	r2, r5, r5, lsl #1
8f61f6e8:	e0855102 	add	r5, r5, r2, lsl #2
8f61f6ec:	e2855012 	add	r5, r5, #18
	desc = udc_descriptor_alloc(TYPE_CONFIGURATION, 0, size, UDC_DESC_SPEC_30);
8f61f6f0:	e1a02005 	mov	r2, r5
8f61f6f4:	ebfffab3 	bl	8f61e1c8 <udc_descriptor_alloc>
	data[0] = 0x09;
8f61f6f8:	e3a03009 	mov	r3, #9
	data[2] = size;
8f61f6fc:	e5c0500b 	strb	r5, [r0, #11]
	data[3] = size >> 8;
8f61f700:	e1a05425 	lsr	r5, r5, #8
	data[0] = 0x09;
8f61f704:	e5c03009 	strb	r3, [r0, #9]
	desc = udc_descriptor_alloc(TYPE_CONFIGURATION, 0, size, UDC_DESC_SPEC_30);
8f61f708:	e1a06000 	mov	r6, r0
	data[0] = 0x09;
8f61f70c:	e5c03012 	strb	r3, [r0, #18]
	data[4] = 0x01;     /* number of interfaces */
8f61f710:	e3a03001 	mov	r3, #1
	data[6] = 0x00;     /* configuration string */
8f61f714:	e5c0800f 	strb	r8, [r0, #15]
	data[4] = 0x01;     /* number of interfaces */
8f61f718:	e5c0300d 	strb	r3, [r0, #13]
	data[5] = 0x01;     /* configuration value */
8f61f71c:	e5c0300e 	strb	r3, [r0, #14]
	data[7] = 0xC0;     /* attributes: reserved and self-powered set */
8f61f720:	e3e0303f 	mvn	r3, #63	; 0x3f
	data[8] = 0x00;     /* max power: 0ma since we are self powered */
8f61f724:	e5c08011 	strb	r8, [r0, #17]
	data[7] = 0xC0;     /* attributes: reserved and self-powered set */
8f61f728:	e5c03010 	strb	r3, [r0, #16]
	data[1] = TYPE_INTERFACE;
8f61f72c:	e3a03004 	mov	r3, #4
	data[2] = 0x00;     /* ifc number */
8f61f730:	e5c08014 	strb	r8, [r0, #20]
	data[3] = 0x00;     /* alt number */
8f61f734:	e5c08015 	strb	r8, [r0, #21]
	data[3] = size >> 8;
8f61f738:	e5c0500c 	strb	r5, [r0, #12]
	data[1] = TYPE_CONFIGURATION;
8f61f73c:	e5c0700a 	strb	r7, [r0, #10]
	data[1] = TYPE_INTERFACE;
8f61f740:	e5c03013 	strb	r3, [r0, #19]
	data[4] = gadget->ifc_endpoints;
8f61f744:	e5d4300b 	ldrb	r3, [r4, #11]
8f61f748:	e5c03016 	strb	r3, [r0, #22]
	data[5] = gadget->ifc_class;
8f61f74c:	e5d43008 	ldrb	r3, [r4, #8]
8f61f750:	e5c03017 	strb	r3, [r0, #23]
	data[6] = gadget->ifc_subclass;
8f61f754:	e5d43009 	ldrb	r3, [r4, #9]
8f61f758:	e5c03018 	strb	r3, [r0, #24]
	data[7] = gadget->ifc_protocol;
8f61f75c:	e5d4300a 	ldrb	r3, [r4, #10]
8f61f760:	e5c03019 	strb	r3, [r0, #25]
	data[8] = udc_string_desc_alloc(udc, gadget->ifc_string);
8f61f764:	e59d000c 	ldr	r0, [r13, #12]
8f61f768:	e594100c 	ldr	r1, [r4, #12]
8f61f76c:	ebfffad8 	bl	8f61e2d4 <udc_string_desc_alloc>
8f61f770:	e5c6001a 	strb	r0, [r6, #26]
	for (uint8_t n = 0; n < gadget->ifc_endpoints; n++)
8f61f774:	e5d4300b 	ldrb	r3, [r4, #11]
8f61f778:	e1530008 	cmp	r3, r8
8f61f77c:	0a000026 	beq	8f61f81c <usb30_udc_register_gadget+0x1b8>
8f61f780:	e2863028 	add	r3, r6, #40	; 0x28
8f61f784:	e1a0e008 	mov	r14, r8
8f61f788:	e1a02008 	mov	r2, r8
	data[6] = 0; /* bInterval: must be 0 for bulk. */
8f61f78c:	e1a0c008 	mov	r12, r8
	data[0] = 7;
8f61f790:	e3a0b007 	mov	r11, #7
	data[1] = TYPE_ENDPOINT;
8f61f794:	e3a0a005 	mov	r10, #5
	data[0] = 6;               /* bLength */
8f61f798:	e3a09006 	mov	r9, #6
	data[1] = TYPE_SS_EP_COMP; /* ep type */
8f61f79c:	e3a08030 	mov	r8, #48	; 0x30
		udc_ept_desc_fill(gadget->ept[n], data, 0);
8f61f7a0:	e5941014 	ldr	r1, [r4, #20]
	for (uint8_t n = 0; n < gadget->ifc_endpoints; n++)
8f61f7a4:	e28ee001 	add	r14, r14, #1
8f61f7a8:	e283300d 	add	r3, r3, #13
		udc_ept_desc_fill(gadget->ept[n], data, 0);
8f61f7ac:	e7910102 	ldr	r0, [r1, r2, lsl #2]
8f61f7b0:	e1a02102 	lsl	r2, r2, #2
		max_pkt_sz = ept->maxpkt;
8f61f7b4:	e1d010b8 	ldrh	r1, [r0, #8]
	data[0] = 7;
8f61f7b8:	e543b01a 	strb	r11, [r3, #-26]	; 0xffffffe6
	data[1] = TYPE_ENDPOINT;
8f61f7bc:	e543a019 	strb	r10, [r3, #-25]	; 0xffffffe7
	data[2] = ept->num | (ept->in ? 0x80 : 0x00);
8f61f7c0:	e5d05006 	ldrb	r5, [r0, #6]
8f61f7c4:	e5d00004 	ldrb	r0, [r0, #4]
8f61f7c8:	e3550000 	cmp	r5, #0
	data[4] = max_pkt_sz;
8f61f7cc:	e5431016 	strb	r1, [r3, #-22]	; 0xffffffea
	data[3] = 0x02; /* bulk -- the only kind we support */
8f61f7d0:	e5437017 	strb	r7, [r3, #-23]	; 0xffffffe9
	data[2] = ept->num | (ept->in ? 0x80 : 0x00);
8f61f7d4:	13800080 	orrne	r0, r0, #128	; 0x80
	data[6] = 0; /* bInterval: must be 0 for bulk. */
8f61f7d8:	e543c014 	strb	r12, [r3, #-20]	; 0xffffffec
	data[5] = max_pkt_sz >> 8;
8f61f7dc:	e1a01421 	lsr	r1, r1, #8
	data[2] = ept->num | (ept->in ? 0x80 : 0x00);
8f61f7e0:	e5430018 	strb	r0, [r3, #-24]	; 0xffffffe8
	data[5] = max_pkt_sz >> 8;
8f61f7e4:	e5431015 	strb	r1, [r3, #-21]	; 0xffffffeb
		udc_ept_comp_desc_fill(gadget->ept[n], data);
8f61f7e8:	e5941014 	ldr	r1, [r4, #20]
8f61f7ec:	e7912002 	ldr	r2, [r1, r2]
	data[0] = 6;               /* bLength */
8f61f7f0:	e5439013 	strb	r9, [r3, #-19]	; 0xffffffed
	data[1] = TYPE_SS_EP_COMP; /* ep type */
8f61f7f4:	e5438012 	strb	r8, [r3, #-18]	; 0xffffffee
	data[2] = ept->maxburst;   /* maxBurst */
8f61f7f8:	e592200c 	ldr	r2, [r2, #12]
	data[3] = 0x0;             /* maxStreams */
8f61f7fc:	e543c010 	strb	r12, [r3, #-16]
	data[4] = 0x0;             /* wBytesPerInterval */
8f61f800:	e543c00f 	strb	r12, [r3, #-15]
	data[2] = ept->maxburst;   /* maxBurst */
8f61f804:	e5432011 	strb	r2, [r3, #-17]	; 0xffffffef
	for (uint8_t n = 0; n < gadget->ifc_endpoints; n++)
8f61f808:	e6ef207e 	uxtb	r2, r14
	data[5] = 0x0;             /* wBytesPerInterval */
8f61f80c:	e543c00e 	strb	r12, [r3, #-14]
	for (uint8_t n = 0; n < gadget->ifc_endpoints; n++)
8f61f810:	e5d4100b 	ldrb	r1, [r4, #11]
8f61f814:	e1510002 	cmp	r1, r2
8f61f818:	8affffe0 	bhi	8f61f7a0 <usb30_udc_register_gadget+0x13c>
	desc->next     = udc->desc_list;
8f61f81c:	e59d100c 	ldr	r1, [r13, #12]
	return 0;
8f61f820:	e3a00000 	mov	r0, #0
	udc_dev->gadget = gadget;
8f61f824:	e59d3008 	ldr	r3, [r13, #8]
	desc->next     = udc->desc_list;
8f61f828:	e591200c 	ldr	r2, [r1, #12]
	udc_dev->gadget = gadget;
8f61f82c:	e5933000 	ldr	r3, [r3]
	desc->next     = udc->desc_list;
8f61f830:	e5862000 	str	r2, [r6]
	udc->desc_list = desc;
8f61f834:	e581600c 	str	r6, [r1, #12]
	udc_dev->gadget = gadget;
8f61f838:	e5834008 	str	r4, [r3, #8]
}
8f61f83c:	e59f30b4 	ldr	r3, [pc, #180]	; 8f61f8f8 <usb30_udc_register_gadget+0x294>
8f61f840:	e5932000 	ldr	r2, [r3]
8f61f844:	e59d3014 	ldr	r3, [r13, #20]
8f61f848:	e0332002 	eors	r2, r3, r2
8f61f84c:	e3a03000 	mov	r3, #0
8f61f850:	1a000027 	bne	8f61f8f4 <usb30_udc_register_gadget+0x290>
8f61f854:	e28dd01c 	add	r13, r13, #28
8f61f858:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	ASSERT(gadget);
8f61f85c:	e307019c 	movw	r0, #29084	; 0x719c
8f61f860:	e3072178 	movw	r2, #29048	; 0x7178
8f61f864:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61f868:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61f86c:	e58d0000 	str	r0, [r13]
8f61f870:	e3001130 	movw	r1, #304	; 0x130
8f61f874:	e3003152 	movw	r3, #338	; 0x152
8f61f878:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61f87c:	e1a0000e 	mov	r0, r14
8f61f880:	eb004c8d 	bl	8f632abc <_panic>
8f61f884:	eaffff7f 	b	8f61f688 <usb30_udc_register_gadget+0x24>
	ASSERT(udc);
8f61f888:	e3073198 	movw	r3, #29080	; 0x7198
8f61f88c:	e3072178 	movw	r2, #29048	; 0x7178
8f61f890:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61f894:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61f898:	e58d3000 	str	r3, [r13]
8f61f89c:	e3001130 	movw	r1, #304	; 0x130
8f61f8a0:	e3003476 	movw	r3, #1142	; 0x476
8f61f8a4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61f8a8:	e1a00005 	mov	r0, r5
8f61f8ac:	eb004c82 	bl	8f632abc <_panic>
8f61f8b0:	eaffff83 	b	8f61f6c4 <usb30_udc_register_gadget+0x60>
	ASSERT(gadget);
8f61f8b4:	e307319c 	movw	r3, #29084	; 0x719c
8f61f8b8:	e1a00005 	mov	r0, r5
8f61f8bc:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61f8c0:	e3072178 	movw	r2, #29048	; 0x7178
8f61f8c4:	e58d3000 	str	r3, [r13]
8f61f8c8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61f8cc:	e3003477 	movw	r3, #1143	; 0x477
8f61f8d0:	e3001130 	movw	r1, #304	; 0x130
8f61f8d4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61f8d8:	eb004c77 	bl	8f632abc <_panic>
8f61f8dc:	eaffff7a 	b	8f61f6cc <usb30_udc_register_gadget+0x68>
		ERR("\nonly one gadget supported\n");
8f61f8e0:	e307027c 	movw	r0, #29308	; 0x727c
8f61f8e4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f61f8e8:	eb004c21 	bl	8f632974 <_dprintf>
		return -1;
8f61f8ec:	e3e00000 	mvn	r0, #0
8f61f8f0:	eaffffd1 	b	8f61f83c <usb30_udc_register_gadget+0x1d8>
}
8f61f8f4:	eb004cb1 	bl	8f632bc0 <__stack_chk_fail>
8f61f8f8:	8f74221c 	.word	0x8f74221c

8f61f8fc <usb30_udc_start>:
	dwc_device_run(udc_dev->dwc, 1);
8f61f8fc:	e30d318c 	movw	r3, #53644	; 0xd18c
8f61f900:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f61f904:	e59f2048 	ldr	r2, [pc, #72]	; 8f61f954 <usb30_udc_start+0x58>
	dwc_device_run(udc_dev->dwc, 1);
8f61f908:	e3a01001 	mov	r1, #1
8f61f90c:	e5933000 	ldr	r3, [r3]
{
8f61f910:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61f914:	e24dd00c 	sub	r13, r13, #12
	dwc_device_run(udc_dev->dwc, 1);
8f61f918:	e5930004 	ldr	r0, [r3, #4]
{
8f61f91c:	e5922000 	ldr	r2, [r2]
8f61f920:	e58d2004 	str	r2, [r13, #4]
8f61f924:	e3a02000 	mov	r2, #0
	dwc_device_run(udc_dev->dwc, 1);
8f61f928:	ebfff797 	bl	8f61d78c <dwc_device_run>
}
8f61f92c:	e59f3020 	ldr	r3, [pc, #32]	; 8f61f954 <usb30_udc_start+0x58>
8f61f930:	e5932000 	ldr	r2, [r3]
8f61f934:	e59d3004 	ldr	r3, [r13, #4]
8f61f938:	e0332002 	eors	r2, r3, r2
8f61f93c:	e3a03000 	mov	r3, #0
8f61f940:	1a000002 	bne	8f61f950 <usb30_udc_start+0x54>
8f61f944:	e3a00000 	mov	r0, #0
8f61f948:	e28dd00c 	add	r13, r13, #12
8f61f94c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61f950:	eb004c9a 	bl	8f632bc0 <__stack_chk_fail>
8f61f954:	8f74221c 	.word	0x8f74221c

8f61f958 <usb30_udc_request_queue>:
{
8f61f958:	e92d40f0 	push	{r4, r5, r6, r7, r14}
    dwc_dev_t *dwc_dev = udc_dev->dwc;
8f61f95c:	e30d718c 	movw	r7, #53644	; 0xd18c
8f61f960:	e3487f72 	movt	r7, #36722	; 0x8f72
{
8f61f964:	e59f20cc 	ldr	r2, [pc, #204]	; 8f61fa38 <usb30_udc_request_queue+0xe0>
8f61f968:	e24dd01c 	sub	r13, r13, #28
8f61f96c:	e1a06000 	mov	r6, r0
    dwc_dev_t *dwc_dev = udc_dev->dwc;
8f61f970:	e5973000 	ldr	r3, [r7]
{
8f61f974:	e5922000 	ldr	r2, [r2]
8f61f978:	e58d2014 	str	r2, [r13, #20]
8f61f97c:	e3a02000 	mov	r2, #0
8f61f980:	e1a04001 	mov	r4, r1
    dwc_dev_t *dwc_dev = udc_dev->dwc;
8f61f984:	e5935004 	ldr	r5, [r3, #4]
	ASSERT(dwc_dev);
8f61f988:	e3550000 	cmp	r5, #0
8f61f98c:	0a00001a 	beq	8f61f9fc <usb30_udc_request_queue+0xa4>
	if(udc_dev->config_selected == 0)
8f61f990:	e5d32025 	ldrb	r2, [r3, #37]	; 0x25
8f61f994:	e3520000 	cmp	r2, #0
8f61f998:	0a000023 	beq	8f61fa2c <usb30_udc_request_queue+0xd4>
	if(udc_dev->queued_req)
8f61f99c:	e5932028 	ldr	r2, [r3, #40]	; 0x28
8f61f9a0:	e3520000 	cmp	r2, #0
8f61f9a4:	1a000020 	bne	8f61fa2c <usb30_udc_request_queue+0xd4>
	udc_dev->queued_req = req;
8f61f9a8:	e5834028 	str	r4, [r3, #40]	; 0x28
	ret = dwc_transfer_request(dwc_dev,
8f61f9ac:	e1a00005 	mov	r0, r5
8f61f9b0:	e5d62006 	ldrb	r2, [r6, #6]
8f61f9b4:	e5d61004 	ldrb	r1, [r6, #4]
8f61f9b8:	e58d3008 	str	r3, [r13, #8]
8f61f9bc:	e30e30b4 	movw	r3, #57524	; 0xe0b4
8f61f9c0:	e3483f61 	movt	r3, #36705	; 0x8f61
8f61f9c4:	e58d3004 	str	r3, [r13, #4]
8f61f9c8:	e8941008 	ldm	r4, {r3, r12}
8f61f9cc:	e2522000 	subs	r2, r2, #0
8f61f9d0:	13a02001 	movne	r2, #1
8f61f9d4:	e58dc000 	str	r12, [r13]
8f61f9d8:	ebfff5a9 	bl	8f61d084 <dwc_transfer_request>
}
8f61f9dc:	e59f3054 	ldr	r3, [pc, #84]	; 8f61fa38 <usb30_udc_request_queue+0xe0>
8f61f9e0:	e5932000 	ldr	r2, [r3]
8f61f9e4:	e59d3014 	ldr	r3, [r13, #20]
8f61f9e8:	e0332002 	eors	r2, r3, r2
8f61f9ec:	e3a03000 	mov	r3, #0
8f61f9f0:	1a00000f 	bne	8f61fa34 <usb30_udc_request_queue+0xdc>
8f61f9f4:	e28dd01c 	add	r13, r13, #28
8f61f9f8:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
	ASSERT(dwc_dev);
8f61f9fc:	e1a0000e 	mov	r0, r14
8f61fa00:	e3073298 	movw	r3, #29336	; 0x7298
8f61fa04:	e3072178 	movw	r2, #29048	; 0x7178
8f61fa08:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61fa0c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61fa10:	e58d3000 	str	r3, [r13]
8f61fa14:	e3001130 	movw	r1, #304	; 0x130
8f61fa18:	e300336e 	movw	r3, #878	; 0x36e
8f61fa1c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61fa20:	eb004c25 	bl	8f632abc <_panic>
	if(udc_dev->config_selected == 0)
8f61fa24:	e5973000 	ldr	r3, [r7]
8f61fa28:	eaffffd8 	b	8f61f990 <usb30_udc_request_queue+0x38>
		return -1;
8f61fa2c:	e3e00000 	mvn	r0, #0
8f61fa30:	eaffffe9 	b	8f61f9dc <usb30_udc_request_queue+0x84>
}
8f61fa34:	eb004c61 	bl	8f632bc0 <__stack_chk_fail>
8f61fa38:	8f74221c 	.word	0x8f74221c

8f61fa3c <usb30_udc_endpoint_alloc>:
	udc_t *udc = udc_dev;
8f61fa3c:	e30d318c 	movw	r3, #53644	; 0xd18c
8f61fa40:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f61fa44:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	if (type == UDC_TYPE_BULK_IN) {
8f61fa48:	e3500001 	cmp	r0, #1
	udc_t *udc = udc_dev;
8f61fa4c:	e5936000 	ldr	r6, [r3]
{
8f61fa50:	e24dd014 	sub	r13, r13, #20
8f61fa54:	e59f317c 	ldr	r3, [pc, #380]	; 8f61fbd8 <usb30_udc_endpoint_alloc+0x19c>
8f61fa58:	e1a0800e 	mov	r8, r14
8f61fa5c:	e5933000 	ldr	r3, [r3]
8f61fa60:	e58d300c 	str	r3, [r13, #12]
8f61fa64:	e3a03000 	mov	r3, #0
	if (type == UDC_TYPE_BULK_IN) {
8f61fa68:	0a00003e 	beq	8f61fb68 <usb30_udc_endpoint_alloc+0x12c>
	} else if (type == UDC_TYPE_BULK_OUT) {
8f61fa6c:	e3500002 	cmp	r0, #2
8f61fa70:	0a000014 	beq	8f61fac8 <usb30_udc_endpoint_alloc+0x8c>
	} else if (type == UDC_TYPE_INTR_IN) {
8f61fa74:	e3500003 	cmp	r0, #3
8f61fa78:	0a00003d 	beq	8f61fb74 <usb30_udc_endpoint_alloc+0x138>
	} else if (type == UDC_TYPE_INTR_OUT){
8f61fa7c:	e3500004 	cmp	r0, #4
8f61fa80:	1a00000e 	bne	8f61fac0 <usb30_udc_endpoint_alloc+0x84>
		in = 0;
8f61fa84:	e3a07000 	mov	r7, #0
		type = EP_TYPE_INTERRUPT;
8f61fa88:	e3a00003 	mov	r0, #3
		if (udc->ept_alloc_table & bit)
8f61fa8c:	e5962014 	ldr	r2, [r6, #20]
8f61fa90:	e3a03001 	mov	r3, #1
		uint32_t bit = in ? EPT_TX(n) : EPT_RX(n);
8f61fa94:	e1a0c003 	mov	r12, r3
8f61fa98:	e3570000 	cmp	r7, #0
8f61fa9c:	e6ef9073 	uxtb	r9, r3
8f61faa0:	12835010 	addne	r5, r3, #16
8f61faa4:	01a0531c 	lsleq	r5, r12, r3
8f61faa8:	11a0551c 	lslne	r5, r12, r5
		if (udc->ept_alloc_table & bit)
8f61faac:	e1120005 	tst	r2, r5
8f61fab0:	0a000006 	beq	8f61fad0 <usb30_udc_endpoint_alloc+0x94>
	for (n = 1; n < 16; n++) {
8f61fab4:	e2833001 	add	r3, r3, #1
8f61fab8:	e3530010 	cmp	r3, #16
8f61fabc:	1afffff5 	bne	8f61fa98 <usb30_udc_endpoint_alloc+0x5c>
		return 0;
8f61fac0:	e3a04000 	mov	r4, #0
8f61fac4:	ea00001e 	b	8f61fb44 <usb30_udc_endpoint_alloc+0x108>
		in = 0;
8f61fac8:	e3a07000 	mov	r7, #0
8f61facc:	eaffffee 	b	8f61fa8c <usb30_udc_endpoint_alloc+0x50>
		ept = _udc_endpoint_alloc(n, in, type, maxpkt);
8f61fad0:	e6efa070 	uxtb	r10, r0
	ept = malloc(sizeof(*ept));
8f61fad4:	e3a00018 	mov	r0, #24
		ept = _udc_endpoint_alloc(n, in, type, maxpkt);
8f61fad8:	e6ffb071 	uxth	r11, r1
	ept = malloc(sizeof(*ept));
8f61fadc:	eb005146 	bl	8f633ffc <malloc>
	ASSERT(ept);
8f61fae0:	e2504000 	subs	r4, r0, #0
8f61fae4:	0a00002f 	beq	8f61fba8 <usb30_udc_endpoint_alloc+0x16c>
	ept->maxburst   = 4;      /* no performance improvement is seen beyond burst size of 4 */
8f61fae8:	e3a03004 	mov	r3, #4
	ept->trb        = memalign(lcm(CACHE_LINE, 16), ROUNDUP(ept->trb_count*sizeof(dwc_trb_t), CACHE_LINE)); /* TRB must be aligned to 16 */
8f61faec:	e3a01010 	mov	r1, #16
	ept->maxburst   = 4;      /* no performance improvement is seen beyond burst size of 4 */
8f61faf0:	e584300c 	str	r3, [r4, #12]
	ept->trb        = memalign(lcm(CACHE_LINE, 16), ROUNDUP(ept->trb_count*sizeof(dwc_trb_t), CACHE_LINE)); /* TRB must be aligned to 16 */
8f61faf4:	e3a00040 	mov	r0, #64	; 0x40
	ept->trb_count  = 66;     /* each trb can transfer (16MB - 1). 65 for 1GB transfer + 1 for roundup/zero length pkt. */
8f61faf8:	e3a03042 	mov	r3, #66	; 0x42
	ept->maxpkt     = max_pkt;
8f61fafc:	e1c4b0b8 	strh	r11, [r4, #8]
	ept->trb_count  = 66;     /* each trb can transfer (16MB - 1). 65 for 1GB transfer + 1 for roundup/zero length pkt. */
8f61fb00:	e5843014 	str	r3, [r4, #20]
	ept->num        = num;
8f61fb04:	e5c49004 	strb	r9, [r4, #4]
	ept->type       = type;
8f61fb08:	e5c4a005 	strb	r10, [r4, #5]
	ept->in         = !!in;
8f61fb0c:	e5c47006 	strb	r7, [r4, #6]
	ept->trb        = memalign(lcm(CACHE_LINE, 16), ROUNDUP(ept->trb_count*sizeof(dwc_trb_t), CACHE_LINE)); /* TRB must be aligned to 16 */
8f61fb10:	eb004e95 	bl	8f63356c <lcm>
8f61fb14:	e5941014 	ldr	r1, [r4, #20]
8f61fb18:	e1a01201 	lsl	r1, r1, #4
8f61fb1c:	e281103f 	add	r1, r1, #63	; 0x3f
8f61fb20:	e3c1103f 	bic	r1, r1, #63	; 0x3f
8f61fb24:	eb005146 	bl	8f634044 <memalign>
	ASSERT(ept->trb);
8f61fb28:	e3500000 	cmp	r0, #0
	ept->trb        = memalign(lcm(CACHE_LINE, 16), ROUNDUP(ept->trb_count*sizeof(dwc_trb_t), CACHE_LINE)); /* TRB must be aligned to 16 */
8f61fb2c:	e5840010 	str	r0, [r4, #16]
	ASSERT(ept->trb);
8f61fb30:	0a000011 	beq	8f61fb7c <usb30_udc_endpoint_alloc+0x140>
			udc->ept_alloc_table |= bit;
8f61fb34:	e1c621d0 	ldrd	r2, [r6, #16]
8f61fb38:	e1835005 	orr	r5, r3, r5
	ept->next      = udc->ept_list;
8f61fb3c:	e5842000 	str	r2, [r4]
			udc->ept_alloc_table |= bit;
8f61fb40:	e1c641f0 	strd	r4, [r6, #16]
}
8f61fb44:	e59f308c 	ldr	r3, [pc, #140]	; 8f61fbd8 <usb30_udc_endpoint_alloc+0x19c>
8f61fb48:	e5932000 	ldr	r2, [r3]
8f61fb4c:	e59d300c 	ldr	r3, [r13, #12]
8f61fb50:	e0332002 	eors	r2, r3, r2
8f61fb54:	e3a03000 	mov	r3, #0
8f61fb58:	1a00001d 	bne	8f61fbd4 <usb30_udc_endpoint_alloc+0x198>
8f61fb5c:	e1a00004 	mov	r0, r4
8f61fb60:	e28dd014 	add	r13, r13, #20
8f61fb64:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		in = 1;
8f61fb68:	e1a07000 	mov	r7, r0
		type = EP_TYPE_BULK;
8f61fb6c:	e3a00002 	mov	r0, #2
8f61fb70:	eaffffc5 	b	8f61fa8c <usb30_udc_endpoint_alloc+0x50>
		in = 1;
8f61fb74:	e3a07001 	mov	r7, #1
8f61fb78:	eaffffc3 	b	8f61fa8c <usb30_udc_endpoint_alloc+0x50>
	ASSERT(ept->trb);
8f61fb7c:	e30732a0 	movw	r3, #29344	; 0x72a0
8f61fb80:	e1a00008 	mov	r0, r8
8f61fb84:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61fb88:	e3072178 	movw	r2, #29048	; 0x7178
8f61fb8c:	e58d3000 	str	r3, [r13]
8f61fb90:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61fb94:	e300340a 	movw	r3, #1034	; 0x40a
8f61fb98:	e3001130 	movw	r1, #304	; 0x130
8f61fb9c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61fba0:	eb004bc5 	bl	8f632abc <_panic>
8f61fba4:	eaffffe2 	b	8f61fb34 <usb30_udc_endpoint_alloc+0xf8>
	ASSERT(ept);
8f61fba8:	e30134bc 	movw	r3, #5308	; 0x14bc
8f61fbac:	e3072178 	movw	r2, #29048	; 0x7178
8f61fbb0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f61fbb4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61fbb8:	e58d3000 	str	r3, [r13]
8f61fbbc:	e3001130 	movw	r1, #304	; 0x130
8f61fbc0:	e3003401 	movw	r3, #1025	; 0x401
8f61fbc4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61fbc8:	e1a00008 	mov	r0, r8
8f61fbcc:	eb004bba 	bl	8f632abc <_panic>
8f61fbd0:	eaffffc4 	b	8f61fae8 <usb30_udc_endpoint_alloc+0xac>
}
8f61fbd4:	eb004bf9 	bl	8f632bc0 <__stack_chk_fail>
8f61fbd8:	8f74221c 	.word	0x8f74221c

8f61fbdc <usb30_udc_request_alloc>:
}


struct udc_request *usb30_udc_request_alloc(void)
{
8f61fbdc:	e59f308c 	ldr	r3, [pc, #140]	; 8f61fc70 <usb30_udc_request_alloc+0x94>
	struct udc_request *req;

	req = malloc(sizeof(*req));
8f61fbe0:	e3a00010 	mov	r0, #16
{
8f61fbe4:	e92d4030 	push	{r4, r5, r14}
8f61fbe8:	e24dd014 	sub	r13, r13, #20
8f61fbec:	e5933000 	ldr	r3, [r3]
8f61fbf0:	e58d300c 	str	r3, [r13, #12]
8f61fbf4:	e3a03000 	mov	r3, #0
	req = malloc(sizeof(*req));
8f61fbf8:	e1a0500e 	mov	r5, r14
8f61fbfc:	eb0050fe 	bl	8f633ffc <malloc>
	ASSERT(req);
8f61fc00:	e2504000 	subs	r4, r0, #0
8f61fc04:	0a00000d 	beq	8f61fc40 <usb30_udc_request_alloc+0x64>

	req->buf      = 0;
8f61fc08:	e3a03000 	mov	r3, #0
8f61fc0c:	e5843000 	str	r3, [r4]
	req->length   = 0;
8f61fc10:	e5843004 	str	r3, [r4, #4]
	req->complete = NULL;
8f61fc14:	e5843008 	str	r3, [r4, #8]
	req->context  = 0;
8f61fc18:	e584300c 	str	r3, [r4, #12]

	return req;
}
8f61fc1c:	e59f304c 	ldr	r3, [pc, #76]	; 8f61fc70 <usb30_udc_request_alloc+0x94>
8f61fc20:	e5932000 	ldr	r2, [r3]
8f61fc24:	e59d300c 	ldr	r3, [r13, #12]
8f61fc28:	e0332002 	eors	r2, r3, r2
8f61fc2c:	e3a03000 	mov	r3, #0
8f61fc30:	1a00000d 	bne	8f61fc6c <usb30_udc_request_alloc+0x90>
8f61fc34:	e1a00004 	mov	r0, r4
8f61fc38:	e28dd014 	add	r13, r13, #20
8f61fc3c:	e8bd8030 	pop	{r4, r5, r15}
	ASSERT(req);
8f61fc40:	e301c4c0 	movw	r12, #5312	; 0x14c0
8f61fc44:	e3072178 	movw	r2, #29048	; 0x7178
8f61fc48:	e348cf70 	movt	r12, #36720	; 0x8f70
8f61fc4c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f61fc50:	e3001130 	movw	r1, #304	; 0x130
8f61fc54:	e3003587 	movw	r3, #1415	; 0x587
8f61fc58:	e3481f70 	movt	r1, #36720	; 0x8f70
8f61fc5c:	e1a00005 	mov	r0, r5
8f61fc60:	e58dc000 	str	r12, [r13]
8f61fc64:	eb004b94 	bl	8f632abc <_panic>
8f61fc68:	eaffffe6 	b	8f61fc08 <usb30_udc_request_alloc+0x2c>
}
8f61fc6c:	eb004bd3 	bl	8f632bc0 <__stack_chk_fail>
8f61fc70:	8f74221c 	.word	0x8f74221c

8f61fc74 <usb30_udc_request_free>:

void usb30_udc_request_free(struct udc_request *req)
{
8f61fc74:	e59f3038 	ldr	r3, [pc, #56]	; 8f61fcb4 <usb30_udc_request_free+0x40>
8f61fc78:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61fc7c:	e24dd00c 	sub	r13, r13, #12
8f61fc80:	e5933000 	ldr	r3, [r3]
8f61fc84:	e58d3004 	str	r3, [r13, #4]
8f61fc88:	e3a03000 	mov	r3, #0
	free(req);
8f61fc8c:	e59f3020 	ldr	r3, [pc, #32]	; 8f61fcb4 <usb30_udc_request_free+0x40>
8f61fc90:	e5932000 	ldr	r2, [r3]
8f61fc94:	e59d3004 	ldr	r3, [r13, #4]
8f61fc98:	e0332002 	eors	r2, r3, r2
8f61fc9c:	e3a03000 	mov	r3, #0
8f61fca0:	1a000002 	bne	8f61fcb0 <usb30_udc_request_free+0x3c>
}
8f61fca4:	e28dd00c 	add	r13, r13, #12
8f61fca8:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	free(req);
8f61fcac:	ea005116 	b	8f63410c <free>
8f61fcb0:	eb004bc2 	bl	8f632bc0 <__stack_chk_fail>
8f61fcb4:	8f74221c 	.word	0x8f74221c

8f61fcb8 <usb30_udc_stop>:
	/* TODO */
}

int usb30_udc_stop(void)
{
	dwc_device_run(udc_dev->dwc, 0);
8f61fcb8:	e30d318c 	movw	r3, #53644	; 0xd18c
8f61fcbc:	e3483f72 	movt	r3, #36722	; 0x8f72
{
8f61fcc0:	e59f2048 	ldr	r2, [pc, #72]	; 8f61fd10 <usb30_udc_stop+0x58>
	dwc_device_run(udc_dev->dwc, 0);
8f61fcc4:	e3a01000 	mov	r1, #0
8f61fcc8:	e5933000 	ldr	r3, [r3]
{
8f61fccc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61fcd0:	e24dd00c 	sub	r13, r13, #12
	dwc_device_run(udc_dev->dwc, 0);
8f61fcd4:	e5930004 	ldr	r0, [r3, #4]
{
8f61fcd8:	e5922000 	ldr	r2, [r2]
8f61fcdc:	e58d2004 	str	r2, [r13, #4]
8f61fce0:	e3a02000 	mov	r2, #0
	dwc_device_run(udc_dev->dwc, 0);
8f61fce4:	ebfff6a8 	bl	8f61d78c <dwc_device_run>

	return 0;
}
8f61fce8:	e59f3020 	ldr	r3, [pc, #32]	; 8f61fd10 <usb30_udc_stop+0x58>
8f61fcec:	e5932000 	ldr	r2, [r3]
8f61fcf0:	e59d3004 	ldr	r3, [r13, #4]
8f61fcf4:	e0332002 	eors	r2, r3, r2
8f61fcf8:	e3a03000 	mov	r3, #0
8f61fcfc:	1a000002 	bne	8f61fd0c <usb30_udc_stop+0x54>
8f61fd00:	e3a00000 	mov	r0, #0
8f61fd04:	e28dd00c 	add	r13, r13, #12
8f61fd08:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61fd0c:	eb004bab 	bl	8f632bc0 <__stack_chk_fail>
8f61fd10:	8f74221c 	.word	0x8f74221c

8f61fd14 <usb_wrapper_dbm_mode>:
#include <qmp_phy.h>


/* Configure DBM mode: by-pass or DBM */
void usb_wrapper_dbm_mode(usb_wrapper_dev_t *dev, dbm_mode_t mode)
{
8f61fd14:	e59f304c 	ldr	r3, [pc, #76]	; 8f61fd68 <usb_wrapper_dbm_mode+0x54>
	if (mode == DBM_MODE_BYPASS)
8f61fd18:	e3510000 	cmp	r1, #0
{
8f61fd1c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61fd20:	e24dd00c 	sub	r13, r13, #12
8f61fd24:	e5902000 	ldr	r2, [r0]
8f61fd28:	e5933000 	ldr	r3, [r3]
8f61fd2c:	e58d3004 	str	r3, [r13, #4]
8f61fd30:	e3a03000 	mov	r3, #0
	{
		REG_WRITE_FIELD(dev, GENERAL_CFG, DBM_EN, 0);
8f61fd34:	e5923008 	ldr	r3, [r2, #8]
8f61fd38:	03c33002 	biceq	r3, r3, #2
	}
	else
	{
		REG_WRITE_FIELD(dev, GENERAL_CFG, DBM_EN, 1);
8f61fd3c:	13833002 	orrne	r3, r3, #2
8f61fd40:	e5823008 	str	r3, [r2, #8]
	}
}
8f61fd44:	e59f301c 	ldr	r3, [pc, #28]	; 8f61fd68 <usb_wrapper_dbm_mode+0x54>
8f61fd48:	e5932000 	ldr	r2, [r3]
8f61fd4c:	e59d3004 	ldr	r3, [r13, #4]
8f61fd50:	e0332002 	eors	r2, r3, r2
8f61fd54:	e3a03000 	mov	r3, #0
8f61fd58:	1a000001 	bne	8f61fd64 <usb_wrapper_dbm_mode+0x50>
8f61fd5c:	e28dd00c 	add	r13, r13, #12
8f61fd60:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61fd64:	eb004b95 	bl	8f632bc0 <__stack_chk_fail>
8f61fd68:	8f74221c 	.word	0x8f74221c

8f61fd6c <usb_wrapper_ram_configure>:

/* use config 0: all of RAM1 */
void usb_wrapper_ram_configure(usb_wrapper_dev_t *dev)
{
	REG_WRITE(dev, RAM1_REG, 0x0);
8f61fd6c:	e5903000 	ldr	r3, [r0]
8f61fd70:	e3a02000 	mov	r2, #0
{
8f61fd74:	e59f1038 	ldr	r1, [pc, #56]	; 8f61fdb4 <usb_wrapper_ram_configure+0x48>
8f61fd78:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61fd7c:	e24dd00c 	sub	r13, r13, #12
8f61fd80:	e5911000 	ldr	r1, [r1]
8f61fd84:	e58d1004 	str	r1, [r13, #4]
8f61fd88:	e3a01000 	mov	r1, #0
	REG_WRITE(dev, RAM1_REG, 0x0);
8f61fd8c:	e583200c 	str	r2, [r3, #12]
}
8f61fd90:	e59f301c 	ldr	r3, [pc, #28]	; 8f61fdb4 <usb_wrapper_ram_configure+0x48>
8f61fd94:	e5932000 	ldr	r2, [r3]
8f61fd98:	e59d3004 	ldr	r3, [r13, #4]
8f61fd9c:	e0332002 	eors	r2, r3, r2
8f61fda0:	e3a03000 	mov	r3, #0
8f61fda4:	1a000001 	bne	8f61fdb0 <usb_wrapper_ram_configure+0x44>
8f61fda8:	e28dd00c 	add	r13, r13, #12
8f61fdac:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61fdb0:	eb004b82 	bl	8f632bc0 <__stack_chk_fail>
8f61fdb4:	8f74221c 	.word	0x8f74221c

8f61fdb8 <usb_wrapper_ss_phy_reset>:

/* reset SS phy */
void usb_wrapper_ss_phy_reset(usb_wrapper_dev_t *dev)
{
8f61fdb8:	e92d4010 	push	{r4, r14}
8f61fdbc:	e1a04000 	mov	r4, r0
8f61fdc0:	e59f3058 	ldr	r3, [pc, #88]	; 8f61fe20 <usb_wrapper_ss_phy_reset+0x68>
8f61fdc4:	e24dd008 	sub	r13, r13, #8
	REG_WRITE_FIELD(dev, SS_PHY_CTRL, SS_PHY_RESET, 1);
8f61fdc8:	e5942000 	ldr	r2, [r4]

	/* per HPG */
	udelay(10);
8f61fdcc:	e3a0000a 	mov	r0, #10
{
8f61fdd0:	e5933000 	ldr	r3, [r3]
8f61fdd4:	e58d3004 	str	r3, [r13, #4]
8f61fdd8:	e3a03000 	mov	r3, #0
	REG_WRITE_FIELD(dev, SS_PHY_CTRL, SS_PHY_RESET, 1);
8f61fddc:	e5923030 	ldr	r3, [r2, #48]	; 0x30
8f61fde0:	e3833080 	orr	r3, r3, #128	; 0x80
8f61fde4:	e5823030 	str	r3, [r2, #48]	; 0x30
	udelay(10);
8f61fde8:	ebffbbdb 	bl	8f60ed5c <udelay>

	REG_WRITE_FIELD(dev, SS_PHY_CTRL, SS_PHY_RESET, 0);
8f61fdec:	e5942000 	ldr	r2, [r4]
8f61fdf0:	e5923030 	ldr	r3, [r2, #48]	; 0x30
8f61fdf4:	e3c33080 	bic	r3, r3, #128	; 0x80
8f61fdf8:	e5823030 	str	r3, [r2, #48]	; 0x30
}
8f61fdfc:	e59f301c 	ldr	r3, [pc, #28]	; 8f61fe20 <usb_wrapper_ss_phy_reset+0x68>
8f61fe00:	e5932000 	ldr	r2, [r3]
8f61fe04:	e59d3004 	ldr	r3, [r13, #4]
8f61fe08:	e0332002 	eors	r2, r3, r2
8f61fe0c:	e3a03000 	mov	r3, #0
8f61fe10:	1a000001 	bne	8f61fe1c <usb_wrapper_ss_phy_reset+0x64>
8f61fe14:	e28dd008 	add	r13, r13, #8
8f61fe18:	e8bd8010 	pop	{r4, r15}
8f61fe1c:	eb004b67 	bl	8f632bc0 <__stack_chk_fail>
8f61fe20:	8f74221c 	.word	0x8f74221c

8f61fe24 <usb_wrapper_ss_phy_configure>:

/* configure SS phy as specified in HPG */
void usb_wrapper_ss_phy_configure(usb_wrapper_dev_t *dev)
{
8f61fe24:	e59f3094 	ldr	r3, [pc, #148]	; 8f61fec0 <usb_wrapper_ss_phy_configure+0x9c>
8f61fe28:	e92d4010 	push	{r4, r14}
8f61fe2c:	e24dd008 	sub	r13, r13, #8
8f61fe30:	e5933000 	ldr	r3, [r3]
8f61fe34:	e58d3004 	str	r3, [r13, #4]
8f61fe38:	e3a03000 	mov	r3, #0
	/* 4.a */
	REG_WRITE_FIELD(dev, SS_PHY_CTRL, REF_USE_PAD, 1);
8f61fe3c:	e5903000 	ldr	r3, [r0]
{
8f61fe40:	e1a04000 	mov	r4, r0
	REG_WRITE_FIELD(dev, SS_PHY_CTRL, REF_USE_PAD, 1);
8f61fe44:	e5932030 	ldr	r2, [r3, #48]	; 0x30
8f61fe48:	e3822201 	orr	r2, r2, #268435456	; 0x10000000
8f61fe4c:	e5832030 	str	r2, [r3, #48]	; 0x30
	/* .b */
	REG_WRITE_FIELD(dev, SS_PHY_CTRL, LANE0_PWR_PRESENT, 1);
8f61fe50:	e5932030 	ldr	r2, [r3, #48]	; 0x30
8f61fe54:	e3822401 	orr	r2, r2, #16777216	; 0x1000000
8f61fe58:	e5832030 	str	r2, [r3, #48]	; 0x30
	/* .c */
	REG_WRITE_FIELD(dev, SS_PHY_CTRL, REF_SS_PHY_EN, 1);
8f61fe5c:	e5932030 	ldr	r2, [r3, #48]	; 0x30
8f61fe60:	e3822c01 	orr	r2, r2, #256	; 0x100
8f61fe64:	e5832030 	str	r2, [r3, #48]	; 0x30

	/* For Aragorn V1, reset value fix is required.*/
	if ( (board_platform_id() == MSM8974) &&
8f61fe68:	ebffc0d7 	bl	8f6101cc <board_platform_id>
8f61fe6c:	e350007e 	cmp	r0, #126	; 0x7e
8f61fe70:	0a000007 	beq	8f61fe94 <usb_wrapper_ss_phy_configure+0x70>
		 (board_soc_version() < BOARD_SOC_VERSION2))
	{
		REG_WRITE_FIELD(dev, SS_PHY_CTRL, SSC_REF_CLK_SEL, 0x108);
	}
}
8f61fe74:	e59f3044 	ldr	r3, [pc, #68]	; 8f61fec0 <usb_wrapper_ss_phy_configure+0x9c>
8f61fe78:	e5932000 	ldr	r2, [r3]
8f61fe7c:	e59d3004 	ldr	r3, [r13, #4]
8f61fe80:	e0332002 	eors	r2, r3, r2
8f61fe84:	e3a03000 	mov	r3, #0
8f61fe88:	1a00000b 	bne	8f61febc <usb_wrapper_ss_phy_configure+0x98>
8f61fe8c:	e28dd008 	add	r13, r13, #8
8f61fe90:	e8bd8010 	pop	{r4, r15}
		 (board_soc_version() < BOARD_SOC_VERSION2))
8f61fe94:	ebffc15e 	bl	8f610414 <board_soc_version>
	if ( (board_platform_id() == MSM8974) &&
8f61fe98:	e3500802 	cmp	r0, #131072	; 0x20000
8f61fe9c:	2afffff4 	bcs	8f61fe74 <usb_wrapper_ss_phy_configure+0x50>
		REG_WRITE_FIELD(dev, SS_PHY_CTRL, SSC_REF_CLK_SEL, 0x108);
8f61fea0:	e5942000 	ldr	r2, [r4]
8f61fea4:	e5923030 	ldr	r3, [r2, #48]	; 0x30
8f61fea8:	e3c339ff 	bic	r3, r3, #4177920	; 0x3fc000
8f61feac:	e3c33a02 	bic	r3, r3, #8192	; 0x2000
8f61feb0:	e3833821 	orr	r3, r3, #2162688	; 0x210000
8f61feb4:	e5823030 	str	r3, [r2, #48]	; 0x30
}
8f61feb8:	eaffffed 	b	8f61fe74 <usb_wrapper_ss_phy_configure+0x50>
8f61febc:	eb004b3f 	bl	8f632bc0 <__stack_chk_fail>
8f61fec0:	8f74221c 	.word	0x8f74221c

8f61fec4 <usb_wrapper_ss_phy_electrical_config>:

/* configure SS phy electrical params */
void usb_wrapper_ss_phy_electrical_config(usb_wrapper_dev_t *dev)
{
8f61fec4:	e59f3034 	ldr	r3, [pc, #52]	; 8f61ff00 <usb_wrapper_ss_phy_electrical_config+0x3c>
8f61fec8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61fecc:	e24dd00c 	sub	r13, r13, #12
8f61fed0:	e5933000 	ldr	r3, [r3]
8f61fed4:	e58d3004 	str	r3, [r13, #4]
8f61fed8:	e3a03000 	mov	r3, #0
	/* reset value seems to work just fine for now. */
}
8f61fedc:	e59f301c 	ldr	r3, [pc, #28]	; 8f61ff00 <usb_wrapper_ss_phy_electrical_config+0x3c>
8f61fee0:	e5932000 	ldr	r2, [r3]
8f61fee4:	e59d3004 	ldr	r3, [r13, #4]
8f61fee8:	e0332002 	eors	r2, r3, r2
8f61feec:	e3a03000 	mov	r3, #0
8f61fef0:	1a000001 	bne	8f61fefc <usb_wrapper_ss_phy_electrical_config+0x38>
8f61fef4:	e28dd00c 	add	r13, r13, #12
8f61fef8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61fefc:	eb004b2f 	bl	8f632bc0 <__stack_chk_fail>
8f61ff00:	8f74221c 	.word	0x8f74221c

8f61ff04 <usb_wrapper_hs_phy_init>:

/* Initialize HS phy */
void usb_wrapper_hs_phy_init(usb_wrapper_dev_t *dev)
{
8f61ff04:	e59f3050 	ldr	r3, [pc, #80]	; 8f61ff5c <usb_wrapper_hs_phy_init+0x58>
8f61ff08:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61ff0c:	e24dd00c 	sub	r13, r13, #12
8f61ff10:	e5933000 	ldr	r3, [r3]
8f61ff14:	e58d3004 	str	r3, [r13, #4]
8f61ff18:	e3a03000 	mov	r3, #0
	/* 5.a */
	REG_WRITE_FIELD(dev, HS_PHY_CTRL, FREECLK_SEL, 0x0);
8f61ff1c:	e5903000 	ldr	r3, [r0]
8f61ff20:	e5932010 	ldr	r2, [r3, #16]
8f61ff24:	e3c22402 	bic	r2, r2, #33554432	; 0x2000000
8f61ff28:	e5832010 	str	r2, [r3, #16]

	/* 5.b */
	REG_WRITE_FIELD(dev, HS_PHY_CTRL, COMMONONN, 0x1);
8f61ff2c:	e5932010 	ldr	r2, [r3, #16]
8f61ff30:	e3822b02 	orr	r2, r2, #2048	; 0x800
8f61ff34:	e5832010 	str	r2, [r3, #16]
}
8f61ff38:	e59f301c 	ldr	r3, [pc, #28]	; 8f61ff5c <usb_wrapper_hs_phy_init+0x58>
8f61ff3c:	e5932000 	ldr	r2, [r3]
8f61ff40:	e59d3004 	ldr	r3, [r13, #4]
8f61ff44:	e0332002 	eors	r2, r3, r2
8f61ff48:	e3a03000 	mov	r3, #0
8f61ff4c:	1a000001 	bne	8f61ff58 <usb_wrapper_hs_phy_init+0x54>
8f61ff50:	e28dd00c 	add	r13, r13, #12
8f61ff54:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61ff58:	eb004b18 	bl	8f632bc0 <__stack_chk_fail>
8f61ff5c:	8f74221c 	.word	0x8f74221c

8f61ff60 <usb_wrapper_hs_phy_configure>:

/* configure HS phy as specified in HPG */
void usb_wrapper_hs_phy_configure(usb_wrapper_dev_t *dev)
{
	/* 6.a */
	REG_WRITE(dev, PARAMETER_OVERRIDE_X, 0xD190E4);
8f61ff60:	e5902000 	ldr	r2, [r0]
8f61ff64:	e30930e4 	movw	r3, #37092	; 0x90e4
{
8f61ff68:	e59f103c 	ldr	r1, [pc, #60]	; 8f61ffac <usb_wrapper_hs_phy_configure+0x4c>
	REG_WRITE(dev, PARAMETER_OVERRIDE_X, 0xD190E4);
8f61ff6c:	e34030d1 	movt	r3, #209	; 0xd1
{
8f61ff70:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f61ff74:	e24dd00c 	sub	r13, r13, #12
8f61ff78:	e5911000 	ldr	r1, [r1]
8f61ff7c:	e58d1004 	str	r1, [r13, #4]
8f61ff80:	e3a01000 	mov	r1, #0
	REG_WRITE(dev, PARAMETER_OVERRIDE_X, 0xD190E4);
8f61ff84:	e5823014 	str	r3, [r2, #20]
}
8f61ff88:	e59f301c 	ldr	r3, [pc, #28]	; 8f61ffac <usb_wrapper_hs_phy_configure+0x4c>
8f61ff8c:	e5932000 	ldr	r2, [r3]
8f61ff90:	e59d3004 	ldr	r3, [r13, #4]
8f61ff94:	e0332002 	eors	r2, r3, r2
8f61ff98:	e3a03000 	mov	r3, #0
8f61ff9c:	1a000001 	bne	8f61ffa8 <usb_wrapper_hs_phy_configure+0x48>
8f61ffa0:	e28dd00c 	add	r13, r13, #12
8f61ffa4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f61ffa8:	eb004b04 	bl	8f632bc0 <__stack_chk_fail>
8f61ffac:	8f74221c 	.word	0x8f74221c

8f61ffb0 <usb_wrapper_workaround_10>:

void usb_wrapper_workaround_10(usb_wrapper_dev_t *dev)
{
8f61ffb0:	e59f305c 	ldr	r3, [pc, #92]	; 8f620014 <usb_wrapper_workaround_10+0x64>
8f61ffb4:	e92d4010 	push	{r4, r14}
8f61ffb8:	e24dd008 	sub	r13, r13, #8
8f61ffbc:	e5933000 	ldr	r3, [r3]
8f61ffc0:	e58d3004 	str	r3, [r13, #4]
8f61ffc4:	e3a03000 	mov	r3, #0
8f61ffc8:	e1a04000 	mov	r4, r0
	/* 10. */
	if ( (board_platform_id() == MSM8974) &&
8f61ffcc:	ebffc07e 	bl	8f6101cc <board_platform_id>
8f61ffd0:	e350007e 	cmp	r0, #126	; 0x7e
8f61ffd4:	0a000007 	beq	8f61fff8 <usb_wrapper_workaround_10+0x48>
		 (board_soc_version() < BOARD_SOC_VERSION2))
	{
		REG_WRITE(dev, GENERAL_CFG, 0x78);
	}
}
8f61ffd8:	e59f3034 	ldr	r3, [pc, #52]	; 8f620014 <usb_wrapper_workaround_10+0x64>
8f61ffdc:	e5932000 	ldr	r2, [r3]
8f61ffe0:	e59d3004 	ldr	r3, [r13, #4]
8f61ffe4:	e0332002 	eors	r2, r3, r2
8f61ffe8:	e3a03000 	mov	r3, #0
8f61ffec:	1a000007 	bne	8f620010 <usb_wrapper_workaround_10+0x60>
8f61fff0:	e28dd008 	add	r13, r13, #8
8f61fff4:	e8bd8010 	pop	{r4, r15}
		 (board_soc_version() < BOARD_SOC_VERSION2))
8f61fff8:	ebffc105 	bl	8f610414 <board_soc_version>
	if ( (board_platform_id() == MSM8974) &&
8f61fffc:	e3500802 	cmp	r0, #131072	; 0x20000
		REG_WRITE(dev, GENERAL_CFG, 0x78);
8f620000:	35943000 	ldrcc	r3, [r4]
8f620004:	33a02078 	movcc	r2, #120	; 0x78
8f620008:	35832008 	strcc	r2, [r3, #8]
}
8f62000c:	eafffff1 	b	8f61ffd8 <usb_wrapper_workaround_10+0x28>
8f620010:	eb004aea 	bl	8f632bc0 <__stack_chk_fail>
8f620014:	8f74221c 	.word	0x8f74221c

8f620018 <usb_wrapper_workaround_11>:
8f620018:	e59f3034 	ldr	r3, [pc, #52]	; 8f620054 <usb_wrapper_workaround_11+0x3c>
8f62001c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f620020:	e24dd00c 	sub	r13, r13, #12
8f620024:	e5933000 	ldr	r3, [r3]
8f620028:	e58d3004 	str	r3, [r13, #4]
8f62002c:	e3a03000 	mov	r3, #0
8f620030:	e59f301c 	ldr	r3, [pc, #28]	; 8f620054 <usb_wrapper_workaround_11+0x3c>
8f620034:	e5932000 	ldr	r2, [r3]
8f620038:	e59d3004 	ldr	r3, [r13, #4]
8f62003c:	e0332002 	eors	r2, r3, r2
8f620040:	e3a03000 	mov	r3, #0
8f620044:	1a000001 	bne	8f620050 <usb_wrapper_workaround_11+0x38>
8f620048:	e28dd00c 	add	r13, r13, #12
8f62004c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f620050:	eb004ada 	bl	8f632bc0 <__stack_chk_fail>
8f620054:	8f74221c 	.word	0x8f74221c

8f620058 <usb_wrapper_workaround_13>:
	/* Not implemented. required if manually running the alt bus features.*/
}

/* workaround #13 as described in HPG */
void usb_wrapper_workaround_13(usb_wrapper_dev_t *dev)
{
8f620058:	e59f3048 	ldr	r3, [pc, #72]	; 8f6200a8 <usb_wrapper_workaround_13+0x50>
8f62005c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f620060:	e24dd00c 	sub	r13, r13, #12
	REG_WRITE_FIELD(dev, SS_PHY_PARAM_CTRL_1, LOS_BIAS, 0x5);
8f620064:	e5902000 	ldr	r2, [r0]
{
8f620068:	e5933000 	ldr	r3, [r3]
8f62006c:	e58d3004 	str	r3, [r13, #4]
8f620070:	e3a03000 	mov	r3, #0
	REG_WRITE_FIELD(dev, SS_PHY_PARAM_CTRL_1, LOS_BIAS, 0x5);
8f620074:	e5923034 	ldr	r3, [r2, #52]	; 0x34
8f620078:	e3c33007 	bic	r3, r3, #7
8f62007c:	e3833005 	orr	r3, r3, #5
8f620080:	e5823034 	str	r3, [r2, #52]	; 0x34
}
8f620084:	e59f301c 	ldr	r3, [pc, #28]	; 8f6200a8 <usb_wrapper_workaround_13+0x50>
8f620088:	e5932000 	ldr	r2, [r3]
8f62008c:	e59d3004 	ldr	r3, [r13, #4]
8f620090:	e0332002 	eors	r2, r3, r2
8f620094:	e3a03000 	mov	r3, #0
8f620098:	1a000001 	bne	8f6200a4 <usb_wrapper_workaround_13+0x4c>
8f62009c:	e28dd00c 	add	r13, r13, #12
8f6200a0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6200a4:	eb004ac5 	bl	8f632bc0 <__stack_chk_fail>
8f6200a8:	8f74221c 	.word	0x8f74221c

8f6200ac <usb_wrapper_vbus_override>:

void usb_wrapper_vbus_override(usb_wrapper_dev_t *dev)
{
8f6200ac:	e59f3084 	ldr	r3, [pc, #132]	; 8f620138 <usb_wrapper_vbus_override+0x8c>
8f6200b0:	e92d4010 	push	{r4, r14}
8f6200b4:	e24dd008 	sub	r13, r13, #8
8f6200b8:	e5933000 	ldr	r3, [r3]
8f6200bc:	e58d3004 	str	r3, [r13, #4]
8f6200c0:	e3a03000 	mov	r3, #0
	/* set extenal vbus valid select */
	REG_WRITE_FIELD(dev, HS_PHY_CTRL_COMMON, VBUSVLDEXTSEL0, 0x1);
8f6200c4:	e5903000 	ldr	r3, [r0]
{
8f6200c8:	e1a04000 	mov	r4, r0
	REG_WRITE_FIELD(dev, HS_PHY_CTRL_COMMON, VBUSVLDEXTSEL0, 0x1);
8f6200cc:	e59320ec 	ldr	r2, [r3, #236]	; 0xec
8f6200d0:	e3822a01 	orr	r2, r2, #4096	; 0x1000
8f6200d4:	e58320ec 	str	r2, [r3, #236]	; 0xec

	/* enable D+ pullup */
	REG_WRITE_FIELD(dev, HS_PHY_CTRL, VBUSVLDEXT0, 0x1);
8f6200d8:	e5932010 	ldr	r2, [r3, #16]
8f6200dc:	e3822a02 	orr	r2, r2, #8192	; 0x2000
8f6200e0:	e5832010 	str	r2, [r3, #16]

	/* set otg vbus valid from hs phy to controller */
	REG_WRITE_FIELD(dev, HS_PHY_CTRL, UTMI_OTG_VBUS_VALID, 0x1);
8f6200e4:	e5932010 	ldr	r2, [r3, #16]
8f6200e8:	e3822601 	orr	r2, r2, #1048576	; 0x100000
8f6200ec:	e5832010 	str	r2, [r3, #16]

	/* Indicate value is driven by UTMI_OTG_VBUS_VALID bit */
	REG_WRITE_FIELD(dev, HS_PHY_CTRL, SW_SESSVLD_SEL, 0x1);
8f6200f0:	e5932010 	ldr	r2, [r3, #16]
8f6200f4:	e3822201 	orr	r2, r2, #268435456	; 0x10000000
8f6200f8:	e5832010 	str	r2, [r3, #16]

	/* Indicate power present to SS phy */
	if (!use_hsonly_mode())
8f6200fc:	ebffe84f 	bl	8f61a240 <use_hsonly_mode>
8f620100:	e3500000 	cmp	r0, #0
		REG_WRITE_FIELD(dev, SS_PHY_CTRL, LANE0_PWR_PRESENT, 0x1);
8f620104:	05942000 	ldreq	r2, [r4]
8f620108:	05923030 	ldreq	r3, [r2, #48]	; 0x30
8f62010c:	03833401 	orreq	r3, r3, #16777216	; 0x1000000
8f620110:	05823030 	streq	r3, [r2, #48]	; 0x30
}
8f620114:	e59f301c 	ldr	r3, [pc, #28]	; 8f620138 <usb_wrapper_vbus_override+0x8c>
8f620118:	e5932000 	ldr	r2, [r3]
8f62011c:	e59d3004 	ldr	r3, [r13, #4]
8f620120:	e0332002 	eors	r2, r3, r2
8f620124:	e3a03000 	mov	r3, #0
8f620128:	1a000001 	bne	8f620134 <usb_wrapper_vbus_override+0x88>
8f62012c:	e28dd008 	add	r13, r13, #8
8f620130:	e8bd8010 	pop	{r4, r15}
8f620134:	eb004aa1 	bl	8f632bc0 <__stack_chk_fail>
8f620138:	8f74221c 	.word	0x8f74221c

8f62013c <usb_wrapper_init>:
	ASSERT(0);
}

/* initialize the wrapper core */
usb_wrapper_dev_t * usb_wrapper_init(usb_wrapper_config_t *config)
{
8f62013c:	e59f3098 	ldr	r3, [pc, #152]	; 8f6201dc <usb_wrapper_init+0xa0>
8f620140:	e92d4070 	push	{r4, r5, r6, r14}
8f620144:	e1a05000 	mov	r5, r0
8f620148:	e24dd010 	sub	r13, r13, #16
	usb_wrapper_dev_t *wrapper;

	/* create a wrapper device */
	wrapper = (usb_wrapper_dev_t*) malloc(sizeof(usb_wrapper_dev_t));
8f62014c:	e3a00004 	mov	r0, #4
{
8f620150:	e5933000 	ldr	r3, [r3]
8f620154:	e58d300c 	str	r3, [r13, #12]
8f620158:	e3a03000 	mov	r3, #0
	wrapper = (usb_wrapper_dev_t*) malloc(sizeof(usb_wrapper_dev_t));
8f62015c:	e1a0600e 	mov	r6, r14
8f620160:	eb004fa5 	bl	8f633ffc <malloc>
	ASSERT(wrapper);
8f620164:	e2504000 	subs	r4, r0, #0
8f620168:	0a00000f 	beq	8f6201ac <usb_wrapper_init+0x70>

	/* save qscratch base */
	wrapper->base = config->qscratch_base;
8f62016c:	e5953000 	ldr	r3, [r5]
	REG_WRITE(dev, RAM1_REG, 0x0);
8f620170:	e3a01000 	mov	r1, #0
		REG_WRITE_FIELD(dev, GENERAL_CFG, DBM_EN, 0);
8f620174:	e5932008 	ldr	r2, [r3, #8]
	wrapper->base = config->qscratch_base;
8f620178:	e5843000 	str	r3, [r4]
		REG_WRITE_FIELD(dev, GENERAL_CFG, DBM_EN, 0);
8f62017c:	e3c22002 	bic	r2, r2, #2
8f620180:	e5832008 	str	r2, [r3, #8]
	REG_WRITE(dev, RAM1_REG, 0x0);
8f620184:	e583100c 	str	r1, [r3, #12]

	/* HPG: section 4.4.1: use config 0 - all of RAM1 */
	usb_wrapper_ram_configure(wrapper);

	return wrapper;
}
8f620188:	e59f304c 	ldr	r3, [pc, #76]	; 8f6201dc <usb_wrapper_init+0xa0>
8f62018c:	e5932000 	ldr	r2, [r3]
8f620190:	e59d300c 	ldr	r3, [r13, #12]
8f620194:	e0332002 	eors	r2, r3, r2
8f620198:	e3a03000 	mov	r3, #0
8f62019c:	1a00000d 	bne	8f6201d8 <usb_wrapper_init+0x9c>
8f6201a0:	e1a00004 	mov	r0, r4
8f6201a4:	e28dd010 	add	r13, r13, #16
8f6201a8:	e8bd8070 	pop	{r4, r5, r6, r15}
	ASSERT(wrapper);
8f6201ac:	e307125c 	movw	r1, #29276	; 0x725c
8f6201b0:	e3072378 	movw	r2, #29560	; 0x7378
8f6201b4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6201b8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6201bc:	e58d1000 	str	r1, [r13]
8f6201c0:	e3a030ef 	mov	r3, #239	; 0xef
8f6201c4:	e1a00006 	mov	r0, r6
8f6201c8:	e3001130 	movw	r1, #304	; 0x130
8f6201cc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6201d0:	eb004a39 	bl	8f632abc <_panic>
8f6201d4:	eaffffe4 	b	8f62016c <usb_wrapper_init+0x30>
}
8f6201d8:	eb004a78 	bl	8f632bc0 <__stack_chk_fail>
8f6201dc:	8f74221c 	.word	0x8f74221c

8f6201e0 <usb_wrapper_hs_phy_ctrl_force_write>:

void usb_wrapper_hs_phy_ctrl_force_write(usb_wrapper_dev_t *dev)
{
	REG_WRITE(dev, HS_PHY_CTRL_COMMON, 0x00001CB8);
8f6201e0:	e5903000 	ldr	r3, [r0]
8f6201e4:	e3012cb8 	movw	r2, #7352	; 0x1cb8
{
8f6201e8:	e59f1038 	ldr	r1, [pc, #56]	; 8f620228 <usb_wrapper_hs_phy_ctrl_force_write+0x48>
8f6201ec:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6201f0:	e24dd00c 	sub	r13, r13, #12
8f6201f4:	e5911000 	ldr	r1, [r1]
8f6201f8:	e58d1004 	str	r1, [r13, #4]
8f6201fc:	e3a01000 	mov	r1, #0
	REG_WRITE(dev, HS_PHY_CTRL_COMMON, 0x00001CB8);
8f620200:	e58320ec 	str	r2, [r3, #236]	; 0xec
}
8f620204:	e59f301c 	ldr	r3, [pc, #28]	; 8f620228 <usb_wrapper_hs_phy_ctrl_force_write+0x48>
8f620208:	e5932000 	ldr	r2, [r3]
8f62020c:	e59d3004 	ldr	r3, [r13, #4]
8f620210:	e0332002 	eors	r2, r3, r2
8f620214:	e3a03000 	mov	r3, #0
8f620218:	1a000001 	bne	8f620224 <usb_wrapper_hs_phy_ctrl_force_write+0x44>
8f62021c:	e28dd00c 	add	r13, r13, #12
8f620220:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f620224:	eb004a65 	bl	8f632bc0 <__stack_chk_fail>
8f620228:	8f74221c 	.word	0x8f74221c

8f62022c <usb_wrapper_hsonly_mode>:

void usb_wrapper_hsonly_mode(usb_wrapper_dev_t *dev)
{
8f62022c:	e92d4010 	push	{r4, r14}
8f620230:	e1a04000 	mov	r4, r0
8f620234:	e59f307c 	ldr	r3, [pc, #124]	; 8f6202b8 <usb_wrapper_hsonly_mode+0x8c>
8f620238:	e24dd008 	sub	r13, r13, #8
	REG_WRITE_FIELD(dev, GENERAL_CFG, PIPE_UTMI_CLK_DIS, 0x1);
8f62023c:	e5942000 	ldr	r2, [r4]
	udelay(1);
8f620240:	e3a00001 	mov	r0, #1
{
8f620244:	e5933000 	ldr	r3, [r3]
8f620248:	e58d3004 	str	r3, [r13, #4]
8f62024c:	e3a03000 	mov	r3, #0
	REG_WRITE_FIELD(dev, GENERAL_CFG, PIPE_UTMI_CLK_DIS, 0x1);
8f620250:	e5923008 	ldr	r3, [r2, #8]
8f620254:	e3833c01 	orr	r3, r3, #256	; 0x100
8f620258:	e5823008 	str	r3, [r2, #8]
	udelay(1);
8f62025c:	ebffbabe 	bl	8f60ed5c <udelay>
	REG_WRITE_FIELD(dev, GENERAL_CFG, PIPE_UTMI_CLK_SEL, 0x1);
8f620260:	e5943000 	ldr	r3, [r4]
	REG_WRITE_FIELD(dev, GENERAL_CFG, PIPE3_PHYSTATUS_SW, 0x1);
	udelay(1);
8f620264:	e3a00001 	mov	r0, #1
	REG_WRITE_FIELD(dev, GENERAL_CFG, PIPE_UTMI_CLK_SEL, 0x1);
8f620268:	e5932008 	ldr	r2, [r3, #8]
8f62026c:	e1822000 	orr	r2, r2, r0
8f620270:	e5832008 	str	r2, [r3, #8]
	REG_WRITE_FIELD(dev, GENERAL_CFG, PIPE3_PHYSTATUS_SW, 0x1);
8f620274:	e5932008 	ldr	r2, [r3, #8]
8f620278:	e3822008 	orr	r2, r2, #8
8f62027c:	e5832008 	str	r2, [r3, #8]
	udelay(1);
8f620280:	ebffbab5 	bl	8f60ed5c <udelay>
	REG_WRITE_FIELD(dev, GENERAL_CFG, PIPE_UTMI_CLK_DIS, 0x0);
8f620284:	e5942000 	ldr	r2, [r4]
8f620288:	e5923008 	ldr	r3, [r2, #8]
8f62028c:	e3c33c01 	bic	r3, r3, #256	; 0x100
8f620290:	e5823008 	str	r3, [r2, #8]
}
8f620294:	e59f301c 	ldr	r3, [pc, #28]	; 8f6202b8 <usb_wrapper_hsonly_mode+0x8c>
8f620298:	e5932000 	ldr	r2, [r3]
8f62029c:	e59d3004 	ldr	r3, [r13, #4]
8f6202a0:	e0332002 	eors	r2, r3, r2
8f6202a4:	e3a03000 	mov	r3, #0
8f6202a8:	1a000001 	bne	8f6202b4 <usb_wrapper_hsonly_mode+0x88>
8f6202ac:	e28dd008 	add	r13, r13, #8
8f6202b0:	e8bd8010 	pop	{r4, r15}
8f6202b4:	eb004a41 	bl	8f632bc0 <__stack_chk_fail>
8f6202b8:	8f74221c 	.word	0x8f74221c

8f6202bc <check_hard_reboot_mode>:

	return restart_reason;
}

unsigned check_hard_reboot_mode(void)
{
8f6202bc:	e59f3050 	ldr	r3, [pc, #80]	; 8f620314 <check_hard_reboot_mode+0x58>
	uint8_t hard_restart_reason = 0;

	/* Read reboot reason and scrub it
	 * Bit-2 to bit-7 of SOFT_RB_SPARE for hard reset reason
	 */
	hard_restart_reason = REG_READ(PON_SOFT_RB_SPARE);
8f6202c0:	e300088f 	movw	r0, #2191	; 0x88f
{
8f6202c4:	e92d4010 	push	{r4, r14}
8f6202c8:	e24dd008 	sub	r13, r13, #8
8f6202cc:	e5933000 	ldr	r3, [r3]
8f6202d0:	e58d3004 	str	r3, [r13, #4]
8f6202d4:	e3a03000 	mov	r3, #0
	hard_restart_reason = REG_READ(PON_SOFT_RB_SPARE);
8f6202d8:	eb004266 	bl	8f630c78 <pm8x41_reg_read>
8f6202dc:	e1a04000 	mov	r4, r0
	REG_WRITE(PON_SOFT_RB_SPARE, hard_restart_reason & 0x03);
8f6202e0:	e300088f 	movw	r0, #2191	; 0x88f
8f6202e4:	e2041003 	and	r1, r4, #3
8f6202e8:	eb0042bb 	bl	8f630ddc <pm8x41_reg_write>

	/* Extract the bits 2 to 7 and return */
	return (hard_restart_reason & 0xFC) >> 2;
}
8f6202ec:	e59f3020 	ldr	r3, [pc, #32]	; 8f620314 <check_hard_reboot_mode+0x58>
	return (hard_restart_reason & 0xFC) >> 2;
8f6202f0:	e7e70154 	ubfx	r0, r4, #2, #8
}
8f6202f4:	e5932000 	ldr	r2, [r3]
8f6202f8:	e59d3004 	ldr	r3, [r13, #4]
8f6202fc:	e0332002 	eors	r2, r3, r2
8f620300:	e3a03000 	mov	r3, #0
8f620304:	1a000001 	bne	8f620310 <check_hard_reboot_mode+0x54>
8f620308:	e28dd008 	add	r13, r13, #8
8f62030c:	e8bd8010 	pop	{r4, r15}
8f620310:	eb004a2a 	bl	8f632bc0 <__stack_chk_fail>
8f620314:	8f74221c 	.word	0x8f74221c

8f620318 <reboot_device>:

	return 0;
}

void reboot_device(unsigned reboot_reason)
{
8f620318:	e59f30ec 	ldr	r3, [pc, #236]	; 8f62040c <reboot_device+0xf4>
8f62031c:	e92d4010 	push	{r4, r14}
8f620320:	e24dd008 	sub	r13, r13, #8
8f620324:	e5933000 	ldr	r3, [r3]
8f620328:	e58d3004 	str	r3, [r13, #4]
8f62032c:	e3a03000 	mov	r3, #0
8f620330:	e1a04000 	mov	r4, r0
#if USE_PON_REBOOT_REG
	uint8_t value;
#endif

	/* Set cookie for dload mode */
	if(set_download_mode(reboot_reason)) {
8f620334:	ebff825e 	bl	8f600cb4 <set_download_mode>
8f620338:	e3500000 	cmp	r0, #0
8f62033c:	1a000029 	bne	8f6203e8 <reboot_device+0xd0>
		dprintf(CRITICAL, "HALT: set_download_mode not supported\n");
		return;
	}

	if (reboot_reason != NORMAL_DLOAD && reboot_reason != EMERGENCY_DLOAD) {
8f620340:	e244321f 	sub	r3, r4, #-268435455	; 0xf0000001
8f620344:	e3530001 	cmp	r3, #1
	if(reboot_reason == NORMAL_DLOAD || reboot_reason == EMERGENCY_DLOAD) {
#else
	if(reboot_reason == FASTBOOT_MODE || reboot_reason == NORMAL_DLOAD ||
		reboot_reason == EMERGENCY_DLOAD || reboot_reason == RECOVERY_MODE) {
#endif
		reset_type = PON_PSHOLD_WARM_RESET;
8f620348:	93a00001 	movls	r0, #1
	if (reboot_reason != NORMAL_DLOAD && reboot_reason != EMERGENCY_DLOAD) {
8f62034c:	8a00001d 	bhi	8f6203c8 <reboot_device+0xb0>
#endif
	} else {
		reset_type = PON_PSHOLD_HARD_RESET;
	}

	pmic_reset_configure(reset_type);
8f620350:	ebff836e 	bl	8f601110 <pmic_reset_configure>

	/* Force spmi shutdown to avoid spmi lock up on some pmics */
	ret = is_scm_call_available(SCM_SVC_PWR, SCM_IO_DISABLE_PMIC_ARBITER);
8f620354:	e3a01001 	mov	r1, #1
8f620358:	e3a00009 	mov	r0, #9
8f62035c:	ebffccd2 	bl	8f6136ac <is_scm_call_available>
	if ( ret > 0)
8f620360:	e3500000 	cmp	r0, #0
8f620364:	ca000010 	bgt	8f6203ac <reboot_device+0x94>
		if (ret)
			dprintf(CRITICAL , "Failed to halt pmic arbiter: %d\n", ret);
	}

	/* Drop PS_HOLD for MSM */
	writel(0x00, MPM2_MPM_PS_HOLD);
8f620368:	e3a03a0b 	mov	r3, #45056	; 0xb000
8f62036c:	e340304a 	movt	r3, #74	; 0x4a
8f620370:	e3a02000 	mov	r2, #0

	mdelay(5000);
8f620374:	e3010388 	movw	r0, #5000	; 0x1388
	writel(0x00, MPM2_MPM_PS_HOLD);
8f620378:	e5832000 	str	r2, [r3]
	mdelay(5000);
8f62037c:	ebffba5e 	bl	8f60ecfc <mdelay>

	dprintf(CRITICAL, "Rebooting failed\n");
8f620380:	e59f3084 	ldr	r3, [pc, #132]	; 8f62040c <reboot_device+0xf4>
8f620384:	e5932000 	ldr	r2, [r3]
8f620388:	e59d3004 	ldr	r3, [r13, #4]
8f62038c:	e0332002 	eors	r2, r3, r2
8f620390:	e3a03000 	mov	r3, #0
8f620394:	030703e8 	movweq	r0, #29672	; 0x73e8
8f620398:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62039c:	1a000019 	bne	8f620408 <reboot_device+0xf0>
}
8f6203a0:	e28dd008 	add	r13, r13, #8
8f6203a4:	e8bd4010 	pop	{r4, r14}
	dprintf(CRITICAL, "Rebooting failed\n");
8f6203a8:	ea004971 	b	8f632974 <_dprintf>
		ret = scm_halt_pmic_arbiter();
8f6203ac:	ebffd11e 	bl	8f61482c <scm_halt_pmic_arbiter>
		if (ret)
8f6203b0:	e2501000 	subs	r1, r0, #0
8f6203b4:	0affffeb 	beq	8f620368 <reboot_device+0x50>
			dprintf(CRITICAL , "Failed to halt pmic arbiter: %d\n", ret);
8f6203b8:	e30703c4 	movw	r0, #29636	; 0x73c4
8f6203bc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6203c0:	eb00496b 	bl	8f632974 <_dprintf>
8f6203c4:	eaffffe7 	b	8f620368 <reboot_device+0x50>
		value = REG_READ(PON_SOFT_RB_SPARE);
8f6203c8:	e300088f 	movw	r0, #2191	; 0x88f
8f6203cc:	eb004229 	bl	8f630c78 <pm8x41_reg_read>
		value |= (reboot_reason << 2);
8f6203d0:	e1801104 	orr	r1, r0, r4, lsl #2
		REG_WRITE(PON_SOFT_RB_SPARE, value);
8f6203d4:	e300088f 	movw	r0, #2191	; 0x88f
8f6203d8:	e6ef1071 	uxtb	r1, r1
8f6203dc:	eb00427e 	bl	8f630ddc <pm8x41_reg_write>
		reset_type = PON_PSHOLD_HARD_RESET;
8f6203e0:	e3a00007 	mov	r0, #7
8f6203e4:	eaffffd9 	b	8f620350 <reboot_device+0x38>
		dprintf(CRITICAL, "HALT: set_download_mode not supported\n");
8f6203e8:	e59f301c 	ldr	r3, [pc, #28]	; 8f62040c <reboot_device+0xf4>
8f6203ec:	e5932000 	ldr	r2, [r3]
8f6203f0:	e59d3004 	ldr	r3, [r13, #4]
8f6203f4:	e0332002 	eors	r2, r3, r2
8f6203f8:	e3a03000 	mov	r3, #0
8f6203fc:	0307039c 	movweq	r0, #29596	; 0x739c
8f620400:	03480f70 	movteq	r0, #36720	; 0x8f70
8f620404:	0affffe5 	beq	8f6203a0 <reboot_device+0x88>
	dprintf(CRITICAL, "Rebooting failed\n");
8f620408:	eb0049ec 	bl	8f632bc0 <__stack_chk_fail>
8f62040c:	8f74221c 	.word	0x8f74221c

8f620410 <shutdown_device>:

void shutdown_device()
{
8f620410:	e59f3098 	ldr	r3, [pc, #152]	; 8f6204b0 <shutdown_device+0xa0>
	dprintf(CRITICAL, "Going down for shutdown.\n");
8f620414:	e30703fc 	movw	r0, #29692	; 0x73fc
{
8f620418:	e92d4010 	push	{r4, r14}
	dprintf(CRITICAL, "Going down for shutdown.\n");
8f62041c:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f620420:	e24dd010 	sub	r13, r13, #16
8f620424:	e1a0400e 	mov	r4, r14
8f620428:	e5933000 	ldr	r3, [r3]
8f62042c:	e58d300c 	str	r3, [r13, #12]
8f620430:	e3a03000 	mov	r3, #0
	dprintf(CRITICAL, "Going down for shutdown.\n");
8f620434:	eb00494e 	bl	8f632974 <_dprintf>

	/* Configure PMIC for shutdown. */
	pmic_reset_configure(PON_PSHOLD_SHUTDOWN);
8f620438:	e3a00004 	mov	r0, #4
8f62043c:	ebff8333 	bl	8f601110 <pmic_reset_configure>

	/* Drop PS_HOLD for MSM */
	writel(0x00, MPM2_MPM_PS_HOLD);
8f620440:	e3a03a0b 	mov	r3, #45056	; 0xb000
8f620444:	e340304a 	movt	r3, #74	; 0x4a
8f620448:	e3a02000 	mov	r2, #0

	mdelay(5000);
8f62044c:	e3010388 	movw	r0, #5000	; 0x1388
	writel(0x00, MPM2_MPM_PS_HOLD);
8f620450:	e5832000 	str	r2, [r3]
	mdelay(5000);
8f620454:	ebffba28 	bl	8f60ecfc <mdelay>

	dprintf(CRITICAL, "Shutdown failed\n");
8f620458:	e3070418 	movw	r0, #29720	; 0x7418
8f62045c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f620460:	eb004943 	bl	8f632974 <_dprintf>

	ASSERT(0);
8f620464:	e3a030ad 	mov	r3, #173	; 0xad
8f620468:	e307cf64 	movw	r12, #32612	; 0x7f64
8f62046c:	e307242c 	movw	r2, #29740	; 0x742c
8f620470:	e348cf70 	movt	r12, #36720	; 0x8f70
8f620474:	e3482f70 	movt	r2, #36720	; 0x8f70
8f620478:	e3001130 	movw	r1, #304	; 0x130
8f62047c:	e1a00004 	mov	r0, r4
8f620480:	e3481f70 	movt	r1, #36720	; 0x8f70
8f620484:	e58dc000 	str	r12, [r13]
8f620488:	eb00498b 	bl	8f632abc <_panic>
}
8f62048c:	e59f301c 	ldr	r3, [pc, #28]	; 8f6204b0 <shutdown_device+0xa0>
8f620490:	e5932000 	ldr	r2, [r3]
8f620494:	e59d300c 	ldr	r3, [r13, #12]
8f620498:	e0332002 	eors	r2, r3, r2
8f62049c:	e3a03000 	mov	r3, #0
8f6204a0:	1a000001 	bne	8f6204ac <shutdown_device+0x9c>
8f6204a4:	e28dd010 	add	r13, r13, #16
8f6204a8:	e8bd8010 	pop	{r4, r15}
8f6204ac:	eb0049c3 	bl	8f632bc0 <__stack_chk_fail>
8f6204b0:	8f74221c 	.word	0x8f74221c

8f6204b4 <rpmb_init>:

static void *dev;
struct rpmb_init_info info;

int rpmb_init()
{
8f6204b4:	e59f3108 	ldr	r3, [pc, #264]	; 8f6205c4 <rpmb_init+0x110>
8f6204b8:	e92d4010 	push	{r4, r14}
8f6204bc:	e24dd008 	sub	r13, r13, #8
8f6204c0:	e5933000 	ldr	r3, [r3]
8f6204c4:	e58d3004 	str	r3, [r13, #4]
8f6204c8:	e3a03000 	mov	r3, #0
	int ret = 0;

	dev = target_mmc_device();
8f6204cc:	ebff805b 	bl	8f600640 <target_mmc_device>
8f6204d0:	e30d4198 	movw	r4, #53656	; 0xd198
8f6204d4:	e3484f72 	movt	r4, #36722	; 0x8f72
8f6204d8:	e5840000 	str	r0, [r4]

	/* 1. Initialize storage specific data */
	if (platform_boot_dev_isemmc())
8f6204dc:	eb000501 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f6204e0:	e3500000 	cmp	r0, #0
8f6204e4:	0a000019 	beq	8f620550 <rpmb_init+0x9c>
	{
		struct mmc_device *mmc_dev = (struct mmc_device *) dev;
8f6204e8:	e5943000 	ldr	r3, [r4]
		info.size = mmc_dev->card.rpmb_size / RPMB_MIN_BLK_SZ;
8f6204ec:	e3024cb4 	movw	r4, #11444	; 0x2cb4
8f6204f0:	e3484f74 	movt	r4, #36724	; 0x8f74

		if ((mmc_dev->card.ext_csd !=NULL) &&
8f6204f4:	e5932058 	ldr	r2, [r3, #88]	; 0x58
		info.size = mmc_dev->card.rpmb_size / RPMB_MIN_BLK_SZ;
8f6204f8:	e5933074 	ldr	r3, [r3, #116]	; 0x74
		if ((mmc_dev->card.ext_csd !=NULL) &&
8f6204fc:	e3520000 	cmp	r2, #0
		info.size = mmc_dev->card.rpmb_size / RPMB_MIN_BLK_SZ;
8f620500:	e1a034a3 	lsr	r3, r3, #9
8f620504:	e5843000 	str	r3, [r4]
		if ((mmc_dev->card.ext_csd !=NULL) &&
8f620508:	0a000005 	beq	8f620524 <rpmb_init+0x70>
8f62050c:	e5d230c0 	ldrb	r3, [r2, #192]	; 0xc0
8f620510:	e3530007 	cmp	r3, #7
8f620514:	9a00001d 	bls	8f620590 <rpmb_init+0xdc>
			dprintf(SPEW, "EMMC Version < 5.1\n");
			info.rel_wr_count = 1;
		}
		else
		{
			if ((mmc_dev->card.ext_csd !=NULL) &&
8f620518:	e5d230a6 	ldrb	r3, [r2, #166]	; 0xa6
8f62051c:	e3130010 	tst	r3, #16
8f620520:	0a000020 	beq	8f6205a8 <rpmb_init+0xf4>
        		*/
				info.rel_wr_count = 1;
			}
			else
			{
				dprintf(SPEW, "EMMC Version >= 5.1 EN_RPMB_REL_WR = 1\n");
8f620524:	e3070488 	movw	r0, #29832	; 0x7488
8f620528:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62052c:	eb004910 	bl	8f632974 <_dprintf>
				// according to emmc version 5.1 and above if EN_RPMB_REL_WR in extended
				// csd is set the maximum number of frames that can be reliably written
				// to emmc would be 32
				info.rel_wr_count = 32;
8f620530:	e3a03020 	mov	r3, #32
8f620534:	e5843004 	str	r3, [r4, #4]
		 *  tz changes required for supporting
		 *  multiple frames are not present
		 *  force the number of frames to be minimum
		 *  i.e. one for tz 3.0 and earlier.
		 */
		if( qseecom_get_version() < QSEE_VERSION_40 )
8f620538:	ebffdacd 	bl	8f617074 <qseecom_get_version>
8f62053c:	e3500401 	cmp	r0, #16777216	; 0x1000000
			info.rel_wr_count = 1;
8f620540:	33a03001 	movcc	r3, #1
8f620544:	35843004 	strcc	r3, [r4, #4]

		info.dev_type  = EMMC_RPMB;
8f620548:	e3a03003 	mov	r3, #3
8f62054c:	e5843008 	str	r3, [r4, #8]
		info.dev_type  = UFS_RPMB;
	}
#endif

	/* Register & start the listener */
	ret = rpmb_listener_start();
8f620550:	eb00012e 	bl	8f620a10 <rpmb_listener_start>
	if (ret < 0)
8f620554:	e2504000 	subs	r4, r0, #0
8f620558:	ba000008 	blt	8f620580 <rpmb_init+0xcc>
		goto err;
	}

err:
	return ret;
}
8f62055c:	e59f3060 	ldr	r3, [pc, #96]	; 8f6205c4 <rpmb_init+0x110>
8f620560:	e5932000 	ldr	r2, [r3]
8f620564:	e59d3004 	ldr	r3, [r13, #4]
8f620568:	e0332002 	eors	r2, r3, r2
8f62056c:	e3a03000 	mov	r3, #0
8f620570:	1a000012 	bne	8f6205c0 <rpmb_init+0x10c>
8f620574:	e1a00004 	mov	r0, r4
8f620578:	e28dd008 	add	r13, r13, #8
8f62057c:	e8bd8010 	pop	{r4, r15}
		dprintf(CRITICAL, "Error registering the handler\n");
8f620580:	e30704b0 	movw	r0, #29872	; 0x74b0
8f620584:	e3480f70 	movt	r0, #36720	; 0x8f70
8f620588:	eb0048f9 	bl	8f632974 <_dprintf>
	return ret;
8f62058c:	eafffff2 	b	8f62055c <rpmb_init+0xa8>
			dprintf(SPEW, "EMMC Version < 5.1\n");
8f620590:	e307044c 	movw	r0, #29772	; 0x744c
8f620594:	e3480f70 	movt	r0, #36720	; 0x8f70
8f620598:	eb0048f5 	bl	8f632974 <_dprintf>
			info.rel_wr_count = 1;
8f62059c:	e3a03001 	mov	r3, #1
8f6205a0:	e5843004 	str	r3, [r4, #4]
8f6205a4:	eaffffe3 	b	8f620538 <rpmb_init+0x84>
				dprintf(SPEW, "EMMC Version >= 5.1 EN_RPMB_REL_WR = 0\n");
8f6205a8:	e3070460 	movw	r0, #29792	; 0x7460
8f6205ac:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6205b0:	eb0048ef 	bl	8f632974 <_dprintf>
				info.rel_wr_count = 1;
8f6205b4:	e3a03001 	mov	r3, #1
8f6205b8:	e5843004 	str	r3, [r4, #4]
8f6205bc:	eaffffdd 	b	8f620538 <rpmb_init+0x84>
}
8f6205c0:	eb00497e 	bl	8f632bc0 <__stack_chk_fail>
8f6205c4:	8f74221c 	.word	0x8f74221c

8f6205c8 <rpmb_get_init_info>:

struct rpmb_init_info *rpmb_get_init_info()
{
8f6205c8:	e59f303c 	ldr	r3, [pc, #60]	; 8f62060c <rpmb_get_init_info+0x44>
8f6205cc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6205d0:	e24dd00c 	sub	r13, r13, #12
8f6205d4:	e5933000 	ldr	r3, [r3]
8f6205d8:	e58d3004 	str	r3, [r13, #4]
8f6205dc:	e3a03000 	mov	r3, #0
	return &info;
}
8f6205e0:	e59f3024 	ldr	r3, [pc, #36]	; 8f62060c <rpmb_get_init_info+0x44>
8f6205e4:	e5932000 	ldr	r2, [r3]
8f6205e8:	e59d3004 	ldr	r3, [r13, #4]
8f6205ec:	e0332002 	eors	r2, r3, r2
8f6205f0:	e3a03000 	mov	r3, #0
8f6205f4:	1a000003 	bne	8f620608 <rpmb_get_init_info+0x40>
8f6205f8:	e3020cb4 	movw	r0, #11444	; 0x2cb4
8f6205fc:	e3480f74 	movt	r0, #36724	; 0x8f74
8f620600:	e28dd00c 	add	r13, r13, #12
8f620604:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f620608:	eb00496c 	bl	8f632bc0 <__stack_chk_fail>
8f62060c:	8f74221c 	.word	0x8f74221c

8f620610 <rpmb_read>:

int rpmb_read(uint32_t *req, uint32_t req_len, uint32_t *resp, uint32_t *resp_len)
{
8f620610:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f620614:	e1a04003 	mov	r4, r3
8f620618:	e59f306c 	ldr	r3, [pc, #108]	; 8f62068c <rpmb_read+0x7c>
8f62061c:	e24dd014 	sub	r13, r13, #20
8f620620:	e1a05000 	mov	r5, r0
8f620624:	e1a07001 	mov	r7, r1
8f620628:	e5933000 	ldr	r3, [r3]
8f62062c:	e58d300c 	str	r3, [r13, #12]
8f620630:	e3a03000 	mov	r3, #0
8f620634:	e1a06002 	mov	r6, r2
	int ret = 0;
	if (platform_boot_dev_isemmc())
8f620638:	eb0004aa 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f62063c:	e3500000 	cmp	r0, #0
8f620640:	1a000007 	bne	8f620664 <rpmb_read+0x54>
#ifdef UFS_SUPPORT
	else
		ret = rpmb_read_ufs(dev, req, req_len, resp, resp_len);
#endif
	return ret;
}
8f620644:	e59f3040 	ldr	r3, [pc, #64]	; 8f62068c <rpmb_read+0x7c>
8f620648:	e5932000 	ldr	r2, [r3]
8f62064c:	e59d300c 	ldr	r3, [r13, #12]
8f620650:	e0332002 	eors	r2, r3, r2
8f620654:	e3a03000 	mov	r3, #0
8f620658:	1a00000a 	bne	8f620688 <rpmb_read+0x78>
8f62065c:	e28dd014 	add	r13, r13, #20
8f620660:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		ret = rpmb_read_emmc(dev, req, req_len, resp, resp_len);
8f620664:	e30d1198 	movw	r1, #53656	; 0xd198
8f620668:	e3481f72 	movt	r1, #36722	; 0x8f72
8f62066c:	e1a03006 	mov	r3, r6
8f620670:	e1a02007 	mov	r2, r7
8f620674:	e5910000 	ldr	r0, [r1]
8f620678:	e1a01005 	mov	r1, r5
8f62067c:	e58d4000 	str	r4, [r13]
8f620680:	eb00011c 	bl	8f620af8 <rpmb_read_emmc>
8f620684:	eaffffee 	b	8f620644 <rpmb_read+0x34>
}
8f620688:	eb00494c 	bl	8f632bc0 <__stack_chk_fail>
8f62068c:	8f74221c 	.word	0x8f74221c

8f620690 <rpmb_write>:

int rpmb_write(uint32_t *req, uint32_t req_len, uint32_t rel_wr_count, uint32_t *resp, uint32_t *resp_len)
{
8f620690:	e59f3044 	ldr	r3, [pc, #68]	; 8f6206dc <rpmb_write+0x4c>
#ifdef SAFE_MODE
	dprintf(CRITICAL, "Tried to write rpmb\n");
8f620694:	e30704d0 	movw	r0, #29904	; 0x74d0
{
8f620698:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	dprintf(CRITICAL, "Tried to write rpmb\n");
8f62069c:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f6206a0:	e24dd00c 	sub	r13, r13, #12
8f6206a4:	e5933000 	ldr	r3, [r3]
8f6206a8:	e58d3004 	str	r3, [r13, #4]
8f6206ac:	e3a03000 	mov	r3, #0
	dprintf(CRITICAL, "Tried to write rpmb\n");
8f6206b0:	eb0048af 	bl	8f632974 <_dprintf>
	else
		ret = rpmb_write_ufs(dev, req, req_len, rel_wr_count, resp, resp_len);
#endif
	return ret;
#endif
}
8f6206b4:	e59f3020 	ldr	r3, [pc, #32]	; 8f6206dc <rpmb_write+0x4c>
8f6206b8:	e5932000 	ldr	r2, [r3]
8f6206bc:	e59d3004 	ldr	r3, [r13, #4]
8f6206c0:	e0332002 	eors	r2, r3, r2
8f6206c4:	e3a03000 	mov	r3, #0
8f6206c8:	1a000002 	bne	8f6206d8 <rpmb_write+0x48>
8f6206cc:	e3e00000 	mvn	r0, #0
8f6206d0:	e28dd00c 	add	r13, r13, #12
8f6206d4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6206d8:	eb004938 	bl	8f632bc0 <__stack_chk_fail>
8f6206dc:	8f74221c 	.word	0x8f74221c

8f6206e0 <read_device_info_rpmb>:

/* This API calls into TZ app to read device_info */
int read_device_info_rpmb(void *info, uint32_t sz)
{
8f6206e0:	e92d4070 	push	{r4, r5, r6, r14}
8f6206e4:	e24dd028 	sub	r13, r13, #40	; 0x28
8f6206e8:	e59f30ac 	ldr	r3, [pc, #172]	; 8f62079c <read_device_info_rpmb+0xbc>
8f6206ec:	e1a06001 	mov	r6, r1
8f6206f0:	e1a05000 	mov	r5, r0
	int ret = 0;
	struct send_cmd_req read_req = {0};
	struct send_cmd_rsp read_rsp = {0};
8f6206f4:	e3a04000 	mov	r4, #0
{
8f6206f8:	e5933000 	ldr	r3, [r3]
8f6206fc:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f620700:	e3a03000 	mov	r3, #0

	read_req.cmd_id = KEYMASTER_READ_LK_DEVICE_STATE;
8f620704:	e3003202 	movw	r3, #514	; 0x202
	read_req.data   = (uint32_t) info;
	read_req.len    = sz;
8f620708:	e1cd01f0 	strd	r0, [r13, #16]
	read_req.cmd_id = KEYMASTER_READ_LK_DEVICE_STATE;
8f62070c:	e58d300c 	str	r3, [r13, #12]
	struct send_cmd_rsp read_rsp = {0};
8f620710:	e58d4018 	str	r4, [r13, #24]
8f620714:	e58d401c 	str	r4, [r13, #28]
8f620718:	e58d4020 	str	r4, [r13, #32]

	/* Read the device info */
	arch_clean_invalidate_cache_range((addr_t) info, sz);
8f62071c:	eb00021f 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	ret = qseecom_send_command(get_secapp_handle(), (void*) &read_req, sizeof(read_req), (void*) &read_rsp, sizeof(read_rsp));
8f620720:	ebff9bf6 	bl	8f607700 <get_secapp_handle>
8f620724:	e3a0200c 	mov	r2, #12
8f620728:	e28d3018 	add	r3, r13, #24
8f62072c:	e08d1002 	add	r1, r13, r2
8f620730:	e58d2000 	str	r2, [r13]
8f620734:	ebffd7da 	bl	8f6166a4 <qseecom_send_command>
	arch_invalidate_cache_range((addr_t) info, sz);
8f620738:	e1a01006 	mov	r1, r6
	ret = qseecom_send_command(get_secapp_handle(), (void*) &read_req, sizeof(read_req), (void*) &read_rsp, sizeof(read_rsp));
8f62073c:	e1a03000 	mov	r3, r0
	arch_invalidate_cache_range((addr_t) info, sz);
8f620740:	e1a00005 	mov	r0, r5
	ret = qseecom_send_command(get_secapp_handle(), (void*) &read_req, sizeof(read_req), (void*) &read_rsp, sizeof(read_rsp));
8f620744:	e1a05003 	mov	r5, r3
	arch_invalidate_cache_range((addr_t) info, sz);
8f620748:	eb00021e 	bl	8f620fc8 <arch_invalidate_cache_range>

	if (ret < 0 || read_rsp.status < 0)
8f62074c:	e1550004 	cmp	r5, r4
8f620750:	e59d1020 	ldr	r1, [r13, #32]
8f620754:	ba00000a 	blt	8f620784 <read_device_info_rpmb+0xa4>
8f620758:	e3510000 	cmp	r1, #0
	{
		dprintf(CRITICAL, "Reading device info failed: Error: %d\n", read_rsp.status);
		return -1;
	}

	return 0;
8f62075c:	a1a00004 	movge	r0, r4
	if (ret < 0 || read_rsp.status < 0)
8f620760:	ba000007 	blt	8f620784 <read_device_info_rpmb+0xa4>
}
8f620764:	e59f3030 	ldr	r3, [pc, #48]	; 8f62079c <read_device_info_rpmb+0xbc>
8f620768:	e5932000 	ldr	r2, [r3]
8f62076c:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f620770:	e0332002 	eors	r2, r3, r2
8f620774:	e3a03000 	mov	r3, #0
8f620778:	1a000006 	bne	8f620798 <read_device_info_rpmb+0xb8>
8f62077c:	e28dd028 	add	r13, r13, #40	; 0x28
8f620780:	e8bd8070 	pop	{r4, r5, r6, r15}
		dprintf(CRITICAL, "Reading device info failed: Error: %d\n", read_rsp.status);
8f620784:	e30704e8 	movw	r0, #29928	; 0x74e8
8f620788:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62078c:	eb004878 	bl	8f632974 <_dprintf>
		return -1;
8f620790:	e3e00000 	mvn	r0, #0
8f620794:	eafffff2 	b	8f620764 <read_device_info_rpmb+0x84>
}
8f620798:	eb004908 	bl	8f632bc0 <__stack_chk_fail>
8f62079c:	8f74221c 	.word	0x8f74221c

8f6207a0 <write_device_info_rpmb>:

int write_device_info_rpmb(void *info, uint32_t sz)
{
8f6207a0:	e59f3044 	ldr	r3, [pc, #68]	; 8f6207ec <write_device_info_rpmb+0x4c>
		return -1;
	}

	return 0;
#else
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f6207a4:	e3070510 	movw	r0, #29968	; 0x7510
{
8f6207a8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f6207ac:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f6207b0:	e24dd00c 	sub	r13, r13, #12
8f6207b4:	e5933000 	ldr	r3, [r3]
8f6207b8:	e58d3004 	str	r3, [r13, #4]
8f6207bc:	e3a03000 	mov	r3, #0
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f6207c0:	eb00486b 	bl	8f632974 <_dprintf>
	return -1;
#endif
}
8f6207c4:	e59f3020 	ldr	r3, [pc, #32]	; 8f6207ec <write_device_info_rpmb+0x4c>
8f6207c8:	e5932000 	ldr	r2, [r3]
8f6207cc:	e59d3004 	ldr	r3, [r13, #4]
8f6207d0:	e0332002 	eors	r2, r3, r2
8f6207d4:	e3a03000 	mov	r3, #0
8f6207d8:	1a000002 	bne	8f6207e8 <write_device_info_rpmb+0x48>
8f6207dc:	e3e00000 	mvn	r0, #0
8f6207e0:	e28dd00c 	add	r13, r13, #12
8f6207e4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6207e8:	eb0048f4 	bl	8f632bc0 <__stack_chk_fail>
8f6207ec:	8f74221c 	.word	0x8f74221c

8f6207f0 <rpmb_uninit>:
	}
	return 0;
}

int rpmb_uninit()
{
8f6207f0:	e59f3074 	ldr	r3, [pc, #116]	; 8f62086c <rpmb_uninit+0x7c>
	int ret = 0;

	ret = rpmb_listener_stop(RPMB_LSTNR_ID);
8f6207f4:	e3a00a02 	mov	r0, #8192	; 0x2000
{
8f6207f8:	e92d4010 	push	{r4, r14}
8f6207fc:	e24dd008 	sub	r13, r13, #8
8f620800:	e5933000 	ldr	r3, [r3]
8f620804:	e58d3004 	str	r3, [r13, #4]
8f620808:	e3a03000 	mov	r3, #0
	ret = rpmb_listener_stop(RPMB_LSTNR_ID);
8f62080c:	eb0000a1 	bl	8f620a98 <rpmb_listener_stop>
	if (ret < 0)
8f620810:	e2504000 	subs	r4, r0, #0
8f620814:	ba00000b 	blt	8f620848 <rpmb_uninit+0x58>
	{
		dprintf(CRITICAL, "Failed to stop Qseecom Listener\n");
		return ret;
	}
	ret = qseecom_exit();
8f620818:	ebffda28 	bl	8f6170c0 <qseecom_exit>

	if (ret < 0)
8f62081c:	e2504000 	subs	r4, r0, #0
8f620820:	ba00000c 	blt	8f620858 <rpmb_uninit+0x68>
		dprintf(CRITICAL, "Failed to exit qseecom \n");
		return ret;
	}

	return ret;
}
8f620824:	e59f3040 	ldr	r3, [pc, #64]	; 8f62086c <rpmb_uninit+0x7c>
8f620828:	e5932000 	ldr	r2, [r3]
8f62082c:	e59d3004 	ldr	r3, [r13, #4]
8f620830:	e0332002 	eors	r2, r3, r2
8f620834:	e3a03000 	mov	r3, #0
8f620838:	1a00000a 	bne	8f620868 <rpmb_uninit+0x78>
8f62083c:	e1a00004 	mov	r0, r4
8f620840:	e28dd008 	add	r13, r13, #8
8f620844:	e8bd8010 	pop	{r4, r15}
		dprintf(CRITICAL, "Failed to stop Qseecom Listener\n");
8f620848:	e3070538 	movw	r0, #30008	; 0x7538
8f62084c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f620850:	eb004847 	bl	8f632974 <_dprintf>
		return ret;
8f620854:	eafffff2 	b	8f620824 <rpmb_uninit+0x34>
		dprintf(CRITICAL, "Failed to exit qseecom \n");
8f620858:	e307055c 	movw	r0, #30044	; 0x755c
8f62085c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f620860:	eb004843 	bl	8f632974 <_dprintf>
		return ret;
8f620864:	eaffffee 	b	8f620824 <rpmb_uninit+0x34>
}
8f620868:	eb0048d4 	bl	8f632bc0 <__stack_chk_fail>
8f62086c:	8f74221c 	.word	0x8f74221c

8f620870 <rpmb_cmd_handler>:
	resp_p->res_buff_offset = sizeof(struct tz_rpmb_rw_resp);
	resp_p->cmd_id = req_p->cmd_id;
}

int rpmb_cmd_handler(void *buf, uint32_t sz)
{
8f620870:	e92d4030 	push	{r4, r5, r14}
	int ret = 0;
	uint32_t cmd_id;

	ASSERT(buf);
8f620874:	e2504000 	subs	r4, r0, #0
{
8f620878:	e59f318c 	ldr	r3, [pc, #396]	; 8f620a0c <rpmb_cmd_handler+0x19c>
8f62087c:	e24dd014 	sub	r13, r13, #20
8f620880:	e1a0500e 	mov	r5, r14
8f620884:	e5933000 	ldr	r3, [r3]
8f620888:	e58d300c 	str	r3, [r13, #12]
8f62088c:	e3a03000 	mov	r3, #0
	ASSERT(buf);
8f620890:	0a000051 	beq	8f6209dc <rpmb_cmd_handler+0x16c>

	cmd_id = (uint32_t) *((uint32_t *)buf);
8f620894:	e5941000 	ldr	r1, [r4]

	switch(cmd_id)
8f620898:	e3510f41 	cmp	r1, #260	; 0x104
8f62089c:	2a000020 	bcs	8f620924 <rpmb_cmd_handler+0xb4>
8f6208a0:	e3003101 	movw	r3, #257	; 0x101
8f6208a4:	e1510003 	cmp	r1, r3
8f6208a8:	8a00002e 	bhi	8f620968 <rpmb_cmd_handler+0xf8>
8f6208ac:	1a00001e 	bne	8f62092c <rpmb_cmd_handler+0xbc>
	rpmb_info = rpmb_get_init_info();
8f6208b0:	ebffff44 	bl	8f6205c8 <rpmb_get_init_info>
	init_resp->cmd_id = init_req_p->cmd_id;
8f6208b4:	e5941000 	ldr	r1, [r4]
	if (rpmb_info)
8f6208b8:	e3500000 	cmp	r0, #0
		init_resp->status = 0;
8f6208bc:	13a03000 	movne	r3, #0
8f6208c0:	15c43008 	strbne	r3, [r4, #8]
8f6208c4:	15c43009 	strbne	r3, [r4, #9]
8f6208c8:	15c4300a 	strbne	r3, [r4, #10]
8f6208cc:	15c4300b 	strbne	r3, [r4, #11]
	init_resp->num_sectors = rpmb_info->size;
8f6208d0:	e5903000 	ldr	r3, [r0]
	init_resp->rel_wr_count = rpmb_info->rel_wr_count;
8f6208d4:	e5902004 	ldr	r2, [r0, #4]
	init_resp->num_sectors = rpmb_info->size;
8f6208d8:	e584300c 	str	r3, [r4, #12]
	init_resp->dev_type = rpmb_info->dev_type;
8f6208dc:	e5903008 	ldr	r3, [r0, #8]
	init_resp->version = RPMB_LSTNR_VERSION_2;
8f6208e0:	e3a00000 	mov	r0, #0
	init_resp->cmd_id = init_req_p->cmd_id;
8f6208e4:	e5841000 	str	r1, [r4]
	init_resp->version = RPMB_LSTNR_VERSION_2;
8f6208e8:	e3a01002 	mov	r1, #2
8f6208ec:	e5c40005 	strb	r0, [r4, #5]
8f6208f0:	e5c41004 	strb	r1, [r4, #4]
8f6208f4:	e5c40006 	strb	r0, [r4, #6]
8f6208f8:	e5c40007 	strb	r0, [r4, #7]
	init_resp->rel_wr_count = rpmb_info->rel_wr_count;
8f6208fc:	e5842010 	str	r2, [r4, #16]
	init_resp->dev_type = rpmb_info->dev_type;
8f620900:	e5843014 	str	r3, [r4, #20]
			dprintf(CRITICAL, "Unsupported Request from qseecom: %d\n", cmd_id);
			ASSERT(0);
	};

	return ret;
}
8f620904:	e59f3100 	ldr	r3, [pc, #256]	; 8f620a0c <rpmb_cmd_handler+0x19c>
8f620908:	e5932000 	ldr	r2, [r3]
8f62090c:	e59d300c 	ldr	r3, [r13, #12]
8f620910:	e0332002 	eors	r2, r3, r2
8f620914:	e3a03000 	mov	r3, #0
8f620918:	1a00003a 	bne	8f620a08 <rpmb_cmd_handler+0x198>
8f62091c:	e28dd014 	add	r13, r13, #20
8f620920:	e8bd8030 	pop	{r4, r5, r15}
	switch(cmd_id)
8f620924:	03e00000 	mvneq	r0, #0
8f620928:	0afffff5 	beq	8f620904 <rpmb_cmd_handler+0x94>
			dprintf(CRITICAL, "Unsupported Request from qseecom: %d\n", cmd_id);
8f62092c:	e30705a4 	movw	r0, #30116	; 0x75a4
8f620930:	e3480f70 	movt	r0, #36720	; 0x8f70
8f620934:	eb00480e 	bl	8f632974 <_dprintf>
			ASSERT(0);
8f620938:	e1a00005 	mov	r0, r5
8f62093c:	e307cf64 	movw	r12, #32612	; 0x7f64
8f620940:	e3a030aa 	mov	r3, #170	; 0xaa
8f620944:	e348cf70 	movt	r12, #36720	; 0x8f70
8f620948:	e3072578 	movw	r2, #30072	; 0x7578
8f62094c:	e3001130 	movw	r1, #304	; 0x130
8f620950:	e3482f70 	movt	r2, #36720	; 0x8f70
8f620954:	e3481f70 	movt	r1, #36720	; 0x8f70
8f620958:	e58dc000 	str	r12, [r13]
8f62095c:	eb004856 	bl	8f632abc <_panic>
	int ret = 0;
8f620960:	e3a00000 	mov	r0, #0
8f620964:	eaffffe6 	b	8f620904 <rpmb_cmd_handler+0x94>
	uint32_t *req_buf = buf + req_p->req_buff_offset;
8f620968:	e594000c 	ldr	r0, [r4, #12]
	switch (req_p->cmd_id)
8f62096c:	e3003103 	movw	r3, #259	; 0x103
8f620970:	e1510003 	cmp	r1, r3
	uint32_t *resp_buf = buf + sizeof(struct tz_rpmb_rw_resp);
8f620974:	e284c014 	add	r12, r4, #20
	uint32_t *req_buf = buf + req_p->req_buff_offset;
8f620978:	e0840000 	add	r0, r4, r0
	switch (req_p->cmd_id)
8f62097c:	0a00000e 	beq	8f6209bc <rpmb_cmd_handler+0x14c>
			resp_p->status = rpmb_read(req_buf, req_p->num_sectors, resp_buf, &resp_p->res_buff_len);
8f620980:	e5941004 	ldr	r1, [r4, #4]
8f620984:	e2843008 	add	r3, r4, #8
8f620988:	e1a0200c 	mov	r2, r12
8f62098c:	ebffff1f 	bl	8f620610 <rpmb_read>
8f620990:	e5840004 	str	r0, [r4, #4]
	resp_p->cmd_id = req_p->cmd_id;
8f620994:	e5942000 	ldr	r2, [r4]
	resp_p->res_buff_offset = sizeof(struct tz_rpmb_rw_resp);
8f620998:	e3a03000 	mov	r3, #0
8f62099c:	e3a01014 	mov	r1, #20
	int ret = 0;
8f6209a0:	e1a00003 	mov	r0, r3
	resp_p->res_buff_offset = sizeof(struct tz_rpmb_rw_resp);
8f6209a4:	e5c4100c 	strb	r1, [r4, #12]
8f6209a8:	e5c4300d 	strb	r3, [r4, #13]
8f6209ac:	e5c4300e 	strb	r3, [r4, #14]
8f6209b0:	e5c4300f 	strb	r3, [r4, #15]
	resp_p->cmd_id = req_p->cmd_id;
8f6209b4:	e5842000 	str	r2, [r4]
}
8f6209b8:	eaffffd1 	b	8f620904 <rpmb_cmd_handler+0x94>
			resp_p->status = rpmb_write(req_buf, req_p->num_sectors, req_p->rel_wr_count, resp_buf, &resp_p->res_buff_len);
8f6209bc:	e5942014 	ldr	r2, [r4, #20]
8f6209c0:	e2843008 	add	r3, r4, #8
8f6209c4:	e5941004 	ldr	r1, [r4, #4]
8f6209c8:	e58d3000 	str	r3, [r13]
8f6209cc:	e1a0300c 	mov	r3, r12
8f6209d0:	ebffff2e 	bl	8f620690 <rpmb_write>
8f6209d4:	e5840004 	str	r0, [r4, #4]
			break;
8f6209d8:	eaffffed 	b	8f620994 <rpmb_cmd_handler+0x124>
	ASSERT(buf);
8f6209dc:	e3040214 	movw	r0, #16916	; 0x4214
8f6209e0:	e3072578 	movw	r2, #30072	; 0x7578
8f6209e4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6209e8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6209ec:	e58d0000 	str	r0, [r13]
8f6209f0:	e3001130 	movw	r1, #304	; 0x130
8f6209f4:	e3a03091 	mov	r3, #145	; 0x91
8f6209f8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6209fc:	e1a0000e 	mov	r0, r14
8f620a00:	eb00482d 	bl	8f632abc <_panic>
8f620a04:	eaffffa2 	b	8f620894 <rpmb_cmd_handler+0x24>
}
8f620a08:	eb00486c 	bl	8f632bc0 <__stack_chk_fail>
8f620a0c:	8f74221c 	.word	0x8f74221c

8f620a10 <rpmb_listener_start>:

int rpmb_listener_start()
{
8f620a10:	e92d4010 	push	{r4, r14}
8f620a14:	e24dd018 	sub	r13, r13, #24
8f620a18:	e59fe074 	ldr	r14, [pc, #116]	; 8f620a94 <rpmb_listener_start+0x84>
	rpmb_listener.service_name = "RPMB system services";
	rpmb_listener.id           =  RPMB_LSTNR_ID;
	rpmb_listener.sb_size      = 25 * 1024;
	rpmb_listener.service_cmd_handler = rpmb_cmd_handler;

	ret = qseecom_register_listener(&rpmb_listener);
8f620a1c:	e28d0004 	add	r0, r13, #4
	rpmb_listener.id           =  RPMB_LSTNR_ID;
8f620a20:	e3a0ca02 	mov	r12, #8192	; 0x2000
	rpmb_listener.sb_size      = 25 * 1024;
8f620a24:	e3a01b19 	mov	r1, #25600	; 0x6400
{
8f620a28:	e59ee000 	ldr	r14, [r14]
8f620a2c:	e58de014 	str	r14, [r13, #20]
8f620a30:	e3a0e000 	mov	r14, #0
	rpmb_listener.service_name = "RPMB system services";
8f620a34:	e30725cc 	movw	r2, #30156	; 0x75cc
	rpmb_listener.service_cmd_handler = rpmb_cmd_handler;
8f620a38:	e3003870 	movw	r3, #2160	; 0x870
	rpmb_listener.service_name = "RPMB system services";
8f620a3c:	e3482f70 	movt	r2, #36720	; 0x8f70
	rpmb_listener.service_cmd_handler = rpmb_cmd_handler;
8f620a40:	e3483f62 	movt	r3, #36706	; 0x8f62
	rpmb_listener.id           =  RPMB_LSTNR_ID;
8f620a44:	e98d1004 	stmib	r13, {r2, r12}
	rpmb_listener.sb_size      = 25 * 1024;
8f620a48:	e58d100c 	str	r1, [r13, #12]
	rpmb_listener.service_cmd_handler = rpmb_cmd_handler;
8f620a4c:	e58d3010 	str	r3, [r13, #16]
	ret = qseecom_register_listener(&rpmb_listener);
8f620a50:	ebffd7d4 	bl	8f6169a8 <qseecom_register_listener>

	if (ret < 0)
8f620a54:	e2504000 	subs	r4, r0, #0
8f620a58:	ba000008 	blt	8f620a80 <rpmb_listener_start+0x70>
		dprintf(CRITICAL, "Failed to register rpmb listener\n");

	return ret;
}
8f620a5c:	e59f3030 	ldr	r3, [pc, #48]	; 8f620a94 <rpmb_listener_start+0x84>
8f620a60:	e5932000 	ldr	r2, [r3]
8f620a64:	e59d3014 	ldr	r3, [r13, #20]
8f620a68:	e0332002 	eors	r2, r3, r2
8f620a6c:	e3a03000 	mov	r3, #0
8f620a70:	1a000006 	bne	8f620a90 <rpmb_listener_start+0x80>
8f620a74:	e1a00004 	mov	r0, r4
8f620a78:	e28dd018 	add	r13, r13, #24
8f620a7c:	e8bd8010 	pop	{r4, r15}
		dprintf(CRITICAL, "Failed to register rpmb listener\n");
8f620a80:	e30705e4 	movw	r0, #30180	; 0x75e4
8f620a84:	e3480f70 	movt	r0, #36720	; 0x8f70
8f620a88:	eb0047b9 	bl	8f632974 <_dprintf>
	return ret;
8f620a8c:	eafffff2 	b	8f620a5c <rpmb_listener_start+0x4c>
}
8f620a90:	eb00484a 	bl	8f632bc0 <__stack_chk_fail>
8f620a94:	8f74221c 	.word	0x8f74221c

8f620a98 <rpmb_listener_stop>:

int rpmb_listener_stop(int id)
{
8f620a98:	e59f3054 	ldr	r3, [pc, #84]	; 8f620af4 <rpmb_listener_stop+0x5c>
8f620a9c:	e92d4010 	push	{r4, r14}
8f620aa0:	e24dd008 	sub	r13, r13, #8
8f620aa4:	e5933000 	ldr	r3, [r3]
8f620aa8:	e58d3004 	str	r3, [r13, #4]
8f620aac:	e3a03000 	mov	r3, #0
	int ret;

	ret = qseecom_deregister_listener(id);
8f620ab0:	ebffd875 	bl	8f616c8c <qseecom_deregister_listener>

	if (ret < 0)
8f620ab4:	e2504000 	subs	r4, r0, #0
8f620ab8:	ba000008 	blt	8f620ae0 <rpmb_listener_stop+0x48>
		dprintf(CRITICAL, "Failed to unregister rpmb listener\n");

	return ret;
}
8f620abc:	e59f3030 	ldr	r3, [pc, #48]	; 8f620af4 <rpmb_listener_stop+0x5c>
8f620ac0:	e5932000 	ldr	r2, [r3]
8f620ac4:	e59d3004 	ldr	r3, [r13, #4]
8f620ac8:	e0332002 	eors	r2, r3, r2
8f620acc:	e3a03000 	mov	r3, #0
8f620ad0:	1a000006 	bne	8f620af0 <rpmb_listener_stop+0x58>
8f620ad4:	e1a00004 	mov	r0, r4
8f620ad8:	e28dd008 	add	r13, r13, #8
8f620adc:	e8bd8010 	pop	{r4, r15}
		dprintf(CRITICAL, "Failed to unregister rpmb listener\n");
8f620ae0:	e3070608 	movw	r0, #30216	; 0x7608
8f620ae4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f620ae8:	eb0047a1 	bl	8f632974 <_dprintf>
	return ret;
8f620aec:	eafffff2 	b	8f620abc <rpmb_listener_stop+0x24>
}
8f620af0:	eb004832 	bl	8f632bc0 <__stack_chk_fail>
8f620af4:	8f74221c 	.word	0x8f74221c

8f620af8 <rpmb_read_emmc>:

	return 0;
}

int rpmb_read_emmc(struct mmc_device *dev, uint32_t *req_buf, uint32_t blk_cnt, uint32_t *resp_buf, uint32_t *resp_len)
{
8f620af8:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f620afc:	e24dd0e0 	sub	r13, r13, #224	; 0xe0
8f620b00:	e1a05003 	mov	r5, r3
8f620b04:	e59f30fc 	ldr	r3, [pc, #252]	; 8f620c08 <rpmb_read_emmc+0x110>
8f620b08:	e1a06000 	mov	r6, r0
8f620b0c:	e1a08001 	mov	r8, r1
8f620b10:	e1a04002 	mov	r4, r2
	struct mmc_command cmd[3] ;
	int ret = 0;
	struct rpmb_frame *result = (struct rpmb_frame *)resp_buf;
	memset(cmd, 0, (size_t) sizeof(cmd));
8f620b14:	e3a01000 	mov	r1, #0
8f620b18:	e3a020d8 	mov	r2, #216	; 0xd8
8f620b1c:	e1a0000d 	mov	r0, r13
{
8f620b20:	e5933000 	ldr	r3, [r3]
8f620b24:	e58d30dc 	str	r3, [r13, #220]	; 0xdc
8f620b28:	e3a03000 	mov	r3, #0
8f620b2c:	e59d70f8 	ldr	r7, [r13, #248]	; 0xf8
	memset(cmd, 0, (size_t) sizeof(cmd));
8f620b30:	eb004de3 	bl	8f6342c4 <memset>
	cmd[1].data_present = 0x1;
	cmd[1].data.data_ptr = (void *)resp_buf;
	cmd[1].data.num_blocks = blk_cnt;
	cmd[1].cmd23_support  = 0x1;

	ret = mmc_sdhci_rpmb_send(dev, cmd);
8f620b34:	e1a0100d 	mov	r1, r13
8f620b38:	e1a00006 	mov	r0, r6
	cmd[0].write_flag = false;
8f620b3c:	e3a02000 	mov	r2, #0
	cmd[0].data.num_blocks = RPMB_MIN_BLK_CNT;
8f620b40:	e3a03001 	mov	r3, #1
	cmd[0].data.data_ptr = (void *)req_buf;
8f620b44:	e58d8034 	str	r8, [r13, #52]	; 0x34
	cmd[0].data.num_blocks = RPMB_MIN_BLK_CNT;
8f620b48:	e58d303c 	str	r3, [r13, #60]	; 0x3c
	cmd[1].trans_mode = SDHCI_MMC_READ;
8f620b4c:	e58d3064 	str	r3, [r13, #100]	; 0x64
	cmd[1].cmd23_support  = 0x1;
8f620b50:	e58d306c 	str	r3, [r13, #108]	; 0x6c
	cmd[0].cmd_index = CMD25_WRITE_MULTIPLE_BLOCK;
8f620b54:	e3a03019 	mov	r3, #25
	cmd[1].data.data_ptr = (void *)resp_buf;
8f620b58:	e58d507c 	str	r5, [r13, #124]	; 0x7c
	cmd[0].cmd_index = CMD25_WRITE_MULTIPLE_BLOCK;
8f620b5c:	e1cd30b0 	strh	r3, [r13]
	cmd[0].data_present = 0x1;
8f620b60:	e3a03001 	mov	r3, #1
	cmd[1].data.num_blocks = blk_cnt;
8f620b64:	e58d4084 	str	r4, [r13, #132]	; 0x84
	cmd[0].data_present = 0x1;
8f620b68:	e3403001 	movt	r3, #1
	cmd[0].write_flag = false;
8f620b6c:	e58d2030 	str	r2, [r13, #48]	; 0x30
	cmd[0].data_present = 0x1;
8f620b70:	e58d3008 	str	r3, [r13, #8]
	cmd[1].data_present = 0x1;
8f620b74:	e58d3050 	str	r3, [r13, #80]	; 0x50
	cmd[1].cmd_index = CMD18_READ_MULTIPLE_BLOCK;
8f620b78:	e3a03012 	mov	r3, #18
	cmd[0].trans_mode = SDHCI_MMC_WRITE;
8f620b7c:	e58d201c 	str	r2, [r13, #28]
	cmd[0].argument = 0;
8f620b80:	e58d2004 	str	r2, [r13, #4]
	cmd[1].write_flag = false;
8f620b84:	e58d2078 	str	r2, [r13, #120]	; 0x78
	cmd[1].argument = 0;
8f620b88:	e58d204c 	str	r2, [r13, #76]	; 0x4c
	cmd[1].cmd_index = CMD18_READ_MULTIPLE_BLOCK;
8f620b8c:	e1cd34b8 	strh	r3, [r13, #72]	; 0x48
	ret = mmc_sdhci_rpmb_send(dev, cmd);
8f620b90:	ebffae4b 	bl	8f60c4c4 <mmc_sdhci_rpmb_send>

	if (ret)
8f620b94:	e3500000 	cmp	r0, #0
8f620b98:	1a000014 	bne	8f620bf0 <rpmb_read_emmc+0xf8>
	{
		dprintf(CRITICAL, "Failed to Send the RPMB read sequence of commands\n");
		return -1;
	}

	if (result->result[1])
8f620b9c:	e5d531fd 	ldrb	r3, [r5, #509]	; 0x1fd
8f620ba0:	e3530000 	cmp	r3, #0
8f620ba4:	1a00000a 	bne	8f620bd4 <rpmb_read_emmc+0xdc>
#if DEBUG_RPMB
	dump_rpmb_frame((uint8_t *)resp_buf, "response");
#endif
	*resp_len = blk_cnt * RPMB_BLK_SIZE;

	return 0;
8f620ba8:	e3a00000 	mov	r0, #0
	*resp_len = blk_cnt * RPMB_BLK_SIZE;
8f620bac:	e1a04484 	lsl	r4, r4, #9
8f620bb0:	e5874000 	str	r4, [r7]
}
8f620bb4:	e59f304c 	ldr	r3, [pc, #76]	; 8f620c08 <rpmb_read_emmc+0x110>
8f620bb8:	e5932000 	ldr	r2, [r3]
8f620bbc:	e59d30dc 	ldr	r3, [r13, #220]	; 0xdc
8f620bc0:	e0332002 	eors	r2, r3, r2
8f620bc4:	e3a03000 	mov	r3, #0
8f620bc8:	1a00000d 	bne	8f620c04 <rpmb_read_emmc+0x10c>
8f620bcc:	e28dd0e0 	add	r13, r13, #224	; 0xe0
8f620bd0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
		dprintf(CRITICAL, "%s\n", str_err[result->result[1]]);
8f620bd4:	e3072884 	movw	r2, #30852	; 0x7884
8f620bd8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f620bdc:	e30306e0 	movw	r0, #14048	; 0x36e0
8f620be0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f620be4:	e7921103 	ldr	r1, [r2, r3, lsl #2]
8f620be8:	eb004761 	bl	8f632974 <_dprintf>
8f620bec:	eaffffed 	b	8f620ba8 <rpmb_read_emmc+0xb0>
		dprintf(CRITICAL, "Failed to Send the RPMB read sequence of commands\n");
8f620bf0:	e30706c4 	movw	r0, #30404	; 0x76c4
8f620bf4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f620bf8:	eb00475d 	bl	8f632974 <_dprintf>
		return -1;
8f620bfc:	e3e00000 	mvn	r0, #0
8f620c00:	eaffffeb 	b	8f620bb4 <rpmb_read_emmc+0xbc>
}
8f620c04:	eb0047ed 	bl	8f632bc0 <__stack_chk_fail>
8f620c08:	8f74221c 	.word	0x8f74221c

8f620c0c <free_verified_boot_resource>:
	}
	return;
}
#else
VOID free_verified_boot_resource(bootinfo *Info)
{
8f620c0c:	e59f3034 	ldr	r3, [pc, #52]	; 8f620c48 <free_verified_boot_resource+0x3c>
8f620c10:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f620c14:	e24dd00c 	sub	r13, r13, #12
8f620c18:	e5933000 	ldr	r3, [r3]
8f620c1c:	e58d3004 	str	r3, [r13, #4]
8f620c20:	e3a03000 	mov	r3, #0
	return;
}
8f620c24:	e59f301c 	ldr	r3, [pc, #28]	; 8f620c48 <free_verified_boot_resource+0x3c>
8f620c28:	e5932000 	ldr	r2, [r3]
8f620c2c:	e59d3004 	ldr	r3, [r13, #4]
8f620c30:	e0332002 	eors	r2, r3, r2
8f620c34:	e3a03000 	mov	r3, #0
8f620c38:	1a000001 	bne	8f620c44 <free_verified_boot_resource+0x38>
8f620c3c:	e28dd00c 	add	r13, r13, #12
8f620c40:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f620c44:	eb0047dd 	bl	8f632bc0 <__stack_chk_fail>
8f620c48:	8f74221c 	.word	0x8f74221c

8f620c4c <arch_early_init>:
	__asm__ volatile("mcr	p15, 0, %0, c12, c0, 0" :: "r" (addr));
}
#endif

void arch_early_init(void)
{
8f620c4c:	e59f3088 	ldr	r3, [pc, #136]	; 8f620cdc <arch_early_init+0x90>
	/* turn off the cache */
	arch_disable_cache(UCACHE);
8f620c50:	e3a00003 	mov	r0, #3
{
8f620c54:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f620c58:	e24dd00c 	sub	r13, r13, #12
8f620c5c:	e5933000 	ldr	r3, [r3]
8f620c60:	e58d3004 	str	r3, [r13, #4]
8f620c64:	e3a03000 	mov	r3, #0
	arch_disable_cache(UCACHE);
8f620c68:	eb00004a 	bl	8f620d98 <arch_disable_cache>
	__asm__ volatile("mcr	p15, 0, %0, c12, c0, 0" :: "r" (addr));
8f620c6c:	e3a03000 	mov	r3, #0
8f620c70:	e3483f60 	movt	r3, #36704	; 0x8f60
8f620c74:	ee0c3f10 	mcr	15, 0, r3, cr12, cr0, {0}
#if ARM_CPU_CORTEX_A8
	set_vector_base(MEMBASE);
#endif

#if ARM_WITH_MMU
	arm_mmu_init();
8f620c78:	eb0002a5 	bl	8f621714 <arm_mmu_init>

#endif

	/* turn the cache back on */
	arch_enable_cache(UCACHE);
8f620c7c:	e3a00003 	mov	r0, #3
8f620c80:	eb00005e 	bl	8f620e00 <arch_enable_cache>

#if ARM_WITH_NEON
	/* enable cp10 and cp11 */
	uint32_t val;
	__asm__ volatile("mrc	p15, 0, %0, c1, c0, 2" : "=r" (val));
8f620c84:	ee113f50 	mrc	15, 0, r3, cr1, cr0, {2}
	val |= (3<<22)|(3<<20);
8f620c88:	e383360f 	orr	r3, r3, #15728640	; 0xf00000
	__asm__ volatile("mcr	p15, 0, %0, c1, c0, 2" :: "r" (val));
8f620c8c:	ee013f50 	mcr	15, 0, r3, cr1, cr0, {2}

	isb();
8f620c90:	f57ff06f 	isb	sy

	/* set enable bit in fpexc */
	__asm__ volatile("mrc  p10, 7, %0, c8, c0, 0" : "=r" (val));
8f620c94:	eef83a10 	vmrs	r3, fpexc
	val |= (1<<30);
8f620c98:	e3833101 	orr	r3, r3, #1073741824	; 0x40000000
	__asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
8f620c9c:	eee83a10 	vmsr	fpexc, r3
#endif

#if ARM_CPU_CORTEX_A8
	/* enable the cycle count register */
	uint32_t en;
	__asm__ volatile("mrc	p15, 0, %0, c9, c12, 0" : "=r" (en));
8f620ca0:	ee193f1c 	mrc	15, 0, r3, cr9, cr12, {0}
	en &= ~(1<<3); /* cycle count every cycle */
8f620ca4:	e3c33008 	bic	r3, r3, #8
	en |= 1; /* enable all performance counters */
8f620ca8:	e3833001 	orr	r3, r3, #1
	__asm__ volatile("mcr	p15, 0, %0, c9, c12, 0" :: "r" (en));
8f620cac:	ee093f1c 	mcr	15, 0, r3, cr9, cr12, {0}

	/* enable cycle counter */
	en = (1<<31);
	__asm__ volatile("mcr	p15, 0, %0, c9, c12, 1" :: "r" (en));
8f620cb0:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
8f620cb4:	ee093f3c 	mcr	15, 0, r3, cr9, cr12, {1}
#endif
}
8f620cb8:	e59f301c 	ldr	r3, [pc, #28]	; 8f620cdc <arch_early_init+0x90>
8f620cbc:	e5932000 	ldr	r2, [r3]
8f620cc0:	e59d3004 	ldr	r3, [r13, #4]
8f620cc4:	e0332002 	eors	r2, r3, r2
8f620cc8:	e3a03000 	mov	r3, #0
8f620ccc:	1a000001 	bne	8f620cd8 <arch_early_init+0x8c>
8f620cd0:	e28dd00c 	add	r13, r13, #12
8f620cd4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f620cd8:	eb0047b8 	bl	8f632bc0 <__stack_chk_fail>
8f620cdc:	8f74221c 	.word	0x8f74221c

8f620ce0 <arch_init>:

void arch_init(void)
{
8f620ce0:	e59f3034 	ldr	r3, [pc, #52]	; 8f620d1c <arch_init+0x3c>
8f620ce4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f620ce8:	e24dd00c 	sub	r13, r13, #12
8f620cec:	e5933000 	ldr	r3, [r3]
8f620cf0:	e58d3004 	str	r3, [r13, #4]
8f620cf4:	e3a03000 	mov	r3, #0
}
8f620cf8:	e59f301c 	ldr	r3, [pc, #28]	; 8f620d1c <arch_init+0x3c>
8f620cfc:	e5932000 	ldr	r2, [r3]
8f620d00:	e59d3004 	ldr	r3, [r13, #4]
8f620d04:	e0332002 	eors	r2, r3, r2
8f620d08:	e3a03000 	mov	r3, #0
8f620d0c:	1a000001 	bne	8f620d18 <arch_init+0x38>
8f620d10:	e28dd00c 	add	r13, r13, #12
8f620d14:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f620d18:	eb0047a8 	bl	8f632bc0 <__stack_chk_fail>
8f620d1c:	8f74221c 	.word	0x8f74221c

8f620d20 <arm_context_switch>:
	 */
/* arm_context_switch(addr_t *old_sp, addr_t new_sp) */
FUNCTION(arm_context_switch)
	/* save all the usual registers + user regs */
	/* the spsr is saved and restored in the iframe by exceptions.S */
	sub		r3, sp, #(11*4)		/* can't use sp in user mode stm */
8f620d20:	e24d302c 	sub	r3, r13, #44	; 0x2c
	mov		r12, lr
8f620d24:	e1a0c00e 	mov	r12, r14
	stmia	r3, { r4-r11, r12, r13, r14 }^
8f620d28:	e8c37ff0 	stmia	r3, {r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14}^
	
	/* save old sp */
	str		r3, [r0] 
8f620d2c:	e5803000 	str	r3, [r0]

	/* clear any exlusive locks that the old thread holds */
#if ARM_ISA_ARMV7
	clrex
8f620d30:	f57ff01f 	clrex
	ldr		r0, =strex_spot
	strex	r3, r2, [r0]
#endif

	/* load new regs */
	ldmia	r1, { r4-r11, r12, r13, r14 }^
8f620d34:	e8d17ff0 	ldm	r1, {r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14}^
	mov		lr, r12				/* restore lr */
8f620d38:	e1a0e00c 	mov	r14, r12
	add		sp, r1, #(11*4)     /* restore sp */
8f620d3c:	e281d02c 	add	r13, r1, #44	; 0x2c
	bx		lr
8f620d40:	e12fff1e 	bx	r14

8f620d44 <arm_save_mode_regs>:

.ltorg

FUNCTION(arm_save_mode_regs)
	mrs		r1, cpsr
8f620d44:	e10f1000 	mrs	r1, CPSR

#if ARM_ISA_ARMv6 || ARM_ISA_ARMV7
	cps		#0x11			/* fiq */
8f620d48:	f1020011 	cps	#17
	str		r13, [r0], #4
8f620d4c:	e480d004 	str	r13, [r0], #4
	str		r14, [r0], #4
8f620d50:	e480e004 	str	r14, [r0], #4
	cps		#0x12			/* irq */
8f620d54:	f1020012 	cps	#18
	str		r13, [r0], #4
8f620d58:	e480d004 	str	r13, [r0], #4
	str		r14, [r0], #4
8f620d5c:	e480e004 	str	r14, [r0], #4
	cps		#0x13			/* svc */
8f620d60:	f1020013 	cps	#19
	str		r13, [r0], #4
8f620d64:	e480d004 	str	r13, [r0], #4
	str		r14, [r0], #4
8f620d68:	e480e004 	str	r14, [r0], #4
	cps		#0x17			/* abt */
8f620d6c:	f1020017 	cps	#23
	str		r13, [r0], #4
8f620d70:	e480d004 	str	r13, [r0], #4
	str		r14, [r0], #4
8f620d74:	e480e004 	str	r14, [r0], #4
	cps		#0x1b			/* und */
8f620d78:	f102001b 	cps	#27
	str		r13, [r0], #4
8f620d7c:	e480d004 	str	r13, [r0], #4
	str		r14, [r0], #4
8f620d80:	e480e004 	str	r14, [r0], #4
	cps		#0x1f			/* sys */
8f620d84:	f102001f 	cps	#31
	str		r13, [r0], #4
8f620d88:	e480d004 	str	r13, [r0], #4
	str		r14, [r0], #4
8f620d8c:	e480e004 	str	r14, [r0], #4
#else
	// XXX implement
	b		.
#endif
	
	msr		cpsr_c, r1
8f620d90:	e121f001 	msr	CPSR_c, r1

	bx		lr
8f620d94:	e12fff1e 	bx	r14

8f620d98 <arch_disable_cache>:

#elif ARM_CPU_CORTEX_A8

/* void arch_disable_cache(uint flags) */
FUNCTION(arch_disable_cache)
	stmfd	sp!, {r4-r11, lr}
8f620d98:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}

	mov		r7, r0						// save flags
8f620d9c:	e1a07000 	mov	r7, r0

	mrs		r12, cpsr					// save the old interrupt state
8f620da0:	e10fc000 	mrs	r12, CPSR
	cpsid iaf							// interrupts disabled
8f620da4:	f10c01c0 	cpsid	aif

.Ldcache_disable:
	tst		r7, #DCACHE
8f620da8:	e3170002 	tst	r7, #2
	beq		.Licache_disable
8f620dac:	0a000008 	beq	8f620dd4 <arch_disable_cache+0x3c>
	mrc     p15, 0, r0, c1, c0, 0		// cr1
8f620db0:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	tst		r0, #(1<<2)					// is the dcache already disabled?
8f620db4:	e3100004 	tst	r0, #4
	beq		.Ldcache_already_disabled
8f620db8:	0a000004 	beq	8f620dd0 <arch_disable_cache+0x38>

	bic		r0, #(1<<2)
8f620dbc:	e3c00004 	bic	r0, r0, #4
	// make sure all data operations are completed
	dsb
8f620dc0:	f57ff04f 	dsb	sy
	mcr		p15, 0, r0, c1, c0, 0		// disable dcache
8f620dc4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
	// make sure previous instruction finishes before we clean and flush
	isb
8f620dc8:	f57ff06f 	isb	sy

	// flush and invalidate the dcache
	// NOTE: trashes a bunch of registers, can't be spilling stuff to the stack
	bl		flush_invalidate_cache_v7
8f620dcc:	eb000021 	bl	8f620e58 <flush_invalidate_cache_v7>

.Ldcache_already_disabled:
	// make sure all of the caches are invalidated
	// NOTE: trashes a bunch of registers, can't be spilling stuff to the stack
	bl		invalidate_cache_v7
8f620dd0:	eb000045 	bl	8f620eec <invalidate_cache_v7>

.Licache_disable:
	tst		r7, #ICACHE
8f620dd4:	e3170001 	tst	r7, #1
	beq		.Ldone_disable
8f620dd8:	0a000003 	beq	8f620dec <arch_disable_cache+0x54>

	mrc     p15, 0, r0, c1, c0, 0		// cr1
8f620ddc:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic		r0, #(1<<12)
8f620de0:	e3c00a01 	bic	r0, r0, #4096	; 0x1000
	mcr		p15, 0, r0, c1, c0, 0		// disable icache
8f620de4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
	// make sure previous instruction finishes
	isb
8f620de8:	f57ff06f 	isb	sy

.Ldone_disable:
	// make sure the icache is always invalidated
	mov		r0, #0
8f620dec:	e3a00000 	mov	r0, #0
	mcr		p15, 0, r0, c7, c5, 0		// invalidate icache to PoU
8f620df0:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
	// make sure that data is in sync
	dsb
8f620df4:	f57ff04f 	dsb	sy

	msr		cpsr, r12
8f620df8:	e129f00c 	msr	CPSR_fc, r12
	ldmfd	sp!, {r4-r11, pc}
8f620dfc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}

8f620e00 <arch_enable_cache>:

/* void arch_enable_cache(uint flags) */
FUNCTION(arch_enable_cache)
	stmfd	sp!, {r4-r11, lr}
8f620e00:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}

	mov		r7, r0						// save flags
8f620e04:	e1a07000 	mov	r7, r0

	mrs		r12, cpsr					// save the old interrupt state
8f620e08:	e10fc000 	mrs	r12, CPSR
8f620e0c:	f10c01c0 	.word	0xf10c01c0
	.word	0xf10c01c0	/* cpsid iaf */	// interrupts disabled
	
.Ldcache_enable:
	tst		r7, #DCACHE
8f620e10:	e3170002 	tst	r7, #2
	beq		.Licache_enable
8f620e14:	0a000006 	beq	8f620e34 <arch_enable_cache+0x34>
	mrc     p15, 0, r0, c1, c0, 0		// cr1
8f620e18:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	tst		r0, #(1<<2)					// is the dcache already enabled?
8f620e1c:	e3100004 	tst	r0, #4
	bne		.Licache_enable
8f620e20:	1a000003 	bne	8f620e34 <arch_enable_cache+0x34>

	// invalidate L1 and L2
	// NOTE: trashes a bunch of registers, can't be spilling stuff to the stack
	bl		invalidate_cache_v7
8f620e24:	eb000030 	bl	8f620eec <invalidate_cache_v7>

	mrc     p15, 0, r0, c1, c0, 0		// cr1
8f620e28:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	orr		r0, #(1<<2)
8f620e2c:	e3800004 	orr	r0, r0, #4
	mcr		p15, 0, r0, c1, c0, 0		// enable dcache
8f620e30:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

.Licache_enable:
	tst		r7, #ICACHE
8f620e34:	e3170001 	tst	r7, #1
	beq		.Ldone_enable
8f620e38:	0a000004 	beq	8f620e50 <arch_enable_cache+0x50>

	mov		r0, #0
8f620e3c:	e3a00000 	mov	r0, #0
	mcr		p15, 0, r0, c7, c5, 0		// invalidate icache to PoU
8f620e40:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}

	mrc     p15, 0, r0, c1, c0, 0		// cr1
8f620e44:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	orr		r0, #(1<<12)
8f620e48:	e3800a01 	orr	r0, r0, #4096	; 0x1000
	mcr		p15, 0, r0, c1, c0, 0		// enable icache
8f620e4c:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

.Ldone_enable:
	msr		cpsr, r12
8f620e50:	e129f00c 	msr	CPSR_fc, r12
	ldmfd	sp!, {r4-r11, pc}
8f620e54:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}

8f620e58 <flush_invalidate_cache_v7>:

// flush & invalidate cache routine
flush_invalidate_cache_v7:
	DMB
8f620e58:	f57ff05f 	dmb	sy
	/* from ARMv7 manual, B2-17 */
	MRC 	p15, 1, R0, c0, c0, 1 		// Read CLIDR 
8f620e5c:	ee300f30 	mrc	15, 1, r0, cr0, cr0, {1}
	ANDS 	R3, R0, #0x7000000 
8f620e60:	e2103407 	ands	r3, r0, #117440512	; 0x7000000
	MOV 	R3, R3, LSR #23 			// Cache level value (naturally aligned) 
8f620e64:	e1a03ba3 	lsr	r3, r3, #23
	BEQ 	.Lfinished 
8f620e68:	0a00001a 	beq	8f620ed8 <flush_invalidate_cache_v7+0x80>
	MOV 	R10, #0 
8f620e6c:	e3a0a000 	mov	r10, #0
.Loop1:
	ADD 	R2, R10, R10, LSR #1 		// Work out 3xcachelevel 
8f620e70:	e08a20aa 	add	r2, r10, r10, lsr #1
	MOV 	R1, R0, LSR R2 				// bottom 3 bits are the Cache type for this level 
8f620e74:	e1a01230 	lsr	r1, r0, r2
	AND 	R1, R1, #7 					// get those 3 bits alone 
8f620e78:	e2011007 	and	r1, r1, #7
	CMP 	R1, #2 
8f620e7c:	e3510002 	cmp	r1, #2
	BLT 	.Lskip 						// no cache or only instruction cache at this level 
8f620e80:	ba000011 	blt	8f620ecc <flush_invalidate_cache_v7+0x74>
	MCR 	p15, 2, R10, c0, c0, 0 		// write the Cache Size selection register 
8f620e84:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
	ISB									// ISB to sync the change to the CacheSizeID reg
8f620e88:	f57ff06f 	isb	sy
	MRC 	p15, 1, R1, c0, c0, 0 		// reads current Cache Size ID register 
8f620e8c:	ee301f10 	mrc	15, 1, r1, cr0, cr0, {0}
	AND 	R2, R1, #0x7 				// extract the line length field 
8f620e90:	e2012007 	and	r2, r1, #7
	ADD 	R2, R2, #4 					// add 4 for the line length offset (log2 16 bytes) 
8f620e94:	e2822004 	add	r2, r2, #4
	LDR 	R4, =0x3FF 
8f620e98:	e59f4160 	ldr	r4, [pc, #352]	; 8f621000 <arch_sync_cache_range+0x14>
	ANDS 	R4, R4, R1, LSR #3 			// R4 is the max number on the way size (right aligned) 
8f620e9c:	e01441a1 	ands	r4, r4, r1, lsr #3
	CLZ 	R5, R4 						// R5 is the bit position of the way size increment
8f620ea0:	e16f5f14 	clz	r5, r4
	MOV		R9, R4						// R9 working copy of max way size (right aligned)
8f620ea4:	e1a09004 	mov	r9, r4
.Loop2:
	LDR 	R7, =0x00007FFF
8f620ea8:	e59f7154 	ldr	r7, [pc, #340]	; 8f621004 <arch_sync_cache_range+0x18>
	ANDS 	R7, R7, R1, LSR #13 		// R7 is the max number of the index size (right aligned)
8f620eac:	e01776a1 	ands	r7, r7, r1, lsr #13
.Loop3:
	ORR 	R11, R10, R9, LSL R5 		// factor in the way number and cache number into R11 
8f620eb0:	e18ab519 	orr	r11, r10, r9, lsl r5
	ORR 	R11, R11, R7, LSL R2 		// factor in the index number
8f620eb4:	e18bb217 	orr	r11, r11, r7, lsl r2
	MCR 	p15, 0, R11, c7, c10, 2 	// clean & invalidate by set/way
8f620eb8:	ee07bf5a 	mcr	15, 0, r11, cr7, cr10, {2}
	SUBS 	R7, R7, #1 					// decrement the index
8f620ebc:	e2577001 	subs	r7, r7, #1
	BGE 	.Loop3 
8f620ec0:	aafffffa 	bge	8f620eb0 <flush_invalidate_cache_v7+0x58>
	SUBS 	R9, R9, #1 					// decrement the index
8f620ec4:	e2599001 	subs	r9, r9, #1
	BGE 	.Loop2 
8f620ec8:	aafffff6 	bge	8f620ea8 <flush_invalidate_cache_v7+0x50>
.Lskip:
 	ADD 	R10, R10, #2 					// increment the cache number 
8f620ecc:	e28aa002 	add	r10, r10, #2
	CMP 	R3, R10 
8f620ed0:	e153000a 	cmp	r3, r10
	BGT 	.Loop1 
8f620ed4:	caffffe5 	bgt	8f620e70 <flush_invalidate_cache_v7+0x18>

.Lfinished:
	mov		r10, #0
8f620ed8:	e3a0a000 	mov	r10, #0
	mcr		p15, 2, r10, c0, c0, 0		// select cache level 0
8f620edc:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
	dsb
8f620ee0:	f57ff04f 	dsb	sy
	ISB
8f620ee4:	f57ff06f 	isb	sy

	bx		lr
8f620ee8:	e12fff1e 	bx	r14

8f620eec <invalidate_cache_v7>:

// invalidate cache routine
invalidate_cache_v7:
	/* from ARMv7 manual, B2-17 */
	MRC 	p15, 1, R0, c0, c0, 1 		// Read CLIDR 
8f620eec:	ee300f30 	mrc	15, 1, r0, cr0, cr0, {1}
	ANDS 	R3, R0, #0x7000000 
8f620ef0:	e2103407 	ands	r3, r0, #117440512	; 0x7000000
	MOV 	R3, R3, LSR #23 			// Cache level value (naturally aligned) 
8f620ef4:	e1a03ba3 	lsr	r3, r3, #23
	BEQ 	.Lfinished_invalidate
8f620ef8:	0a00001a 	beq	8f620f68 <invalidate_cache_v7+0x7c>
	MOV 	R10, #0 
8f620efc:	e3a0a000 	mov	r10, #0
.Loop1_invalidate:
	ADD 	R2, R10, R10, LSR #1 		// Work out 3xcachelevel 
8f620f00:	e08a20aa 	add	r2, r10, r10, lsr #1
	MOV 	R1, R0, LSR R2 				// bottom 3 bits are the Cache type for this level 
8f620f04:	e1a01230 	lsr	r1, r0, r2
	AND 	R1, R1, #7 					// get those 3 bits alone 
8f620f08:	e2011007 	and	r1, r1, #7
	CMP 	R1, #2 
8f620f0c:	e3510002 	cmp	r1, #2
	BLT 	.Lskip_invalidate 			// no cache or only instruction cache at this level 
8f620f10:	ba000011 	blt	8f620f5c <invalidate_cache_v7+0x70>
	MCR 	p15, 2, R10, c0, c0, 0 		// write the Cache Size selection register 
8f620f14:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
	ISB 								// ISB to sync the change to the CacheSizeID reg
8f620f18:	f57ff06f 	isb	sy
	MRC 	p15, 1, R1, c0, c0, 0 		// reads current Cache Size ID register 
8f620f1c:	ee301f10 	mrc	15, 1, r1, cr0, cr0, {0}
	AND 	R2, R1, #0x7 				// extract the line length field 
8f620f20:	e2012007 	and	r2, r1, #7
	ADD 	R2, R2, #4 					// add 4 for the line length offset (log2 16 bytes) 
8f620f24:	e2822004 	add	r2, r2, #4
	LDR 	R4, =0x3FF 
8f620f28:	e59f40d0 	ldr	r4, [pc, #208]	; 8f621000 <arch_sync_cache_range+0x14>
	ANDS 	R4, R4, R1, LSR #3 			// R4 is the max number on the way size (right aligned) 
8f620f2c:	e01441a1 	ands	r4, r4, r1, lsr #3
	CLZ 	R5, R4 						// R5 is the bit position of the way size increment 
8f620f30:	e16f5f14 	clz	r5, r4
	MOV		R9, R4						//R9 working copy of the max way size (right aligned)
8f620f34:	e1a09004 	mov	r9, r4
.Loop2_invalidate:
	LDR 	R7, =0x00007FFF
8f620f38:	e59f70c4 	ldr	r7, [pc, #196]	; 8f621004 <arch_sync_cache_range+0x18>
	ANDS 	R7, R7, R1, LSR #13 		// R7 is the max number of the index size (right aligned)
8f620f3c:	e01776a1 	ands	r7, r7, r1, lsr #13
.Loop3_invalidate:
	ORR 	R11, R10, R9, LSL R5 		// factor in the way number and cache number into R11 
8f620f40:	e18ab519 	orr	r11, r10, r9, lsl r5
	ORR 	R11, R11, R7, LSL R2 		// factor in the index number
8f620f44:	e18bb217 	orr	r11, r11, r7, lsl r2
	MCR 	p15, 0, R11, c7, c14, 2 	// clean and invalidate by set/way
8f620f48:	ee07bf5e 	mcr	15, 0, r11, cr7, cr14, {2}
	SUBS 	R7, R7, #1 					// decrement the way number
8f620f4c:	e2577001 	subs	r7, r7, #1
	BGE 	.Loop3_invalidate 
8f620f50:	aafffffa 	bge	8f620f40 <invalidate_cache_v7+0x54>
	SUBS 	R9, R9, #1 					// decrement the index
8f620f54:	e2599001 	subs	r9, r9, #1
	BGE 	.Loop2_invalidate 
8f620f58:	aafffff6 	bge	8f620f38 <invalidate_cache_v7+0x4c>
.Lskip_invalidate:
 	ADD 	R10, R10, #2 				// increment the cache number 
8f620f5c:	e28aa002 	add	r10, r10, #2
	CMP 	R3, R10 
8f620f60:	e153000a 	cmp	r3, r10
	BGT 	.Loop1_invalidate 
8f620f64:	caffffe5 	bgt	8f620f00 <invalidate_cache_v7+0x14>

.Lfinished_invalidate:
	mov		r10, #0
8f620f68:	e3a0a000 	mov	r10, #0
	mcr		p15, 2, r10, c0, c0, 0		// select cache level 0
8f620f6c:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
	dsb
8f620f70:	f57ff04f 	dsb	sy
	ISB
8f620f74:	f57ff06f 	isb	sy

	bx		lr
8f620f78:	e12fff1e 	bx	r14

8f620f7c <arch_clean_cache_range>:
#if ARM_CPU_ARM926 || ARM_CPU_ARM1136 || ARM_CPU_CORTEX_A8
/* shared cache flush routines */

	/* void arch_flush_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_cache_range)
	add 	r2, r0, r1					// Calculate the end address
8f620f7c:	e0802001 	add	r2, r0, r1
	bic 	r0,#(CACHE_LINE-1)			// Align start with cache line
8f620f80:	e3c0003f 	bic	r0, r0, #63	; 0x3f
0:
	mcr		p15, 0, r0, c7, c10, 1		// clean cache to PoC by MVA
8f620f84:	ee070f3a 	mcr	15, 0, r0, cr7, cr10, {1}
	add		r0, r0, #CACHE_LINE
8f620f88:	e2800040 	add	r0, r0, #64	; 0x40
	cmp 	r0, r2
8f620f8c:	e1500002 	cmp	r0, r2
	blo		0b
8f620f90:	3afffffb 	bcc	8f620f84 <arch_clean_cache_range+0x8>
	
	mov		r0, #0
8f620f94:	e3a00000 	mov	r0, #0
	dsb
8f620f98:	f57ff04f 	dsb	sy

	bx		lr
8f620f9c:	e12fff1e 	bx	r14

8f620fa0 <arch_clean_invalidate_cache_range>:

	/* void arch_flush_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_invalidate_cache_range)
	dsb
8f620fa0:	f57ff04f 	dsb	sy
	add 	r2, r0, r1					// Calculate the end address
8f620fa4:	e0802001 	add	r2, r0, r1
	bic 	r0,#(CACHE_LINE-1)			// Align start with cache line
8f620fa8:	e3c0003f 	bic	r0, r0, #63	; 0x3f
0:
	mcr		p15, 0, r0, c7, c14, 1		// clean & invalidate cache to PoC by MVA
8f620fac:	ee070f3e 	mcr	15, 0, r0, cr7, cr14, {1}
	add		r0, r0, #CACHE_LINE
8f620fb0:	e2800040 	add	r0, r0, #64	; 0x40
	cmp 	r0, r2
8f620fb4:	e1500002 	cmp	r0, r2
	blo		0b
8f620fb8:	3afffffb 	bcc	8f620fac <arch_clean_invalidate_cache_range+0xc>

	mov		r0, #0
8f620fbc:	e3a00000 	mov	r0, #0
	dsb
8f620fc0:	f57ff04f 	dsb	sy

	bx		lr
8f620fc4:	e12fff1e 	bx	r14

8f620fc8 <arch_invalidate_cache_range>:

	/* void arch_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_invalidate_cache_range)
	/* invalidate cache line */
	add 	r2, r0, r1					// Calculate the end address
8f620fc8:	e0802001 	add	r2, r0, r1
	bic 	r0,#(CACHE_LINE-1)			// Align start with cache line
8f620fcc:	e3c0003f 	bic	r0, r0, #63	; 0x3f
0:
	mcr		p15, 0, r0, c7, c6, 1
8f620fd0:	ee070f36 	mcr	15, 0, r0, cr7, cr6, {1}
	add		r0, r0, #CACHE_LINE
8f620fd4:	e2800040 	add	r0, r0, #64	; 0x40
	cmp 	r0, r2
8f620fd8:	e1500002 	cmp	r0, r2
	blo		0b
8f620fdc:	3afffffb 	bcc	8f620fd0 <arch_invalidate_cache_range+0x8>
	mov		r0, #0
8f620fe0:	e3a00000 	mov	r0, #0
	dsb
8f620fe4:	f57ff04f 	dsb	sy
	bx		lr
8f620fe8:	e12fff1e 	bx	r14

8f620fec <arch_sync_cache_range>:

	/* void arch_sync_cache_range(addr_t start, size_t len); */
FUNCTION(arch_sync_cache_range)
	push    { r14 }
8f620fec:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	bl      arch_clean_cache_range
8f620ff0:	ebffffe1 	bl	8f620f7c <arch_clean_cache_range>

	mov     r0, #0
8f620ff4:	e3a00000 	mov	r0, #0
	mcr     p15, 0, r0, c7, c5, 0       // invalidate icache to PoU
8f620ff8:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}

	pop     { pc }
8f620ffc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	LDR 	R4, =0x3FF 
8f621000:	000003ff 	.word	0x000003ff
	LDR 	R7, =0x00007FFF
8f621004:	00007fff 	.word	0x00007fff

8f621008 <arch_enable_ints>:

.text

/* void arch_enable_ints(void); */
FUNCTION(arch_enable_ints)
	mrs	r0, cpsr
8f621008:	e10f0000 	mrs	r0, CPSR
	bic	r0, r0, #(1<<7)		/* clear the I bit */
8f62100c:	e3c00080 	bic	r0, r0, #128	; 0x80
	msr	cpsr_c, r0
8f621010:	e121f000 	msr	CPSR_c, r0
	bx	lr
8f621014:	e12fff1e 	bx	r14

8f621018 <arch_disable_ints>:

/* void arch_disable_ints(void); */
FUNCTION(arch_disable_ints)
	mrs	r0, cpsr
8f621018:	e10f0000 	mrs	r0, CPSR
	orr	r0, r0, #(1<<7)
8f62101c:	e3800080 	orr	r0, r0, #128	; 0x80
	msr	cpsr_c, r0
8f621020:	e121f000 	msr	CPSR_c, r0
	bx	lr
8f621024:	e12fff1e 	bx	r14

8f621028 <atomic_swap>:

/* int atomic_swap(int *ptr, int val); */
FUNCTION(atomic_swap)
.L_loop_swap:
	ldrex r12, [r0]
8f621028:	e190cf9f 	ldrex	r12, [r0]
	strex r2, r1, [r0]
8f62102c:	e1802f91 	strex	r2, r1, [r0]
	cmp   r2 , #0
8f621030:	e3520000 	cmp	r2, #0
	bne .L_loop_swap
8f621034:	1afffffb 	bne	8f621028 <atomic_swap>

	mov r0, r12
8f621038:	e1a0000c 	mov	r0, r12
	bx	lr
8f62103c:	e12fff1e 	bx	r14

8f621040 <atomic_add>:
/* int atomic_add(int *ptr, int val); */
FUNCTION(atomic_add)
#if ARM_ISA_ARMV6 || ARM_ISA_ARMV7
	/* use load/store exclusive */
.L_loop_add:
	ldrex	r12, [r0]
8f621040:	e190cf9f 	ldrex	r12, [r0]
	add		r2, r12, r1
8f621044:	e08c2001 	add	r2, r12, r1
	strex	r3, r2, [r0]
8f621048:	e1803f92 	strex	r3, r2, [r0]
	cmp		r3, #0
8f62104c:	e3530000 	cmp	r3, #0
	bne	.L_loop_add
8f621050:	1afffffa 	bne	8f621040 <atomic_add>

	/* save old value */
	mov		r0, r12
8f621054:	e1a0000c 	mov	r0, r12
	bx		lr
8f621058:	e12fff1e 	bx	r14

8f62105c <atomic_dw_read>:
 * uint32_t st_addr_lo, uint32_t st_addr_hi);
 */
/* Reads a double word from memory atomically */
FUNCTION(atomic_dw_read)
#if ARM_ISA_ARMV6 || ARM_ISA_ARMV7
	stmfd	sp!, {r4-r5}
8f62105c:	e92d0030 	push	{r4, r5}
	/* use load/store exclusive */
	ldrexd	r4, [r0]
8f621060:	e1b04f9f 	ldrexd	r4, [r0]
	str		r4, [r1]
8f621064:	e5814000 	str	r4, [r1]
	str		r5, [r2]
8f621068:	e5825000 	str	r5, [r2]

	/* Restore registers */
	ldmfd	sp!, {r4-r5}
8f62106c:	e8bd0030 	pop	{r4, r5}

	bx		lr
8f621070:	e12fff1e 	bx	r14

8f621074 <atomic_and>:
/* int atomic_and(int *ptr, int val); */
FUNCTION(atomic_and)
#if ARM_ISA_ARMV6 || ARM_ISA_ARMV7
	/* use load/store exclusive */
.L_loop_and:
	ldrex	r12, [r0]
8f621074:	e190cf9f 	ldrex	r12, [r0]
	and		r2, r12, r1
8f621078:	e00c2001 	and	r2, r12, r1
	strex	r3, r2, [r0]
8f62107c:	e1803f92 	strex	r3, r2, [r0]
	cmp		r3, #0
8f621080:	e3530000 	cmp	r3, #0
	bne	.L_loop_and
8f621084:	1afffffa 	bne	8f621074 <atomic_and>

	/* save old value */
	mov		r0, r12
8f621088:	e1a0000c 	mov	r0, r12
	bx		lr
8f62108c:	e12fff1e 	bx	r14

8f621090 <atomic_or>:
/* int atomic_or(int *ptr, int val); */
FUNCTION(atomic_or)
#if ARM_ISA_ARMV6 || ARM_ISA_ARMV7
	/* use load/store exclusive */
.L_loop_or:
	ldrex	r12, [r0]
8f621090:	e190cf9f 	ldrex	r12, [r0]
	orr		r2, r12, r1
8f621094:	e18c2001 	orr	r2, r12, r1
	strex	r3, r2, [r0]
8f621098:	e1803f92 	strex	r3, r2, [r0]
	cmp		r3, #0
8f62109c:	e3530000 	cmp	r3, #0
	bne	.L_loop_or
8f6210a0:	1afffffa 	bne	8f621090 <atomic_or>

	/* save old value */
	mov		r0, r12
8f6210a4:	e1a0000c 	mov	r0, r12
	bx		lr
8f6210a8:	e12fff1e 	bx	r14

8f6210ac <arch_idle>:
#endif

/* void arch_idle(); */
FUNCTION(arch_idle)
#if ARM_CPU_CORTEX_A8
	wfi
8f6210ac:	e320f003 	wfi
#elif ARM_CPU_ARM7
	/* nothing to do here */
#else
#error unknown cpu
#endif
	bx	lr
8f6210b0:	e12fff1e 	bx	r14

8f6210b4 <arm_read_cr1>:

/* uint32_t arm_read_cr1(void) */
FUNCTION(arm_read_cr1)
	mrc		p15, 0, r0, c1, c0, 0
8f6210b4:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bx		lr
8f6210b8:	e12fff1e 	bx	r14

8f6210bc <arm_write_cr1>:

/* void arm_write_cr1(uint32_t val) */
FUNCTION(arm_write_cr1)
	mcr		p15, 0, r0, c1, c0, 0
8f6210bc:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
#if ARM_CPU_CORTEX_A8
	isb		sy
8f6210c0:	f57ff06f 	isb	sy
#elif ARM_CPU_ARM1136
	mov		r0, #0
	mcr		p15, 0, r0, c7, c5, 4
#endif
	bx		lr
8f6210c4:	e12fff1e 	bx	r14

8f6210c8 <arm_read_cr1_aux>:

/* uint32_t arm_read_cr1_aux(void) */
FUNCTION(arm_read_cr1_aux)
	mrc		p15, 0, r0, c1, c0, 1
8f6210c8:	ee110f30 	mrc	15, 0, r0, cr1, cr0, {1}
	bx		lr
8f6210cc:	e12fff1e 	bx	r14

8f6210d0 <arm_write_cr1_aux>:

/* void arm_write_cr1_aux(uint32_t val) */
FUNCTION(arm_write_cr1_aux)
	mcr		p15, 0, r0, c1, c0, 1
8f6210d0:	ee010f30 	mcr	15, 0, r0, cr1, cr0, {1}
	bx		lr
8f6210d4:	e12fff1e 	bx	r14

8f6210d8 <arm_write_ttbr>:

/* void arm_write_ttbr(uint32_t val) */
FUNCTION(arm_write_ttbr)
	mcr	p15, 0, r0, c2, c0, 0
8f6210d8:	ee020f10 	mcr	15, 0, r0, cr2, cr0, {0}
	bx		lr
8f6210dc:	e12fff1e 	bx	r14

8f6210e0 <arm_write_dacr>:

/* void arm_write_dacr(uint32_t val) */
FUNCTION(arm_write_dacr)
	mcr	p15, 0, r0, c3, c0, 0
8f6210e0:	ee030f10 	mcr	15, 0, r0, cr3, cr0, {0}
	bx		lr
8f6210e4:	e12fff1e 	bx	r14

8f6210e8 <arm_invalidate_tlb>:

/* void arm_invalidate_tlb(void) */
FUNCTION(arm_invalidate_tlb)
	dsb
8f6210e8:	f57ff04f 	dsb	sy
	isb
8f6210ec:	f57ff06f 	isb	sy
	mov		r0, #0
8f6210f0:	e3a00000 	mov	r0, #0
	mcr	p15, 0, r0, c8, c7, 0
8f6210f4:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
#if ARM_CPU_CORTEX_A8
	dsb		sy
8f6210f8:	f57ff04f 	dsb	sy
#elif ARM_CPU_ARM1136
	mov		r0, #0
	mcr		p15, 0, r0, c7, c10, 4
#endif
#if ARM_CPU_CORTEX_A8
	isb		sy
8f6210fc:	f57ff06f 	isb	sy
#elif ARM_CPU_ARM1136
	mov		r0, #0
	mcr		p15, 0, r0, c7, c5, 4
#endif
	bx		lr
8f621100:	e12fff1e 	bx	r14

8f621104 <arch_switch_stacks_and_call>:

/* void arch_switch_stacks_and_call(addr_t call, addr_t stack) */
FUNCTION(arch_switch_stacks_and_call)
	mov		sp, r1
8f621104:	e1a0d001 	mov	r13, r1
	bx		r0
8f621108:	e12fff10 	bx	r0

8f62110c <dmb>:

/*void dmb(void) */
FUNCTION(dmb)
#if ARM_CPU_CORTEX_A8
	dmb		sy
8f62110c:	f57ff05f 	dmb	sy
#elif ARM_CPU_ARM1136
	mov		r0, #0
	mcr		p15, 0, r0, c7, c10, 5
#endif
	bx		lr
8f621110:	e12fff1e 	bx	r14

8f621114 <arch_cycle_count>:
FUNCTION(arm_read_cycle_count)

/* uint32_t arch_cycle_count(void); */
FUNCTION(arch_cycle_count)
#if ARM_CPU_CORTEX_A8
	mrc		p15, 0, r0, c9, c13, 0
8f621114:	ee190f1d 	mrc	15, 0, r0, cr9, cr13, {0}
#else
	mov		r0, #0
#endif
	bx		lr
8f621118:	e12fff1e 	bx	r14

8f62111c <arm_write_mair0>:

FUNCTION(arm_write_mair0)
	mcr p15, 0, r0, c10, c2, 0
8f62111c:	ee0a0f12 	mcr	15, 0, r0, cr10, cr2, {0}
	bx	lr
8f621120:	e12fff1e 	bx	r14

8f621124 <arm_write_mair1>:

FUNCTION(arm_write_mair1)
	mcr p15, 0, r0, c10, c2, 1
8f621124:	ee0a0f32 	mcr	15, 0, r0, cr10, cr2, {1}
	bx lr
8f621128:	e12fff1e 	bx	r14

8f62112c <arm_write_ttbcr>:

FUNCTION(arm_write_ttbcr)
	mcr p15, 0, r0, c2, c0, 2
8f62112c:	ee020f50 	mcr	15, 0, r0, cr2, cr0, {2}
	bx lr
8f621130:	e12fff1e 	bx	r14

8f621134 <arm_undefined>:
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
#include <asm.h>

FUNCTION(arm_undefined)
	stmfd 	sp!, { r0-r12, r14 }
8f621134:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
	sub		sp, sp, #12
8f621138:	e24dd00c 	sub	r13, r13, #12
	mov		r0, sp
8f62113c:	e1a0000d 	mov	r0, r13
	mrs		r1, spsr
8f621140:	e14f1000 	mrs	r1, SPSR
	stmia	r0, { r1, r13-r14 }^
8f621144:	e8c06002 	stmia	r0, {r1, r13, r14}^
	b		arm_undefined_handler
8f621148:	ea0000ef 	b	8f62150c <arm_undefined_handler>
	b		.
8f62114c:	eafffffe 	b	8f62114c <arm_undefined+0x18>

8f621150 <arm_syscall>:

FUNCTION(arm_syscall)
	stmfd 	sp!, { r0-r12, r14 }
8f621150:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
	sub		sp, sp, #12
8f621154:	e24dd00c 	sub	r13, r13, #12
	mov		r0, sp
8f621158:	e1a0000d 	mov	r0, r13
	mrs		r1, spsr
8f62115c:	e14f1000 	mrs	r1, SPSR
	stmia	r0, { r1, r13-r14 }^
8f621160:	e8c06002 	stmia	r0, {r1, r13, r14}^
	b		arm_syscall_handler
8f621164:	ea0000dd 	b	8f6214e0 <arm_syscall_handler>
	b		.
8f621168:	eafffffe 	b	8f621168 <arm_syscall+0x18>

8f62116c <arm_prefetch_abort>:
	
FUNCTION(arm_prefetch_abort)
	stmfd 	sp!, { r0-r12, r14 }
8f62116c:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
	sub		sp, sp, #12
8f621170:	e24dd00c 	sub	r13, r13, #12
	mov		r0, sp
8f621174:	e1a0000d 	mov	r0, r13
	mrs		r1, spsr
8f621178:	e14f1000 	mrs	r1, SPSR
	stmia	r0, { r1, r13-r14 }^
8f62117c:	e8c06002 	stmia	r0, {r1, r13, r14}^
	b		arm_prefetch_abort_handler
8f621180:	ea0000f7 	b	8f621564 <arm_prefetch_abort_handler>
	b		.
8f621184:	eafffffe 	b	8f621184 <arm_prefetch_abort+0x18>

8f621188 <arm_data_abort>:

FUNCTION(arm_data_abort)
	stmfd 	sp!, { r0-r12, r14 }
8f621188:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
	sub		sp, sp, #12
8f62118c:	e24dd00c 	sub	r13, r13, #12
	mov		r0, sp
8f621190:	e1a0000d 	mov	r0, r13
	mrs		r1, spsr
8f621194:	e14f1000 	mrs	r1, SPSR
	stmia	r0, { r1, r13-r14 }^
8f621198:	e8c06002 	stmia	r0, {r1, r13, r14}^
	b		arm_data_abort_handler
8f62119c:	ea0000e5 	b	8f621538 <arm_data_abort_handler>
	b		.
8f6211a0:	eafffffe 	b	8f6211a0 <arm_data_abort+0x18>

8f6211a4 <arm_reserved>:
	
FUNCTION(arm_reserved)
	b	.
8f6211a4:	eafffffe 	b	8f6211a4 <arm_reserved>

8f6211a8 <arm_irq>:
	
FUNCTION(arm_irq)
	/* XXX only deals with interrupting supervisor mode */

	/* save r4-r6 and use as a temporary place to save while we switch into supervisor mode */
	stmia	r13, { r4-r6 }
8f6211a8:	e88d0070 	stm	r13, {r4, r5, r6}
	mov		r4, r13
8f6211ac:	e1a0400d 	mov	r4, r13
	sub		r5, lr, #4
8f6211b0:	e24e5004 	sub	r5, r14, #4
	mrs		r6, spsr
8f6211b4:	e14f6000 	mrs	r6, SPSR

	/* move into supervisor mode. irq/fiq disabled */
	msr	cpsr_c, #(3<<6 | 0x13)
8f6211b8:	e321f0d3 	msr	CPSR_c, #211	; 0xd3

	/* save the return address */
	stmfd	sp!, { r5 }
8f6211bc:	e92d0020 	stmfd	r13!, {r5}

	/* save C trashed regs, supervisor lr */
	stmfd	sp!, { r0-r3, r12, lr }
8f6211c0:	e92d500f 	push	{r0, r1, r2, r3, r12, r14}

	/* save spsr */
	stmfd	sp!, { r6 }
8f6211c4:	e92d0040 	stmfd	r13!, {r6}

	/* restore r4-r6 */
	ldmia	r4, { r4-r6 }
8f6211c8:	e8940070 	ldm	r4, {r4, r5, r6}

	/* increment the global critical section count */
	ldr     r1, =critical_section_count
8f6211cc:	e59f1044 	ldr	r1, [pc, #68]	; 8f621218 <arm_fiq+0x10>
	ldr     r0, [r1]
8f6211d0:	e5910000 	ldr	r0, [r1]
	add     r0, r0, #1
8f6211d4:	e2800001 	add	r0, r0, #1
	str     r0, [r1]
8f6211d8:	e5810000 	str	r0, [r1]
	
	/* call into higher level code */
	mov	r0, sp /* iframe */
8f6211dc:	e1a0000d 	mov	r0, r13
	bl	platform_irq
8f6211e0:	ebffb7e5 	bl	8f60f17c <platform_irq>

	/* reschedule if the handler returns nonzero */
	cmp     r0, #0
8f6211e4:	e3500000 	cmp	r0, #0
	blne    thread_preempt
8f6211e8:	1b000b61 	blne	8f623f74 <thread_preempt>

	/* decrement the global critical section count */
	ldr     r1, =critical_section_count
8f6211ec:	e59f1024 	ldr	r1, [pc, #36]	; 8f621218 <arm_fiq+0x10>
	ldr     r0, [r1]
8f6211f0:	e5910000 	ldr	r0, [r1]
	sub     r0, r0, #1
8f6211f4:	e2400001 	sub	r0, r0, #1
	str     r0, [r1]
8f6211f8:	e5810000 	str	r0, [r1]

	/* restore spsr */
	ldmfd	sp!, { r0 }
8f6211fc:	e8bd0001 	ldmfd	r13!, {r0}
	msr     spsr_cxsf, r0
8f621200:	e16ff000 	msr	SPSR_fsxc, r0

	/* restore back to where we came from */
	ldmfd	sp!, { r0-r3, r12, lr, pc }^
8f621204:	e8fdd00f 	ldm	r13!, {r0, r1, r2, r3, r12, r14, r15}^

8f621208 <arm_fiq>:
	.word	0	/* r5 */
	.word	0	/* r6 */
	
.text
FUNCTION(arm_fiq)
	sub	lr, lr, #4
8f621208:	e24ee004 	sub	r14, r14, #4
	stmfd	sp!, { r0-r3, r12, lr }
8f62120c:	e92d500f 	push	{r0, r1, r2, r3, r12, r14}

	bl	platform_fiq
8f621210:	ebffb7ea 	bl	8f60f1c0 <platform_fiq>
	
	ldmfd	sp!, { r0-r3, r12, pc }^
8f621214:	e8fd900f 	ldm	r13!, {r0, r1, r2, r3, r12, r15}^
	ldr     r1, =critical_section_count
8f621218:	8f711acc 	.word	0x8f711acc

8f62121c <dump_fault_frame>:
#include <debug.h>
#include <arch/arm.h>
#include <kernel/thread.h>

void dump_fault_frame(struct arm_fault_frame *frame)
{
8f62121c:	e92d4010 	push	{r4, r14}
8f621220:	e1a04000 	mov	r4, r0
	dprintf(CRITICAL, "r0  0x%08x r1  0x%08x r2  0x%08x r3  0x%08x\n", frame->r[0], frame->r[1], frame->r[2], frame->r[3]);
8f621224:	e5941018 	ldr	r1, [r4, #24]
{
8f621228:	e24dd040 	sub	r13, r13, #64	; 0x40
8f62122c:	e59fc250 	ldr	r12, [pc, #592]	; 8f621484 <dump_fault_frame+0x268>
	dprintf(CRITICAL, "r0  0x%08x r1  0x%08x r2  0x%08x r3  0x%08x\n", frame->r[0], frame->r[1], frame->r[2], frame->r[3]);
8f621230:	e30708a4 	movw	r0, #30884	; 0x78a4
8f621234:	e1c421d0 	ldrd	r2, [r4, #16]
8f621238:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f62123c:	e59cc000 	ldr	r12, [r12]
8f621240:	e58dc03c 	str	r12, [r13, #60]	; 0x3c
8f621244:	e3a0c000 	mov	r12, #0
	dprintf(CRITICAL, "r0  0x%08x r1  0x%08x r2  0x%08x r3  0x%08x\n", frame->r[0], frame->r[1], frame->r[2], frame->r[3]);
8f621248:	e58d1000 	str	r1, [r13]
8f62124c:	e594100c 	ldr	r1, [r4, #12]
8f621250:	eb0045c7 	bl	8f632974 <_dprintf>
	dprintf(CRITICAL, "r4  0x%08x r5  0x%08x r6  0x%08x r7  0x%08x\n", frame->r[4], frame->r[5], frame->r[6], frame->r[7]);
8f621254:	e5940028 	ldr	r0, [r4, #40]	; 0x28
8f621258:	e1c422d0 	ldrd	r2, [r4, #32]
8f62125c:	e594101c 	ldr	r1, [r4, #28]
8f621260:	e58d0000 	str	r0, [r13]
8f621264:	e30708d4 	movw	r0, #30932	; 0x78d4
8f621268:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62126c:	eb0045c0 	bl	8f632974 <_dprintf>
	dprintf(CRITICAL, "r8  0x%08x r9  0x%08x r10 0x%08x r11 0x%08x\n", frame->r[8], frame->r[9], frame->r[10], frame->r[11]);
8f621270:	e5940038 	ldr	r0, [r4, #56]	; 0x38
8f621274:	e1c423d0 	ldrd	r2, [r4, #48]	; 0x30
8f621278:	e594102c 	ldr	r1, [r4, #44]	; 0x2c
8f62127c:	e58d0000 	str	r0, [r13]
8f621280:	e3070904 	movw	r0, #30980	; 0x7904
8f621284:	e3480f70 	movt	r0, #36720	; 0x8f70
8f621288:	eb0045b9 	bl	8f632974 <_dprintf>
	dprintf(CRITICAL, "r12 0x%08x usp 0x%08x ulr 0x%08x pc  0x%08x\n", frame->r[12], frame->usp, frame->ulr, frame->pc);
8f62128c:	e5940040 	ldr	r0, [r4, #64]	; 0x40
8f621290:	e1c420d4 	ldrd	r2, [r4, #4]
8f621294:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
8f621298:	e58d0000 	str	r0, [r13]
8f62129c:	e3070934 	movw	r0, #31028	; 0x7934
8f6212a0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6212a4:	eb0045b2 	bl	8f632974 <_dprintf>
	dprintf(CRITICAL, "spsr 0x%08x\n", frame->spsr);
8f6212a8:	e5941000 	ldr	r1, [r4]
8f6212ac:	e3070964 	movw	r0, #31076	; 0x7964
8f6212b0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6212b4:	eb0045ae 	bl	8f632974 <_dprintf>

	struct arm_mode_regs regs;
	arm_save_mode_regs(&regs);
8f6212b8:	e28d000c 	add	r0, r13, #12
8f6212bc:	ebfffea0 	bl	8f620d44 <arm_save_mode_regs>

	dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((frame->spsr & MODE_MASK) == MODE_FIQ) ? '*' : ' ', "fiq", regs.fiq_r13, regs.fiq_r14);
8f6212c0:	e5941000 	ldr	r1, [r4]
8f6212c4:	e59d0010 	ldr	r0, [r13, #16]
8f6212c8:	e3072974 	movw	r2, #31092	; 0x7974
8f6212cc:	e201101f 	and	r1, r1, #31
8f6212d0:	e59d300c 	ldr	r3, [r13, #12]
8f6212d4:	e3510011 	cmp	r1, #17
8f6212d8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6212dc:	e58d0000 	str	r0, [r13]
8f6212e0:	e3070978 	movw	r0, #31096	; 0x7978
8f6212e4:	03a0102a 	moveq	r1, #42	; 0x2a
8f6212e8:	13a01020 	movne	r1, #32
8f6212ec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6212f0:	eb00459f 	bl	8f632974 <_dprintf>
	dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((frame->spsr & MODE_MASK) == MODE_IRQ) ? '*' : ' ', "irq", regs.irq_r13, regs.irq_r14);
8f6212f4:	e5941000 	ldr	r1, [r4]
8f6212f8:	e59d0018 	ldr	r0, [r13, #24]
8f6212fc:	e3072994 	movw	r2, #31124	; 0x7994
8f621300:	e201101f 	and	r1, r1, #31
8f621304:	e59d3014 	ldr	r3, [r13, #20]
8f621308:	e3510012 	cmp	r1, #18
8f62130c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f621310:	e58d0000 	str	r0, [r13]
8f621314:	e3070978 	movw	r0, #31096	; 0x7978
8f621318:	03a0102a 	moveq	r1, #42	; 0x2a
8f62131c:	13a01020 	movne	r1, #32
8f621320:	e3480f70 	movt	r0, #36720	; 0x8f70
8f621324:	eb004592 	bl	8f632974 <_dprintf>
	dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((frame->spsr & MODE_MASK) == MODE_SVC) ? '*' : ' ', "svc", regs.svc_r13, regs.svc_r14);
8f621328:	e5941000 	ldr	r1, [r4]
8f62132c:	e59d0020 	ldr	r0, [r13, #32]
8f621330:	e3072998 	movw	r2, #31128	; 0x7998
8f621334:	e201101f 	and	r1, r1, #31
8f621338:	e59d301c 	ldr	r3, [r13, #28]
8f62133c:	e3510013 	cmp	r1, #19
8f621340:	e3482f70 	movt	r2, #36720	; 0x8f70
8f621344:	e58d0000 	str	r0, [r13]
8f621348:	e3070978 	movw	r0, #31096	; 0x7978
8f62134c:	03a0102a 	moveq	r1, #42	; 0x2a
8f621350:	13a01020 	movne	r1, #32
8f621354:	e3480f70 	movt	r0, #36720	; 0x8f70
8f621358:	eb004585 	bl	8f632974 <_dprintf>
	dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((frame->spsr & MODE_MASK) == MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
8f62135c:	e5941000 	ldr	r1, [r4]
8f621360:	e59d0030 	ldr	r0, [r13, #48]	; 0x30
8f621364:	e307299c 	movw	r2, #31132	; 0x799c
8f621368:	e201101f 	and	r1, r1, #31
8f62136c:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
8f621370:	e351001b 	cmp	r1, #27
8f621374:	e3482f70 	movt	r2, #36720	; 0x8f70
8f621378:	e58d0000 	str	r0, [r13]
8f62137c:	e3070978 	movw	r0, #31096	; 0x7978
8f621380:	03a0102a 	moveq	r1, #42	; 0x2a
8f621384:	13a01020 	movne	r1, #32
8f621388:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62138c:	eb004578 	bl	8f632974 <_dprintf>
	dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((frame->spsr & MODE_MASK) == MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
8f621390:	e5941000 	ldr	r1, [r4]
8f621394:	e59d0038 	ldr	r0, [r13, #56]	; 0x38
8f621398:	e30729a0 	movw	r2, #31136	; 0x79a0
8f62139c:	e201101f 	and	r1, r1, #31
8f6213a0:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f6213a4:	e351001f 	cmp	r1, #31
8f6213a8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6213ac:	e58d0000 	str	r0, [r13]
8f6213b0:	e3070978 	movw	r0, #31096	; 0x7978
8f6213b4:	03a0102a 	moveq	r1, #42	; 0x2a
8f6213b8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6213bc:	13a01020 	movne	r1, #32
8f6213c0:	eb00456b 	bl	8f632974 <_dprintf>

	// dump the bottom of the current stack
	addr_t stack;
	switch (frame->spsr & MODE_MASK) {
8f6213c4:	e5943000 	ldr	r3, [r4]
8f6213c8:	e203301f 	and	r3, r3, #31
8f6213cc:	e2433011 	sub	r3, r3, #17
8f6213d0:	e353000e 	cmp	r3, #14
8f6213d4:	979ff103 	ldrls	r15, [r15, r3, lsl #2]
8f6213d8:	ea000018 	b	8f621440 <dump_fault_frame+0x224>
8f6213dc:	8f621460 	.word	0x8f621460
8f6213e0:	8f621468 	.word	0x8f621468
8f6213e4:	8f621470 	.word	0x8f621470
8f6213e8:	8f621440 	.word	0x8f621440
8f6213ec:	8f621440 	.word	0x8f621440
8f6213f0:	8f621440 	.word	0x8f621440
8f6213f4:	8f621440 	.word	0x8f621440
8f6213f8:	8f621440 	.word	0x8f621440
8f6213fc:	8f621440 	.word	0x8f621440
8f621400:	8f621440 	.word	0x8f621440
8f621404:	8f621478 	.word	0x8f621478
8f621408:	8f621440 	.word	0x8f621440
8f62140c:	8f621440 	.word	0x8f621440
8f621410:	8f621440 	.word	0x8f621440
8f621414:	8f621418 	.word	0x8f621418
		case MODE_FIQ: stack = regs.fiq_r13; break;
		case MODE_IRQ: stack = regs.irq_r13; break;
		case MODE_SVC: stack = regs.svc_r13; break;
		case MODE_UND: stack = regs.und_r13; break;
		case MODE_SYS: stack = regs.sys_r13; break;
8f621418:	e59d4034 	ldr	r4, [r13, #52]	; 0x34
		default:
			stack = 0;
	}

	if (stack != 0) {
8f62141c:	e3540000 	cmp	r4, #0
8f621420:	0a000006 	beq	8f621440 <dump_fault_frame+0x224>
		dprintf(CRITICAL, "bottom of stack at 0x%08x:\n", (unsigned int)stack);
8f621424:	e1a01004 	mov	r1, r4
8f621428:	e30709a4 	movw	r0, #31140	; 0x79a4
8f62142c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f621430:	eb00454f 	bl	8f632974 <_dprintf>
		hexdump((void *)stack, 128);
8f621434:	e3a01080 	mov	r1, #128	; 0x80
8f621438:	e1a00004 	mov	r0, r4
8f62143c:	eb0045eb 	bl	8f632bf0 <hexdump>
	}
}
8f621440:	e59f303c 	ldr	r3, [pc, #60]	; 8f621484 <dump_fault_frame+0x268>
8f621444:	e5932000 	ldr	r2, [r3]
8f621448:	e59d303c 	ldr	r3, [r13, #60]	; 0x3c
8f62144c:	e0332002 	eors	r2, r3, r2
8f621450:	e3a03000 	mov	r3, #0
8f621454:	1a000009 	bne	8f621480 <dump_fault_frame+0x264>
8f621458:	e28dd040 	add	r13, r13, #64	; 0x40
8f62145c:	e8bd8010 	pop	{r4, r15}
		case MODE_FIQ: stack = regs.fiq_r13; break;
8f621460:	e59d400c 	ldr	r4, [r13, #12]
8f621464:	eaffffec 	b	8f62141c <dump_fault_frame+0x200>
		case MODE_IRQ: stack = regs.irq_r13; break;
8f621468:	e59d4014 	ldr	r4, [r13, #20]
8f62146c:	eaffffea 	b	8f62141c <dump_fault_frame+0x200>
		case MODE_SVC: stack = regs.svc_r13; break;
8f621470:	e59d401c 	ldr	r4, [r13, #28]
8f621474:	eaffffe8 	b	8f62141c <dump_fault_frame+0x200>
		case MODE_UND: stack = regs.und_r13; break;
8f621478:	e59d402c 	ldr	r4, [r13, #44]	; 0x2c
8f62147c:	eaffffe6 	b	8f62141c <dump_fault_frame+0x200>
}
8f621480:	eb0045ce 	bl	8f632bc0 <__stack_chk_fail>
8f621484:	8f74221c 	.word	0x8f74221c

8f621488 <exception_die>:
{
	return critical_section_count > 0;
}

/* only used by interrupt glue */
static inline void inc_critical_section(void) { critical_section_count++; }
8f621488:	e3013acc 	movw	r3, #6860	; 0x1acc
8f62148c:	e3483f71 	movt	r3, #36721	; 0x8f71

static void exception_die(struct arm_fault_frame *frame, int pc_off, const char *msg)
{
8f621490:	e1a04000 	mov	r4, r0
	inc_critical_section();
	frame->pc += pc_off;
	dprintf(CRITICAL, msg);
8f621494:	e1a00002 	mov	r0, r2
8f621498:	e593c000 	ldr	r12, [r3]
{
8f62149c:	e59f2038 	ldr	r2, [pc, #56]	; 8f6214dc <exception_die+0x54>
8f6214a0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6214a4:	e24dd00c 	sub	r13, r13, #12
8f6214a8:	e5922000 	ldr	r2, [r2]
8f6214ac:	e58d2004 	str	r2, [r13, #4]
8f6214b0:	e3a02000 	mov	r2, #0
8f6214b4:	e28cc001 	add	r12, r12, #1
8f6214b8:	e583c000 	str	r12, [r3]
	frame->pc += pc_off;
8f6214bc:	e5943040 	ldr	r3, [r4, #64]	; 0x40
8f6214c0:	e0833001 	add	r3, r3, r1
8f6214c4:	e5843040 	str	r3, [r4, #64]	; 0x40
	dprintf(CRITICAL, msg);
8f6214c8:	eb004529 	bl	8f632974 <_dprintf>
	dump_fault_frame(frame);
8f6214cc:	e1a00004 	mov	r0, r4
8f6214d0:	ebffff51 	bl	8f62121c <dump_fault_frame>
	
	halt();
8f6214d4:	eb0044f3 	bl	8f6328a8 <halt>
	for(;;);
8f6214d8:	eafffffe 	b	8f6214d8 <exception_die+0x50>
8f6214dc:	8f74221c 	.word	0x8f74221c

8f6214e0 <arm_syscall_handler>:
}

void arm_syscall_handler(struct arm_fault_frame *frame)
{
8f6214e0:	e59f3020 	ldr	r3, [pc, #32]	; 8f621508 <arm_syscall_handler+0x28>
	exception_die(frame, -4, "unhandled syscall, halting\n");
8f6214e4:	e30729c0 	movw	r2, #31168	; 0x79c0
{
8f6214e8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	exception_die(frame, -4, "unhandled syscall, halting\n");
8f6214ec:	e3482f70 	movt	r2, #36720	; 0x8f70
{
8f6214f0:	e24dd00c 	sub	r13, r13, #12
	exception_die(frame, -4, "unhandled syscall, halting\n");
8f6214f4:	e3e01003 	mvn	r1, #3
{
8f6214f8:	e5933000 	ldr	r3, [r3]
8f6214fc:	e58d3004 	str	r3, [r13, #4]
8f621500:	e3a03000 	mov	r3, #0
	exception_die(frame, -4, "unhandled syscall, halting\n");
8f621504:	ebffffdf 	bl	8f621488 <exception_die>
8f621508:	8f74221c 	.word	0x8f74221c

8f62150c <arm_undefined_handler>:
}

void arm_undefined_handler(struct arm_fault_frame *frame)
{
8f62150c:	e59f3020 	ldr	r3, [pc, #32]	; 8f621534 <arm_undefined_handler+0x28>
	exception_die(frame, -4, "undefined abort, halting\n");
8f621510:	e30729dc 	movw	r2, #31196	; 0x79dc
{
8f621514:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	exception_die(frame, -4, "undefined abort, halting\n");
8f621518:	e3482f70 	movt	r2, #36720	; 0x8f70
{
8f62151c:	e24dd00c 	sub	r13, r13, #12
	exception_die(frame, -4, "undefined abort, halting\n");
8f621520:	e3e01003 	mvn	r1, #3
{
8f621524:	e5933000 	ldr	r3, [r3]
8f621528:	e58d3004 	str	r3, [r13, #4]
8f62152c:	e3a03000 	mov	r3, #0
	exception_die(frame, -4, "undefined abort, halting\n");
8f621530:	ebffffd4 	bl	8f621488 <exception_die>
8f621534:	8f74221c 	.word	0x8f74221c

8f621538 <arm_data_abort_handler>:
}

void arm_data_abort_handler(struct arm_fault_frame *frame)
{
8f621538:	e59f3020 	ldr	r3, [pc, #32]	; 8f621560 <arm_data_abort_handler+0x28>
	exception_die(frame, -8, "data abort, halting\n");
8f62153c:	e30729f8 	movw	r2, #31224	; 0x79f8
{
8f621540:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	exception_die(frame, -8, "data abort, halting\n");
8f621544:	e3482f70 	movt	r2, #36720	; 0x8f70
{
8f621548:	e24dd00c 	sub	r13, r13, #12
	exception_die(frame, -8, "data abort, halting\n");
8f62154c:	e3e01007 	mvn	r1, #7
{
8f621550:	e5933000 	ldr	r3, [r3]
8f621554:	e58d3004 	str	r3, [r13, #4]
8f621558:	e3a03000 	mov	r3, #0
	exception_die(frame, -8, "data abort, halting\n");
8f62155c:	ebffffc9 	bl	8f621488 <exception_die>
8f621560:	8f74221c 	.word	0x8f74221c

8f621564 <arm_prefetch_abort_handler>:
}

void arm_prefetch_abort_handler(struct arm_fault_frame *frame)
{
8f621564:	e59f3020 	ldr	r3, [pc, #32]	; 8f62158c <arm_prefetch_abort_handler+0x28>
	exception_die(frame, -4, "prefetch abort, halting\n");
8f621568:	e3072a10 	movw	r2, #31248	; 0x7a10
{
8f62156c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	exception_die(frame, -4, "prefetch abort, halting\n");
8f621570:	e3482f70 	movt	r2, #36720	; 0x8f70
{
8f621574:	e24dd00c 	sub	r13, r13, #12
	exception_die(frame, -4, "prefetch abort, halting\n");
8f621578:	e3e01003 	mvn	r1, #3
{
8f62157c:	e5933000 	ldr	r3, [r3]
8f621580:	e58d3004 	str	r3, [r13, #4]
8f621584:	e3a03000 	mov	r3, #0
	exception_die(frame, -4, "prefetch abort, halting\n");
8f621588:	ebffffbe 	bl	8f621488 <exception_die>
8f62158c:	8f74221c 	.word	0x8f74221c

8f621590 <initial_thread_func>:

extern void arm_context_switch(addr_t *old_sp, addr_t new_sp);

static void initial_thread_func(void) __NO_RETURN;
static void initial_thread_func(void)
{
8f621590:	e59f3050 	ldr	r3, [pc, #80]	; 8f6215e8 <initial_thread_func+0x58>
	critical_section_count--;
8f621594:	e3012acc 	movw	r2, #6860	; 0x1acc
8f621598:	e3482f71 	movt	r2, #36721	; 0x8f71
8f62159c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6215a0:	e24dd00c 	sub	r13, r13, #12
8f6215a4:	e5933000 	ldr	r3, [r3]
8f6215a8:	e58d3004 	str	r3, [r13, #4]
8f6215ac:	e3a03000 	mov	r3, #0
8f6215b0:	e5923000 	ldr	r3, [r2]
8f6215b4:	e2433001 	sub	r3, r3, #1
8f6215b8:	e5823000 	str	r3, [r2]
	if (critical_section_count == 0)
8f6215bc:	e3530000 	cmp	r3, #0
8f6215c0:	0a000006 	beq	8f6215e0 <initial_thread_func+0x50>
//	dump_thread(current_thread);

	/* exit the implicit critical section we're within */
	exit_critical_section();

	ret = current_thread->entry(current_thread->arg);
8f6215c4:	e3023cc0 	movw	r3, #11456	; 0x2cc0
8f6215c8:	e3483f74 	movt	r3, #36724	; 0x8f74
8f6215cc:	e5933000 	ldr	r3, [r3]
8f6215d0:	e5932038 	ldr	r2, [r3, #56]	; 0x38
8f6215d4:	e593003c 	ldr	r0, [r3, #60]	; 0x3c
8f6215d8:	e12fff32 	blx	r2

//	dprintf("initial_thread_func: thread %p exiting with %d\n", current_thread, ret);

	thread_exit(ret);
8f6215dc:	eb000980 	bl	8f623be4 <thread_exit>
		arch_enable_ints();
8f6215e0:	ebfffe88 	bl	8f621008 <arch_enable_ints>
8f6215e4:	eafffff6 	b	8f6215c4 <initial_thread_func+0x34>
8f6215e8:	8f74221c 	.word	0x8f74221c

8f6215ec <arch_thread_initialize>:
}

void arch_thread_initialize(thread_t *t)
{
8f6215ec:	e92d4070 	push	{r4, r5, r6, r14}
8f6215f0:	e1a05000 	mov	r5, r0
	// create a default stack frame on the stack
	vaddr_t stack_top = (vaddr_t)t->stack + t->stack_size;
8f6215f4:	e5903034 	ldr	r3, [r0, #52]	; 0x34
{
8f6215f8:	e24dd008 	sub	r13, r13, #8
	vaddr_t stack_top = (vaddr_t)t->stack + t->stack_size;
8f6215fc:	e5904030 	ldr	r4, [r0, #48]	; 0x30

	struct context_switch_frame *frame = (struct context_switch_frame *)(stack_top);
	frame--;

	// fill it in
	memset(frame, 0, sizeof(*frame));
8f621600:	e3a0202c 	mov	r2, #44	; 0x2c
{
8f621604:	e59f0054 	ldr	r0, [pc, #84]	; 8f621660 <arch_thread_initialize+0x74>
	memset(frame, 0, sizeof(*frame));
8f621608:	e3a01000 	mov	r1, #0
	vaddr_t stack_top = (vaddr_t)t->stack + t->stack_size;
8f62160c:	e0844003 	add	r4, r4, r3
	stack_top = ROUNDDOWN(stack_top, 8);
8f621610:	e3c44007 	bic	r4, r4, #7
{
8f621614:	e5900000 	ldr	r0, [r0]
8f621618:	e58d0004 	str	r0, [r13, #4]
8f62161c:	e3a00000 	mov	r0, #0
	frame--;
8f621620:	e244602c 	sub	r6, r4, #44	; 0x2c
	memset(frame, 0, sizeof(*frame));
8f621624:	e1a00006 	mov	r0, r6
8f621628:	eb004b25 	bl	8f6342c4 <memset>
	frame->lr = (vaddr_t)&initial_thread_func;
8f62162c:	e3013590 	movw	r3, #5520	; 0x1590
8f621630:	e3483f62 	movt	r3, #36706	; 0x8f62
8f621634:	e504300c 	str	r3, [r4, #-12]
	
	// set the stack pointer
	t->arch.sp = (vaddr_t)frame;
}
8f621638:	e59f3020 	ldr	r3, [pc, #32]	; 8f621660 <arch_thread_initialize+0x74>
	t->arch.sp = (vaddr_t)frame;
8f62163c:	e585602c 	str	r6, [r5, #44]	; 0x2c
}
8f621640:	e5932000 	ldr	r2, [r3]
8f621644:	e59d3004 	ldr	r3, [r13, #4]
8f621648:	e0332002 	eors	r2, r3, r2
8f62164c:	e3a03000 	mov	r3, #0
8f621650:	1a000001 	bne	8f62165c <arch_thread_initialize+0x70>
8f621654:	e28dd008 	add	r13, r13, #8
8f621658:	e8bd8070 	pop	{r4, r5, r6, r15}
8f62165c:	eb004557 	bl	8f632bc0 <__stack_chk_fail>
8f621660:	8f74221c 	.word	0x8f74221c

8f621664 <arch_context_switch>:

void arch_context_switch(thread_t *oldthread, thread_t *newthread)
{
8f621664:	e59f3040 	ldr	r3, [pc, #64]	; 8f6216ac <arch_context_switch+0x48>
8f621668:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62166c:	e24dd00c 	sub	r13, r13, #12
8f621670:	e5933000 	ldr	r3, [r3]
8f621674:	e58d3004 	str	r3, [r13, #4]
8f621678:	e3a03000 	mov	r3, #0
//	dprintf("arch_context_switch: old %p (%s), new %p (%s)\n", oldthread, oldthread->name, newthread, newthread->name);
	arm_context_switch(&oldthread->arch.sp, newthread->arch.sp);
8f62167c:	e59f3028 	ldr	r3, [pc, #40]	; 8f6216ac <arch_context_switch+0x48>
8f621680:	e5932000 	ldr	r2, [r3]
8f621684:	e59d3004 	ldr	r3, [r13, #4]
8f621688:	e0332002 	eors	r2, r3, r2
8f62168c:	e3a03000 	mov	r3, #0
8f621690:	1a000004 	bne	8f6216a8 <arch_context_switch+0x44>
8f621694:	e591102c 	ldr	r1, [r1, #44]	; 0x2c
8f621698:	e280002c 	add	r0, r0, #44	; 0x2c
}
8f62169c:	e28dd00c 	add	r13, r13, #12
8f6216a0:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	arm_context_switch(&oldthread->arch.sp, newthread->arch.sp);
8f6216a4:	eafffd9d 	b	8f620d20 <arm_context_switch>
8f6216a8:	eb004544 	bl	8f632bc0 <__stack_chk_fail>
8f6216ac:	8f74221c 	.word	0x8f74221c

8f6216b0 <arm_mmu_map_section>:
	/* Set the entry value:
	 * (2<<0): Section entry
	 * (0<<5): Domain = 0
	 *  flags: TEX, CB and AP bit settings provided by the caller.
	 */
	tt[index] = (paddr & ~(MB-1)) | (0<<5) | (2<<0) | flags;
8f6216b0:	e1a00a20 	lsr	r0, r0, #20
	index = vaddr / MB;
8f6216b4:	e1a01a21 	lsr	r1, r1, #20
	tt[index] = (paddr & ~(MB-1)) | (0<<5) | (2<<0) | flags;
8f6216b8:	e3003000 	movw	r3, #0
8f6216bc:	e3483f73 	movt	r3, #36723	; 0x8f73
8f6216c0:	e1a00a00 	lsl	r0, r0, #20
8f6216c4:	e1800002 	orr	r0, r0, r2
{
8f6216c8:	e59f2040 	ldr	r2, [pc, #64]	; 8f621710 <arm_mmu_map_section+0x60>
8f6216cc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6216d0:	e24dd00c 	sub	r13, r13, #12
8f6216d4:	e5922000 	ldr	r2, [r2]
8f6216d8:	e58d2004 	str	r2, [r13, #4]
8f6216dc:	e3a02000 	mov	r2, #0
	tt[index] = (paddr & ~(MB-1)) | (0<<5) | (2<<0) | flags;
8f6216e0:	e3800002 	orr	r0, r0, #2
8f6216e4:	e7830101 	str	r0, [r3, r1, lsl #2]

	arm_invalidate_tlb();
8f6216e8:	e59f3020 	ldr	r3, [pc, #32]	; 8f621710 <arm_mmu_map_section+0x60>
8f6216ec:	e5932000 	ldr	r2, [r3]
8f6216f0:	e59d3004 	ldr	r3, [r13, #4]
8f6216f4:	e0332002 	eors	r2, r3, r2
8f6216f8:	e3a03000 	mov	r3, #0
8f6216fc:	1a000002 	bne	8f62170c <arm_mmu_map_section+0x5c>
}
8f621700:	e28dd00c 	add	r13, r13, #12
8f621704:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	arm_invalidate_tlb();
8f621708:	eafffe76 	b	8f6210e8 <arm_invalidate_tlb>
8f62170c:	eb00452b 	bl	8f632bc0 <__stack_chk_fail>
8f621710:	8f74221c 	.word	0x8f74221c

8f621714 <arm_mmu_init>:

void arm_mmu_init(void)
{
8f621714:	e59f309c 	ldr	r3, [pc, #156]	; 8f6217b8 <arm_mmu_init+0xa4>
8f621718:	e92d4070 	push	{r4, r5, r6, r14}
8f62171c:	e24dd008 	sub	r13, r13, #8
8f621720:	e5933000 	ldr	r3, [r3]
8f621724:	e58d3004 	str	r3, [r13, #4]
8f621728:	e3a03000 	mov	r3, #0
	int i;

	/* set some mmu specific control bits:
	 * access flag disabled, TEX remap disabled, mmu disabled
	 */
	arm_write_cr1(arm_read_cr1() & ~((1<<29)|(1<<28)|(1<<0)));
8f62172c:	ebfffe60 	bl	8f6210b4 <arm_read_cr1>
8f621730:	e3c00213 	bic	r0, r0, #805306369	; 0x30000001
8f621734:	ebfffe60 	bl	8f6210bc <arm_write_cr1>

	if (platform_use_identity_mmu_mappings())
8f621738:	ebff7fb2 	bl	8f601608 <platform_use_identity_mmu_mappings>
8f62173c:	e3500000 	cmp	r0, #0
8f621740:	0a00000a 	beq	8f621770 <arm_mmu_init+0x5c>
8f621744:	e3005000 	movw	r5, #0
8f621748:	e3485f73 	movt	r5, #36723	; 0x8f73
	{
		/* set up an identity-mapped translation table with
		 * strongly ordered memory type and read/write access.
		 */
		for (i=0; i < 4096; i++) {
8f62174c:	e3a04000 	mov	r4, #0
	tt[index] = (paddr & ~(MB-1)) | (0<<5) | (2<<0) | flags;
8f621750:	e3006c02 	movw	r6, #3074	; 0xc02
	index = vaddr / MB;
8f621754:	e7eb3054 	ubfx	r3, r4, #0, #12
	tt[index] = (paddr & ~(MB-1)) | (0<<5) | (2<<0) | flags;
8f621758:	e1862a04 	orr	r2, r6, r4, lsl #20
		for (i=0; i < 4096; i++) {
8f62175c:	e2844001 	add	r4, r4, #1
	tt[index] = (paddr & ~(MB-1)) | (0<<5) | (2<<0) | flags;
8f621760:	e7852103 	str	r2, [r5, r3, lsl #2]
	arm_invalidate_tlb();
8f621764:	ebfffe5f 	bl	8f6210e8 <arm_invalidate_tlb>
		for (i=0; i < 4096; i++) {
8f621768:	e3540a01 	cmp	r4, #4096	; 0x1000
8f62176c:	1afffff8 	bne	8f621754 <arm_mmu_init+0x40>
								i * MB,
								MMU_MEMORY_TYPE_STRONGLY_ORDERED | MMU_MEMORY_AP_READ_WRITE);
		}
	}

	platform_init_mmu_mappings();
8f621770:	ebff7fb5 	bl	8f60164c <platform_init_mmu_mappings>

	/* set up the translation table base */
	arm_write_ttbr((uint32_t)tt);
8f621774:	e3000000 	movw	r0, #0
8f621778:	e3480f73 	movt	r0, #36723	; 0x8f73
8f62177c:	ebfffe55 	bl	8f6210d8 <arm_write_ttbr>

	/* set up the domain access register */
	arm_write_dacr(0x00000001);
8f621780:	e3a00001 	mov	r0, #1
8f621784:	ebfffe55 	bl	8f6210e0 <arm_write_dacr>

	/* turn on the mmu */
	arm_write_cr1(arm_read_cr1() | 0x1);
8f621788:	ebfffe49 	bl	8f6210b4 <arm_read_cr1>
8f62178c:	e59f3024 	ldr	r3, [pc, #36]	; 8f6217b8 <arm_mmu_init+0xa4>
8f621790:	e5932000 	ldr	r2, [r3]
8f621794:	e59d3004 	ldr	r3, [r13, #4]
8f621798:	e0332002 	eors	r2, r3, r2
8f62179c:	e3a03000 	mov	r3, #0
8f6217a0:	1a000003 	bne	8f6217b4 <arm_mmu_init+0xa0>
8f6217a4:	e3800001 	orr	r0, r0, #1
}
8f6217a8:	e28dd008 	add	r13, r13, #8
8f6217ac:	e8bd4070 	pop	{r4, r5, r6, r14}
	arm_write_cr1(arm_read_cr1() | 0x1);
8f6217b0:	eafffe41 	b	8f6210bc <arm_write_cr1>
8f6217b4:	eb004501 	bl	8f632bc0 <__stack_chk_fail>
8f6217b8:	8f74221c 	.word	0x8f74221c

8f6217bc <arm_mmu_flush>:

void arm_mmu_flush(void)
{
8f6217bc:	e59f304c 	ldr	r3, [pc, #76]	; 8f621810 <arm_mmu_flush+0x54>
	arch_clean_cache_range((vaddr_t) &tt, sizeof(tt));
8f6217c0:	e3a01901 	mov	r1, #16384	; 0x4000
{
8f6217c4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	arch_clean_cache_range((vaddr_t) &tt, sizeof(tt));
8f6217c8:	e3000000 	movw	r0, #0
{
8f6217cc:	e24dd00c 	sub	r13, r13, #12
	arch_clean_cache_range((vaddr_t) &tt, sizeof(tt));
8f6217d0:	e3480f73 	movt	r0, #36723	; 0x8f73
{
8f6217d4:	e5933000 	ldr	r3, [r3]
8f6217d8:	e58d3004 	str	r3, [r13, #4]
8f6217dc:	e3a03000 	mov	r3, #0
	arch_clean_cache_range((vaddr_t) &tt, sizeof(tt));
8f6217e0:	ebfffde5 	bl	8f620f7c <arch_clean_cache_range>
	dsb();
8f6217e4:	f57ff04f 	dsb	sy
	isb();
8f6217e8:	f57ff06f 	isb	sy
}
8f6217ec:	e59f301c 	ldr	r3, [pc, #28]	; 8f621810 <arm_mmu_flush+0x54>
8f6217f0:	e5932000 	ldr	r2, [r3]
8f6217f4:	e59d3004 	ldr	r3, [r13, #4]
8f6217f8:	e0332002 	eors	r2, r3, r2
8f6217fc:	e3a03000 	mov	r3, #0
8f621800:	1a000001 	bne	8f62180c <arm_mmu_flush+0x50>
8f621804:	e28dd00c 	add	r13, r13, #12
8f621808:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f62180c:	eb0044eb 	bl	8f632bc0 <__stack_chk_fail>
8f621810:	8f74221c 	.word	0x8f74221c

8f621814 <arch_disable_mmu>:

void arch_disable_mmu(void)
{
8f621814:	e59f3048 	ldr	r3, [pc, #72]	; 8f621864 <arch_disable_mmu+0x50>
8f621818:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62181c:	e24dd00c 	sub	r13, r13, #12
8f621820:	e5933000 	ldr	r3, [r3]
8f621824:	e58d3004 	str	r3, [r13, #4]
8f621828:	e3a03000 	mov	r3, #0
	/* Ensure all memory access are complete
	 * before disabling MMU
	 */
	dsb();
8f62182c:	f57ff04f 	dsb	sy
	arm_write_cr1(arm_read_cr1() & ~(1<<0));
8f621830:	ebfffe1f 	bl	8f6210b4 <arm_read_cr1>
8f621834:	e3c00001 	bic	r0, r0, #1
8f621838:	ebfffe1f 	bl	8f6210bc <arm_write_cr1>
	arm_invalidate_tlb();
8f62183c:	e59f3020 	ldr	r3, [pc, #32]	; 8f621864 <arch_disable_mmu+0x50>
8f621840:	e5932000 	ldr	r2, [r3]
8f621844:	e59d3004 	ldr	r3, [r13, #4]
8f621848:	e0332002 	eors	r2, r3, r2
8f62184c:	e3a03000 	mov	r3, #0
8f621850:	1a000002 	bne	8f621860 <arch_disable_mmu+0x4c>
}
8f621854:	e28dd00c 	add	r13, r13, #12
8f621858:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	arm_invalidate_tlb();
8f62185c:	eafffe21 	b	8f6210e8 <arm_invalidate_tlb>
8f621860:	eb0044d6 	bl	8f632bc0 <__stack_chk_fail>
8f621864:	8f74221c 	.word	0x8f74221c

8f621868 <platform_map_fb>:
__WEAK void platform_init_mmu_mappings(void)
{
}

__WEAK addr_t platform_map_fb(addr_t phys_addr, uint32_t size)
{
8f621868:	e59f3034 	ldr	r3, [pc, #52]	; 8f6218a4 <platform_map_fb+0x3c>
8f62186c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621870:	e24dd00c 	sub	r13, r13, #12
8f621874:	e5933000 	ldr	r3, [r3]
8f621878:	e58d3004 	str	r3, [r13, #4]
8f62187c:	e3a03000 	mov	r3, #0
	return phys_addr;
}
8f621880:	e59f301c 	ldr	r3, [pc, #28]	; 8f6218a4 <platform_map_fb+0x3c>
8f621884:	e5932000 	ldr	r2, [r3]
8f621888:	e59d3004 	ldr	r3, [r13, #4]
8f62188c:	e0332002 	eors	r2, r3, r2
8f621890:	e3a03000 	mov	r3, #0
8f621894:	1a000001 	bne	8f6218a0 <platform_map_fb+0x38>
8f621898:	e28dd00c 	add	r13, r13, #12
8f62189c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6218a0:	eb0044c6 	bl	8f632bc0 <__stack_chk_fail>
8f6218a4:	8f74221c 	.word	0x8f74221c

8f6218a8 <clock_config_cdc>:
{
	return 0;
}

__WEAK void clock_config_cdc(uint32_t slot)
{
8f6218a8:	e59f3034 	ldr	r3, [pc, #52]	; 8f6218e4 <clock_config_cdc+0x3c>
8f6218ac:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6218b0:	e24dd00c 	sub	r13, r13, #12
8f6218b4:	e5933000 	ldr	r3, [r3]
8f6218b8:	e58d3004 	str	r3, [r13, #4]
8f6218bc:	e3a03000 	mov	r3, #0

}
8f6218c0:	e59f301c 	ldr	r3, [pc, #28]	; 8f6218e4 <clock_config_cdc+0x3c>
8f6218c4:	e5932000 	ldr	r2, [r3]
8f6218c8:	e59d3004 	ldr	r3, [r13, #4]
8f6218cc:	e0332002 	eors	r2, r3, r2
8f6218d0:	e3a03000 	mov	r3, #0
8f6218d4:	1a000001 	bne	8f6218e0 <clock_config_cdc+0x38>
8f6218d8:	e28dd00c 	add	r13, r13, #12
8f6218dc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6218e0:	eb0044b6 	bl	8f632bc0 <__stack_chk_fail>
8f6218e4:	8f74221c 	.word	0x8f74221c

8f6218e8 <platform_boot_dev_isemmc>:
{
	return (uint32_t)MSM_SHARED_BASE;
}

__WEAK uint32_t platform_boot_dev_isemmc()
{
8f6218e8:	e59f3038 	ldr	r3, [pc, #56]	; 8f621928 <platform_boot_dev_isemmc+0x40>
8f6218ec:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6218f0:	e24dd00c 	sub	r13, r13, #12
8f6218f4:	e5933000 	ldr	r3, [r3]
8f6218f8:	e58d3004 	str	r3, [r13, #4]
8f6218fc:	e3a03000 	mov	r3, #0
        return 1;
}
8f621900:	e59f3020 	ldr	r3, [pc, #32]	; 8f621928 <platform_boot_dev_isemmc+0x40>
8f621904:	e5932000 	ldr	r2, [r3]
8f621908:	e59d3004 	ldr	r3, [r13, #4]
8f62190c:	e0332002 	eors	r2, r3, r2
8f621910:	e3a03000 	mov	r3, #0
8f621914:	1a000002 	bne	8f621924 <platform_boot_dev_isemmc+0x3c>
8f621918:	e3a00001 	mov	r0, #1
8f62191c:	e28dd00c 	add	r13, r13, #12
8f621920:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f621924:	eb0044a5 	bl	8f632bc0 <__stack_chk_fail>
8f621928:	8f74221c 	.word	0x8f74221c

8f62192c <platform_get_boot_dev>:
8f62192c:	e59f3038 	ldr	r3, [pc, #56]	; 8f62196c <platform_get_boot_dev+0x40>
8f621930:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621934:	e24dd00c 	sub	r13, r13, #12
8f621938:	e5933000 	ldr	r3, [r3]
8f62193c:	e58d3004 	str	r3, [r13, #4]
8f621940:	e3a03000 	mov	r3, #0
8f621944:	e59f3020 	ldr	r3, [pc, #32]	; 8f62196c <platform_get_boot_dev+0x40>
8f621948:	e5932000 	ldr	r2, [r3]
8f62194c:	e59d3004 	ldr	r3, [r13, #4]
8f621950:	e0332002 	eors	r2, r3, r2
8f621954:	e3a03000 	mov	r3, #0
8f621958:	1a000002 	bne	8f621968 <platform_get_boot_dev+0x3c>
8f62195c:	e3a00000 	mov	r0, #0
8f621960:	e28dd00c 	add	r13, r13, #12
8f621964:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f621968:	eb004494 	bl	8f632bc0 <__stack_chk_fail>
8f62196c:	8f74221c 	.word	0x8f74221c

8f621970 <platform_detect_panel>:
{
	return ((val & 0x3E) >> 1);
}

__WEAK uint32_t platform_detect_panel()
{
8f621970:	e59f3038 	ldr	r3, [pc, #56]	; 8f6219b0 <platform_detect_panel+0x40>
8f621974:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621978:	e24dd00c 	sub	r13, r13, #12
8f62197c:	e5933000 	ldr	r3, [r3]
8f621980:	e58d3004 	str	r3, [r13, #4]
8f621984:	e3a03000 	mov	r3, #0
	return 0;
}
8f621988:	e59f3020 	ldr	r3, [pc, #32]	; 8f6219b0 <platform_detect_panel+0x40>
8f62198c:	e5932000 	ldr	r2, [r3]
8f621990:	e59d3004 	ldr	r3, [r13, #4]
8f621994:	e0332002 	eors	r2, r3, r2
8f621998:	e3a03000 	mov	r3, #0
8f62199c:	1a000002 	bne	8f6219ac <platform_detect_panel+0x3c>
8f6219a0:	e3a00000 	mov	r0, #0
8f6219a4:	e28dd00c 	add	r13, r13, #12
8f6219a8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6219ac:	eb004483 	bl	8f632bc0 <__stack_chk_fail>
8f6219b0:	8f74221c 	.word	0x8f74221c

8f6219b4 <read_der_message_length>:
}

/* This function definition should not be used if VERIFIED_BOOT
is enabled. And this is expected to be called only for MDM Targets */
__WEAK uint32_t read_der_message_length(unsigned char* input, unsigned sz)
{
8f6219b4:	e59f3038 	ldr	r3, [pc, #56]	; 8f6219f4 <read_der_message_length+0x40>
8f6219b8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6219bc:	e24dd00c 	sub	r13, r13, #12
8f6219c0:	e5933000 	ldr	r3, [r3]
8f6219c4:	e58d3004 	str	r3, [r13, #4]
8f6219c8:	e3a03000 	mov	r3, #0
	return SIGNATURE_SIZE;
}
8f6219cc:	e59f3020 	ldr	r3, [pc, #32]	; 8f6219f4 <read_der_message_length+0x40>
8f6219d0:	e5932000 	ldr	r2, [r3]
8f6219d4:	e59d3004 	ldr	r3, [r13, #4]
8f6219d8:	e0332002 	eors	r2, r3, r2
8f6219dc:	e3a03000 	mov	r3, #0
8f6219e0:	1a000002 	bne	8f6219f0 <read_der_message_length+0x3c>
8f6219e4:	e3a00c01 	mov	r0, #256	; 0x100
8f6219e8:	e28dd00c 	add	r13, r13, #12
8f6219ec:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6219f0:	eb004472 	bl	8f632bc0 <__stack_chk_fail>
8f6219f4:	8f74221c 	.word	0x8f74221c

8f6219f8 <flash_ubi_img>:
8f6219f8:	e59f3038 	ldr	r3, [pc, #56]	; 8f621a38 <flash_ubi_img+0x40>
8f6219fc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621a00:	e24dd00c 	sub	r13, r13, #12
8f621a04:	e5933000 	ldr	r3, [r3]
8f621a08:	e58d3004 	str	r3, [r13, #4]
8f621a0c:	e3a03000 	mov	r3, #0
8f621a10:	e59f3020 	ldr	r3, [pc, #32]	; 8f621a38 <flash_ubi_img+0x40>
8f621a14:	e5932000 	ldr	r2, [r3]
8f621a18:	e59d3004 	ldr	r3, [r13, #4]
8f621a1c:	e0332002 	eors	r2, r3, r2
8f621a20:	e3a03000 	mov	r3, #0
8f621a24:	1a000002 	bne	8f621a34 <flash_ubi_img+0x3c>
8f621a28:	e3a00000 	mov	r0, #0
8f621a2c:	e28dd00c 	add	r13, r13, #12
8f621a30:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f621a34:	eb004461 	bl	8f632bc0 <__stack_chk_fail>
8f621a38:	8f74221c 	.word	0x8f74221c

8f621a3c <update_ubi_vol>:
8f621a3c:	e59f3038 	ldr	r3, [pc, #56]	; 8f621a7c <update_ubi_vol+0x40>
8f621a40:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621a44:	e24dd00c 	sub	r13, r13, #12
8f621a48:	e5933000 	ldr	r3, [r3]
8f621a4c:	e58d3004 	str	r3, [r13, #4]
8f621a50:	e3a03000 	mov	r3, #0
8f621a54:	e59f3020 	ldr	r3, [pc, #32]	; 8f621a7c <update_ubi_vol+0x40>
8f621a58:	e5932000 	ldr	r2, [r3]
8f621a5c:	e59d3004 	ldr	r3, [r13, #4]
8f621a60:	e0332002 	eors	r2, r3, r2
8f621a64:	e3a03000 	mov	r3, #0
8f621a68:	1a000002 	bne	8f621a78 <update_ubi_vol+0x3c>
8f621a6c:	e3a00000 	mov	r0, #0
8f621a70:	e28dd00c 	add	r13, r13, #12
8f621a74:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f621a78:	eb004450 	bl	8f632bc0 <__stack_chk_fail>
8f621a7c:	8f74221c 	.word	0x8f74221c

8f621a80 <target_is_emmc_boot>:
{
    return 0;
}

__WEAK int target_is_emmc_boot(void)
{
8f621a80:	e59f3038 	ldr	r3, [pc, #56]	; 8f621ac0 <target_is_emmc_boot+0x40>
8f621a84:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621a88:	e24dd00c 	sub	r13, r13, #12
8f621a8c:	e5933000 	ldr	r3, [r3]
8f621a90:	e58d3004 	str	r3, [r13, #4]
8f621a94:	e3a03000 	mov	r3, #0
#if _EMMC_BOOT
    return 1;
#else
    return 0;
#endif
}
8f621a98:	e59f3020 	ldr	r3, [pc, #32]	; 8f621ac0 <target_is_emmc_boot+0x40>
8f621a9c:	e5932000 	ldr	r2, [r3]
8f621aa0:	e59d3004 	ldr	r3, [r13, #4]
8f621aa4:	e0332002 	eors	r2, r3, r2
8f621aa8:	e3a03000 	mov	r3, #0
8f621aac:	1a000002 	bne	8f621abc <target_is_emmc_boot+0x3c>
8f621ab0:	e3a00001 	mov	r0, #1
8f621ab4:	e28dd00c 	add	r13, r13, #12
8f621ab8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f621abc:	eb00443f 	bl	8f632bc0 <__stack_chk_fail>
8f621ac0:	8f74221c 	.word	0x8f74221c

8f621ac4 <target_use_signed_kernel>:
8f621ac4:	e59f3038 	ldr	r3, [pc, #56]	; 8f621b04 <target_use_signed_kernel+0x40>
8f621ac8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621acc:	e24dd00c 	sub	r13, r13, #12
8f621ad0:	e5933000 	ldr	r3, [r3]
8f621ad4:	e58d3004 	str	r3, [r13, #4]
8f621ad8:	e3a03000 	mov	r3, #0
8f621adc:	e59f3020 	ldr	r3, [pc, #32]	; 8f621b04 <target_use_signed_kernel+0x40>
8f621ae0:	e5932000 	ldr	r2, [r3]
8f621ae4:	e59d3004 	ldr	r3, [r13, #4]
8f621ae8:	e0332002 	eors	r2, r3, r2
8f621aec:	e3a03000 	mov	r3, #0
8f621af0:	1a000002 	bne	8f621b00 <target_use_signed_kernel+0x3c>
8f621af4:	e3a00000 	mov	r0, #0
8f621af8:	e28dd00c 	add	r13, r13, #12
8f621afc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f621b00:	eb00442e 	bl	8f632bc0 <__stack_chk_fail>
8f621b04:	8f74221c 	.word	0x8f74221c

8f621b08 <target_is_ssd_enabled>:
8f621b08:	e59f3038 	ldr	r3, [pc, #56]	; 8f621b48 <target_is_ssd_enabled+0x40>
8f621b0c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621b10:	e24dd00c 	sub	r13, r13, #12
8f621b14:	e5933000 	ldr	r3, [r3]
8f621b18:	e58d3004 	str	r3, [r13, #4]
8f621b1c:	e3a03000 	mov	r3, #0
8f621b20:	e59f3020 	ldr	r3, [pc, #32]	; 8f621b48 <target_is_ssd_enabled+0x40>
8f621b24:	e5932000 	ldr	r2, [r3]
8f621b28:	e59d3004 	ldr	r3, [r13, #4]
8f621b2c:	e0332002 	eors	r2, r3, r2
8f621b30:	e3a03000 	mov	r3, #0
8f621b34:	1a000002 	bne	8f621b44 <target_is_ssd_enabled+0x3c>
8f621b38:	e3a00001 	mov	r0, #1
8f621b3c:	e28dd00c 	add	r13, r13, #12
8f621b40:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f621b44:	eb00441d 	bl	8f632bc0 <__stack_chk_fail>
8f621b48:	8f74221c 	.word	0x8f74221c

8f621b4c <target_usb_init>:
8f621b4c:	e59f3034 	ldr	r3, [pc, #52]	; 8f621b88 <target_usb_init+0x3c>
8f621b50:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621b54:	e24dd00c 	sub	r13, r13, #12
8f621b58:	e5933000 	ldr	r3, [r3]
8f621b5c:	e58d3004 	str	r3, [r13, #4]
8f621b60:	e3a03000 	mov	r3, #0
8f621b64:	e59f301c 	ldr	r3, [pc, #28]	; 8f621b88 <target_usb_init+0x3c>
8f621b68:	e5932000 	ldr	r2, [r3]
8f621b6c:	e59d3004 	ldr	r3, [r13, #4]
8f621b70:	e0332002 	eors	r2, r3, r2
8f621b74:	e3a03000 	mov	r3, #0
8f621b78:	1a000001 	bne	8f621b84 <target_usb_init+0x38>
8f621b7c:	e28dd00c 	add	r13, r13, #12
8f621b80:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f621b84:	eb00440d 	bl	8f632bc0 <__stack_chk_fail>
8f621b88:	8f74221c 	.word	0x8f74221c

8f621b8c <target_usb_stop>:
8f621b8c:	e59f3034 	ldr	r3, [pc, #52]	; 8f621bc8 <target_usb_stop+0x3c>
8f621b90:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621b94:	e24dd00c 	sub	r13, r13, #12
8f621b98:	e5933000 	ldr	r3, [r3]
8f621b9c:	e58d3004 	str	r3, [r13, #4]
8f621ba0:	e3a03000 	mov	r3, #0
8f621ba4:	e59f301c 	ldr	r3, [pc, #28]	; 8f621bc8 <target_usb_stop+0x3c>
8f621ba8:	e5932000 	ldr	r2, [r3]
8f621bac:	e59d3004 	ldr	r3, [r13, #4]
8f621bb0:	e0332002 	eors	r2, r3, r2
8f621bb4:	e3a03000 	mov	r3, #0
8f621bb8:	1a000001 	bne	8f621bc4 <target_usb_stop+0x38>
8f621bbc:	e28dd00c 	add	r13, r13, #12
8f621bc0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f621bc4:	eb0043fd 	bl	8f632bc0 <__stack_chk_fail>
8f621bc8:	8f74221c 	.word	0x8f74221c

8f621bcc <target_display_shutdown>:
8f621bcc:	e59f3034 	ldr	r3, [pc, #52]	; 8f621c08 <target_display_shutdown+0x3c>
8f621bd0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621bd4:	e24dd00c 	sub	r13, r13, #12
8f621bd8:	e5933000 	ldr	r3, [r3]
8f621bdc:	e58d3004 	str	r3, [r13, #4]
8f621be0:	e3a03000 	mov	r3, #0
8f621be4:	e59f301c 	ldr	r3, [pc, #28]	; 8f621c08 <target_display_shutdown+0x3c>
8f621be8:	e5932000 	ldr	r2, [r3]
8f621bec:	e59d3004 	ldr	r3, [r13, #4]
8f621bf0:	e0332002 	eors	r2, r3, r2
8f621bf4:	e3a03000 	mov	r3, #0
8f621bf8:	1a000001 	bne	8f621c04 <target_display_shutdown+0x38>
8f621bfc:	e28dd00c 	add	r13, r13, #12
8f621c00:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f621c04:	eb0043ed 	bl	8f632bc0 <__stack_chk_fail>
8f621c08:	8f74221c 	.word	0x8f74221c

8f621c0c <target_get_hlos_subtype>:
8f621c0c:	e59f3038 	ldr	r3, [pc, #56]	; 8f621c4c <target_get_hlos_subtype+0x40>
8f621c10:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621c14:	e24dd00c 	sub	r13, r13, #12
8f621c18:	e5933000 	ldr	r3, [r3]
8f621c1c:	e58d3004 	str	r3, [r13, #4]
8f621c20:	e3a03000 	mov	r3, #0
8f621c24:	e59f3020 	ldr	r3, [pc, #32]	; 8f621c4c <target_get_hlos_subtype+0x40>
8f621c28:	e5932000 	ldr	r2, [r3]
8f621c2c:	e59d3004 	ldr	r3, [r13, #4]
8f621c30:	e0332002 	eors	r2, r3, r2
8f621c34:	e3a03000 	mov	r3, #0
8f621c38:	1a000002 	bne	8f621c48 <target_get_hlos_subtype+0x3c>
8f621c3c:	e3a00000 	mov	r0, #0
8f621c40:	e28dd00c 	add	r13, r13, #12
8f621c44:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f621c48:	eb0043dc 	bl	8f632bc0 <__stack_chk_fail>
8f621c4c:	8f74221c 	.word	0x8f74221c

8f621c50 <target_is_pmi_enabled>:
8f621c50:	e59f3038 	ldr	r3, [pc, #56]	; 8f621c90 <target_is_pmi_enabled+0x40>
8f621c54:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621c58:	e24dd00c 	sub	r13, r13, #12
8f621c5c:	e5933000 	ldr	r3, [r3]
8f621c60:	e58d3004 	str	r3, [r13, #4]
8f621c64:	e3a03000 	mov	r3, #0
8f621c68:	e59f3020 	ldr	r3, [pc, #32]	; 8f621c90 <target_is_pmi_enabled+0x40>
8f621c6c:	e5932000 	ldr	r2, [r3]
8f621c70:	e59d3004 	ldr	r3, [r13, #4]
8f621c74:	e0332002 	eors	r2, r3, r2
8f621c78:	e3a03000 	mov	r3, #0
8f621c7c:	1a000002 	bne	8f621c8c <target_is_pmi_enabled+0x3c>
8f621c80:	e3a00001 	mov	r0, #1
8f621c84:	e28dd00c 	add	r13, r13, #12
8f621c88:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f621c8c:	eb0043cb 	bl	8f632bc0 <__stack_chk_fail>
8f621c90:	8f74221c 	.word	0x8f74221c

8f621c94 <target_ddr_cfg_val>:
	return 1;
}

/* Default CFG delay value */
__WEAK uint32_t target_ddr_cfg_val()
{
8f621c94:	e59f303c 	ldr	r3, [pc, #60]	; 8f621cd8 <target_ddr_cfg_val+0x44>
8f621c98:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621c9c:	e24dd00c 	sub	r13, r13, #12
8f621ca0:	e5933000 	ldr	r3, [r3]
8f621ca4:	e58d3004 	str	r3, [r13, #4]
8f621ca8:	e3a03000 	mov	r3, #0
	return DDR_CONFIG_VAL;
}
8f621cac:	e59f3024 	ldr	r3, [pc, #36]	; 8f621cd8 <target_ddr_cfg_val+0x44>
8f621cb0:	e5932000 	ldr	r2, [r3]
8f621cb4:	e59d3004 	ldr	r3, [r13, #4]
8f621cb8:	e0332002 	eors	r2, r3, r2
8f621cbc:	e3a03000 	mov	r3, #0
8f621cc0:	1a000003 	bne	8f621cd4 <target_ddr_cfg_val+0x40>
8f621cc4:	e3000853 	movw	r0, #2131	; 0x853
8f621cc8:	e3480004 	movt	r0, #32772	; 0x8004
8f621ccc:	e28dd00c 	add	r13, r13, #12
8f621cd0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f621cd4:	eb0043b9 	bl	8f632bc0 <__stack_chk_fail>
8f621cd8:	8f74221c 	.word	0x8f74221c

8f621cdc <target_ddr_cfg_reg>:
		return false;
}

/* Default CFG register value */
uint32_t target_ddr_cfg_reg()
{
8f621cdc:	e59f31d0 	ldr	r3, [pc, #464]	; 8f621eb4 <target_ddr_cfg_reg+0x1d8>
8f621ce0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621ce4:	e24dd00c 	sub	r13, r13, #12
8f621ce8:	e5933000 	ldr	r3, [r3]
8f621cec:	e58d3004 	str	r3, [r13, #4]
8f621cf0:	e3a03000 	mov	r3, #0
	uint32_t platform = board_platform_id();
8f621cf4:	ebffb934 	bl	8f6101cc <board_platform_id>
	uint32_t ret = SDCC_HC_REG_DDR_CONFIG;

	switch(platform)
8f621cf8:	e2400f49 	sub	r0, r0, #292	; 0x124
8f621cfc:	e2400001 	sub	r0, r0, #1
8f621d00:	e350005d 	cmp	r0, #93	; 0x5d
8f621d04:	979ff100 	ldrls	r15, [r15, r0, lsl #2]
8f621d08:	ea00005d 	b	8f621e84 <target_ddr_cfg_reg+0x1a8>
8f621d0c:	8f621ea8 	.word	0x8f621ea8
8f621d10:	8f621ea8 	.word	0x8f621ea8
8f621d14:	8f621ea8 	.word	0x8f621ea8
8f621d18:	8f621e84 	.word	0x8f621e84
8f621d1c:	8f621e84 	.word	0x8f621e84
8f621d20:	8f621e84 	.word	0x8f621e84
8f621d24:	8f621e84 	.word	0x8f621e84
8f621d28:	8f621e84 	.word	0x8f621e84
8f621d2c:	8f621e84 	.word	0x8f621e84
8f621d30:	8f621e84 	.word	0x8f621e84
8f621d34:	8f621ea8 	.word	0x8f621ea8
8f621d38:	8f621ea8 	.word	0x8f621ea8
8f621d3c:	8f621e84 	.word	0x8f621e84
8f621d40:	8f621e84 	.word	0x8f621e84
8f621d44:	8f621ea8 	.word	0x8f621ea8
8f621d48:	8f621ea8 	.word	0x8f621ea8
8f621d4c:	8f621ea8 	.word	0x8f621ea8
8f621d50:	8f621e84 	.word	0x8f621e84
8f621d54:	8f621e84 	.word	0x8f621e84
8f621d58:	8f621e84 	.word	0x8f621e84
8f621d5c:	8f621ea8 	.word	0x8f621ea8
8f621d60:	8f621e84 	.word	0x8f621e84
8f621d64:	8f621e84 	.word	0x8f621e84
8f621d68:	8f621e84 	.word	0x8f621e84
8f621d6c:	8f621e84 	.word	0x8f621e84
8f621d70:	8f621e84 	.word	0x8f621e84
8f621d74:	8f621e84 	.word	0x8f621e84
8f621d78:	8f621ea8 	.word	0x8f621ea8
8f621d7c:	8f621e84 	.word	0x8f621e84
8f621d80:	8f621e84 	.word	0x8f621e84
8f621d84:	8f621e84 	.word	0x8f621e84
8f621d88:	8f621e84 	.word	0x8f621e84
8f621d8c:	8f621e84 	.word	0x8f621e84
8f621d90:	8f621e84 	.word	0x8f621e84
8f621d94:	8f621e84 	.word	0x8f621e84
8f621d98:	8f621e84 	.word	0x8f621e84
8f621d9c:	8f621e84 	.word	0x8f621e84
8f621da0:	8f621e84 	.word	0x8f621e84
8f621da4:	8f621e84 	.word	0x8f621e84
8f621da8:	8f621e84 	.word	0x8f621e84
8f621dac:	8f621e84 	.word	0x8f621e84
8f621db0:	8f621e84 	.word	0x8f621e84
8f621db4:	8f621e84 	.word	0x8f621e84
8f621db8:	8f621e84 	.word	0x8f621e84
8f621dbc:	8f621e84 	.word	0x8f621e84
8f621dc0:	8f621ea8 	.word	0x8f621ea8
8f621dc4:	8f621e84 	.word	0x8f621e84
8f621dc8:	8f621e84 	.word	0x8f621e84
8f621dcc:	8f621e84 	.word	0x8f621e84
8f621dd0:	8f621e84 	.word	0x8f621e84
8f621dd4:	8f621e84 	.word	0x8f621e84
8f621dd8:	8f621e84 	.word	0x8f621e84
8f621ddc:	8f621e84 	.word	0x8f621e84
8f621de0:	8f621e84 	.word	0x8f621e84
8f621de4:	8f621e84 	.word	0x8f621e84
8f621de8:	8f621e84 	.word	0x8f621e84
8f621dec:	8f621ea8 	.word	0x8f621ea8
8f621df0:	8f621ea8 	.word	0x8f621ea8
8f621df4:	8f621ea8 	.word	0x8f621ea8
8f621df8:	8f621e84 	.word	0x8f621e84
8f621dfc:	8f621ea8 	.word	0x8f621ea8
8f621e00:	8f621ea8 	.word	0x8f621ea8
8f621e04:	8f621e84 	.word	0x8f621e84
8f621e08:	8f621e84 	.word	0x8f621e84
8f621e0c:	8f621e84 	.word	0x8f621e84
8f621e10:	8f621e84 	.word	0x8f621e84
8f621e14:	8f621e84 	.word	0x8f621e84
8f621e18:	8f621e84 	.word	0x8f621e84
8f621e1c:	8f621e84 	.word	0x8f621e84
8f621e20:	8f621e84 	.word	0x8f621e84
8f621e24:	8f621ea8 	.word	0x8f621ea8
8f621e28:	8f621ea8 	.word	0x8f621ea8
8f621e2c:	8f621e84 	.word	0x8f621e84
8f621e30:	8f621e84 	.word	0x8f621e84
8f621e34:	8f621e84 	.word	0x8f621e84
8f621e38:	8f621e84 	.word	0x8f621e84
8f621e3c:	8f621e84 	.word	0x8f621e84
8f621e40:	8f621e84 	.word	0x8f621e84
8f621e44:	8f621e84 	.word	0x8f621e84
8f621e48:	8f621e84 	.word	0x8f621e84
8f621e4c:	8f621e84 	.word	0x8f621e84
8f621e50:	8f621e84 	.word	0x8f621e84
8f621e54:	8f621e84 	.word	0x8f621e84
8f621e58:	8f621e84 	.word	0x8f621e84
8f621e5c:	8f621e84 	.word	0x8f621e84
8f621e60:	8f621e84 	.word	0x8f621e84
8f621e64:	8f621e84 	.word	0x8f621e84
8f621e68:	8f621e84 	.word	0x8f621e84
8f621e6c:	8f621e84 	.word	0x8f621e84
8f621e70:	8f621e84 	.word	0x8f621e84
8f621e74:	8f621e84 	.word	0x8f621e84
8f621e78:	8f621e84 	.word	0x8f621e84
8f621e7c:	8f621e84 	.word	0x8f621e84
8f621e80:	8f621ea8 	.word	0x8f621ea8
	uint32_t ret = SDCC_HC_REG_DDR_CONFIG;
8f621e84:	e3a00f6e 	mov	r0, #440	; 0x1b8
			break;
		default:
			break;
	}
	return ret;
}
8f621e88:	e59f3024 	ldr	r3, [pc, #36]	; 8f621eb4 <target_ddr_cfg_reg+0x1d8>
8f621e8c:	e5932000 	ldr	r2, [r3]
8f621e90:	e59d3004 	ldr	r3, [r13, #4]
8f621e94:	e0332002 	eors	r2, r3, r2
8f621e98:	e3a03000 	mov	r3, #0
8f621e9c:	1a000003 	bne	8f621eb0 <target_ddr_cfg_reg+0x1d4>
8f621ea0:	e28dd00c 	add	r13, r13, #12
8f621ea4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	switch(platform)
8f621ea8:	e3a00f6f 	mov	r0, #444	; 0x1bc
8f621eac:	eafffff5 	b	8f621e88 <target_ddr_cfg_reg+0x1ac>
}
8f621eb0:	eb004342 	bl	8f632bc0 <__stack_chk_fail>
8f621eb4:	8f74221c 	.word	0x8f74221c

8f621eb8 <target_get_vb_version>:
	}
	return vb_version;
}
#else
int target_get_vb_version()
{
8f621eb8:	e59f3038 	ldr	r3, [pc, #56]	; 8f621ef8 <target_get_vb_version+0x40>
8f621ebc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f621ec0:	e24dd00c 	sub	r13, r13, #12
8f621ec4:	e5933000 	ldr	r3, [r3]
8f621ec8:	e58d3004 	str	r3, [r13, #4]
8f621ecc:	e3a03000 	mov	r3, #0
	return vb_version;
}
8f621ed0:	e59f3020 	ldr	r3, [pc, #32]	; 8f621ef8 <target_get_vb_version+0x40>
8f621ed4:	e5932000 	ldr	r2, [r3]
8f621ed8:	e59d3004 	ldr	r3, [r13, #4]
8f621edc:	e0332002 	eors	r2, r3, r2
8f621ee0:	e3a03000 	mov	r3, #0
8f621ee4:	1a000002 	bne	8f621ef4 <target_get_vb_version+0x3c>
8f621ee8:	e3e00000 	mvn	r0, #0
8f621eec:	e28dd00c 	add	r13, r13, #12
8f621ef0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f621ef4:	eb004331 	bl	8f632bc0 <__stack_chk_fail>
8f621ef8:	8f74221c 	.word	0x8f74221c

8f621efc <get_vibration_type>:
	return 0;
}

#if PON_VIB_SUPPORT
void get_vibration_type(struct qpnp_hap *config)
{
8f621efc:	e59f32d8 	ldr	r3, [pc, #728]	; 8f6221dc <get_vibration_type+0x2e0>
8f621f00:	e92d4030 	push	{r4, r5, r14}
8f621f04:	e24dd00c 	sub	r13, r13, #12
8f621f08:	e1a04000 	mov	r4, r0
8f621f0c:	e5933000 	ldr	r3, [r3]
8f621f10:	e58d3004 	str	r3, [r13, #4]
8f621f14:	e3a03000 	mov	r3, #0
	uint32_t hw_id = board_hardware_id();
8f621f18:	ebffb8d1 	bl	8f610264 <board_hardware_id>
8f621f1c:	e1a05000 	mov	r5, r0
	uint32_t platform = board_platform_id();
8f621f20:	ebffb8a9 	bl	8f6101cc <board_platform_id>

	config->vib_type = VIB_ERM_TYPE;
	config->hap_rate_cfg1 = QPNP_HAP_RATE_CFG1_1c;
	config->hap_rate_cfg2 = QPNP_HAP_RATE_CFG2_04;
	switch(hw_id){
8f621f24:	e3550008 	cmp	r5, #8
	config->hap_rate_cfg1 = QPNP_HAP_RATE_CFG1_1c;
8f621f28:	e3a0301c 	mov	r3, #28
	config->vib_type = VIB_ERM_TYPE;
8f621f2c:	e3a02001 	mov	r2, #1
	config->hap_rate_cfg1 = QPNP_HAP_RATE_CFG1_1c;
8f621f30:	e5c43000 	strb	r3, [r4]
	config->vib_type = VIB_ERM_TYPE;
8f621f34:	e5c42002 	strb	r2, [r4, #2]
	config->hap_rate_cfg2 = QPNP_HAP_RATE_CFG2_04;
8f621f38:	e3a03004 	mov	r3, #4
8f621f3c:	e5c43001 	strb	r3, [r4, #1]
	switch(hw_id){
8f621f40:	0a000016 	beq	8f621fa0 <get_vibration_type+0xa4>
8f621f44:	e355000b 	cmp	r5, #11
8f621f48:	0a00000c 	beq	8f621f80 <get_vibration_type+0x84>
		break;
	case HW_PLATFORM_QRD:
		config->vib_type = VIB_ERM_TYPE;
		break;
	default:
		dprintf(CRITICAL,"Unsupported hardware id\n");
8f621f4c:	e59f3288 	ldr	r3, [pc, #648]	; 8f6221dc <get_vibration_type+0x2e0>
8f621f50:	e5932000 	ldr	r2, [r3]
8f621f54:	e59d3004 	ldr	r3, [r13, #4]
8f621f58:	e0332002 	eors	r2, r3, r2
8f621f5c:	e3a03000 	mov	r3, #0
8f621f60:	03070a48 	movweq	r0, #31304	; 0x7a48
8f621f64:	03480f70 	movteq	r0, #36720	; 0x8f70
8f621f68:	1a000093 	bne	8f6221bc <get_vibration_type+0x2c0>
		break;
	}
}
8f621f6c:	e28dd00c 	add	r13, r13, #12
8f621f70:	e8bd4030 	pop	{r4, r5, r14}
		dprintf(CRITICAL,"Unsupported hardware id\n");
8f621f74:	ea00427e 	b	8f632974 <_dprintf>
			config->vib_type = VIB_LRA_TYPE;
8f621f78:	e3a03000 	mov	r3, #0
8f621f7c:	e5c43002 	strb	r3, [r4, #2]
}
8f621f80:	e59f3254 	ldr	r3, [pc, #596]	; 8f6221dc <get_vibration_type+0x2e0>
8f621f84:	e5932000 	ldr	r2, [r3]
8f621f88:	e59d3004 	ldr	r3, [r13, #4]
8f621f8c:	e0332002 	eors	r2, r3, r2
8f621f90:	e3a03000 	mov	r3, #0
8f621f94:	1a000088 	bne	8f6221bc <get_vibration_type+0x2c0>
8f621f98:	e28dd00c 	add	r13, r13, #12
8f621f9c:	e8bd8030 	pop	{r4, r5, r15}
		switch(platform){
8f621fa0:	e2400f42 	sub	r0, r0, #264	; 0x108
8f621fa4:	e350007a 	cmp	r0, #122	; 0x7a
8f621fa8:	979ff100 	ldrls	r15, [r15, r0, lsl #2]
8f621fac:	ea00007a 	b	8f62219c <get_vibration_type+0x2a0>
8f621fb0:	8f621f80 	.word	0x8f621f80
8f621fb4:	8f62219c 	.word	0x8f62219c
8f621fb8:	8f621f78 	.word	0x8f621f78
8f621fbc:	8f62219c 	.word	0x8f62219c
8f621fc0:	8f62219c 	.word	0x8f62219c
8f621fc4:	8f62219c 	.word	0x8f62219c
8f621fc8:	8f62219c 	.word	0x8f62219c
8f621fcc:	8f62219c 	.word	0x8f62219c
8f621fd0:	8f62219c 	.word	0x8f62219c
8f621fd4:	8f62219c 	.word	0x8f62219c
8f621fd8:	8f621f78 	.word	0x8f621f78
8f621fdc:	8f62219c 	.word	0x8f62219c
8f621fe0:	8f62219c 	.word	0x8f62219c
8f621fe4:	8f62219c 	.word	0x8f62219c
8f621fe8:	8f621f78 	.word	0x8f621f78
8f621fec:	8f62219c 	.word	0x8f62219c
8f621ff0:	8f62219c 	.word	0x8f62219c
8f621ff4:	8f62219c 	.word	0x8f62219c
8f621ff8:	8f62219c 	.word	0x8f62219c
8f621ffc:	8f62219c 	.word	0x8f62219c
8f622000:	8f62219c 	.word	0x8f62219c
8f622004:	8f62219c 	.word	0x8f62219c
8f622008:	8f62219c 	.word	0x8f62219c
8f62200c:	8f62219c 	.word	0x8f62219c
8f622010:	8f62219c 	.word	0x8f62219c
8f622014:	8f62219c 	.word	0x8f62219c
8f622018:	8f62219c 	.word	0x8f62219c
8f62201c:	8f62219c 	.word	0x8f62219c
8f622020:	8f62219c 	.word	0x8f62219c
8f622024:	8f6221c0 	.word	0x8f6221c0
8f622028:	8f6221c0 	.word	0x8f6221c0
8f62202c:	8f6221c0 	.word	0x8f6221c0
8f622030:	8f62219c 	.word	0x8f62219c
8f622034:	8f62219c 	.word	0x8f62219c
8f622038:	8f62219c 	.word	0x8f62219c
8f62203c:	8f62219c 	.word	0x8f62219c
8f622040:	8f62219c 	.word	0x8f62219c
8f622044:	8f62219c 	.word	0x8f62219c
8f622048:	8f62219c 	.word	0x8f62219c
8f62204c:	8f6221c0 	.word	0x8f6221c0
8f622050:	8f6221c0 	.word	0x8f6221c0
8f622054:	8f62219c 	.word	0x8f62219c
8f622058:	8f62219c 	.word	0x8f62219c
8f62205c:	8f6221c0 	.word	0x8f6221c0
8f622060:	8f6221c0 	.word	0x8f6221c0
8f622064:	8f6221c0 	.word	0x8f6221c0
8f622068:	8f62219c 	.word	0x8f62219c
8f62206c:	8f62219c 	.word	0x8f62219c
8f622070:	8f62219c 	.word	0x8f62219c
8f622074:	8f6221c0 	.word	0x8f6221c0
8f622078:	8f62219c 	.word	0x8f62219c
8f62207c:	8f62219c 	.word	0x8f62219c
8f622080:	8f62219c 	.word	0x8f62219c
8f622084:	8f62219c 	.word	0x8f62219c
8f622088:	8f62219c 	.word	0x8f62219c
8f62208c:	8f62219c 	.word	0x8f62219c
8f622090:	8f6221c0 	.word	0x8f6221c0
8f622094:	8f62219c 	.word	0x8f62219c
8f622098:	8f62219c 	.word	0x8f62219c
8f62209c:	8f62219c 	.word	0x8f62219c
8f6220a0:	8f62219c 	.word	0x8f62219c
8f6220a4:	8f62219c 	.word	0x8f62219c
8f6220a8:	8f62219c 	.word	0x8f62219c
8f6220ac:	8f62219c 	.word	0x8f62219c
8f6220b0:	8f62219c 	.word	0x8f62219c
8f6220b4:	8f62219c 	.word	0x8f62219c
8f6220b8:	8f62219c 	.word	0x8f62219c
8f6220bc:	8f62219c 	.word	0x8f62219c
8f6220c0:	8f62219c 	.word	0x8f62219c
8f6220c4:	8f62219c 	.word	0x8f62219c
8f6220c8:	8f62219c 	.word	0x8f62219c
8f6220cc:	8f62219c 	.word	0x8f62219c
8f6220d0:	8f62219c 	.word	0x8f62219c
8f6220d4:	8f62219c 	.word	0x8f62219c
8f6220d8:	8f6221c0 	.word	0x8f6221c0
8f6220dc:	8f62219c 	.word	0x8f62219c
8f6220e0:	8f62219c 	.word	0x8f62219c
8f6220e4:	8f62219c 	.word	0x8f62219c
8f6220e8:	8f62219c 	.word	0x8f62219c
8f6220ec:	8f62219c 	.word	0x8f62219c
8f6220f0:	8f62219c 	.word	0x8f62219c
8f6220f4:	8f62219c 	.word	0x8f62219c
8f6220f8:	8f62219c 	.word	0x8f62219c
8f6220fc:	8f62219c 	.word	0x8f62219c
8f622100:	8f62219c 	.word	0x8f62219c
8f622104:	8f6221c0 	.word	0x8f6221c0
8f622108:	8f6221c0 	.word	0x8f6221c0
8f62210c:	8f6221c0 	.word	0x8f6221c0
8f622110:	8f62219c 	.word	0x8f62219c
8f622114:	8f6221c0 	.word	0x8f6221c0
8f622118:	8f6221c0 	.word	0x8f6221c0
8f62211c:	8f62219c 	.word	0x8f62219c
8f622120:	8f62219c 	.word	0x8f62219c
8f622124:	8f62219c 	.word	0x8f62219c
8f622128:	8f62219c 	.word	0x8f62219c
8f62212c:	8f62219c 	.word	0x8f62219c
8f622130:	8f62219c 	.word	0x8f62219c
8f622134:	8f62219c 	.word	0x8f62219c
8f622138:	8f62219c 	.word	0x8f62219c
8f62213c:	8f6221c0 	.word	0x8f6221c0
8f622140:	8f6221c0 	.word	0x8f6221c0
8f622144:	8f62219c 	.word	0x8f62219c
8f622148:	8f62219c 	.word	0x8f62219c
8f62214c:	8f62219c 	.word	0x8f62219c
8f622150:	8f62219c 	.word	0x8f62219c
8f622154:	8f62219c 	.word	0x8f62219c
8f622158:	8f62219c 	.word	0x8f62219c
8f62215c:	8f62219c 	.word	0x8f62219c
8f622160:	8f62219c 	.word	0x8f62219c
8f622164:	8f62219c 	.word	0x8f62219c
8f622168:	8f62219c 	.word	0x8f62219c
8f62216c:	8f62219c 	.word	0x8f62219c
8f622170:	8f62219c 	.word	0x8f62219c
8f622174:	8f62219c 	.word	0x8f62219c
8f622178:	8f62219c 	.word	0x8f62219c
8f62217c:	8f62219c 	.word	0x8f62219c
8f622180:	8f62219c 	.word	0x8f62219c
8f622184:	8f62219c 	.word	0x8f62219c
8f622188:	8f62219c 	.word	0x8f62219c
8f62218c:	8f62219c 	.word	0x8f62219c
8f622190:	8f62219c 	.word	0x8f62219c
8f622194:	8f62219c 	.word	0x8f62219c
8f622198:	8f6221c0 	.word	0x8f6221c0
			dprintf(CRITICAL,"Unsupported platform id\n");
8f62219c:	e59f3038 	ldr	r3, [pc, #56]	; 8f6221dc <get_vibration_type+0x2e0>
8f6221a0:	e5932000 	ldr	r2, [r3]
8f6221a4:	e59d3004 	ldr	r3, [r13, #4]
8f6221a8:	e0332002 	eors	r2, r3, r2
8f6221ac:	e3a03000 	mov	r3, #0
8f6221b0:	03070a2c 	movweq	r0, #31276	; 0x7a2c
8f6221b4:	03480f70 	movteq	r0, #36720	; 0x8f70
8f6221b8:	0affff6b 	beq	8f621f6c <get_vibration_type+0x70>
}
8f6221bc:	eb00427f 	bl	8f632bc0 <__stack_chk_fail>
			config->vib_type = VIB_LRA_TYPE;
8f6221c0:	e3a01000 	mov	r1, #0
			config->hap_rate_cfg1 = QPNP_HAP_RATE_CFG1_41;
8f6221c4:	e3a02041 	mov	r2, #65	; 0x41
			config->hap_rate_cfg2 = QPNP_HAP_RATE_CFG2_03;
8f6221c8:	e3a03003 	mov	r3, #3
			config->vib_type = VIB_LRA_TYPE;
8f6221cc:	e5c41002 	strb	r1, [r4, #2]
			config->hap_rate_cfg1 = QPNP_HAP_RATE_CFG1_41;
8f6221d0:	e5c42000 	strb	r2, [r4]
			config->hap_rate_cfg2 = QPNP_HAP_RATE_CFG2_03;
8f6221d4:	e5c43001 	strb	r3, [r4, #1]
			break;
8f6221d8:	eaffff68 	b	8f621f80 <get_vibration_type+0x84>
8f6221dc:	8f74221c 	.word	0x8f74221c

8f6221e0 <is_display_disabled>:
8f6221e0:	e59f3038 	ldr	r3, [pc, #56]	; 8f622220 <is_display_disabled+0x40>
8f6221e4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6221e8:	e24dd00c 	sub	r13, r13, #12
8f6221ec:	e5933000 	ldr	r3, [r3]
8f6221f0:	e58d3004 	str	r3, [r13, #4]
8f6221f4:	e3a03000 	mov	r3, #0
8f6221f8:	e59f3020 	ldr	r3, [pc, #32]	; 8f622220 <is_display_disabled+0x40>
8f6221fc:	e5932000 	ldr	r2, [r3]
8f622200:	e59d3004 	ldr	r3, [r13, #4]
8f622204:	e0332002 	eors	r2, r3, r2
8f622208:	e3a03000 	mov	r3, #0
8f62220c:	1a000002 	bne	8f62221c <is_display_disabled+0x3c>
8f622210:	e3a00000 	mov	r0, #0
8f622214:	e28dd00c 	add	r13, r13, #12
8f622218:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f62221c:	eb004267 	bl	8f632bc0 <__stack_chk_fail>
8f622220:	8f74221c 	.word	0x8f74221c

8f622224 <target_battery_is_present>:
{
	return false;
}
/* Check battery if it's exist */
bool target_battery_is_present()
{
8f622224:	e59f3150 	ldr	r3, [pc, #336]	; 8f62237c <target_battery_is_present+0x158>
8f622228:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62222c:	e24dd00c 	sub	r13, r13, #12
8f622230:	e5933000 	ldr	r3, [r3]
8f622234:	e58d3004 	str	r3, [r13, #4]
8f622238:	e3a03000 	mov	r3, #0
	bool batt_is_exist;
	uint8_t value = 0;
	uint32_t pmic;

	pmic = target_get_pmic();
8f62223c:	ebff7b9b 	bl	8f6010b0 <target_get_pmic>

	switch(pmic)
8f622240:	e2400001 	sub	r0, r0, #1
8f622244:	e3500024 	cmp	r0, #36	; 0x24
8f622248:	979ff100 	ldrls	r15, [r15, r0, lsl #2]
8f62224c:	ea000024 	b	8f6222e4 <target_battery_is_present+0xc0>
8f622250:	8f622334 	.word	0x8f622334
8f622254:	8f6222e4 	.word	0x8f6222e4
8f622258:	8f6222e4 	.word	0x8f6222e4
8f62225c:	8f6222e4 	.word	0x8f6222e4
8f622260:	8f6222e4 	.word	0x8f6222e4
8f622264:	8f6222e4 	.word	0x8f6222e4
8f622268:	8f6222e4 	.word	0x8f6222e4
8f62226c:	8f6222e4 	.word	0x8f6222e4
8f622270:	8f6222e4 	.word	0x8f6222e4
8f622274:	8f622314 	.word	0x8f622314
8f622278:	8f622334 	.word	0x8f622334
8f62227c:	8f6222e4 	.word	0x8f6222e4
8f622280:	8f622334 	.word	0x8f622334
8f622284:	8f6222e4 	.word	0x8f6222e4
8f622288:	8f6222e4 	.word	0x8f6222e4
8f62228c:	8f6222e4 	.word	0x8f6222e4
8f622290:	8f622314 	.word	0x8f622314
8f622294:	8f6222e4 	.word	0x8f6222e4
8f622298:	8f622314 	.word	0x8f622314
8f62229c:	8f6222e4 	.word	0x8f6222e4
8f6222a0:	8f6222e4 	.word	0x8f6222e4
8f6222a4:	8f6222e4 	.word	0x8f6222e4
8f6222a8:	8f6222e4 	.word	0x8f6222e4
8f6222ac:	8f6222e4 	.word	0x8f6222e4
8f6222b0:	8f6222e4 	.word	0x8f6222e4
8f6222b4:	8f6222e4 	.word	0x8f6222e4
8f6222b8:	8f622360 	.word	0x8f622360
8f6222bc:	8f6222e4 	.word	0x8f6222e4
8f6222c0:	8f6222e4 	.word	0x8f6222e4
8f6222c4:	8f6222e4 	.word	0x8f6222e4
8f6222c8:	8f6222e4 	.word	0x8f6222e4
8f6222cc:	8f6222e4 	.word	0x8f6222e4
8f6222d0:	8f6222e4 	.word	0x8f6222e4
8f6222d4:	8f6222e4 	.word	0x8f6222e4
8f6222d8:	8f6222e4 	.word	0x8f6222e4
8f6222dc:	8f6222e4 	.word	0x8f6222e4
8f6222e0:	8f622344 	.word	0x8f622344
				return false;
			else
				return true;
			break;
		default:
			dprintf(CRITICAL, "ERROR: Couldn't get the pmic type\n");
8f6222e4:	e3070a64 	movw	r0, #31332	; 0x7a64
8f6222e8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6222ec:	eb0041a0 	bl	8f632974 <_dprintf>
			break;
8f6222f0:	e3a00000 	mov	r0, #0

	batt_is_exist = value >> 7;

	return batt_is_exist;

}
8f6222f4:	e59f3080 	ldr	r3, [pc, #128]	; 8f62237c <target_battery_is_present+0x158>
8f6222f8:	e5932000 	ldr	r2, [r3]
8f6222fc:	e59d3004 	ldr	r3, [r13, #4]
8f622300:	e0332002 	eors	r2, r3, r2
8f622304:	e3a03000 	mov	r3, #0
8f622308:	1a00001a 	bne	8f622378 <target_battery_is_present+0x154>
8f62230c:	e28dd00c 	add	r13, r13, #12
8f622310:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
			if(target_is_pmi_enabled())
8f622314:	ebfffe4d 	bl	8f621c50 <target_is_pmi_enabled>
8f622318:	e3500000 	cmp	r0, #0
8f62231c:	0afffff4 	beq	8f6222f4 <target_battery_is_present+0xd0>
				value = REG_READ(PMIC_SLAVE_ID|
8f622320:	e3010208 	movw	r0, #4616	; 0x1208
8f622324:	e3400002 	movt	r0, #2
8f622328:	eb003a52 	bl	8f630c78 <pm8x41_reg_read>
	batt_is_exist = value >> 7;
8f62232c:	e7e703d0 	ubfx	r0, r0, #7, #8
8f622330:	eaffffef 	b	8f6222f4 <target_battery_is_present+0xd0>
			value = REG_READ(BAT_IF_BAT_PRES_STATUS);
8f622334:	e3010208 	movw	r0, #4616	; 0x1208
8f622338:	eb003a4e 	bl	8f630c78 <pm8x41_reg_read>
	batt_is_exist = value >> 7;
8f62233c:	e7e703d0 	ubfx	r0, r0, #7, #8
			break;
8f622340:	eaffffeb 	b	8f6222f4 <target_battery_is_present+0xd0>
			value = REG_READ(PMIC_SLAVE_ID|BAT_IF_INT_RT_STS);
8f622344:	e3010210 	movw	r0, #4624	; 0x1210
8f622348:	e3400002 	movt	r0, #2
8f62234c:	eb003a49 	bl	8f630c78 <pm8x41_reg_read>
			if (value & (BIT(5) | BIT(4)))
8f622350:	e3100030 	tst	r0, #48	; 0x30
8f622354:	03a00001 	moveq	r0, #1
8f622358:	13a00000 	movne	r0, #0
8f62235c:	eaffffe4 	b	8f6222f4 <target_battery_is_present+0xd0>
			value = REG_READ(BAT_IF_INT_RT_STS);
8f622360:	e3010210 	movw	r0, #4624	; 0x1210
8f622364:	eb003a43 	bl	8f630c78 <pm8x41_reg_read>
			if (value & (BIT(5) | BIT(4)))
8f622368:	e3100030 	tst	r0, #48	; 0x30
8f62236c:	03a00001 	moveq	r0, #1
8f622370:	13a00000 	movne	r0, #0
8f622374:	eaffffde 	b	8f6222f4 <target_battery_is_present+0xd0>
}
8f622378:	eb004210 	bl	8f632bc0 <__stack_chk_fail>
8f62237c:	8f74221c 	.word	0x8f74221c

8f622380 <target_get_battery_voltage>:
}

#if CHECK_BAT_VOLTAGE
/* Return battery voltage */
uint32_t target_get_battery_voltage()
{
8f622380:	e92d4010 	push	{r4, r14}
8f622384:	e24dd008 	sub	r13, r13, #8
8f622388:	e59f21b0 	ldr	r2, [pc, #432]	; 8f622540 <target_get_battery_voltage+0x1c0>
	uint32_t pmic;
	uint32_t vbat = 0;
8f62238c:	e3a03000 	mov	r3, #0
{
8f622390:	e5922000 	ldr	r2, [r2]
8f622394:	e58d2004 	str	r2, [r13, #4]
8f622398:	e3a02000 	mov	r2, #0
	uint32_t vbat = 0;
8f62239c:	e58d3000 	str	r3, [r13]
	uint8_t buff[2];
	uint16_t temp;

	pmic = target_get_pmic();
8f6223a0:	ebff7b42 	bl	8f6010b0 <target_get_pmic>

	switch(pmic)
8f6223a4:	e2400001 	sub	r0, r0, #1
8f6223a8:	e3500024 	cmp	r0, #36	; 0x24
8f6223ac:	979ff100 	ldrls	r15, [r15, r0, lsl #2]
8f6223b0:	ea000024 	b	8f622448 <target_get_battery_voltage+0xc8>
8f6223b4:	8f6224a8 	.word	0x8f6224a8
8f6223b8:	8f622448 	.word	0x8f622448
8f6223bc:	8f622448 	.word	0x8f622448
8f6223c0:	8f622448 	.word	0x8f622448
8f6223c4:	8f622448 	.word	0x8f622448
8f6223c8:	8f622448 	.word	0x8f622448
8f6223cc:	8f622448 	.word	0x8f622448
8f6223d0:	8f622448 	.word	0x8f622448
8f6223d4:	8f622448 	.word	0x8f622448
8f6223d8:	8f622478 	.word	0x8f622478
8f6223dc:	8f6224a8 	.word	0x8f6224a8
8f6223e0:	8f622448 	.word	0x8f622448
8f6223e4:	8f6224a8 	.word	0x8f6224a8
8f6223e8:	8f622448 	.word	0x8f622448
8f6223ec:	8f622448 	.word	0x8f622448
8f6223f0:	8f622448 	.word	0x8f622448
8f6223f4:	8f622478 	.word	0x8f622478
8f6223f8:	8f622448 	.word	0x8f622448
8f6223fc:	8f622478 	.word	0x8f622478
8f622400:	8f622448 	.word	0x8f622448
8f622404:	8f622448 	.word	0x8f622448
8f622408:	8f622448 	.word	0x8f622448
8f62240c:	8f622448 	.word	0x8f622448
8f622410:	8f622448 	.word	0x8f622448
8f622414:	8f622448 	.word	0x8f622448
8f622418:	8f622448 	.word	0x8f622448
8f62241c:	8f6224f0 	.word	0x8f6224f0
8f622420:	8f622448 	.word	0x8f622448
8f622424:	8f622448 	.word	0x8f622448
8f622428:	8f622448 	.word	0x8f622448
8f62242c:	8f622448 	.word	0x8f622448
8f622430:	8f622448 	.word	0x8f622448
8f622434:	8f622448 	.word	0x8f622448
8f622438:	8f622448 	.word	0x8f622448
8f62243c:	8f622448 	.word	0x8f622448
8f622440:	8f622448 	.word	0x8f622448
8f622444:	8f6224b0 	.word	0x8f6224b0
			temp = buff[1] << 8 | buff[0];
			/* {MSB,LSB} to decode the voltage level, refer register description. */
			vbat = (((uint64_t)temp)*QGAUGE_VOLTAGE_NUMR/BATT_VOLTAGE_DENR);
			break;
		default:
			dprintf(CRITICAL, "ERROR: Couldn't get the pmic type\n");
8f622448:	e3070a64 	movw	r0, #31332	; 0x7a64
8f62244c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f622450:	eb004147 	bl	8f632974 <_dprintf>
			break;
	}

	return vbat;
8f622454:	e59d0000 	ldr	r0, [r13]
}
8f622458:	e59f30e0 	ldr	r3, [pc, #224]	; 8f622540 <target_get_battery_voltage+0x1c0>
8f62245c:	e5932000 	ldr	r2, [r3]
8f622460:	e59d3004 	ldr	r3, [r13, #4]
8f622464:	e0332002 	eors	r2, r3, r2
8f622468:	e3a03000 	mov	r3, #0
8f62246c:	1a000032 	bne	8f62253c <target_get_battery_voltage+0x1bc>
8f622470:	e28dd008 	add	r13, r13, #8
8f622474:	e8bd8010 	pop	{r4, r15}
			if(target_is_pmi_enabled())
8f622478:	ebfffdf4 	bl	8f621c50 <target_is_pmi_enabled>
8f62247c:	e3500000 	cmp	r0, #0
8f622480:	0afffff3 	beq	8f622454 <target_get_battery_voltage+0xd4>
				if (!pm_fg_usr_get_vbat(1, &vbat)) {
8f622484:	e1a0100d 	mov	r1, r13
8f622488:	e3a00001 	mov	r0, #1
8f62248c:	eb003ebc 	bl	8f631f84 <pm_fg_usr_get_vbat>
8f622490:	e3500000 	cmp	r0, #0
8f622494:	1a000023 	bne	8f622528 <target_get_battery_voltage+0x1a8>
					vbat = vbat*1000; //uv
8f622498:	e59d0000 	ldr	r0, [r13]
8f62249c:	e3a03ffa 	mov	r3, #1000	; 0x3e8
8f6224a0:	e0000093 	mul	r0, r3, r0
8f6224a4:	eaffffeb 	b	8f622458 <target_get_battery_voltage+0xd8>
			vbat = pm8x41_get_batt_voltage(); //uv
8f6224a8:	eb003d2f 	bl	8f63196c <pm8x41_get_batt_voltage>
			break;
8f6224ac:	eaffffe9 	b	8f622458 <target_get_battery_voltage+0xd8>
			buff[0] = REG_READ(ADC_V_DATA_LSB);
8f6224b0:	e30408c0 	movw	r0, #18624	; 0x48c0
8f6224b4:	e3400002 	movt	r0, #2
8f6224b8:	eb0039ee 	bl	8f630c78 <pm8x41_reg_read>
8f6224bc:	e1a04000 	mov	r4, r0
			buff[1] = REG_READ(ADC_V_DATA_MSB);
8f6224c0:	e30408c1 	movw	r0, #18625	; 0x48c1
8f6224c4:	e3400002 	movt	r0, #2
8f6224c8:	eb0039ea 	bl	8f630c78 <pm8x41_reg_read>
			vbat = (((uint64_t)temp)*QGAUGE_VOLTAGE_NUMR/BATT_VOLTAGE_DENR);
8f6224cc:	e30fc84d 	movw	r12, #63565	; 0xf84d
8f6224d0:	e340c002 	movt	r12, #2
8f6224d4:	e3a02ffa 	mov	r2, #1000	; 0x3e8
8f6224d8:	e3a03000 	mov	r3, #0
			temp = buff[1] << 8 | buff[0];
8f6224dc:	e1841400 	orr	r1, r4, r0, lsl #8
			vbat = (((uint64_t)temp)*QGAUGE_VOLTAGE_NUMR/BATT_VOLTAGE_DENR);
8f6224e0:	e6ff1071 	uxth	r1, r1
8f6224e4:	e0810c91 	umull	r0, r1, r1, r12
8f6224e8:	fa006b2d 	blx	8f63d1a4 <__aeabi_uldivmod>
			break;
8f6224ec:	eaffffd9 	b	8f622458 <target_get_battery_voltage+0xd8>
			buff[0] = REG_READ(BATT_INFO_VBATT_LSB);
8f6224f0:	e30401a0 	movw	r0, #16800	; 0x41a0
8f6224f4:	eb0039df 	bl	8f630c78 <pm8x41_reg_read>
8f6224f8:	e1a04000 	mov	r4, r0
			buff[1] = REG_READ(BATT_INFO_VBATT_MSB);
8f6224fc:	e30401a1 	movw	r0, #16801	; 0x41a1
8f622500:	eb0039dc 	bl	8f630c78 <pm8x41_reg_read>
			vbat = (((uint64_t)temp)*BATT_VOLTAGE_NUMR/BATT_VOLTAGE_DENR);
8f622504:	e3a02ffa 	mov	r2, #1000	; 0x3e8
8f622508:	e3a03000 	mov	r3, #0
			temp = buff[1] << 8 | buff[0];
8f62250c:	e1841400 	orr	r1, r4, r0, lsl #8
			vbat = (((uint64_t)temp)*BATT_VOLTAGE_NUMR/BATT_VOLTAGE_DENR);
8f622510:	e30d0cd6 	movw	r0, #56534	; 0xdcd6
8f622514:	e3400001 	movt	r0, #1
8f622518:	e6ff1071 	uxth	r1, r1
8f62251c:	e0810091 	umull	r0, r1, r1, r0
8f622520:	fa006b1f 	blx	8f63d1a4 <__aeabi_uldivmod>
			break;
8f622524:	eaffffcb 	b	8f622458 <target_get_battery_voltage+0xd8>
					dprintf(CRITICAL, "ERROR: Get battery voltage failed!!!\n");
8f622528:	e3070a88 	movw	r0, #31368	; 0x7a88
8f62252c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f622530:	eb00410f 	bl	8f632974 <_dprintf>
	return vbat;
8f622534:	e59d0000 	ldr	r0, [r13]
8f622538:	eaffffc6 	b	8f622458 <target_get_battery_voltage+0xd8>
}
8f62253c:	eb00419f 	bl	8f632bc0 <__stack_chk_fail>
8f622540:	8f74221c 	.word	0x8f74221c

8f622544 <target_battery_soc_ok>:

/* Add safeguards such as refusing to flash if minimum battery levels
 * are not present or be bypass if the device doesn't have a battery
 */
bool target_battery_soc_ok()
{
8f622544:	e59f306c 	ldr	r3, [pc, #108]	; 8f6225b8 <target_battery_soc_ok+0x74>
8f622548:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62254c:	e24dd00c 	sub	r13, r13, #12
8f622550:	e5933000 	ldr	r3, [r3]
8f622554:	e58d3004 	str	r3, [r13, #4]
8f622558:	e3a03000 	mov	r3, #0
	if (!target_battery_is_present()) {
8f62255c:	ebffff30 	bl	8f622224 <target_battery_is_present>
8f622560:	e3500000 	cmp	r0, #0
8f622564:	0a00000d 	beq	8f6225a0 <target_battery_soc_ok+0x5c>
		dprintf(INFO, "battery is not present\n");
		return true;
	}

	if (target_get_battery_voltage() >= BATTERY_MIN_VOLTAGE)
8f622568:	ebffff84 	bl	8f622380 <target_get_battery_voltage>
8f62256c:	e3a03b35 	mov	r3, #54272	; 0xd400
8f622570:	e3403030 	movt	r3, #48	; 0x30
8f622574:	e1500003 	cmp	r0, r3
8f622578:	33a00000 	movcc	r0, #0
8f62257c:	23a00001 	movcs	r0, #1
		return true;

	return false;
}
8f622580:	e59f3030 	ldr	r3, [pc, #48]	; 8f6225b8 <target_battery_soc_ok+0x74>
8f622584:	e5932000 	ldr	r2, [r3]
8f622588:	e59d3004 	ldr	r3, [r13, #4]
8f62258c:	e0332002 	eors	r2, r3, r2
8f622590:	e3a03000 	mov	r3, #0
8f622594:	1a000006 	bne	8f6225b4 <target_battery_soc_ok+0x70>
8f622598:	e28dd00c 	add	r13, r13, #12
8f62259c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		dprintf(INFO, "battery is not present\n");
8f6225a0:	e3070ab0 	movw	r0, #31408	; 0x7ab0
8f6225a4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6225a8:	eb0040f1 	bl	8f632974 <_dprintf>
		return true;
8f6225ac:	e3a00001 	mov	r0, #1
8f6225b0:	eafffff2 	b	8f622580 <target_battery_soc_ok+0x3c>
}
8f6225b4:	eb004181 	bl	8f632bc0 <__stack_chk_fail>
8f6225b8:	8f74221c 	.word	0x8f74221c

8f6225bc <target_display_init>:

	return 0;
}

void target_display_init(const char *panel_name)
{
8f6225bc:	e59f3238 	ldr	r3, [pc, #568]	; 8f6227fc <target_display_init+0x240>
8f6225c0:	e1a01000 	mov	r1, r0
8f6225c4:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
	dprintf(SPEW, "Panel: %s\n", panel_name);
8f6225c8:	e3070ac8 	movw	r0, #31432	; 0x7ac8
{
8f6225cc:	e24dd028 	sub	r13, r13, #40	; 0x28
	dprintf(SPEW, "Panel: %s\n", panel_name);
8f6225d0:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f6225d4:	e5933000 	ldr	r3, [r3]
8f6225d8:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f6225dc:	e3a03000 	mov	r3, #0
	dprintf(SPEW, "Panel: %s\n", panel_name);
8f6225e0:	eb0040e3 	bl	8f632974 <_dprintf>
	fb->base = (void*) readl(MDP_PIPE_BASE + PIPE_SSPP_SRC0_ADDR);
8f6225e4:	e3a02a05 	mov	r2, #20480	; 0x5000
8f6225e8:	e34021a1 	movt	r2, #417	; 0x1a1
8f6225ec:	e3014aa4 	movw	r4, #6820	; 0x1aa4
8f6225f0:	e3484f71 	movt	r4, #36721	; 0x8f71
8f6225f4:	e5921014 	ldr	r1, [r2, #20]
	if (!fb->base) {
8f6225f8:	e3510000 	cmp	r1, #0
	fb->base = (void*) readl(MDP_PIPE_BASE + PIPE_SSPP_SRC0_ADDR);
8f6225fc:	e5841000 	str	r1, [r4]
	if (!fb->base) {
8f622600:	0a00006c 	beq	8f6227b8 <target_display_init+0x1fc>
	cmd_mode = !!(readl(MDP_CTL_BASE + CTL_TOP) & MDP_CTL_TOP_MODE_SEL_CMD);
8f622604:	e3a0ea02 	mov	r14, #8192	; 0x2000
8f622608:	e340e1a0 	movt	r14, #416	; 0x1a0
	stride = readl(MDP_PIPE_BASE + PIPE_SSPP_SRC_YSTRIDE);
8f62260c:	e5926024 	ldr	r6, [r2, #36]	; 0x24
	src_size = readl(MDP_PIPE_BASE + PIPE_SSPP_SRC_IMG_SIZE);
8f622610:	e5923004 	ldr	r3, [r2, #4]
	out_size = readl(MDP_PIPE_BASE + PIPE_SSPP_SRC_OUT_SIZE);
8f622614:	e592c00c 	ldr	r12, [r2, #12]
	src_xy = readl(MDP_PIPE_BASE + PIPE_SSPP_SRC_XY);
8f622618:	e5920008 	ldr	r0, [r2, #8]
	out_xy = readl(MDP_PIPE_BASE + PIPE_SSPP_OUT_XY);
8f62261c:	e5922010 	ldr	r2, [r2, #16]
	cmd_mode = !!(readl(MDP_CTL_BASE + CTL_TOP) & MDP_CTL_TOP_MODE_SEL_CMD);
8f622620:	e59e7014 	ldr	r7, [r14, #20]
	dprintf(SPEW, "Continuous splash detected: base: %p, stride: %d, "
8f622624:	e1a0882c 	lsr	r8, r12, #16
8f622628:	e1a0e823 	lsr	r14, r3, #16
8f62262c:	e6ffc07c 	uxth	r12, r12
8f622630:	e6ff3073 	uxth	r3, r3
8f622634:	e58de000 	str	r14, [r13]
8f622638:	e58dc00c 	str	r12, [r13, #12]
	cmd_mode = !!(readl(MDP_CTL_BASE + CTL_TOP) & MDP_CTL_TOP_MODE_SEL_CMD);
8f62263c:	e7e0c8d7 	ubfx	r12, r7, #17, #1
	dprintf(SPEW, "Continuous splash detected: base: %p, stride: %d, "
8f622640:	e58d8010 	str	r8, [r13, #16]
	cmd_mode = !!(readl(MDP_CTL_BASE + CTL_TOP) & MDP_CTL_TOP_MODE_SEL_CMD);
8f622644:	e2077802 	and	r7, r7, #131072	; 0x20000
	dprintf(SPEW, "Continuous splash detected: base: %p, stride: %d, "
8f622648:	e58dc01c 	str	r12, [r13, #28]
8f62264c:	e1a0c822 	lsr	r12, r2, #16
8f622650:	e6ff2072 	uxth	r2, r2
8f622654:	e58dc018 	str	r12, [r13, #24]
8f622658:	e58d2014 	str	r2, [r13, #20]
8f62265c:	e1a02820 	lsr	r2, r0, #16
8f622660:	e6ff0070 	uxth	r0, r0
8f622664:	e58d2008 	str	r2, [r13, #8]
8f622668:	e58d0004 	str	r0, [r13, #4]
8f62266c:	e1a02006 	mov	r2, r6
8f622670:	e3070b08 	movw	r0, #31496	; 0x7b08
8f622674:	e3480f70 	movt	r0, #36720	; 0x8f70
8f622678:	eb0040bd 	bl	8f632974 <_dprintf>
	fb->stride = stride / (fb->bpp/8);
8f62267c:	e5945010 	ldr	r5, [r4, #16]
8f622680:	e1a00006 	mov	r0, r6
8f622684:	e1a051a5 	lsr	r5, r5, #3
8f622688:	e1a01005 	mov	r1, r5
8f62268c:	fa006951 	blx	8f63cbd8 <__udivsi3>
	if (fb->stride == 0 || fb->width == 0 || fb->height == 0) {
8f622690:	e1560005 	cmp	r6, r5
8f622694:	23a05000 	movcs	r5, #0
8f622698:	33a05001 	movcc	r5, #1
8f62269c:	e3580000 	cmp	r8, #0
8f6226a0:	03855001 	orreq	r5, r5, #1
8f6226a4:	e3550000 	cmp	r5, #0
	fb->stride = stride / (fb->bpp/8);
8f6226a8:	e584000c 	str	r0, [r4, #12]
	fb->height = out_size >> 16;
8f6226ac:	e9840101 	stmib	r4, {r0, r8}
	if (fb->stride == 0 || fb->width == 0 || fb->height == 0) {
8f6226b0:	1a00002c 	bne	8f622768 <target_display_init+0x1ac>
	size = stride * fb->height;
8f6226b4:	e0060698 	mul	r6, r8, r6
	if (check_aboot_addr_range_overlap((uintptr_t) fb->base, size)
8f6226b8:	e5940000 	ldr	r0, [r4]
8f6226bc:	e1a01006 	mov	r1, r6
8f6226c0:	eb00114c 	bl	8f626bf8 <check_aboot_addr_range_overlap>
8f6226c4:	e3500000 	cmp	r0, #0
8f6226c8:	1a000031 	bne	8f622794 <target_display_init+0x1d8>
			|| check_ddr_addr_range_bound((uintptr_t) fb->base, size)) {
8f6226cc:	e5940000 	ldr	r0, [r4]
8f6226d0:	e1a01006 	mov	r1, r6
8f6226d4:	eb00116b 	bl	8f626c88 <check_ddr_addr_range_bound>
8f6226d8:	e3500000 	cmp	r0, #0
8f6226dc:	1a00002c 	bne	8f622794 <target_display_init+0x1d8>
	if (cmd_mode && !(BIT(31) & readl(MDP_REG_PP_0_AUTOREFRESH_CONFIG)))
8f6226e0:	e3570000 	cmp	r7, #0
8f6226e4:	1a000010 	bne	8f62272c <target_display_init+0x170>
	fb->base = (void*) platform_map_fb((addr_t) fb->base, size);
8f6226e8:	e5940000 	ldr	r0, [r4]
8f6226ec:	e1a01006 	mov	r1, r6
8f6226f0:	ebfffc5c 	bl	8f621868 <platform_map_fb>
		dprintf(CRITICAL, "Failed to map continuous splash memory region\n");
8f6226f4:	e59f3100 	ldr	r3, [pc, #256]	; 8f6227fc <target_display_init+0x240>
	if (!fb->base) {
8f6226f8:	e3500000 	cmp	r0, #0
	fb->base = (void*) platform_map_fb((addr_t) fb->base, size);
8f6226fc:	e5840000 	str	r0, [r4]
	if (!fb->base) {
8f622700:	0a000035 	beq	8f6227dc <target_display_init+0x220>

	if (mdp5_read_config(&fb))
		return;

	// Setup framebuffer
	fbcon_setup(&fb);
8f622704:	e5932000 	ldr	r2, [r3]
8f622708:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f62270c:	e0332002 	eors	r2, r3, r2
8f622710:	e3a03000 	mov	r3, #0
8f622714:	1a000026 	bne	8f6227b4 <target_display_init+0x1f8>
8f622718:	e3010aa4 	movw	r0, #6820	; 0x1aa4
8f62271c:	e3480f71 	movt	r0, #36721	; 0x8f71
}
8f622720:	e28dd028 	add	r13, r13, #40	; 0x28
8f622724:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, r14}
	fbcon_setup(&fb);
8f622728:	ea00385e 	b	8f6308a8 <fbcon_setup>
	if (cmd_mode && !(BIT(31) & readl(MDP_REG_PP_0_AUTOREFRESH_CONFIG)))
8f62272c:	e3a03a01 	mov	r3, #4096	; 0x1000
8f622730:	e34031a7 	movt	r3, #423	; 0x1a7
8f622734:	e5933030 	ldr	r3, [r3, #48]	; 0x30
8f622738:	e3530000 	cmp	r3, #0
8f62273c:	baffffe9 	blt	8f6226e8 <target_display_init+0x12c>
		dummy_panel.autorefresh_enable = 1;
8f622740:	e301056c 	movw	r0, #5484	; 0x156c
8f622744:	e3480f71 	movt	r0, #36721	; 0x8f71
8f622748:	e3a03001 	mov	r3, #1
		dummy_panel.type = MIPI_CMD_PANEL;
8f62274c:	e3a02009 	mov	r2, #9
		dummy_panel.autorefresh_enable = 1;
8f622750:	e5c03530 	strb	r3, [r0, #1328]	; 0x530
		dummy_panel.autorefresh_framenum = 1;
8f622754:	e5803534 	str	r3, [r0, #1332]	; 0x534
		dummy_panel.type = MIPI_CMD_PANEL;
8f622758:	e580200c 	str	r2, [r0, #12]
		mdp_dma_on(&dummy_panel);
8f62275c:	ebffe085 	bl	8f61a978 <mdp_dma_on>
		dsb();
8f622760:	f57ff04f 	dsb	sy
8f622764:	eaffffdf 	b	8f6226e8 <target_display_init+0x12c>
		dprintf(CRITICAL, "Invalid parameters for continuous splash\n");
8f622768:	e59f308c 	ldr	r3, [pc, #140]	; 8f6227fc <target_display_init+0x240>
8f62276c:	e5932000 	ldr	r2, [r3]
8f622770:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f622774:	e0332002 	eors	r2, r3, r2
8f622778:	e3a03000 	mov	r3, #0
8f62277c:	03070b78 	movweq	r0, #31608	; 0x7b78
8f622780:	03480f70 	movteq	r0, #36720	; 0x8f70
8f622784:	1a00000a 	bne	8f6227b4 <target_display_init+0x1f8>
}
8f622788:	e28dd028 	add	r13, r13, #40	; 0x28
8f62278c:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, r14}
		dprintf(CRITICAL, "Invalid parameters for continuous splash\n");
8f622790:	ea004077 	b	8f632974 <_dprintf>
		dprintf(CRITICAL, "Invalid memory region for continuous splash"
8f622794:	e59f3060 	ldr	r3, [pc, #96]	; 8f6227fc <target_display_init+0x240>
8f622798:	e5932000 	ldr	r2, [r3]
8f62279c:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f6227a0:	e0332002 	eors	r2, r3, r2
8f6227a4:	e3a03000 	mov	r3, #0
8f6227a8:	03070ba4 	movweq	r0, #31652	; 0x7ba4
8f6227ac:	03480f70 	movteq	r0, #36720	; 0x8f70
8f6227b0:	0afffff4 	beq	8f622788 <target_display_init+0x1cc>
	fbcon_setup(&fb);
8f6227b4:	eb004101 	bl	8f632bc0 <__stack_chk_fail>
		dprintf(CRITICAL, "Continuous splash does not appear to be enabled\n");
8f6227b8:	e59f303c 	ldr	r3, [pc, #60]	; 8f6227fc <target_display_init+0x240>
8f6227bc:	e5932000 	ldr	r2, [r3]
8f6227c0:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f6227c4:	e0332002 	eors	r2, r3, r2
8f6227c8:	e3a03000 	mov	r3, #0
8f6227cc:	03070ad4 	movweq	r0, #31444	; 0x7ad4
8f6227d0:	03480f70 	movteq	r0, #36720	; 0x8f70
8f6227d4:	0affffeb 	beq	8f622788 <target_display_init+0x1cc>
8f6227d8:	eafffff5 	b	8f6227b4 <target_display_init+0x1f8>
		dprintf(CRITICAL, "Failed to map continuous splash memory region\n");
8f6227dc:	e5932000 	ldr	r2, [r3]
8f6227e0:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f6227e4:	e0332002 	eors	r2, r3, r2
8f6227e8:	e3a03000 	mov	r3, #0
8f6227ec:	03070bec 	movweq	r0, #31724	; 0x7bec
8f6227f0:	03480f70 	movteq	r0, #36720	; 0x8f70
8f6227f4:	0affffe3 	beq	8f622788 <target_display_init+0x1cc>
8f6227f8:	eaffffed 	b	8f6227b4 <target_display_init+0x1f8>
8f6227fc:	8f74221c 	.word	0x8f74221c

8f622800 <dpc_thread_routine>:

	return NO_ERROR;
}

static int dpc_thread_routine(void *arg)
{
8f622800:	e59f30d4 	ldr	r3, [pc, #212]	; 8f6228dc <dpc_thread_routine+0xdc>
8f622804:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f622808:	e24dd008 	sub	r13, r13, #8
8f62280c:	e3018acc 	movw	r8, #6860	; 0x1acc
8f622810:	e3015ac4 	movw	r5, #6852	; 0x1ac4
	for (;;) {
		event_wait(&dpc_event);
8f622814:	e3047000 	movw	r7, #16384	; 0x4000
8f622818:	e3488f71 	movt	r8, #36721	; 0x8f71
8f62281c:	e3485f71 	movt	r5, #36721	; 0x8f71
8f622820:	e3487f73 	movt	r7, #36723	; 0x8f73
{
8f622824:	e5933000 	ldr	r3, [r3]
8f622828:	e58d3004 	str	r3, [r13, #4]
8f62282c:	e3a03000 	mov	r3, #0
	item->prev = item->next = 0;
8f622830:	e3a06000 	mov	r6, #0
		event_wait(&dpc_event);
8f622834:	e1a00007 	mov	r0, r7
8f622838:	eb00009c 	bl	8f622ab0 <event_wait>
	critical_section_count++;
8f62283c:	e5983000 	ldr	r3, [r8]
8f622840:	e2833001 	add	r3, r3, #1
8f622844:	e5883000 	str	r3, [r8]
	if (critical_section_count == 1)
8f622848:	e3530001 	cmp	r3, #1
8f62284c:	0a000015 	beq	8f6228a8 <dpc_thread_routine+0xa8>
}

static inline struct list_node* list_remove_head(struct list_node *list)
{
	if(list->next != list) {
8f622850:	e5954004 	ldr	r4, [r5, #4]
8f622854:	e1540005 	cmp	r4, r5
8f622858:	0a000016 	beq	8f6228b8 <dpc_thread_routine+0xb8>
	critical_section_count--;
8f62285c:	e5983000 	ldr	r3, [r8]
	item->next->prev = item->prev;
8f622860:	e5942000 	ldr	r2, [r4]
8f622864:	e5941004 	ldr	r1, [r4, #4]
8f622868:	e2433001 	sub	r3, r3, #1
	if (critical_section_count == 0)
8f62286c:	e3530000 	cmp	r3, #0
8f622870:	e5812000 	str	r2, [r1]
	item->prev->next = item->next;
8f622874:	e5821004 	str	r1, [r2, #4]
	item->prev = item->next = 0;
8f622878:	e5846000 	str	r6, [r4]
8f62287c:	e5846004 	str	r6, [r4, #4]
	critical_section_count--;
8f622880:	e5883000 	str	r3, [r8]
	if (critical_section_count == 0)
8f622884:	0a000005 	beq	8f6228a0 <dpc_thread_routine+0xa0>
			event_unsignal(&dpc_event);
		exit_critical_section();

		if (dpc) {
//			dprintf("dpc calling %p, arg %p\n", dpc->cb, dpc->arg);
			dpc->cb(dpc->arg);
8f622888:	e594000c 	ldr	r0, [r4, #12]
8f62288c:	e5943008 	ldr	r3, [r4, #8]
8f622890:	e12fff33 	blx	r3

			free(dpc);
8f622894:	e1a00004 	mov	r0, r4
8f622898:	eb00461b 	bl	8f63410c <free>
8f62289c:	eaffffe4 	b	8f622834 <dpc_thread_routine+0x34>
		arch_enable_ints();
8f6228a0:	ebfff9d8 	bl	8f621008 <arch_enable_ints>
		if (dpc) {
8f6228a4:	eafffff7 	b	8f622888 <dpc_thread_routine+0x88>
		arch_disable_ints();
8f6228a8:	ebfff9da 	bl	8f621018 <arch_disable_ints>
	if(list->next != list) {
8f6228ac:	e5954004 	ldr	r4, [r5, #4]
8f6228b0:	e1540005 	cmp	r4, r5
8f6228b4:	1affffe8 	bne	8f62285c <dpc_thread_routine+0x5c>
			event_unsignal(&dpc_event);
8f6228b8:	e1a00007 	mov	r0, r7
8f6228bc:	eb000101 	bl	8f622cc8 <event_unsignal>
	critical_section_count--;
8f6228c0:	e5983000 	ldr	r3, [r8]
8f6228c4:	e2433001 	sub	r3, r3, #1
8f6228c8:	e5883000 	str	r3, [r8]
	if (critical_section_count == 0)
8f6228cc:	e3530000 	cmp	r3, #0
8f6228d0:	1affffd7 	bne	8f622834 <dpc_thread_routine+0x34>
		arch_enable_ints();
8f6228d4:	ebfff9cb 	bl	8f621008 <arch_enable_ints>
		if (dpc) {
8f6228d8:	eaffffd5 	b	8f622834 <dpc_thread_routine+0x34>
8f6228dc:	8f74221c 	.word	0x8f74221c

8f6228e0 <dpc_init>:
{
8f6228e0:	e92d4030 	push	{r4, r5, r14}
	event_init(&dpc_event, false, 0);
8f6228e4:	e3a02000 	mov	r2, #0
{
8f6228e8:	e24dd014 	sub	r13, r13, #20
8f6228ec:	e59f3088 	ldr	r3, [pc, #136]	; 8f62297c <dpc_init+0x9c>
	event_init(&dpc_event, false, 0);
8f6228f0:	e1a01002 	mov	r1, r2
8f6228f4:	e3040000 	movw	r0, #16384	; 0x4000
8f6228f8:	e3480f73 	movt	r0, #36723	; 0x8f73
{
8f6228fc:	e5933000 	ldr	r3, [r3]
8f622900:	e58d300c 	str	r3, [r13, #12]
8f622904:	e3a03000 	mov	r3, #0
	event_init(&dpc_event, false, 0);
8f622908:	e1a0500e 	mov	r5, r14
8f62290c:	eb000050 	bl	8f622a54 <event_init>
	thr = thread_create("dpc", &dpc_thread_routine, NULL, DPC_PRIORITY, DEFAULT_STACK_SIZE);
8f622910:	e3a00a03 	mov	r0, #12288	; 0x3000
8f622914:	e3a0301e 	mov	r3, #30
8f622918:	e58d0000 	str	r0, [r13]
8f62291c:	e3a02000 	mov	r2, #0
8f622920:	e3021800 	movw	r1, #10240	; 0x2800
8f622924:	e3070c1c 	movw	r0, #31772	; 0x7c1c
8f622928:	e3481f62 	movt	r1, #36706	; 0x8f62
8f62292c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f622930:	eb000451 	bl	8f623a7c <thread_create>
	if (!thr)
8f622934:	e2504000 	subs	r4, r0, #0
8f622938:	0a000009 	beq	8f622964 <dpc_init+0x84>
	thread_resume(thr);
8f62293c:	e59f3038 	ldr	r3, [pc, #56]	; 8f62297c <dpc_init+0x9c>
8f622940:	e5932000 	ldr	r2, [r3]
8f622944:	e59d300c 	ldr	r3, [r13, #12]
8f622948:	e0332002 	eors	r2, r3, r2
8f62294c:	e3a03000 	mov	r3, #0
8f622950:	1a000008 	bne	8f622978 <dpc_init+0x98>
8f622954:	e1a00004 	mov	r0, r4
}
8f622958:	e28dd014 	add	r13, r13, #20
8f62295c:	e8bd4030 	pop	{r4, r5, r14}
	thread_resume(thr);
8f622960:	ea000536 	b	8f623e40 <thread_resume>
		panic("failed to create dpc thread\n");
8f622964:	e3071c20 	movw	r1, #31776	; 0x7c20
8f622968:	e1a00005 	mov	r0, r5
8f62296c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f622970:	eb004051 	bl	8f632abc <_panic>
8f622974:	eafffff0 	b	8f62293c <dpc_init+0x5c>
	thread_resume(thr);
8f622978:	eb004090 	bl	8f632bc0 <__stack_chk_fail>
8f62297c:	8f74221c 	.word	0x8f74221c

8f622980 <dpc_queue>:
{
8f622980:	e59f30c8 	ldr	r3, [pc, #200]	; 8f622a50 <dpc_queue+0xd0>
8f622984:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f622988:	e1a08000 	mov	r8, r0
8f62298c:	e24dd008 	sub	r13, r13, #8
	dpc = malloc(sizeof(struct dpc));
8f622990:	e3a00010 	mov	r0, #16
{
8f622994:	e5933000 	ldr	r3, [r3]
8f622998:	e58d3004 	str	r3, [r13, #4]
8f62299c:	e3a03000 	mov	r3, #0
8f6229a0:	e1a07001 	mov	r7, r1
8f6229a4:	e1a06002 	mov	r6, r2
	dpc = malloc(sizeof(struct dpc));
8f6229a8:	eb004593 	bl	8f633ffc <malloc>
	critical_section_count++;
8f6229ac:	e3015acc 	movw	r5, #6860	; 0x1acc
8f6229b0:	e3485f71 	movt	r5, #36721	; 0x8f71
8f6229b4:	e5953000 	ldr	r3, [r5]
8f6229b8:	e2833001 	add	r3, r3, #1
8f6229bc:	e5853000 	str	r3, [r5]
	if (critical_section_count == 1)
8f6229c0:	e3530001 	cmp	r3, #1
8f6229c4:	e1a04000 	mov	r4, r0
	dpc->cb = cb;
8f6229c8:	e5808008 	str	r8, [r0, #8]
	dpc->arg = arg;
8f6229cc:	e580700c 	str	r7, [r0, #12]
8f6229d0:	0a00001b 	beq	8f622a44 <dpc_queue+0xc4>
	item->prev = list->prev;
8f6229d4:	e3013ac4 	movw	r3, #6852	; 0x1ac4
8f6229d8:	e3483f71 	movt	r3, #36721	; 0x8f71
	event_signal(&dpc_event, (flags & DPC_FLAG_NORESCHED) ? false : true);
8f6229dc:	e1e01006 	mvn	r1, r6
	item->next = list;
8f6229e0:	e5843004 	str	r3, [r4, #4]
	item->prev = list->prev;
8f6229e4:	e5932000 	ldr	r2, [r3]
8f6229e8:	e2011001 	and	r1, r1, #1
8f6229ec:	e3040000 	movw	r0, #16384	; 0x4000
8f6229f0:	e3480f73 	movt	r0, #36723	; 0x8f73
	list->prev = item;
8f6229f4:	e5834000 	str	r4, [r3]
	item->prev = list->prev;
8f6229f8:	e5842000 	str	r2, [r4]
	list->prev->next = item;
8f6229fc:	e5824004 	str	r4, [r2, #4]
8f622a00:	eb000069 	bl	8f622bac <event_signal>
	critical_section_count--;
8f622a04:	e5953000 	ldr	r3, [r5]
8f622a08:	e2433001 	sub	r3, r3, #1
8f622a0c:	e5853000 	str	r3, [r5]
	if (critical_section_count == 0)
8f622a10:	e3530000 	cmp	r3, #0
8f622a14:	0a000008 	beq	8f622a3c <dpc_queue+0xbc>
}
8f622a18:	e59f3030 	ldr	r3, [pc, #48]	; 8f622a50 <dpc_queue+0xd0>
8f622a1c:	e5932000 	ldr	r2, [r3]
8f622a20:	e59d3004 	ldr	r3, [r13, #4]
8f622a24:	e0332002 	eors	r2, r3, r2
8f622a28:	e3a03000 	mov	r3, #0
8f622a2c:	1a000006 	bne	8f622a4c <dpc_queue+0xcc>
8f622a30:	e3a00000 	mov	r0, #0
8f622a34:	e28dd008 	add	r13, r13, #8
8f622a38:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
		arch_enable_ints();
8f622a3c:	ebfff971 	bl	8f621008 <arch_enable_ints>
8f622a40:	eafffff4 	b	8f622a18 <dpc_queue+0x98>
		arch_disable_ints();
8f622a44:	ebfff973 	bl	8f621018 <arch_disable_ints>
8f622a48:	eaffffe1 	b	8f6229d4 <dpc_queue+0x54>
8f622a4c:	eb00405b 	bl	8f632bc0 <__stack_chk_fail>
8f622a50:	8f74221c 	.word	0x8f74221c

8f622a54 <event_init>:
 * @param e        Event object to initialize
 * @param initial  Initial value for "signaled" state
 * @param flags    0 or EVENT_FLAG_AUTOUNSIGNAL
 */
void event_init(event_t *e, bool initial, uint flags)
{
8f622a54:	e59fc050 	ldr	r12, [pc, #80]	; 8f622aac <event_init+0x58>
#if EVENT_CHECK
//	ASSERT(e->magic != EVENT_MAGIC);
#endif

	e->magic = EVENT_MAGIC;
8f622a58:	e3063e74 	movw	r3, #28276	; 0x6e74
{
8f622a5c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f622a60:	e24dd00c 	sub	r13, r13, #12
8f622a64:	e59cc000 	ldr	r12, [r12]
8f622a68:	e58dc004 	str	r12, [r13, #4]
8f622a6c:	e3a0c000 	mov	r12, #0
	e->magic = EVENT_MAGIC;
8f622a70:	e3463576 	movt	r3, #25974	; 0x6576
8f622a74:	e5803000 	str	r3, [r0]
	e->signalled = initial;
	e->flags = flags;
	wait_queue_init(&e->wait);
8f622a78:	e59f302c 	ldr	r3, [pc, #44]	; 8f622aac <event_init+0x58>
	e->signalled = initial;
8f622a7c:	e5801004 	str	r1, [r0, #4]
	e->flags = flags;
8f622a80:	e5802008 	str	r2, [r0, #8]
	wait_queue_init(&e->wait);
8f622a84:	e5932000 	ldr	r2, [r3]
8f622a88:	e59d3004 	ldr	r3, [r13, #4]
8f622a8c:	e0332002 	eors	r2, r3, r2
8f622a90:	e3a03000 	mov	r3, #0
8f622a94:	1a000003 	bne	8f622aa8 <event_init+0x54>
8f622a98:	e280000c 	add	r0, r0, #12
}
8f622a9c:	e28dd00c 	add	r13, r13, #12
8f622aa0:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	wait_queue_init(&e->wait);
8f622aa4:	ea0006a7 	b	8f624548 <wait_queue_init>
8f622aa8:	eb004044 	bl	8f632bc0 <__stack_chk_fail>
8f622aac:	8f74221c 	.word	0x8f74221c

8f622ab0 <event_wait>:

/**
 * @brief  Same as event_wait_timeout(), but without a timeout.
 */
status_t event_wait(event_t *e)
{
8f622ab0:	e92d4070 	push	{r4, r5, r6, r14}
	critical_section_count++;
8f622ab4:	e3014acc 	movw	r4, #6860	; 0x1acc
8f622ab8:	e3484f71 	movt	r4, #36721	; 0x8f71
8f622abc:	e59f20e4 	ldr	r2, [pc, #228]	; 8f622ba8 <event_wait+0xf8>
8f622ac0:	e24dd010 	sub	r13, r13, #16
8f622ac4:	e1a0500e 	mov	r5, r14
8f622ac8:	e5943000 	ldr	r3, [r4]
8f622acc:	e5922000 	ldr	r2, [r2]
8f622ad0:	e58d200c 	str	r2, [r13, #12]
8f622ad4:	e3a02000 	mov	r2, #0
8f622ad8:	e1a06000 	mov	r6, r0
8f622adc:	e2833001 	add	r3, r3, #1
8f622ae0:	e5843000 	str	r3, [r4]
	if (critical_section_count == 1)
8f622ae4:	e3530001 	cmp	r3, #1
8f622ae8:	0a000020 	beq	8f622b70 <event_wait+0xc0>
	ASSERT(e->magic == EVENT_MAGIC);
8f622aec:	e5962000 	ldr	r2, [r6]
8f622af0:	e3063e74 	movw	r3, #28276	; 0x6e74
8f622af4:	e3463576 	movt	r3, #25974	; 0x6576
8f622af8:	e1520003 	cmp	r2, r3
8f622afc:	1a00001d 	bne	8f622b78 <event_wait+0xc8>
	if (e->signalled) {
8f622b00:	e5963004 	ldr	r3, [r6, #4]
8f622b04:	e3530000 	cmp	r3, #0
8f622b08:	0a000011 	beq	8f622b54 <event_wait+0xa4>
		if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
8f622b0c:	e5963008 	ldr	r3, [r6, #8]
8f622b10:	e2135001 	ands	r5, r3, #1
			e->signalled = false;
8f622b14:	13a05000 	movne	r5, #0
8f622b18:	15865004 	strne	r5, [r6, #4]
	critical_section_count--;
8f622b1c:	e5943000 	ldr	r3, [r4]
8f622b20:	e2433001 	sub	r3, r3, #1
8f622b24:	e5843000 	str	r3, [r4]
	if (critical_section_count == 0)
8f622b28:	e3530000 	cmp	r3, #0
8f622b2c:	0a00000d 	beq	8f622b68 <event_wait+0xb8>
	return event_wait_timeout(e, INFINITE_TIME);
}
8f622b30:	e59f3070 	ldr	r3, [pc, #112]	; 8f622ba8 <event_wait+0xf8>
8f622b34:	e5932000 	ldr	r2, [r3]
8f622b38:	e59d300c 	ldr	r3, [r13, #12]
8f622b3c:	e0332002 	eors	r2, r3, r2
8f622b40:	e3a03000 	mov	r3, #0
8f622b44:	1a000016 	bne	8f622ba4 <event_wait+0xf4>
8f622b48:	e1a00005 	mov	r0, r5
8f622b4c:	e28dd010 	add	r13, r13, #16
8f622b50:	e8bd8070 	pop	{r4, r5, r6, r15}
		ret = wait_queue_block(&e->wait, timeout);
8f622b54:	e286000c 	add	r0, r6, #12
8f622b58:	e3e01000 	mvn	r1, #0
8f622b5c:	eb000691 	bl	8f6245a8 <wait_queue_block>
8f622b60:	e1a05000 	mov	r5, r0
err:
8f622b64:	eaffffec 	b	8f622b1c <event_wait+0x6c>
		arch_enable_ints();
8f622b68:	ebfff926 	bl	8f621008 <arch_enable_ints>
	return event_wait_timeout(e, INFINITE_TIME);
8f622b6c:	eaffffef 	b	8f622b30 <event_wait+0x80>
		arch_disable_ints();
8f622b70:	ebfff928 	bl	8f621018 <arch_disable_ints>
8f622b74:	eaffffdc 	b	8f622aec <event_wait+0x3c>
	ASSERT(e->magic == EVENT_MAGIC);
8f622b78:	e3071c50 	movw	r1, #31824	; 0x7c50
8f622b7c:	e3072c40 	movw	r2, #31808	; 0x7c40
8f622b80:	e3481f70 	movt	r1, #36720	; 0x8f70
8f622b84:	e3482f70 	movt	r2, #36720	; 0x8f70
8f622b88:	e58d1000 	str	r1, [r13]
8f622b8c:	e3a03075 	mov	r3, #117	; 0x75
8f622b90:	e1a00005 	mov	r0, r5
8f622b94:	e3001130 	movw	r1, #304	; 0x130
8f622b98:	e3481f70 	movt	r1, #36720	; 0x8f70
8f622b9c:	eb003fc6 	bl	8f632abc <_panic>
8f622ba0:	eaffffd6 	b	8f622b00 <event_wait+0x50>
}
8f622ba4:	eb004005 	bl	8f632bc0 <__stack_chk_fail>
8f622ba8:	8f74221c 	.word	0x8f74221c

8f622bac <event_signal>:
 *                    queue.
 *
 * @return  Returns NO_ERROR on success.
 */
status_t event_signal(event_t *e, bool reschedule)
{
8f622bac:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	critical_section_count++;
8f622bb0:	e3014acc 	movw	r4, #6860	; 0x1acc
8f622bb4:	e3484f71 	movt	r4, #36721	; 0x8f71
8f622bb8:	e59f2104 	ldr	r2, [pc, #260]	; 8f622cc4 <event_signal+0x118>
8f622bbc:	e24dd014 	sub	r13, r13, #20
8f622bc0:	e1a0700e 	mov	r7, r14
8f622bc4:	e5943000 	ldr	r3, [r4]
8f622bc8:	e5922000 	ldr	r2, [r2]
8f622bcc:	e58d200c 	str	r2, [r13, #12]
8f622bd0:	e3a02000 	mov	r2, #0
8f622bd4:	e1a05000 	mov	r5, r0
8f622bd8:	e1a06001 	mov	r6, r1
8f622bdc:	e2833001 	add	r3, r3, #1
8f622be0:	e5843000 	str	r3, [r4]
	if (critical_section_count == 1)
8f622be4:	e3530001 	cmp	r3, #1
8f622be8:	0a000027 	beq	8f622c8c <event_signal+0xe0>
	enter_critical_section();

#if EVENT_CHECK
	ASSERT(e->magic == EVENT_MAGIC);
8f622bec:	e5952000 	ldr	r2, [r5]
8f622bf0:	e3063e74 	movw	r3, #28276	; 0x6e74
8f622bf4:	e3463576 	movt	r3, #25974	; 0x6576
8f622bf8:	e1520003 	cmp	r2, r3
8f622bfc:	1a000024 	bne	8f622c94 <event_signal+0xe8>
#endif

	if (!e->signalled) {
8f622c00:	e5952004 	ldr	r2, [r5, #4]
8f622c04:	e3520000 	cmp	r2, #0
8f622c08:	1a000008 	bne	8f622c30 <event_signal+0x84>
		if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
8f622c0c:	e5953008 	ldr	r3, [r5, #8]
8f622c10:	e2133001 	ands	r3, r3, #1
8f622c14:	0a000013 	beq	8f622c68 <event_signal+0xbc>
			/* try to release one thread and leave unsignalled if successful */
			if (wait_queue_wake_one(&e->wait, reschedule, NO_ERROR) <= 0) {
8f622c18:	e285000c 	add	r0, r5, #12
8f622c1c:	e1a01006 	mov	r1, r6
8f622c20:	eb0006c9 	bl	8f62474c <wait_queue_wake_one>
8f622c24:	e3500000 	cmp	r0, #0
				/*
				 * if we didn't actually find a thread to wake up, go to
				 * signalled state and let the next call to event_wait
				 * unsignal the event.
				 */
				e->signalled = true;
8f622c28:	d3a03001 	movle	r3, #1
8f622c2c:	d5853004 	strle	r3, [r5, #4]
	critical_section_count--;
8f622c30:	e5943000 	ldr	r3, [r4]
8f622c34:	e2433001 	sub	r3, r3, #1
8f622c38:	e5843000 	str	r3, [r4]
	if (critical_section_count == 0)
8f622c3c:	e3530000 	cmp	r3, #0
8f622c40:	0a00000f 	beq	8f622c84 <event_signal+0xd8>
	}

	exit_critical_section();

	return NO_ERROR;
}
8f622c44:	e59f3078 	ldr	r3, [pc, #120]	; 8f622cc4 <event_signal+0x118>
8f622c48:	e5932000 	ldr	r2, [r3]
8f622c4c:	e59d300c 	ldr	r3, [r13, #12]
8f622c50:	e0332002 	eors	r2, r3, r2
8f622c54:	e3a03000 	mov	r3, #0
8f622c58:	1a000018 	bne	8f622cc0 <event_signal+0x114>
8f622c5c:	e3a00000 	mov	r0, #0
8f622c60:	e28dd014 	add	r13, r13, #20
8f622c64:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
			e->signalled = true;
8f622c68:	e3a00001 	mov	r0, #1
			wait_queue_wake_all(&e->wait, reschedule, NO_ERROR);
8f622c6c:	e1a02003 	mov	r2, r3
			e->signalled = true;
8f622c70:	e5850004 	str	r0, [r5, #4]
			wait_queue_wake_all(&e->wait, reschedule, NO_ERROR);
8f622c74:	e1a01006 	mov	r1, r6
8f622c78:	e285000c 	add	r0, r5, #12
8f622c7c:	eb00071b 	bl	8f6248f0 <wait_queue_wake_all>
8f622c80:	eaffffea 	b	8f622c30 <event_signal+0x84>
		arch_enable_ints();
8f622c84:	ebfff8df 	bl	8f621008 <arch_enable_ints>
8f622c88:	eaffffed 	b	8f622c44 <event_signal+0x98>
		arch_disable_ints();
8f622c8c:	ebfff8e1 	bl	8f621018 <arch_disable_ints>
8f622c90:	eaffffd5 	b	8f622bec <event_signal+0x40>
	ASSERT(e->magic == EVENT_MAGIC);
8f622c94:	e3073c50 	movw	r3, #31824	; 0x7c50
8f622c98:	e1a00007 	mov	r0, r7
8f622c9c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f622ca0:	e3072c40 	movw	r2, #31808	; 0x7c40
8f622ca4:	e58d3000 	str	r3, [r13]
8f622ca8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f622cac:	e3a030a9 	mov	r3, #169	; 0xa9
8f622cb0:	e3001130 	movw	r1, #304	; 0x130
8f622cb4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f622cb8:	eb003f7f 	bl	8f632abc <_panic>
8f622cbc:	eaffffcf 	b	8f622c00 <event_signal+0x54>
}
8f622cc0:	eb003fbe 	bl	8f632bc0 <__stack_chk_fail>
8f622cc4:	8f74221c 	.word	0x8f74221c

8f622cc8 <event_unsignal>:
 * @param e  Event object
 *
 * @return  Returns NO_ERROR on success.
 */
status_t event_unsignal(event_t *e)
{
8f622cc8:	e92d4070 	push	{r4, r5, r6, r14}
	critical_section_count++;
8f622ccc:	e3014acc 	movw	r4, #6860	; 0x1acc
8f622cd0:	e3484f71 	movt	r4, #36721	; 0x8f71
8f622cd4:	e59f20bc 	ldr	r2, [pc, #188]	; 8f622d98 <event_unsignal+0xd0>
8f622cd8:	e24dd010 	sub	r13, r13, #16
8f622cdc:	e1a0600e 	mov	r6, r14
8f622ce0:	e5943000 	ldr	r3, [r4]
8f622ce4:	e5922000 	ldr	r2, [r2]
8f622ce8:	e58d200c 	str	r2, [r13, #12]
8f622cec:	e3a02000 	mov	r2, #0
8f622cf0:	e1a05000 	mov	r5, r0
8f622cf4:	e2833001 	add	r3, r3, #1
8f622cf8:	e5843000 	str	r3, [r4]
	if (critical_section_count == 1)
8f622cfc:	e3530001 	cmp	r3, #1
8f622d00:	0a000016 	beq	8f622d60 <event_unsignal+0x98>
	enter_critical_section();

#if EVENT_CHECK
	ASSERT(e->magic == EVENT_MAGIC);
8f622d04:	e5952000 	ldr	r2, [r5]
8f622d08:	e3063e74 	movw	r3, #28276	; 0x6e74
8f622d0c:	e3463576 	movt	r3, #25974	; 0x6576
8f622d10:	e1520003 	cmp	r2, r3
8f622d14:	1a000013 	bne	8f622d68 <event_unsignal+0xa0>
	critical_section_count--;
8f622d18:	e5943000 	ldr	r3, [r4]
#endif

	e->signalled = false;
8f622d1c:	e3a02000 	mov	r2, #0
8f622d20:	e5852004 	str	r2, [r5, #4]
8f622d24:	e2433001 	sub	r3, r3, #1
8f622d28:	e5843000 	str	r3, [r4]
	if (critical_section_count == 0)
8f622d2c:	e1530002 	cmp	r3, r2
8f622d30:	0a000008 	beq	8f622d58 <event_unsignal+0x90>

	exit_critical_section();

	return NO_ERROR;
}
8f622d34:	e59f305c 	ldr	r3, [pc, #92]	; 8f622d98 <event_unsignal+0xd0>
8f622d38:	e5932000 	ldr	r2, [r3]
8f622d3c:	e59d300c 	ldr	r3, [r13, #12]
8f622d40:	e0332002 	eors	r2, r3, r2
8f622d44:	e3a03000 	mov	r3, #0
8f622d48:	1a000011 	bne	8f622d94 <event_unsignal+0xcc>
8f622d4c:	e3a00000 	mov	r0, #0
8f622d50:	e28dd010 	add	r13, r13, #16
8f622d54:	e8bd8070 	pop	{r4, r5, r6, r15}
		arch_enable_ints();
8f622d58:	ebfff8aa 	bl	8f621008 <arch_enable_ints>
8f622d5c:	eafffff4 	b	8f622d34 <event_unsignal+0x6c>
		arch_disable_ints();
8f622d60:	ebfff8ac 	bl	8f621018 <arch_disable_ints>
8f622d64:	eaffffe6 	b	8f622d04 <event_unsignal+0x3c>
	ASSERT(e->magic == EVENT_MAGIC);
8f622d68:	e3071c50 	movw	r1, #31824	; 0x7c50
8f622d6c:	e3072c40 	movw	r2, #31808	; 0x7c40
8f622d70:	e3481f70 	movt	r1, #36720	; 0x8f70
8f622d74:	e3482f70 	movt	r2, #36720	; 0x8f70
8f622d78:	e58d1000 	str	r1, [r13]
8f622d7c:	e3a030d4 	mov	r3, #212	; 0xd4
8f622d80:	e1a00006 	mov	r0, r6
8f622d84:	e3001130 	movw	r1, #304	; 0x130
8f622d88:	e3481f70 	movt	r1, #36720	; 0x8f70
8f622d8c:	eb003f4a 	bl	8f632abc <_panic>
8f622d90:	eaffffe0 	b	8f622d18 <event_unsignal+0x50>
}
8f622d94:	eb003f89 	bl	8f632bc0 <__stack_chk_fail>
8f622d98:	8f74221c 	.word	0x8f74221c

8f622d9c <bootstrap2>:
}

int main(void);

static int bootstrap2(void *arg)
{
8f622d9c:	e59f3080 	ldr	r3, [pc, #128]	; 8f622e24 <bootstrap2+0x88>
	dprintf(SPEW, "top of bootstrap2()\n");
8f622da0:	e3070c68 	movw	r0, #31848	; 0x7c68
{
8f622da4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	dprintf(SPEW, "top of bootstrap2()\n");
8f622da8:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f622dac:	e24dd00c 	sub	r13, r13, #12
8f622db0:	e5933000 	ldr	r3, [r3]
8f622db4:	e58d3004 	str	r3, [r13, #4]
8f622db8:	e3a03000 	mov	r3, #0
	dprintf(SPEW, "top of bootstrap2()\n");
8f622dbc:	eb003eec 	bl	8f632974 <_dprintf>

	arch_init();
8f622dc0:	ebfff7c6 	bl	8f620ce0 <arch_init>

	// XXX put this somewhere else
#if WITH_LIB_BIO
	bio_init();
8f622dc4:	eb00525a 	bl	8f637734 <bio_init>
#endif
#if WITH_LIB_FS
	fs_init();
8f622dc8:	eb00538a 	bl	8f637bf8 <fs_init>
#endif

	// initialize the rest of the platform
	dprintf(SPEW, "initializing platform\n");
8f622dcc:	e3070c80 	movw	r0, #31872	; 0x7c80
8f622dd0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f622dd4:	eb003ee6 	bl	8f632974 <_dprintf>
	platform_init();
8f622dd8:	ebff79bb 	bl	8f6014cc <platform_init>

	// initialize the target
	dprintf(SPEW, "initializing target\n");
8f622ddc:	e3070c98 	movw	r0, #31896	; 0x7c98
8f622de0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f622de4:	eb003ee2 	bl	8f632974 <_dprintf>
	target_init();
8f622de8:	ebff7688 	bl	8f600810 <target_init>

	dprintf(SPEW, "calling apps_init()\n");
8f622dec:	e3070cb0 	movw	r0, #31920	; 0x7cb0
8f622df0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f622df4:	eb003ede 	bl	8f632974 <_dprintf>
	apps_init();
8f622df8:	eb000940 	bl	8f625300 <apps_init>

	return 0;
}
8f622dfc:	e59f3020 	ldr	r3, [pc, #32]	; 8f622e24 <bootstrap2+0x88>
8f622e00:	e5932000 	ldr	r2, [r3]
8f622e04:	e59d3004 	ldr	r3, [r13, #4]
8f622e08:	e0332002 	eors	r2, r3, r2
8f622e0c:	e3a03000 	mov	r3, #0
8f622e10:	1a000002 	bne	8f622e20 <bootstrap2+0x84>
8f622e14:	e3a00000 	mov	r0, #0
8f622e18:	e28dd00c 	add	r13, r13, #12
8f622e1c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f622e20:	eb003f66 	bl	8f632bc0 <__stack_chk_fail>
8f622e24:	8f74221c 	.word	0x8f74221c

8f622e28 <kmain>:
{
8f622e28:	e59f313c 	ldr	r3, [pc, #316]	; 8f622f6c <kmain+0x144>
8f622e2c:	e1a0600e 	mov	r6, r14
8f622e30:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f622e34:	e24dd014 	sub	r13, r13, #20
8f622e38:	e5933000 	ldr	r3, [r3]
8f622e3c:	e58d300c 	str	r3, [r13, #12]
8f622e40:	e3a03000 	mov	r3, #0
	thread_init_early();
8f622e44:	eb00055f 	bl	8f6243c8 <thread_init_early>
	arch_early_init();
8f622e48:	ebfff77f 	bl	8f620c4c <arch_early_init>
	while(ctor != &__ctor_end) {
8f622e4c:	e3045614 	movw	r5, #17940	; 0x4614
	platform_early_init();
8f622e50:	ebff7988 	bl	8f601478 <platform_early_init>
	while(ctor != &__ctor_end) {
8f622e54:	e3485f72 	movt	r5, #36722	; 0x8f72
	target_early_init();
8f622e58:	ebff7577 	bl	8f60043c <target_early_init>
	dprintf(INFO, "welcome to lk\n\n");
8f622e5c:	e3070cc8 	movw	r0, #31944	; 0x7cc8
8f622e60:	e3480f70 	movt	r0, #36720	; 0x8f70
	while(ctor != &__ctor_end) {
8f622e64:	e3044614 	movw	r4, #17940	; 0x4614
	dprintf(INFO, "welcome to lk\n\n");
8f622e68:	eb003ec1 	bl	8f632974 <_dprintf>
	bs_set_timestamp(BS_BL_START);
8f622e6c:	e3a00000 	mov	r0, #0
8f622e70:	ebff909c 	bl	8f6070e8 <bs_set_timestamp>
	while(ctor != &__ctor_end) {
8f622e74:	e3484f72 	movt	r4, #36722	; 0x8f72
	dprintf(SPEW, "calling constructors\n");
8f622e78:	e3070cd8 	movw	r0, #31960	; 0x7cd8
8f622e7c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f622e80:	eb003ebb 	bl	8f632974 <_dprintf>
	while(ctor != &__ctor_end) {
8f622e84:	e1540005 	cmp	r4, r5
8f622e88:	0a000003 	beq	8f622e9c <kmain+0x74>
		func();
8f622e8c:	e4943004 	ldr	r3, [r4], #4
8f622e90:	e12fff33 	blx	r3
	while(ctor != &__ctor_end) {
8f622e94:	e1540005 	cmp	r4, r5
8f622e98:	1afffffb 	bne	8f622e8c <kmain+0x64>
	dprintf(SPEW, "initializing heap\n");
8f622e9c:	e3070cf0 	movw	r0, #31984	; 0x7cf0
8f622ea0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f622ea4:	eb003eb2 	bl	8f632974 <_dprintf>
	heap_init();
8f622ea8:	eb00409a 	bl	8f633118 <heap_init>
	__stack_chk_guard_setup();
8f622eac:	ebffc774 	bl	8f614c84 <get_canary>
8f622eb0:	e302321c 	movw	r3, #8732	; 0x221c
8f622eb4:	e3483f74 	movt	r3, #36724	; 0x8f74
8f622eb8:	e1a02000 	mov	r2, r0
	dprintf(SPEW, "initializing threads\n");
8f622ebc:	e3070d04 	movw	r0, #32004	; 0x7d04
8f622ec0:	e3480f70 	movt	r0, #36720	; 0x8f70
	__stack_chk_guard_setup();
8f622ec4:	e5832000 	str	r2, [r3]
	dprintf(SPEW, "initializing threads\n");
8f622ec8:	eb003ea9 	bl	8f632974 <_dprintf>
	thread_init();
8f622ecc:	eb000576 	bl	8f6244ac <thread_init>
	dprintf(SPEW, "initializing dpc\n");
8f622ed0:	e3070d1c 	movw	r0, #32028	; 0x7d1c
8f622ed4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f622ed8:	eb003ea5 	bl	8f632974 <_dprintf>
	dpc_init();
8f622edc:	ebfffe7f 	bl	8f6228e0 <dpc_init>
	dprintf(SPEW, "initializing timers\n");
8f622ee0:	e3070d30 	movw	r0, #32048	; 0x7d30
8f622ee4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f622ee8:	eb003ea1 	bl	8f632974 <_dprintf>
	timer_init();
8f622eec:	eb0008d6 	bl	8f62524c <timer_init>
	dprintf(SPEW, "creating bootstrap completion thread\n");
8f622ef0:	e3070d48 	movw	r0, #32072	; 0x7d48
8f622ef4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f622ef8:	eb003e9d 	bl	8f632974 <_dprintf>
	thr = thread_create("bootstrap2", &bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
8f622efc:	e3a00a03 	mov	r0, #12288	; 0x3000
8f622f00:	e3a03010 	mov	r3, #16
8f622f04:	e58d0000 	str	r0, [r13]
8f622f08:	e3a02000 	mov	r2, #0
8f622f0c:	e3021d9c 	movw	r1, #11676	; 0x2d9c
8f622f10:	e3070d70 	movw	r0, #32112	; 0x7d70
8f622f14:	e3481f62 	movt	r1, #36706	; 0x8f62
8f622f18:	e3480f70 	movt	r0, #36720	; 0x8f70
8f622f1c:	eb0002d6 	bl	8f623a7c <thread_create>
	if (!thr)
8f622f20:	e2504000 	subs	r4, r0, #0
8f622f24:	0a00000b 	beq	8f622f58 <kmain+0x130>
	thread_resume(thr);
8f622f28:	e1a00004 	mov	r0, r4
8f622f2c:	eb0003c3 	bl	8f623e40 <thread_resume>
	critical_section_count--;
8f622f30:	e3012acc 	movw	r2, #6860	; 0x1acc
8f622f34:	e3482f71 	movt	r2, #36721	; 0x8f71
8f622f38:	e5923000 	ldr	r3, [r2]
8f622f3c:	e2433001 	sub	r3, r3, #1
8f622f40:	e5823000 	str	r3, [r2]
	if (critical_section_count == 0)
8f622f44:	e3530000 	cmp	r3, #0
8f622f48:	0a000000 	beq	8f622f50 <kmain+0x128>
	thread_become_idle();
8f622f4c:	eb000566 	bl	8f6244ec <thread_become_idle>
		arch_enable_ints();
8f622f50:	ebfff82c 	bl	8f621008 <arch_enable_ints>
8f622f54:	eafffffc 	b	8f622f4c <kmain+0x124>
		panic("failed to create thread bootstrap2\n");
8f622f58:	e3071d7c 	movw	r1, #32124	; 0x7d7c
8f622f5c:	e1a00006 	mov	r0, r6
8f622f60:	e3481f70 	movt	r1, #36720	; 0x8f70
8f622f64:	eb003ed4 	bl	8f632abc <_panic>
8f622f68:	eaffffee 	b	8f622f28 <kmain+0x100>
8f622f6c:	8f74221c 	.word	0x8f74221c

8f622f70 <mutex_init>:

/**
 * @brief  Initialize a mutex_t
 */
void mutex_init(mutex_t *m)
{
8f622f70:	e59f1050 	ldr	r1, [pc, #80]	; 8f622fc8 <mutex_init+0x58>
#if MUTEX_CHECK
//	ASSERT(m->magic != MUTEX_MAGIC);
#endif

	m->magic = MUTEX_MAGIC;
	m->count = 0;
8f622f74:	e3a03000 	mov	r3, #0
{
8f622f78:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f622f7c:	e24dd00c 	sub	r13, r13, #12
8f622f80:	e5911000 	ldr	r1, [r1]
8f622f84:	e58d1004 	str	r1, [r13, #4]
8f622f88:	e3a01000 	mov	r1, #0
	m->magic = MUTEX_MAGIC;
8f622f8c:	e3072478 	movw	r2, #29816	; 0x7478
	m->holder = 0;
8f622f90:	e5803008 	str	r3, [r0, #8]
	m->magic = MUTEX_MAGIC;
8f622f94:	e3462d75 	movt	r2, #28021	; 0x6d75
8f622f98:	e1c020f0 	strd	r2, [r0]
	wait_queue_init(&m->wait);
8f622f9c:	e59f3024 	ldr	r3, [pc, #36]	; 8f622fc8 <mutex_init+0x58>
8f622fa0:	e5932000 	ldr	r2, [r3]
8f622fa4:	e59d3004 	ldr	r3, [r13, #4]
8f622fa8:	e0332002 	eors	r2, r3, r2
8f622fac:	e3a03000 	mov	r3, #0
8f622fb0:	1a000003 	bne	8f622fc4 <mutex_init+0x54>
8f622fb4:	e280000c 	add	r0, r0, #12
}
8f622fb8:	e28dd00c 	add	r13, r13, #12
8f622fbc:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	wait_queue_init(&m->wait);
8f622fc0:	ea000560 	b	8f624548 <wait_queue_init>
8f622fc4:	eb003efd 	bl	8f632bc0 <__stack_chk_fail>
8f622fc8:	8f74221c 	.word	0x8f74221c

8f622fcc <mutex_acquire>:
 * may wait forever if the mutex never becomes free.
 *
 * @return  NO_ERROR on success, other values on error
 */
status_t mutex_acquire(mutex_t *m)
{
8f622fcc:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	status_t ret = NO_ERROR;

	if (current_thread == m->holder)
8f622fd0:	e3026cc0 	movw	r6, #11456	; 0x2cc0
8f622fd4:	e3486f74 	movt	r6, #36724	; 0x8f74
8f622fd8:	e5902008 	ldr	r2, [r0, #8]
{
8f622fdc:	e59f111c 	ldr	r1, [pc, #284]	; 8f623100 <mutex_acquire+0x134>
8f622fe0:	e24dd014 	sub	r13, r13, #20
	if (current_thread == m->holder)
8f622fe4:	e5963000 	ldr	r3, [r6]
{
8f622fe8:	e1a04000 	mov	r4, r0
8f622fec:	e5911000 	ldr	r1, [r1]
8f622ff0:	e58d100c 	str	r1, [r13, #12]
8f622ff4:	e3a01000 	mov	r1, #0
	if (current_thread == m->holder)
8f622ff8:	e1a0700e 	mov	r7, r14
8f622ffc:	e1520003 	cmp	r2, r3
8f623000:	0a000025 	beq	8f62309c <mutex_acquire+0xd0>
	critical_section_count++;
8f623004:	e3015acc 	movw	r5, #6860	; 0x1acc
8f623008:	e3485f71 	movt	r5, #36721	; 0x8f71
8f62300c:	e5953000 	ldr	r3, [r5]
8f623010:	e2833001 	add	r3, r3, #1
8f623014:	e5853000 	str	r3, [r5]
	if (critical_section_count == 1)
8f623018:	e3530001 	cmp	r3, #1
8f62301c:	0a00001c 	beq	8f623094 <mutex_acquire+0xc8>
				current_thread, current_thread->name, m);

	enter_critical_section();

#if MUTEX_CHECK
	ASSERT(m->magic == MUTEX_MAGIC);
8f623020:	e5942000 	ldr	r2, [r4]
8f623024:	e3073478 	movw	r3, #29816	; 0x7478
8f623028:	e3463d75 	movt	r3, #28021	; 0x6d75
8f62302c:	e1520003 	cmp	r2, r3
8f623030:	1a000020 	bne	8f6230b8 <mutex_acquire+0xec>
#endif

//	dprintf("mutex_acquire: m %p, count %d, curr %p\n", m, m->count, current_thread);

	m->count++;
8f623034:	e5943004 	ldr	r3, [r4, #4]
8f623038:	e2833001 	add	r3, r3, #1
8f62303c:	e5843004 	str	r3, [r4, #4]
	if (unlikely(m->count > 1)) {
8f623040:	e3530001 	cmp	r3, #1
	status_t ret = NO_ERROR;
8f623044:	d3a07000 	movle	r7, #0
	if (unlikely(m->count > 1)) {
8f623048:	ca000025 	bgt	8f6230e4 <mutex_acquire+0x118>
		 */
		ret = wait_queue_block(&m->wait, INFINITE_TIME);
		if (ret < 0)
			goto err;
	}
	m->holder = current_thread;	
8f62304c:	e5963000 	ldr	r3, [r6]
8f623050:	e5843008 	str	r3, [r4, #8]
	critical_section_count--;
8f623054:	e5953000 	ldr	r3, [r5]
8f623058:	e2433001 	sub	r3, r3, #1
8f62305c:	e5853000 	str	r3, [r5]
	if (critical_section_count == 0)
8f623060:	e3530000 	cmp	r3, #0
8f623064:	0a000008 	beq	8f62308c <mutex_acquire+0xc0>

err:
	exit_critical_section();

	return ret;
}
8f623068:	e59f3090 	ldr	r3, [pc, #144]	; 8f623100 <mutex_acquire+0x134>
8f62306c:	e5932000 	ldr	r2, [r3]
8f623070:	e59d300c 	ldr	r3, [r13, #12]
8f623074:	e0332002 	eors	r2, r3, r2
8f623078:	e3a03000 	mov	r3, #0
8f62307c:	1a00001e 	bne	8f6230fc <mutex_acquire+0x130>
8f623080:	e1a00007 	mov	r0, r7
8f623084:	e28dd014 	add	r13, r13, #20
8f623088:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		arch_enable_ints();
8f62308c:	ebfff7dd 	bl	8f621008 <arch_enable_ints>
	return ret;
8f623090:	eafffff4 	b	8f623068 <mutex_acquire+0x9c>
		arch_disable_ints();
8f623094:	ebfff7df 	bl	8f621018 <arch_disable_ints>
8f623098:	eaffffe0 	b	8f623020 <mutex_acquire+0x54>
		panic("mutex_acquire: thread %p (%s) tried to acquire mutex %p it already owns.\n",
8f62309c:	e58d0000 	str	r0, [r13]
8f6230a0:	e2823044 	add	r3, r2, #68	; 0x44
8f6230a4:	e3071dc8 	movw	r1, #32200	; 0x7dc8
8f6230a8:	e1a0000e 	mov	r0, r14
8f6230ac:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6230b0:	eb003e81 	bl	8f632abc <_panic>
8f6230b4:	eaffffd2 	b	8f623004 <mutex_acquire+0x38>
	ASSERT(m->magic == MUTEX_MAGIC);
8f6230b8:	e3073db0 	movw	r3, #32176	; 0x7db0
8f6230bc:	e1a00007 	mov	r0, r7
8f6230c0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6230c4:	e3072da0 	movw	r2, #32160	; 0x7da0
8f6230c8:	e58d3000 	str	r3, [r13]
8f6230cc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6230d0:	e3a03063 	mov	r3, #99	; 0x63
8f6230d4:	e3001130 	movw	r1, #304	; 0x130
8f6230d8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6230dc:	eb003e76 	bl	8f632abc <_panic>
8f6230e0:	eaffffd3 	b	8f623034 <mutex_acquire+0x68>
		ret = wait_queue_block(&m->wait, INFINITE_TIME);
8f6230e4:	e284000c 	add	r0, r4, #12
8f6230e8:	e3e01000 	mvn	r1, #0
8f6230ec:	eb00052d 	bl	8f6245a8 <wait_queue_block>
		if (ret < 0)
8f6230f0:	e2507000 	subs	r7, r0, #0
8f6230f4:	aaffffd4 	bge	8f62304c <mutex_acquire+0x80>
8f6230f8:	eaffffd5 	b	8f623054 <mutex_acquire+0x88>
}
8f6230fc:	eb003eaf 	bl	8f632bc0 <__stack_chk_fail>
8f623100:	8f74221c 	.word	0x8f74221c

8f623104 <mutex_release>:
/**
 * @brief  Release mutex
 */
status_t mutex_release(mutex_t *m)
{
	if (current_thread != m->holder)
8f623104:	e3023cc0 	movw	r3, #11456	; 0x2cc0
8f623108:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62310c:	e5901008 	ldr	r1, [r0, #8]
8f623110:	e5932000 	ldr	r2, [r3]
{
8f623114:	e59f3124 	ldr	r3, [pc, #292]	; 8f623240 <mutex_release+0x13c>
	if (current_thread != m->holder)
8f623118:	e1510002 	cmp	r1, r2
{
8f62311c:	e92d4070 	push	{r4, r5, r6, r14}
8f623120:	e24dd018 	sub	r13, r13, #24
8f623124:	e5933000 	ldr	r3, [r3]
8f623128:	e58d3014 	str	r3, [r13, #20]
8f62312c:	e3a03000 	mov	r3, #0
8f623130:	e1a04000 	mov	r4, r0
8f623134:	e1a0600e 	mov	r6, r14
	if (current_thread != m->holder)
8f623138:	0a00000b 	beq	8f62316c <mutex_release+0x68>
		panic("mutex_release: thread %p (%s) tried to release mutex %p it doesn't own. owned by %p (%s)\n", 
8f62313c:	e3510000 	cmp	r1, #0
8f623140:	e58d1004 	str	r1, [r13, #4]
8f623144:	12810044 	addne	r0, r1, #68	; 0x44
8f623148:	e2823044 	add	r3, r2, #68	; 0x44
8f62314c:	03070e14 	movweq	r0, #32276	; 0x7e14
8f623150:	e3071e1c 	movw	r1, #32284	; 0x7e1c
8f623154:	03480f70 	movteq	r0, #36720	; 0x8f70
8f623158:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62315c:	e58d0008 	str	r0, [r13, #8]
8f623160:	e1a0000e 	mov	r0, r14
8f623164:	e58d4000 	str	r4, [r13]
8f623168:	eb003e53 	bl	8f632abc <_panic>
	critical_section_count++;
8f62316c:	e3015acc 	movw	r5, #6860	; 0x1acc
8f623170:	e3485f71 	movt	r5, #36721	; 0x8f71
8f623174:	e5953000 	ldr	r3, [r5]
8f623178:	e2833001 	add	r3, r3, #1
8f62317c:	e5853000 	str	r3, [r5]
	if (critical_section_count == 1)
8f623180:	e3530001 	cmp	r3, #1
8f623184:	0a00001b 	beq	8f6231f8 <mutex_release+0xf4>
				current_thread, current_thread->name, m, m->holder, m->holder ? m->holder->name : "none");

	enter_critical_section();

#if MUTEX_CHECK
	ASSERT(m->magic == MUTEX_MAGIC);
8f623188:	e5942000 	ldr	r2, [r4]
8f62318c:	e3073478 	movw	r3, #29816	; 0x7478
8f623190:	e3463d75 	movt	r3, #28021	; 0x6d75
8f623194:	e1520003 	cmp	r2, r3
8f623198:	1a00001c 	bne	8f623210 <mutex_release+0x10c>
#endif

//	dprintf("mutex_release: m %p, count %d, holder %p, curr %p\n", m, m->count, m->holder, current_thread);

	m->holder = 0;
	m->count--;
8f62319c:	e5943004 	ldr	r3, [r4, #4]
	m->holder = 0;
8f6231a0:	e3a02000 	mov	r2, #0
8f6231a4:	e5842008 	str	r2, [r4, #8]
	m->count--;
8f6231a8:	e2433001 	sub	r3, r3, #1
8f6231ac:	e5843004 	str	r3, [r4, #4]
	if (unlikely(m->count >= 1)) {
8f6231b0:	e1530002 	cmp	r3, r2
8f6231b4:	ca000011 	bgt	8f623200 <mutex_release+0xfc>
	critical_section_count--;
8f6231b8:	e5953000 	ldr	r3, [r5]
8f6231bc:	e2433001 	sub	r3, r3, #1
8f6231c0:	e5853000 	str	r3, [r5]
	if (critical_section_count == 0)
8f6231c4:	e3530000 	cmp	r3, #0
8f6231c8:	0a000008 	beq	8f6231f0 <mutex_release+0xec>
	}

	exit_critical_section();

	return NO_ERROR;
}
8f6231cc:	e59f306c 	ldr	r3, [pc, #108]	; 8f623240 <mutex_release+0x13c>
8f6231d0:	e5932000 	ldr	r2, [r3]
8f6231d4:	e59d3014 	ldr	r3, [r13, #20]
8f6231d8:	e0332002 	eors	r2, r3, r2
8f6231dc:	e3a03000 	mov	r3, #0
8f6231e0:	1a000015 	bne	8f62323c <mutex_release+0x138>
8f6231e4:	e3a00000 	mov	r0, #0
8f6231e8:	e28dd018 	add	r13, r13, #24
8f6231ec:	e8bd8070 	pop	{r4, r5, r6, r15}
		arch_enable_ints();
8f6231f0:	ebfff784 	bl	8f621008 <arch_enable_ints>
8f6231f4:	eafffff4 	b	8f6231cc <mutex_release+0xc8>
		arch_disable_ints();
8f6231f8:	ebfff786 	bl	8f621018 <arch_disable_ints>
8f6231fc:	eaffffe1 	b	8f623188 <mutex_release+0x84>
		wait_queue_wake_one(&m->wait, true, NO_ERROR);
8f623200:	e284000c 	add	r0, r4, #12
8f623204:	e3a01001 	mov	r1, #1
8f623208:	eb00054f 	bl	8f62474c <wait_queue_wake_one>
8f62320c:	eaffffe9 	b	8f6231b8 <mutex_release+0xb4>
	ASSERT(m->magic == MUTEX_MAGIC);
8f623210:	e3071db0 	movw	r1, #32176	; 0x7db0
8f623214:	e3072da0 	movw	r2, #32160	; 0x7da0
8f623218:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62321c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623220:	e58d1000 	str	r1, [r13]
8f623224:	e3a030bf 	mov	r3, #191	; 0xbf
8f623228:	e1a00006 	mov	r0, r6
8f62322c:	e3001130 	movw	r1, #304	; 0x130
8f623230:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623234:	eb003e20 	bl	8f632abc <_panic>
8f623238:	eaffffd7 	b	8f62319c <mutex_release+0x98>
}
8f62323c:	eb003e5f 	bl	8f632bc0 <__stack_chk_fail>
8f623240:	8f74221c 	.word	0x8f74221c

8f623244 <insert_in_run_queue_head>:

/* run queue manipulation */
static void insert_in_run_queue_head(thread_t *t)
{
#if THREAD_CHECKS
	ASSERT(t->magic == THREAD_MAGIC);
8f623244:	e5902000 	ldr	r2, [r0]
8f623248:	e3073264 	movw	r3, #29284	; 0x7264
8f62324c:	e3473468 	movt	r3, #29800	; 0x7468
{
8f623250:	e59f116c 	ldr	r1, [pc, #364]	; 8f6233c4 <insert_in_run_queue_head+0x180>
	ASSERT(t->magic == THREAD_MAGIC);
8f623254:	e1520003 	cmp	r2, r3
{
8f623258:	e92d4030 	push	{r4, r5, r14}
8f62325c:	e24dd014 	sub	r13, r13, #20
8f623260:	e5911000 	ldr	r1, [r1]
8f623264:	e58d100c 	str	r1, [r13, #12]
8f623268:	e3a01000 	mov	r1, #0
8f62326c:	e1a04000 	mov	r4, r0
8f623270:	e1a0500e 	mov	r5, r14
	ASSERT(t->magic == THREAD_MAGIC);
8f623274:	1a000046 	bne	8f623394 <insert_in_run_queue_head+0x150>
	ASSERT(t->state == THREAD_READY);
8f623278:	e5d43018 	ldrb	r3, [r4, #24]
8f62327c:	e3530001 	cmp	r3, #1
8f623280:	1a00002d 	bne	8f62333c <insert_in_run_queue_head+0xf8>
	if (item->prev == 0 && item->next == 0)
8f623284:	e594300c 	ldr	r3, [r4, #12]
8f623288:	e3530000 	cmp	r3, #0
8f62328c:	0a000026 	beq	8f62332c <insert_in_run_queue_head+0xe8>
	ASSERT(!list_in_list(&t->queue_node));
8f623290:	e3070ec0 	movw	r0, #32448	; 0x7ec0
8f623294:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623298:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62329c:	e3001130 	movw	r1, #304	; 0x130
8f6232a0:	e58d0000 	str	r0, [r13]
8f6232a4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6232a8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6232ac:	e3a03057 	mov	r3, #87	; 0x57
8f6232b0:	e1a00005 	mov	r0, r5
8f6232b4:	eb003e00 	bl	8f632abc <_panic>
	return critical_section_count > 0;
8f6232b8:	e3013acc 	movw	r3, #6860	; 0x1acc
8f6232bc:	e3483f71 	movt	r3, #36721	; 0x8f71
	ASSERT(in_critical_section());
8f6232c0:	e5933000 	ldr	r3, [r3]
8f6232c4:	e3530000 	cmp	r3, #0
8f6232c8:	da000026 	ble	8f623368 <insert_in_run_queue_head+0x124>
#endif

	list_add_head(&run_queue[t->priority], &t->queue_node);
8f6232cc:	e594c014 	ldr	r12, [r4, #20]
	run_queue_bitmap |= (1<<t->priority);
8f6232d0:	e3042180 	movw	r2, #16768	; 0x4180
8f6232d4:	e3482f73 	movt	r2, #36723	; 0x8f73
	item->next = list->next;
8f6232d8:	e3043080 	movw	r3, #16512	; 0x4080
8f6232dc:	e3483f73 	movt	r3, #36723	; 0x8f73
8f6232e0:	e3a0e001 	mov	r14, #1
8f6232e4:	e5921000 	ldr	r1, [r2]
8f6232e8:	e083318c 	add	r3, r3, r12, lsl #3
	list_add_head(&run_queue[t->priority], &t->queue_node);
8f6232ec:	e284000c 	add	r0, r4, #12
	run_queue_bitmap |= (1<<t->priority);
8f6232f0:	e1811c1e 	orr	r1, r1, r14, lsl r12
8f6232f4:	e5821000 	str	r1, [r2]
8f6232f8:	e5932004 	ldr	r2, [r3, #4]
	item->prev = list;
8f6232fc:	e584300c 	str	r3, [r4, #12]
	item->next = list->next;
8f623300:	e5842010 	str	r2, [r4, #16]
	list->next->prev = item;
8f623304:	e5820000 	str	r0, [r2]
	list->next = item;
8f623308:	e5830004 	str	r0, [r3, #4]
}
8f62330c:	e59f30b0 	ldr	r3, [pc, #176]	; 8f6233c4 <insert_in_run_queue_head+0x180>
8f623310:	e5932000 	ldr	r2, [r3]
8f623314:	e59d300c 	ldr	r3, [r13, #12]
8f623318:	e0332002 	eors	r2, r3, r2
8f62331c:	e3a03000 	mov	r3, #0
8f623320:	1a000026 	bne	8f6233c0 <insert_in_run_queue_head+0x17c>
8f623324:	e28dd014 	add	r13, r13, #20
8f623328:	e8bd8030 	pop	{r4, r5, r15}
	if (item->prev == 0 && item->next == 0)
8f62332c:	e5943010 	ldr	r3, [r4, #16]
8f623330:	e3530000 	cmp	r3, #0
8f623334:	1affffd5 	bne	8f623290 <insert_in_run_queue_head+0x4c>
8f623338:	eaffffde 	b	8f6232b8 <insert_in_run_queue_head+0x74>
	ASSERT(t->state == THREAD_READY);
8f62333c:	e3070ea4 	movw	r0, #32420	; 0x7ea4
8f623340:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623344:	e3480f70 	movt	r0, #36720	; 0x8f70
8f623348:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62334c:	e58d0000 	str	r0, [r13]
8f623350:	e3001130 	movw	r1, #304	; 0x130
8f623354:	e3a03056 	mov	r3, #86	; 0x56
8f623358:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62335c:	e1a00005 	mov	r0, r5
8f623360:	eb003dd5 	bl	8f632abc <_panic>
8f623364:	eaffffc6 	b	8f623284 <insert_in_run_queue_head+0x40>
	ASSERT(in_critical_section());
8f623368:	e307cee0 	movw	r12, #32480	; 0x7ee0
8f62336c:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623370:	e348cf70 	movt	r12, #36720	; 0x8f70
8f623374:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623378:	e3001130 	movw	r1, #304	; 0x130
8f62337c:	e3a03058 	mov	r3, #88	; 0x58
8f623380:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623384:	e1a00005 	mov	r0, r5
8f623388:	e58dc000 	str	r12, [r13]
8f62338c:	eb003dca 	bl	8f632abc <_panic>
8f623390:	eaffffcd 	b	8f6232cc <insert_in_run_queue_head+0x88>
	ASSERT(t->magic == THREAD_MAGIC);
8f623394:	e3070e88 	movw	r0, #32392	; 0x7e88
8f623398:	e3072e78 	movw	r2, #32376	; 0x7e78
8f62339c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6233a0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6233a4:	e58d0000 	str	r0, [r13]
8f6233a8:	e3001130 	movw	r1, #304	; 0x130
8f6233ac:	e3a03055 	mov	r3, #85	; 0x55
8f6233b0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6233b4:	e1a0000e 	mov	r0, r14
8f6233b8:	eb003dbf 	bl	8f632abc <_panic>
8f6233bc:	eaffffad 	b	8f623278 <insert_in_run_queue_head+0x34>
}
8f6233c0:	eb003dfe 	bl	8f632bc0 <__stack_chk_fail>
8f6233c4:	8f74221c 	.word	0x8f74221c

8f6233c8 <thread_cleanup_dpc>:

	return NO_ERROR;
}

static void thread_cleanup_dpc(void *thread)
{
8f6233c8:	e92d4030 	push	{r4, r5, r14}
8f6233cc:	e24dd014 	sub	r13, r13, #20
	thread_t *t = (thread_t *)thread;

//	dprintf(SPEW, "thread_cleanup_dpc: thread %p (%s)\n", t, t->name);

#if THREAD_CHECKS
	ASSERT(t->state == THREAD_DEATH);
8f6233d0:	e5d03018 	ldrb	r3, [r0, #24]
{
8f6233d4:	e1a04000 	mov	r4, r0
8f6233d8:	e59f2170 	ldr	r2, [pc, #368]	; 8f623550 <thread_cleanup_dpc+0x188>
8f6233dc:	e1a0500e 	mov	r5, r14
	ASSERT(t->state == THREAD_DEATH);
8f6233e0:	e3530005 	cmp	r3, #5
{
8f6233e4:	e5922000 	ldr	r2, [r2]
8f6233e8:	e58d200c 	str	r2, [r13, #12]
8f6233ec:	e3a02000 	mov	r2, #0
	ASSERT(t->state == THREAD_DEATH);
8f6233f0:	1a00004a 	bne	8f623520 <thread_cleanup_dpc+0x158>
	ASSERT(t->blocking_wait_queue == NULL);
8f6233f4:	e5943024 	ldr	r3, [r4, #36]	; 0x24
8f6233f8:	e3530000 	cmp	r3, #0
8f6233fc:	1a00003c 	bne	8f6234f4 <thread_cleanup_dpc+0x12c>
8f623400:	e594300c 	ldr	r3, [r4, #12]
8f623404:	e3530000 	cmp	r3, #0
8f623408:	0a000026 	beq	8f6234a8 <thread_cleanup_dpc+0xe0>
	ASSERT(!list_in_list(&t->queue_node));
8f62340c:	e307cec0 	movw	r12, #32448	; 0x7ec0
8f623410:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623414:	e348cf70 	movt	r12, #36720	; 0x8f70
8f623418:	e3001130 	movw	r1, #304	; 0x130
8f62341c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623420:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623424:	e3a030df 	mov	r3, #223	; 0xdf
8f623428:	e1a00005 	mov	r0, r5
8f62342c:	e58dc000 	str	r12, [r13]
8f623430:	eb003da1 	bl	8f632abc <_panic>
	critical_section_count++;
8f623434:	e3015acc 	movw	r5, #6860	; 0x1acc
8f623438:	e3485f71 	movt	r5, #36721	; 0x8f71
8f62343c:	e5952000 	ldr	r2, [r5]
8f623440:	e2823001 	add	r3, r2, #1
8f623444:	e5853000 	str	r3, [r5]
	if (critical_section_count == 1)
8f623448:	e3530001 	cmp	r3, #1
8f62344c:	0a000019 	beq	8f6234b8 <thread_cleanup_dpc+0xf0>
	item->next->prev = item->prev;
8f623450:	e5943004 	ldr	r3, [r4, #4]
8f623454:	e5941008 	ldr	r1, [r4, #8]
8f623458:	e5813000 	str	r3, [r1]
	item->prev->next = item->next;
8f62345c:	e5831004 	str	r1, [r3, #4]
	item->prev = item->next = 0;
8f623460:	e3a03000 	mov	r3, #0
	critical_section_count--;
8f623464:	e5852000 	str	r2, [r5]
8f623468:	e5843008 	str	r3, [r4, #8]
8f62346c:	e5843004 	str	r3, [r4, #4]
	enter_critical_section();
	list_delete(&t->thread_list_node);
	exit_critical_section();

	/* free its stack and the thread structure itself */
	if (t->stack)
8f623470:	e5940030 	ldr	r0, [r4, #48]	; 0x30
8f623474:	e3500000 	cmp	r0, #0
8f623478:	0a000000 	beq	8f623480 <thread_cleanup_dpc+0xb8>
		free(t->stack);
8f62347c:	eb004322 	bl	8f63410c <free>

	free(t);
8f623480:	e59f30c8 	ldr	r3, [pc, #200]	; 8f623550 <thread_cleanup_dpc+0x188>
8f623484:	e5932000 	ldr	r2, [r3]
8f623488:	e59d300c 	ldr	r3, [r13, #12]
8f62348c:	e0332002 	eors	r2, r3, r2
8f623490:	e3a03000 	mov	r3, #0
8f623494:	1a00002c 	bne	8f62354c <thread_cleanup_dpc+0x184>
8f623498:	e1a00004 	mov	r0, r4
}
8f62349c:	e28dd014 	add	r13, r13, #20
8f6234a0:	e8bd4030 	pop	{r4, r5, r14}
	free(t);
8f6234a4:	ea004318 	b	8f63410c <free>
	if (item->prev == 0 && item->next == 0)
8f6234a8:	e5943010 	ldr	r3, [r4, #16]
8f6234ac:	e3530000 	cmp	r3, #0
8f6234b0:	1affffd5 	bne	8f62340c <thread_cleanup_dpc+0x44>
8f6234b4:	eaffffde 	b	8f623434 <thread_cleanup_dpc+0x6c>
		arch_disable_ints();
8f6234b8:	ebfff6d6 	bl	8f621018 <arch_disable_ints>
	critical_section_count--;
8f6234bc:	e5953000 	ldr	r3, [r5]
	item->next->prev = item->prev;
8f6234c0:	e5941008 	ldr	r1, [r4, #8]
8f6234c4:	e5942004 	ldr	r2, [r4, #4]
8f6234c8:	e2433001 	sub	r3, r3, #1
	if (critical_section_count == 0)
8f6234cc:	e3530000 	cmp	r3, #0
8f6234d0:	e5812000 	str	r2, [r1]
	item->prev->next = item->next;
8f6234d4:	e5821004 	str	r1, [r2, #4]
	critical_section_count--;
8f6234d8:	e5853000 	str	r3, [r5]
	item->prev = item->next = 0;
8f6234dc:	e3a03000 	mov	r3, #0
8f6234e0:	e5843008 	str	r3, [r4, #8]
8f6234e4:	e5843004 	str	r3, [r4, #4]
	if (critical_section_count == 0)
8f6234e8:	1affffe0 	bne	8f623470 <thread_cleanup_dpc+0xa8>
		arch_enable_ints();
8f6234ec:	ebfff6c5 	bl	8f621008 <arch_enable_ints>
8f6234f0:	eaffffde 	b	8f623470 <thread_cleanup_dpc+0xa8>
	ASSERT(t->blocking_wait_queue == NULL);
8f6234f4:	e3070f14 	movw	r0, #32532	; 0x7f14
8f6234f8:	e3072e78 	movw	r2, #32376	; 0x7e78
8f6234fc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f623500:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623504:	e58d0000 	str	r0, [r13]
8f623508:	e3001130 	movw	r1, #304	; 0x130
8f62350c:	e3a030de 	mov	r3, #222	; 0xde
8f623510:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623514:	e1a00005 	mov	r0, r5
8f623518:	eb003d67 	bl	8f632abc <_panic>
8f62351c:	eaffffb7 	b	8f623400 <thread_cleanup_dpc+0x38>
	ASSERT(t->state == THREAD_DEATH);
8f623520:	e3070ef8 	movw	r0, #32504	; 0x7ef8
8f623524:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623528:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62352c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623530:	e58d0000 	str	r0, [r13]
8f623534:	e3001130 	movw	r1, #304	; 0x130
8f623538:	e3a030dd 	mov	r3, #221	; 0xdd
8f62353c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623540:	e1a0000e 	mov	r0, r14
8f623544:	eb003d5c 	bl	8f632abc <_panic>
8f623548:	eaffffa9 	b	8f6233f4 <thread_cleanup_dpc+0x2c>
	free(t);
8f62354c:	eb003d9b 	bl	8f632bc0 <__stack_chk_fail>
8f623550:	8f74221c 	.word	0x8f74221c

8f623554 <thread_sleep_handler>:
		return INT_NO_RESCHEDULE;
}

/* timer callback to wake up a sleeping thread */
static enum handler_return thread_sleep_handler(timer_t *timer, time_t now, void *arg)
{
8f623554:	e92d4030 	push	{r4, r5, r14}
8f623558:	e1a04002 	mov	r4, r2
	thread_t *t = (thread_t *)arg;

#if THREAD_CHECKS
	ASSERT(t->magic == THREAD_MAGIC);
8f62355c:	e5922000 	ldr	r2, [r2]
8f623560:	e3073264 	movw	r3, #29284	; 0x7264
8f623564:	e3473468 	movt	r3, #29800	; 0x7468
{
8f623568:	e59f10bc 	ldr	r1, [pc, #188]	; 8f62362c <thread_sleep_handler+0xd8>
	ASSERT(t->magic == THREAD_MAGIC);
8f62356c:	e1520003 	cmp	r2, r3
{
8f623570:	e24dd014 	sub	r13, r13, #20
8f623574:	e5911000 	ldr	r1, [r1]
8f623578:	e58d100c 	str	r1, [r13, #12]
8f62357c:	e3a01000 	mov	r1, #0
	ASSERT(t->magic == THREAD_MAGIC);
8f623580:	e1a0500e 	mov	r5, r14
8f623584:	1a00000f 	bne	8f6235c8 <thread_sleep_handler+0x74>
	ASSERT(t->state == THREAD_SLEEPING);
8f623588:	e5d43018 	ldrb	r3, [r4, #24]
8f62358c:	e3530004 	cmp	r3, #4
8f623590:	1a000019 	bne	8f6235fc <thread_sleep_handler+0xa8>
#endif

	t->state = THREAD_READY;
8f623594:	e3a05001 	mov	r5, #1
	insert_in_run_queue_head(t);
8f623598:	e1a00004 	mov	r0, r4
	t->state = THREAD_READY;
8f62359c:	e5c45018 	strb	r5, [r4, #24]
	insert_in_run_queue_head(t);
8f6235a0:	ebffff27 	bl	8f623244 <insert_in_run_queue_head>

	return INT_RESCHEDULE;
}
8f6235a4:	e59f3080 	ldr	r3, [pc, #128]	; 8f62362c <thread_sleep_handler+0xd8>
8f6235a8:	e5932000 	ldr	r2, [r3]
8f6235ac:	e59d300c 	ldr	r3, [r13, #12]
8f6235b0:	e0332002 	eors	r2, r3, r2
8f6235b4:	e3a03000 	mov	r3, #0
8f6235b8:	1a00001a 	bne	8f623628 <thread_sleep_handler+0xd4>
8f6235bc:	e1a00005 	mov	r0, r5
8f6235c0:	e28dd014 	add	r13, r13, #20
8f6235c4:	e8bd8030 	pop	{r4, r5, r15}
	ASSERT(t->magic == THREAD_MAGIC);
8f6235c8:	e3a03e1f 	mov	r3, #496	; 0x1f0
8f6235cc:	e3070e88 	movw	r0, #32392	; 0x7e88
8f6235d0:	e3072e78 	movw	r2, #32376	; 0x7e78
8f6235d4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6235d8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6235dc:	e58d0000 	str	r0, [r13]
8f6235e0:	e3001130 	movw	r1, #304	; 0x130
8f6235e4:	e1a0000e 	mov	r0, r14
8f6235e8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6235ec:	eb003d32 	bl	8f632abc <_panic>
	ASSERT(t->state == THREAD_SLEEPING);
8f6235f0:	e5d43018 	ldrb	r3, [r4, #24]
8f6235f4:	e3530004 	cmp	r3, #4
8f6235f8:	0affffe5 	beq	8f623594 <thread_sleep_handler+0x40>
8f6235fc:	e307cf34 	movw	r12, #32564	; 0x7f34
8f623600:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623604:	e348cf70 	movt	r12, #36720	; 0x8f70
8f623608:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62360c:	e3001130 	movw	r1, #304	; 0x130
8f623610:	e30031f1 	movw	r3, #497	; 0x1f1
8f623614:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623618:	e1a00005 	mov	r0, r5
8f62361c:	e58dc000 	str	r12, [r13]
8f623620:	eb003d25 	bl	8f632abc <_panic>
8f623624:	eaffffda 	b	8f623594 <thread_sleep_handler+0x40>
}
8f623628:	eb003d64 	bl	8f632bc0 <__stack_chk_fail>
8f62362c:	8f74221c 	.word	0x8f74221c

8f623630 <thread_resched>:
{
8f623630:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	return critical_section_count > 0;
8f623634:	e3017acc 	movw	r7, #6860	; 0x1acc
8f623638:	e59f32b4 	ldr	r3, [pc, #692]	; 8f6238f4 <thread_resched+0x2c4>
8f62363c:	e3487f71 	movt	r7, #36721	; 0x8f71
8f623640:	e24dd024 	sub	r13, r13, #36	; 0x24
8f623644:	e5933000 	ldr	r3, [r3]
8f623648:	e58d301c 	str	r3, [r13, #28]
8f62364c:	e3a03000 	mov	r3, #0
	ASSERT(in_critical_section());
8f623650:	e5973000 	ldr	r3, [r7]
8f623654:	e58de010 	str	r14, [r13, #16]
8f623658:	e3530000 	cmp	r3, #0
8f62365c:	da000082 	ble	8f62386c <thread_resched+0x23c>
	thread_stats.reschedules++;
8f623660:	e3025cc8 	movw	r5, #11464	; 0x2cc8
8f623664:	e3485f74 	movt	r5, #36724	; 0x8f74
	ASSERT(run_queue_bitmap != 0);
8f623668:	e3049180 	movw	r9, #16768	; 0x4180
8f62366c:	e3489f73 	movt	r9, #36723	; 0x8f73
	thread_stats.reschedules++;
8f623670:	e5953010 	ldr	r3, [r5, #16]
	oldthread = current_thread;
8f623674:	e3028cc0 	movw	r8, #11456	; 0x2cc0
8f623678:	e3488f74 	movt	r8, #36724	; 0x8f74
	thread_stats.reschedules++;
8f62367c:	e2833001 	add	r3, r3, #1
8f623680:	e5853010 	str	r3, [r5, #16]
	ASSERT(run_queue_bitmap != 0);
8f623684:	e5993000 	ldr	r3, [r9]
	oldthread = current_thread;
8f623688:	e598a000 	ldr	r10, [r8]
	ASSERT(run_queue_bitmap != 0);
8f62368c:	e3530000 	cmp	r3, #0
8f623690:	0a000069 	beq	8f62383c <thread_resched+0x20c>
	int next_queue = HIGHEST_PRIORITY - __builtin_clz(run_queue_bitmap) - (32 - NUM_PRIORITIES);
8f623694:	e16f3f13 	clz	r3, r3
	newthread = list_remove_head_type(&run_queue[next_queue], thread_t, queue_node);
8f623698:	e3046080 	movw	r6, #16512	; 0x4080
	int next_queue = HIGHEST_PRIORITY - __builtin_clz(run_queue_bitmap) - (32 - NUM_PRIORITIES);
8f62369c:	e263301f 	rsb	r3, r3, #31
	newthread = list_remove_head_type(&run_queue[next_queue], thread_t, queue_node);
8f6236a0:	e3486f73 	movt	r6, #36723	; 0x8f73
	int next_queue = HIGHEST_PRIORITY - __builtin_clz(run_queue_bitmap) - (32 - NUM_PRIORITIES);
8f6236a4:	e58d3014 	str	r3, [r13, #20]
	newthread = list_remove_head_type(&run_queue[next_queue], thread_t, queue_node);
8f6236a8:	e1a03183 	lsl	r3, r3, #3
8f6236ac:	e58d300c 	str	r3, [r13, #12]
8f6236b0:	e086b003 	add	r11, r6, r3
	if(list->next != list) {
8f6236b4:	e59b3004 	ldr	r3, [r11, #4]
8f6236b8:	e15b0003 	cmp	r11, r3
8f6236bc:	0a000042 	beq	8f6237cc <thread_resched+0x19c>
	item->next->prev = item->prev;
8f6236c0:	e5931004 	ldr	r1, [r3, #4]
	ASSERT(newthread);
8f6236c4:	e353000c 	cmp	r3, #12
8f6236c8:	e5932000 	ldr	r2, [r3]
	item->prev = item->next = 0;
8f6236cc:	e1a04003 	mov	r4, r3
	item->next->prev = item->prev;
8f6236d0:	e5812000 	str	r2, [r1]
	item->prev->next = item->next;
8f6236d4:	e5821004 	str	r1, [r2, #4]
	item->prev = item->next = 0;
8f6236d8:	e3a02000 	mov	r2, #0
8f6236dc:	e5832004 	str	r2, [r3, #4]
8f6236e0:	e404200c 	str	r2, [r4], #-12
8f6236e4:	0a000038 	beq	8f6237cc <thread_resched+0x19c>
		&(entry)->member != (list);\
		entry = temp_entry, temp_entry = containerof((temp_entry)->member.next, type, member))

static inline bool list_is_empty(struct list_node *list)
{
	return (list->next == list) ? true : false;
8f6236e8:	e59d300c 	ldr	r3, [r13, #12]
8f6236ec:	e0866003 	add	r6, r6, r3
	if (list_is_empty(&run_queue[next_queue]))
8f6236f0:	e5963004 	ldr	r3, [r6, #4]
8f6236f4:	e15b0003 	cmp	r11, r3
		run_queue_bitmap &= ~(1<<next_queue);
8f6236f8:	05993000 	ldreq	r3, [r9]
8f6236fc:	03a02001 	moveq	r2, #1
8f623700:	059d1014 	ldreq	r1, [r13, #20]
8f623704:	01c33112 	biceq	r3, r3, r2, lsl r1
8f623708:	05893000 	streq	r3, [r9]
	if (newthread == oldthread)
8f62370c:	e15a0004 	cmp	r10, r4
	newthread->state = THREAD_RUNNING;
8f623710:	e3a03002 	mov	r3, #2
8f623714:	e5c43018 	strb	r3, [r4, #24]
	if (newthread == oldthread)
8f623718:	0a000023 	beq	8f6237ac <thread_resched+0x17c>
	if (newthread->remaining_quantum <= 0) {
8f62371c:	e5943020 	ldr	r3, [r4, #32]
	if (oldthread == idle_thread) {
8f623720:	e3026cf8 	movw	r6, #11512	; 0x2cf8
8f623724:	e3486f74 	movt	r6, #36724	; 0x8f74
	if (newthread->remaining_quantum <= 0) {
8f623728:	e3530000 	cmp	r3, #0
		newthread->remaining_quantum = 5; // XXX make this smarter
8f62372c:	d3a03005 	movle	r3, #5
8f623730:	d5843020 	strle	r3, [r4, #32]
	thread_stats.context_switches++;
8f623734:	e5953014 	ldr	r3, [r5, #20]
8f623738:	e2833001 	add	r3, r3, #1
8f62373c:	e5853014 	str	r3, [r5, #20]
	if (oldthread == idle_thread) {
8f623740:	e5963000 	ldr	r3, [r6]
8f623744:	e153000a 	cmp	r3, r10
8f623748:	0a00002e 	beq	8f623808 <thread_resched+0x1d8>
	if (newthread == idle_thread) {
8f62374c:	e1540003 	cmp	r4, r3
8f623750:	0a000029 	beq	8f6237fc <thread_resched+0x1cc>
	ASSERT(critical_section_count > 0);
8f623754:	e5973000 	ldr	r3, [r7]
8f623758:	e3530000 	cmp	r3, #0
8f62375c:	da000058 	ble	8f6238c4 <thread_resched+0x294>
	ASSERT(newthread->saved_critical_section_count > 0);
8f623760:	e594301c 	ldr	r3, [r4, #28]
8f623764:	e3530000 	cmp	r3, #0
8f623768:	da00004a 	ble	8f623898 <thread_resched+0x268>
	oldthread->saved_critical_section_count = critical_section_count;
8f62376c:	e5973000 	ldr	r3, [r7]
	current_thread = newthread;
8f623770:	e5884000 	str	r4, [r8]
	oldthread->saved_critical_section_count = critical_section_count;
8f623774:	e58a301c 	str	r3, [r10, #28]
	critical_section_count = newthread->saved_critical_section_count;
8f623778:	e594301c 	ldr	r3, [r4, #28]
8f62377c:	e5873000 	str	r3, [r7]
	arch_context_switch(oldthread, newthread);
8f623780:	e59f316c 	ldr	r3, [pc, #364]	; 8f6238f4 <thread_resched+0x2c4>
8f623784:	e5932000 	ldr	r2, [r3]
8f623788:	e59d301c 	ldr	r3, [r13, #28]
8f62378c:	e0332002 	eors	r2, r3, r2
8f623790:	e3a03000 	mov	r3, #0
8f623794:	1a000055 	bne	8f6238f0 <thread_resched+0x2c0>
8f623798:	e1a01004 	mov	r1, r4
8f62379c:	e1a0000a 	mov	r0, r10
}
8f6237a0:	e28dd024 	add	r13, r13, #36	; 0x24
8f6237a4:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	arch_context_switch(oldthread, newthread);
8f6237a8:	eafff7ad 	b	8f621664 <arch_context_switch>
}
8f6237ac:	e59f3140 	ldr	r3, [pc, #320]	; 8f6238f4 <thread_resched+0x2c4>
8f6237b0:	e5932000 	ldr	r2, [r3]
8f6237b4:	e59d301c 	ldr	r3, [r13, #28]
8f6237b8:	e0332002 	eors	r2, r3, r2
8f6237bc:	e3a03000 	mov	r3, #0
8f6237c0:	1a00004a 	bne	8f6238f0 <thread_resched+0x2c0>
8f6237c4:	e28dd024 	add	r13, r13, #36	; 0x24
8f6237c8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	ASSERT(newthread);
8f6237cc:	e59d0010 	ldr	r0, [r13, #16]
8f6237d0:	e3073f68 	movw	r3, #32616	; 0x7f68
8f6237d4:	e3072e78 	movw	r2, #32376	; 0x7e78
8f6237d8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6237dc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6237e0:	e58d3000 	str	r3, [r13]
8f6237e4:	e3001130 	movw	r1, #304	; 0x130
8f6237e8:	e300313e 	movw	r3, #318	; 0x13e
8f6237ec:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6237f0:	e3a04000 	mov	r4, #0
8f6237f4:	eb003cb0 	bl	8f632abc <_panic>
8f6237f8:	eaffffba 	b	8f6236e8 <thread_resched+0xb8>
		thread_stats.last_idle_timestamp = current_time_hires();
8f6237fc:	ebffad6f 	bl	8f60edc0 <current_time_hires>
8f623800:	e1c500f8 	strd	r0, [r5, #8]
8f623804:	eaffffd2 	b	8f623754 <thread_resched+0x124>
		bigtime_t now = current_time_hires();
8f623808:	ebffad6c 	bl	8f60edc0 <current_time_hires>
		thread_stats.idle_time += now - thread_stats.last_idle_timestamp;
8f62380c:	e5952000 	ldr	r2, [r5]
8f623810:	e595c008 	ldr	r12, [r5, #8]
8f623814:	e595e00c 	ldr	r14, [r5, #12]
8f623818:	e052200c 	subs	r2, r2, r12
8f62381c:	e595c004 	ldr	r12, [r5, #4]
	if (newthread == idle_thread) {
8f623820:	e5963000 	ldr	r3, [r6]
		thread_stats.idle_time += now - thread_stats.last_idle_timestamp;
8f623824:	e0ccc00e 	sbc	r12, r12, r14
8f623828:	e0922000 	adds	r2, r2, r0
8f62382c:	e5852000 	str	r2, [r5]
8f623830:	e0ac1001 	adc	r1, r12, r1
8f623834:	e5851004 	str	r1, [r5, #4]
8f623838:	eaffffc3 	b	8f62374c <thread_resched+0x11c>
	ASSERT(run_queue_bitmap != 0);
8f62383c:	e59d0010 	ldr	r0, [r13, #16]
8f623840:	e3073f50 	movw	r3, #32592	; 0x7f50
8f623844:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623848:	e3483f70 	movt	r3, #36720	; 0x8f70
8f62384c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623850:	e58d3000 	str	r3, [r13]
8f623854:	e3001130 	movw	r1, #304	; 0x130
8f623858:	e3003135 	movw	r3, #309	; 0x135
8f62385c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623860:	eb003c95 	bl	8f632abc <_panic>
	int next_queue = HIGHEST_PRIORITY - __builtin_clz(run_queue_bitmap) - (32 - NUM_PRIORITIES);
8f623864:	e5993000 	ldr	r3, [r9]
8f623868:	eaffff89 	b	8f623694 <thread_resched+0x64>
	ASSERT(in_critical_section());
8f62386c:	e3070ee0 	movw	r0, #32480	; 0x7ee0
8f623870:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623874:	e3480f70 	movt	r0, #36720	; 0x8f70
8f623878:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62387c:	e58d0000 	str	r0, [r13]
8f623880:	e3001130 	movw	r1, #304	; 0x130
8f623884:	e3003127 	movw	r3, #295	; 0x127
8f623888:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62388c:	e1a0000e 	mov	r0, r14
8f623890:	eb003c89 	bl	8f632abc <_panic>
8f623894:	eaffff71 	b	8f623660 <thread_resched+0x30>
	ASSERT(newthread->saved_critical_section_count > 0);
8f623898:	e59d0010 	ldr	r0, [r13, #16]
8f62389c:	e3073f90 	movw	r3, #32656	; 0x7f90
8f6238a0:	e3072e78 	movw	r2, #32376	; 0x7e78
8f6238a4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6238a8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6238ac:	e58d3000 	str	r3, [r13]
8f6238b0:	e3001130 	movw	r1, #304	; 0x130
8f6238b4:	e3003169 	movw	r3, #361	; 0x169
8f6238b8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6238bc:	eb003c7e 	bl	8f632abc <_panic>
8f6238c0:	eaffffa9 	b	8f62376c <thread_resched+0x13c>
	ASSERT(critical_section_count > 0);
8f6238c4:	e59d0010 	ldr	r0, [r13, #16]
8f6238c8:	e3073f74 	movw	r3, #32628	; 0x7f74
8f6238cc:	e3072e78 	movw	r2, #32376	; 0x7e78
8f6238d0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6238d4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6238d8:	e58d3000 	str	r3, [r13]
8f6238dc:	e3001130 	movw	r1, #304	; 0x130
8f6238e0:	e3a03f5a 	mov	r3, #360	; 0x168
8f6238e4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6238e8:	eb003c73 	bl	8f632abc <_panic>
8f6238ec:	eaffff9b 	b	8f623760 <thread_resched+0x130>
}
8f6238f0:	eb003cb2 	bl	8f632bc0 <__stack_chk_fail>
8f6238f4:	8f74221c 	.word	0x8f74221c

8f6238f8 <insert_in_run_queue_tail.constprop.0>:
	ASSERT(t->magic == THREAD_MAGIC);
8f6238f8:	e5902000 	ldr	r2, [r0]
8f6238fc:	e3073264 	movw	r3, #29284	; 0x7264
8f623900:	e3473468 	movt	r3, #29800	; 0x7468
static void insert_in_run_queue_tail(thread_t *t)
8f623904:	e59f116c 	ldr	r1, [pc, #364]	; 8f623a78 <insert_in_run_queue_tail.constprop.0+0x180>
	ASSERT(t->magic == THREAD_MAGIC);
8f623908:	e1520003 	cmp	r2, r3
static void insert_in_run_queue_tail(thread_t *t)
8f62390c:	e92d4030 	push	{r4, r5, r14}
8f623910:	e24dd014 	sub	r13, r13, #20
8f623914:	e5911000 	ldr	r1, [r1]
8f623918:	e58d100c 	str	r1, [r13, #12]
8f62391c:	e3a01000 	mov	r1, #0
8f623920:	e1a04000 	mov	r4, r0
8f623924:	e1a0500e 	mov	r5, r14
	ASSERT(t->magic == THREAD_MAGIC);
8f623928:	1a000046 	bne	8f623a48 <insert_in_run_queue_tail.constprop.0+0x150>
	ASSERT(t->state == THREAD_READY);
8f62392c:	e5d43018 	ldrb	r3, [r4, #24]
8f623930:	e3530001 	cmp	r3, #1
8f623934:	1a00002d 	bne	8f6239f0 <insert_in_run_queue_tail.constprop.0+0xf8>
	if (item->prev == 0 && item->next == 0)
8f623938:	e594300c 	ldr	r3, [r4, #12]
8f62393c:	e3530000 	cmp	r3, #0
8f623940:	0a000026 	beq	8f6239e0 <insert_in_run_queue_tail.constprop.0+0xe8>
	ASSERT(!list_in_list(&t->queue_node));
8f623944:	e3070ec0 	movw	r0, #32448	; 0x7ec0
8f623948:	e3072e78 	movw	r2, #32376	; 0x7e78
8f62394c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f623950:	e3001130 	movw	r1, #304	; 0x130
8f623954:	e58d0000 	str	r0, [r13]
8f623958:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62395c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623960:	e3a03064 	mov	r3, #100	; 0x64
8f623964:	e1a00005 	mov	r0, r5
8f623968:	eb003c53 	bl	8f632abc <_panic>
8f62396c:	e3013acc 	movw	r3, #6860	; 0x1acc
8f623970:	e3483f71 	movt	r3, #36721	; 0x8f71
	ASSERT(in_critical_section());
8f623974:	e5933000 	ldr	r3, [r3]
8f623978:	e3530000 	cmp	r3, #0
8f62397c:	da000026 	ble	8f623a1c <insert_in_run_queue_tail.constprop.0+0x124>
	list_add_tail(&run_queue[t->priority], &t->queue_node);
8f623980:	e5941014 	ldr	r1, [r4, #20]
	item->prev = list->prev;
8f623984:	e3043080 	movw	r3, #16512	; 0x4080
8f623988:	e3483f73 	movt	r3, #36723	; 0x8f73
	run_queue_bitmap |= (1<<t->priority);
8f62398c:	e3042180 	movw	r2, #16768	; 0x4180
8f623990:	e3482f73 	movt	r2, #36723	; 0x8f73
	list_add_tail(&run_queue[t->priority], &t->queue_node);
8f623994:	e284000c 	add	r0, r4, #12
8f623998:	e793c181 	ldr	r12, [r3, r1, lsl #3]
8f62399c:	e0835181 	add	r5, r3, r1, lsl #3
	item->next = list;
8f6239a0:	e5845010 	str	r5, [r4, #16]
	run_queue_bitmap |= (1<<t->priority);
8f6239a4:	e3a0e001 	mov	r14, #1
	item->prev = list->prev;
8f6239a8:	e584c00c 	str	r12, [r4, #12]
	list->prev->next = item;
8f6239ac:	e58c0004 	str	r0, [r12, #4]
	list->prev = item;
8f6239b0:	e7830181 	str	r0, [r3, r1, lsl #3]
8f6239b4:	e5923000 	ldr	r3, [r2]
8f6239b8:	e183111e 	orr	r1, r3, r14, lsl r1
}
8f6239bc:	e59f30b4 	ldr	r3, [pc, #180]	; 8f623a78 <insert_in_run_queue_tail.constprop.0+0x180>
	run_queue_bitmap |= (1<<t->priority);
8f6239c0:	e5821000 	str	r1, [r2]
}
8f6239c4:	e5932000 	ldr	r2, [r3]
8f6239c8:	e59d300c 	ldr	r3, [r13, #12]
8f6239cc:	e0332002 	eors	r2, r3, r2
8f6239d0:	e3a03000 	mov	r3, #0
8f6239d4:	1a000026 	bne	8f623a74 <insert_in_run_queue_tail.constprop.0+0x17c>
8f6239d8:	e28dd014 	add	r13, r13, #20
8f6239dc:	e8bd8030 	pop	{r4, r5, r15}
	if (item->prev == 0 && item->next == 0)
8f6239e0:	e5943010 	ldr	r3, [r4, #16]
8f6239e4:	e3530000 	cmp	r3, #0
8f6239e8:	1affffd5 	bne	8f623944 <insert_in_run_queue_tail.constprop.0+0x4c>
8f6239ec:	eaffffde 	b	8f62396c <insert_in_run_queue_tail.constprop.0+0x74>
	ASSERT(t->state == THREAD_READY);
8f6239f0:	e3070ea4 	movw	r0, #32420	; 0x7ea4
8f6239f4:	e3072e78 	movw	r2, #32376	; 0x7e78
8f6239f8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6239fc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623a00:	e58d0000 	str	r0, [r13]
8f623a04:	e3001130 	movw	r1, #304	; 0x130
8f623a08:	e3a03063 	mov	r3, #99	; 0x63
8f623a0c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623a10:	e1a00005 	mov	r0, r5
8f623a14:	eb003c28 	bl	8f632abc <_panic>
8f623a18:	eaffffc6 	b	8f623938 <insert_in_run_queue_tail.constprop.0+0x40>
	ASSERT(in_critical_section());
8f623a1c:	e307cee0 	movw	r12, #32480	; 0x7ee0
8f623a20:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623a24:	e348cf70 	movt	r12, #36720	; 0x8f70
8f623a28:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623a2c:	e3001130 	movw	r1, #304	; 0x130
8f623a30:	e3a03065 	mov	r3, #101	; 0x65
8f623a34:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623a38:	e1a00005 	mov	r0, r5
8f623a3c:	e58dc000 	str	r12, [r13]
8f623a40:	eb003c1d 	bl	8f632abc <_panic>
8f623a44:	eaffffcd 	b	8f623980 <insert_in_run_queue_tail.constprop.0+0x88>
	ASSERT(t->magic == THREAD_MAGIC);
8f623a48:	e3070e88 	movw	r0, #32392	; 0x7e88
8f623a4c:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623a50:	e3480f70 	movt	r0, #36720	; 0x8f70
8f623a54:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623a58:	e58d0000 	str	r0, [r13]
8f623a5c:	e3001130 	movw	r1, #304	; 0x130
8f623a60:	e3a03062 	mov	r3, #98	; 0x62
8f623a64:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623a68:	e1a0000e 	mov	r0, r14
8f623a6c:	eb003c12 	bl	8f632abc <_panic>
8f623a70:	eaffffad 	b	8f62392c <insert_in_run_queue_tail.constprop.0+0x34>
}
8f623a74:	eb003c51 	bl	8f632bc0 <__stack_chk_fail>
8f623a78:	8f74221c 	.word	0x8f74221c

8f623a7c <thread_create>:
{
8f623a7c:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f623a80:	e1a05003 	mov	r5, r3
8f623a84:	e24dd00c 	sub	r13, r13, #12
8f623a88:	e59f3150 	ldr	r3, [pc, #336]	; 8f623be0 <thread_create+0x164>
8f623a8c:	e1a09000 	mov	r9, r0
	t = malloc(sizeof(thread_t));
8f623a90:	e3a00064 	mov	r0, #100	; 0x64
{
8f623a94:	e59d8028 	ldr	r8, [r13, #40]	; 0x28
8f623a98:	e5933000 	ldr	r3, [r3]
8f623a9c:	e58d3004 	str	r3, [r13, #4]
8f623aa0:	e3a03000 	mov	r3, #0
8f623aa4:	e1a07001 	mov	r7, r1
8f623aa8:	e1a06002 	mov	r6, r2
	t = malloc(sizeof(thread_t));
8f623aac:	eb004152 	bl	8f633ffc <malloc>
	if (!t)
8f623ab0:	e2504000 	subs	r4, r0, #0
8f623ab4:	0a00002b 	beq	8f623b68 <thread_create+0xec>
	memset(t, 0, sizeof(thread_t));
8f623ab8:	e3a02064 	mov	r2, #100	; 0x64
8f623abc:	e3a01000 	mov	r1, #0
8f623ac0:	eb0041ff 	bl	8f6342c4 <memset>
	t->magic = THREAD_MAGIC;
8f623ac4:	e1a00004 	mov	r0, r4
	strlcpy(t->name, name, sizeof(t->name));
8f623ac8:	e1a01009 	mov	r1, r9
8f623acc:	e3a02020 	mov	r2, #32
	t->magic = THREAD_MAGIC;
8f623ad0:	e3073264 	movw	r3, #29284	; 0x7264
8f623ad4:	e3473468 	movt	r3, #29800	; 0x7468
8f623ad8:	e4803044 	str	r3, [r0], #68	; 0x44
	strlcpy(t->name, name, sizeof(t->name));
8f623adc:	eb004313 	bl	8f634730 <strlcpy>
	t->state = THREAD_SUSPENDED;
8f623ae0:	e3a03000 	mov	r3, #0
	t->saved_critical_section_count = 1; /* we always start inside a critical section */
8f623ae4:	e3a02001 	mov	r2, #1
	t->state = THREAD_SUSPENDED;
8f623ae8:	e5c43018 	strb	r3, [r4, #24]
	t->blocking_wait_queue = NULL;
8f623aec:	e5843024 	str	r3, [r4, #36]	; 0x24
	t->stack = malloc(stack_size);
8f623af0:	e1a00008 	mov	r0, r8
	t->wait_queue_block_ret = NO_ERROR;
8f623af4:	e5843028 	str	r3, [r4, #40]	; 0x28
	t->entry = entry;
8f623af8:	e5847038 	str	r7, [r4, #56]	; 0x38
	t->saved_critical_section_count = 1; /* we always start inside a critical section */
8f623afc:	e584201c 	str	r2, [r4, #28]
	t->arg = arg;
8f623b00:	e584603c 	str	r6, [r4, #60]	; 0x3c
	t->priority = priority;
8f623b04:	e5845014 	str	r5, [r4, #20]
	t->stack = malloc(stack_size);
8f623b08:	eb00413b 	bl	8f633ffc <malloc>
	if (!t->stack) {
8f623b0c:	e3500000 	cmp	r0, #0
	t->stack = malloc(stack_size);
8f623b10:	e1a03000 	mov	r3, r0
8f623b14:	e5840030 	str	r0, [r4, #48]	; 0x30
	if (!t->stack) {
8f623b18:	0a00002b 	beq	8f623bcc <thread_create+0x150>
	critical_section_count++;
8f623b1c:	e3015acc 	movw	r5, #6860	; 0x1acc
8f623b20:	e3485f71 	movt	r5, #36721	; 0x8f71
	arch_thread_initialize(t);
8f623b24:	e1a00004 	mov	r0, r4
	t->stack_size = stack_size;
8f623b28:	e5848034 	str	r8, [r4, #52]	; 0x34
	arch_thread_initialize(t);
8f623b2c:	ebfff6ae 	bl	8f6215ec <arch_thread_initialize>
8f623b30:	e5951000 	ldr	r1, [r5]
8f623b34:	e2813001 	add	r3, r1, #1
8f623b38:	e5853000 	str	r3, [r5]
	if (critical_section_count == 1)
8f623b3c:	e3530001 	cmp	r3, #1
8f623b40:	0a000011 	beq	8f623b8c <thread_create+0x110>
	item->next = list->next;
8f623b44:	e3043184 	movw	r3, #16772	; 0x4184
8f623b48:	e3483f73 	movt	r3, #36723	; 0x8f73
	list_add_head(&thread_list, &t->thread_list_node);
8f623b4c:	e2842004 	add	r2, r4, #4
	item->prev = list;
8f623b50:	e5843004 	str	r3, [r4, #4]
	item->next = list->next;
8f623b54:	e5930004 	ldr	r0, [r3, #4]
8f623b58:	e5840008 	str	r0, [r4, #8]
	list->next->prev = item;
8f623b5c:	e5802000 	str	r2, [r0]
	list->next = item;
8f623b60:	e5832004 	str	r2, [r3, #4]
	critical_section_count--;
8f623b64:	e5851000 	str	r1, [r5]
}
8f623b68:	e59f3070 	ldr	r3, [pc, #112]	; 8f623be0 <thread_create+0x164>
8f623b6c:	e5932000 	ldr	r2, [r3]
8f623b70:	e59d3004 	ldr	r3, [r13, #4]
8f623b74:	e0332002 	eors	r2, r3, r2
8f623b78:	e3a03000 	mov	r3, #0
8f623b7c:	1a000016 	bne	8f623bdc <thread_create+0x160>
8f623b80:	e1a00004 	mov	r0, r4
8f623b84:	e28dd00c 	add	r13, r13, #12
8f623b88:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
		arch_disable_ints();
8f623b8c:	ebfff521 	bl	8f621018 <arch_disable_ints>
	critical_section_count--;
8f623b90:	e5952000 	ldr	r2, [r5]
	item->next = list->next;
8f623b94:	e3043184 	movw	r3, #16772	; 0x4184
8f623b98:	e3483f73 	movt	r3, #36723	; 0x8f73
8f623b9c:	e2422001 	sub	r2, r2, #1
	list_add_head(&thread_list, &t->thread_list_node);
8f623ba0:	e2841004 	add	r1, r4, #4
8f623ba4:	e5930004 	ldr	r0, [r3, #4]
	if (critical_section_count == 0)
8f623ba8:	e3520000 	cmp	r2, #0
	item->prev = list;
8f623bac:	e5843004 	str	r3, [r4, #4]
	item->next = list->next;
8f623bb0:	e5840008 	str	r0, [r4, #8]
	list->next->prev = item;
8f623bb4:	e5801000 	str	r1, [r0]
	list->next = item;
8f623bb8:	e5831004 	str	r1, [r3, #4]
	critical_section_count--;
8f623bbc:	e5852000 	str	r2, [r5]
	if (critical_section_count == 0)
8f623bc0:	1affffe8 	bne	8f623b68 <thread_create+0xec>
		arch_enable_ints();
8f623bc4:	ebfff50f 	bl	8f621008 <arch_enable_ints>
8f623bc8:	eaffffe6 	b	8f623b68 <thread_create+0xec>
		free(t);
8f623bcc:	e1a00004 	mov	r0, r4
		return NULL;
8f623bd0:	e1a04003 	mov	r4, r3
		free(t);
8f623bd4:	eb00414c 	bl	8f63410c <free>
		return NULL;
8f623bd8:	eaffffe2 	b	8f623b68 <thread_create+0xec>
}
8f623bdc:	eb003bf7 	bl	8f632bc0 <__stack_chk_fail>
8f623be0:	8f74221c 	.word	0x8f74221c

8f623be4 <thread_exit>:
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f623be4:	e3024cc0 	movw	r4, #11456	; 0x2cc0
8f623be8:	e3484f74 	movt	r4, #36724	; 0x8f74
{
8f623bec:	e59f10f4 	ldr	r1, [pc, #244]	; 8f623ce8 <thread_exit+0x104>
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f623bf0:	e3072264 	movw	r2, #29284	; 0x7264
8f623bf4:	e5943000 	ldr	r3, [r4]
8f623bf8:	e3472468 	movt	r2, #29800	; 0x7468
{
8f623bfc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f623c00:	e24dd014 	sub	r13, r13, #20
8f623c04:	e5911000 	ldr	r1, [r1]
8f623c08:	e58d100c 	str	r1, [r13, #12]
8f623c0c:	e3a01000 	mov	r1, #0
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f623c10:	e5931000 	ldr	r1, [r3]
8f623c14:	e1a0500e 	mov	r5, r14
{
8f623c18:	e1a06000 	mov	r6, r0
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f623c1c:	e1510002 	cmp	r1, r2
8f623c20:	1a000024 	bne	8f623cb8 <thread_exit+0xd4>
	ASSERT(current_thread->state == THREAD_RUNNING);
8f623c24:	e5d33018 	ldrb	r3, [r3, #24]
8f623c28:	e3530002 	cmp	r3, #2
8f623c2c:	1a000016 	bne	8f623c8c <thread_exit+0xa8>
	critical_section_count++;
8f623c30:	e3012acc 	movw	r2, #6860	; 0x1acc
8f623c34:	e3482f71 	movt	r2, #36721	; 0x8f71
8f623c38:	e5923000 	ldr	r3, [r2]
8f623c3c:	e2833001 	add	r3, r3, #1
8f623c40:	e5823000 	str	r3, [r2]
	if (critical_section_count == 1)
8f623c44:	e3530001 	cmp	r3, #1
8f623c48:	0a00000d 	beq	8f623c84 <thread_exit+0xa0>
	current_thread->state = THREAD_DEATH;
8f623c4c:	e5941000 	ldr	r1, [r4]
8f623c50:	e3a03005 	mov	r3, #5
	dpc_queue(thread_cleanup_dpc, (void *)current_thread, DPC_FLAG_NORESCHED);
8f623c54:	e3a02001 	mov	r2, #1
8f623c58:	e30303c8 	movw	r0, #13256	; 0x33c8
8f623c5c:	e3480f62 	movt	r0, #36706	; 0x8f62
	current_thread->retcode = retcode;
8f623c60:	e5816040 	str	r6, [r1, #64]	; 0x40
	current_thread->state = THREAD_DEATH;
8f623c64:	e5c13018 	strb	r3, [r1, #24]
	dpc_queue(thread_cleanup_dpc, (void *)current_thread, DPC_FLAG_NORESCHED);
8f623c68:	ebfffb44 	bl	8f622980 <dpc_queue>
	thread_resched();
8f623c6c:	ebfffe6f 	bl	8f623630 <thread_resched>
	panic("somehow fell through thread_exit()\n");
8f623c70:	e308100c 	movw	r1, #32780	; 0x800c
8f623c74:	e1a00005 	mov	r0, r5
8f623c78:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623c7c:	eb003b8e 	bl	8f632abc <_panic>
	for(;;);
8f623c80:	eafffffe 	b	8f623c80 <thread_exit+0x9c>
		arch_disable_ints();
8f623c84:	ebfff4e3 	bl	8f621018 <arch_disable_ints>
8f623c88:	eaffffef 	b	8f623c4c <thread_exit+0x68>
	ASSERT(current_thread->state == THREAD_RUNNING);
8f623c8c:	e3071fe4 	movw	r1, #32740	; 0x7fe4
8f623c90:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623c94:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623c98:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623c9c:	e58d1000 	str	r1, [r13]
8f623ca0:	e3a030f9 	mov	r3, #249	; 0xf9
8f623ca4:	e3001130 	movw	r1, #304	; 0x130
8f623ca8:	e1a00005 	mov	r0, r5
8f623cac:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623cb0:	eb003b81 	bl	8f632abc <_panic>
8f623cb4:	eaffffdd 	b	8f623c30 <thread_exit+0x4c>
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f623cb8:	e3a030f8 	mov	r3, #248	; 0xf8
8f623cbc:	e3072fbc 	movw	r2, #32700	; 0x7fbc
8f623cc0:	e3001130 	movw	r1, #304	; 0x130
8f623cc4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623cc8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623ccc:	e58d2000 	str	r2, [r13]
8f623cd0:	e1a0000e 	mov	r0, r14
8f623cd4:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623cd8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623cdc:	eb003b76 	bl	8f632abc <_panic>
	ASSERT(current_thread->state == THREAD_RUNNING);
8f623ce0:	e5943000 	ldr	r3, [r4]
8f623ce4:	eaffffce 	b	8f623c24 <thread_exit+0x40>
8f623ce8:	8f74221c 	.word	0x8f74221c

8f623cec <thread_yield>:
{
8f623cec:	e92d4030 	push	{r4, r5, r14}
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f623cf0:	e3025cc0 	movw	r5, #11456	; 0x2cc0
8f623cf4:	e3485f74 	movt	r5, #36724	; 0x8f74
{
8f623cf8:	e59f113c 	ldr	r1, [pc, #316]	; 8f623e3c <thread_yield+0x150>
8f623cfc:	e24dd014 	sub	r13, r13, #20
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f623d00:	e3072264 	movw	r2, #29284	; 0x7264
8f623d04:	e5953000 	ldr	r3, [r5]
{
8f623d08:	e5911000 	ldr	r1, [r1]
8f623d0c:	e58d100c 	str	r1, [r13, #12]
8f623d10:	e3a01000 	mov	r1, #0
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f623d14:	e3472468 	movt	r2, #29800	; 0x7468
8f623d18:	e1a0400e 	mov	r4, r14
8f623d1c:	e5931000 	ldr	r1, [r3]
8f623d20:	e1510002 	cmp	r1, r2
8f623d24:	1a000037 	bne	8f623e08 <thread_yield+0x11c>
	ASSERT(current_thread->state == THREAD_RUNNING);
8f623d28:	e5d33018 	ldrb	r3, [r3, #24]
8f623d2c:	e3530002 	cmp	r3, #2
8f623d30:	1a000029 	bne	8f623ddc <thread_yield+0xf0>
	critical_section_count++;
8f623d34:	e3014acc 	movw	r4, #6860	; 0x1acc
8f623d38:	e3484f71 	movt	r4, #36721	; 0x8f71
8f623d3c:	e5943000 	ldr	r3, [r4]
8f623d40:	e2833001 	add	r3, r3, #1
8f623d44:	e5843000 	str	r3, [r4]
	if (critical_section_count == 1)
8f623d48:	e3530001 	cmp	r3, #1
8f623d4c:	0a000020 	beq	8f623dd4 <thread_yield+0xe8>
	thread_stats.yields++;
8f623d50:	e3023cc8 	movw	r3, #11464	; 0x2cc8
8f623d54:	e3483f74 	movt	r3, #36724	; 0x8f74
	current_thread->state = THREAD_READY;
8f623d58:	e5950000 	ldr	r0, [r5]
8f623d5c:	e3a01001 	mov	r1, #1
	thread_stats.yields++;
8f623d60:	e593201c 	ldr	r2, [r3, #28]
8f623d64:	e0822001 	add	r2, r2, r1
8f623d68:	e583201c 	str	r2, [r3, #28]
	current_thread->remaining_quantum = 0;
8f623d6c:	e3a03000 	mov	r3, #0
	current_thread->state = THREAD_READY;
8f623d70:	e5c01018 	strb	r1, [r0, #24]
	current_thread->remaining_quantum = 0;
8f623d74:	e5803020 	str	r3, [r0, #32]
	insert_in_run_queue_tail(current_thread);
8f623d78:	ebfffede 	bl	8f6238f8 <insert_in_run_queue_tail.constprop.0>
	thread_resched();
8f623d7c:	ebfffe2b 	bl	8f623630 <thread_resched>
	critical_section_count--;
8f623d80:	e5943000 	ldr	r3, [r4]
8f623d84:	e2433001 	sub	r3, r3, #1
8f623d88:	e5843000 	str	r3, [r4]
	if (critical_section_count == 0)
8f623d8c:	e3530000 	cmp	r3, #0
		arch_enable_ints();
8f623d90:	e59f30a4 	ldr	r3, [pc, #164]	; 8f623e3c <thread_yield+0x150>
	if (critical_section_count == 0)
8f623d94:	0a000006 	beq	8f623db4 <thread_yield+0xc8>
}
8f623d98:	e5932000 	ldr	r2, [r3]
8f623d9c:	e59d300c 	ldr	r3, [r13, #12]
8f623da0:	e0332002 	eors	r2, r3, r2
8f623da4:	e3a03000 	mov	r3, #0
8f623da8:	1a000022 	bne	8f623e38 <thread_yield+0x14c>
8f623dac:	e28dd014 	add	r13, r13, #20
8f623db0:	e8bd8030 	pop	{r4, r5, r15}
		arch_enable_ints();
8f623db4:	e5932000 	ldr	r2, [r3]
8f623db8:	e59d300c 	ldr	r3, [r13, #12]
8f623dbc:	e0332002 	eors	r2, r3, r2
8f623dc0:	e3a03000 	mov	r3, #0
8f623dc4:	1a00001b 	bne	8f623e38 <thread_yield+0x14c>
8f623dc8:	e28dd014 	add	r13, r13, #20
8f623dcc:	e8bd4030 	pop	{r4, r5, r14}
8f623dd0:	eafff48c 	b	8f621008 <arch_enable_ints>
		arch_disable_ints();
8f623dd4:	ebfff48f 	bl	8f621018 <arch_disable_ints>
8f623dd8:	eaffffdc 	b	8f623d50 <thread_yield+0x64>
	ASSERT(current_thread->state == THREAD_RUNNING);
8f623ddc:	e307cfe4 	movw	r12, #32740	; 0x7fe4
8f623de0:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623de4:	e348cf70 	movt	r12, #36720	; 0x8f70
8f623de8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623dec:	e3001130 	movw	r1, #304	; 0x130
8f623df0:	e300318b 	movw	r3, #395	; 0x18b
8f623df4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623df8:	e1a00004 	mov	r0, r4
8f623dfc:	e58dc000 	str	r12, [r13]
8f623e00:	eb003b2d 	bl	8f632abc <_panic>
8f623e04:	eaffffca 	b	8f623d34 <thread_yield+0x48>
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f623e08:	e300318a 	movw	r3, #394	; 0x18a
8f623e0c:	e3071fbc 	movw	r1, #32700	; 0x7fbc
8f623e10:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623e14:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623e18:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623e1c:	e58d1000 	str	r1, [r13]
8f623e20:	e1a0000e 	mov	r0, r14
8f623e24:	e3001130 	movw	r1, #304	; 0x130
8f623e28:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623e2c:	eb003b22 	bl	8f632abc <_panic>
	ASSERT(current_thread->state == THREAD_RUNNING);
8f623e30:	e5953000 	ldr	r3, [r5]
8f623e34:	eaffffbb 	b	8f623d28 <thread_yield+0x3c>
}
8f623e38:	eb003b60 	bl	8f632bc0 <__stack_chk_fail>
8f623e3c:	8f74221c 	.word	0x8f74221c

8f623e40 <thread_resume>:
	ASSERT(t->magic == THREAD_MAGIC);
8f623e40:	e5902000 	ldr	r2, [r0]
8f623e44:	e3073264 	movw	r3, #29284	; 0x7264
8f623e48:	e3473468 	movt	r3, #29800	; 0x7468
{
8f623e4c:	e59f111c 	ldr	r1, [pc, #284]	; 8f623f70 <thread_resume+0x130>
	ASSERT(t->magic == THREAD_MAGIC);
8f623e50:	e1520003 	cmp	r2, r3
{
8f623e54:	e92d4030 	push	{r4, r5, r14}
8f623e58:	e24dd014 	sub	r13, r13, #20
8f623e5c:	e5911000 	ldr	r1, [r1]
8f623e60:	e58d100c 	str	r1, [r13, #12]
8f623e64:	e3a01000 	mov	r1, #0
8f623e68:	e1a04000 	mov	r4, r0
8f623e6c:	e1a0500e 	mov	r5, r14
	ASSERT(t->magic == THREAD_MAGIC);
8f623e70:	1a000030 	bne	8f623f38 <thread_resume+0xf8>
	ASSERT(t->state != THREAD_DEATH);
8f623e74:	e5d43018 	ldrb	r3, [r4, #24]
8f623e78:	e3530005 	cmp	r3, #5
8f623e7c:	0a000021 	beq	8f623f08 <thread_resume+0xc8>
	if (t->state == THREAD_READY || t->state == THREAD_RUNNING)
8f623e80:	e2433001 	sub	r3, r3, #1
8f623e84:	e3530001 	cmp	r3, #1
8f623e88:	9a000035 	bls	8f623f64 <thread_resume+0x124>
	critical_section_count++;
8f623e8c:	e3015acc 	movw	r5, #6860	; 0x1acc
8f623e90:	e3485f71 	movt	r5, #36721	; 0x8f71
8f623e94:	e5953000 	ldr	r3, [r5]
8f623e98:	e2833001 	add	r3, r3, #1
8f623e9c:	e5853000 	str	r3, [r5]
	if (critical_section_count == 1)
8f623ea0:	e3530001 	cmp	r3, #1
8f623ea4:	0a000015 	beq	8f623f00 <thread_resume+0xc0>
	insert_in_run_queue_head(t);
8f623ea8:	e1a00004 	mov	r0, r4
	t->state = THREAD_READY;
8f623eac:	e3a03001 	mov	r3, #1
8f623eb0:	e5c43018 	strb	r3, [r4, #24]
	insert_in_run_queue_head(t);
8f623eb4:	ebfffce2 	bl	8f623244 <insert_in_run_queue_head>
	thread_yield();
8f623eb8:	ebffff8b 	bl	8f623cec <thread_yield>
	critical_section_count--;
8f623ebc:	e5954000 	ldr	r4, [r5]
8f623ec0:	e2444001 	sub	r4, r4, #1
8f623ec4:	e5854000 	str	r4, [r5]
	if (critical_section_count == 0)
8f623ec8:	e3540000 	cmp	r4, #0
	return NO_ERROR;
8f623ecc:	13a04000 	movne	r4, #0
8f623ed0:	0a000008 	beq	8f623ef8 <thread_resume+0xb8>
}
8f623ed4:	e59f3094 	ldr	r3, [pc, #148]	; 8f623f70 <thread_resume+0x130>
8f623ed8:	e5932000 	ldr	r2, [r3]
8f623edc:	e59d300c 	ldr	r3, [r13, #12]
8f623ee0:	e0332002 	eors	r2, r3, r2
8f623ee4:	e3a03000 	mov	r3, #0
8f623ee8:	1a00001f 	bne	8f623f6c <thread_resume+0x12c>
8f623eec:	e1a00004 	mov	r0, r4
8f623ef0:	e28dd014 	add	r13, r13, #20
8f623ef4:	e8bd8030 	pop	{r4, r5, r15}
		arch_enable_ints();
8f623ef8:	ebfff442 	bl	8f621008 <arch_enable_ints>
8f623efc:	eafffff4 	b	8f623ed4 <thread_resume+0x94>
		arch_disable_ints();
8f623f00:	ebfff444 	bl	8f621018 <arch_disable_ints>
8f623f04:	eaffffe7 	b	8f623ea8 <thread_resume+0x68>
	ASSERT(t->state != THREAD_DEATH);
8f623f08:	e3a030c7 	mov	r3, #199	; 0xc7
8f623f0c:	e3081030 	movw	r1, #32816	; 0x8030
8f623f10:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623f14:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623f18:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623f1c:	e58d1000 	str	r1, [r13]
8f623f20:	e1a00005 	mov	r0, r5
8f623f24:	e3001130 	movw	r1, #304	; 0x130
8f623f28:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623f2c:	eb003ae2 	bl	8f632abc <_panic>
	if (t->state == THREAD_READY || t->state == THREAD_RUNNING)
8f623f30:	e5d43018 	ldrb	r3, [r4, #24]
8f623f34:	eaffffd1 	b	8f623e80 <thread_resume+0x40>
	ASSERT(t->magic == THREAD_MAGIC);
8f623f38:	e3070e88 	movw	r0, #32392	; 0x7e88
8f623f3c:	e3072e78 	movw	r2, #32376	; 0x7e78
8f623f40:	e3480f70 	movt	r0, #36720	; 0x8f70
8f623f44:	e3482f70 	movt	r2, #36720	; 0x8f70
8f623f48:	e58d0000 	str	r0, [r13]
8f623f4c:	e3001130 	movw	r1, #304	; 0x130
8f623f50:	e3a030c6 	mov	r3, #198	; 0xc6
8f623f54:	e3481f70 	movt	r1, #36720	; 0x8f70
8f623f58:	e1a0000e 	mov	r0, r14
8f623f5c:	eb003ad6 	bl	8f632abc <_panic>
8f623f60:	eaffffc3 	b	8f623e74 <thread_resume+0x34>
		return ERR_NOT_SUSPENDED;
8f623f64:	e3e04009 	mvn	r4, #9
8f623f68:	eaffffd9 	b	8f623ed4 <thread_resume+0x94>
}
8f623f6c:	eb003b13 	bl	8f632bc0 <__stack_chk_fail>
8f623f70:	8f74221c 	.word	0x8f74221c

8f623f74 <thread_preempt>:
{
8f623f74:	e92d4030 	push	{r4, r5, r14}
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f623f78:	e3025cc0 	movw	r5, #11456	; 0x2cc0
8f623f7c:	e3485f74 	movt	r5, #36724	; 0x8f74
{
8f623f80:	e59f1158 	ldr	r1, [pc, #344]	; 8f6240e0 <thread_preempt+0x16c>
8f623f84:	e24dd014 	sub	r13, r13, #20
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f623f88:	e3072264 	movw	r2, #29284	; 0x7264
8f623f8c:	e5953000 	ldr	r3, [r5]
{
8f623f90:	e5911000 	ldr	r1, [r1]
8f623f94:	e58d100c 	str	r1, [r13, #12]
8f623f98:	e3a01000 	mov	r1, #0
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f623f9c:	e3472468 	movt	r2, #29800	; 0x7468
8f623fa0:	e1a0400e 	mov	r4, r14
8f623fa4:	e5931000 	ldr	r1, [r3]
8f623fa8:	e1510002 	cmp	r1, r2
8f623fac:	1a00003e 	bne	8f6240ac <thread_preempt+0x138>
	ASSERT(current_thread->state == THREAD_RUNNING);
8f623fb0:	e5d33018 	ldrb	r3, [r3, #24]
8f623fb4:	e3530002 	cmp	r3, #2
8f623fb8:	1a000030 	bne	8f624080 <thread_preempt+0x10c>
	critical_section_count++;
8f623fbc:	e3014acc 	movw	r4, #6860	; 0x1acc
8f623fc0:	e3484f71 	movt	r4, #36721	; 0x8f71
8f623fc4:	e5943000 	ldr	r3, [r4]
8f623fc8:	e2833001 	add	r3, r3, #1
8f623fcc:	e5843000 	str	r3, [r4]
	if (critical_section_count == 1)
8f623fd0:	e3530001 	cmp	r3, #1
8f623fd4:	0a000027 	beq	8f624078 <thread_preempt+0x104>
	if (current_thread != idle_thread)
8f623fd8:	e3023cf8 	movw	r3, #11512	; 0x2cf8
8f623fdc:	e3483f74 	movt	r3, #36724	; 0x8f74
8f623fe0:	e5950000 	ldr	r0, [r5]
8f623fe4:	e5933000 	ldr	r3, [r3]
8f623fe8:	e1500003 	cmp	r0, r3
		thread_stats.preempts++; /* only track when a meaningful preempt happens */
8f623fec:	13023cc8 	movwne	r3, #11464	; 0x2cc8
8f623ff0:	13483f74 	movtne	r3, #36724	; 0x8f74
8f623ff4:	15932018 	ldrne	r2, [r3, #24]
8f623ff8:	12822001 	addne	r2, r2, #1
8f623ffc:	15832018 	strne	r2, [r3, #24]
	current_thread->state = THREAD_READY;
8f624000:	e3a02001 	mov	r2, #1
	if (current_thread->remaining_quantum > 0)
8f624004:	e5903020 	ldr	r3, [r0, #32]
	current_thread->state = THREAD_READY;
8f624008:	e5c02018 	strb	r2, [r0, #24]
	if (current_thread->remaining_quantum > 0)
8f62400c:	e3530000 	cmp	r3, #0
8f624010:	da00000e 	ble	8f624050 <thread_preempt+0xdc>
		insert_in_run_queue_head(current_thread);
8f624014:	ebfffc8a 	bl	8f623244 <insert_in_run_queue_head>
	thread_resched();
8f624018:	ebfffd84 	bl	8f623630 <thread_resched>
	critical_section_count--;
8f62401c:	e5943000 	ldr	r3, [r4]
8f624020:	e2433001 	sub	r3, r3, #1
8f624024:	e5843000 	str	r3, [r4]
	if (critical_section_count == 0)
8f624028:	e3530000 	cmp	r3, #0
		arch_enable_ints();
8f62402c:	e59f30ac 	ldr	r3, [pc, #172]	; 8f6240e0 <thread_preempt+0x16c>
	if (critical_section_count == 0)
8f624030:	0a000008 	beq	8f624058 <thread_preempt+0xe4>
}
8f624034:	e5932000 	ldr	r2, [r3]
8f624038:	e59d300c 	ldr	r3, [r13, #12]
8f62403c:	e0332002 	eors	r2, r3, r2
8f624040:	e3a03000 	mov	r3, #0
8f624044:	1a000024 	bne	8f6240dc <thread_preempt+0x168>
8f624048:	e28dd014 	add	r13, r13, #20
8f62404c:	e8bd8030 	pop	{r4, r5, r15}
		insert_in_run_queue_tail(current_thread); /* if we're out of quantum, go to the tail of the queue */
8f624050:	ebfffe28 	bl	8f6238f8 <insert_in_run_queue_tail.constprop.0>
8f624054:	eaffffef 	b	8f624018 <thread_preempt+0xa4>
		arch_enable_ints();
8f624058:	e5932000 	ldr	r2, [r3]
8f62405c:	e59d300c 	ldr	r3, [r13, #12]
8f624060:	e0332002 	eors	r2, r3, r2
8f624064:	e3a03000 	mov	r3, #0
8f624068:	1a00001b 	bne	8f6240dc <thread_preempt+0x168>
}
8f62406c:	e28dd014 	add	r13, r13, #20
8f624070:	e8bd4030 	pop	{r4, r5, r14}
8f624074:	eafff3e3 	b	8f621008 <arch_enable_ints>
		arch_disable_ints();
8f624078:	ebfff3e6 	bl	8f621018 <arch_disable_ints>
8f62407c:	eaffffd5 	b	8f623fd8 <thread_preempt+0x64>
	ASSERT(current_thread->state == THREAD_RUNNING);
8f624080:	e307cfe4 	movw	r12, #32740	; 0x7fe4
8f624084:	e3072e78 	movw	r2, #32376	; 0x7e78
8f624088:	e348cf70 	movt	r12, #36720	; 0x8f70
8f62408c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f624090:	e3001130 	movw	r1, #304	; 0x130
8f624094:	e3a03e1b 	mov	r3, #432	; 0x1b0
8f624098:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62409c:	e1a00004 	mov	r0, r4
8f6240a0:	e58dc000 	str	r12, [r13]
8f6240a4:	eb003a84 	bl	8f632abc <_panic>
8f6240a8:	eaffffc3 	b	8f623fbc <thread_preempt+0x48>
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f6240ac:	e30031af 	movw	r3, #431	; 0x1af
8f6240b0:	e3071fbc 	movw	r1, #32700	; 0x7fbc
8f6240b4:	e3072e78 	movw	r2, #32376	; 0x7e78
8f6240b8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6240bc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6240c0:	e58d1000 	str	r1, [r13]
8f6240c4:	e1a0000e 	mov	r0, r14
8f6240c8:	e3001130 	movw	r1, #304	; 0x130
8f6240cc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6240d0:	eb003a79 	bl	8f632abc <_panic>
	ASSERT(current_thread->state == THREAD_RUNNING);
8f6240d4:	e5953000 	ldr	r3, [r5]
8f6240d8:	eaffffb4 	b	8f623fb0 <thread_preempt+0x3c>
}
8f6240dc:	eb003ab7 	bl	8f632bc0 <__stack_chk_fail>
8f6240e0:	8f74221c 	.word	0x8f74221c

8f6240e4 <thread_block>:
{
8f6240e4:	e92d4030 	push	{r4, r5, r14}
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f6240e8:	e3024cc0 	movw	r4, #11456	; 0x2cc0
8f6240ec:	e3484f74 	movt	r4, #36724	; 0x8f74
{
8f6240f0:	e59f1110 	ldr	r1, [pc, #272]	; 8f624208 <thread_block+0x124>
8f6240f4:	e24dd014 	sub	r13, r13, #20
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f6240f8:	e3072264 	movw	r2, #29284	; 0x7264
8f6240fc:	e5943000 	ldr	r3, [r4]
{
8f624100:	e5911000 	ldr	r1, [r1]
8f624104:	e58d100c 	str	r1, [r13, #12]
8f624108:	e3a01000 	mov	r1, #0
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f62410c:	e3472468 	movt	r2, #29800	; 0x7468
8f624110:	e1a0500e 	mov	r5, r14
8f624114:	e5931000 	ldr	r1, [r3]
8f624118:	e1510002 	cmp	r1, r2
8f62411c:	1a00002c 	bne	8f6241d4 <thread_block+0xf0>
	ASSERT(current_thread->state == THREAD_BLOCKED);
8f624120:	e5d33018 	ldrb	r3, [r3, #24]
8f624124:	e3530003 	cmp	r3, #3
8f624128:	1a00001e 	bne	8f6241a8 <thread_block+0xc4>
	critical_section_count++;
8f62412c:	e3014acc 	movw	r4, #6860	; 0x1acc
8f624130:	e3484f71 	movt	r4, #36721	; 0x8f71
8f624134:	e5943000 	ldr	r3, [r4]
8f624138:	e2833001 	add	r3, r3, #1
8f62413c:	e5843000 	str	r3, [r4]
	if (critical_section_count == 1)
8f624140:	e3530001 	cmp	r3, #1
8f624144:	0a000015 	beq	8f6241a0 <thread_block+0xbc>
	thread_resched();
8f624148:	ebfffd38 	bl	8f623630 <thread_resched>
	critical_section_count--;
8f62414c:	e5943000 	ldr	r3, [r4]
8f624150:	e2433001 	sub	r3, r3, #1
8f624154:	e5843000 	str	r3, [r4]
	if (critical_section_count == 0)
8f624158:	e3530000 	cmp	r3, #0
		arch_enable_ints();
8f62415c:	e59f30a4 	ldr	r3, [pc, #164]	; 8f624208 <thread_block+0x124>
	if (critical_section_count == 0)
8f624160:	0a000006 	beq	8f624180 <thread_block+0x9c>
}
8f624164:	e5932000 	ldr	r2, [r3]
8f624168:	e59d300c 	ldr	r3, [r13, #12]
8f62416c:	e0332002 	eors	r2, r3, r2
8f624170:	e3a03000 	mov	r3, #0
8f624174:	1a000022 	bne	8f624204 <thread_block+0x120>
8f624178:	e28dd014 	add	r13, r13, #20
8f62417c:	e8bd8030 	pop	{r4, r5, r15}
		arch_enable_ints();
8f624180:	e5932000 	ldr	r2, [r3]
8f624184:	e59d300c 	ldr	r3, [r13, #12]
8f624188:	e0332002 	eors	r2, r3, r2
8f62418c:	e3a03000 	mov	r3, #0
8f624190:	1a00001b 	bne	8f624204 <thread_block+0x120>
8f624194:	e28dd014 	add	r13, r13, #20
8f624198:	e8bd4030 	pop	{r4, r5, r14}
8f62419c:	eafff399 	b	8f621008 <arch_enable_ints>
		arch_disable_ints();
8f6241a0:	ebfff39c 	bl	8f621018 <arch_disable_ints>
8f6241a4:	eaffffe7 	b	8f624148 <thread_block+0x64>
	ASSERT(current_thread->state == THREAD_BLOCKED);
8f6241a8:	e308c04c 	movw	r12, #32844	; 0x804c
8f6241ac:	e3072e78 	movw	r2, #32376	; 0x7e78
8f6241b0:	e348cf70 	movt	r12, #36720	; 0x8f70
8f6241b4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6241b8:	e3001130 	movw	r1, #304	; 0x130
8f6241bc:	e30031d3 	movw	r3, #467	; 0x1d3
8f6241c0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6241c4:	e1a00005 	mov	r0, r5
8f6241c8:	e58dc000 	str	r12, [r13]
8f6241cc:	eb003a3a 	bl	8f632abc <_panic>
8f6241d0:	eaffffd5 	b	8f62412c <thread_block+0x48>
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f6241d4:	e30031d2 	movw	r3, #466	; 0x1d2
8f6241d8:	e3071fbc 	movw	r1, #32700	; 0x7fbc
8f6241dc:	e3072e78 	movw	r2, #32376	; 0x7e78
8f6241e0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6241e4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6241e8:	e58d1000 	str	r1, [r13]
8f6241ec:	e1a0000e 	mov	r0, r14
8f6241f0:	e3001130 	movw	r1, #304	; 0x130
8f6241f4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6241f8:	eb003a2f 	bl	8f632abc <_panic>
	ASSERT(current_thread->state == THREAD_BLOCKED);
8f6241fc:	e5943000 	ldr	r3, [r4]
8f624200:	eaffffc6 	b	8f624120 <thread_block+0x3c>
}
8f624204:	eb003a6d 	bl	8f632bc0 <__stack_chk_fail>
8f624208:	8f74221c 	.word	0x8f74221c

8f62420c <thread_timer_tick>:
	if (current_thread == idle_thread)
8f62420c:	e3022cc0 	movw	r2, #11456	; 0x2cc0
8f624210:	e3023cf8 	movw	r3, #11512	; 0x2cf8
8f624214:	e3482f74 	movt	r2, #36724	; 0x8f74
8f624218:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f62421c:	e59f1060 	ldr	r1, [pc, #96]	; 8f624284 <thread_timer_tick+0x78>
	if (current_thread == idle_thread)
8f624220:	e5922000 	ldr	r2, [r2]
8f624224:	e5933000 	ldr	r3, [r3]
{
8f624228:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	if (current_thread == idle_thread)
8f62422c:	e1520003 	cmp	r2, r3
{
8f624230:	e24dd00c 	sub	r13, r13, #12
8f624234:	e5911000 	ldr	r1, [r1]
8f624238:	e58d1004 	str	r1, [r13, #4]
8f62423c:	e3a01000 	mov	r1, #0
		return INT_NO_RESCHEDULE;
8f624240:	03a00000 	moveq	r0, #0
	if (current_thread == idle_thread)
8f624244:	0a000005 	beq	8f624260 <thread_timer_tick+0x54>
	current_thread->remaining_quantum--;
8f624248:	e5920020 	ldr	r0, [r2, #32]
8f62424c:	e2400001 	sub	r0, r0, #1
8f624250:	e5820020 	str	r0, [r2, #32]
		return INT_NO_RESCHEDULE;
8f624254:	e3500000 	cmp	r0, #0
8f624258:	c3a00000 	movgt	r0, #0
8f62425c:	d3a00001 	movle	r0, #1
}
8f624260:	e59f301c 	ldr	r3, [pc, #28]	; 8f624284 <thread_timer_tick+0x78>
8f624264:	e5932000 	ldr	r2, [r3]
8f624268:	e59d3004 	ldr	r3, [r13, #4]
8f62426c:	e0332002 	eors	r2, r3, r2
8f624270:	e3a03000 	mov	r3, #0
8f624274:	1a000001 	bne	8f624280 <thread_timer_tick+0x74>
8f624278:	e28dd00c 	add	r13, r13, #12
8f62427c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f624280:	eb003a4e 	bl	8f632bc0 <__stack_chk_fail>
8f624284:	8f74221c 	.word	0x8f74221c

8f624288 <thread_sleep>:
 * Note that this function could sleep for longer than the specified delay if
 * other threads are running.  When the timer expires, this thread will
 * be placed at the head of the run queue.
 */
void thread_sleep(time_t delay)
{
8f624288:	e92d4070 	push	{r4, r5, r6, r14}
	timer_t timer;

#if THREAD_CHECKS
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f62428c:	e3025cc0 	movw	r5, #11456	; 0x2cc0
8f624290:	e3485f74 	movt	r5, #36724	; 0x8f74
{
8f624294:	e59f1128 	ldr	r1, [pc, #296]	; 8f6243c4 <thread_sleep+0x13c>
8f624298:	e24dd028 	sub	r13, r13, #40	; 0x28
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f62429c:	e3072264 	movw	r2, #29284	; 0x7264
8f6242a0:	e5953000 	ldr	r3, [r5]
{
8f6242a4:	e5911000 	ldr	r1, [r1]
8f6242a8:	e58d1024 	str	r1, [r13, #36]	; 0x24
8f6242ac:	e3a01000 	mov	r1, #0
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f6242b0:	e3472468 	movt	r2, #29800	; 0x7468
8f6242b4:	e1a0400e 	mov	r4, r14
{
8f6242b8:	e1a06000 	mov	r6, r0
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f6242bc:	e5931000 	ldr	r1, [r3]
8f6242c0:	e1510002 	cmp	r1, r2
8f6242c4:	1a000031 	bne	8f624390 <thread_sleep+0x108>
	ASSERT(current_thread->state == THREAD_RUNNING);
8f6242c8:	e5d33018 	ldrb	r3, [r3, #24]
8f6242cc:	e3530002 	cmp	r3, #2
8f6242d0:	1a000023 	bne	8f624364 <thread_sleep+0xdc>
	critical_section_count++;
8f6242d4:	e3014acc 	movw	r4, #6860	; 0x1acc
8f6242d8:	e3484f71 	movt	r4, #36721	; 0x8f71
#endif

	timer_initialize(&timer);
8f6242dc:	e28d0008 	add	r0, r13, #8
8f6242e0:	eb000372 	bl	8f6250b0 <timer_initialize>
8f6242e4:	e5943000 	ldr	r3, [r4]
8f6242e8:	e2833001 	add	r3, r3, #1
8f6242ec:	e5843000 	str	r3, [r4]
	if (critical_section_count == 1)
8f6242f0:	e3530001 	cmp	r3, #1
8f6242f4:	0a000018 	beq	8f62435c <thread_sleep+0xd4>

	enter_critical_section();
	timer_set_oneshot(&timer, delay, thread_sleep_handler, (void *)current_thread);
8f6242f8:	e5953000 	ldr	r3, [r5]
8f6242fc:	e28d0008 	add	r0, r13, #8
8f624300:	e1a01006 	mov	r1, r6
8f624304:	e3032554 	movw	r2, #13652	; 0x3554
8f624308:	e3482f62 	movt	r2, #36706	; 0x8f62
8f62430c:	eb000380 	bl	8f625114 <timer_set_oneshot>
	current_thread->state = THREAD_SLEEPING;
8f624310:	e5953000 	ldr	r3, [r5]
8f624314:	e3a02004 	mov	r2, #4
8f624318:	e5c32018 	strb	r2, [r3, #24]
	thread_resched();
8f62431c:	ebfffcc3 	bl	8f623630 <thread_resched>
	critical_section_count--;
8f624320:	e5943000 	ldr	r3, [r4]
8f624324:	e2433001 	sub	r3, r3, #1
8f624328:	e5843000 	str	r3, [r4]
	if (critical_section_count == 0)
8f62432c:	e3530000 	cmp	r3, #0
8f624330:	0a000007 	beq	8f624354 <thread_sleep+0xcc>
	exit_critical_section();
}
8f624334:	e59f3088 	ldr	r3, [pc, #136]	; 8f6243c4 <thread_sleep+0x13c>
8f624338:	e5932000 	ldr	r2, [r3]
8f62433c:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f624340:	e0332002 	eors	r2, r3, r2
8f624344:	e3a03000 	mov	r3, #0
8f624348:	1a00001c 	bne	8f6243c0 <thread_sleep+0x138>
8f62434c:	e28dd028 	add	r13, r13, #40	; 0x28
8f624350:	e8bd8070 	pop	{r4, r5, r6, r15}
		arch_enable_ints();
8f624354:	ebfff32b 	bl	8f621008 <arch_enable_ints>
8f624358:	eafffff5 	b	8f624334 <thread_sleep+0xac>
		arch_disable_ints();
8f62435c:	ebfff32d 	bl	8f621018 <arch_disable_ints>
8f624360:	eaffffe4 	b	8f6242f8 <thread_sleep+0x70>
	ASSERT(current_thread->state == THREAD_RUNNING);
8f624364:	e3071fe4 	movw	r1, #32740	; 0x7fe4
8f624368:	e3072e78 	movw	r2, #32376	; 0x7e78
8f62436c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f624370:	e3482f70 	movt	r2, #36720	; 0x8f70
8f624374:	e58d1000 	str	r1, [r13]
8f624378:	e300320a 	movw	r3, #522	; 0x20a
8f62437c:	e1a00004 	mov	r0, r4
8f624380:	e3001130 	movw	r1, #304	; 0x130
8f624384:	e3481f70 	movt	r1, #36720	; 0x8f70
8f624388:	eb0039cb 	bl	8f632abc <_panic>
8f62438c:	eaffffd0 	b	8f6242d4 <thread_sleep+0x4c>
	ASSERT(current_thread->magic == THREAD_MAGIC);
8f624390:	e3003209 	movw	r3, #521	; 0x209
8f624394:	e3072fbc 	movw	r2, #32700	; 0x7fbc
8f624398:	e3001130 	movw	r1, #304	; 0x130
8f62439c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6243a0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6243a4:	e58d2000 	str	r2, [r13]
8f6243a8:	e1a0000e 	mov	r0, r14
8f6243ac:	e3072e78 	movw	r2, #32376	; 0x7e78
8f6243b0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6243b4:	eb0039c0 	bl	8f632abc <_panic>
	ASSERT(current_thread->state == THREAD_RUNNING);
8f6243b8:	e5953000 	ldr	r3, [r5]
8f6243bc:	eaffffc1 	b	8f6242c8 <thread_sleep+0x40>
}
8f6243c0:	eb0039fe 	bl	8f632bc0 <__stack_chk_fail>
8f6243c4:	8f74221c 	.word	0x8f74221c

8f6243c8 <thread_init_early>:
 * @brief  Initialize threading system
 *
 * This function is called once, from kmain()
 */
void thread_init_early(void)
{
8f6243c8:	e59f10d8 	ldr	r1, [pc, #216]	; 8f6244a8 <thread_init_early+0xe0>
8f6243cc:	e3043080 	movw	r3, #16512	; 0x4080
8f6243d0:	e92d4030 	push	{r4, r5, r14}
8f6243d4:	e3483f73 	movt	r3, #36723	; 0x8f73
8f6243d8:	e24dd00c 	sub	r13, r13, #12
8f6243dc:	e2832c01 	add	r2, r3, #256	; 0x100
8f6243e0:	e5911000 	ldr	r1, [r1]
8f6243e4:	e58d1004 	str	r1, [r13, #4]
8f6243e8:	e3a01000 	mov	r1, #0
	list->prev = list->next = list;
8f6243ec:	e5833004 	str	r3, [r3, #4]
8f6243f0:	e5833000 	str	r3, [r3]
	int i;

	/* initialize the run queues */
	for (i=0; i < NUM_PRIORITIES; i++)
8f6243f4:	e2833008 	add	r3, r3, #8
8f6243f8:	e1530002 	cmp	r3, r2
8f6243fc:	1afffffa 	bne	8f6243ec <thread_init_early+0x24>
	memset(t, 0, sizeof(thread_t));
8f624400:	e304401c 	movw	r4, #16412	; 0x401c
8f624404:	e3484f73 	movt	r4, #36723	; 0x8f73
8f624408:	e3045184 	movw	r5, #16772	; 0x4184
8f62440c:	e3485f73 	movt	r5, #36723	; 0x8f73
8f624410:	e3a02064 	mov	r2, #100	; 0x64
8f624414:	e3a01000 	mov	r1, #0
8f624418:	e1a00004 	mov	r0, r4
8f62441c:	e5855004 	str	r5, [r5, #4]
8f624420:	e5855000 	str	r5, [r5]
8f624424:	eb003fa6 	bl	8f6342c4 <memset>
	t->magic = THREAD_MAGIC;
8f624428:	e1a00004 	mov	r0, r4
	strlcpy(t->name, name, sizeof(t->name));
8f62442c:	e3a02020 	mov	r2, #32
	t->magic = THREAD_MAGIC;
8f624430:	e3073264 	movw	r3, #29284	; 0x7264
	strlcpy(t->name, name, sizeof(t->name));
8f624434:	e3081074 	movw	r1, #32884	; 0x8074
	t->magic = THREAD_MAGIC;
8f624438:	e3473468 	movt	r3, #29800	; 0x7468
	strlcpy(t->name, name, sizeof(t->name));
8f62443c:	e3481f70 	movt	r1, #36720	; 0x8f70
	t->magic = THREAD_MAGIC;
8f624440:	e4803044 	str	r3, [r0], #68	; 0x44
	strlcpy(t->name, name, sizeof(t->name));
8f624444:	eb0040b9 	bl	8f634730 <strlcpy>
	item->next = list->next;
8f624448:	e5951004 	ldr	r1, [r5, #4]
	item->prev = list;
8f62444c:	e1a03004 	mov	r3, r4
	/* create a thread to cover the current running state */
	thread_t *t = &bootstrap_thread;
	init_thread_struct(t, "bootstrap");

	/* half construct this thread, since we're already running */
	t->priority = HIGHEST_PRIORITY;
8f624450:	e3a0001f 	mov	r0, #31
8f624454:	e5a35004 	str	r5, [r3, #4]!
	t->state = THREAD_RUNNING;
	t->saved_critical_section_count = 1;
	list_add_head(&thread_list, &t->thread_list_node);
	current_thread = t;
8f624458:	e3022cc0 	movw	r2, #11456	; 0x2cc0
	t->priority = HIGHEST_PRIORITY;
8f62445c:	e5840014 	str	r0, [r4, #20]
	current_thread = t;
8f624460:	e3482f74 	movt	r2, #36724	; 0x8f74
	t->state = THREAD_RUNNING;
8f624464:	e3a00002 	mov	r0, #2
	item->next = list->next;
8f624468:	e5841008 	str	r1, [r4, #8]
8f62446c:	e5c40018 	strb	r0, [r4, #24]
	t->saved_critical_section_count = 1;
8f624470:	e3a00001 	mov	r0, #1
8f624474:	e584001c 	str	r0, [r4, #28]
	list->next->prev = item;
8f624478:	e5813000 	str	r3, [r1]
	list->next = item;
8f62447c:	e5853004 	str	r3, [r5, #4]
}
8f624480:	e59f3020 	ldr	r3, [pc, #32]	; 8f6244a8 <thread_init_early+0xe0>
	current_thread = t;
8f624484:	e5824000 	str	r4, [r2]
}
8f624488:	e5932000 	ldr	r2, [r3]
8f62448c:	e59d3004 	ldr	r3, [r13, #4]
8f624490:	e0332002 	eors	r2, r3, r2
8f624494:	e3a03000 	mov	r3, #0
8f624498:	1a000001 	bne	8f6244a4 <thread_init_early+0xdc>
8f62449c:	e28dd00c 	add	r13, r13, #12
8f6244a0:	e8bd8030 	pop	{r4, r5, r15}
8f6244a4:	eb0039c5 	bl	8f632bc0 <__stack_chk_fail>
8f6244a8:	8f74221c 	.word	0x8f74221c

8f6244ac <thread_init>:
 * @brief Complete thread initialization
 *
 * This function is called once at boot time
 */
void thread_init(void)
{
8f6244ac:	e59f3034 	ldr	r3, [pc, #52]	; 8f6244e8 <thread_init+0x3c>
8f6244b0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6244b4:	e24dd00c 	sub	r13, r13, #12
8f6244b8:	e5933000 	ldr	r3, [r3]
8f6244bc:	e58d3004 	str	r3, [r13, #4]
8f6244c0:	e3a03000 	mov	r3, #0
#if PLATFORM_HAS_DYNAMIC_TIMER
	timer_initialize(&preempt_timer);
#endif
}
8f6244c4:	e59f301c 	ldr	r3, [pc, #28]	; 8f6244e8 <thread_init+0x3c>
8f6244c8:	e5932000 	ldr	r2, [r3]
8f6244cc:	e59d3004 	ldr	r3, [r13, #4]
8f6244d0:	e0332002 	eors	r2, r3, r2
8f6244d4:	e3a03000 	mov	r3, #0
8f6244d8:	1a000001 	bne	8f6244e4 <thread_init+0x38>
8f6244dc:	e28dd00c 	add	r13, r13, #12
8f6244e0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6244e4:	eb0039b5 	bl	8f632bc0 <__stack_chk_fail>
8f6244e8:	8f74221c 	.word	0x8f74221c

8f6244ec <thread_become_idle>:
/**
 * @brief Change name of current thread
 */
void thread_set_name(const char *name)
{
	strlcpy(current_thread->name, name, sizeof(current_thread->name));
8f6244ec:	e3024cc0 	movw	r4, #11456	; 0x2cc0
8f6244f0:	e3484f74 	movt	r4, #36724	; 0x8f74
 * This function marks the current thread as the idle thread -- the one which
 * executes when there is nothing else to do.  This function does not return.
 * This function is called once at boot time.
 */
void thread_become_idle(void)
{
8f6244f4:	e59f3048 	ldr	r3, [pc, #72]	; 8f624544 <thread_become_idle+0x58>
	strlcpy(current_thread->name, name, sizeof(current_thread->name));
8f6244f8:	e3a02020 	mov	r2, #32
8f6244fc:	e5940000 	ldr	r0, [r4]
8f624500:	e3081080 	movw	r1, #32896	; 0x8080
{
8f624504:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	strlcpy(current_thread->name, name, sizeof(current_thread->name));
8f624508:	e3481f70 	movt	r1, #36720	; 0x8f70
{
8f62450c:	e24dd00c 	sub	r13, r13, #12
	strlcpy(current_thread->name, name, sizeof(current_thread->name));
8f624510:	e2800044 	add	r0, r0, #68	; 0x44
{
8f624514:	e5933000 	ldr	r3, [r3]
8f624518:	e58d3004 	str	r3, [r13, #4]
8f62451c:	e3a03000 	mov	r3, #0
	strlcpy(current_thread->name, name, sizeof(current_thread->name));
8f624520:	eb004082 	bl	8f634730 <strlcpy>
	current_thread->priority = priority;
8f624524:	e5942000 	ldr	r2, [r4]
	thread_set_name("idle");
	thread_set_priority(IDLE_PRIORITY);
	idle_thread = current_thread;
8f624528:	e3023cf8 	movw	r3, #11512	; 0x2cf8
8f62452c:	e3483f74 	movt	r3, #36724	; 0x8f74
	current_thread->priority = priority;
8f624530:	e3a01000 	mov	r1, #0
	idle_thread = current_thread;
8f624534:	e5832000 	str	r2, [r3]
	current_thread->priority = priority;
8f624538:	e5821014 	str	r1, [r2, #20]
		arch_idle();
8f62453c:	ebfff2da 	bl	8f6210ac <arch_idle>
	for(;;)
8f624540:	eafffffd 	b	8f62453c <thread_become_idle+0x50>
8f624544:	8f74221c 	.word	0x8f74221c

8f624548 <wait_queue_init>:

/**
 * @brief  Initialize a wait queue
 */
void wait_queue_init(wait_queue_t *wait)
{
8f624548:	e59fc054 	ldr	r12, [pc, #84]	; 8f6245a4 <wait_queue_init+0x5c>
	wait->magic = WAIT_QUEUE_MAGIC;
8f62454c:	e1a03000 	mov	r3, r0
{
8f624550:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f624554:	e24dd00c 	sub	r13, r13, #12
8f624558:	e59cc000 	ldr	r12, [r12]
8f62455c:	e58dc004 	str	r12, [r13, #4]
8f624560:	e3a0c000 	mov	r12, #0
	wait->magic = WAIT_QUEUE_MAGIC;
8f624564:	e3062974 	movw	r2, #26996	; 0x6974
8f624568:	e3472761 	movt	r2, #30561	; 0x7761
8f62456c:	e4832004 	str	r2, [r3], #4
	list->prev = list->next = list;
8f624570:	e5803008 	str	r3, [r0, #8]
	list_initialize(&wait->list);
	wait->count = 0;
8f624574:	e3a01000 	mov	r1, #0
8f624578:	e5803004 	str	r3, [r0, #4]
}
8f62457c:	e59f3020 	ldr	r3, [pc, #32]	; 8f6245a4 <wait_queue_init+0x5c>
	wait->count = 0;
8f624580:	e580100c 	str	r1, [r0, #12]
}
8f624584:	e5932000 	ldr	r2, [r3]
8f624588:	e59d3004 	ldr	r3, [r13, #4]
8f62458c:	e0332002 	eors	r2, r3, r2
8f624590:	e3a03000 	mov	r3, #0
8f624594:	1a000001 	bne	8f6245a0 <wait_queue_init+0x58>
8f624598:	e28dd00c 	add	r13, r13, #12
8f62459c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6245a0:	eb003986 	bl	8f632bc0 <__stack_chk_fail>
8f6245a4:	8f74221c 	.word	0x8f74221c

8f6245a8 <wait_queue_block>:
status_t wait_queue_block(wait_queue_t *wait, time_t timeout)
{
	timer_t timer;

#if THREAD_CHECKS
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
8f6245a8:	e5902000 	ldr	r2, [r0]
8f6245ac:	e3063974 	movw	r3, #26996	; 0x6974
8f6245b0:	e3473761 	movt	r3, #30561	; 0x7761
8f6245b4:	e1520003 	cmp	r2, r3
{
8f6245b8:	e59f3188 	ldr	r3, [pc, #392]	; 8f624748 <wait_queue_block+0x1a0>
8f6245bc:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f6245c0:	e24dd02c 	sub	r13, r13, #44	; 0x2c
8f6245c4:	e5933000 	ldr	r3, [r3]
8f6245c8:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f6245cc:	e3a03000 	mov	r3, #0
8f6245d0:	e1a04000 	mov	r4, r0
8f6245d4:	e1a0700e 	mov	r7, r14
8f6245d8:	e1a06001 	mov	r6, r1
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
8f6245dc:	1a000040 	bne	8f6246e4 <wait_queue_block+0x13c>
	ASSERT(current_thread->state == THREAD_RUNNING);
8f6245e0:	e3025cc0 	movw	r5, #11456	; 0x2cc0
8f6245e4:	e3485f74 	movt	r5, #36724	; 0x8f74
8f6245e8:	e5953000 	ldr	r3, [r5]
8f6245ec:	e5d33018 	ldrb	r3, [r3, #24]
8f6245f0:	e3530002 	cmp	r3, #2
8f6245f4:	1a000045 	bne	8f624710 <wait_queue_block+0x168>
	return critical_section_count > 0;
8f6245f8:	e3013acc 	movw	r3, #6860	; 0x1acc
8f6245fc:	e3483f71 	movt	r3, #36721	; 0x8f71
	ASSERT(in_critical_section());
8f624600:	e5933000 	ldr	r3, [r3]
8f624604:	e3530000 	cmp	r3, #0
8f624608:	da00002a 	ble	8f6246b8 <wait_queue_block+0x110>
#endif

	if (timeout == 0)
8f62460c:	e3560000 	cmp	r6, #0
8f624610:	0a000049 	beq	8f62473c <wait_queue_block+0x194>
	item->prev = list->prev;
8f624614:	e1a02004 	mov	r2, r4
		return ERR_TIMED_OUT;

	list_add_tail(&wait->list, &current_thread->queue_node);
8f624618:	e5953000 	ldr	r3, [r5]
8f62461c:	e5b20004 	ldr	r0, [r2, #4]!
	current_thread->state = THREAD_BLOCKED;
	current_thread->blocking_wait_queue = wait;
	current_thread->wait_queue_block_ret = NO_ERROR;

	/* if the timeout is nonzero or noninfinite, set a callback to yank us out of the queue */
	if (timeout != INFINITE_TIME) {
8f624620:	e3760001 	cmn	r6, #1
	list_add_tail(&wait->list, &current_thread->queue_node);
8f624624:	e283100c 	add	r1, r3, #12
	item->next = list;
8f624628:	e5832010 	str	r2, [r3, #16]
	wait->count++;
8f62462c:	e594200c 	ldr	r2, [r4, #12]
	item->prev = list->prev;
8f624630:	e583000c 	str	r0, [r3, #12]
8f624634:	e2822001 	add	r2, r2, #1
	list->prev->next = item;
8f624638:	e5801004 	str	r1, [r0, #4]
	list->prev = item;
8f62463c:	e5841004 	str	r1, [r4, #4]
	current_thread->state = THREAD_BLOCKED;
8f624640:	e3a01003 	mov	r1, #3
	wait->count++;
8f624644:	e584200c 	str	r2, [r4, #12]
	current_thread->wait_queue_block_ret = NO_ERROR;
8f624648:	e3a02000 	mov	r2, #0
	current_thread->blocking_wait_queue = wait;
8f62464c:	e5834024 	str	r4, [r3, #36]	; 0x24
	current_thread->state = THREAD_BLOCKED;
8f624650:	e5c31018 	strb	r1, [r3, #24]
	current_thread->wait_queue_block_ret = NO_ERROR;
8f624654:	e5832028 	str	r2, [r3, #40]	; 0x28
	if (timeout != INFINITE_TIME) {
8f624658:	1a00000a 	bne	8f624688 <wait_queue_block+0xe0>
		timer_initialize(&timer);
		timer_set_oneshot(&timer, timeout, wait_queue_timeout_handler, (void *)current_thread);
	}

	thread_block();
8f62465c:	ebfffea0 	bl	8f6240e4 <thread_block>
	/* we don't really know if the timer fired or not, so it's better safe to try to cancel it */
	if (timeout != INFINITE_TIME) {
		timer_cancel(&timer);
	}

	return current_thread->wait_queue_block_ret;
8f624660:	e5953000 	ldr	r3, [r5]
8f624664:	e5930028 	ldr	r0, [r3, #40]	; 0x28
}
8f624668:	e59f30d8 	ldr	r3, [pc, #216]	; 8f624748 <wait_queue_block+0x1a0>
8f62466c:	e5932000 	ldr	r2, [r3]
8f624670:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f624674:	e0332002 	eors	r2, r3, r2
8f624678:	e3a03000 	mov	r3, #0
8f62467c:	1a000030 	bne	8f624744 <wait_queue_block+0x19c>
8f624680:	e28dd02c 	add	r13, r13, #44	; 0x2c
8f624684:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		timer_initialize(&timer);
8f624688:	e28d0008 	add	r0, r13, #8
8f62468c:	eb000287 	bl	8f6250b0 <timer_initialize>
		timer_set_oneshot(&timer, timeout, wait_queue_timeout_handler, (void *)current_thread);
8f624690:	e28d0008 	add	r0, r13, #8
8f624694:	e5953000 	ldr	r3, [r5]
8f624698:	e1a01006 	mov	r1, r6
8f62469c:	e3042d38 	movw	r2, #19768	; 0x4d38
8f6246a0:	e3482f62 	movt	r2, #36706	; 0x8f62
8f6246a4:	eb00029a 	bl	8f625114 <timer_set_oneshot>
	thread_block();
8f6246a8:	ebfffe8d 	bl	8f6240e4 <thread_block>
		timer_cancel(&timer);
8f6246ac:	e28d0008 	add	r0, r13, #8
8f6246b0:	eb0002ae 	bl	8f625170 <timer_cancel>
8f6246b4:	eaffffe9 	b	8f624660 <wait_queue_block+0xb8>
	ASSERT(in_critical_section());
8f6246b8:	e3073ee0 	movw	r3, #32480	; 0x7ee0
8f6246bc:	e1a00007 	mov	r0, r7
8f6246c0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6246c4:	e3072e78 	movw	r2, #32376	; 0x7e78
8f6246c8:	e58d3000 	str	r3, [r13]
8f6246cc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6246d0:	e3a03faf 	mov	r3, #700	; 0x2bc
8f6246d4:	e3001130 	movw	r1, #304	; 0x130
8f6246d8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6246dc:	eb0038f6 	bl	8f632abc <_panic>
8f6246e0:	eaffffc9 	b	8f62460c <wait_queue_block+0x64>
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
8f6246e4:	e3081088 	movw	r1, #32904	; 0x8088
8f6246e8:	e3072e78 	movw	r2, #32376	; 0x7e78
8f6246ec:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6246f0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6246f4:	e58d1000 	str	r1, [r13]
8f6246f8:	e30032ba 	movw	r3, #698	; 0x2ba
8f6246fc:	e3001130 	movw	r1, #304	; 0x130
8f624700:	e1a0000e 	mov	r0, r14
8f624704:	e3481f70 	movt	r1, #36720	; 0x8f70
8f624708:	eb0038eb 	bl	8f632abc <_panic>
8f62470c:	eaffffb3 	b	8f6245e0 <wait_queue_block+0x38>
	ASSERT(current_thread->state == THREAD_RUNNING);
8f624710:	e3073fe4 	movw	r3, #32740	; 0x7fe4
8f624714:	e3072e78 	movw	r2, #32376	; 0x7e78
8f624718:	e3483f70 	movt	r3, #36720	; 0x8f70
8f62471c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f624720:	e58d3000 	str	r3, [r13]
8f624724:	e3001130 	movw	r1, #304	; 0x130
8f624728:	e30032bb 	movw	r3, #699	; 0x2bb
8f62472c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f624730:	e1a00007 	mov	r0, r7
8f624734:	eb0038e0 	bl	8f632abc <_panic>
8f624738:	eaffffae 	b	8f6245f8 <wait_queue_block+0x50>
		return ERR_TIMED_OUT;
8f62473c:	e3e0000c 	mvn	r0, #12
8f624740:	eaffffc8 	b	8f624668 <wait_queue_block+0xc0>
}
8f624744:	eb00391d 	bl	8f632bc0 <__stack_chk_fail>
8f624748:	8f74221c 	.word	0x8f74221c

8f62474c <wait_queue_wake_one>:
 * from wait_queue_block().
 *
 * @return  The number of threads woken (zero or one)
 */
int wait_queue_wake_one(wait_queue_t *wait, bool reschedule, status_t wait_queue_error)
{
8f62474c:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f624750:	e1a06002 	mov	r6, r2
8f624754:	e59f2190 	ldr	r2, [pc, #400]	; 8f6248ec <wait_queue_wake_one+0x1a0>
8f624758:	e24dd010 	sub	r13, r13, #16
	thread_t *t;
	int ret = 0;

#if THREAD_CHECKS
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
8f62475c:	e3063974 	movw	r3, #26996	; 0x6974
8f624760:	e3473761 	movt	r3, #30561	; 0x7761
{
8f624764:	e5922000 	ldr	r2, [r2]
8f624768:	e58d200c 	str	r2, [r13, #12]
8f62476c:	e3a02000 	mov	r2, #0
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
8f624770:	e5902000 	ldr	r2, [r0]
{
8f624774:	e1a04000 	mov	r4, r0
8f624778:	e1a0800e 	mov	r8, r14
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
8f62477c:	e1520003 	cmp	r2, r3
{
8f624780:	e1a07001 	mov	r7, r1
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
8f624784:	1a000041 	bne	8f624890 <wait_queue_wake_one+0x144>
8f624788:	e3013acc 	movw	r3, #6860	; 0x1acc
8f62478c:	e3483f71 	movt	r3, #36721	; 0x8f71
	ASSERT(in_critical_section());
8f624790:	e5933000 	ldr	r3, [r3]
8f624794:	e3530000 	cmp	r3, #0
8f624798:	da000031 	ble	8f624864 <wait_queue_wake_one+0x118>
	if(list->next != list) {
8f62479c:	e5943008 	ldr	r3, [r4, #8]
#endif

	t = list_remove_head_type(&wait->list, thread_t, queue_node);
8f6247a0:	e2842004 	add	r2, r4, #4
8f6247a4:	e1530002 	cmp	r3, r2
8f6247a8:	0a00002b 	beq	8f62485c <wait_queue_wake_one+0x110>
	item->next->prev = item->prev;
8f6247ac:	e5931004 	ldr	r1, [r3, #4]
	if (t) {
8f6247b0:	e353000c 	cmp	r3, #12
8f6247b4:	e5932000 	ldr	r2, [r3]
	item->prev = item->next = 0;
8f6247b8:	e1a05003 	mov	r5, r3
	item->next->prev = item->prev;
8f6247bc:	e5812000 	str	r2, [r1]
	item->prev->next = item->next;
8f6247c0:	e5821004 	str	r1, [r2, #4]
	item->prev = item->next = 0;
8f6247c4:	e3a02000 	mov	r2, #0
8f6247c8:	e5832004 	str	r2, [r3, #4]
8f6247cc:	e405200c 	str	r2, [r5], #-12
8f6247d0:	0a000021 	beq	8f62485c <wait_queue_wake_one+0x110>
		wait->count--;
8f6247d4:	e594300c 	ldr	r3, [r4, #12]
8f6247d8:	e2433001 	sub	r3, r3, #1
8f6247dc:	e584300c 	str	r3, [r4, #12]
#if THREAD_CHECKS
		ASSERT(t->state == THREAD_BLOCKED);
8f6247e0:	e5d53018 	ldrb	r3, [r5, #24]
8f6247e4:	e3530003 	cmp	r3, #3
8f6247e8:	1a000033 	bne	8f6248bc <wait_queue_wake_one+0x170>

		/* if we're instructed to reschedule, stick the current thread on the head
		 * of the run queue first, so that the newly awakened thread gets a chance to run
		 * before the current one, but the current one doesn't get unnecessarilly punished.
		 */
		if (reschedule) {
8f6247ec:	e3570000 	cmp	r7, #0
		t->state = THREAD_READY;
8f6247f0:	e3a04001 	mov	r4, #1
		t->blocking_wait_queue = NULL;
8f6247f4:	e3a03000 	mov	r3, #0
		t->state = THREAD_READY;
8f6247f8:	e5c54018 	strb	r4, [r5, #24]
		t->wait_queue_block_ret = wait_queue_error;
8f6247fc:	e5856028 	str	r6, [r5, #40]	; 0x28
		t->blocking_wait_queue = NULL;
8f624800:	e5853024 	str	r3, [r5, #36]	; 0x24
		if (reschedule) {
8f624804:	1a00000a 	bne	8f624834 <wait_queue_wake_one+0xe8>
			current_thread->state = THREAD_READY;
			insert_in_run_queue_head(current_thread);
		}
		insert_in_run_queue_head(t);
8f624808:	e1a00005 	mov	r0, r5
8f62480c:	ebfffa8c 	bl	8f623244 <insert_in_run_queue_head>
		if (reschedule)
			thread_resched();
		ret = 1;
8f624810:	e1a00004 	mov	r0, r4
	}

	return ret;
}
8f624814:	e59f30d0 	ldr	r3, [pc, #208]	; 8f6248ec <wait_queue_wake_one+0x1a0>
8f624818:	e5932000 	ldr	r2, [r3]
8f62481c:	e59d300c 	ldr	r3, [r13, #12]
8f624820:	e0332002 	eors	r2, r3, r2
8f624824:	e3a03000 	mov	r3, #0
8f624828:	1a00002e 	bne	8f6248e8 <wait_queue_wake_one+0x19c>
8f62482c:	e28dd010 	add	r13, r13, #16
8f624830:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
			current_thread->state = THREAD_READY;
8f624834:	e3023cc0 	movw	r3, #11456	; 0x2cc0
8f624838:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62483c:	e5930000 	ldr	r0, [r3]
8f624840:	e5c04018 	strb	r4, [r0, #24]
			insert_in_run_queue_head(current_thread);
8f624844:	ebfffa7e 	bl	8f623244 <insert_in_run_queue_head>
		insert_in_run_queue_head(t);
8f624848:	e1a00005 	mov	r0, r5
8f62484c:	ebfffa7c 	bl	8f623244 <insert_in_run_queue_head>
			thread_resched();
8f624850:	ebfffb76 	bl	8f623630 <thread_resched>
		ret = 1;
8f624854:	e1a00004 	mov	r0, r4
	return ret;
8f624858:	eaffffed 	b	8f624814 <wait_queue_wake_one+0xc8>
	int ret = 0;
8f62485c:	e3a00000 	mov	r0, #0
8f624860:	eaffffeb 	b	8f624814 <wait_queue_wake_one+0xc8>
	ASSERT(in_critical_section());
8f624864:	e3073ee0 	movw	r3, #32480	; 0x7ee0
8f624868:	e3072e78 	movw	r2, #32376	; 0x7e78
8f62486c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f624870:	e3482f70 	movt	r2, #36720	; 0x8f70
8f624874:	e58d3000 	str	r3, [r13]
8f624878:	e3001130 	movw	r1, #304	; 0x130
8f62487c:	e30032ed 	movw	r3, #749	; 0x2ed
8f624880:	e3481f70 	movt	r1, #36720	; 0x8f70
8f624884:	e1a00008 	mov	r0, r8
8f624888:	eb00388b 	bl	8f632abc <_panic>
8f62488c:	eaffffc2 	b	8f62479c <wait_queue_wake_one+0x50>
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
8f624890:	e3083088 	movw	r3, #32904	; 0x8088
8f624894:	e3072e78 	movw	r2, #32376	; 0x7e78
8f624898:	e3483f70 	movt	r3, #36720	; 0x8f70
8f62489c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6248a0:	e58d3000 	str	r3, [r13]
8f6248a4:	e3001130 	movw	r1, #304	; 0x130
8f6248a8:	e3a03fbb 	mov	r3, #748	; 0x2ec
8f6248ac:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6248b0:	e1a0000e 	mov	r0, r14
8f6248b4:	eb003880 	bl	8f632abc <_panic>
8f6248b8:	eaffffb2 	b	8f624788 <wait_queue_wake_one+0x3c>
		ASSERT(t->state == THREAD_BLOCKED);
8f6248bc:	e30830a8 	movw	r3, #32936	; 0x80a8
8f6248c0:	e1a00008 	mov	r0, r8
8f6248c4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6248c8:	e3072e78 	movw	r2, #32376	; 0x7e78
8f6248cc:	e58d3000 	str	r3, [r13]
8f6248d0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6248d4:	e3a03fbd 	mov	r3, #756	; 0x2f4
8f6248d8:	e3001130 	movw	r1, #304	; 0x130
8f6248dc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6248e0:	eb003875 	bl	8f632abc <_panic>
8f6248e4:	eaffffc0 	b	8f6247ec <wait_queue_wake_one+0xa0>
}
8f6248e8:	eb0038b4 	bl	8f632bc0 <__stack_chk_fail>
8f6248ec:	8f74221c 	.word	0x8f74221c

8f6248f0 <wait_queue_wake_all>:
 * from wait_queue_block().
 *
 * @return  The number of threads woken (zero or one)
 */
int wait_queue_wake_all(wait_queue_t *wait, bool reschedule, status_t wait_queue_error)
{
8f6248f0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f6248f4:	e1a07002 	mov	r7, r2
8f6248f8:	e24dd01c 	sub	r13, r13, #28
8f6248fc:	e59f2230 	ldr	r2, [pc, #560]	; 8f624b34 <wait_queue_wake_all+0x244>
	thread_t *t;
	int ret = 0;

#if THREAD_CHECKS
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
8f624900:	e3063974 	movw	r3, #26996	; 0x6974
8f624904:	e3473761 	movt	r3, #30561	; 0x7761
8f624908:	e58de00c 	str	r14, [r13, #12]
{
8f62490c:	e1a05000 	mov	r5, r0
8f624910:	e58d1008 	str	r1, [r13, #8]
8f624914:	e5922000 	ldr	r2, [r2]
8f624918:	e58d2014 	str	r2, [r13, #20]
8f62491c:	e3a02000 	mov	r2, #0
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
8f624920:	e5902000 	ldr	r2, [r0]
8f624924:	e1520003 	cmp	r2, r3
8f624928:	1a000058 	bne	8f624a90 <wait_queue_wake_all+0x1a0>
8f62492c:	e3013acc 	movw	r3, #6860	; 0x1acc
8f624930:	e3483f71 	movt	r3, #36721	; 0x8f71
	ASSERT(in_critical_section());
8f624934:	e5933000 	ldr	r3, [r3]
8f624938:	e3530000 	cmp	r3, #0
8f62493c:	da00005e 	ble	8f624abc <wait_queue_wake_all+0x1cc>
#endif

	if (reschedule && wait->count > 0) {
8f624940:	e59d3008 	ldr	r3, [r13, #8]
8f624944:	e3530000 	cmp	r3, #0
8f624948:	e595300c 	ldr	r3, [r5, #12]
8f62494c:	0a000001 	beq	8f624958 <wait_queue_wake_all+0x68>
8f624950:	e3530000 	cmp	r3, #0
8f624954:	ca00003e 	bgt	8f624a54 <wait_queue_wake_all+0x164>
	if(list->next != list) {
8f624958:	e5954008 	ldr	r4, [r5, #8]
		current_thread->state = THREAD_READY;
		insert_in_run_queue_head(current_thread);
	}

	/* pop all the threads off the wait queue into the run queue */
	while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
8f62495c:	e2858004 	add	r8, r5, #4
8f624960:	e1580004 	cmp	r8, r4
8f624964:	0a000045 	beq	8f624a80 <wait_queue_wake_all+0x190>
		wait->count--;
#if THREAD_CHECKS
		ASSERT(t->state == THREAD_BLOCKED);
8f624968:	e308b0a8 	movw	r11, #32936	; 0x80a8
8f62496c:	e307ae78 	movw	r10, #32376	; 0x7e78
8f624970:	e3009130 	movw	r9, #304	; 0x130
8f624974:	e348bf70 	movt	r11, #36720	; 0x8f70
8f624978:	e348af70 	movt	r10, #36720	; 0x8f70
8f62497c:	e3489f70 	movt	r9, #36720	; 0x8f70
8f624980:	e3a06000 	mov	r6, #0
	item->next->prev = item->prev;
8f624984:	e5941004 	ldr	r1, [r4, #4]
	while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
8f624988:	e354000c 	cmp	r4, #12
8f62498c:	e5942000 	ldr	r2, [r4]
8f624990:	e5812000 	str	r2, [r1]
	item->prev->next = item->next;
8f624994:	e5821004 	str	r1, [r2, #4]
	item->prev = item->next = 0;
8f624998:	e3a02000 	mov	r2, #0
8f62499c:	e5842004 	str	r2, [r4, #4]
8f6249a0:	e404200c 	str	r2, [r4], #-12
8f6249a4:	0a000010 	beq	8f6249ec <wait_queue_wake_all+0xfc>
		wait->count--;
8f6249a8:	e2433001 	sub	r3, r3, #1
8f6249ac:	e585300c 	str	r3, [r5, #12]
		ASSERT(t->state == THREAD_BLOCKED);
8f6249b0:	e5d43018 	ldrb	r3, [r4, #24]
8f6249b4:	e3530003 	cmp	r3, #3
8f6249b8:	1a00001e 	bne	8f624a38 <wait_queue_wake_all+0x148>
#endif
		t->state = THREAD_READY;
		t->wait_queue_block_ret = wait_queue_error;
		t->blocking_wait_queue = NULL;
8f6249bc:	e3a03000 	mov	r3, #0
		t->state = THREAD_READY;
8f6249c0:	e3a02001 	mov	r2, #1
		t->blocking_wait_queue = NULL;
8f6249c4:	e5843024 	str	r3, [r4, #36]	; 0x24

		insert_in_run_queue_head(t);
8f6249c8:	e1a00004 	mov	r0, r4
		t->state = THREAD_READY;
8f6249cc:	e5c42018 	strb	r2, [r4, #24]
		ret++;
8f6249d0:	e2866001 	add	r6, r6, #1
		t->wait_queue_block_ret = wait_queue_error;
8f6249d4:	e5847028 	str	r7, [r4, #40]	; 0x28
		insert_in_run_queue_head(t);
8f6249d8:	ebfffa19 	bl	8f623244 <insert_in_run_queue_head>
	if(list->next != list) {
8f6249dc:	e5954008 	ldr	r4, [r5, #8]
		wait->count--;
8f6249e0:	e595300c 	ldr	r3, [r5, #12]
8f6249e4:	e1580004 	cmp	r8, r4
8f6249e8:	1affffe5 	bne	8f624984 <wait_queue_wake_all+0x94>
	}

#if THREAD_CHECKS
	ASSERT(wait->count == 0);
8f6249ec:	e3530000 	cmp	r3, #0
#endif

	if (reschedule && ret > 0)
8f6249f0:	e59d3008 	ldr	r3, [r13, #8]
	ASSERT(wait->count == 0);
8f6249f4:	1a00003b 	bne	8f624ae8 <wait_queue_wake_all+0x1f8>
	if (reschedule && ret > 0)
8f6249f8:	e3530000 	cmp	r3, #0
8f6249fc:	13560000 	cmpne	r6, #0
8f624a00:	c3a04001 	movgt	r4, #1
8f624a04:	d3a04000 	movle	r4, #0
8f624a08:	e3540000 	cmp	r4, #0
8f624a0c:	0a000000 	beq	8f624a14 <wait_queue_wake_all+0x124>
		thread_resched();
8f624a10:	ebfffb06 	bl	8f623630 <thread_resched>

	return ret;
}
8f624a14:	e59f3118 	ldr	r3, [pc, #280]	; 8f624b34 <wait_queue_wake_all+0x244>
8f624a18:	e5932000 	ldr	r2, [r3]
8f624a1c:	e59d3014 	ldr	r3, [r13, #20]
8f624a20:	e0332002 	eors	r2, r3, r2
8f624a24:	e3a03000 	mov	r3, #0
8f624a28:	1a000040 	bne	8f624b30 <wait_queue_wake_all+0x240>
8f624a2c:	e1a00006 	mov	r0, r6
8f624a30:	e28dd01c 	add	r13, r13, #28
8f624a34:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		ASSERT(t->state == THREAD_BLOCKED);
8f624a38:	e59d000c 	ldr	r0, [r13, #12]
8f624a3c:	e3003331 	movw	r3, #817	; 0x331
8f624a40:	e1a0200a 	mov	r2, r10
8f624a44:	e1a01009 	mov	r1, r9
8f624a48:	e58db000 	str	r11, [r13]
8f624a4c:	eb00381a 	bl	8f632abc <_panic>
8f624a50:	eaffffd9 	b	8f6249bc <wait_queue_wake_all+0xcc>
		current_thread->state = THREAD_READY;
8f624a54:	e3023cc0 	movw	r3, #11456	; 0x2cc0
8f624a58:	e3483f74 	movt	r3, #36724	; 0x8f74
	while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
8f624a5c:	e2858004 	add	r8, r5, #4
		current_thread->state = THREAD_READY;
8f624a60:	e5930000 	ldr	r0, [r3]
8f624a64:	e3a03001 	mov	r3, #1
8f624a68:	e5c03018 	strb	r3, [r0, #24]
		insert_in_run_queue_head(current_thread);
8f624a6c:	ebfff9f4 	bl	8f623244 <insert_in_run_queue_head>
8f624a70:	e5954008 	ldr	r4, [r5, #8]
	ASSERT(wait->count == 0);
8f624a74:	e595300c 	ldr	r3, [r5, #12]
8f624a78:	e1580004 	cmp	r8, r4
8f624a7c:	1affffb9 	bne	8f624968 <wait_queue_wake_all+0x78>
8f624a80:	e3530000 	cmp	r3, #0
8f624a84:	1a000026 	bne	8f624b24 <wait_queue_wake_all+0x234>
8f624a88:	e1a06003 	mov	r6, r3
8f624a8c:	eaffffe0 	b	8f624a14 <wait_queue_wake_all+0x124>
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
8f624a90:	e3083088 	movw	r3, #32904	; 0x8088
8f624a94:	e3072e78 	movw	r2, #32376	; 0x7e78
8f624a98:	e3483f70 	movt	r3, #36720	; 0x8f70
8f624a9c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f624aa0:	e58d3000 	str	r3, [r13]
8f624aa4:	e3001130 	movw	r1, #304	; 0x130
8f624aa8:	e3a03e32 	mov	r3, #800	; 0x320
8f624aac:	e3481f70 	movt	r1, #36720	; 0x8f70
8f624ab0:	e1a0000e 	mov	r0, r14
8f624ab4:	eb003800 	bl	8f632abc <_panic>
8f624ab8:	eaffff9b 	b	8f62492c <wait_queue_wake_all+0x3c>
	ASSERT(in_critical_section());
8f624abc:	e59d000c 	ldr	r0, [r13, #12]
8f624ac0:	e3073ee0 	movw	r3, #32480	; 0x7ee0
8f624ac4:	e3072e78 	movw	r2, #32376	; 0x7e78
8f624ac8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f624acc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f624ad0:	e58d3000 	str	r3, [r13]
8f624ad4:	e3001130 	movw	r1, #304	; 0x130
8f624ad8:	e3003321 	movw	r3, #801	; 0x321
8f624adc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f624ae0:	eb0037f5 	bl	8f632abc <_panic>
8f624ae4:	eaffff95 	b	8f624940 <wait_queue_wake_all+0x50>
	if (reschedule && ret > 0)
8f624ae8:	e3530000 	cmp	r3, #0
8f624aec:	13560000 	cmpne	r6, #0
8f624af0:	c3a04001 	movgt	r4, #1
8f624af4:	d3a04000 	movle	r4, #0
	ASSERT(wait->count == 0);
8f624af8:	e59d000c 	ldr	r0, [r13, #12]
8f624afc:	e30810c4 	movw	r1, #32964	; 0x80c4
8f624b00:	e3072e78 	movw	r2, #32376	; 0x7e78
8f624b04:	e3481f70 	movt	r1, #36720	; 0x8f70
8f624b08:	e3482f70 	movt	r2, #36720	; 0x8f70
8f624b0c:	e58d1000 	str	r1, [r13]
8f624b10:	e3a03fcf 	mov	r3, #828	; 0x33c
8f624b14:	e3001130 	movw	r1, #304	; 0x130
8f624b18:	e3481f70 	movt	r1, #36720	; 0x8f70
8f624b1c:	eb0037e6 	bl	8f632abc <_panic>
8f624b20:	eaffffb8 	b	8f624a08 <wait_queue_wake_all+0x118>
8f624b24:	e3a04000 	mov	r4, #0
8f624b28:	e1a06004 	mov	r6, r4
8f624b2c:	eafffff1 	b	8f624af8 <wait_queue_wake_all+0x208>
}
8f624b30:	eb003822 	bl	8f632bc0 <__stack_chk_fail>
8f624b34:	8f74221c 	.word	0x8f74221c

8f624b38 <thread_unblock_from_wait_queue>:
 *   from wait_queue_block().
 *
 * @return ERR_NOT_BLOCKED if thread was not in any wait queue.
 */
status_t thread_unblock_from_wait_queue(thread_t *t, bool reschedule, status_t wait_queue_error)
{
8f624b38:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
	critical_section_count++;
8f624b3c:	e3015acc 	movw	r5, #6860	; 0x1acc
8f624b40:	e59f31ec 	ldr	r3, [pc, #492]	; 8f624d34 <thread_unblock_from_wait_queue+0x1fc>
8f624b44:	e3485f71 	movt	r5, #36721	; 0x8f71
8f624b48:	e24dd010 	sub	r13, r13, #16
8f624b4c:	e1a0800e 	mov	r8, r14
8f624b50:	e5933000 	ldr	r3, [r3]
8f624b54:	e58d300c 	str	r3, [r13, #12]
8f624b58:	e3a03000 	mov	r3, #0
8f624b5c:	e5953000 	ldr	r3, [r5]
8f624b60:	e1a04000 	mov	r4, r0
8f624b64:	e1a06001 	mov	r6, r1
8f624b68:	e2833001 	add	r3, r3, #1
8f624b6c:	e1a07002 	mov	r7, r2
	if (critical_section_count == 1)
8f624b70:	e3530001 	cmp	r3, #1
	critical_section_count++;
8f624b74:	e5853000 	str	r3, [r5]
	if (critical_section_count == 1)
8f624b78:	0a000046 	beq	8f624c98 <thread_unblock_from_wait_queue+0x160>
	enter_critical_section();

#if THREAD_CHECKS
	ASSERT(t->magic == THREAD_MAGIC);
8f624b7c:	e5942000 	ldr	r2, [r4]
8f624b80:	e3073264 	movw	r3, #29284	; 0x7264
8f624b84:	e3473468 	movt	r3, #29800	; 0x7468
8f624b88:	e1520003 	cmp	r2, r3
8f624b8c:	1a000043 	bne	8f624ca0 <thread_unblock_from_wait_queue+0x168>
#endif

	if (t->state != THREAD_BLOCKED)
8f624b90:	e5d43018 	ldrb	r3, [r4, #24]
8f624b94:	e3530003 	cmp	r3, #3
8f624b98:	1a000062 	bne	8f624d28 <thread_unblock_from_wait_queue+0x1f0>
		return ERR_NOT_BLOCKED;

#if THREAD_CHECKS
	ASSERT(t->blocking_wait_queue != NULL);
8f624b9c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
8f624ba0:	e3530000 	cmp	r3, #0
8f624ba4:	0a000053 	beq	8f624cf8 <thread_unblock_from_wait_queue+0x1c0>
	ASSERT(t->blocking_wait_queue->magic == WAIT_QUEUE_MAGIC);
8f624ba8:	e5932000 	ldr	r2, [r3]
8f624bac:	e3063974 	movw	r3, #26996	; 0x6974
8f624bb0:	e3473761 	movt	r3, #30561	; 0x7761
8f624bb4:	e1520003 	cmp	r2, r3
8f624bb8:	1a000043 	bne	8f624ccc <thread_unblock_from_wait_queue+0x194>
	if (item->prev == 0 && item->next == 0)
8f624bbc:	e594300c 	ldr	r3, [r4, #12]
8f624bc0:	e5942010 	ldr	r2, [r4, #16]
8f624bc4:	e3530000 	cmp	r3, #0
8f624bc8:	0a00001f 	beq	8f624c4c <thread_unblock_from_wait_queue+0x114>
	ASSERT(list_in_list(&t->queue_node));
#endif	

	list_delete(&t->queue_node);
	t->blocking_wait_queue->count--;
8f624bcc:	e5941024 	ldr	r1, [r4, #36]	; 0x24
	t->blocking_wait_queue = NULL;
	t->state = THREAD_READY;
8f624bd0:	e3a0c001 	mov	r12, #1
	item->next->prev = item->prev;
8f624bd4:	e5823000 	str	r3, [r2]
	t->wait_queue_block_ret = wait_queue_error;
	insert_in_run_queue_head(t);
8f624bd8:	e1a00004 	mov	r0, r4
	item->prev->next = item->next;
8f624bdc:	e5832004 	str	r2, [r3, #4]
	item->prev = item->next = 0;
8f624be0:	e3a03000 	mov	r3, #0
	t->blocking_wait_queue->count--;
8f624be4:	e591200c 	ldr	r2, [r1, #12]
8f624be8:	e5843010 	str	r3, [r4, #16]
8f624bec:	e2422001 	sub	r2, r2, #1
8f624bf0:	e584300c 	str	r3, [r4, #12]
8f624bf4:	e581200c 	str	r2, [r1, #12]
	t->blocking_wait_queue = NULL;
8f624bf8:	e5843024 	str	r3, [r4, #36]	; 0x24
	t->state = THREAD_READY;
8f624bfc:	e5c4c018 	strb	r12, [r4, #24]
	t->wait_queue_block_ret = wait_queue_error;
8f624c00:	e5847028 	str	r7, [r4, #40]	; 0x28
	insert_in_run_queue_head(t);
8f624c04:	ebfff98e 	bl	8f623244 <insert_in_run_queue_head>

	if (reschedule)
8f624c08:	e3560000 	cmp	r6, #0
8f624c0c:	1a00001f 	bne	8f624c90 <thread_unblock_from_wait_queue+0x158>
	critical_section_count--;
8f624c10:	e5954000 	ldr	r4, [r5]
8f624c14:	e2444001 	sub	r4, r4, #1
8f624c18:	e5854000 	str	r4, [r5]
	if (critical_section_count == 0)
8f624c1c:	e3540000 	cmp	r4, #0
		thread_resched();

	exit_critical_section();

	return NO_ERROR;
8f624c20:	13a04000 	movne	r4, #0
8f624c24:	0a000017 	beq	8f624c88 <thread_unblock_from_wait_queue+0x150>
}
8f624c28:	e59f3104 	ldr	r3, [pc, #260]	; 8f624d34 <thread_unblock_from_wait_queue+0x1fc>
8f624c2c:	e5932000 	ldr	r2, [r3]
8f624c30:	e59d300c 	ldr	r3, [r13, #12]
8f624c34:	e0332002 	eors	r2, r3, r2
8f624c38:	e3a03000 	mov	r3, #0
8f624c3c:	1a00003b 	bne	8f624d30 <thread_unblock_from_wait_queue+0x1f8>
8f624c40:	e1a00004 	mov	r0, r4
8f624c44:	e28dd010 	add	r13, r13, #16
8f624c48:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
	if (item->prev == 0 && item->next == 0)
8f624c4c:	e3520000 	cmp	r2, #0
8f624c50:	1affffdd 	bne	8f624bcc <thread_unblock_from_wait_queue+0x94>
	ASSERT(list_in_list(&t->queue_node));
8f624c54:	e1a00008 	mov	r0, r8
8f624c58:	e308312c 	movw	r3, #33068	; 0x812c
8f624c5c:	e3072e78 	movw	r2, #32376	; 0x7e78
8f624c60:	e3483f70 	movt	r3, #36720	; 0x8f70
8f624c64:	e3482f70 	movt	r2, #36720	; 0x8f70
8f624c68:	e58d3000 	str	r3, [r13]
8f624c6c:	e3001130 	movw	r1, #304	; 0x130
8f624c70:	e300336f 	movw	r3, #879	; 0x36f
8f624c74:	e3481f70 	movt	r1, #36720	; 0x8f70
8f624c78:	eb00378f 	bl	8f632abc <_panic>
	item->next->prev = item->prev;
8f624c7c:	e5942010 	ldr	r2, [r4, #16]
8f624c80:	e594300c 	ldr	r3, [r4, #12]
8f624c84:	eaffffd0 	b	8f624bcc <thread_unblock_from_wait_queue+0x94>
		arch_enable_ints();
8f624c88:	ebfff0de 	bl	8f621008 <arch_enable_ints>
8f624c8c:	eaffffe5 	b	8f624c28 <thread_unblock_from_wait_queue+0xf0>
		thread_resched();
8f624c90:	ebfffa66 	bl	8f623630 <thread_resched>
8f624c94:	eaffffdd 	b	8f624c10 <thread_unblock_from_wait_queue+0xd8>
		arch_disable_ints();
8f624c98:	ebfff0de 	bl	8f621018 <arch_disable_ints>
8f624c9c:	eaffffb6 	b	8f624b7c <thread_unblock_from_wait_queue+0x44>
	ASSERT(t->magic == THREAD_MAGIC);
8f624ca0:	e3073e88 	movw	r3, #32392	; 0x7e88
8f624ca4:	e3072e78 	movw	r2, #32376	; 0x7e78
8f624ca8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f624cac:	e3482f70 	movt	r2, #36720	; 0x8f70
8f624cb0:	e58d3000 	str	r3, [r13]
8f624cb4:	e3001130 	movw	r1, #304	; 0x130
8f624cb8:	e3003366 	movw	r3, #870	; 0x366
8f624cbc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f624cc0:	e1a00008 	mov	r0, r8
8f624cc4:	eb00377c 	bl	8f632abc <_panic>
8f624cc8:	eaffffb0 	b	8f624b90 <thread_unblock_from_wait_queue+0x58>
	ASSERT(t->blocking_wait_queue->magic == WAIT_QUEUE_MAGIC);
8f624ccc:	e30830f8 	movw	r3, #33016	; 0x80f8
8f624cd0:	e3072e78 	movw	r2, #32376	; 0x7e78
8f624cd4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f624cd8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f624cdc:	e58d3000 	str	r3, [r13]
8f624ce0:	e3001130 	movw	r1, #304	; 0x130
8f624ce4:	e300336e 	movw	r3, #878	; 0x36e
8f624ce8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f624cec:	e1a00008 	mov	r0, r8
8f624cf0:	eb003771 	bl	8f632abc <_panic>
8f624cf4:	eaffffb0 	b	8f624bbc <thread_unblock_from_wait_queue+0x84>
	ASSERT(t->blocking_wait_queue != NULL);
8f624cf8:	e30830d8 	movw	r3, #32984	; 0x80d8
8f624cfc:	e3072e78 	movw	r2, #32376	; 0x7e78
8f624d00:	e3483f70 	movt	r3, #36720	; 0x8f70
8f624d04:	e3482f70 	movt	r2, #36720	; 0x8f70
8f624d08:	e58d3000 	str	r3, [r13]
8f624d0c:	e3001130 	movw	r1, #304	; 0x130
8f624d10:	e300336d 	movw	r3, #877	; 0x36d
8f624d14:	e3481f70 	movt	r1, #36720	; 0x8f70
8f624d18:	e1a00008 	mov	r0, r8
8f624d1c:	eb003766 	bl	8f632abc <_panic>
	ASSERT(t->blocking_wait_queue->magic == WAIT_QUEUE_MAGIC);
8f624d20:	e5943024 	ldr	r3, [r4, #36]	; 0x24
8f624d24:	eaffff9f 	b	8f624ba8 <thread_unblock_from_wait_queue+0x70>
		return ERR_NOT_BLOCKED;
8f624d28:	e3e0400b 	mvn	r4, #11
8f624d2c:	eaffffbd 	b	8f624c28 <thread_unblock_from_wait_queue+0xf0>
}
8f624d30:	eb0037a2 	bl	8f632bc0 <__stack_chk_fail>
8f624d34:	8f74221c 	.word	0x8f74221c

8f624d38 <wait_queue_timeout_handler>:
{
8f624d38:	e92d4010 	push	{r4, r14}
8f624d3c:	e1a04002 	mov	r4, r2
	ASSERT(thread->magic == THREAD_MAGIC);
8f624d40:	e5922000 	ldr	r2, [r2]
8f624d44:	e3073264 	movw	r3, #29284	; 0x7264
8f624d48:	e3473468 	movt	r3, #29800	; 0x7468
{
8f624d4c:	e59f107c 	ldr	r1, [pc, #124]	; 8f624dd0 <wait_queue_timeout_handler+0x98>
	ASSERT(thread->magic == THREAD_MAGIC);
8f624d50:	e1520003 	cmp	r2, r3
{
8f624d54:	e24dd010 	sub	r13, r13, #16
8f624d58:	e5911000 	ldr	r1, [r1]
8f624d5c:	e58d100c 	str	r1, [r13, #12]
8f624d60:	e3a01000 	mov	r1, #0
	ASSERT(thread->magic == THREAD_MAGIC);
8f624d64:	1a00000d 	bne	8f624da0 <wait_queue_timeout_handler+0x68>
	if (thread_unblock_from_wait_queue(thread, false, ERR_TIMED_OUT) >= NO_ERROR)
8f624d68:	e3e0200c 	mvn	r2, #12
8f624d6c:	e3a01000 	mov	r1, #0
8f624d70:	e1a00004 	mov	r0, r4
8f624d74:	ebffff6f 	bl	8f624b38 <thread_unblock_from_wait_queue>
}
8f624d78:	e59f3050 	ldr	r3, [pc, #80]	; 8f624dd0 <wait_queue_timeout_handler+0x98>
8f624d7c:	e5932000 	ldr	r2, [r3]
8f624d80:	e59d300c 	ldr	r3, [r13, #12]
8f624d84:	e0332002 	eors	r2, r3, r2
8f624d88:	e3a03000 	mov	r3, #0
	if (thread_unblock_from_wait_queue(thread, false, ERR_TIMED_OUT) >= NO_ERROR)
8f624d8c:	e1e00000 	mvn	r0, r0
}
8f624d90:	e1a00fa0 	lsr	r0, r0, #31
8f624d94:	1a00000c 	bne	8f624dcc <wait_queue_timeout_handler+0x94>
8f624d98:	e28dd010 	add	r13, r13, #16
8f624d9c:	e8bd8010 	pop	{r4, r15}
	ASSERT(thread->magic == THREAD_MAGIC);
8f624da0:	e307cfc4 	movw	r12, #32708	; 0x7fc4
8f624da4:	e3072e78 	movw	r2, #32376	; 0x7e78
8f624da8:	e348cf70 	movt	r12, #36720	; 0x8f70
8f624dac:	e3482f70 	movt	r2, #36720	; 0x8f70
8f624db0:	e3001130 	movw	r1, #304	; 0x130
8f624db4:	e300329a 	movw	r3, #666	; 0x29a
8f624db8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f624dbc:	e1a0000e 	mov	r0, r14
8f624dc0:	e58dc000 	str	r12, [r13]
8f624dc4:	eb00373c 	bl	8f632abc <_panic>
8f624dc8:	eaffffe6 	b	8f624d68 <wait_queue_timeout_handler+0x30>
}
8f624dcc:	eb00377b 	bl	8f632bc0 <__stack_chk_fail>
8f624dd0:	8f74221c 	.word	0x8f74221c

8f624dd4 <insert_timer_in_queue>:
	timer->callback = 0;
	timer->arg = 0;
}

static void insert_timer_in_queue(timer_t *timer)
{
8f624dd4:	e59f30a8 	ldr	r3, [pc, #168]	; 8f624e84 <insert_timer_in_queue+0xb0>
	timer_t *entry;

//	TRACEF("timer %p, scheduled %d, periodic %d\n", timer, timer->scheduled_time, timer->periodic_time);

	list_for_every_entry(&timer_queue, entry, timer_t, node) {
8f624dd8:	e304c18c 	movw	r12, #16780	; 0x418c
8f624ddc:	e348cf73 	movt	r12, #36723	; 0x8f73
{
8f624de0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f624de4:	e24dd00c 	sub	r13, r13, #12
8f624de8:	e5933000 	ldr	r3, [r3]
8f624dec:	e58d3004 	str	r3, [r13, #4]
8f624df0:	e3a03000 	mov	r3, #0
	list_for_every_entry(&timer_queue, entry, timer_t, node) {
8f624df4:	e59c3004 	ldr	r3, [r12, #4]
8f624df8:	e153000c 	cmp	r3, r12
8f624dfc:	0a000011 	beq	8f624e48 <insert_timer_in_queue+0x74>
		if (TIME_GT(entry->scheduled_time, timer->scheduled_time)) {
8f624e00:	e590e00c 	ldr	r14, [r0, #12]
8f624e04:	e2431004 	sub	r1, r3, #4
8f624e08:	ea000003 	b	8f624e1c <insert_timer_in_queue+0x48>
	list_for_every_entry(&timer_queue, entry, timer_t, node) {
8f624e0c:	e5913008 	ldr	r3, [r1, #8]
8f624e10:	e153000c 	cmp	r3, r12
8f624e14:	e2431004 	sub	r1, r3, #4
8f624e18:	0a00000a 	beq	8f624e48 <insert_timer_in_queue+0x74>
		if (TIME_GT(entry->scheduled_time, timer->scheduled_time)) {
8f624e1c:	e591200c 	ldr	r2, [r1, #12]
8f624e20:	e042200e 	sub	r2, r2, r14
8f624e24:	e3520000 	cmp	r2, #0
8f624e28:	dafffff7 	ble	8f624e0c <insert_timer_in_queue+0x38>
	item->prev = list->prev;
8f624e2c:	e591c004 	ldr	r12, [r1, #4]
			list_add_before(&entry->node, &timer->node);
8f624e30:	e2802004 	add	r2, r0, #4
	item->next = list;
8f624e34:	e5803008 	str	r3, [r0, #8]
	item->prev = list->prev;
8f624e38:	e580c004 	str	r12, [r0, #4]
	list->prev->next = item;
8f624e3c:	e58c2004 	str	r2, [r12, #4]
	list->prev = item;
8f624e40:	e5812004 	str	r2, [r1, #4]
			return;
8f624e44:	ea000005 	b	8f624e60 <insert_timer_in_queue+0x8c>
	item->prev = list->prev;
8f624e48:	e59c3000 	ldr	r3, [r12]
		}
	}

	/* walked off the end of the list */
	list_add_tail(&timer_queue, &timer->node);
8f624e4c:	e2802004 	add	r2, r0, #4
	item->next = list;
8f624e50:	e580c008 	str	r12, [r0, #8]
	list->prev = item;
8f624e54:	e58c2000 	str	r2, [r12]
	item->prev = list->prev;
8f624e58:	e5803004 	str	r3, [r0, #4]
	list->prev->next = item;
8f624e5c:	e5832004 	str	r2, [r3, #4]
}
8f624e60:	e59f301c 	ldr	r3, [pc, #28]	; 8f624e84 <insert_timer_in_queue+0xb0>
8f624e64:	e5932000 	ldr	r2, [r3]
8f624e68:	e59d3004 	ldr	r3, [r13, #4]
8f624e6c:	e0332002 	eors	r2, r3, r2
8f624e70:	e3a03000 	mov	r3, #0
8f624e74:	1a000001 	bne	8f624e80 <insert_timer_in_queue+0xac>
8f624e78:	e28dd00c 	add	r13, r13, #12
8f624e7c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f624e80:	eb00374e 	bl	8f632bc0 <__stack_chk_fail>
8f624e84:	8f74221c 	.word	0x8f74221c

8f624e88 <timer_set>:

static void timer_set(timer_t *timer, time_t delay, time_t period, timer_callback callback, void *arg)
{
8f624e88:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f624e8c:	e1a06003 	mov	r6, r3
8f624e90:	e59f30e8 	ldr	r3, [pc, #232]	; 8f624f80 <timer_set+0xf8>
8f624e94:	e24dd00c 	sub	r13, r13, #12
8f624e98:	e1a04000 	mov	r4, r0
8f624e9c:	e1a07001 	mov	r7, r1
8f624ea0:	e5933000 	ldr	r3, [r3]
8f624ea4:	e58d3004 	str	r3, [r13, #4]
8f624ea8:	e3a03000 	mov	r3, #0
	if (item->prev == 0 && item->next == 0)
8f624eac:	e5943004 	ldr	r3, [r4, #4]
8f624eb0:	e59d8028 	ldr	r8, [r13, #40]	; 0x28
8f624eb4:	e1a0000e 	mov	r0, r14
8f624eb8:	e3530000 	cmp	r3, #0
8f624ebc:	e1a09002 	mov	r9, r2
8f624ec0:	0a00001f 	beq	8f624f44 <timer_set+0xbc>
//	TRACEF("timer %p, delay %d, period %d, callback %p, arg %p, now %d\n", timer, delay, period, callback, arg);

	DEBUG_ASSERT(timer->magic == TIMER_MAGIC);	

	if (list_in_list(&timer->node)) {
		panic("timer %p already in list\n", timer);
8f624ec4:	e308114c 	movw	r1, #33100	; 0x814c
8f624ec8:	e1a02004 	mov	r2, r4
8f624ecc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f624ed0:	eb0036f9 	bl	8f632abc <_panic>
	}

	now = current_time();
8f624ed4:	ebffa766 	bl	8f60ec74 <current_time>
	critical_section_count++;
8f624ed8:	e3015acc 	movw	r5, #6860	; 0x1acc
8f624edc:	e3485f71 	movt	r5, #36721	; 0x8f71
	timer->scheduled_time = now + delay;
	timer->periodic_time = period;
8f624ee0:	e5849010 	str	r9, [r4, #16]
	timer->callback = callback;
8f624ee4:	e5846014 	str	r6, [r4, #20]
8f624ee8:	e5953000 	ldr	r3, [r5]
	timer->arg = arg;
8f624eec:	e5848018 	str	r8, [r4, #24]
8f624ef0:	e2833001 	add	r3, r3, #1
8f624ef4:	e5853000 	str	r3, [r5]
	if (critical_section_count == 1)
8f624ef8:	e3530001 	cmp	r3, #1
	timer->scheduled_time = now + delay;
8f624efc:	e0800007 	add	r0, r0, r7
8f624f00:	e584000c 	str	r0, [r4, #12]
8f624f04:	0a00001a 	beq	8f624f74 <timer_set+0xec>

//	TRACEF("scheduled time %u\n", timer->scheduled_time);

	enter_critical_section();

	insert_timer_in_queue(timer);
8f624f08:	e1a00004 	mov	r0, r4
8f624f0c:	ebffffb0 	bl	8f624dd4 <insert_timer_in_queue>
	critical_section_count--;
8f624f10:	e5953000 	ldr	r3, [r5]
8f624f14:	e2433001 	sub	r3, r3, #1
8f624f18:	e5853000 	str	r3, [r5]
	if (critical_section_count == 0)
8f624f1c:	e3530000 	cmp	r3, #0
		arch_enable_ints();
8f624f20:	e59f3058 	ldr	r3, [pc, #88]	; 8f624f80 <timer_set+0xf8>
	if (critical_section_count == 0)
8f624f24:	0a00000a 	beq	8f624f54 <timer_set+0xcc>
		platform_set_oneshot_timer(timer_tick, NULL, delay);
	}
#endif

	exit_critical_section();
}
8f624f28:	e5932000 	ldr	r2, [r3]
8f624f2c:	e59d3004 	ldr	r3, [r13, #4]
8f624f30:	e0332002 	eors	r2, r3, r2
8f624f34:	e3a03000 	mov	r3, #0
8f624f38:	1a00000f 	bne	8f624f7c <timer_set+0xf4>
8f624f3c:	e28dd00c 	add	r13, r13, #12
8f624f40:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
8f624f44:	e5943008 	ldr	r3, [r4, #8]
8f624f48:	e3530000 	cmp	r3, #0
8f624f4c:	1affffdc 	bne	8f624ec4 <timer_set+0x3c>
8f624f50:	eaffffdf 	b	8f624ed4 <timer_set+0x4c>
		arch_enable_ints();
8f624f54:	e5932000 	ldr	r2, [r3]
8f624f58:	e59d3004 	ldr	r3, [r13, #4]
8f624f5c:	e0332002 	eors	r2, r3, r2
8f624f60:	e3a03000 	mov	r3, #0
8f624f64:	1a000004 	bne	8f624f7c <timer_set+0xf4>
8f624f68:	e28dd00c 	add	r13, r13, #12
8f624f6c:	e8bd43f0 	pop	{r4, r5, r6, r7, r8, r9, r14}
8f624f70:	eafff024 	b	8f621008 <arch_enable_ints>
		arch_disable_ints();
8f624f74:	ebfff027 	bl	8f621018 <arch_disable_ints>
8f624f78:	eaffffe2 	b	8f624f08 <timer_set+0x80>
8f624f7c:	eb00370f 	bl	8f632bc0 <__stack_chk_fail>
8f624f80:	8f74221c 	.word	0x8f74221c

8f624f84 <timer_tick>:
	exit_critical_section();
}

/* called at interrupt time to process any pending timers */
static enum handler_return timer_tick(void *arg, time_t now)
{
8f624f84:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
	if(list->next != list) {
8f624f88:	e304518c 	movw	r5, #16780	; 0x418c
8f624f8c:	e3485f73 	movt	r5, #36723	; 0x8f73
	timer_t *timer;
	enum handler_return ret = INT_NO_RESCHEDULE;

#if THREAD_STATS
	thread_stats.timer_ints++;
8f624f90:	e3024cc8 	movw	r4, #11464	; 0x2cc8
8f624f94:	e3484f74 	movt	r4, #36724	; 0x8f74
{
8f624f98:	e59f010c 	ldr	r0, [pc, #268]	; 8f6250ac <timer_tick+0x128>
8f624f9c:	e5953004 	ldr	r3, [r5, #4]
8f624fa0:	e24dd010 	sub	r13, r13, #16
	thread_stats.timer_ints++;
8f624fa4:	e5942024 	ldr	r2, [r4, #36]	; 0x24
{
8f624fa8:	e5900000 	ldr	r0, [r0]
8f624fac:	e58d000c 	str	r0, [r13, #12]
8f624fb0:	e3a00000 	mov	r0, #0

//	TRACEF("now %d\n", now);

	for (;;) {
		/* see if there's an event to process */
		timer = list_peek_head_type(&timer_queue, timer_t, node);
8f624fb4:	e1530005 	cmp	r3, r5
8f624fb8:	13530000 	cmpne	r3, #0
	thread_stats.timer_ints++;
8f624fbc:	e2822001 	add	r2, r2, #1
8f624fc0:	e5842024 	str	r2, [r4, #36]	; 0x24
	item->prev = item->next = 0;
8f624fc4:	13a07000 	movne	r7, #0
		timer = list_peek_head_type(&timer_queue, timer_t, node);
8f624fc8:	0a000001 	beq	8f624fd4 <timer_tick+0x50>
		if (likely(!timer || TIME_LT(now, timer->scheduled_time)))
8f624fcc:	e3530004 	cmp	r3, #4
8f624fd0:	1a000009 	bne	8f624ffc <timer_tick+0x78>
		platform_set_oneshot_timer(timer_tick, NULL, delay);
	}
#else
	/* let the scheduler have a shot to do quantum expiration, etc */
	/* in case of dynamic timer, the scheduler will set up a periodic timer */
	if (thread_timer_tick() == INT_RESCHEDULE)
8f624fd4:	ebfffc8c 	bl	8f62420c <thread_timer_tick>
#endif

	// XXX fix this, should return ret
	ret = INT_RESCHEDULE;
	return ret;
}
8f624fd8:	e59f30cc 	ldr	r3, [pc, #204]	; 8f6250ac <timer_tick+0x128>
8f624fdc:	e5932000 	ldr	r2, [r3]
8f624fe0:	e59d300c 	ldr	r3, [r13, #12]
8f624fe4:	e0332002 	eors	r2, r3, r2
8f624fe8:	e3a03000 	mov	r3, #0
8f624fec:	1a00002d 	bne	8f6250a8 <timer_tick+0x124>
8f624ff0:	e3a00001 	mov	r0, #1
8f624ff4:	e28dd010 	add	r13, r13, #16
8f624ff8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
		timer = list_peek_head_type(&timer_queue, timer_t, node);
8f624ffc:	e2436004 	sub	r6, r3, #4
		if (likely(!timer || TIME_LT(now, timer->scheduled_time)))
8f625000:	e5933008 	ldr	r3, [r3, #8]
8f625004:	e0413003 	sub	r3, r1, r3
8f625008:	e3530000 	cmp	r3, #0
8f62500c:	bafffff0 	blt	8f624fd4 <timer_tick+0x50>
	item->next->prev = item->prev;
8f625010:	e5962008 	ldr	r2, [r6, #8]
		if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
8f625014:	e1a00006 	mov	r0, r6
8f625018:	e5963004 	ldr	r3, [r6, #4]
		bool periodic = timer->periodic_time > 0;
8f62501c:	e5968010 	ldr	r8, [r6, #16]
		if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
8f625020:	e58d1004 	str	r1, [r13, #4]
8f625024:	e5823000 	str	r3, [r2]
	item->prev->next = item->next;
8f625028:	e5832004 	str	r2, [r3, #4]
		thread_stats.timers++;
8f62502c:	e5943028 	ldr	r3, [r4, #40]	; 0x28
	item->prev = item->next = 0;
8f625030:	e5867008 	str	r7, [r6, #8]
8f625034:	e2833001 	add	r3, r3, #1
8f625038:	e5867004 	str	r7, [r6, #4]
		if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
8f62503c:	e5962018 	ldr	r2, [r6, #24]
		thread_stats.timers++;
8f625040:	e5843028 	str	r3, [r4, #40]	; 0x28
		if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
8f625044:	e5963014 	ldr	r3, [r6, #20]
8f625048:	e12fff33 	blx	r3
		if (periodic && !list_in_list(&timer->node) && timer->periodic_time > 0) {
8f62504c:	e3580000 	cmp	r8, #0
8f625050:	e59d1004 	ldr	r1, [r13, #4]
8f625054:	0a000002 	beq	8f625064 <timer_tick+0xe0>
	if (item->prev == 0 && item->next == 0)
8f625058:	e5963004 	ldr	r3, [r6, #4]
8f62505c:	e3530000 	cmp	r3, #0
8f625060:	0a000004 	beq	8f625078 <timer_tick+0xf4>
	if(list->next != list) {
8f625064:	e5953004 	ldr	r3, [r5, #4]
		timer = list_peek_head_type(&timer_queue, timer_t, node);
8f625068:	e3530000 	cmp	r3, #0
8f62506c:	11530005 	cmpne	r3, r5
8f625070:	1affffd5 	bne	8f624fcc <timer_tick+0x48>
8f625074:	eaffffd6 	b	8f624fd4 <timer_tick+0x50>
	if (item->prev == 0 && item->next == 0)
8f625078:	e5963008 	ldr	r3, [r6, #8]
8f62507c:	e3530000 	cmp	r3, #0
8f625080:	1afffff7 	bne	8f625064 <timer_tick+0xe0>
		if (periodic && !list_in_list(&timer->node) && timer->periodic_time > 0) {
8f625084:	e5963010 	ldr	r3, [r6, #16]
8f625088:	e3530000 	cmp	r3, #0
8f62508c:	0afffff4 	beq	8f625064 <timer_tick+0xe0>
			timer->scheduled_time = now + timer->periodic_time;
8f625090:	e0833001 	add	r3, r3, r1
			insert_timer_in_queue(timer);
8f625094:	e1a00006 	mov	r0, r6
			timer->scheduled_time = now + timer->periodic_time;
8f625098:	e586300c 	str	r3, [r6, #12]
			insert_timer_in_queue(timer);
8f62509c:	ebffff4c 	bl	8f624dd4 <insert_timer_in_queue>
8f6250a0:	e59d1004 	ldr	r1, [r13, #4]
8f6250a4:	eaffffee 	b	8f625064 <timer_tick+0xe0>
}
8f6250a8:	eb0036c4 	bl	8f632bc0 <__stack_chk_fail>
8f6250ac:	8f74221c 	.word	0x8f74221c

8f6250b0 <timer_initialize>:
{
8f6250b0:	e59f1058 	ldr	r1, [pc, #88]	; 8f625110 <timer_initialize+0x60>
	item->prev = item->next = 0;
8f6250b4:	e3a03000 	mov	r3, #0
8f6250b8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6250bc:	e24dd00c 	sub	r13, r13, #12
8f6250c0:	e5911000 	ldr	r1, [r1]
8f6250c4:	e58d1004 	str	r1, [r13, #4]
8f6250c8:	e3a01000 	mov	r1, #0
	timer->magic = TIMER_MAGIC;
8f6250cc:	e3062d72 	movw	r2, #28018	; 0x6d72
8f6250d0:	e5803008 	str	r3, [r0, #8]
8f6250d4:	e3472469 	movt	r2, #29801	; 0x7469
	timer->scheduled_time = 0;
8f6250d8:	e580300c 	str	r3, [r0, #12]
8f6250dc:	e1c020f0 	strd	r2, [r0]
	timer->periodic_time = 0;
8f6250e0:	e5803010 	str	r3, [r0, #16]
	timer->callback = 0;
8f6250e4:	e5803014 	str	r3, [r0, #20]
	timer->arg = 0;
8f6250e8:	e5803018 	str	r3, [r0, #24]
}
8f6250ec:	e59f301c 	ldr	r3, [pc, #28]	; 8f625110 <timer_initialize+0x60>
8f6250f0:	e5932000 	ldr	r2, [r3]
8f6250f4:	e59d3004 	ldr	r3, [r13, #4]
8f6250f8:	e0332002 	eors	r2, r3, r2
8f6250fc:	e3a03000 	mov	r3, #0
8f625100:	1a000001 	bne	8f62510c <timer_initialize+0x5c>
8f625104:	e28dd00c 	add	r13, r13, #12
8f625108:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f62510c:	eb0036ab 	bl	8f632bc0 <__stack_chk_fail>
8f625110:	8f74221c 	.word	0x8f74221c

8f625114 <timer_set_oneshot>:
{
8f625114:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f625118:	e24dd014 	sub	r13, r13, #20
	timer_set(timer, delay, 0, callback, arg);
8f62511c:	e3510001 	cmp	r1, #1
{
8f625120:	e1a0c003 	mov	r12, r3
	timer_set(timer, delay, 0, callback, arg);
8f625124:	e58dc000 	str	r12, [r13]
8f625128:	e1a03002 	mov	r3, r2
{
8f62512c:	e59fc038 	ldr	r12, [pc, #56]	; 8f62516c <timer_set_oneshot+0x58>
	timer_set(timer, delay, 0, callback, arg);
8f625130:	33a01001 	movcc	r1, #1
8f625134:	e3a02000 	mov	r2, #0
{
8f625138:	e59cc000 	ldr	r12, [r12]
8f62513c:	e58dc00c 	str	r12, [r13, #12]
8f625140:	e3a0c000 	mov	r12, #0
	timer_set(timer, delay, 0, callback, arg);
8f625144:	ebffff4f 	bl	8f624e88 <timer_set>
}
8f625148:	e59f301c 	ldr	r3, [pc, #28]	; 8f62516c <timer_set_oneshot+0x58>
8f62514c:	e5932000 	ldr	r2, [r3]
8f625150:	e59d300c 	ldr	r3, [r13, #12]
8f625154:	e0332002 	eors	r2, r3, r2
8f625158:	e3a03000 	mov	r3, #0
8f62515c:	1a000001 	bne	8f625168 <timer_set_oneshot+0x54>
8f625160:	e28dd014 	add	r13, r13, #20
8f625164:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f625168:	eb003694 	bl	8f632bc0 <__stack_chk_fail>
8f62516c:	8f74221c 	.word	0x8f74221c

8f625170 <timer_cancel>:
{
8f625170:	e92d4030 	push	{r4, r5, r14}
	critical_section_count++;
8f625174:	e3015acc 	movw	r5, #6860	; 0x1acc
8f625178:	e59f30c8 	ldr	r3, [pc, #200]	; 8f625248 <timer_cancel+0xd8>
8f62517c:	e3485f71 	movt	r5, #36721	; 0x8f71
8f625180:	e24dd00c 	sub	r13, r13, #12
8f625184:	e1a04000 	mov	r4, r0
8f625188:	e5933000 	ldr	r3, [r3]
8f62518c:	e58d3004 	str	r3, [r13, #4]
8f625190:	e3a03000 	mov	r3, #0
8f625194:	e5953000 	ldr	r3, [r5]
8f625198:	e2832001 	add	r2, r3, #1
8f62519c:	e5852000 	str	r2, [r5]
	if (critical_section_count == 1)
8f6251a0:	e3520001 	cmp	r2, #1
8f6251a4:	0a000022 	beq	8f625234 <timer_cancel+0xc4>
	if (item->prev == 0 && item->next == 0)
8f6251a8:	e5942004 	ldr	r2, [r4, #4]
8f6251ac:	e5941008 	ldr	r1, [r4, #8]
8f6251b0:	e3520000 	cmp	r2, #0
8f6251b4:	0a000013 	beq	8f625208 <timer_cancel+0x98>
	item->next->prev = item->prev;
8f6251b8:	e5812000 	str	r2, [r1]
	item->prev->next = item->next;
8f6251bc:	e5821004 	str	r1, [r2, #4]
	item->prev = item->next = 0;
8f6251c0:	e3a02000 	mov	r2, #0
8f6251c4:	e5842008 	str	r2, [r4, #8]
8f6251c8:	e5842004 	str	r2, [r4, #4]
	if (critical_section_count == 0)
8f6251cc:	e3530000 	cmp	r3, #0
	timer->periodic_time = 0;
8f6251d0:	e3a02000 	mov	r2, #0
	critical_section_count--;
8f6251d4:	e5853000 	str	r3, [r5]
8f6251d8:	e5842010 	str	r2, [r4, #16]
		arch_enable_ints();
8f6251dc:	e59f3064 	ldr	r3, [pc, #100]	; 8f625248 <timer_cancel+0xd8>
	timer->callback = NULL;
8f6251e0:	e5842014 	str	r2, [r4, #20]
	timer->arg = NULL;
8f6251e4:	e5842018 	str	r2, [r4, #24]
	if (critical_section_count == 0)
8f6251e8:	0a000009 	beq	8f625214 <timer_cancel+0xa4>
}
8f6251ec:	e5932000 	ldr	r2, [r3]
8f6251f0:	e59d3004 	ldr	r3, [r13, #4]
8f6251f4:	e0332002 	eors	r2, r3, r2
8f6251f8:	e3a03000 	mov	r3, #0
8f6251fc:	1a000010 	bne	8f625244 <timer_cancel+0xd4>
8f625200:	e28dd00c 	add	r13, r13, #12
8f625204:	e8bd8030 	pop	{r4, r5, r15}
	if (item->prev == 0 && item->next == 0)
8f625208:	e3510000 	cmp	r1, #0
8f62520c:	1affffe9 	bne	8f6251b8 <timer_cancel+0x48>
8f625210:	eaffffed 	b	8f6251cc <timer_cancel+0x5c>
		arch_enable_ints();
8f625214:	e5932000 	ldr	r2, [r3]
8f625218:	e59d3004 	ldr	r3, [r13, #4]
8f62521c:	e0332002 	eors	r2, r3, r2
8f625220:	e3a03000 	mov	r3, #0
8f625224:	1a000006 	bne	8f625244 <timer_cancel+0xd4>
8f625228:	e28dd00c 	add	r13, r13, #12
8f62522c:	e8bd4030 	pop	{r4, r5, r14}
8f625230:	eaffef74 	b	8f621008 <arch_enable_ints>
		arch_disable_ints();
8f625234:	ebffef77 	bl	8f621018 <arch_disable_ints>
	critical_section_count--;
8f625238:	e5953000 	ldr	r3, [r5]
8f62523c:	e2433001 	sub	r3, r3, #1
8f625240:	eaffffd8 	b	8f6251a8 <timer_cancel+0x38>
8f625244:	eb00365d 	bl	8f632bc0 <__stack_chk_fail>
8f625248:	8f74221c 	.word	0x8f74221c

8f62524c <timer_init>:

void timer_init(void)
{
8f62524c:	e59f2058 	ldr	r2, [pc, #88]	; 8f6252ac <timer_init+0x60>
	list->prev = list->next = list;
8f625250:	e304318c 	movw	r3, #16780	; 0x418c
8f625254:	e3483f73 	movt	r3, #36723	; 0x8f73
8f625258:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62525c:	e24dd00c 	sub	r13, r13, #12
8f625260:	e5922000 	ldr	r2, [r2]
8f625264:	e58d2004 	str	r2, [r13, #4]
8f625268:	e3a02000 	mov	r2, #0
8f62526c:	e5833000 	str	r3, [r3]
8f625270:	e5833004 	str	r3, [r3, #4]
	list_initialize(&timer_queue);

	/* register for a periodic timer tick */
	platform_set_periodic_timer(timer_tick, NULL, 10); /* 10ms */
8f625274:	e59f3030 	ldr	r3, [pc, #48]	; 8f6252ac <timer_init+0x60>
8f625278:	e5932000 	ldr	r2, [r3]
8f62527c:	e59d3004 	ldr	r3, [r13, #4]
8f625280:	e0332002 	eors	r2, r3, r2
8f625284:	e3a03000 	mov	r3, #0
8f625288:	1a000006 	bne	8f6252a8 <timer_init+0x5c>
8f62528c:	e3040f84 	movw	r0, #20356	; 0x4f84
8f625290:	e3a0200a 	mov	r2, #10
8f625294:	e3480f62 	movt	r0, #36706	; 0x8f62
8f625298:	e3a01000 	mov	r1, #0
}
8f62529c:	e28dd00c 	add	r13, r13, #12
8f6252a0:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	platform_set_periodic_timer(timer_tick, NULL, 10); /* 10ms */
8f6252a4:	eaffa64a 	b	8f60ebd4 <platform_set_periodic_timer>
8f6252a8:	eb003644 	bl	8f632bc0 <__stack_chk_fail>
8f6252ac:	8f74221c 	.word	0x8f74221c

8f6252b0 <app_thread_entry>:
		}
	}
}

static int app_thread_entry(void *arg)
{
8f6252b0:	e59f2044 	ldr	r2, [pc, #68]	; 8f6252fc <app_thread_entry+0x4c>
	const struct app_descriptor *app = (const struct app_descriptor *)arg;

	app->entry(app, NULL);
8f6252b4:	e3a01000 	mov	r1, #0
{
8f6252b8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6252bc:	e24dd00c 	sub	r13, r13, #12
	app->entry(app, NULL);
8f6252c0:	e5903008 	ldr	r3, [r0, #8]
{
8f6252c4:	e5922000 	ldr	r2, [r2]
8f6252c8:	e58d2004 	str	r2, [r13, #4]
8f6252cc:	e3a02000 	mov	r2, #0
	app->entry(app, NULL);
8f6252d0:	e12fff33 	blx	r3

	return 0;
}
8f6252d4:	e59f3020 	ldr	r3, [pc, #32]	; 8f6252fc <app_thread_entry+0x4c>
8f6252d8:	e5932000 	ldr	r2, [r3]
8f6252dc:	e59d3004 	ldr	r3, [r13, #4]
8f6252e0:	e0332002 	eors	r2, r3, r2
8f6252e4:	e3a03000 	mov	r3, #0
8f6252e8:	1a000002 	bne	8f6252f8 <app_thread_entry+0x48>
8f6252ec:	e3a00000 	mov	r0, #0
8f6252f0:	e28dd00c 	add	r13, r13, #12
8f6252f4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6252f8:	eb003630 	bl	8f632bc0 <__stack_chk_fail>
8f6252fc:	8f74221c 	.word	0x8f74221c

8f625300 <apps_init>:
{
8f625300:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
	for (app = &__apps_start; app != &__apps_end; app++) {
8f625304:	e30c6094 	movw	r6, #49300	; 0xc094
8f625308:	e30c50a4 	movw	r5, #49316	; 0xc0a4
8f62530c:	e3486f70 	movt	r6, #36720	; 0x8f70
8f625310:	e3485f70 	movt	r5, #36720	; 0x8f70
{
8f625314:	e59f30e4 	ldr	r3, [pc, #228]	; 8f625400 <apps_init+0x100>
	for (app = &__apps_start; app != &__apps_end; app++) {
8f625318:	e1560005 	cmp	r6, r5
{
8f62531c:	e24dd010 	sub	r13, r13, #16
8f625320:	e5933000 	ldr	r3, [r3]
8f625324:	e58d300c 	str	r3, [r13, #12]
8f625328:	e3a03000 	mov	r3, #0
	for (app = &__apps_start; app != &__apps_end; app++) {
8f62532c:	0a00002a 	beq	8f6253dc <apps_init+0xdc>
8f625330:	e1a04006 	mov	r4, r6
		if (app->init)
8f625334:	e5943004 	ldr	r3, [r4, #4]
8f625338:	e3530000 	cmp	r3, #0
8f62533c:	0a000001 	beq	8f625348 <apps_init+0x48>
			app->init(app);
8f625340:	e1a00004 	mov	r0, r4
8f625344:	e12fff33 	blx	r3
	for (app = &__apps_start; app != &__apps_end; app++) {
8f625348:	e2844010 	add	r4, r4, #16
8f62534c:	e1540005 	cmp	r4, r5
8f625350:	1afffff7 	bne	8f625334 <apps_init+0x34>
	for (app = &__apps_start; app != &__apps_end; app++) {
8f625354:	e1560005 	cmp	r6, r5
8f625358:	0a00001f 	beq	8f6253dc <apps_init+0xdc>
8f62535c:	e30c4094 	movw	r4, #49300	; 0xc094

static void start_app(const struct app_descriptor *app)
{
	thread_t *thr;
	printf("starting app %s\n", app->name);
8f625360:	e3087168 	movw	r7, #33128	; 0x8168

	thr = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
8f625364:	e30562b0 	movw	r6, #21168	; 0x52b0
	for (app = &__apps_start; app != &__apps_end; app++) {
8f625368:	e3484f70 	movt	r4, #36720	; 0x8f70
	printf("starting app %s\n", app->name);
8f62536c:	e3487f70 	movt	r7, #36720	; 0x8f70
	thr = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
8f625370:	e3486f62 	movt	r6, #36706	; 0x8f62
8f625374:	e3a08a03 	mov	r8, #12288	; 0x3000
8f625378:	ea000002 	b	8f625388 <apps_init+0x88>
	for (app = &__apps_start; app != &__apps_end; app++) {
8f62537c:	e2844010 	add	r4, r4, #16
8f625380:	e1540005 	cmp	r4, r5
8f625384:	0a000014 	beq	8f6253dc <apps_init+0xdc>
		if (app->entry && (app->flags & APP_FLAG_DONT_START_ON_BOOT) == 0) {
8f625388:	e5943008 	ldr	r3, [r4, #8]
8f62538c:	e3530000 	cmp	r3, #0
8f625390:	0afffff9 	beq	8f62537c <apps_init+0x7c>
8f625394:	e594300c 	ldr	r3, [r4, #12]
8f625398:	e3130001 	tst	r3, #1
8f62539c:	1afffff6 	bne	8f62537c <apps_init+0x7c>
	printf("starting app %s\n", app->name);
8f6253a0:	e5941000 	ldr	r1, [r4]
8f6253a4:	e1a00007 	mov	r0, r7
8f6253a8:	eb003911 	bl	8f6337f4 <printf>
	thr = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
8f6253ac:	e5940000 	ldr	r0, [r4]
8f6253b0:	e3a03010 	mov	r3, #16
8f6253b4:	e1a02004 	mov	r2, r4
8f6253b8:	e1a01006 	mov	r1, r6
8f6253bc:	e58d8000 	str	r8, [r13]
8f6253c0:	ebfff9ad 	bl	8f623a7c <thread_create>
	if(!thr)
8f6253c4:	e3500000 	cmp	r0, #0
8f6253c8:	0affffeb 	beq	8f62537c <apps_init+0x7c>
	for (app = &__apps_start; app != &__apps_end; app++) {
8f6253cc:	e2844010 	add	r4, r4, #16
	{
		return;
	}
	thread_resume(thr);
8f6253d0:	ebfffa9a 	bl	8f623e40 <thread_resume>
	for (app = &__apps_start; app != &__apps_end; app++) {
8f6253d4:	e1540005 	cmp	r4, r5
8f6253d8:	1affffea 	bne	8f625388 <apps_init+0x88>
}
8f6253dc:	e59f301c 	ldr	r3, [pc, #28]	; 8f625400 <apps_init+0x100>
8f6253e0:	e5932000 	ldr	r2, [r3]
8f6253e4:	e59d300c 	ldr	r3, [r13, #12]
8f6253e8:	e0332002 	eors	r2, r3, r2
8f6253ec:	e3a03000 	mov	r3, #0
8f6253f0:	1a000001 	bne	8f6253fc <apps_init+0xfc>
8f6253f4:	e28dd010 	add	r13, r13, #16
8f6253f8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
8f6253fc:	eb0035ef 	bl	8f632bc0 <__stack_chk_fail>
8f625400:	8f74221c 	.word	0x8f74221c

8f625404 <update_ker_tags_rdisk_addr>:
	return true;
}
#endif

static void update_ker_tags_rdisk_addr(boot_img_hdr *hdr, struct kernel64_hdr *kptr)
{
8f625404:	e92d4030 	push	{r4, r5, r14}
	/* overwrite the destination of specified for the project */
#ifdef ABOOT_IGNORE_BOOT_HEADER_ADDRS
	if (kptr && IS_ARM64(kptr))
8f625408:	e2515000 	subs	r5, r1, #0
{
8f62540c:	e59f30d4 	ldr	r3, [pc, #212]	; 8f6254e8 <update_ker_tags_rdisk_addr+0xe4>
8f625410:	e24dd00c 	sub	r13, r13, #12
8f625414:	e1a04000 	mov	r4, r0
8f625418:	e5933000 	ldr	r3, [r3]
8f62541c:	e58d3004 	str	r3, [r13, #4]
8f625420:	e3a03000 	mov	r3, #0
	if (kptr && IS_ARM64(kptr))
8f625424:	0a000021 	beq	8f6254b0 <update_ker_tags_rdisk_addr+0xac>
8f625428:	e5952038 	ldr	r2, [r5, #56]	; 0x38
8f62542c:	e3053241 	movw	r3, #21057	; 0x5241
8f625430:	e346344d 	movt	r3, #25677	; 0x644d
8f625434:	e1520003 	cmp	r2, r3
8f625438:	0a000026 	beq	8f6254d8 <update_ker_tags_rdisk_addr+0xd4>
		hdr->kernel_addr = ABOOT_FORCE_KERNEL64_ADDR;
	else
		hdr->kernel_addr = ABOOT_FORCE_KERNEL_ADDR;
8f62543c:	ebff7701 	bl	8f603048 <get_ddr_start>
8f625440:	e2800902 	add	r0, r0, #32768	; 0x8000
		hdr->kernel_addr = ABOOT_FORCE_KERNEL64_ADDR;
8f625444:	e584000c 	str	r0, [r4, #12]
	hdr->ramdisk_addr = ABOOT_FORCE_RAMDISK_ADDR;
8f625448:	ebff76fe 	bl	8f603048 <get_ddr_start>
8f62544c:	e2800636 	add	r0, r0, #56623104	; 0x3600000
8f625450:	e5840014 	str	r0, [r4, #20]
	hdr->tags_addr = ABOOT_FORCE_TAGS_ADDR;
8f625454:	ebff76fb 	bl	8f603048 <get_ddr_start>
	 *
	 * [Firmware Bug]: Kernel image misaligned at boot, please fix your bootloader!
	 *
	 * See Linux commit a2c1d73b94ed49f5fac12e95052d7b140783f800.
	 */
	if (kptr && IS_ARM64(kptr) && kptr->image_size) {
8f625458:	e5952038 	ldr	r2, [r5, #56]	; 0x38
8f62545c:	e3053241 	movw	r3, #21057	; 0x5241
8f625460:	e346344d 	movt	r3, #25677	; 0x644d
8f625464:	e1520003 	cmp	r2, r3
	hdr->tags_addr = ABOOT_FORCE_TAGS_ADDR;
8f625468:	e280050d 	add	r0, r0, #54525952	; 0x3400000
8f62546c:	e5840020 	str	r0, [r4, #32]
	if (kptr && IS_ARM64(kptr) && kptr->image_size) {
8f625470:	0a000007 	beq	8f625494 <update_ker_tags_rdisk_addr+0x90>
		/* text_offset bytes from a 2MB aligned base address */
		hdr->kernel_addr &= ~0x1fffff;
		hdr->kernel_addr += kptr->text_offset;
	}
#endif
}
8f625474:	e59f306c 	ldr	r3, [pc, #108]	; 8f6254e8 <update_ker_tags_rdisk_addr+0xe4>
8f625478:	e5932000 	ldr	r2, [r3]
8f62547c:	e59d3004 	ldr	r3, [r13, #4]
8f625480:	e0332002 	eors	r2, r3, r2
8f625484:	e3a03000 	mov	r3, #0
8f625488:	1a000015 	bne	8f6254e4 <update_ker_tags_rdisk_addr+0xe0>
8f62548c:	e28dd00c 	add	r13, r13, #12
8f625490:	e8bd8030 	pop	{r4, r5, r15}
		hdr->kernel_addr &= ~0x1fffff;
8f625494:	e594300c 	ldr	r3, [r4, #12]
		hdr->kernel_addr += kptr->text_offset;
8f625498:	e5952008 	ldr	r2, [r5, #8]
		hdr->kernel_addr &= ~0x1fffff;
8f62549c:	e1a03aa3 	lsr	r3, r3, #21
8f6254a0:	e1a03a83 	lsl	r3, r3, #21
		hdr->kernel_addr += kptr->text_offset;
8f6254a4:	e0833002 	add	r3, r3, r2
8f6254a8:	e584300c 	str	r3, [r4, #12]
}
8f6254ac:	eafffff0 	b	8f625474 <update_ker_tags_rdisk_addr+0x70>
		hdr->kernel_addr = ABOOT_FORCE_KERNEL_ADDR;
8f6254b0:	ebff76e4 	bl	8f603048 <get_ddr_start>
8f6254b4:	e2800902 	add	r0, r0, #32768	; 0x8000
8f6254b8:	e584000c 	str	r0, [r4, #12]
	hdr->ramdisk_addr = ABOOT_FORCE_RAMDISK_ADDR;
8f6254bc:	ebff76e1 	bl	8f603048 <get_ddr_start>
8f6254c0:	e2800636 	add	r0, r0, #56623104	; 0x3600000
8f6254c4:	e5840014 	str	r0, [r4, #20]
	hdr->tags_addr = ABOOT_FORCE_TAGS_ADDR;
8f6254c8:	ebff76de 	bl	8f603048 <get_ddr_start>
8f6254cc:	e280050d 	add	r0, r0, #54525952	; 0x3400000
8f6254d0:	e5840020 	str	r0, [r4, #32]
	if (kptr && IS_ARM64(kptr) && kptr->image_size) {
8f6254d4:	eaffffe6 	b	8f625474 <update_ker_tags_rdisk_addr+0x70>
		hdr->kernel_addr = ABOOT_FORCE_KERNEL64_ADDR;
8f6254d8:	ebff76da 	bl	8f603048 <get_ddr_start>
8f6254dc:	e2800702 	add	r0, r0, #524288	; 0x80000
8f6254e0:	eaffffd7 	b	8f625444 <update_ker_tags_rdisk_addr+0x40>
}
8f6254e4:	eb0035b5 	bl	8f632bc0 <__stack_chk_fail>
8f6254e8:	8f74221c 	.word	0x8f74221c

8f6254ec <cmd_preflash>:
{
	set_device_unlock(UNLOCK_CRITICAL, TRUE);
}

void cmd_preflash(const char *arg, void *data, unsigned sz)
{
8f6254ec:	e59f3040 	ldr	r3, [pc, #64]	; 8f625534 <cmd_preflash+0x48>
8f6254f0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6254f4:	e24dd00c 	sub	r13, r13, #12
8f6254f8:	e5933000 	ldr	r3, [r3]
8f6254fc:	e58d3004 	str	r3, [r13, #4]
8f625500:	e3a03000 	mov	r3, #0
	fastboot_okay("");
8f625504:	e59f3028 	ldr	r3, [pc, #40]	; 8f625534 <cmd_preflash+0x48>
8f625508:	e5932000 	ldr	r2, [r3]
8f62550c:	e59d3004 	ldr	r3, [r13, #4]
8f625510:	e0332002 	eors	r2, r3, r2
8f625514:	e3a03000 	mov	r3, #0
8f625518:	1a000004 	bne	8f625530 <cmd_preflash+0x44>
8f62551c:	e3070138 	movw	r0, #28984	; 0x7138
8f625520:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f625524:	e28dd00c 	add	r13, r13, #12
8f625528:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	fastboot_okay("");
8f62552c:	ea001e9a 	b	8f62cf9c <fastboot_okay>
8f625530:	eb0035a2 	bl	8f632bc0 <__stack_chk_fail>
8f625534:	8f74221c 	.word	0x8f74221c

8f625538 <cmd_oem_devinfo>:
{
8f625538:	e92d4070 	push	{r4, r5, r6, r14}
	snprintf(response, sizeof(response), "\tDevice tampered: %s", (device.is_tampered ? "true" : "false"));
8f62553c:	e3014ad0 	movw	r4, #6864	; 0x1ad0
8f625540:	e3484f71 	movt	r4, #36721	; 0x8f71
{
8f625544:	e59f20f0 	ldr	r2, [pc, #240]	; 8f62563c <cmd_oem_devinfo+0x104>
	snprintf(response, sizeof(response), "\tDevice tampered: %s", (device.is_tampered ? "true" : "false"));
8f625548:	e30862dc 	movw	r6, #33500	; 0x82dc
8f62554c:	e30852e4 	movw	r5, #33508	; 0x82e4
8f625550:	e5943014 	ldr	r3, [r4, #20]
8f625554:	e3486f70 	movt	r6, #36720	; 0x8f70
8f625558:	e3485f70 	movt	r5, #36720	; 0x8f70
{
8f62555c:	e24dd048 	sub	r13, r13, #72	; 0x48
	snprintf(response, sizeof(response), "\tDevice tampered: %s", (device.is_tampered ? "true" : "false"));
8f625560:	e3530000 	cmp	r3, #0
8f625564:	e3a01040 	mov	r1, #64	; 0x40
{
8f625568:	e5922000 	ldr	r2, [r2]
8f62556c:	e58d2044 	str	r2, [r13, #68]	; 0x44
8f625570:	e3a02000 	mov	r2, #0
	snprintf(response, sizeof(response), "\tDevice tampered: %s", (device.is_tampered ? "true" : "false"));
8f625574:	e28d0004 	add	r0, r13, #4
8f625578:	11a03006 	movne	r3, r6
8f62557c:	01a03005 	moveq	r3, r5
8f625580:	e30822ec 	movw	r2, #33516	; 0x82ec
8f625584:	e3482f70 	movt	r2, #36720	; 0x8f70
8f625588:	eb003a6c 	bl	8f633f40 <snprintf>
	fastboot_info(response);
8f62558c:	e28d0004 	add	r0, r13, #4
8f625590:	eb001cbc 	bl	8f62c888 <fastboot_info>
	snprintf(response, sizeof(response), "\tDevice unlocked: %s", (device.is_unlocked ? "true" : "false"));
8f625594:	e5943010 	ldr	r3, [r4, #16]
8f625598:	e3a01040 	mov	r1, #64	; 0x40
8f62559c:	e28d0004 	add	r0, r13, #4
8f6255a0:	e3530000 	cmp	r3, #0
8f6255a4:	e3082304 	movw	r2, #33540	; 0x8304
8f6255a8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6255ac:	11a03006 	movne	r3, r6
8f6255b0:	01a03005 	moveq	r3, r5
8f6255b4:	eb003a61 	bl	8f633f40 <snprintf>
	fastboot_info(response);
8f6255b8:	e28d0004 	add	r0, r13, #4
8f6255bc:	eb001cb1 	bl	8f62c888 <fastboot_info>
	snprintf(response, sizeof(response), "\tCharger screen enabled: %s", (device.charger_screen_enabled ? "true" : "false"));
8f6255c0:	e594301c 	ldr	r3, [r4, #28]
8f6255c4:	e3a01040 	mov	r1, #64	; 0x40
8f6255c8:	e28d0004 	add	r0, r13, #4
8f6255cc:	e3530000 	cmp	r3, #0
8f6255d0:	e308231c 	movw	r2, #33564	; 0x831c
8f6255d4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6255d8:	11a03006 	movne	r3, r6
8f6255dc:	01a03005 	moveq	r3, r5
8f6255e0:	eb003a56 	bl	8f633f40 <snprintf>
	fastboot_info(response);
8f6255e4:	e28d0004 	add	r0, r13, #4
8f6255e8:	eb001ca6 	bl	8f62c888 <fastboot_info>
	snprintf(response, sizeof(response), "\tDisplay panel: %s", (device.display_panel));
8f6255ec:	e2843020 	add	r3, r4, #32
8f6255f0:	e3a01040 	mov	r1, #64	; 0x40
8f6255f4:	e28d0004 	add	r0, r13, #4
8f6255f8:	e3082338 	movw	r2, #33592	; 0x8338
8f6255fc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f625600:	eb003a4e 	bl	8f633f40 <snprintf>
	fastboot_info(response);
8f625604:	e28d0004 	add	r0, r13, #4
8f625608:	eb001c9e 	bl	8f62c888 <fastboot_info>
	fastboot_okay("");
8f62560c:	e3070138 	movw	r0, #28984	; 0x7138
8f625610:	e3480f70 	movt	r0, #36720	; 0x8f70
8f625614:	eb001e60 	bl	8f62cf9c <fastboot_okay>
}
8f625618:	e59f301c 	ldr	r3, [pc, #28]	; 8f62563c <cmd_oem_devinfo+0x104>
8f62561c:	e5932000 	ldr	r2, [r3]
8f625620:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f625624:	e0332002 	eors	r2, r3, r2
8f625628:	e3a03000 	mov	r3, #0
8f62562c:	1a000001 	bne	8f625638 <cmd_oem_devinfo+0x100>
8f625630:	e28dd048 	add	r13, r13, #72	; 0x48
8f625634:	e8bd8070 	pop	{r4, r5, r6, r15}
8f625638:	eb003560 	bl	8f632bc0 <__stack_chk_fail>
8f62563c:	8f74221c 	.word	0x8f74221c

8f625640 <cmd_flashing_get_unlock_ability>:
	snprintf(response, sizeof(response), "\tget_unlock_ability: %d", is_allow_unlock);
8f625640:	e30f3444 	movw	r3, #62532	; 0xf444
8f625644:	e3483f73 	movt	r3, #36723	; 0x8f73
{
8f625648:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62564c:	e24dd04c 	sub	r13, r13, #76	; 0x4c
8f625650:	e59fc058 	ldr	r12, [pc, #88]	; 8f6256b0 <cmd_flashing_get_unlock_ability+0x70>
	snprintf(response, sizeof(response), "\tget_unlock_ability: %d", is_allow_unlock);
8f625654:	e3a01040 	mov	r1, #64	; 0x40
8f625658:	e5933000 	ldr	r3, [r3]
8f62565c:	e28d0004 	add	r0, r13, #4
8f625660:	e308234c 	movw	r2, #33612	; 0x834c
8f625664:	e3482f70 	movt	r2, #36720	; 0x8f70
{
8f625668:	e59cc000 	ldr	r12, [r12]
8f62566c:	e58dc044 	str	r12, [r13, #68]	; 0x44
8f625670:	e3a0c000 	mov	r12, #0
	snprintf(response, sizeof(response), "\tget_unlock_ability: %d", is_allow_unlock);
8f625674:	eb003a31 	bl	8f633f40 <snprintf>
	fastboot_info(response);
8f625678:	e28d0004 	add	r0, r13, #4
8f62567c:	eb001c81 	bl	8f62c888 <fastboot_info>
	fastboot_okay("");
8f625680:	e3070138 	movw	r0, #28984	; 0x7138
8f625684:	e3480f70 	movt	r0, #36720	; 0x8f70
8f625688:	eb001e43 	bl	8f62cf9c <fastboot_okay>
}
8f62568c:	e59f301c 	ldr	r3, [pc, #28]	; 8f6256b0 <cmd_flashing_get_unlock_ability+0x70>
8f625690:	e5932000 	ldr	r2, [r3]
8f625694:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f625698:	e0332002 	eors	r2, r3, r2
8f62569c:	e3a03000 	mov	r3, #0
8f6256a0:	1a000001 	bne	8f6256ac <cmd_flashing_get_unlock_ability+0x6c>
8f6256a4:	e28dd04c 	add	r13, r13, #76	; 0x4c
8f6256a8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6256ac:	eb003543 	bl	8f632bc0 <__stack_chk_fail>
8f6256b0:	8f74221c 	.word	0x8f74221c

8f6256b4 <cmd_reboot>:
{
8f6256b4:	e59f3054 	ldr	r3, [pc, #84]	; 8f625710 <cmd_reboot+0x5c>
	dprintf(INFO, "rebooting the device\n");
8f6256b8:	e3080364 	movw	r0, #33636	; 0x8364
{
8f6256bc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	dprintf(INFO, "rebooting the device\n");
8f6256c0:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f6256c4:	e24dd00c 	sub	r13, r13, #12
8f6256c8:	e5933000 	ldr	r3, [r3]
8f6256cc:	e58d3004 	str	r3, [r13, #4]
8f6256d0:	e3a03000 	mov	r3, #0
	dprintf(INFO, "rebooting the device\n");
8f6256d4:	eb0034a6 	bl	8f632974 <_dprintf>
	fastboot_okay("");
8f6256d8:	e3070138 	movw	r0, #28984	; 0x7138
8f6256dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6256e0:	eb001e2d 	bl	8f62cf9c <fastboot_okay>
	reboot_device(0);
8f6256e4:	e59f3024 	ldr	r3, [pc, #36]	; 8f625710 <cmd_reboot+0x5c>
8f6256e8:	e5932000 	ldr	r2, [r3]
8f6256ec:	e59d3004 	ldr	r3, [r13, #4]
8f6256f0:	e0332002 	eors	r2, r3, r2
8f6256f4:	e3a03000 	mov	r3, #0
8f6256f8:	1a000003 	bne	8f62570c <cmd_reboot+0x58>
8f6256fc:	e3a00000 	mov	r0, #0
}
8f625700:	e28dd00c 	add	r13, r13, #12
8f625704:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	reboot_device(0);
8f625708:	eaffeb02 	b	8f620318 <reboot_device>
8f62570c:	eb00352b 	bl	8f632bc0 <__stack_chk_fail>
8f625710:	8f74221c 	.word	0x8f74221c

8f625714 <cmd_reboot_bootloader>:
{
8f625714:	e59f3054 	ldr	r3, [pc, #84]	; 8f625770 <cmd_reboot_bootloader+0x5c>
	dprintf(INFO, "rebooting the device\n");
8f625718:	e3080364 	movw	r0, #33636	; 0x8364
{
8f62571c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	dprintf(INFO, "rebooting the device\n");
8f625720:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f625724:	e24dd00c 	sub	r13, r13, #12
8f625728:	e5933000 	ldr	r3, [r3]
8f62572c:	e58d3004 	str	r3, [r13, #4]
8f625730:	e3a03000 	mov	r3, #0
	dprintf(INFO, "rebooting the device\n");
8f625734:	eb00348e 	bl	8f632974 <_dprintf>
	fastboot_okay("");
8f625738:	e3070138 	movw	r0, #28984	; 0x7138
8f62573c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f625740:	eb001e15 	bl	8f62cf9c <fastboot_okay>
	reboot_device(FASTBOOT_MODE);
8f625744:	e59f3024 	ldr	r3, [pc, #36]	; 8f625770 <cmd_reboot_bootloader+0x5c>
8f625748:	e5932000 	ldr	r2, [r3]
8f62574c:	e59d3004 	ldr	r3, [r13, #4]
8f625750:	e0332002 	eors	r2, r3, r2
8f625754:	e3a03000 	mov	r3, #0
8f625758:	1a000003 	bne	8f62576c <cmd_reboot_bootloader+0x58>
8f62575c:	e3a00002 	mov	r0, #2
}
8f625760:	e28dd00c 	add	r13, r13, #12
8f625764:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	reboot_device(FASTBOOT_MODE);
8f625768:	eaffeaea 	b	8f620318 <reboot_device>
8f62576c:	eb003513 	bl	8f632bc0 <__stack_chk_fail>
8f625770:	8f74221c 	.word	0x8f74221c

8f625774 <publish_getvar_multislot_vars>:
		return splash_screen_flash();
	}
}

void publish_getvar_multislot_vars()
{
8f625774:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	static char has_slot_reply[NUM_PARTITIONS][MAX_RSP_SIZE];
	const char *tmp;
	char tmpbuff[MAX_GET_VAR_NAME_SIZE];
	signed active_slt;

	if (!published)
8f625778:	e3005688 	movw	r5, #1672	; 0x688
8f62577c:	e3485f74 	movt	r5, #36724	; 0x8f74
{
8f625780:	e59f324c 	ldr	r3, [pc, #588]	; 8f6259d4 <publish_getvar_multislot_vars+0x260>
8f625784:	e24ddf45 	sub	r13, r13, #276	; 0x114
	if (!published)
8f625788:	e5956000 	ldr	r6, [r5]
{
8f62578c:	e5933000 	ldr	r3, [r3]
8f625790:	e58d310c 	str	r3, [r13, #268]	; 0x10c
8f625794:	e3a03000 	mov	r3, #0
	if (!published)
8f625798:	e3560000 	cmp	r6, #0
8f62579c:	0a00001e 	beq	8f62581c <publish_getvar_multislot_vars+0xa8>
		snprintf(slot_count, sizeof(slot_count),"%d", AB_SUPPORTED_SLOTS);
		fastboot_publish("slot-count", slot_count);
		published = true;
	}

	active_slt = partition_find_active_slot();
8f6257a0:	ebff7e09 	bl	8f604fcc <partition_find_active_slot>
	if (active_slt != INVALID)
8f6257a4:	e3700001 	cmn	r0, #1
8f6257a8:	0a000014 	beq	8f625800 <publish_getvar_multislot_vars+0x8c>
	{
		tmp = SUFFIX_SLOT(active_slt);
8f6257ac:	e30132e0 	movw	r3, #4832	; 0x12e0
8f6257b0:	e3483f71 	movt	r3, #36721	; 0x8f71
		tmp++; // to remove "_" from slot_suffix.
		snprintf(active_slot_suffix, sizeof(active_slot_suffix), "%s", tmp);
8f6257b4:	e3082348 	movw	r2, #33608	; 0x8348
8f6257b8:	e3a01040 	mov	r1, #64	; 0x40
		tmp = SUFFIX_SLOT(active_slt);
8f6257bc:	e7933100 	ldr	r3, [r3, r0, lsl #2]
		snprintf(active_slot_suffix, sizeof(active_slot_suffix), "%s", tmp);
8f6257c0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6257c4:	e3040194 	movw	r0, #16788	; 0x4194
8f6257c8:	e3480f73 	movt	r0, #36723	; 0x8f73
8f6257cc:	e2833001 	add	r3, r3, #1
8f6257d0:	eb0039da 	bl	8f633f40 <snprintf>
	}
	else
		strlcpy(active_slot_suffix, "INVALID", sizeof(active_slot_suffix));

	/* Update partition meta information */
	partition_fill_slot_meta(slot_info);
8f6257d4:	e30006d4 	movw	r0, #1748	; 0x6d4
8f6257d8:	e3480f74 	movt	r0, #36724	; 0x8f74
8f6257dc:	ebff803b 	bl	8f6058d0 <partition_fill_slot_meta>
	return;
}
8f6257e0:	e59f31ec 	ldr	r3, [pc, #492]	; 8f6259d4 <publish_getvar_multislot_vars+0x260>
8f6257e4:	e5932000 	ldr	r2, [r3]
8f6257e8:	e59d310c 	ldr	r3, [r13, #268]	; 0x10c
8f6257ec:	e0332002 	eors	r2, r3, r2
8f6257f0:	e3a03000 	mov	r3, #0
8f6257f4:	1a000075 	bne	8f6259d0 <publish_getvar_multislot_vars+0x25c>
8f6257f8:	e28ddf45 	add	r13, r13, #276	; 0x114
8f6257fc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		strlcpy(active_slot_suffix, "INVALID", sizeof(active_slot_suffix));
8f625800:	e30813ec 	movw	r1, #33772	; 0x83ec
8f625804:	e3040194 	movw	r0, #16788	; 0x4194
8f625808:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62580c:	e3a02040 	mov	r2, #64	; 0x40
8f625810:	e3480f73 	movt	r0, #36723	; 0x8f73
8f625814:	eb003bc5 	bl	8f634730 <strlcpy>
8f625818:	eaffffed 	b	8f6257d4 <publish_getvar_multislot_vars+0x60>
		count = partition_fill_partition_meta(has_slot_pname, has_slot_reply,
8f62581c:	ebff78dd 	bl	8f603b98 <partition_get_partition_count>
8f625820:	e30d120c 	movw	r1, #53772	; 0xd20c
8f625824:	e3481f73 	movt	r1, #36723	; 0x8f73
8f625828:	e1a02000 	mov	r2, r0
8f62582c:	e305020c 	movw	r0, #21004	; 0x520c
8f625830:	e3480f73 	movt	r0, #36723	; 0x8f73
8f625834:	ebff7fc7 	bl	8f605758 <partition_fill_partition_meta>
		for(i=0; i<count; i++)
8f625838:	e2508000 	subs	r8, r0, #0
8f62583c:	da00001a 	ble	8f6258ac <publish_getvar_multislot_vars+0x138>
8f625840:	e305420c 	movw	r4, #21004	; 0x520c
8f625844:	e30d720c 	movw	r7, #53772	; 0xd20c
			snprintf(tmpbuff, MAX_GET_VAR_NAME_SIZE,"has-slot:%s",
8f625848:	e308937c 	movw	r9, #33660	; 0x837c
8f62584c:	e3484f73 	movt	r4, #36723	; 0x8f73
8f625850:	e3487f73 	movt	r7, #36723	; 0x8f73
8f625854:	e3489f70 	movt	r9, #36720	; 0x8f70
			memset(tmpbuff, 0, MAX_GET_VAR_NAME_SIZE);
8f625858:	e3a01000 	mov	r1, #0
8f62585c:	e3a02c01 	mov	r2, #256	; 0x100
8f625860:	e28d000c 	add	r0, r13, #12
		for(i=0; i<count; i++)
8f625864:	e2866001 	add	r6, r6, #1
			memset(tmpbuff, 0, MAX_GET_VAR_NAME_SIZE);
8f625868:	eb003a95 	bl	8f6342c4 <memset>
			snprintf(tmpbuff, MAX_GET_VAR_NAME_SIZE,"has-slot:%s",
8f62586c:	e1a03004 	mov	r3, r4
8f625870:	e1a02009 	mov	r2, r9
8f625874:	e3a01c01 	mov	r1, #256	; 0x100
8f625878:	e28d000c 	add	r0, r13, #12
8f62587c:	eb0039af 	bl	8f633f40 <snprintf>
			strlcpy(has_slot_pname[i], tmpbuff, MAX_GET_VAR_NAME_SIZE);
8f625880:	e28d100c 	add	r1, r13, #12
8f625884:	e3a02c01 	mov	r2, #256	; 0x100
8f625888:	e1a00004 	mov	r0, r4
8f62588c:	eb003ba7 	bl	8f634730 <strlcpy>
			fastboot_publish(has_slot_pname[i], has_slot_reply[i]);
8f625890:	e1a01007 	mov	r1, r7
8f625894:	e1a00004 	mov	r0, r4
		for(i=0; i<count; i++)
8f625898:	e2877040 	add	r7, r7, #64	; 0x40
			fastboot_publish(has_slot_pname[i], has_slot_reply[i]);
8f62589c:	eb001adb 	bl	8f62c410 <fastboot_publish>
		for(i=0; i<count; i++)
8f6258a0:	e1580006 	cmp	r8, r6
8f6258a4:	e2844c01 	add	r4, r4, #256	; 0x100
8f6258a8:	1affffea 	bne	8f625858 <publish_getvar_multislot_vars+0xe4>
8f6258ac:	e30046d4 	movw	r4, #1748	; 0x6d4
8f6258b0:	e30162e0 	movw	r6, #4832	; 0x12e0
			snprintf(slot_info[i].slot_is_unbootable, sizeof(slot_info[i].slot_is_unbootable),
8f6258b4:	e308b388 	movw	r11, #33672	; 0x8388
			snprintf(slot_info[i].slot_is_active, sizeof(slot_info[i].slot_is_active),
8f6258b8:	e308a39c 	movw	r10, #33692	; 0x839c
8f6258bc:	e3484f74 	movt	r4, #36724	; 0x8f74
8f6258c0:	e3486f71 	movt	r6, #36721	; 0x8f71
			snprintf(slot_info[i].slot_is_unbootable, sizeof(slot_info[i].slot_is_unbootable),
8f6258c4:	e348bf70 	movt	r11, #36720	; 0x8f70
			snprintf(slot_info[i].slot_is_active, sizeof(slot_info[i].slot_is_active),
8f6258c8:	e348af70 	movt	r10, #36720	; 0x8f70
8f6258cc:	e58d5004 	str	r5, [r13, #4]
			tmp = SUFFIX_SLOT(i);
8f6258d0:	e4963004 	ldr	r3, [r6], #4
			tmp++; // to remove "_" from slot_suffix.
8f6258d4:	e2849d05 	add	r9, r4, #320	; 0x140
8f6258d8:	e2848d0a 	add	r8, r4, #640	; 0x280
			snprintf(slot_info[i].slot_is_unbootable, sizeof(slot_info[i].slot_is_unbootable),
8f6258dc:	e1a0200b 	mov	r2, r11
			tmp++; // to remove "_" from slot_suffix.
8f6258e0:	e2835001 	add	r5, r3, #1
			snprintf(slot_info[i].slot_is_unbootable, sizeof(slot_info[i].slot_is_unbootable),
8f6258e4:	e3a01c01 	mov	r1, #256	; 0x100
8f6258e8:	e1a00004 	mov	r0, r4
8f6258ec:	e2847d0f 	add	r7, r4, #960	; 0x3c0
8f6258f0:	e1a03005 	mov	r3, r5
8f6258f4:	eb003991 	bl	8f633f40 <snprintf>
			snprintf(slot_info[i].slot_is_active, sizeof(slot_info[i].slot_is_active),
8f6258f8:	e1a03005 	mov	r3, r5
8f6258fc:	e1a0200a 	mov	r2, r10
8f625900:	e3a01c01 	mov	r1, #256	; 0x100
8f625904:	e1a00009 	mov	r0, r9
8f625908:	eb00398c 	bl	8f633f40 <snprintf>
			snprintf(slot_info[i].slot_is_succesful, sizeof(slot_info[i].slot_is_succesful),
8f62590c:	e1a03005 	mov	r3, r5
8f625910:	e3a01c01 	mov	r1, #256	; 0x100
8f625914:	e30823ac 	movw	r2, #33708	; 0x83ac
8f625918:	e1a00008 	mov	r0, r8
8f62591c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f625920:	eb003986 	bl	8f633f40 <snprintf>
			snprintf(slot_info[i].slot_retry_count, sizeof(slot_info[i].slot_retry_count),
8f625924:	e1a03005 	mov	r3, r5
8f625928:	e3a01c01 	mov	r1, #256	; 0x100
8f62592c:	e30823bc 	movw	r2, #33724	; 0x83bc
8f625930:	e1a00007 	mov	r0, r7
8f625934:	e3482f70 	movt	r2, #36720	; 0x8f70
8f625938:	eb003980 	bl	8f633f40 <snprintf>
			fastboot_publish(slot_info[i].slot_is_unbootable,
8f62593c:	e2841c01 	add	r1, r4, #256	; 0x100
8f625940:	e1a00004 	mov	r0, r4
8f625944:	eb001ab1 	bl	8f62c410 <fastboot_publish>
			fastboot_publish(slot_info[i].slot_is_active,
8f625948:	e2841d09 	add	r1, r4, #576	; 0x240
8f62594c:	e1a00009 	mov	r0, r9
8f625950:	eb001aae 	bl	8f62c410 <fastboot_publish>
			fastboot_publish(slot_info[i].slot_is_succesful,
8f625954:	e2841d0e 	add	r1, r4, #896	; 0x380
8f625958:	e1a00008 	mov	r0, r8
8f62595c:	eb001aab 	bl	8f62c410 <fastboot_publish>
			fastboot_publish(slot_info[i].slot_retry_count,
8f625960:	e2841d13 	add	r1, r4, #1216	; 0x4c0
8f625964:	e1a00007 	mov	r0, r7
		for (i=0; i<AB_SUPPORTED_SLOTS; i++)
8f625968:	e2844c05 	add	r4, r4, #1280	; 0x500
			fastboot_publish(slot_info[i].slot_retry_count,
8f62596c:	eb001aa7 	bl	8f62c410 <fastboot_publish>
		for (i=0; i<AB_SUPPORTED_SLOTS; i++)
8f625970:	e59f3060 	ldr	r3, [pc, #96]	; 8f6259d8 <publish_getvar_multislot_vars+0x264>
8f625974:	e1540003 	cmp	r4, r3
8f625978:	1affffd4 	bne	8f6258d0 <publish_getvar_multislot_vars+0x15c>
		fastboot_publish("current-slot", active_slot_suffix);
8f62597c:	e59d5004 	ldr	r5, [r13, #4]
8f625980:	e3041194 	movw	r1, #16788	; 0x4194
8f625984:	e30803d0 	movw	r0, #33744	; 0x83d0
8f625988:	e3481f73 	movt	r1, #36723	; 0x8f73
8f62598c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f625990:	eb001a9e 	bl	8f62c410 <fastboot_publish>
		snprintf(slot_count, sizeof(slot_count),"%d", AB_SUPPORTED_SLOTS);
8f625994:	e3a03002 	mov	r3, #2
8f625998:	e3a01040 	mov	r1, #64	; 0x40
8f62599c:	e30a2b00 	movw	r2, #43776	; 0xab00
8f6259a0:	e3000694 	movw	r0, #1684	; 0x694
8f6259a4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6259a8:	e3480f74 	movt	r0, #36724	; 0x8f74
8f6259ac:	eb003963 	bl	8f633f40 <snprintf>
		fastboot_publish("slot-count", slot_count);
8f6259b0:	e3001694 	movw	r1, #1684	; 0x694
8f6259b4:	e30803e0 	movw	r0, #33760	; 0x83e0
8f6259b8:	e3481f74 	movt	r1, #36724	; 0x8f74
8f6259bc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6259c0:	eb001a92 	bl	8f62c410 <fastboot_publish>
		published = true;
8f6259c4:	e3a03001 	mov	r3, #1
8f6259c8:	e5853000 	str	r3, [r5]
8f6259cc:	eaffff73 	b	8f6257a0 <publish_getvar_multislot_vars+0x2c>
}
8f6259d0:	eb00347a 	bl	8f632bc0 <__stack_chk_fail>
8f6259d4:	8f74221c 	.word	0x8f74221c
8f6259d8:	8f7410d4 	.word	0x8f7410d4

8f6259dc <cmd_set_active>:
{
8f6259dc:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f6259e0:	e24dd00c 	sub	r13, r13, #12
8f6259e4:	e59f214c 	ldr	r2, [pc, #332]	; 8f625b38 <cmd_set_active+0x15c>
	char *p, *sp = NULL;
8f6259e8:	e3a03000 	mov	r3, #0
{
8f6259ec:	e1a04000 	mov	r4, r0
8f6259f0:	e5922000 	ldr	r2, [r2]
8f6259f4:	e58d2004 	str	r2, [r13, #4]
8f6259f8:	e3a02000 	mov	r2, #0
	char *p, *sp = NULL;
8f6259fc:	e58d3000 	str	r3, [r13]
	if (!partition_multislot_is_supported())
8f625a00:	ebff7f41 	bl	8f60570c <partition_multislot_is_supported>
8f625a04:	e3500000 	cmp	r0, #0
8f625a08:	0a000039 	beq	8f625af4 <cmd_set_active+0x118>
	if (arg)
8f625a0c:	e3540000 	cmp	r4, #0
8f625a10:	0a00002c 	beq	8f625ac8 <cmd_set_active+0xec>
		p = strtok_r((char *)arg, ":", &sp);
8f625a14:	e30a1354 	movw	r1, #41812	; 0xa354
8f625a18:	e1a00004 	mov	r0, r4
8f625a1c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f625a20:	e1a0200d 	mov	r2, r13
8f625a24:	eb003c46 	bl	8f634b44 <strtok_r>
		if (p)
8f625a28:	e2506000 	subs	r6, r0, #0
8f625a2c:	0a000025 	beq	8f625ac8 <cmd_set_active+0xec>
			current_active_slot = partition_find_active_slot();
8f625a30:	ebff7d65 	bl	8f604fcc <partition_find_active_slot>
			current_slot_suffix = strtok_r((char *)current_slot_suffix,
8f625a34:	e30172dc 	movw	r7, #4828	; 0x12dc
			current_slot_suffix = SUFFIX_SLOT(current_active_slot);
8f625a38:	e30132e0 	movw	r3, #4832	; 0x12e0
			current_slot_suffix = strtok_r((char *)current_slot_suffix,
8f625a3c:	e3487f71 	movt	r7, #36721	; 0x8f71
			current_slot_suffix = SUFFIX_SLOT(current_active_slot);
8f625a40:	e3483f71 	movt	r3, #36721	; 0x8f71
			current_slot_suffix = strtok_r((char *)current_slot_suffix,
8f625a44:	e1a0200d 	mov	r2, r13
8f625a48:	e5971000 	ldr	r1, [r7]
			current_active_slot = partition_find_active_slot();
8f625a4c:	e1a08000 	mov	r8, r0
			current_slot_suffix = strtok_r((char *)current_slot_suffix,
8f625a50:	e7930100 	ldr	r0, [r3, r0, lsl #2]
8f625a54:	eb003c3a 	bl	8f634b44 <strtok_r>
			if (current_slot_suffix &&
8f625a58:	e2504000 	subs	r4, r0, #0
8f625a5c:	0a000006 	beq	8f625a7c <cmd_set_active+0xa0>
				!strncmp(p, current_slot_suffix, strlen(current_slot_suffix)))
8f625a60:	eb003b68 	bl	8f634808 <strlen>
8f625a64:	e1a01004 	mov	r1, r4
8f625a68:	e1a02000 	mov	r2, r0
8f625a6c:	e1a00006 	mov	r0, r6
8f625a70:	eb003b7d 	bl	8f63486c <strncmp>
			if (current_slot_suffix &&
8f625a74:	e3500000 	cmp	r0, #0
8f625a78:	0a000021 	beq	8f625b04 <cmd_set_active+0x128>
8f625a7c:	e30152e0 	movw	r5, #4832	; 0x12e0
8f625a80:	e3485f71 	movt	r5, #36721	; 0x8f71
{
8f625a84:	e3a09000 	mov	r9, #0
					current_slot_suffix = strtok_r((char *)current_slot_suffix,
8f625a88:	e5971000 	ldr	r1, [r7]
8f625a8c:	e1a0200d 	mov	r2, r13
8f625a90:	e4950004 	ldr	r0, [r5], #4
8f625a94:	eb003c2a 	bl	8f634b44 <strtok_r>
					if (current_slot_suffix &&
8f625a98:	e2504000 	subs	r4, r0, #0
8f625a9c:	0a000006 	beq	8f625abc <cmd_set_active+0xe0>
						!strncmp(p, current_slot_suffix, strlen(current_slot_suffix)))
8f625aa0:	eb003b58 	bl	8f634808 <strlen>
8f625aa4:	e1a01004 	mov	r1, r4
8f625aa8:	e1a02000 	mov	r2, r0
8f625aac:	e1a00006 	mov	r0, r6
8f625ab0:	eb003b6d 	bl	8f63486c <strncmp>
					if (current_slot_suffix &&
8f625ab4:	e3500000 	cmp	r0, #0
8f625ab8:	0a000015 	beq	8f625b14 <cmd_set_active+0x138>
				for (i = 0; i < AB_SUPPORTED_SLOTS; i++)
8f625abc:	e3590001 	cmp	r9, #1
8f625ac0:	13a09001 	movne	r9, #1
8f625ac4:	1affffef 	bne	8f625a88 <cmd_set_active+0xac>
	fastboot_fail("Invalid slot suffix.");
8f625ac8:	e3080424 	movw	r0, #33828	; 0x8424
8f625acc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f625ad0:	eb001d0e 	bl	8f62cf10 <fastboot_fail>
}
8f625ad4:	e59f305c 	ldr	r3, [pc, #92]	; 8f625b38 <cmd_set_active+0x15c>
8f625ad8:	e5932000 	ldr	r2, [r3]
8f625adc:	e59d3004 	ldr	r3, [r13, #4]
8f625ae0:	e0332002 	eors	r2, r3, r2
8f625ae4:	e3a03000 	mov	r3, #0
8f625ae8:	1a000011 	bne	8f625b34 <cmd_set_active+0x158>
8f625aec:	e28dd00c 	add	r13, r13, #12
8f625af0:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
		fastboot_fail("Command not supported");
8f625af4:	e30803f4 	movw	r0, #33780	; 0x83f4
8f625af8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f625afc:	eb001d03 	bl	8f62cf10 <fastboot_fail>
		return;
8f625b00:	eafffff3 	b	8f625ad4 <cmd_set_active+0xf8>
				fastboot_okay("Slot already set active");
8f625b04:	e308040c 	movw	r0, #33804	; 0x840c
8f625b08:	e3480f70 	movt	r0, #36720	; 0x8f70
8f625b0c:	eb001d22 	bl	8f62cf9c <fastboot_okay>
				return;
8f625b10:	eaffffef 	b	8f625ad4 <cmd_set_active+0xf8>
						partition_switch_slots(current_active_slot, i);
8f625b14:	e1a00008 	mov	r0, r8
8f625b18:	e1a01009 	mov	r1, r9
8f625b1c:	ebff7e88 	bl	8f605544 <partition_switch_slots>
						publish_getvar_multislot_vars();
8f625b20:	ebffff13 	bl	8f625774 <publish_getvar_multislot_vars>
						fastboot_okay("");
8f625b24:	e3070138 	movw	r0, #28984	; 0x7138
8f625b28:	e3480f70 	movt	r0, #36720	; 0x8f70
8f625b2c:	eb001d1a 	bl	8f62cf9c <fastboot_okay>
						return;
8f625b30:	eaffffe7 	b	8f625ad4 <cmd_set_active+0xf8>
}
8f625b34:	eb003421 	bl	8f632bc0 <__stack_chk_fail>
8f625b38:	8f74221c 	.word	0x8f74221c

8f625b3c <cmd_oem_unlock>:
		is_unlocked = device.is_unlocked;
8f625b3c:	e3013ad0 	movw	r3, #6864	; 0x1ad0
8f625b40:	e3483f71 	movt	r3, #36721	; 0x8f71
{
8f625b44:	e59f20e8 	ldr	r2, [pc, #232]	; 8f625c34 <cmd_oem_unlock+0xf8>
	if (is_unlocked == status) {
8f625b48:	e5933010 	ldr	r3, [r3, #16]
{
8f625b4c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	if (is_unlocked == status) {
8f625b50:	e3530001 	cmp	r3, #1
{
8f625b54:	e24dd04c 	sub	r13, r13, #76	; 0x4c
8f625b58:	e5922000 	ldr	r2, [r2]
8f625b5c:	e58d2044 	str	r2, [r13, #68]	; 0x44
8f625b60:	e3a02000 	mov	r2, #0
	if (is_unlocked == status) {
8f625b64:	0a000012 	beq	8f625bb4 <cmd_oem_unlock+0x78>
	if (status && !is_allow_unlock) {
8f625b68:	e30f3444 	movw	r3, #62532	; 0xf444
8f625b6c:	e3483f73 	movt	r3, #36723	; 0x8f73
8f625b70:	e5933000 	ldr	r3, [r3]
8f625b74:	e3530000 	cmp	r3, #0
8f625b78:	0a000021 	beq	8f625c04 <cmd_oem_unlock+0xc8>
	display_unlock_menu(type, status);
8f625b7c:	e3a01001 	mov	r1, #1
8f625b80:	e3a00000 	mov	r0, #0
8f625b84:	ebffa257 	bl	8f60e4e8 <display_unlock_menu>
	fastboot_okay("");
8f625b88:	e59f30a4 	ldr	r3, [pc, #164]	; 8f625c34 <cmd_oem_unlock+0xf8>
8f625b8c:	e5932000 	ldr	r2, [r3]
8f625b90:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f625b94:	e0332002 	eors	r2, r3, r2
8f625b98:	e3a03000 	mov	r3, #0
8f625b9c:	1a000023 	bne	8f625c30 <cmd_oem_unlock+0xf4>
8f625ba0:	e3070138 	movw	r0, #28984	; 0x7138
8f625ba4:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f625ba8:	e28dd04c 	add	r13, r13, #76	; 0x4c
8f625bac:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	fastboot_okay("");
8f625bb0:	ea001cf9 	b	8f62cf9c <fastboot_okay>
		snprintf(response, sizeof(response), "\tDevice already : %s", (status ? "unlocked!" : "locked!"));
8f625bb4:	e3a01040 	mov	r1, #64	; 0x40
8f625bb8:	e28d0004 	add	r0, r13, #4
8f625bbc:	e308343c 	movw	r3, #33852	; 0x843c
8f625bc0:	e3082448 	movw	r2, #33864	; 0x8448
8f625bc4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f625bc8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f625bcc:	eb0038db 	bl	8f633f40 <snprintf>
		fastboot_info(response);
8f625bd0:	e28d0004 	add	r0, r13, #4
8f625bd4:	eb001b2b 	bl	8f62c888 <fastboot_info>
		fastboot_okay("");
8f625bd8:	e3070138 	movw	r0, #28984	; 0x7138
8f625bdc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f625be0:	eb001ced 	bl	8f62cf9c <fastboot_okay>
}
8f625be4:	e59f3048 	ldr	r3, [pc, #72]	; 8f625c34 <cmd_oem_unlock+0xf8>
8f625be8:	e5932000 	ldr	r2, [r3]
8f625bec:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f625bf0:	e0332002 	eors	r2, r3, r2
8f625bf4:	e3a03000 	mov	r3, #0
8f625bf8:	1a00000c 	bne	8f625c30 <cmd_oem_unlock+0xf4>
8f625bfc:	e28dd04c 	add	r13, r13, #76	; 0x4c
8f625c00:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		fastboot_fail("oem unlock is not allowed");
8f625c04:	e59f3028 	ldr	r3, [pc, #40]	; 8f625c34 <cmd_oem_unlock+0xf8>
8f625c08:	e5932000 	ldr	r2, [r3]
8f625c0c:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f625c10:	e0332002 	eors	r2, r3, r2
8f625c14:	e3a03000 	mov	r3, #0
8f625c18:	1a000004 	bne	8f625c30 <cmd_oem_unlock+0xf4>
8f625c1c:	e3080460 	movw	r0, #33888	; 0x8460
8f625c20:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f625c24:	e28dd04c 	add	r13, r13, #76	; 0x4c
8f625c28:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		fastboot_fail("oem unlock is not allowed");
8f625c2c:	ea001cb7 	b	8f62cf10 <fastboot_fail>
}
8f625c30:	eb0033e2 	bl	8f632bc0 <__stack_chk_fail>
8f625c34:	8f74221c 	.word	0x8f74221c

8f625c38 <write_device_info.part.0>:
void write_device_info(device_info *dev)
8f625c38:	e59f3110 	ldr	r3, [pc, #272]	; 8f625d50 <write_device_info.part.0+0x118>
		struct device_info *info = memalign(PAGE_SIZE, ROUNDUP(BOOT_IMG_MAX_PAGE_SIZE, PAGE_SIZE));
8f625c3c:	e3a01a01 	mov	r1, #4096	; 0x1000
void write_device_info(device_info *dev)
8f625c40:	e92d4070 	push	{r4, r5, r6, r14}
8f625c44:	e1a05000 	mov	r5, r0
8f625c48:	e24dd010 	sub	r13, r13, #16
		struct device_info *info = memalign(PAGE_SIZE, ROUNDUP(BOOT_IMG_MAX_PAGE_SIZE, PAGE_SIZE));
8f625c4c:	e1a00001 	mov	r0, r1
void write_device_info(device_info *dev)
8f625c50:	e5933000 	ldr	r3, [r3]
8f625c54:	e58d300c 	str	r3, [r13, #12]
8f625c58:	e3a03000 	mov	r3, #0
		struct device_info *info = memalign(PAGE_SIZE, ROUNDUP(BOOT_IMG_MAX_PAGE_SIZE, PAGE_SIZE));
8f625c5c:	e1a0600e 	mov	r6, r14
8f625c60:	eb0038f7 	bl	8f634044 <memalign>
		if(info == NULL)
8f625c64:	e2504000 	subs	r4, r0, #0
8f625c68:	0a000029 	beq	8f625d14 <write_device_info.part.0+0xdc>
		info_buf = info;
8f625c6c:	e3023cfc 	movw	r3, #11516	; 0x2cfc
8f625c70:	e3483f74 	movt	r3, #36724	; 0x8f74
		memcpy(info, dev, sizeof(struct device_info));
8f625c74:	e3a02e9f 	mov	r2, #2544	; 0x9f0
8f625c78:	e1a01005 	mov	r1, r5
8f625c7c:	e1a00004 	mov	r0, r4
		info_buf = info;
8f625c80:	e5834000 	str	r4, [r3]
		memcpy(info, dev, sizeof(struct device_info));
8f625c84:	eb00394b 	bl	8f6341b8 <memcpy>
		if (VB_M <= target_get_vb_version() &&
8f625c88:	ebfff08a 	bl	8f621eb8 <target_get_vb_version>
8f625c8c:	e3500001 	cmp	r0, #1
8f625c90:	da000002 	ble	8f625ca0 <write_device_info.part.0+0x68>
			is_secure_boot_enable()) {
8f625c94:	ebffbd58 	bl	8f6151fc <is_secure_boot_enable>
		if (VB_M <= target_get_vb_version() &&
8f625c98:	e3500000 	cmp	r0, #0
8f625c9c:	1a00000c 	bne	8f625cd4 <write_device_info.part.0+0x9c>
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f625ca0:	e3070510 	movw	r0, #29968	; 0x7510
8f625ca4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f625ca8:	eb003331 	bl	8f632974 <_dprintf>
		free(info);
8f625cac:	e59f309c 	ldr	r3, [pc, #156]	; 8f625d50 <write_device_info.part.0+0x118>
8f625cb0:	e5932000 	ldr	r2, [r3]
8f625cb4:	e59d300c 	ldr	r3, [r13, #12]
8f625cb8:	e0332002 	eors	r2, r3, r2
8f625cbc:	e3a03000 	mov	r3, #0
8f625cc0:	1a000021 	bne	8f625d4c <write_device_info.part.0+0x114>
8f625cc4:	e1a00004 	mov	r0, r4
}
8f625cc8:	e28dd010 	add	r13, r13, #16
8f625ccc:	e8bd4070 	pop	{r4, r5, r6, r14}
		free(info);
8f625cd0:	ea00390d 	b	8f63410c <free>
				if((write_device_info_rpmb((void*) info, PAGE_SIZE)) < 0)
8f625cd4:	e3a01a01 	mov	r1, #4096	; 0x1000
8f625cd8:	e1a00004 	mov	r0, r4
8f625cdc:	ebffeaaf 	bl	8f6207a0 <write_device_info_rpmb>
8f625ce0:	e3500000 	cmp	r0, #0
8f625ce4:	aafffff0 	bge	8f625cac <write_device_info.part.0+0x74>
					ASSERT(0);
8f625ce8:	e3071f64 	movw	r1, #32612	; 0x7f64
8f625cec:	e3003ada 	movw	r3, #2778	; 0xada
8f625cf0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f625cf4:	e30824b0 	movw	r2, #33968	; 0x84b0
8f625cf8:	e58d1000 	str	r1, [r13]
8f625cfc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f625d00:	e1a00006 	mov	r0, r6
8f625d04:	e3001130 	movw	r1, #304	; 0x130
8f625d08:	e3481f70 	movt	r1, #36720	; 0x8f70
8f625d0c:	eb00336a 	bl	8f632abc <_panic>
8f625d10:	eaffffe5 	b	8f625cac <write_device_info.part.0+0x74>
			dprintf(CRITICAL, "Failed to allocate memory for device info struct\n");
8f625d14:	e308047c 	movw	r0, #33916	; 0x847c
8f625d18:	e3480f70 	movt	r0, #36720	; 0x8f70
8f625d1c:	eb003314 	bl	8f632974 <_dprintf>
			ASSERT(0);
8f625d20:	e3071f64 	movw	r1, #32612	; 0x7f64
8f625d24:	e30824b0 	movw	r2, #33968	; 0x84b0
8f625d28:	e3481f70 	movt	r1, #36720	; 0x8f70
8f625d2c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f625d30:	e58d1000 	str	r1, [r13]
8f625d34:	e3003ad1 	movw	r3, #2769	; 0xad1
8f625d38:	e3001130 	movw	r1, #304	; 0x130
8f625d3c:	e1a00006 	mov	r0, r6
8f625d40:	e3481f70 	movt	r1, #36720	; 0x8f70
8f625d44:	eb00335c 	bl	8f632abc <_panic>
8f625d48:	eaffffc7 	b	8f625c6c <write_device_info.part.0+0x34>
		free(info);
8f625d4c:	eb00339b 	bl	8f632bc0 <__stack_chk_fail>
8f625d50:	8f74221c 	.word	0x8f74221c

8f625d54 <publish_getvar_partition_info.constprop.0>:
static void publish_getvar_partition_info(struct getvar_partition_info *info, uint8_t num_parts)
8f625d54:	e59f3420 	ldr	r3, [pc, #1056]	; 8f62617c <publish_getvar_partition_info.constprop.0+0x428>
8f625d58:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f625d5c:	e24dd034 	sub	r13, r13, #52	; 0x34
8f625d60:	e1a04000 	mov	r4, r0
8f625d64:	e5933000 	ldr	r3, [r3]
8f625d68:	e58d302c 	str	r3, [r13, #44]	; 0x2c
8f625d6c:	e3a03000 	mov	r3, #0
				partition_get_partition_entries();
8f625d70:	ebff779b 	bl	8f603be4 <partition_get_partition_entries>
	memset(info, 0, sizeof(struct getvar_partition_info)* num_parts);
8f625d74:	e3a02fb2 	mov	r2, #712	; 0x2c8
8f625d78:	e0020492 	mul	r2, r2, r4
8f625d7c:	e3a01000 	mov	r1, #0
				partition_get_partition_entries();
8f625d80:	e1a05000 	mov	r5, r0
	memset(info, 0, sizeof(struct getvar_partition_info)* num_parts);
8f625d84:	e3020f54 	movw	r0, #12116	; 0x2f54
8f625d88:	e3480f74 	movt	r0, #36724	; 0x8f74
8f625d8c:	eb00394c 	bl	8f6342c4 <memset>
	for (i = 0; i < num_parts; i++) {
8f625d90:	e3540000 	cmp	r4, #0
8f625d94:	0a0000f1 	beq	8f626160 <publish_getvar_partition_info.constprop.0+0x40c>
8f625d98:	e2443001 	sub	r3, r4, #1
8f625d9c:	e3a02098 	mov	r2, #152	; 0x98
8f625da0:	e3024f54 	movw	r4, #12116	; 0x2f54
8f625da4:	e3484f74 	movt	r4, #36724	; 0x8f74
8f625da8:	e6ef3073 	uxtb	r3, r3
8f625dac:	e2859048 	add	r9, r5, #72	; 0x48
8f625db0:	e284bfa2 	add	r11, r4, #648	; 0x288
8f625db4:	e0235392 	mla	r3, r2, r3, r5
		strlcat(info[i].getvar_size, "partition-size:", MAX_GET_VAR_NAME_SIZE);
8f625db8:	e30824c4 	movw	r2, #33988	; 0x84c4
8f625dbc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f625dc0:	e58d2018 	str	r2, [r13, #24]
8f625dc4:	e28330e0 	add	r3, r3, #224	; 0xe0
8f625dc8:	e58d301c 	str	r3, [r13, #28]
	char *buffer = memalign(CACHE_LINE, mmc_blocksize);
8f625dcc:	e30f3648 	movw	r3, #63048	; 0xf648
8f625dd0:	e3483f73 	movt	r3, #36723	; 0x8f73
8f625dd4:	e58d300c 	str	r3, [r13, #12]
	else if (*((uint32 *)(&sb_buffer[F2FS_MAGIC_OFFSET_SB])) == F2FS_MAGIC)
8f625dd8:	e3023010 	movw	r3, #8208	; 0x2010
8f625ddc:	e34f32f5 	movt	r3, #62197	; 0xf2f5
8f625de0:	e58d3020 	str	r3, [r13, #32]
		strlcat(info[i].part_name, (const char *)ptn_entry[i].name, MAX_RSP_SIZE);
8f625de4:	e2848048 	add	r8, r4, #72	; 0x48
8f625de8:	e3a02040 	mov	r2, #64	; 0x40
8f625dec:	e1a01009 	mov	r1, r9
8f625df0:	e284af52 	add	r10, r4, #328	; 0x148
8f625df4:	e1a00004 	mov	r0, r4
8f625df8:	eb003a15 	bl	8f634654 <strlcat>
		strlcat(info[i].getvar_size, "partition-size:", MAX_GET_VAR_NAME_SIZE);
8f625dfc:	e59d1018 	ldr	r1, [r13, #24]
8f625e00:	e3a02c01 	mov	r2, #256	; 0x100
8f625e04:	e1a00008 	mov	r0, r8
8f625e08:	eb003a11 	bl	8f634654 <strlcat>
		strlcat(info[i].getvar_type, "partition-type:", MAX_GET_VAR_NAME_SIZE);
8f625e0c:	e3a02c01 	mov	r2, #256	; 0x100
8f625e10:	e30814d4 	movw	r1, #34004	; 0x84d4
8f625e14:	e1a0000a 	mov	r0, r10
8f625e18:	e3481f70 	movt	r1, #36720	; 0x8f70
8f625e1c:	eb003a0c 	bl	8f634654 <strlcat>
	if (arg == NULL ||
8f625e20:	e35b0000 	cmp	r11, #0
8f625e24:	13540000 	cmpne	r4, #0
8f625e28:	0a000082 	beq	8f626038 <publish_getvar_partition_info.constprop.0+0x2e4>
	strlcpy(response, RAW_STR, MAX_RSP_SIZE);
8f625e2c:	e30254d4 	movw	r5, #9428	; 0x24d4
8f625e30:	e3485f71 	movt	r5, #36721	; 0x8f71
8f625e34:	e3a02040 	mov	r2, #64	; 0x40
8f625e38:	e3081500 	movw	r1, #34048	; 0x8500
8f625e3c:	e1a0000b 	mov	r0, r11
8f625e40:	e3481f70 	movt	r1, #36720	; 0x8f70
8f625e44:	eb003a39 	bl	8f634730 <strlcpy>
		dprintf(SPEW, "%s() Reverting to default 0x%x\n",
8f625e48:	e30835b0 	movw	r3, #34224	; 0x85b0
8f625e4c:	e58d9010 	str	r9, [r13, #16]
8f625e50:	e3483f70 	movt	r3, #36720	; 0x8f70
8f625e54:	e58d8014 	str	r8, [r13, #20]
8f625e58:	e58d3024 	str	r3, [r13, #36]	; 0x24
		if (!strncmp(part_type_known[n].part_name, arg, strlen(arg)))
8f625e5c:	e1a00004 	mov	r0, r4
8f625e60:	eb003a68 	bl	8f634808 <strlen>
8f625e64:	e1a01004 	mov	r1, r4
8f625e68:	e1a02000 	mov	r2, r0
8f625e6c:	e1a00005 	mov	r0, r5
8f625e70:	eb003a7d 	bl	8f63486c <strncmp>
8f625e74:	e3500000 	cmp	r0, #0
8f625e78:	0a000039 	beq	8f625f64 <publish_getvar_partition_info.constprop.0+0x210>
	for (n=0; n < ARRAY_SIZE(part_type_known); n++)
8f625e7c:	e59f32fc 	ldr	r3, [pc, #764]	; 8f626180 <publish_getvar_partition_info.constprop.0+0x42c>
8f625e80:	e2855fb2 	add	r5, r5, #712	; 0x2c8
8f625e84:	e1530005 	cmp	r3, r5
8f625e88:	1afffff3 	bne	8f625e5c <publish_getvar_partition_info.constprop.0+0x108>
8f625e8c:	e59d9010 	ldr	r9, [r13, #16]
8f625e90:	e59d8014 	ldr	r8, [r13, #20]
	index = partition_get_index(arg);
8f625e94:	e1a00004 	mov	r0, r4
8f625e98:	e2845f92 	add	r5, r4, #584	; 0x248
8f625e9c:	ebff777a 	bl	8f603c8c <partition_get_index>
	if (index == INVALID_PTN)
8f625ea0:	e3700001 	cmn	r0, #1
	index = partition_get_index(arg);
8f625ea4:	e1a06000 	mov	r6, r0
	if (index == INVALID_PTN)
8f625ea8:	0a00007e 	beq	8f6260a8 <publish_getvar_partition_info.constprop.0+0x354>
	ptn = partition_get_offset(index);
8f625eac:	ebff7a82 	bl	8f6048bc <partition_get_offset>
	if(!ptn)
8f625eb0:	e1903001 	orrs	r3, r0, r1
8f625eb4:	0a00006a 	beq	8f626064 <publish_getvar_partition_info.constprop.0+0x310>
	size = partition_get_size(index);
8f625eb8:	e1a00006 	mov	r0, r6
8f625ebc:	ebff7a5d 	bl	8f604838 <partition_get_size>
	snprintf(response, MAX_RSP_SIZE, "\t 0x%llx", size);
8f625ec0:	e3082608 	movw	r2, #34312	; 0x8608
8f625ec4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f625ec8:	e1cd00f0 	strd	r0, [r13]
8f625ecc:	e3a01040 	mov	r1, #64	; 0x40
8f625ed0:	e1a00005 	mov	r0, r5
8f625ed4:	eb003819 	bl	8f633f40 <snprintf>
		if (strlcat(info[i].getvar_size, info[i].part_name, MAX_GET_VAR_NAME_SIZE) >= MAX_GET_VAR_NAME_SIZE)
8f625ed8:	e3a02c01 	mov	r2, #256	; 0x100
8f625edc:	e1a01004 	mov	r1, r4
8f625ee0:	e1a00008 	mov	r0, r8
8f625ee4:	eb0039da 	bl	8f634654 <strlcat>
8f625ee8:	e35000ff 	cmp	r0, #255	; 0xff
8f625eec:	8a00007a 	bhi	8f6260dc <publish_getvar_partition_info.constprop.0+0x388>
		if (strlcat(info[i].getvar_type, info[i].part_name, MAX_GET_VAR_NAME_SIZE) >= MAX_GET_VAR_NAME_SIZE)
8f625ef0:	e3a02c01 	mov	r2, #256	; 0x100
8f625ef4:	e1a01004 	mov	r1, r4
8f625ef8:	e1a0000a 	mov	r0, r10
8f625efc:	eb0039d4 	bl	8f634654 <strlcat>
8f625f00:	e35000ff 	cmp	r0, #255	; 0xff
8f625f04:	8a00007f 	bhi	8f626108 <publish_getvar_partition_info.constprop.0+0x3b4>
		if (!published)
8f625f08:	e300668c 	movw	r6, #1676	; 0x68c
8f625f0c:	e3486f74 	movt	r6, #36724	; 0x8f74
8f625f10:	e5963000 	ldr	r3, [r6]
8f625f14:	e3530000 	cmp	r3, #0
8f625f18:	0a00004a 	beq	8f626048 <publish_getvar_partition_info.constprop.0+0x2f4>
	for (i = 0; i < num_parts; i++) {
8f625f1c:	e59d301c 	ldr	r3, [r13, #28]
8f625f20:	e2899098 	add	r9, r9, #152	; 0x98
8f625f24:	e2844fb2 	add	r4, r4, #712	; 0x2c8
8f625f28:	e28bbfb2 	add	r11, r11, #712	; 0x2c8
8f625f2c:	e1590003 	cmp	r9, r3
8f625f30:	1affffab 	bne	8f625de4 <publish_getvar_partition_info.constprop.0+0x90>
	if (!published)
8f625f34:	e5963000 	ldr	r3, [r6]
8f625f38:	e3530000 	cmp	r3, #0
		published = true;
8f625f3c:	03a03001 	moveq	r3, #1
8f625f40:	05863000 	streq	r3, [r6]
}
8f625f44:	e59f3230 	ldr	r3, [pc, #560]	; 8f62617c <publish_getvar_partition_info.constprop.0+0x428>
8f625f48:	e5932000 	ldr	r2, [r3]
8f625f4c:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
8f625f50:	e0332002 	eors	r2, r3, r2
8f625f54:	e3a03000 	mov	r3, #0
8f625f58:	1a000072 	bne	8f626128 <publish_getvar_partition_info.constprop.0+0x3d4>
8f625f5c:	e28dd034 	add	r13, r13, #52	; 0x34
8f625f60:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	char *buffer = memalign(CACHE_LINE, mmc_blocksize);
8f625f64:	e59d300c 	ldr	r3, [r13, #12]
8f625f68:	e3a00040 	mov	r0, #64	; 0x40
8f625f6c:	e5931000 	ldr	r1, [r3]
8f625f70:	eb003833 	bl	8f634044 <memalign>
	if (!sb_buffer)
8f625f74:	e2506000 	subs	r6, r0, #0
8f625f78:	0a00007b 	beq	8f62616c <publish_getvar_partition_info.constprop.0+0x418>
	if ((index = partition_get_index(arg)) < 0)
8f625f7c:	e1a00004 	mov	r0, r4
8f625f80:	ebff7741 	bl	8f603c8c <partition_get_index>
8f625f84:	e2507000 	subs	r7, r0, #0
8f625f88:	ba000067 	blt	8f62612c <publish_getvar_partition_info.constprop.0+0x3d8>
	ptn = partition_get_offset(index);
8f625f8c:	ebff7a4a 	bl	8f6048bc <partition_get_offset>
8f625f90:	e1a03000 	mov	r3, r0
	mmc_set_lun(partition_get_lun(index));
8f625f94:	e1a00007 	mov	r0, r7
	ptn = partition_get_offset(index);
8f625f98:	e1a09001 	mov	r9, r1
8f625f9c:	e1a07003 	mov	r7, r3
	mmc_set_lun(partition_get_lun(index));
8f625fa0:	ebff7a66 	bl	8f604940 <partition_get_lun>
8f625fa4:	ebff9d22 	bl	8f60d434 <mmc_set_lun>
	sb_blk_offset = (FS_SUPERBLOCK_OFFSET/mmc_blocksize);
8f625fa8:	e59d300c 	ldr	r3, [r13, #12]
8f625fac:	e3a00b01 	mov	r0, #1024	; 0x400
8f625fb0:	e5938000 	ldr	r8, [r3]
8f625fb4:	e1a01008 	mov	r1, r8
8f625fb8:	fa005b06 	blx	8f63cbd8 <__udivsi3>
	if(mmc_read(ptn + (sb_blk_offset * mmc_blocksize),
8f625fbc:	e1a03008 	mov	r3, r8
8f625fc0:	e1a02006 	mov	r2, r6
8f625fc4:	e0000098 	mul	r0, r8, r0
8f625fc8:	e0900007 	adds	r0, r0, r7
8f625fcc:	e2a91000 	adc	r1, r9, #0
8f625fd0:	ebff9b2c 	bl	8f60cc88 <mmc_read>
8f625fd4:	e3500000 	cmp	r0, #0
8f625fd8:	1a00005a 	bne	8f626148 <publish_getvar_partition_info.constprop.0+0x3f4>
	if (sb_blk_offset == 0)
8f625fdc:	e3580b01 	cmp	r8, #1024	; 0x400
	if (*((uint16 *)(&sb_buffer[EXT_MAGIC_OFFSET_SB])) == (uint16)EXT_MAGIC)
8f625fe0:	e30e1f53 	movw	r1, #61267	; 0xef53
		sb_buffer += FS_SUPERBLOCK_OFFSET;
8f625fe4:	82863b01 	addhi	r3, r6, #1024	; 0x400
8f625fe8:	91a03006 	movls	r3, r6
	if (*((uint16 *)(&sb_buffer[EXT_MAGIC_OFFSET_SB])) == (uint16)EXT_MAGIC)
8f625fec:	e1d323b8 	ldrh	r2, [r3, #56]	; 0x38
8f625ff0:	e1520001 	cmp	r2, r1
8f625ff4:	0a00001f 	beq	8f626078 <publish_getvar_partition_info.constprop.0+0x324>
	else if (*((uint32 *)(&sb_buffer[F2FS_MAGIC_OFFSET_SB])) == F2FS_MAGIC)
8f625ff8:	e59d1020 	ldr	r1, [r13, #32]
8f625ffc:	e5933000 	ldr	r3, [r3]
8f626000:	e1530001 	cmp	r3, r1
		dprintf(SPEW, "%s() Found F2FS FS\n", arg);
8f626004:	e1a01004 	mov	r1, r4
	else if (*((uint32 *)(&sb_buffer[F2FS_MAGIC_OFFSET_SB])) == F2FS_MAGIC)
8f626008:	1a00002a 	bne	8f6260b8 <publish_getvar_partition_info.constprop.0+0x364>
		dprintf(SPEW, "%s() Found F2FS FS\n", arg);
8f62600c:	e3080594 	movw	r0, #34196	; 0x8594
8f626010:	e3480f70 	movt	r0, #36720	; 0x8f70
8f626014:	eb003256 	bl	8f632974 <_dprintf>
		free(buffer);
8f626018:	e1a00006 	mov	r0, r6
8f62601c:	eb00383a 	bl	8f63410c <free>
					strlcpy(response, F2FS_STR, MAX_RSP_SIZE);
8f626020:	e3a02040 	mov	r2, #64	; 0x40
8f626024:	e30815a8 	movw	r1, #34216	; 0x85a8
8f626028:	e1a0000b 	mov	r0, r11
8f62602c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f626030:	eb0039be 	bl	8f634730 <strlcpy>
					break;
8f626034:	eaffff90 	b	8f625e7c <publish_getvar_partition_info.constprop.0+0x128>
		dprintf(CRITICAL, "Invalid input parameter\n");
8f626038:	e30804e4 	movw	r0, #34020	; 0x84e4
8f62603c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f626040:	eb00324b 	bl	8f632974 <_dprintf>
		return;
8f626044:	eaffff92 	b	8f625e94 <publish_getvar_partition_info.constprop.0+0x140>
			fastboot_publish((const char *) info[i].getvar_size, (const char *) info[i].size_response);
8f626048:	e1a01005 	mov	r1, r5
8f62604c:	e1a00008 	mov	r0, r8
8f626050:	eb0018ee 	bl	8f62c410 <fastboot_publish>
			fastboot_publish((const char *) info[i].getvar_type, (const char *) info[i].type_response);
8f626054:	e1a0100b 	mov	r1, r11
8f626058:	e1a0000a 	mov	r0, r10
8f62605c:	eb0018eb 	bl	8f62c410 <fastboot_publish>
8f626060:	eaffffad 	b	8f625f1c <publish_getvar_partition_info.constprop.0+0x1c8>
		dprintf(CRITICAL, "Invalid partition name %s\n", arg);
8f626064:	e1a01004 	mov	r1, r4
8f626068:	e30805ec 	movw	r0, #34284	; 0x85ec
8f62606c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f626070:	eb00323f 	bl	8f632974 <_dprintf>
		return;
8f626074:	eaffff97 	b	8f625ed8 <publish_getvar_partition_info.constprop.0+0x184>
		dprintf(SPEW, "%s() Found EXT FS\n", arg);
8f626078:	e1a01004 	mov	r1, r4
8f62607c:	e3080578 	movw	r0, #34168	; 0x8578
8f626080:	e3480f70 	movt	r0, #36720	; 0x8f70
8f626084:	eb00323a 	bl	8f632974 <_dprintf>
		free(buffer);
8f626088:	e1a00006 	mov	r0, r6
8f62608c:	eb00381e 	bl	8f63410c <free>
					strlcpy(response, EXT_STR, MAX_RSP_SIZE);
8f626090:	e3a02040 	mov	r2, #64	; 0x40
8f626094:	e308158c 	movw	r1, #34188	; 0x858c
8f626098:	e1a0000b 	mov	r0, r11
8f62609c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6260a0:	eb0039a2 	bl	8f634730 <strlcpy>
					break;
8f6260a4:	eaffff74 	b	8f625e7c <publish_getvar_partition_info.constprop.0+0x128>
		dprintf(CRITICAL, "Invalid partition index\n");
8f6260a8:	e30805d0 	movw	r0, #34256	; 0x85d0
8f6260ac:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6260b0:	eb00322f 	bl	8f632974 <_dprintf>
		return;
8f6260b4:	eaffff87 	b	8f625ed8 <publish_getvar_partition_info.constprop.0+0x184>
		dprintf(SPEW, "%s() Reverting to default 0x%x\n",
8f6260b8:	e59d0024 	ldr	r0, [r13, #36]	; 0x24
8f6260bc:	eb00322c 	bl	8f632974 <_dprintf>
		free(buffer);
8f6260c0:	e1a00006 	mov	r0, r6
8f6260c4:	eb003810 	bl	8f63410c <free>
					strlcpy(response, part_type_known[n].type_response, MAX_RSP_SIZE);
8f6260c8:	e2851fa2 	add	r1, r5, #648	; 0x288
8f6260cc:	e3a02040 	mov	r2, #64	; 0x40
8f6260d0:	e1a0000b 	mov	r0, r11
8f6260d4:	eb003995 	bl	8f634730 <strlcpy>
8f6260d8:	eaffff67 	b	8f625e7c <publish_getvar_partition_info.constprop.0+0x128>
			dprintf(CRITICAL, "partition size name truncated\n");
8f6260dc:	e59f3098 	ldr	r3, [pc, #152]	; 8f62617c <publish_getvar_partition_info.constprop.0+0x428>
8f6260e0:	e5932000 	ldr	r2, [r3]
8f6260e4:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
8f6260e8:	e0332002 	eors	r2, r3, r2
8f6260ec:	e3a03000 	mov	r3, #0
8f6260f0:	03080614 	movweq	r0, #34324	; 0x8614
8f6260f4:	03480f70 	movteq	r0, #36720	; 0x8f70
8f6260f8:	1a00000a 	bne	8f626128 <publish_getvar_partition_info.constprop.0+0x3d4>
}
8f6260fc:	e28dd034 	add	r13, r13, #52	; 0x34
8f626100:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
			dprintf(CRITICAL, "partition type name truncated\n");
8f626104:	ea00321a 	b	8f632974 <_dprintf>
8f626108:	e59f306c 	ldr	r3, [pc, #108]	; 8f62617c <publish_getvar_partition_info.constprop.0+0x428>
8f62610c:	e5932000 	ldr	r2, [r3]
8f626110:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
8f626114:	e0332002 	eors	r2, r3, r2
8f626118:	e3a03000 	mov	r3, #0
8f62611c:	03080634 	movweq	r0, #34356	; 0x8634
8f626120:	03480f70 	movteq	r0, #36720	; 0x8f70
8f626124:	0afffff4 	beq	8f6260fc <publish_getvar_partition_info.constprop.0+0x3a8>
}
8f626128:	eb0032a4 	bl	8f632bc0 <__stack_chk_fail>
		dprintf(CRITICAL, "ERROR: %s() doesn't exsit\n", arg);
8f62612c:	e1a01004 	mov	r1, r4
8f626130:	e3080538 	movw	r0, #34104	; 0x8538
8f626134:	e3480f70 	movt	r0, #36720	; 0x8f70
8f626138:	eb00320d 	bl	8f632974 <_dprintf>
		free(buffer);
8f62613c:	e1a00006 	mov	r0, r6
8f626140:	eb0037f1 	bl	8f63410c <free>
			switch (fs_signature)
8f626144:	eaffffdf 	b	8f6260c8 <publish_getvar_partition_info.constprop.0+0x374>
		dprintf(CRITICAL, "ERROR: Failed to read Superblock\n");
8f626148:	e3080554 	movw	r0, #34132	; 0x8554
8f62614c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f626150:	eb003207 	bl	8f632974 <_dprintf>
		free(buffer);
8f626154:	e1a00006 	mov	r0, r6
8f626158:	eb0037eb 	bl	8f63410c <free>
			switch (fs_signature)
8f62615c:	eaffffd9 	b	8f6260c8 <publish_getvar_partition_info.constprop.0+0x374>
8f626160:	e300668c 	movw	r6, #1676	; 0x68c
8f626164:	e3486f74 	movt	r6, #36724	; 0x8f74
8f626168:	eaffff71 	b	8f625f34 <publish_getvar_partition_info.constprop.0+0x1e0>
		dprintf(CRITICAL, "ERROR: Failed to allocate buffer for superblock\n");
8f62616c:	e3080504 	movw	r0, #34052	; 0x8504
8f626170:	e3480f70 	movt	r0, #36720	; 0x8f70
8f626174:	eb0031fe 	bl	8f632974 <_dprintf>
			switch (fs_signature)
8f626178:	eaffffd2 	b	8f6260c8 <publish_getvar_partition_info.constprop.0+0x374>
8f62617c:	8f74221c 	.word	0x8f74221c
8f626180:	8f712ff4 	.word	0x8f712ff4

8f626184 <cmd_flashing_lock_critical>:
{
8f626184:	e59f304c 	ldr	r3, [pc, #76]	; 8f6261d8 <cmd_flashing_lock_critical+0x54>
	display_unlock_menu(type, status);
8f626188:	e3a01000 	mov	r1, #0
{
8f62618c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	display_unlock_menu(type, status);
8f626190:	e3a00001 	mov	r0, #1
{
8f626194:	e24dd00c 	sub	r13, r13, #12
8f626198:	e5933000 	ldr	r3, [r3]
8f62619c:	e58d3004 	str	r3, [r13, #4]
8f6261a0:	e3a03000 	mov	r3, #0
	display_unlock_menu(type, status);
8f6261a4:	ebffa0cf 	bl	8f60e4e8 <display_unlock_menu>
	fastboot_okay("");
8f6261a8:	e59f3028 	ldr	r3, [pc, #40]	; 8f6261d8 <cmd_flashing_lock_critical+0x54>
8f6261ac:	e5932000 	ldr	r2, [r3]
8f6261b0:	e59d3004 	ldr	r3, [r13, #4]
8f6261b4:	e0332002 	eors	r2, r3, r2
8f6261b8:	e3a03000 	mov	r3, #0
8f6261bc:	1a000004 	bne	8f6261d4 <cmd_flashing_lock_critical+0x50>
8f6261c0:	e3070138 	movw	r0, #28984	; 0x7138
8f6261c4:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f6261c8:	e28dd00c 	add	r13, r13, #12
8f6261cc:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	fastboot_okay("");
8f6261d0:	ea001b71 	b	8f62cf9c <fastboot_okay>
8f6261d4:	eb003279 	bl	8f632bc0 <__stack_chk_fail>
8f6261d8:	8f74221c 	.word	0x8f74221c

8f6261dc <cmd_oem_lock>:
		is_unlocked = device.is_unlocked;
8f6261dc:	e3013ad0 	movw	r3, #6864	; 0x1ad0
8f6261e0:	e3483f71 	movt	r3, #36721	; 0x8f71
{
8f6261e4:	e59f20a8 	ldr	r2, [pc, #168]	; 8f626294 <cmd_oem_lock+0xb8>
	if (is_unlocked == status) {
8f6261e8:	e5933010 	ldr	r3, [r3, #16]
{
8f6261ec:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	if (is_unlocked == status) {
8f6261f0:	e3530000 	cmp	r3, #0
{
8f6261f4:	e24dd04c 	sub	r13, r13, #76	; 0x4c
8f6261f8:	e5922000 	ldr	r2, [r2]
8f6261fc:	e58d2044 	str	r2, [r13, #68]	; 0x44
8f626200:	e3a02000 	mov	r2, #0
	if (is_unlocked == status) {
8f626204:	0a00000d 	beq	8f626240 <cmd_oem_lock+0x64>
	display_unlock_menu(type, status);
8f626208:	e3a01000 	mov	r1, #0
8f62620c:	e1a00001 	mov	r0, r1
8f626210:	ebffa0b4 	bl	8f60e4e8 <display_unlock_menu>
	fastboot_okay("");
8f626214:	e59f3078 	ldr	r3, [pc, #120]	; 8f626294 <cmd_oem_lock+0xb8>
8f626218:	e5932000 	ldr	r2, [r3]
8f62621c:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f626220:	e0332002 	eors	r2, r3, r2
8f626224:	e3a03000 	mov	r3, #0
8f626228:	1a000018 	bne	8f626290 <cmd_oem_lock+0xb4>
8f62622c:	e3070138 	movw	r0, #28984	; 0x7138
8f626230:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f626234:	e28dd04c 	add	r13, r13, #76	; 0x4c
8f626238:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	fastboot_okay("");
8f62623c:	ea001b56 	b	8f62cf9c <fastboot_okay>
		snprintf(response, sizeof(response), "\tDevice already : %s", (status ? "unlocked!" : "locked!"));
8f626240:	e3a01040 	mov	r1, #64	; 0x40
8f626244:	e28d0004 	add	r0, r13, #4
8f626248:	e3083654 	movw	r3, #34388	; 0x8654
8f62624c:	e3082448 	movw	r2, #33864	; 0x8448
8f626250:	e3483f70 	movt	r3, #36720	; 0x8f70
8f626254:	e3482f70 	movt	r2, #36720	; 0x8f70
8f626258:	eb003738 	bl	8f633f40 <snprintf>
		fastboot_info(response);
8f62625c:	e28d0004 	add	r0, r13, #4
8f626260:	eb001988 	bl	8f62c888 <fastboot_info>
		fastboot_okay("");
8f626264:	e3070138 	movw	r0, #28984	; 0x7138
8f626268:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62626c:	eb001b4a 	bl	8f62cf9c <fastboot_okay>
}
8f626270:	e59f301c 	ldr	r3, [pc, #28]	; 8f626294 <cmd_oem_lock+0xb8>
8f626274:	e5932000 	ldr	r2, [r3]
8f626278:	e59d3044 	ldr	r3, [r13, #68]	; 0x44
8f62627c:	e0332002 	eors	r2, r3, r2
8f626280:	e3a03000 	mov	r3, #0
8f626284:	1a000001 	bne	8f626290 <cmd_oem_lock+0xb4>
8f626288:	e28dd04c 	add	r13, r13, #76	; 0x4c
8f62628c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f626290:	eb00324a 	bl	8f632bc0 <__stack_chk_fail>
8f626294:	8f74221c 	.word	0x8f74221c

8f626298 <cmd_flashing_unlock_critical>:
	if (status && !is_allow_unlock) {
8f626298:	e30f3444 	movw	r3, #62532	; 0xf444
8f62629c:	e3483f73 	movt	r3, #36723	; 0x8f73
{
8f6262a0:	e59f2084 	ldr	r2, [pc, #132]	; 8f62632c <cmd_flashing_unlock_critical+0x94>
	if (status && !is_allow_unlock) {
8f6262a4:	e5933000 	ldr	r3, [r3]
{
8f6262a8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	if (status && !is_allow_unlock) {
8f6262ac:	e3530000 	cmp	r3, #0
{
8f6262b0:	e24dd00c 	sub	r13, r13, #12
8f6262b4:	e5922000 	ldr	r2, [r2]
8f6262b8:	e58d2004 	str	r2, [r13, #4]
8f6262bc:	e3a02000 	mov	r2, #0
	if (status && !is_allow_unlock) {
8f6262c0:	0a00000d 	beq	8f6262fc <cmd_flashing_unlock_critical+0x64>
	display_unlock_menu(type, status);
8f6262c4:	e3a01001 	mov	r1, #1
8f6262c8:	e1a00001 	mov	r0, r1
8f6262cc:	ebffa085 	bl	8f60e4e8 <display_unlock_menu>
	fastboot_okay("");
8f6262d0:	e59f3054 	ldr	r3, [pc, #84]	; 8f62632c <cmd_flashing_unlock_critical+0x94>
8f6262d4:	e5932000 	ldr	r2, [r3]
8f6262d8:	e59d3004 	ldr	r3, [r13, #4]
8f6262dc:	e0332002 	eors	r2, r3, r2
8f6262e0:	e3a03000 	mov	r3, #0
8f6262e4:	1a00000f 	bne	8f626328 <cmd_flashing_unlock_critical+0x90>
8f6262e8:	e3070138 	movw	r0, #28984	; 0x7138
8f6262ec:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f6262f0:	e28dd00c 	add	r13, r13, #12
8f6262f4:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	fastboot_okay("");
8f6262f8:	ea001b27 	b	8f62cf9c <fastboot_okay>
		fastboot_fail("oem unlock is not allowed");
8f6262fc:	e59f3028 	ldr	r3, [pc, #40]	; 8f62632c <cmd_flashing_unlock_critical+0x94>
8f626300:	e5932000 	ldr	r2, [r3]
8f626304:	e59d3004 	ldr	r3, [r13, #4]
8f626308:	e0332002 	eors	r2, r3, r2
8f62630c:	e3a03000 	mov	r3, #0
8f626310:	1a000004 	bne	8f626328 <cmd_flashing_unlock_critical+0x90>
8f626314:	e3080460 	movw	r0, #33888	; 0x8460
8f626318:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f62631c:	e28dd00c 	add	r13, r13, #12
8f626320:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		fastboot_fail("oem unlock is not allowed");
8f626324:	ea001af9 	b	8f62cf10 <fastboot_fail>
	fastboot_okay("");
8f626328:	eb003224 	bl	8f632bc0 <__stack_chk_fail>
8f62632c:	8f74221c 	.word	0x8f74221c

8f626330 <cmd_oem_enable_charger_screen>:
{
8f626330:	e92d4010 	push	{r4, r14}
	device.charger_screen_enabled = 1;
8f626334:	e3014ad0 	movw	r4, #6864	; 0x1ad0
{
8f626338:	e59f3078 	ldr	r3, [pc, #120]	; 8f6263b8 <cmd_oem_enable_charger_screen+0x88>
	device.charger_screen_enabled = 1;
8f62633c:	e3484f71 	movt	r4, #36721	; 0x8f71
{
8f626340:	e24dd008 	sub	r13, r13, #8
	dprintf(INFO, "Enabling charger screen check\n");
8f626344:	e308065c 	movw	r0, #34396	; 0x865c
8f626348:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f62634c:	e5933000 	ldr	r3, [r3]
8f626350:	e58d3004 	str	r3, [r13, #4]
8f626354:	e3a03000 	mov	r3, #0
	dprintf(INFO, "Enabling charger screen check\n");
8f626358:	eb003185 	bl	8f632974 <_dprintf>
	device.charger_screen_enabled = 1;
8f62635c:	e3a03001 	mov	r3, #1
8f626360:	e584301c 	str	r3, [r4, #28]
	if(target_is_emmc_boot())
8f626364:	ebffedc5 	bl	8f621a80 <target_is_emmc_boot>
8f626368:	e3500000 	cmp	r0, #0
8f62636c:	0a00000c 	beq	8f6263a4 <cmd_oem_enable_charger_screen+0x74>
8f626370:	e1a00004 	mov	r0, r4
8f626374:	ebfffe2f 	bl	8f625c38 <write_device_info.part.0>
	fastboot_okay("");
8f626378:	e59f3038 	ldr	r3, [pc, #56]	; 8f6263b8 <cmd_oem_enable_charger_screen+0x88>
8f62637c:	e5932000 	ldr	r2, [r3]
8f626380:	e59d3004 	ldr	r3, [r13, #4]
8f626384:	e0332002 	eors	r2, r3, r2
8f626388:	e3a03000 	mov	r3, #0
8f62638c:	1a000008 	bne	8f6263b4 <cmd_oem_enable_charger_screen+0x84>
8f626390:	e3070138 	movw	r0, #28984	; 0x7138
8f626394:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f626398:	e28dd008 	add	r13, r13, #8
8f62639c:	e8bd4010 	pop	{r4, r14}
	fastboot_okay("");
8f6263a0:	ea001afd 	b	8f62cf9c <fastboot_okay>
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f6263a4:	e3070510 	movw	r0, #29968	; 0x7510
8f6263a8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6263ac:	eb003170 	bl	8f632974 <_dprintf>
}
8f6263b0:	eafffff0 	b	8f626378 <cmd_oem_enable_charger_screen+0x48>
	fastboot_okay("");
8f6263b4:	eb003201 	bl	8f632bc0 <__stack_chk_fail>
8f6263b8:	8f74221c 	.word	0x8f74221c

8f6263bc <cmd_oem_disable_charger_screen>:
{
8f6263bc:	e92d4010 	push	{r4, r14}
	device.charger_screen_enabled = 0;
8f6263c0:	e3014ad0 	movw	r4, #6864	; 0x1ad0
{
8f6263c4:	e59f3078 	ldr	r3, [pc, #120]	; 8f626444 <cmd_oem_disable_charger_screen+0x88>
	device.charger_screen_enabled = 0;
8f6263c8:	e3484f71 	movt	r4, #36721	; 0x8f71
{
8f6263cc:	e24dd008 	sub	r13, r13, #8
	dprintf(INFO, "Disabling charger screen check\n");
8f6263d0:	e308067c 	movw	r0, #34428	; 0x867c
8f6263d4:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f6263d8:	e5933000 	ldr	r3, [r3]
8f6263dc:	e58d3004 	str	r3, [r13, #4]
8f6263e0:	e3a03000 	mov	r3, #0
	dprintf(INFO, "Disabling charger screen check\n");
8f6263e4:	eb003162 	bl	8f632974 <_dprintf>
	device.charger_screen_enabled = 0;
8f6263e8:	e3a03000 	mov	r3, #0
8f6263ec:	e584301c 	str	r3, [r4, #28]
	if(target_is_emmc_boot())
8f6263f0:	ebffeda2 	bl	8f621a80 <target_is_emmc_boot>
8f6263f4:	e3500000 	cmp	r0, #0
8f6263f8:	0a00000c 	beq	8f626430 <cmd_oem_disable_charger_screen+0x74>
8f6263fc:	e1a00004 	mov	r0, r4
8f626400:	ebfffe0c 	bl	8f625c38 <write_device_info.part.0>
	fastboot_okay("");
8f626404:	e59f3038 	ldr	r3, [pc, #56]	; 8f626444 <cmd_oem_disable_charger_screen+0x88>
8f626408:	e5932000 	ldr	r2, [r3]
8f62640c:	e59d3004 	ldr	r3, [r13, #4]
8f626410:	e0332002 	eors	r2, r3, r2
8f626414:	e3a03000 	mov	r3, #0
8f626418:	1a000008 	bne	8f626440 <cmd_oem_disable_charger_screen+0x84>
8f62641c:	e3070138 	movw	r0, #28984	; 0x7138
8f626420:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f626424:	e28dd008 	add	r13, r13, #8
8f626428:	e8bd4010 	pop	{r4, r14}
	fastboot_okay("");
8f62642c:	ea001ada 	b	8f62cf9c <fastboot_okay>
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f626430:	e3070510 	movw	r0, #29968	; 0x7510
8f626434:	e3480f70 	movt	r0, #36720	; 0x8f70
8f626438:	eb00314d 	bl	8f632974 <_dprintf>
}
8f62643c:	eafffff0 	b	8f626404 <cmd_oem_disable_charger_screen+0x48>
	fastboot_okay("");
8f626440:	eb0031de 	bl	8f632bc0 <__stack_chk_fail>
8f626444:	8f74221c 	.word	0x8f74221c

8f626448 <cmd_oem_select_display_panel>:
{
8f626448:	e92d4010 	push	{r4, r14}
8f62644c:	e1a04000 	mov	r4, r0
8f626450:	e59f308c 	ldr	r3, [pc, #140]	; 8f6264e4 <cmd_oem_select_display_panel+0x9c>
8f626454:	e24dd008 	sub	r13, r13, #8
	dprintf(INFO, "Selecting display panel %s\n", arg);
8f626458:	e308069c 	movw	r0, #34460	; 0x869c
8f62645c:	e1a01004 	mov	r1, r4
8f626460:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f626464:	e5933000 	ldr	r3, [r3]
8f626468:	e58d3004 	str	r3, [r13, #4]
8f62646c:	e3a03000 	mov	r3, #0
	dprintf(INFO, "Selecting display panel %s\n", arg);
8f626470:	eb00313f 	bl	8f632974 <_dprintf>
	if (arg)
8f626474:	e3540000 	cmp	r4, #0
8f626478:	0a000003 	beq	8f62648c <cmd_oem_select_display_panel+0x44>
		strlcpy(device.display_panel, arg,
8f62647c:	e59f0064 	ldr	r0, [pc, #100]	; 8f6264e8 <cmd_oem_select_display_panel+0xa0>
8f626480:	e3a02040 	mov	r2, #64	; 0x40
8f626484:	e1a01004 	mov	r1, r4
8f626488:	eb0038a8 	bl	8f634730 <strlcpy>
	if(target_is_emmc_boot())
8f62648c:	ebffed7b 	bl	8f621a80 <target_is_emmc_boot>
8f626490:	e3500000 	cmp	r0, #0
8f626494:	0a00000d 	beq	8f6264d0 <cmd_oem_select_display_panel+0x88>
8f626498:	e3010ad0 	movw	r0, #6864	; 0x1ad0
8f62649c:	e3480f71 	movt	r0, #36721	; 0x8f71
8f6264a0:	ebfffde4 	bl	8f625c38 <write_device_info.part.0>
	fastboot_okay("");
8f6264a4:	e59f3038 	ldr	r3, [pc, #56]	; 8f6264e4 <cmd_oem_select_display_panel+0x9c>
8f6264a8:	e5932000 	ldr	r2, [r3]
8f6264ac:	e59d3004 	ldr	r3, [r13, #4]
8f6264b0:	e0332002 	eors	r2, r3, r2
8f6264b4:	e3a03000 	mov	r3, #0
8f6264b8:	1a000008 	bne	8f6264e0 <cmd_oem_select_display_panel+0x98>
8f6264bc:	e3070138 	movw	r0, #28984	; 0x7138
8f6264c0:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f6264c4:	e28dd008 	add	r13, r13, #8
8f6264c8:	e8bd4010 	pop	{r4, r14}
	fastboot_okay("");
8f6264cc:	ea001ab2 	b	8f62cf9c <fastboot_okay>
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f6264d0:	e3070510 	movw	r0, #29968	; 0x7510
8f6264d4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6264d8:	eb003125 	bl	8f632974 <_dprintf>
}
8f6264dc:	eafffff0 	b	8f6264a4 <cmd_oem_select_display_panel+0x5c>
	fastboot_okay("");
8f6264e0:	eb0031b6 	bl	8f632bc0 <__stack_chk_fail>
8f6264e4:	8f74221c 	.word	0x8f74221c
8f6264e8:	8f711af0 	.word	0x8f711af0

8f6264ec <cmd_oem_off_mode_charger>:
{
8f6264ec:	e59f3108 	ldr	r3, [pc, #264]	; 8f6265fc <cmd_oem_off_mode_charger+0x110>
	if (arg) {
8f6264f0:	e3500000 	cmp	r0, #0
{
8f6264f4:	e92d4010 	push	{r4, r14}
8f6264f8:	e24dd008 	sub	r13, r13, #8
8f6264fc:	e5933000 	ldr	r3, [r3]
8f626500:	e58d3004 	str	r3, [r13, #4]
8f626504:	e3a03000 	mov	r3, #0
	if (arg) {
8f626508:	0a000018 	beq	8f626570 <cmd_oem_off_mode_charger+0x84>
		p = strtok_r((char *)arg, delim, &sp);
8f62650c:	e1a0200d 	mov	r2, r13
8f626510:	e30816b8 	movw	r1, #34488	; 0x86b8
8f626514:	e3481f70 	movt	r1, #36720	; 0x8f70
8f626518:	eb003989 	bl	8f634b44 <strtok_r>
		if (p) {
8f62651c:	e2504000 	subs	r4, r0, #0
8f626520:	0a000012 	beq	8f626570 <cmd_oem_off_mode_charger+0x84>
			if (!strncmp(p, "0", 1)) {
8f626524:	e3a02001 	mov	r2, #1
8f626528:	e3071f64 	movw	r1, #32612	; 0x7f64
8f62652c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f626530:	eb0038cd 	bl	8f63486c <strncmp>
8f626534:	e2503000 	subs	r3, r0, #0
8f626538:	0a00002a 	beq	8f6265e8 <cmd_oem_off_mode_charger+0xfc>
			} else if (!strncmp(p, "1", 1)) {
8f62653c:	e3a02001 	mov	r2, #1
8f626540:	e3001d1c 	movw	r1, #3356	; 0xd1c
8f626544:	e1a00004 	mov	r0, r4
8f626548:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62654c:	eb0038c6 	bl	8f63486c <strncmp>
8f626550:	e3500000 	cmp	r0, #0
8f626554:	1a000005 	bne	8f626570 <cmd_oem_off_mode_charger+0x84>
				device.charger_screen_enabled = 1;
8f626558:	e3012ad0 	movw	r2, #6864	; 0x1ad0
8f62655c:	e3482f71 	movt	r2, #36721	; 0x8f71
8f626560:	e3a01001 	mov	r1, #1
8f626564:	e1a03001 	mov	r3, r1
8f626568:	e582101c 	str	r1, [r2, #28]
8f62656c:	ea000002 	b	8f62657c <cmd_oem_off_mode_charger+0x90>
	snprintf(charger_screen_enabled, MAX_RSP_SIZE, "%d",
8f626570:	e3013ad0 	movw	r3, #6864	; 0x1ad0
8f626574:	e3483f71 	movt	r3, #36721	; 0x8f71
8f626578:	e593301c 	ldr	r3, [r3, #28]
8f62657c:	e3a01040 	mov	r1, #64	; 0x40
8f626580:	e30a2b00 	movw	r2, #43776	; 0xab00
8f626584:	e3020f14 	movw	r0, #12052	; 0x2f14
8f626588:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62658c:	e3480f74 	movt	r0, #36724	; 0x8f74
8f626590:	eb00366a 	bl	8f633f40 <snprintf>
	if(target_is_emmc_boot())
8f626594:	ebffed39 	bl	8f621a80 <target_is_emmc_boot>
8f626598:	e3500000 	cmp	r0, #0
8f62659c:	0a00000d 	beq	8f6265d8 <cmd_oem_off_mode_charger+0xec>
8f6265a0:	e3010ad0 	movw	r0, #6864	; 0x1ad0
8f6265a4:	e3480f71 	movt	r0, #36721	; 0x8f71
8f6265a8:	ebfffda2 	bl	8f625c38 <write_device_info.part.0>
	fastboot_okay("");
8f6265ac:	e3070138 	movw	r0, #28984	; 0x7138
8f6265b0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6265b4:	eb001a78 	bl	8f62cf9c <fastboot_okay>
}
8f6265b8:	e59f303c 	ldr	r3, [pc, #60]	; 8f6265fc <cmd_oem_off_mode_charger+0x110>
8f6265bc:	e5932000 	ldr	r2, [r3]
8f6265c0:	e59d3004 	ldr	r3, [r13, #4]
8f6265c4:	e0332002 	eors	r2, r3, r2
8f6265c8:	e3a03000 	mov	r3, #0
8f6265cc:	1a000009 	bne	8f6265f8 <cmd_oem_off_mode_charger+0x10c>
8f6265d0:	e28dd008 	add	r13, r13, #8
8f6265d4:	e8bd8010 	pop	{r4, r15}
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f6265d8:	e3070510 	movw	r0, #29968	; 0x7510
8f6265dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6265e0:	eb0030e3 	bl	8f632974 <_dprintf>
}
8f6265e4:	eafffff0 	b	8f6265ac <cmd_oem_off_mode_charger+0xc0>
				device.charger_screen_enabled = 0;
8f6265e8:	e3012ad0 	movw	r2, #6864	; 0x1ad0
8f6265ec:	e3482f71 	movt	r2, #36721	; 0x8f71
8f6265f0:	e582301c 	str	r3, [r2, #28]
8f6265f4:	eaffffe0 	b	8f62657c <cmd_oem_off_mode_charger+0x90>
}
8f6265f8:	eb003170 	bl	8f632bc0 <__stack_chk_fail>
8f6265fc:	8f74221c 	.word	0x8f74221c

8f626600 <cmd_oem_unlock_go>:
{
8f626600:	e92d4010 	push	{r4, r14}
	if(!device.is_unlocked) {
8f626604:	e3014ad0 	movw	r4, #6864	; 0x1ad0
{
8f626608:	e59f310c 	ldr	r3, [pc, #268]	; 8f62671c <cmd_oem_unlock_go+0x11c>
8f62660c:	e24ddd11 	sub	r13, r13, #1088	; 0x440
	if(!device.is_unlocked) {
8f626610:	e3484f71 	movt	r4, #36721	; 0x8f71
{
8f626614:	e24dd008 	sub	r13, r13, #8
8f626618:	e5933000 	ldr	r3, [r3]
8f62661c:	e58d3444 	str	r3, [r13, #1092]	; 0x444
8f626620:	e3a03000 	mov	r3, #0
	if(!device.is_unlocked) {
8f626624:	e5943010 	ldr	r3, [r4, #16]
8f626628:	e3530000 	cmp	r3, #0
8f62662c:	1a00001d 	bne	8f6266a8 <cmd_oem_unlock_go+0xa8>
		if(!is_allow_unlock) {
8f626630:	e30f3444 	movw	r3, #62532	; 0xf444
8f626634:	e3483f73 	movt	r3, #36723	; 0x8f73
8f626638:	e5933000 	ldr	r3, [r3]
8f62663c:	e3530000 	cmp	r3, #0
8f626640:	0a000024 	beq	8f6266d8 <cmd_oem_unlock_go+0xd8>
		device.is_unlocked = status;
8f626644:	e3a03001 	mov	r3, #1
8f626648:	e5843010 	str	r3, [r4, #16]
	if(target_is_emmc_boot())
8f62664c:	ebffed0b 	bl	8f621a80 <target_is_emmc_boot>
8f626650:	e3500000 	cmp	r0, #0
8f626654:	0a00002b 	beq	8f626708 <cmd_oem_unlock_go+0x108>
8f626658:	e1a00004 	mov	r0, r4
8f62665c:	ebfffd75 	bl	8f625c38 <write_device_info.part.0>
	        memset(&msg, 0, sizeof(msg));
8f626660:	e3a02d11 	mov	r2, #1088	; 0x440
8f626664:	e3a01000 	mov	r1, #0
8f626668:	e28d0004 	add	r0, r13, #4
8f62666c:	eb003714 	bl	8f6342c4 <memset>
		snprintf(msg.recovery, sizeof(msg.recovery), "recovery\n--wipe_data");
8f626670:	e3a01b01 	mov	r1, #1024	; 0x400
8f626674:	e28d0044 	add	r0, r13, #68	; 0x44
8f626678:	e30325dc 	movw	r2, #13788	; 0x35dc
8f62667c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f626680:	eb00362e 	bl	8f633f40 <snprintf>
		write_misc(0, &msg, sizeof(msg));
8f626684:	e28d1004 	add	r1, r13, #4
8f626688:	e3a02d11 	mov	r2, #1088	; 0x440
8f62668c:	e3a00000 	mov	r0, #0
8f626690:	eb002429 	bl	8f62f73c <write_misc>
		fastboot_okay("");
8f626694:	e3070138 	movw	r0, #28984	; 0x7138
8f626698:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62669c:	eb001a3e 	bl	8f62cf9c <fastboot_okay>
		reboot_device(RECOVERY_MODE);
8f6266a0:	e3a00001 	mov	r0, #1
8f6266a4:	ebffe71b 	bl	8f620318 <reboot_device>
	fastboot_okay("");
8f6266a8:	e59f306c 	ldr	r3, [pc, #108]	; 8f62671c <cmd_oem_unlock_go+0x11c>
8f6266ac:	e5932000 	ldr	r2, [r3]
8f6266b0:	e59d3444 	ldr	r3, [r13, #1092]	; 0x444
8f6266b4:	e0332002 	eors	r2, r3, r2
8f6266b8:	e3a03000 	mov	r3, #0
8f6266bc:	1a000015 	bne	8f626718 <cmd_oem_unlock_go+0x118>
8f6266c0:	e3070138 	movw	r0, #28984	; 0x7138
8f6266c4:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f6266c8:	e28ddd11 	add	r13, r13, #1088	; 0x440
8f6266cc:	e28dd008 	add	r13, r13, #8
8f6266d0:	e8bd4010 	pop	{r4, r14}
	fastboot_okay("");
8f6266d4:	ea001a30 	b	8f62cf9c <fastboot_okay>
			fastboot_fail("oem unlock is not allowed");
8f6266d8:	e59f303c 	ldr	r3, [pc, #60]	; 8f62671c <cmd_oem_unlock_go+0x11c>
8f6266dc:	e5932000 	ldr	r2, [r3]
8f6266e0:	e59d3444 	ldr	r3, [r13, #1092]	; 0x444
8f6266e4:	e0332002 	eors	r2, r3, r2
8f6266e8:	e3a03000 	mov	r3, #0
8f6266ec:	1a000009 	bne	8f626718 <cmd_oem_unlock_go+0x118>
8f6266f0:	e3080460 	movw	r0, #33888	; 0x8460
8f6266f4:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f6266f8:	e28ddd11 	add	r13, r13, #1088	; 0x440
8f6266fc:	e28dd008 	add	r13, r13, #8
8f626700:	e8bd4010 	pop	{r4, r14}
			fastboot_fail("oem unlock is not allowed");
8f626704:	ea001a01 	b	8f62cf10 <fastboot_fail>
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f626708:	e3070510 	movw	r0, #29968	; 0x7510
8f62670c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f626710:	eb003097 	bl	8f632974 <_dprintf>
}
8f626714:	eaffffd1 	b	8f626660 <cmd_oem_unlock_go+0x60>
	fastboot_okay("");
8f626718:	eb003128 	bl	8f632bc0 <__stack_chk_fail>
8f62671c:	8f74221c 	.word	0x8f74221c

8f626720 <update_battery_status>:
{
8f626720:	e59f3088 	ldr	r3, [pc, #136]	; 8f6267b0 <update_battery_status+0x90>
8f626724:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f626728:	e24dd00c 	sub	r13, r13, #12
8f62672c:	e5933000 	ldr	r3, [r3]
8f626730:	e58d3004 	str	r3, [r13, #4]
8f626734:	e3a03000 	mov	r3, #0
	snprintf(battery_voltage,MAX_RSP_SIZE, "%d",target_get_battery_voltage());
8f626738:	ebffef10 	bl	8f622380 <target_get_battery_voltage>
8f62673c:	e3a01040 	mov	r1, #64	; 0x40
8f626740:	e30a2b00 	movw	r2, #43776	; 0xab00
8f626744:	e3482f70 	movt	r2, #36720	; 0x8f70
8f626748:	e1a03000 	mov	r3, r0
8f62674c:	e3020d00 	movw	r0, #11520	; 0x2d00
8f626750:	e3480f74 	movt	r0, #36724	; 0x8f74
8f626754:	eb0035f9 	bl	8f633f40 <snprintf>
	snprintf(battery_soc_ok ,MAX_RSP_SIZE, "%s",target_battery_soc_ok()? "yes":"no");
8f626758:	ebffef79 	bl	8f622544 <target_battery_soc_ok>
8f62675c:	e30826c4 	movw	r2, #34500	; 0x86c4
8f626760:	e3482f70 	movt	r2, #36720	; 0x8f70
8f626764:	e30836c0 	movw	r3, #34496	; 0x86c0
8f626768:	e3483f70 	movt	r3, #36720	; 0x8f70
8f62676c:	e3500000 	cmp	r0, #0
8f626770:	01a03002 	moveq	r3, r2
8f626774:	e59f2034 	ldr	r2, [pc, #52]	; 8f6267b0 <update_battery_status+0x90>
8f626778:	e5921000 	ldr	r1, [r2]
8f62677c:	e59d2004 	ldr	r2, [r13, #4]
8f626780:	e0321001 	eors	r1, r2, r1
8f626784:	e3a02000 	mov	r2, #0
8f626788:	1a000007 	bne	8f6267ac <update_battery_status+0x8c>
8f62678c:	e3082348 	movw	r2, #33608	; 0x8348
8f626790:	e3090354 	movw	r0, #37716	; 0x9354
8f626794:	e3482f70 	movt	r2, #36720	; 0x8f70
8f626798:	e3480f75 	movt	r0, #36725	; 0x8f75
8f62679c:	e3a01040 	mov	r1, #64	; 0x40
}
8f6267a0:	e28dd00c 	add	r13, r13, #12
8f6267a4:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	snprintf(battery_soc_ok ,MAX_RSP_SIZE, "%s",target_battery_soc_ok()? "yes":"no");
8f6267a8:	ea0035e4 	b	8f633f40 <snprintf>
8f6267ac:	eb003103 	bl	8f632bc0 <__stack_chk_fail>
8f6267b0:	8f74221c 	.word	0x8f74221c

8f6267b4 <update_cmdline>:
{
8f6267b4:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	if (cmdline && lk2nd_dev.cmdline &&
8f6267b8:	e2504000 	subs	r4, r0, #0
{
8f6267bc:	e59f30f0 	ldr	r3, [pc, #240]	; 8f6268b4 <update_cmdline+0x100>
8f6267c0:	e24dd00c 	sub	r13, r13, #12
8f6267c4:	e5933000 	ldr	r3, [r3]
8f6267c8:	e58d3004 	str	r3, [r13, #4]
8f6267cc:	e3a03000 	mov	r3, #0
	if (cmdline && lk2nd_dev.cmdline &&
8f6267d0:	0a00002c 	beq	8f626888 <update_cmdline+0xd4>
8f6267d4:	e301313c 	movw	r3, #4412	; 0x113c
8f6267d8:	e3483f74 	movt	r3, #36724	; 0x8f74
8f6267dc:	e5936008 	ldr	r6, [r3, #8]
8f6267e0:	e3560000 	cmp	r6, #0
8f6267e4:	0a000027 	beq	8f626888 <update_cmdline+0xd4>
	    (strstr(cmdline, "androidboot.hardware=qcom") || strstr(cmdline, "lk2nd")))
8f6267e8:	e30816c8 	movw	r1, #34504	; 0x86c8
8f6267ec:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6267f0:	eb003884 	bl	8f634a08 <strstr>
	if (cmdline && lk2nd_dev.cmdline &&
8f6267f4:	e3500000 	cmp	r0, #0
8f6267f8:	1a000005 	bne	8f626814 <update_cmdline+0x60>
	    (strstr(cmdline, "androidboot.hardware=qcom") || strstr(cmdline, "lk2nd")))
8f6267fc:	e3011004 	movw	r1, #4100	; 0x1004
8f626800:	e1a00004 	mov	r0, r4
8f626804:	e3481f70 	movt	r1, #36720	; 0x8f70
8f626808:	eb00387e 	bl	8f634a08 <strstr>
8f62680c:	e3500000 	cmp	r0, #0
8f626810:	0a00001c 	beq	8f626888 <update_cmdline+0xd4>
	int lenA = strlen(a), lenB = strlen(b);
8f626814:	e1a00004 	mov	r0, r4
8f626818:	eb0037fa 	bl	8f634808 <strlen>
8f62681c:	e1a05000 	mov	r5, r0
8f626820:	e1a00006 	mov	r0, r6
8f626824:	eb0037f7 	bl	8f634808 <strlen>
8f626828:	e1a07000 	mov	r7, r0
	char *r = malloc(lenA + lenB + 2);
8f62682c:	e0850000 	add	r0, r5, r0
8f626830:	e2800002 	add	r0, r0, #2
8f626834:	eb0035f0 	bl	8f633ffc <malloc>
	memcpy(r, a, lenA);
8f626838:	e1a01004 	mov	r1, r4
8f62683c:	e1a02005 	mov	r2, r5
	char *r = malloc(lenA + lenB + 2);
8f626840:	e1a04000 	mov	r4, r0
	memcpy(r, a, lenA);
8f626844:	eb00365b 	bl	8f6341b8 <memcpy>
	r[lenA] = ' ';
8f626848:	e3a03020 	mov	r3, #32
8f62684c:	e7c43005 	strb	r3, [r4, r5]
	memcpy(r + lenA + 1, b, lenB + 1);
8f626850:	e2855001 	add	r5, r5, #1
8f626854:	e2872001 	add	r2, r7, #1
8f626858:	e0840005 	add	r0, r4, r5
8f62685c:	e1a01006 	mov	r1, r6
8f626860:	eb003654 	bl	8f6341b8 <memcpy>
}
8f626864:	e59f3048 	ldr	r3, [pc, #72]	; 8f6268b4 <update_cmdline+0x100>
8f626868:	e5932000 	ldr	r2, [r3]
8f62686c:	e59d3004 	ldr	r3, [r13, #4]
8f626870:	e0332002 	eors	r2, r3, r2
8f626874:	e3a03000 	mov	r3, #0
8f626878:	1a00000c 	bne	8f6268b0 <update_cmdline+0xfc>
8f62687c:	e1a00004 	mov	r0, r4
8f626880:	e28dd00c 	add	r13, r13, #12
8f626884:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
	return strdup(cmdline);
8f626888:	e59f3024 	ldr	r3, [pc, #36]	; 8f6268b4 <update_cmdline+0x100>
8f62688c:	e5932000 	ldr	r2, [r3]
8f626890:	e59d3004 	ldr	r3, [r13, #4]
8f626894:	e0332002 	eors	r2, r3, r2
8f626898:	e3a03000 	mov	r3, #0
8f62689c:	1a000003 	bne	8f6268b0 <update_cmdline+0xfc>
8f6268a0:	e1a00004 	mov	r0, r4
}
8f6268a4:	e28dd00c 	add	r13, r13, #12
8f6268a8:	e8bd40f0 	pop	{r4, r5, r6, r7, r14}
	return strdup(cmdline);
8f6268ac:	ea00374d 	b	8f6345e8 <strdup>
}
8f6268b0:	eb0030c2 	bl	8f632bc0 <__stack_chk_fail>
8f6268b4:	8f74221c 	.word	0x8f74221c

8f6268b8 <generate_mac_address>:
	char sn[] = "00000000";
8f6268b8:	e30826f0 	movw	r2, #34544	; 0x86f0
8f6268bc:	e3482f70 	movt	r2, #36720	; 0x8f70
{
8f6268c0:	e59f3154 	ldr	r3, [pc, #340]	; 8f626a1c <generate_mac_address+0x164>
	char sn[] = "00000000";
8f6268c4:	e8920007 	ldm	r2, {r0, r1, r2}
{
8f6268c8:	e92d4070 	push	{r4, r5, r6, r14}
8f6268cc:	e24dd018 	sub	r13, r13, #24
8f6268d0:	e5933000 	ldr	r3, [r3]
8f6268d4:	e58d3014 	str	r3, [r13, #20]
8f6268d8:	e3a03000 	mov	r3, #0
	char sn[] = "00000000";
8f6268dc:	e28d3008 	add	r3, r13, #8
8f6268e0:	e1a0500e 	mov	r5, r14
8f6268e4:	e8a30003 	stmia	r3!, {r0, r1}
	len = MIN(strlen(sn_buf), 8);
8f6268e8:	e3020dc0 	movw	r0, #11712	; 0x2dc0
8f6268ec:	e3480f74 	movt	r0, #36724	; 0x8f74
	char sn[] = "00000000";
8f6268f0:	e5c32000 	strb	r2, [r3]
	len = MIN(strlen(sn_buf), 8);
8f6268f4:	eb0037c3 	bl	8f634808 <strlen>
	memcpy(&sn[8-len], sn_buf, len);
8f6268f8:	e3021dc0 	movw	r1, #11712	; 0x2dc0
8f6268fc:	e3481f74 	movt	r1, #36724	; 0x8f74
	len = MIN(strlen(sn_buf), 8);
8f626900:	e3500007 	cmp	r0, #7
	memcpy(&sn[8-len], sn_buf, len);
8f626904:	928d3008 	addls	r3, r13, #8
8f626908:	828d0008 	addhi	r0, r13, #8
8f62690c:	91a02000 	movls	r2, r0
8f626910:	92620008 	rsbls	r0, r2, #8
8f626914:	90830000 	addls	r0, r3, r0
8f626918:	83a02008 	movhi	r2, #8
8f62691c:	eb003625 	bl	8f6341b8 <memcpy>
	mac = (unsigned char*) malloc(6*sizeof(unsigned char));
8f626920:	e3a00006 	mov	r0, #6
8f626924:	eb0035b4 	bl	8f633ffc <malloc>
	ASSERT(mac != NULL);
8f626928:	e2504000 	subs	r4, r0, #0
8f62692c:	0a00002e 	beq	8f6269ec <generate_mac_address+0x134>
	mac[0] = 0x02;
8f626930:	e284e006 	add	r14, r4, #6
8f626934:	e2846002 	add	r6, r4, #2
8f626938:	e28d0008 	add	r0, r13, #8
8f62693c:	e3a03002 	mov	r3, #2
	mac[1] = 00;
8f626940:	e3a05000 	mov	r5, #0
	mac[0] = 0x02;
8f626944:	e5c43000 	strb	r3, [r4]
	mac[1] = 00;
8f626948:	e5c45001 	strb	r5, [r4, #1]
    while(*x) {
8f62694c:	e5d03006 	ldrb	r3, [r0, #6]
8f626950:	e280c006 	add	r12, r0, #6
8f626954:	e3530000 	cmp	r3, #0
8f626958:	0a00000d 	beq	8f626994 <generate_mac_address+0xdc>
    unsigned n = 0;
8f62695c:	e3a02000 	mov	r2, #0
        switch(*x) {
8f626960:	e3530046 	cmp	r3, #70	; 0x46
8f626964:	8a000018 	bhi	8f6269cc <generate_mac_address+0x114>
8f626968:	e3530040 	cmp	r3, #64	; 0x40
8f62696c:	8a00001c 	bhi	8f6269e4 <generate_mac_address+0x12c>
8f626970:	e2433030 	sub	r3, r3, #48	; 0x30
8f626974:	e6ef1073 	uxtb	r1, r3
8f626978:	e3510009 	cmp	r1, #9
8f62697c:	8a000003 	bhi	8f626990 <generate_mac_address+0xd8>
            n = (n << 4) | (*x - 'A' + 10);
8f626980:	e1832202 	orr	r2, r3, r2, lsl #4
    while(*x) {
8f626984:	e5fc3001 	ldrb	r3, [r12, #1]!
8f626988:	e3530000 	cmp	r3, #0
8f62698c:	1afffff3 	bne	8f626960 <generate_mac_address+0xa8>
		mac[i+2] = hex2unsigned(&sn[2*i]);
8f626990:	e6ef3072 	uxtb	r3, r2
8f626994:	e56e3001 	strb	r3, [r14, #-1]!
	for (i = 3 ; i >= 0; i--)
8f626998:	e156000e 	cmp	r6, r14
		sn[2*i]=0;
8f62699c:	e5c05006 	strb	r5, [r0, #6]
	for (i = 3 ; i >= 0; i--)
8f6269a0:	e2400002 	sub	r0, r0, #2
8f6269a4:	1affffe8 	bne	8f62694c <generate_mac_address+0x94>
}
8f6269a8:	e59f306c 	ldr	r3, [pc, #108]	; 8f626a1c <generate_mac_address+0x164>
8f6269ac:	e5932000 	ldr	r2, [r3]
8f6269b0:	e59d3014 	ldr	r3, [r13, #20]
8f6269b4:	e0332002 	eors	r2, r3, r2
8f6269b8:	e3a03000 	mov	r3, #0
8f6269bc:	1a000015 	bne	8f626a18 <generate_mac_address+0x160>
8f6269c0:	e1a00004 	mov	r0, r4
8f6269c4:	e28dd018 	add	r13, r13, #24
8f6269c8:	e8bd8070 	pop	{r4, r5, r6, r15}
        switch(*x) {
8f6269cc:	e2431061 	sub	r1, r3, #97	; 0x61
8f6269d0:	e3510005 	cmp	r1, #5
8f6269d4:	8affffed 	bhi	8f626990 <generate_mac_address+0xd8>
            n = (n << 4) | (*x - 'a' + 10);
8f6269d8:	e2433057 	sub	r3, r3, #87	; 0x57
8f6269dc:	e1832202 	orr	r2, r3, r2, lsl #4
            break;
8f6269e0:	eaffffe7 	b	8f626984 <generate_mac_address+0xcc>
            n = (n << 4) | (*x - 'A' + 10);
8f6269e4:	e2433037 	sub	r3, r3, #55	; 0x37
8f6269e8:	eaffffe4 	b	8f626980 <generate_mac_address+0xc8>
	ASSERT(mac != NULL);
8f6269ec:	e30816e4 	movw	r1, #34532	; 0x86e4
8f6269f0:	e30824b0 	movw	r2, #33968	; 0x84b0
8f6269f4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6269f8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6269fc:	e58d1000 	str	r1, [r13]
8f626a00:	e30034c6 	movw	r3, #1222	; 0x4c6
8f626a04:	e1a00005 	mov	r0, r5
8f626a08:	e3001130 	movw	r1, #304	; 0x130
8f626a0c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f626a10:	eb003029 	bl	8f632abc <_panic>
8f626a14:	eaffffc5 	b	8f626930 <generate_mac_address+0x78>
}
8f626a18:	eb003068 	bl	8f632bc0 <__stack_chk_fail>
8f626a1c:	8f74221c 	.word	0x8f74221c

8f626a20 <boot_linux>:
{
8f626a20:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f626a24:	e24dd01c 	sub	r13, r13, #28
8f626a28:	e1a0a001 	mov	r10, r1
8f626a2c:	e1a04002 	mov	r4, r2
8f626a30:	e58d3008 	str	r3, [r13, #8]
8f626a34:	e1a08000 	mov	r8, r0
8f626a38:	e59f31b4 	ldr	r3, [pc, #436]	; 8f626bf4 <boot_linux+0x1d4>
8f626a3c:	e58de00c 	str	r14, [r13, #12]
8f626a40:	e59d5040 	ldr	r5, [r13, #64]	; 0x40
8f626a44:	e5933000 	ldr	r3, [r3]
8f626a48:	e58d3014 	str	r3, [r13, #20]
8f626a4c:	e3a03000 	mov	r3, #0
8f626a50:	e59db044 	ldr	r11, [r13, #68]	; 0x44
	void (*entry)(unsigned, unsigned, unsigned*) = (entry_func_ptr*)(PA((addr_t)kernel));
8f626a54:	ebff6b3e 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f626a58:	e1a07000 	mov	r7, r0
	uint32_t tags_phys = PA((addr_t)tags);
8f626a5c:	e1a0000a 	mov	r0, r10
8f626a60:	ebff6b3b 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f626a64:	e1a06000 	mov	r6, r0
	struct kernel64_hdr *kptr = ((struct kernel64_hdr*)(PA((addr_t)kernel)));
8f626a68:	e1a00008 	mov	r0, r8
8f626a6c:	ebff6b38 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f626a70:	e1a09000 	mov	r9, r0
	ramdisk = (void *)PA((addr_t)ramdisk);
8f626a74:	e1a00005 	mov	r0, r5
8f626a78:	ebff6b35 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f626a7c:	e1a05000 	mov	r5, r0
	final_cmdline = update_cmdline((const char*)cmdline);
8f626a80:	e1a00004 	mov	r0, r4
8f626a84:	ebffff4a 	bl	8f6267b4 <update_cmdline>
8f626a88:	e1a04000 	mov	r4, r0
	lk2nd_clear_pstore();
8f626a8c:	eb001c4e 	bl	8f62dbcc <lk2nd_clear_pstore>
	dprintf(INFO, "Updating device tree: start\n");
8f626a90:	e30806fc 	movw	r0, #34556	; 0x86fc
8f626a94:	e3480f70 	movt	r0, #36720	; 0x8f70
8f626a98:	eb002fb5 	bl	8f632974 <_dprintf>
	mac = generate_mac_address();
8f626a9c:	ebffff85 	bl	8f6268b8 <generate_mac_address>
	ret = update_device_tree((void *)tags,(const char *)final_cmdline, ramdisk, ramdisk_size, mac);
8f626aa0:	e1a0300b 	mov	r3, r11
8f626aa4:	e1a02005 	mov	r2, r5
8f626aa8:	e1a01004 	mov	r1, r4
8f626aac:	e58d0000 	str	r0, [r13]
8f626ab0:	e1a0000a 	mov	r0, r10
8f626ab4:	ebffcaa1 	bl	8f619540 <update_device_tree>
	if(ret)
8f626ab8:	e3500000 	cmp	r0, #0
8f626abc:	1a000031 	bne	8f626b88 <boot_linux+0x168>
	dprintf(INFO, "Updating device tree: done\n");
8f626ac0:	e3080744 	movw	r0, #34628	; 0x8744
8f626ac4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f626ac8:	eb002fa9 	bl	8f632974 <_dprintf>
	target_display_shutdown();
8f626acc:	ebffec3e 	bl	8f621bcc <target_display_shutdown>
	target_uninit();
8f626ad0:	ebff689c 	bl	8f600d48 <target_uninit>
	free_verified_boot_resource(&info);
8f626ad4:	e30f020c 	movw	r0, #61964	; 0xf20c
8f626ad8:	e3480f73 	movt	r0, #36723	; 0x8f73
8f626adc:	ebffe84a 	bl	8f620c0c <free_verified_boot_resource>
	if (final_cmdline)
8f626ae0:	e3540000 	cmp	r4, #0
8f626ae4:	0a000001 	beq	8f626af0 <boot_linux+0xd0>
		free(final_cmdline);
8f626ae8:	e1a00004 	mov	r0, r4
8f626aec:	eb003586 	bl	8f63410c <free>
	dprintf(INFO, "booting linux @ %p, ramdisk @ %p (%d), tags/device tree @ %p\n",
8f626af0:	e1a0300b 	mov	r3, r11
8f626af4:	e1a02005 	mov	r2, r5
8f626af8:	e1a01007 	mov	r1, r7
8f626afc:	e3080760 	movw	r0, #34656	; 0x8760
8f626b00:	e58d6000 	str	r6, [r13]
8f626b04:	e3480f70 	movt	r0, #36720	; 0x8f70
8f626b08:	eb002f99 	bl	8f632974 <_dprintf>
	critical_section_count++;
8f626b0c:	e3012acc 	movw	r2, #6860	; 0x1acc
8f626b10:	e3482f71 	movt	r2, #36721	; 0x8f71
8f626b14:	e5923000 	ldr	r3, [r2]
8f626b18:	e2833001 	add	r3, r3, #1
8f626b1c:	e5823000 	str	r3, [r2]
	if (critical_section_count == 1)
8f626b20:	e3530001 	cmp	r3, #1
8f626b24:	0a00002f 	beq	8f626be8 <boot_linux+0x1c8>
	platform_uninit();
8f626b28:	ebff6a80 	bl	8f601530 <platform_uninit>
	arch_disable_cache(UCACHE);
8f626b2c:	e3a00003 	mov	r0, #3
8f626b30:	ebffe898 	bl	8f620d98 <arch_disable_cache>
	arch_disable_mmu();
8f626b34:	ebffeb36 	bl	8f621814 <arch_disable_mmu>
	bs_set_timestamp(BS_KERNEL_ENTRY);
8f626b38:	e3a00001 	mov	r0, #1
8f626b3c:	ebff8169 	bl	8f6070e8 <bs_set_timestamp>
	if (IS_ARM64(kptr))
8f626b40:	e5992038 	ldr	r2, [r9, #56]	; 0x38
8f626b44:	e3053241 	movw	r3, #21057	; 0x5241
8f626b48:	e346344d 	movt	r3, #25677	; 0x644d
8f626b4c:	e1520003 	cmp	r2, r3
		scm_elexec_call((paddr_t)kernel, tags_phys);
8f626b50:	e59f309c 	ldr	r3, [pc, #156]	; 8f626bf4 <boot_linux+0x1d4>
	if (IS_ARM64(kptr))
8f626b54:	0a000019 	beq	8f626bc0 <boot_linux+0x1a0>
		entry(0, machtype, (unsigned*)tags_phys);
8f626b58:	e5932000 	ldr	r2, [r3]
8f626b5c:	e59d3014 	ldr	r3, [r13, #20]
8f626b60:	e0332002 	eors	r2, r3, r2
8f626b64:	e3a03000 	mov	r3, #0
8f626b68:	1a000020 	bne	8f626bf0 <boot_linux+0x1d0>
8f626b6c:	e59d1008 	ldr	r1, [r13, #8]
8f626b70:	e1a02006 	mov	r2, r6
8f626b74:	e3a00000 	mov	r0, #0
8f626b78:	e1a03007 	mov	r3, r7
}
8f626b7c:	e28dd01c 	add	r13, r13, #28
8f626b80:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
		entry(0, machtype, (unsigned*)tags_phys);
8f626b84:	e12fff13 	bx	r3
		dprintf(CRITICAL, "ERROR: Updating Device Tree Failed \n");
8f626b88:	e308071c 	movw	r0, #34588	; 0x871c
8f626b8c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f626b90:	eb002f77 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f626b94:	e59d000c 	ldr	r0, [r13, #12]
8f626b98:	e3073f64 	movw	r3, #32612	; 0x7f64
8f626b9c:	e30824b0 	movw	r2, #33968	; 0x84b0
8f626ba0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f626ba4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f626ba8:	e58d3000 	str	r3, [r13]
8f626bac:	e3001130 	movw	r1, #304	; 0x130
8f626bb0:	e30034f3 	movw	r3, #1267	; 0x4f3
8f626bb4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f626bb8:	eb002fbf 	bl	8f632abc <_panic>
8f626bbc:	eaffffbf 	b	8f626ac0 <boot_linux+0xa0>
		scm_elexec_call((paddr_t)kernel, tags_phys);
8f626bc0:	e5932000 	ldr	r2, [r3]
8f626bc4:	e59d3014 	ldr	r3, [r13, #20]
8f626bc8:	e0332002 	eors	r2, r3, r2
8f626bcc:	e3a03000 	mov	r3, #0
8f626bd0:	1a000006 	bne	8f626bf0 <boot_linux+0x1d0>
8f626bd4:	e1a01006 	mov	r1, r6
8f626bd8:	e1a00008 	mov	r0, r8
}
8f626bdc:	e28dd01c 	add	r13, r13, #28
8f626be0:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
		scm_elexec_call((paddr_t)kernel, tags_phys);
8f626be4:	eaffb75f 	b	8f614968 <scm_elexec_call>
		arch_disable_ints();
8f626be8:	ebffe90a 	bl	8f621018 <arch_disable_ints>
8f626bec:	eaffffcd 	b	8f626b28 <boot_linux+0x108>
		entry(0, machtype, (unsigned*)tags_phys);
8f626bf0:	eb002ff2 	bl	8f632bc0 <__stack_chk_fail>
8f626bf4:	8f74221c 	.word	0x8f74221c

8f626bf8 <check_aboot_addr_range_overlap>:
	if ((UINT_MAX - start) < size)
8f626bf8:	e1e03000 	mvn	r3, r0
8f626bfc:	e1530001 	cmp	r3, r1
{
8f626c00:	e59f307c 	ldr	r3, [pc, #124]	; 8f626c84 <check_aboot_addr_range_overlap+0x8c>
8f626c04:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f626c08:	e24dd00c 	sub	r13, r13, #12
8f626c0c:	e5933000 	ldr	r3, [r3]
8f626c10:	e58d3004 	str	r3, [r13, #4]
8f626c14:	e3a03000 	mov	r3, #0
	if ((UINT_MAX - start) < size)
8f626c18:	3a000016 	bcc	8f626c78 <check_aboot_addr_range_overlap+0x80>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f626c1c:	e30f3fff 	movw	r3, #65535	; 0xffff
8f626c20:	e3483f5f 	movt	r3, #36703	; 0x8f5f
8f626c24:	e1500003 	cmp	r0, r3
8f626c28:	9a00000b 	bls	8f626c5c <check_aboot_addr_range_overlap+0x64>
	else if (start >= (MEMBASE + MEMSIZE))
8f626c2c:	e3700217 	cmn	r0, #1879048193	; 0x70000001
8f626c30:	83a00000 	movhi	r0, #0
8f626c34:	93a00001 	movls	r0, #1
8f626c38:	e2600000 	rsb	r0, r0, #0
}
8f626c3c:	e59f3040 	ldr	r3, [pc, #64]	; 8f626c84 <check_aboot_addr_range_overlap+0x8c>
8f626c40:	e5932000 	ldr	r2, [r3]
8f626c44:	e59d3004 	ldr	r3, [r13, #4]
8f626c48:	e0332002 	eors	r2, r3, r2
8f626c4c:	e3a03000 	mov	r3, #0
8f626c50:	1a00000a 	bne	8f626c80 <check_aboot_addr_range_overlap+0x88>
8f626c54:	e28dd00c 	add	r13, r13, #12
8f626c58:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f626c5c:	e0800001 	add	r0, r0, r1
8f626c60:	e3a01000 	mov	r1, #0
8f626c64:	e3481f60 	movt	r1, #36704	; 0x8f60
8f626c68:	e1500001 	cmp	r0, r1
8f626c6c:	93a00000 	movls	r0, #0
8f626c70:	83e00000 	mvnhi	r0, #0
8f626c74:	eafffff0 	b	8f626c3c <check_aboot_addr_range_overlap+0x44>
		return -1;
8f626c78:	e3e00000 	mvn	r0, #0
8f626c7c:	eaffffee 	b	8f626c3c <check_aboot_addr_range_overlap+0x44>
}
8f626c80:	eb002fce 	bl	8f632bc0 <__stack_chk_fail>
8f626c84:	8f74221c 	.word	0x8f74221c

8f626c88 <check_ddr_addr_range_bound>:
{
8f626c88:	e59f30a4 	ldr	r3, [pc, #164]	; 8f626d34 <check_ddr_addr_range_bound+0xac>
8f626c8c:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f626c90:	e24dd008 	sub	r13, r13, #8
8f626c94:	e5933000 	ldr	r3, [r3]
8f626c98:	e58d3004 	str	r3, [r13, #4]
8f626c9c:	e3a03000 	mov	r3, #0
8f626ca0:	e1a07001 	mov	r7, r1
8f626ca4:	e1a05000 	mov	r5, r0
	uintptr_t ddr_pa_start_addr = PA(get_ddr_start());
8f626ca8:	ebff70e6 	bl	8f603048 <get_ddr_start>
8f626cac:	ebff6aa8 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f626cb0:	e1a04000 	mov	r4, r0
	uint64_t ddr_size = smem_get_ddr_size();
8f626cb4:	ebff712a 	bl	8f603164 <smem_get_ddr_size>
	uint64_t ddr_pa_end_addr = ddr_pa_start_addr + ddr_size;
8f626cb8:	e0946000 	adds	r6, r4, r0
	uintptr_t pa_start_addr = PA(start);
8f626cbc:	e1a00005 	mov	r0, r5
	uint64_t ddr_pa_end_addr = ddr_pa_start_addr + ddr_size;
8f626cc0:	e2a18000 	adc	r8, r1, #0
	uintptr_t pa_start_addr = PA(start);
8f626cc4:	ebff6aa2 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	if ((UINT_MAX - start) < size)
8f626cc8:	e1e05005 	mvn	r5, r5
	if (pa_start_addr < ddr_pa_start_addr ||
8f626ccc:	e1540000 	cmp	r4, r0
8f626cd0:	93a04000 	movls	r4, #0
8f626cd4:	83a04001 	movhi	r4, #1
8f626cd8:	e1550007 	cmp	r5, r7
8f626cdc:	33844001 	orrcc	r4, r4, #1
8f626ce0:	e3540000 	cmp	r4, #0
8f626ce4:	1a00000f 	bne	8f626d28 <check_ddr_addr_range_bound+0xa0>
8f626ce8:	e1500006 	cmp	r0, r6
8f626cec:	e0d43008 	sbcs	r3, r4, r8
8f626cf0:	2a00000c 	bcs	8f626d28 <check_ddr_addr_range_bound+0xa0>
		(pa_start_addr + size) > ddr_pa_end_addr)
8f626cf4:	e0800007 	add	r0, r0, r7
		pa_start_addr >= (ddr_pa_end_addr) ||
8f626cf8:	e1560000 	cmp	r6, r0
8f626cfc:	e2d83000 	sbcs	r3, r8, #0
8f626d00:	33e00000 	mvncc	r0, #0
8f626d04:	23a00000 	movcs	r0, #0
}
8f626d08:	e59f3024 	ldr	r3, [pc, #36]	; 8f626d34 <check_ddr_addr_range_bound+0xac>
8f626d0c:	e5932000 	ldr	r2, [r3]
8f626d10:	e59d3004 	ldr	r3, [r13, #4]
8f626d14:	e0332002 	eors	r2, r3, r2
8f626d18:	e3a03000 	mov	r3, #0
8f626d1c:	1a000003 	bne	8f626d30 <check_ddr_addr_range_bound+0xa8>
8f626d20:	e28dd008 	add	r13, r13, #8
8f626d24:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
		return -1;
8f626d28:	e3e00000 	mvn	r0, #0
8f626d2c:	eafffff5 	b	8f626d08 <check_ddr_addr_range_bound+0x80>
}
8f626d30:	eb002fa2 	bl	8f632bc0 <__stack_chk_fail>
8f626d34:	8f74221c 	.word	0x8f74221c

8f626d38 <boot_linux_from_mmc>:
{
8f626d38:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f626d3c:	e24dd074 	sub	r13, r13, #116	; 0x74
8f626d40:	e59f2d84 	ldr	r2, [pc, #3460]	; 8f627acc <boot_linux_from_mmc+0xd94>
	index = partition_get_index("bootselect");
8f626d44:	e30807a0 	movw	r0, #34720	; 0x87a0
8f626d48:	e3480f70 	movt	r0, #36720	; 0x8f70
	unsigned int dtb_size = 0;
8f626d4c:	e3a03000 	mov	r3, #0
8f626d50:	e58de020 	str	r14, [r13, #32]
{
8f626d54:	e5922000 	ldr	r2, [r2]
8f626d58:	e58d206c 	str	r2, [r13, #108]	; 0x6c
8f626d5c:	e3a02000 	mov	r2, #0
	unsigned int dtb_size = 0;
8f626d60:	e58d3030 	str	r3, [r13, #48]	; 0x30
	unsigned int out_len = 0;
8f626d64:	e58d3034 	str	r3, [r13, #52]	; 0x34
	uint32_t dtb_offset = 0;
8f626d68:	e58d3038 	str	r3, [r13, #56]	; 0x38
	index = partition_get_index("bootselect");
8f626d6c:	ebff73c6 	bl	8f603c8c <partition_get_index>
	if (index == INVALID_PTN)
8f626d70:	e3700001 	cmn	r0, #1
8f626d74:	0a00023e 	beq	8f627674 <boot_linux_from_mmc+0x93c>
8f626d78:	e1a04000 	mov	r4, r0
	offset = partition_get_offset(index);
8f626d7c:	ebff76ce 	bl	8f6048bc <partition_get_offset>
	if(!offset)
8f626d80:	e1903001 	orrs	r3, r0, r1
	offset = partition_get_offset(index);
8f626d84:	e1a07000 	mov	r7, r0
8f626d88:	e1a05001 	mov	r5, r1
	if(!offset)
8f626d8c:	0a00021c 	beq	8f627604 <boot_linux_from_mmc+0x8cc>
	buf = (char *) memalign(CACHE_LINE, ROUNDUP(page_size, CACHE_LINE));
8f626d90:	e3006684 	movw	r6, #1668	; 0x684
8f626d94:	e3486f74 	movt	r6, #36724	; 0x8f74
8f626d98:	e3a00040 	mov	r0, #64	; 0x40
8f626d9c:	e5961000 	ldr	r1, [r6]
8f626da0:	e281103f 	add	r1, r1, #63	; 0x3f
8f626da4:	e3c1103f 	bic	r1, r1, #63	; 0x3f
8f626da8:	eb0034a5 	bl	8f634044 <memalign>
8f626dac:	e1a03000 	mov	r3, r0
	mmc_set_lun(partition_get_lun(index));
8f626db0:	e1a00004 	mov	r0, r4
	buf = (char *) memalign(CACHE_LINE, ROUNDUP(page_size, CACHE_LINE));
8f626db4:	e1a04003 	mov	r4, r3
	mmc_set_lun(partition_get_lun(index));
8f626db8:	ebff76e0 	bl	8f604940 <partition_get_lun>
8f626dbc:	ebff999c 	bl	8f60d434 <mmc_set_lun>
	ASSERT(buf);
8f626dc0:	e3540000 	cmp	r4, #0
8f626dc4:	0a00025b 	beq	8f627738 <boot_linux_from_mmc+0xa00>
	if (mmc_read(offset, (uint32_t *)buf, page_size))
8f626dc8:	e5963000 	ldr	r3, [r6]
8f626dcc:	e1a00007 	mov	r0, r7
8f626dd0:	e1a01005 	mov	r1, r5
8f626dd4:	e1a02004 	mov	r2, r4
8f626dd8:	ebff97aa 	bl	8f60cc88 <mmc_read>
8f626ddc:	e3500000 	cmp	r0, #0
8f626de0:	1a00024d 	bne	8f62771c <boot_linux_from_mmc+0x9e4>
	if ((in->signature == BOOTSELECT_SIGNATURE) &&
8f626de4:	e5941000 	ldr	r1, [r4]
8f626de8:	e3053342 	movw	r3, #21314	; 0x5342
8f626dec:	e3463c65 	movt	r3, #27749	; 0x6c65
			(in->version == BOOTSELECT_VERSION)) {
8f626df0:	e5942004 	ldr	r2, [r4, #4]
	if ((in->signature == BOOTSELECT_SIGNATURE) &&
8f626df4:	e1510003 	cmp	r1, r3
8f626df8:	1a000003 	bne	8f626e0c <boot_linux_from_mmc+0xd4>
8f626dfc:	e3a03001 	mov	r3, #1
8f626e00:	e3403001 	movt	r3, #1
8f626e04:	e1520003 	cmp	r2, r3
8f626e08:	0a0000c0 	beq	8f627110 <boot_linux_from_mmc+0x3d8>
		dprintf(CRITICAL, "Signature: 0x%08x or version: 0x%08x mismatched of /bootselect\n",
8f626e0c:	e3080820 	movw	r0, #34848	; 0x8820
8f626e10:	e3480f70 	movt	r0, #36720	; 0x8f70
8f626e14:	eb002ed6 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f626e18:	e59d0020 	ldr	r0, [r13, #32]
8f626e1c:	e300361c 	movw	r3, #1564	; 0x61c
8f626e20:	e3071f64 	movw	r1, #32612	; 0x7f64
8f626e24:	e30824b0 	movw	r2, #33968	; 0x84b0
8f626e28:	e3481f70 	movt	r1, #36720	; 0x8f70
8f626e2c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f626e30:	e58d1000 	str	r1, [r13]
8f626e34:	e3001130 	movw	r1, #304	; 0x130
8f626e38:	e3481f70 	movt	r1, #36720	; 0x8f70
8f626e3c:	eb002f1e 	bl	8f632abc <_panic>
	free(buf);
8f626e40:	e1a00004 	mov	r0, r4
8f626e44:	eb0034b0 	bl	8f63410c <free>
	if (!boot_into_recovery) {
8f626e48:	e301817c 	movw	r8, #4476	; 0x117c
8f626e4c:	e3488f74 	movt	r8, #36724	; 0x8f74
8f626e50:	e5981000 	ldr	r1, [r8]
8f626e54:	e3510000 	cmp	r1, #0
8f626e58:	1a0000b7 	bne	8f62713c <boot_linux_from_mmc+0x404>
		memset(ffbm_mode_string, '\0', sizeof(ffbm_mode_string));
8f626e5c:	e3a02008 	mov	r2, #8
8f626e60:	e3050204 	movw	r0, #20996	; 0x5204
8f626e64:	e3480f73 	movt	r0, #36723	; 0x8f73
8f626e68:	eb003515 	bl	8f6342c4 <memset>
		rcode = get_ffbm(ffbm_mode_string, sizeof(ffbm_mode_string));
8f626e6c:	e3a01008 	mov	r1, #8
8f626e70:	e3050204 	movw	r0, #20996	; 0x5204
8f626e74:	e3480f73 	movt	r0, #36723	; 0x8f73
8f626e78:	eb0022c6 	bl	8f62f998 <get_ffbm>
			if (rcode < 0)
8f626e7c:	e3500000 	cmp	r0, #0
8f626e80:	ba0002d3 	blt	8f6279d4 <boot_linux_from_mmc+0xc9c>
	if (!memcmp(uhdr->magic, BOOT_MAGIC, BOOT_MAGIC_SIZE)) {
8f626e84:	e3a02008 	mov	r2, #8
8f626e88:	e308187c 	movw	r1, #34940	; 0x887c
8f626e8c:	e3a00a0f 	mov	r0, #61440	; 0xf000
8f626e90:	e3481f70 	movt	r1, #36720	; 0x8f70
8f626e94:	e3480f6f 	movt	r0, #36719	; 0x8f6f
8f626e98:	eb00354e 	bl	8f6343d8 <memcmp>
8f626e9c:	e3500000 	cmp	r0, #0
8f626ea0:	0a0000ad 	beq	8f62715c <boot_linux_from_mmc+0x424>
	if (boot_into_recovery &&
8f626ea4:	e5983000 	ldr	r3, [r8]
8f626ea8:	e3530000 	cmp	r3, #0
8f626eac:	1a0001d8 	bne	8f627614 <boot_linux_from_mmc+0x8dc>
			ptn_name = "boot";
8f626eb0:	e30a5370 	movw	r5, #41840	; 0xa370
8f626eb4:	e3485f70 	movt	r5, #36720	; 0x8f70
	index = partition_get_index(ptn_name);
8f626eb8:	e1a00005 	mov	r0, r5
8f626ebc:	ebff7372 	bl	8f603c8c <partition_get_index>
8f626ec0:	e1a04000 	mov	r4, r0
	ptn = partition_get_offset(index);
8f626ec4:	ebff767c 	bl	8f6048bc <partition_get_offset>
8f626ec8:	e1a0b000 	mov	r11, r0
	image_size = partition_get_size(index);
8f626ecc:	e1a00004 	mov	r0, r4
	ptn = partition_get_offset(index);
8f626ed0:	e1a06001 	mov	r6, r1
8f626ed4:	e58d1018 	str	r1, [r13, #24]
	image_size = partition_get_size(index);
8f626ed8:	ebff7656 	bl	8f604838 <partition_get_size>
	if(ptn == 0 || image_size == 0) {
8f626edc:	e1a03006 	mov	r3, r6
8f626ee0:	e19b3003 	orrs	r3, r11, r3
8f626ee4:	03a03001 	moveq	r3, #1
8f626ee8:	13a03000 	movne	r3, #0
	image_size = partition_get_size(index);
8f626eec:	e1a02001 	mov	r2, r1
	if(ptn == 0 || image_size == 0) {
8f626ef0:	e1902002 	orrs	r2, r0, r2
8f626ef4:	03833001 	orreq	r3, r3, #1
	image_size = partition_get_size(index);
8f626ef8:	e1a0a000 	mov	r10, r0
	if(ptn == 0 || image_size == 0) {
8f626efc:	e3530000 	cmp	r3, #0
	image_size = partition_get_size(index);
8f626f00:	e58d1024 	str	r1, [r13, #36]	; 0x24
	if(ptn == 0 || image_size == 0) {
8f626f04:	1a0002b6 	bne	8f6279e4 <boot_linux_from_mmc+0xcac>
	mmc_set_lun(partition_get_lun(index));
8f626f08:	e1a00004 	mov	r0, r4
	if (mmc_read(ptn + offset, (uint32_t *) buf, page_size)) {
8f626f0c:	e3006684 	movw	r6, #1668	; 0x684
8f626f10:	e3044200 	movw	r4, #16896	; 0x4200
8f626f14:	e3486f74 	movt	r6, #36724	; 0x8f74
8f626f18:	e3484f73 	movt	r4, #36723	; 0x8f73
	mmc_set_lun(partition_get_lun(index));
8f626f1c:	ebff7687 	bl	8f604940 <partition_get_lun>
8f626f20:	ebff9943 	bl	8f60d434 <mmc_set_lun>
	if (mmc_read(ptn + offset, (uint32_t *) buf, page_size)) {
8f626f24:	e5963000 	ldr	r3, [r6]
8f626f28:	e59d1018 	ldr	r1, [r13, #24]
8f626f2c:	e1a0000b 	mov	r0, r11
8f626f30:	e1a02004 	mov	r2, r4
8f626f34:	ebff9753 	bl	8f60cc88 <mmc_read>
8f626f38:	e3500000 	cmp	r0, #0
8f626f3c:	1a0002b8 	bne	8f627a24 <boot_linux_from_mmc+0xcec>
	if (memcmp(hdr->magic, BOOT_MAGIC, BOOT_MAGIC_SIZE)) {
8f626f40:	e3a02008 	mov	r2, #8
8f626f44:	e308187c 	movw	r1, #34940	; 0x887c
8f626f48:	e1a00004 	mov	r0, r4
8f626f4c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f626f50:	eb003520 	bl	8f6343d8 <memcmp>
8f626f54:	e3500000 	cmp	r0, #0
8f626f58:	1a000269 	bne	8f627904 <boot_linux_from_mmc+0xbcc>
	if (hdr->page_size && (hdr->page_size != page_size)) {
8f626f5c:	e5942024 	ldr	r2, [r4, #36]	; 0x24
8f626f60:	e3520000 	cmp	r2, #0
8f626f64:	0a000170 	beq	8f62752c <boot_linux_from_mmc+0x7f4>
8f626f68:	e5963000 	ldr	r3, [r6]
8f626f6c:	e1520003 	cmp	r2, r3
8f626f70:	0a00016d 	beq	8f62752c <boot_linux_from_mmc+0x7f4>
		if (hdr->page_size > BOOT_IMG_MAX_PAGE_SIZE) {
8f626f74:	e3520a01 	cmp	r2, #4096	; 0x1000
8f626f78:	8a0002be 	bhi	8f627a78 <boot_linux_from_mmc+0xd40>
		page_mask = page_size - 1;
8f626f7c:	e3009680 	movw	r9, #1664	; 0x680
8f626f80:	e3489f74 	movt	r9, #36724	; 0x8f74
		page_size = hdr->page_size;
8f626f84:	e5862000 	str	r2, [r6]
		page_mask = page_size - 1;
8f626f88:	e2422001 	sub	r2, r2, #1
8f626f8c:	e5892000 	str	r2, [r9]
	kernel_actual  = ROUND_TO_PAGE(hdr->kernel_size,  page_mask);
8f626f90:	e5943008 	ldr	r3, [r4, #8]
8f626f94:	e1e00002 	mvn	r0, r2
8f626f98:	e0831002 	add	r1, r3, r2
8f626f9c:	e1c15002 	bic	r5, r1, r2
8f626fa0:	e58d500c 	str	r5, [r13, #12]
8f626fa4:	e1530005 	cmp	r3, r5
	if (UINT_MAX < ((uint64_t)kernel_actual + (uint64_t)ramdisk_actual+ (uint64_t)second_actual + (uint64_t)dt_actual + page_size)) {
8f626fa8:	93a03000 	movls	r3, #0
8f626fac:	83a03000 	movhi	r3, #0
8f626fb0:	958d3028 	strls	r3, [r13, #40]	; 0x28
8f626fb4:	83e05000 	mvnhi	r5, #0
8f626fb8:	858d3028 	strhi	r3, [r13, #40]	; 0x28
	ramdisk_actual = ROUND_TO_PAGE(hdr->ramdisk_size, page_mask);
8f626fbc:	e5943010 	ldr	r3, [r4, #16]
	kernel_actual  = ROUND_TO_PAGE(hdr->kernel_size,  page_mask);
8f626fc0:	858d500c 	strhi	r5, [r13, #12]
	ramdisk_actual = ROUND_TO_PAGE(hdr->ramdisk_size, page_mask);
8f626fc4:	e0831002 	add	r1, r3, r2
8f626fc8:	e0011000 	and	r1, r1, r0
8f626fcc:	e58d1010 	str	r1, [r13, #16]
8f626fd0:	e1530001 	cmp	r3, r1
	if (UINT_MAX < ((uint64_t)kernel_actual + (uint64_t)ramdisk_actual+ (uint64_t)second_actual + (uint64_t)dt_actual + page_size)) {
8f626fd4:	91a03001 	movls	r3, r1
	second_actual  = ROUND_TO_PAGE(hdr->second_size, page_mask);
8f626fd8:	e5941018 	ldr	r1, [r4, #24]
8f626fdc:	83e03000 	mvnhi	r3, #0
	ramdisk_actual = ROUND_TO_PAGE(hdr->ramdisk_size, page_mask);
8f626fe0:	858d3010 	strhi	r3, [r13, #16]
	second_actual  = ROUND_TO_PAGE(hdr->second_size, page_mask);
8f626fe4:	e0812002 	add	r2, r1, r2
8f626fe8:	e0022000 	and	r2, r2, r0
8f626fec:	e58d2014 	str	r2, [r13, #20]
8f626ff0:	e1510002 	cmp	r1, r2
8f626ff4:	8a000150 	bhi	8f62753c <boot_linux_from_mmc+0x804>
8f626ff8:	e58d302c 	str	r3, [r13, #44]	; 0x2c
	image_addr = (unsigned char *)target_get_scratch_address();
8f626ffc:	ebff68d4 	bl	8f601354 <target_get_scratch_address>
	memcpy(image_addr, (void *)buf, page_size);
8f627000:	e5962000 	ldr	r2, [r6]
8f627004:	e3041200 	movw	r1, #16896	; 0x4200
8f627008:	e3481f73 	movt	r1, #36723	; 0x8f73
	image_addr = (unsigned char *)target_get_scratch_address();
8f62700c:	e1a07000 	mov	r7, r0
	memcpy(image_addr, (void *)buf, page_size);
8f627010:	eb003468 	bl	8f6341b8 <memcpy>
	dt_size = hdr->dt_size;
8f627014:	e5942028 	ldr	r2, [r4, #40]	; 0x28
8f627018:	e3053200 	movw	r3, #20992	; 0x5200
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f62701c:	e5991000 	ldr	r1, [r9]
	dt_size = hdr->dt_size;
8f627020:	e3483f73 	movt	r3, #36723	; 0x8f73
	if (UINT_MAX < ((uint64_t)kernel_actual + (uint64_t)ramdisk_actual+ (uint64_t)second_actual + (uint64_t)dt_actual + page_size)) {
8f627024:	e59dc014 	ldr	r12, [r13, #20]
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f627028:	e0820001 	add	r0, r2, r1
	dt_size = hdr->dt_size;
8f62702c:	e5832000 	str	r2, [r3]
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f627030:	e1c01001 	bic	r1, r0, r1
	dt_size = hdr->dt_size;
8f627034:	e58d301c 	str	r3, [r13, #28]
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f627038:	e1520001 	cmp	r2, r1
8f62703c:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
	if (UINT_MAX < ((uint64_t)kernel_actual + (uint64_t)ramdisk_actual+ (uint64_t)second_actual + (uint64_t)dt_actual + page_size)) {
8f627040:	e3a02000 	mov	r2, #0
        hdr->cmdline[BOOT_ARGS_SIZE-1] = 0;
8f627044:	e5c4223f 	strb	r2, [r4, #575]	; 0x23f
8f627048:	83e00000 	mvnhi	r0, #0
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f62704c:	81a01000 	movhi	r1, r0
8f627050:	9a00014f 	bls	8f627594 <boot_linux_from_mmc+0x85c>
	if (UINT_MAX < ((uint64_t)kernel_actual + (uint64_t)ramdisk_actual+ (uint64_t)second_actual + (uint64_t)dt_actual + page_size)) {
8f627054:	e5962000 	ldr	r2, [r6]
8f627058:	e59de028 	ldr	r14, [r13, #40]	; 0x28
8f62705c:	e0925005 	adds	r5, r2, r5
8f627060:	e2aee000 	adc	r14, r14, #0
8f627064:	e0955003 	adds	r5, r5, r3
8f627068:	e2aee000 	adc	r14, r14, #0
8f62706c:	e095500c 	adds	r5, r5, r12
8f627070:	e2aee000 	adc	r14, r14, #0
8f627074:	e0955000 	adds	r5, r5, r0
8f627078:	e2aee000 	adc	r14, r14, #0
8f62707c:	e35e0000 	cmp	r14, #0
8f627080:	1a00024b 	bne	8f6279b4 <boot_linux_from_mmc+0xc7c>
	imagesize_actual = (page_size + kernel_actual + ramdisk_actual + second_actual + dt_actual);
8f627084:	e59d000c 	ldr	r0, [r13, #12]
8f627088:	e0825000 	add	r5, r2, r0
8f62708c:	e59d2010 	ldr	r2, [r13, #16]
8f627090:	e0855002 	add	r5, r5, r2
8f627094:	e59d2014 	ldr	r2, [r13, #20]
8f627098:	e0855002 	add	r5, r5, r2
	if (imagesize_actual > image_size) {
8f62709c:	e59d2024 	ldr	r2, [r13, #36]	; 0x24
	imagesize_actual = (page_size + kernel_actual + ramdisk_actual + second_actual + dt_actual);
8f6270a0:	e0855001 	add	r5, r5, r1
	if (imagesize_actual > image_size) {
8f6270a4:	e15a0005 	cmp	r10, r5
8f6270a8:	e2d22000 	sbcs	r2, r2, #0
8f6270ac:	3a000261 	bcc	8f627a38 <boot_linux_from_mmc+0xd00>
	if ((UINT_MAX - start) < size)
8f6270b0:	e1e03007 	mvn	r3, r7
8f6270b4:	e1550003 	cmp	r5, r3
8f6270b8:	8a000008 	bhi	8f6270e0 <boot_linux_from_mmc+0x3a8>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f6270bc:	e30f3fff 	movw	r3, #65535	; 0xffff
8f6270c0:	e3483f5f 	movt	r3, #36703	; 0x8f5f
8f6270c4:	e1570003 	cmp	r7, r3
8f6270c8:	8a000036 	bhi	8f6271a8 <boot_linux_from_mmc+0x470>
8f6270cc:	e0872005 	add	r2, r7, r5
8f6270d0:	e3a03000 	mov	r3, #0
8f6270d4:	e3483f60 	movt	r3, #36704	; 0x8f60
8f6270d8:	e1520003 	cmp	r2, r3
8f6270dc:	9a000033 	bls	8f6271b0 <boot_linux_from_mmc+0x478>
		dprintf(CRITICAL, "Boot image buffer address overlaps with aboot addresses.\n");
8f6270e0:	e3080998 	movw	r0, #35224	; 0x8998
8f6270e4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6270e8:	eb002e21 	bl	8f632974 <_dprintf>
		return -1;
8f6270ec:	e3e00000 	mvn	r0, #0
}
8f6270f0:	e59f39d4 	ldr	r3, [pc, #2516]	; 8f627acc <boot_linux_from_mmc+0xd94>
8f6270f4:	e5932000 	ldr	r2, [r3]
8f6270f8:	e59d306c 	ldr	r3, [r13, #108]	; 0x6c
8f6270fc:	e0332002 	eors	r2, r3, r2
8f627100:	e3a03000 	mov	r3, #0
8f627104:	1a00026f 	bne	8f627ac8 <boot_linux_from_mmc+0xd90>
8f627108:	e28dd074 	add	r13, r13, #116	; 0x74
8f62710c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		if ((in->state_info & BOOTSELECT_FORMAT) &&
8f627110:	e594300c 	ldr	r3, [r4, #12]
8f627114:	e3530000 	cmp	r3, #0
8f627118:	aa000191 	bge	8f627764 <boot_linux_from_mmc+0xa2c>
8f62711c:	e3130101 	tst	r3, #1073741824	; 0x40000000
8f627120:	1a00018f 	bne	8f627764 <boot_linux_from_mmc+0xa2c>
		boot_into_recovery = 1;
8f627124:	e301817c 	movw	r8, #4476	; 0x117c
8f627128:	e3488f74 	movt	r8, #36724	; 0x8f74
	free(buf);
8f62712c:	e1a00004 	mov	r0, r4
8f627130:	eb0033f5 	bl	8f63410c <free>
		boot_into_recovery = 1;
8f627134:	e3a03001 	mov	r3, #1
8f627138:	e5883000 	str	r3, [r8]
	if (!memcmp(uhdr->magic, BOOT_MAGIC, BOOT_MAGIC_SIZE)) {
8f62713c:	e3a02008 	mov	r2, #8
8f627140:	e308187c 	movw	r1, #34940	; 0x887c
8f627144:	e3a00a0f 	mov	r0, #61440	; 0xf000
8f627148:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62714c:	e3480f6f 	movt	r0, #36719	; 0x8f6f
8f627150:	eb0034a0 	bl	8f6343d8 <memcmp>
8f627154:	e3500000 	cmp	r0, #0
8f627158:	1a00012d 	bne	8f627614 <boot_linux_from_mmc+0x8dc>
		dprintf(INFO, "Unified boot method!\n");
8f62715c:	e3080888 	movw	r0, #34952	; 0x8888
8f627160:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627164:	eb002e02 	bl	8f632974 <_dprintf>
		hdr = uhdr;
8f627168:	e3a04a0f 	mov	r4, #61440	; 0xf000
8f62716c:	e3484f6f 	movt	r4, #36719	; 0x8f6f
	boot_linux((void *)hdr->kernel_addr, (void *)hdr->tags_addr,
8f627170:	e594500c 	ldr	r5, [r4, #12]
8f627174:	e5946020 	ldr	r6, [r4, #32]
8f627178:	ebff6677 	bl	8f600b5c <board_machtype>
8f62717c:	e5942010 	ldr	r2, [r4, #16]
8f627180:	e1a01006 	mov	r1, r6
8f627184:	e58d2004 	str	r2, [r13, #4]
8f627188:	e2842040 	add	r2, r4, #64	; 0x40
8f62718c:	e594c014 	ldr	r12, [r4, #20]
8f627190:	e58dc000 	str	r12, [r13]
8f627194:	e1a03000 	mov	r3, r0
8f627198:	e1a00005 	mov	r0, r5
8f62719c:	ebfffe1f 	bl	8f626a20 <boot_linux>
	return 0;
8f6271a0:	e3a00000 	mov	r0, #0
8f6271a4:	eaffffd1 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
	else if (start >= (MEMBASE + MEMSIZE))
8f6271a8:	e3770217 	cmn	r7, #1879048193	; 0x70000001
8f6271ac:	9affffcb 	bls	8f6270e0 <boot_linux_from_mmc+0x3a8>
	if (partition_multislot_is_supported())
8f6271b0:	ebff7955 	bl	8f60570c <partition_multislot_is_supported>
8f6271b4:	e3500000 	cmp	r0, #0
8f6271b8:	1a00011b 	bne	8f62762c <boot_linux_from_mmc+0x8f4>
		dprintf(INFO, "Loading (%s) image (%d): start\n",
8f6271bc:	e5981000 	ldr	r1, [r8]
8f6271c0:	e30a2370 	movw	r2, #41840	; 0xa370
8f6271c4:	e3003d34 	movw	r3, #3380	; 0xd34
8f6271c8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6271cc:	e3510000 	cmp	r1, #0
8f6271d0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6271d4:	e3080a04 	movw	r0, #35332	; 0x8a04
8f6271d8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6271dc:	01a01002 	moveq	r1, r2
8f6271e0:	11a01003 	movne	r1, r3
8f6271e4:	e1a02005 	mov	r2, r5
	int current_active_slot = INVALID;
8f6271e8:	e3e0a000 	mvn	r10, #0
		dprintf(INFO, "Loading (%s) image (%d): start\n",
8f6271ec:	eb002de0 	bl	8f632974 <_dprintf>
	bs_set_timestamp(BS_KERNEL_LOAD_START);
8f6271f0:	e3a00004 	mov	r0, #4
8f6271f4:	ebff7fbb 	bl	8f6070e8 <bs_set_timestamp>
	if ((target_get_max_flash_size() - page_size) < imagesize_actual)
8f6271f8:	ebff6867 	bl	8f60139c <target_get_max_flash_size>
8f6271fc:	e5962000 	ldr	r2, [r6]
8f627200:	e0400002 	sub	r0, r0, r2
8f627204:	e1500005 	cmp	r0, r5
8f627208:	3a0001fb 	bcc	8f6279fc <boot_linux_from_mmc+0xcc4>
	if (mmc_read(ptn + offset, (void *)(image_addr + offset), imagesize_actual - page_size))
8f62720c:	e59d3018 	ldr	r3, [r13, #24]
8f627210:	e092000b 	adds	r0, r2, r11
8f627214:	e2a31000 	adc	r1, r3, #0
8f627218:	e0453002 	sub	r3, r5, r2
8f62721c:	e0872002 	add	r2, r7, r2
8f627220:	ebff9698 	bl	8f60cc88 <mmc_read>
8f627224:	e2503000 	subs	r3, r0, #0
8f627228:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f62722c:	1a0001f7 	bne	8f627a10 <boot_linux_from_mmc+0xcd8>
	if (partition_multislot_is_supported())
8f627230:	ebff7935 	bl	8f60570c <partition_multislot_is_supported>
8f627234:	e3500000 	cmp	r0, #0
8f627238:	1a000105 	bne	8f627654 <boot_linux_from_mmc+0x91c>
		dprintf(INFO, "Loading (%s) image (%d): done\n",
8f62723c:	e5981000 	ldr	r1, [r8]
8f627240:	e30a2370 	movw	r2, #41840	; 0xa370
8f627244:	e3003d34 	movw	r3, #3380	; 0xd34
8f627248:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62724c:	e3510000 	cmp	r1, #0
8f627250:	e3483f70 	movt	r3, #36720	; 0x8f70
8f627254:	e3080aa4 	movw	r0, #35492	; 0x8aa4
8f627258:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62725c:	01a01002 	moveq	r1, r2
8f627260:	11a01003 	movne	r1, r3
8f627264:	e1a02005 	mov	r2, r5
8f627268:	eb002dc1 	bl	8f632974 <_dprintf>
	bs_set_timestamp(BS_KERNEL_LOAD_DONE);
8f62726c:	e3a00005 	mov	r0, #5
	dprintf(INFO, "use_signed_kernel=%d, is_unlocked=%d, is_tampered=%d.\n",
8f627270:	e301aad0 	movw	r10, #6864	; 0x1ad0
	bs_set_timestamp(BS_KERNEL_LOAD_DONE);
8f627274:	ebff7f9b 	bl	8f6070e8 <bs_set_timestamp>
	dprintf(INFO, "use_signed_kernel=%d, is_unlocked=%d, is_tampered=%d.\n",
8f627278:	e348af71 	movt	r10, #36721	; 0x8f71
8f62727c:	ebffea10 	bl	8f621ac4 <target_use_signed_kernel>
8f627280:	e1ca21d0 	ldrd	r2, [r10, #16]
8f627284:	e1a01000 	mov	r1, r0
8f627288:	e3080ac4 	movw	r0, #35524	; 0x8ac4
8f62728c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627290:	eb002db7 	bl	8f632974 <_dprintf>
	if((target_use_signed_kernel() && (!device.is_unlocked)) || is_test_mode_enabled())
8f627294:	ebffea0a 	bl	8f621ac4 <target_use_signed_kernel>
8f627298:	e3500000 	cmp	r0, #0
8f62729c:	0a000002 	beq	8f6272ac <boot_linux_from_mmc+0x574>
8f6272a0:	e59a3010 	ldr	r3, [r10, #16]
8f6272a4:	e3530000 	cmp	r3, #0
8f6272a8:	0a000100 	beq	8f6276b0 <boot_linux_from_mmc+0x978>
		second_actual  = ROUND_TO_PAGE(hdr->second_size,  page_mask);
8f6272ac:	e5943018 	ldr	r3, [r4, #24]
8f6272b0:	e5992000 	ldr	r2, [r9]
8f6272b4:	e0831002 	add	r1, r3, r2
8f6272b8:	e1c12002 	bic	r2, r1, r2
8f6272bc:	e1530002 	cmp	r3, r2
8f6272c0:	91a03002 	movls	r3, r2
8f6272c4:	83e03000 	mvnhi	r3, #0
8f6272c8:	e58d3014 	str	r3, [r13, #20]
	if (is_gzip_package((unsigned char *)(image_addr + page_size), hdr->kernel_size))
8f6272cc:	e5960000 	ldr	r0, [r6]
8f6272d0:	e5941008 	ldr	r1, [r4, #8]
8f6272d4:	e0870000 	add	r0, r7, r0
8f6272d8:	eb00506b 	bl	8f63b48c <is_gzip_package>
8f6272dc:	e250b000 	subs	r11, r0, #0
8f6272e0:	0a0000ad 	beq	8f62759c <boot_linux_from_mmc+0x864>
		out_addr = (unsigned char *)(image_addr + imagesize_actual + page_size);
8f6272e4:	e596b000 	ldr	r11, [r6]
		out_avai_len = target_get_max_flash_size() - imagesize_actual - page_size;
8f6272e8:	ebff682b 	bl	8f60139c <target_get_max_flash_size>
8f6272ec:	e5963000 	ldr	r3, [r6]
		out_addr = (unsigned char *)(image_addr + imagesize_actual + page_size);
8f6272f0:	e085b00b 	add	r11, r5, r11
		out_avai_len = target_get_max_flash_size() - imagesize_actual - page_size;
8f6272f4:	e0855003 	add	r5, r5, r3
		out_addr = (unsigned char *)(image_addr + imagesize_actual + page_size);
8f6272f8:	e087b00b 	add	r11, r7, r11
		out_avai_len = target_get_max_flash_size() - imagesize_actual - page_size;
8f6272fc:	e0405005 	sub	r5, r0, r5
		dprintf(INFO, "decompressing kernel image: start\n");
8f627300:	e3080b68 	movw	r0, #35688	; 0x8b68
8f627304:	e3480f70 	movt	r0, #36720	; 0x8f70
		out_avai_len = target_get_max_flash_size() - imagesize_actual - page_size;
8f627308:	e58d5028 	str	r5, [r13, #40]	; 0x28
		dprintf(INFO, "decompressing kernel image: start\n");
8f62730c:	eb002d98 	bl	8f632974 <_dprintf>
		rc = decompress((unsigned char *)(image_addr + page_size),
8f627310:	e5960000 	ldr	r0, [r6]
8f627314:	e5941008 	ldr	r1, [r4, #8]
8f627318:	e28d3034 	add	r3, r13, #52	; 0x34
8f62731c:	e0870000 	add	r0, r7, r0
8f627320:	e58d3004 	str	r3, [r13, #4]
8f627324:	e1a0200b 	mov	r2, r11
8f627328:	e28d3038 	add	r3, r13, #56	; 0x38
8f62732c:	e58d3000 	str	r3, [r13]
8f627330:	e1a03005 	mov	r3, r5
8f627334:	eb004fe2 	bl	8f63b2c4 <decompress>
		if (rc)
8f627338:	e3500000 	cmp	r0, #0
8f62733c:	1a000162 	bne	8f6278cc <boot_linux_from_mmc+0xb94>
		dprintf(INFO, "decompressing kernel image: done\n");
8f627340:	e3080bb4 	movw	r0, #35764	; 0x8bb4
8f627344:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627348:	eb002d89 	bl	8f632974 <_dprintf>
		kernel_size = out_len;
8f62734c:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
		kernel_start_addr = out_addr;
8f627350:	e1a0500b 	mov	r5, r11
	update_ker_tags_rdisk_addr(hdr, kptr);
8f627354:	e1a01005 	mov	r1, r5
8f627358:	e3040200 	movw	r0, #16896	; 0x4200
8f62735c:	e3480f73 	movt	r0, #36723	; 0x8f73
8f627360:	e58d3018 	str	r3, [r13, #24]
8f627364:	ebfff826 	bl	8f625404 <update_ker_tags_rdisk_addr>
	hdr->kernel_addr = VA((addr_t)(hdr->kernel_addr));
8f627368:	e594000c 	ldr	r0, [r4, #12]
8f62736c:	ebff6908 	bl	8f601794 <platform_get_phys_to_virt_mapping>
8f627370:	e584000c 	str	r0, [r4, #12]
	hdr->ramdisk_addr = VA((addr_t)(hdr->ramdisk_addr));
8f627374:	e5940014 	ldr	r0, [r4, #20]
8f627378:	ebff6905 	bl	8f601794 <platform_get_phys_to_virt_mapping>
8f62737c:	e5840014 	str	r0, [r4, #20]
	hdr->tags_addr = VA((addr_t)(hdr->tags_addr));
8f627380:	e5940020 	ldr	r0, [r4, #32]
8f627384:	ebff6902 	bl	8f601794 <platform_get_phys_to_virt_mapping>
	kernel_size = ROUND_TO_PAGE(kernel_size,  page_mask);
8f627388:	e59d3018 	ldr	r3, [r13, #24]
8f62738c:	e5992000 	ldr	r2, [r9]
8f627390:	e0829003 	add	r9, r2, r3
8f627394:	e1c99002 	bic	r9, r9, r2
8f627398:	e1590003 	cmp	r9, r3
8f62739c:	33e09000 	mvncc	r9, #0
	hdr->tags_addr = VA((addr_t)(hdr->tags_addr));
8f6273a0:	e5840020 	str	r0, [r4, #32]
	if (check_aboot_addr_range_overlap(hdr->kernel_addr, kernel_size) ||
8f6273a4:	e594000c 	ldr	r0, [r4, #12]
	if ((UINT_MAX - start) < size)
8f6273a8:	e1e03000 	mvn	r3, r0
8f6273ac:	e1590003 	cmp	r9, r3
8f6273b0:	8a000008 	bhi	8f6273d8 <boot_linux_from_mmc+0x6a0>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f6273b4:	e30f3fff 	movw	r3, #65535	; 0xffff
8f6273b8:	e3483f5f 	movt	r3, #36703	; 0x8f5f
8f6273bc:	e1500003 	cmp	r0, r3
8f6273c0:	8a000009 	bhi	8f6273ec <boot_linux_from_mmc+0x6b4>
8f6273c4:	e0802009 	add	r2, r0, r9
8f6273c8:	e3a03000 	mov	r3, #0
8f6273cc:	e3483f60 	movt	r3, #36704	; 0x8f60
8f6273d0:	e1520003 	cmp	r2, r3
8f6273d4:	9a000006 	bls	8f6273f4 <boot_linux_from_mmc+0x6bc>
		dprintf(CRITICAL, "kernel/ramdisk addresses are not valid.\n");
8f6273d8:	e3080c5c 	movw	r0, #35932	; 0x8c5c
8f6273dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6273e0:	eb002d63 	bl	8f632974 <_dprintf>
		return -1;
8f6273e4:	e3e00000 	mvn	r0, #0
8f6273e8:	eaffff40 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
	else if (start >= (MEMBASE + MEMSIZE))
8f6273ec:	e3700217 	cmn	r0, #1879048193	; 0x70000001
8f6273f0:	9afffff8 	bls	8f6273d8 <boot_linux_from_mmc+0x6a0>
		check_ddr_addr_range_bound(hdr->kernel_addr, kernel_size) ||
8f6273f4:	e1a01009 	mov	r1, r9
8f6273f8:	ebfffe22 	bl	8f626c88 <check_ddr_addr_range_bound>
	if (check_aboot_addr_range_overlap(hdr->kernel_addr, kernel_size) ||
8f6273fc:	e3500000 	cmp	r0, #0
8f627400:	1afffff4 	bne	8f6273d8 <boot_linux_from_mmc+0x6a0>
		check_aboot_addr_range_overlap(hdr->ramdisk_addr, ramdisk_actual) ||
8f627404:	e5940014 	ldr	r0, [r4, #20]
	if ((UINT_MAX - start) < size)
8f627408:	e59d2010 	ldr	r2, [r13, #16]
8f62740c:	e1e03000 	mvn	r3, r0
8f627410:	e1520003 	cmp	r2, r3
8f627414:	8affffef 	bhi	8f6273d8 <boot_linux_from_mmc+0x6a0>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f627418:	e30f3fff 	movw	r3, #65535	; 0xffff
8f62741c:	e3483f5f 	movt	r3, #36703	; 0x8f5f
8f627420:	e1500003 	cmp	r0, r3
8f627424:	8a00003d 	bhi	8f627520 <boot_linux_from_mmc+0x7e8>
8f627428:	e0802002 	add	r2, r0, r2
8f62742c:	e3a03000 	mov	r3, #0
8f627430:	e3483f60 	movt	r3, #36704	; 0x8f60
8f627434:	e1520003 	cmp	r2, r3
8f627438:	8affffe6 	bhi	8f6273d8 <boot_linux_from_mmc+0x6a0>
		check_ddr_addr_range_bound(hdr->ramdisk_addr, ramdisk_actual))
8f62743c:	e59d1010 	ldr	r1, [r13, #16]
8f627440:	ebfffe10 	bl	8f626c88 <check_ddr_addr_range_bound>
		check_aboot_addr_range_overlap(hdr->ramdisk_addr, ramdisk_actual) ||
8f627444:	e3500000 	cmp	r0, #0
8f627448:	1affffe2 	bne	8f6273d8 <boot_linux_from_mmc+0x6a0>
	memmove((void*) hdr->kernel_addr, kernel_start_addr, kernel_size);
8f62744c:	e1a02009 	mov	r2, r9
8f627450:	e1a01005 	mov	r1, r5
8f627454:	e594000c 	ldr	r0, [r4, #12]
8f627458:	eb003356 	bl	8f6341b8 <memcpy>
	memmove((void*) hdr->ramdisk_addr, (char *)(image_addr + page_size + kernel_actual), hdr->ramdisk_size);
8f62745c:	e59d300c 	ldr	r3, [r13, #12]
8f627460:	e5961000 	ldr	r1, [r6]
8f627464:	e5942010 	ldr	r2, [r4, #16]
8f627468:	e0831001 	add	r1, r3, r1
8f62746c:	e5940014 	ldr	r0, [r4, #20]
8f627470:	e0871001 	add	r1, r7, r1
8f627474:	eb00334f 	bl	8f6341b8 <memcpy>
	if(dt_size) {
8f627478:	e59d301c 	ldr	r3, [r13, #28]
8f62747c:	e5933000 	ldr	r3, [r3]
8f627480:	e3530000 	cmp	r3, #0
8f627484:	1a0000b9 	bne	8f627770 <boot_linux_from_mmc+0xa38>
		if (check_aboot_addr_range_overlap(hdr->tags_addr, kernel_actual) ||
8f627488:	e5940020 	ldr	r0, [r4, #32]
	if ((UINT_MAX - start) < size)
8f62748c:	e59d200c 	ldr	r2, [r13, #12]
8f627490:	e1e03000 	mvn	r3, r0
8f627494:	e1520003 	cmp	r2, r3
8f627498:	8a00007f 	bhi	8f62769c <boot_linux_from_mmc+0x964>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f62749c:	e30f3fff 	movw	r3, #65535	; 0xffff
8f6274a0:	e3483f5f 	movt	r3, #36703	; 0x8f5f
8f6274a4:	e1500003 	cmp	r0, r3
8f6274a8:	9a000075 	bls	8f627684 <boot_linux_from_mmc+0x94c>
	else if (start >= (MEMBASE + MEMSIZE))
8f6274ac:	e3700217 	cmn	r0, #1879048193	; 0x70000001
8f6274b0:	9a000079 	bls	8f62769c <boot_linux_from_mmc+0x964>
			check_ddr_addr_range_bound(hdr->tags_addr, kernel_actual))
8f6274b4:	e59d100c 	ldr	r1, [r13, #12]
8f6274b8:	ebfffdf2 	bl	8f626c88 <check_ddr_addr_range_bound>
		if (check_aboot_addr_range_overlap(hdr->tags_addr, kernel_actual) ||
8f6274bc:	e3500000 	cmp	r0, #0
8f6274c0:	1a000075 	bne	8f62769c <boot_linux_from_mmc+0x964>
				(void*)(image_addr + page_size +
8f6274c4:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f6274c8:	e5960000 	ldr	r0, [r6]
		dtb = dev_tree_appended(
8f6274cc:	e5941008 	ldr	r1, [r4, #8]
				(void*)(image_addr + page_size +
8f6274d0:	e0830000 	add	r0, r3, r0
		dtb = dev_tree_appended(
8f6274d4:	e59d2038 	ldr	r2, [r13, #56]	; 0x38
8f6274d8:	e5943020 	ldr	r3, [r4, #32]
8f6274dc:	e0870000 	add	r0, r7, r0
8f6274e0:	ebffc21a 	bl	8f617d50 <dev_tree_appended>
		if (!dtb) {
8f6274e4:	e3500000 	cmp	r0, #0
8f6274e8:	0a000171 	beq	8f627ab4 <boot_linux_from_mmc+0xd7c>
	if (boot_into_recovery && !device.is_unlocked && !device.is_tampered)
8f6274ec:	e5983000 	ldr	r3, [r8]
8f6274f0:	e3530000 	cmp	r3, #0
	boot_img_hdr *hdr = (void*) buf;
8f6274f4:	03044200 	movweq	r4, #16896	; 0x4200
8f6274f8:	03484f73 	movteq	r4, #36723	; 0x8f73
	if (boot_into_recovery && !device.is_unlocked && !device.is_tampered)
8f6274fc:	0affff1b 	beq	8f627170 <boot_linux_from_mmc+0x438>
8f627500:	e1ca21d0 	ldrd	r2, [r10, #16]
	boot_img_hdr *hdr = (void*) buf;
8f627504:	e3044200 	movw	r4, #16896	; 0x4200
	if (boot_into_recovery && !device.is_unlocked && !device.is_tampered)
8f627508:	e1923003 	orrs	r3, r2, r3
	boot_img_hdr *hdr = (void*) buf;
8f62750c:	13484f73 	movtne	r4, #36723	; 0x8f73
	if (boot_into_recovery && !device.is_unlocked && !device.is_tampered)
8f627510:	1affff16 	bne	8f627170 <boot_linux_from_mmc+0x438>
		target_load_ssd_keystore();
8f627514:	ebff66ca 	bl	8f601044 <target_load_ssd_keystore>
	boot_img_hdr *hdr = (void*) buf;
8f627518:	e3484f73 	movt	r4, #36723	; 0x8f73
8f62751c:	eaffff13 	b	8f627170 <boot_linux_from_mmc+0x438>
	else if (start >= (MEMBASE + MEMSIZE))
8f627520:	e3700217 	cmn	r0, #1879048193	; 0x70000001
8f627524:	8affffc4 	bhi	8f62743c <boot_linux_from_mmc+0x704>
8f627528:	eaffffaa 	b	8f6273d8 <boot_linux_from_mmc+0x6a0>
	kernel_actual  = ROUND_TO_PAGE(hdr->kernel_size,  page_mask);
8f62752c:	e3009680 	movw	r9, #1664	; 0x680
8f627530:	e3489f74 	movt	r9, #36724	; 0x8f74
8f627534:	e5992000 	ldr	r2, [r9]
8f627538:	eafffe94 	b	8f626f90 <boot_linux_from_mmc+0x258>
	image_addr = (unsigned char *)target_get_scratch_address();
8f62753c:	e58d3014 	str	r3, [r13, #20]
8f627540:	ebff6783 	bl	8f601354 <target_get_scratch_address>
	memcpy(image_addr, (void *)buf, page_size);
8f627544:	e5962000 	ldr	r2, [r6]
8f627548:	e3041200 	movw	r1, #16896	; 0x4200
8f62754c:	e3481f73 	movt	r1, #36723	; 0x8f73
	image_addr = (unsigned char *)target_get_scratch_address();
8f627550:	e1a07000 	mov	r7, r0
	memcpy(image_addr, (void *)buf, page_size);
8f627554:	eb003317 	bl	8f6341b8 <memcpy>
	dt_size = hdr->dt_size;
8f627558:	e5942028 	ldr	r2, [r4, #40]	; 0x28
8f62755c:	e3053200 	movw	r3, #20992	; 0x5200
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f627560:	e5991000 	ldr	r1, [r9]
	dt_size = hdr->dt_size;
8f627564:	e3483f73 	movt	r3, #36723	; 0x8f73
8f627568:	e58d301c 	str	r3, [r13, #28]
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f62756c:	e0810002 	add	r0, r1, r2
	dt_size = hdr->dt_size;
8f627570:	e5832000 	str	r2, [r3]
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f627574:	e1c01001 	bic	r1, r0, r1
8f627578:	e59d3014 	ldr	r3, [r13, #20]
8f62757c:	e1510002 	cmp	r1, r2
        hdr->cmdline[BOOT_ARGS_SIZE-1] = 0;
8f627580:	e3a02000 	mov	r2, #0
8f627584:	e5c4223f 	strb	r2, [r4, #575]	; 0x23f
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f627588:	23e0c000 	mvncs	r12, #0
	second_actual  = ROUND_TO_PAGE(hdr->second_size, page_mask);
8f62758c:	258dc014 	strcs	r12, [r13, #20]
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f627590:	3a000107 	bcc	8f6279b4 <boot_linux_from_mmc+0xc7c>
	if (UINT_MAX < ((uint64_t)kernel_actual + (uint64_t)ramdisk_actual+ (uint64_t)second_actual + (uint64_t)dt_actual + page_size)) {
8f627594:	e1a00001 	mov	r0, r1
8f627598:	eafffead 	b	8f627054 <boot_linux_from_mmc+0x31c>
		dprintf(INFO, "Uncpmpressed kernel in use\n");
8f62759c:	e3080bd8 	movw	r0, #35800	; 0x8bd8
8f6275a0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6275a4:	eb002cf2 	bl	8f632974 <_dprintf>
		if (!strncmp((char*)(image_addr + page_size),
8f6275a8:	e5960000 	ldr	r0, [r6]
8f6275ac:	e3a02010 	mov	r2, #16
8f6275b0:	e3081bf4 	movw	r1, #35828	; 0x8bf4
8f6275b4:	e0870000 	add	r0, r7, r0
8f6275b8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6275bc:	eb0034aa 	bl	8f63486c <strncmp>
8f6275c0:	e3500000 	cmp	r0, #0
8f6275c4:	1a00004c 	bne	8f6276fc <boot_linux_from_mmc+0x9c4>
	unsigned int out_avai_len = 0;
8f6275c8:	e58d0028 	str	r0, [r13, #40]	; 0x28
8f6275cc:	e1a0b000 	mov	r11, r0
			dprintf(INFO, "Patched kernel detected\n");
8f6275d0:	e3080c08 	movw	r0, #35848	; 0x8c08
8f6275d4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6275d8:	eb002ce5 	bl	8f632974 <_dprintf>
			kptr = (struct kernel64_hdr *)(image_addr + page_size +
8f6275dc:	e5965000 	ldr	r5, [r6]
			patched_kernel_hdr_size = PATCHED_KERNEL_HEADER_SIZE;
8f6275e0:	e3a02014 	mov	r2, #20
8f6275e4:	e58d2024 	str	r2, [r13, #36]	; 0x24
			dtb_offset = *((uint32_t*)((unsigned char*)
8f6275e8:	e0872005 	add	r2, r7, r5
			kptr = (struct kernel64_hdr *)(image_addr + page_size +
8f6275ec:	e2855014 	add	r5, r5, #20
			kernel_size = hdr->kernel_size;
8f6275f0:	e5943008 	ldr	r3, [r4, #8]
			kptr = (struct kernel64_hdr *)(image_addr + page_size +
8f6275f4:	e0875005 	add	r5, r7, r5
			dtb_offset = *((uint32_t*)((unsigned char*)
8f6275f8:	e5922010 	ldr	r2, [r2, #16]
8f6275fc:	e58d2038 	str	r2, [r13, #56]	; 0x38
			patched_kernel_hdr_size = PATCHED_KERNEL_HEADER_SIZE;
8f627600:	eaffff53 	b	8f627354 <boot_linux_from_mmc+0x61c>
		dprintf(INFO, "partition /bootselect doesn't exist\n");
8f627604:	e30807d4 	movw	r0, #34772	; 0x87d4
8f627608:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62760c:	eb002cd8 	bl	8f632974 <_dprintf>
		return ret;
8f627610:	eafffe0c 	b	8f626e48 <boot_linux_from_mmc+0x110>
		(!partition_multislot_is_supported()))
8f627614:	ebff783c 	bl	8f60570c <partition_multislot_is_supported>
	if (boot_into_recovery &&
8f627618:	e3500000 	cmp	r0, #0
8f62761c:	1afffe23 	bne	8f626eb0 <boot_linux_from_mmc+0x178>
			ptn_name = "recovery";
8f627620:	e3005d34 	movw	r5, #3380	; 0xd34
8f627624:	e3485f70 	movt	r5, #36720	; 0x8f70
8f627628:	eafffe22 	b	8f626eb8 <boot_linux_from_mmc+0x180>
		current_active_slot = partition_find_active_slot();
8f62762c:	ebff7666 	bl	8f604fcc <partition_find_active_slot>
		dprintf(INFO, "Loading boot image (%d) active_slot(%s): start\n",
8f627630:	e30132e0 	movw	r3, #4832	; 0x12e0
8f627634:	e3483f71 	movt	r3, #36721	; 0x8f71
8f627638:	e1a01005 	mov	r1, r5
8f62763c:	e7932100 	ldr	r2, [r3, r0, lsl #2]
		current_active_slot = partition_find_active_slot();
8f627640:	e1a0a000 	mov	r10, r0
		dprintf(INFO, "Loading boot image (%d) active_slot(%s): start\n",
8f627644:	e30809d4 	movw	r0, #35284	; 0x89d4
8f627648:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62764c:	eb002cc8 	bl	8f632974 <_dprintf>
8f627650:	eafffee6 	b	8f6271f0 <boot_linux_from_mmc+0x4b8>
		dprintf(INFO, "Loading boot image (%d) active_slot(%s): done\n",
8f627654:	e30132e0 	movw	r3, #4832	; 0x12e0
8f627658:	e3483f71 	movt	r3, #36721	; 0x8f71
8f62765c:	e1a01005 	mov	r1, r5
8f627660:	e3080a74 	movw	r0, #35444	; 0x8a74
8f627664:	e793210a 	ldr	r2, [r3, r10, lsl #2]
8f627668:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62766c:	eb002cc0 	bl	8f632974 <_dprintf>
8f627670:	eafffefd 	b	8f62726c <boot_linux_from_mmc+0x534>
		dprintf(INFO, "Unable to locate /bootselect partition\n");
8f627674:	e30807ac 	movw	r0, #34732	; 0x87ac
8f627678:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62767c:	eb002cbc 	bl	8f632974 <_dprintf>
		return ret;
8f627680:	eafffdf0 	b	8f626e48 <boot_linux_from_mmc+0x110>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f627684:	e59d300c 	ldr	r3, [r13, #12]
8f627688:	e0802003 	add	r2, r0, r3
8f62768c:	e3a03000 	mov	r3, #0
8f627690:	e3483f60 	movt	r3, #36704	; 0x8f60
8f627694:	e1520003 	cmp	r2, r3
8f627698:	9affff85 	bls	8f6274b4 <boot_linux_from_mmc+0x77c>
			dprintf(CRITICAL, "Device tree addresses are not valid.\n");
8f62769c:	e3080db0 	movw	r0, #36272	; 0x8db0
8f6276a0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6276a4:	eb002cb2 	bl	8f632974 <_dprintf>
			return -1;
8f6276a8:	e3e00000 	mvn	r0, #0
8f6276ac:	eafffe8f 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
		if (check_aboot_addr_range_overlap((uintptr_t)image_addr + offset, page_size))
8f6276b0:	e5963000 	ldr	r3, [r6]
8f6276b4:	e0872005 	add	r2, r7, r5
	if ((UINT_MAX - start) < size)
8f6276b8:	e1e01002 	mvn	r1, r2
8f6276bc:	e1530001 	cmp	r3, r1
8f6276c0:	8a000008 	bhi	8f6276e8 <boot_linux_from_mmc+0x9b0>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f6276c4:	e30f1fff 	movw	r1, #65535	; 0xffff
8f6276c8:	e3481f5f 	movt	r1, #36703	; 0x8f5f
8f6276cc:	e1520001 	cmp	r2, r1
8f6276d0:	8a000070 	bhi	8f627898 <boot_linux_from_mmc+0xb60>
8f6276d4:	e0820003 	add	r0, r2, r3
8f6276d8:	e3a01000 	mov	r1, #0
8f6276dc:	e3481f60 	movt	r1, #36704	; 0x8f60
8f6276e0:	e1500001 	cmp	r0, r1
8f6276e4:	9a00006d 	bls	8f6278a0 <boot_linux_from_mmc+0xb68>
			dprintf(CRITICAL, "Signature read buffer address overlaps with aboot addresses.\n");
8f6276e8:	e3080afc 	movw	r0, #35580	; 0x8afc
8f6276ec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6276f0:	eb002c9f 	bl	8f632974 <_dprintf>
			return -1;
8f6276f4:	e3e00000 	mvn	r0, #0
8f6276f8:	eafffe7c 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
			dprintf(INFO, "Kernel image not patched..Unable to locate dt offset\n");
8f6276fc:	e3080c24 	movw	r0, #35876	; 0x8c24
8f627700:	e3480f70 	movt	r0, #36720	; 0x8f70
	unsigned int out_avai_len = 0;
8f627704:	e58db028 	str	r11, [r13, #40]	; 0x28
			dprintf(INFO, "Kernel image not patched..Unable to locate dt offset\n");
8f627708:	eb002c99 	bl	8f632974 <_dprintf>
			kptr = (struct kernel64_hdr *)(image_addr + page_size);
8f62770c:	e5965000 	ldr	r5, [r6]
			kernel_size = hdr->kernel_size;
8f627710:	e5943008 	ldr	r3, [r4, #8]
			kptr = (struct kernel64_hdr *)(image_addr + page_size);
8f627714:	e0875005 	add	r5, r7, r5
			kernel_size = hdr->kernel_size;
8f627718:	eaffff0d 	b	8f627354 <boot_linux_from_mmc+0x61c>
		dprintf(INFO, "mmc read failure /bootselect %d\n", page_size);
8f62771c:	e5961000 	ldr	r1, [r6]
8f627720:	e30807fc 	movw	r0, #34812	; 0x87fc
8f627724:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627728:	eb002c91 	bl	8f632974 <_dprintf>
		free(buf);
8f62772c:	e1a00004 	mov	r0, r4
8f627730:	eb003275 	bl	8f63410c <free>
		return ret;
8f627734:	eafffdc3 	b	8f626e48 <boot_linux_from_mmc+0x110>
	ASSERT(buf);
8f627738:	e59d0020 	ldr	r0, [r13, #32]
8f62773c:	e3043214 	movw	r3, #16916	; 0x4214
8f627740:	e30824b0 	movw	r2, #33968	; 0x84b0
8f627744:	e3483f70 	movt	r3, #36720	; 0x8f70
8f627748:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62774c:	e58d3000 	str	r3, [r13]
8f627750:	e3001130 	movw	r1, #304	; 0x130
8f627754:	e300360c 	movw	r3, #1548	; 0x60c
8f627758:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62775c:	eb002cd6 	bl	8f632abc <_panic>
8f627760:	eafffd98 	b	8f626dc8 <boot_linux_from_mmc+0x90>
	free(buf);
8f627764:	e1a00004 	mov	r0, r4
8f627768:	eb003267 	bl	8f63410c <free>
	return ret;
8f62776c:	eafffdb5 	b	8f626e48 <boot_linux_from_mmc+0x110>
		dt_table_offset = ((uint32_t)image_addr + page_size + kernel_actual + ramdisk_actual + second_actual);
8f627770:	e59d300c 	ldr	r3, [r13, #12]
		if (dev_tree_validate(table, hdr->page_size, &dt_hdr_size) != 0) {
8f627774:	e28d203c 	add	r2, r13, #60	; 0x3c
		dt_table_offset = ((uint32_t)image_addr + page_size + kernel_actual + ramdisk_actual + second_actual);
8f627778:	e5960000 	ldr	r0, [r6]
		if (dev_tree_validate(table, hdr->page_size, &dt_hdr_size) != 0) {
8f62777c:	e5941024 	ldr	r1, [r4, #36]	; 0x24
		dt_table_offset = ((uint32_t)image_addr + page_size + kernel_actual + ramdisk_actual + second_actual);
8f627780:	e0830000 	add	r0, r3, r0
8f627784:	e59d3010 	ldr	r3, [r13, #16]
8f627788:	e0800003 	add	r0, r0, r3
8f62778c:	e59d3014 	ldr	r3, [r13, #20]
8f627790:	e0877000 	add	r7, r7, r0
8f627794:	e0877003 	add	r7, r7, r3
		if (dev_tree_validate(table, hdr->page_size, &dt_hdr_size) != 0) {
8f627798:	e1a00007 	mov	r0, r7
8f62779c:	ebffc526 	bl	8f618c3c <dev_tree_validate>
8f6277a0:	e3500000 	cmp	r0, #0
8f6277a4:	1a0000b8 	bne	8f627a8c <boot_linux_from_mmc+0xd54>
		if (dt_hdr_size > ROUND_TO_PAGE(dt_size,hdr->page_size)) {
8f6277a8:	e59d301c 	ldr	r3, [r13, #28]
8f6277ac:	e5941024 	ldr	r1, [r4, #36]	; 0x24
8f6277b0:	e5932000 	ldr	r2, [r3]
8f6277b4:	e0813002 	add	r3, r1, r2
8f6277b8:	e1c33001 	bic	r3, r3, r1
8f6277bc:	e1520003 	cmp	r2, r3
8f6277c0:	8a000002 	bhi	8f6277d0 <boot_linux_from_mmc+0xa98>
8f6277c4:	e59d203c 	ldr	r2, [r13, #60]	; 0x3c
8f6277c8:	e1530002 	cmp	r3, r2
8f6277cc:	3a0000a4 	bcc	8f627a64 <boot_linux_from_mmc+0xd2c>
		if(dev_tree_get_entry_info(table, &dt_entry) != 0){
8f6277d0:	e28d1044 	add	r1, r13, #68	; 0x44
8f6277d4:	e1a00007 	mov	r0, r7
8f6277d8:	ebffc54b 	bl	8f618d0c <dev_tree_get_entry_info>
8f6277dc:	e2505000 	subs	r5, r0, #0
8f6277e0:	1a0000ae 	bne	8f627aa0 <boot_linux_from_mmc+0xd68>
		if(dt_entry.offset > (UINT_MAX - dt_entry.size)) {
8f6277e4:	e1cd06d4 	ldrd	r0, [r13, #100]	; 0x64
8f6277e8:	e1e03001 	mvn	r3, r1
8f6277ec:	e1500003 	cmp	r0, r3
8f6277f0:	8a000096 	bhi	8f627a50 <boot_linux_from_mmc+0xd18>
		if ((dt_entry.offset + dt_entry.size) > dt_size) {
8f6277f4:	e59d301c 	ldr	r3, [r13, #28]
8f6277f8:	e0802001 	add	r2, r0, r1
8f6277fc:	e5933000 	ldr	r3, [r3]
8f627800:	e1520003 	cmp	r2, r3
8f627804:	8a000091 	bhi	8f627a50 <boot_linux_from_mmc+0xd18>
		if (is_gzip_package((unsigned char *)dt_table_offset + dt_entry.offset, dt_entry.size))
8f627808:	e0800007 	add	r0, r0, r7
8f62780c:	eb004f1e 	bl	8f63b48c <is_gzip_package>
8f627810:	e3500000 	cmp	r0, #0
8f627814:	1a00003f 	bne	8f627918 <boot_linux_from_mmc+0xbe0>
			best_match_dt_addr = (unsigned char *)dt_table_offset + dt_entry.offset;
8f627818:	e59db064 	ldr	r11, [r13, #100]	; 0x64
			dtb_size = dt_entry.size;
8f62781c:	e59d1068 	ldr	r1, [r13, #104]	; 0x68
			best_match_dt_addr = (unsigned char *)dt_table_offset + dt_entry.offset;
8f627820:	e087b00b 	add	r11, r7, r11
			dtb_size = dt_entry.size;
8f627824:	e58d1030 	str	r1, [r13, #48]	; 0x30
		if (check_aboot_addr_range_overlap(hdr->tags_addr, dtb_size) ||
8f627828:	e5940020 	ldr	r0, [r4, #32]
	if ((UINT_MAX - start) < size)
8f62782c:	e1e03000 	mvn	r3, r0
8f627830:	e1510003 	cmp	r1, r3
8f627834:	8a000008 	bhi	8f62785c <boot_linux_from_mmc+0xb24>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f627838:	e30f3fff 	movw	r3, #65535	; 0xffff
8f62783c:	e3483f5f 	movt	r3, #36703	; 0x8f5f
8f627840:	e1500003 	cmp	r0, r3
8f627844:	8a000009 	bhi	8f627870 <boot_linux_from_mmc+0xb38>
8f627848:	e0812000 	add	r2, r1, r0
8f62784c:	e3a03000 	mov	r3, #0
8f627850:	e3483f60 	movt	r3, #36704	; 0x8f60
8f627854:	e1520003 	cmp	r2, r3
8f627858:	9a000006 	bls	8f627878 <boot_linux_from_mmc+0xb40>
			dprintf(CRITICAL, "Device tree addresses are not valid\n");
8f62785c:	e3080d88 	movw	r0, #36232	; 0x8d88
8f627860:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627864:	eb002c42 	bl	8f632974 <_dprintf>
			return -1;
8f627868:	e3e00000 	mvn	r0, #0
8f62786c:	eafffe1f 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
	else if (start >= (MEMBASE + MEMSIZE))
8f627870:	e3700217 	cmn	r0, #1879048193	; 0x70000001
8f627874:	9afffff8 	bls	8f62785c <boot_linux_from_mmc+0xb24>
			check_ddr_addr_range_bound(hdr->tags_addr, dtb_size))
8f627878:	ebfffd02 	bl	8f626c88 <check_ddr_addr_range_bound>
		if (check_aboot_addr_range_overlap(hdr->tags_addr, dtb_size) ||
8f62787c:	e3500000 	cmp	r0, #0
8f627880:	1afffff5 	bne	8f62785c <boot_linux_from_mmc+0xb24>
		memmove((void *)hdr->tags_addr, (char *)best_match_dt_addr, dtb_size);
8f627884:	e59d2030 	ldr	r2, [r13, #48]	; 0x30
8f627888:	e1a0100b 	mov	r1, r11
8f62788c:	e5940020 	ldr	r0, [r4, #32]
8f627890:	eb003248 	bl	8f6341b8 <memcpy>
8f627894:	eaffff14 	b	8f6274ec <boot_linux_from_mmc+0x7b4>
	else if (start >= (MEMBASE + MEMSIZE))
8f627898:	e3720217 	cmn	r2, #1879048193	; 0x70000001
8f62789c:	9affff91 	bls	8f6276e8 <boot_linux_from_mmc+0x9b0>
		if(mmc_read(ptn + offset, (void *)(image_addr + offset), page_size))
8f6278a0:	e59d1018 	ldr	r1, [r13, #24]
8f6278a4:	e095000b 	adds	r0, r5, r11
8f6278a8:	e2a11000 	adc	r1, r1, #0
8f6278ac:	ebff94f5 	bl	8f60cc88 <mmc_read>
8f6278b0:	e3500000 	cmp	r0, #0
8f6278b4:	0afffe84 	beq	8f6272cc <boot_linux_from_mmc+0x594>
			dprintf(CRITICAL, "ERROR: Cannot read boot image signature\n");
8f6278b8:	e3080b3c 	movw	r0, #35644	; 0x8b3c
8f6278bc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6278c0:	eb002c2b 	bl	8f632974 <_dprintf>
			return -1;
8f6278c4:	e3e00000 	mvn	r0, #0
8f6278c8:	eafffe08 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
			dprintf(CRITICAL, "decompressing kernel image failed!!!\n");
8f6278cc:	e3080b8c 	movw	r0, #35724	; 0x8b8c
8f6278d0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6278d4:	eb002c26 	bl	8f632974 <_dprintf>
			ASSERT(0);
8f6278d8:	e59d0020 	ldr	r0, [r13, #32]
8f6278dc:	e3073f64 	movw	r3, #32612	; 0x7f64
8f6278e0:	e30824b0 	movw	r2, #33968	; 0x84b0
8f6278e4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f6278e8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6278ec:	e58d3000 	str	r3, [r13]
8f6278f0:	e3001130 	movw	r1, #304	; 0x130
8f6278f4:	e30037f3 	movw	r3, #2035	; 0x7f3
8f6278f8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6278fc:	eb002c6e 	bl	8f632abc <_panic>
8f627900:	eafffe8e 	b	8f627340 <boot_linux_from_mmc+0x608>
		dprintf(CRITICAL, "ERROR: Invalid boot image header\n");
8f627904:	e30808e8 	movw	r0, #35048	; 0x88e8
8f627908:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62790c:	eb002c18 	bl	8f632974 <_dprintf>
                return ERR_INVALID_BOOT_MAGIC;
8f627910:	e3a00004 	mov	r0, #4
8f627914:	eafffdf5 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
			out_avai_len -= out_len;
8f627918:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
			dprintf(INFO, "decompressing dtb: start\n");
8f62791c:	e3080d30 	movw	r0, #36144	; 0x8d30
			unsigned int compressed_size = 0;
8f627920:	e58d5040 	str	r5, [r13, #64]	; 0x40
			dprintf(INFO, "decompressing dtb: start\n");
8f627924:	e3480f70 	movt	r0, #36720	; 0x8f70
			out_addr += out_len;
8f627928:	e59d5034 	ldr	r5, [r13, #52]	; 0x34
8f62792c:	e08bb005 	add	r11, r11, r5
			out_avai_len -= out_len;
8f627930:	e0435005 	sub	r5, r3, r5
			dprintf(INFO, "decompressing dtb: start\n");
8f627934:	eb002c0e 	bl	8f632974 <_dprintf>
			rc = decompress((unsigned char *)dt_table_offset + dt_entry.offset,
8f627938:	e59d0064 	ldr	r0, [r13, #100]	; 0x64
8f62793c:	e28d2030 	add	r2, r13, #48	; 0x30
8f627940:	e59d1068 	ldr	r1, [r13, #104]	; 0x68
8f627944:	e58d2004 	str	r2, [r13, #4]
8f627948:	e0870000 	add	r0, r7, r0
8f62794c:	e28d2040 	add	r2, r13, #64	; 0x40
8f627950:	e1a03005 	mov	r3, r5
8f627954:	e58d2000 	str	r2, [r13]
8f627958:	e1a0200b 	mov	r2, r11
8f62795c:	eb004e58 	bl	8f63b2c4 <decompress>
			if (rc)
8f627960:	e3500000 	cmp	r0, #0
8f627964:	1a000004 	bne	8f62797c <boot_linux_from_mmc+0xc44>
			dprintf(INFO, "decompressing dtb: done\n");
8f627968:	e3080d6c 	movw	r0, #36204	; 0x8d6c
8f62796c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627970:	eb002bff 	bl	8f632974 <_dprintf>
		if (check_aboot_addr_range_overlap(hdr->tags_addr, dtb_size) ||
8f627974:	e59d1030 	ldr	r1, [r13, #48]	; 0x30
8f627978:	eaffffaa 	b	8f627828 <boot_linux_from_mmc+0xaf0>
				dprintf(CRITICAL, "decompressing dtb failed!!!\n");
8f62797c:	e3080d4c 	movw	r0, #36172	; 0x8d4c
8f627980:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627984:	eb002bfa 	bl	8f632974 <_dprintf>
				ASSERT(0);
8f627988:	e59d0020 	ldr	r0, [r13, #32]
8f62798c:	e3073f64 	movw	r3, #32612	; 0x7f64
8f627990:	e30824b0 	movw	r2, #33968	; 0x84b0
8f627994:	e3483f70 	movt	r3, #36720	; 0x8f70
8f627998:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62799c:	e58d3000 	str	r3, [r13]
8f6279a0:	e3001130 	movw	r1, #304	; 0x130
8f6279a4:	e3003867 	movw	r3, #2151	; 0x867
8f6279a8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6279ac:	eb002c42 	bl	8f632abc <_panic>
8f6279b0:	eaffffec 	b	8f627968 <boot_linux_from_mmc+0xc30>
		dprintf(CRITICAL, "Integer overflow detected in bootimage header fields at %u in %s\n",__LINE__,__FILE__);
8f6279b4:	e30824b0 	movw	r2, #33968	; 0x84b0
8f6279b8:	e30016c2 	movw	r1, #1730	; 0x6c2
8f6279bc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6279c0:	e3080928 	movw	r0, #35112	; 0x8928
8f6279c4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6279c8:	eb002be9 	bl	8f632974 <_dprintf>
		return -1;
8f6279cc:	e3e00000 	mvn	r0, #0
8f6279d0:	eafffdc6 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
				dprintf(CRITICAL,"failed to get ffbm cookie");
8f6279d4:	e3080860 	movw	r0, #34912	; 0x8860
8f6279d8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6279dc:	eb002be4 	bl	8f632974 <_dprintf>
8f6279e0:	eafffd27 	b	8f626e84 <boot_linux_from_mmc+0x14c>
		dprintf(CRITICAL, "ERROR: No %s partition found\n", ptn_name);
8f6279e4:	e1a01005 	mov	r1, r5
8f6279e8:	e30808a0 	movw	r0, #34976	; 0x88a0
8f6279ec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6279f0:	eb002bdf 	bl	8f632974 <_dprintf>
		return -1;
8f6279f4:	e3e00000 	mvn	r0, #0
8f6279f8:	eafffdbc 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
		dprintf(CRITICAL, "booimage  size is greater than DDR can hold\n");
8f6279fc:	e3080a24 	movw	r0, #35364	; 0x8a24
8f627a00:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627a04:	eb002bda 	bl	8f632974 <_dprintf>
		return -1;
8f627a08:	e3e00000 	mvn	r0, #0
8f627a0c:	eafffdb7 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
		dprintf(CRITICAL, "ERROR: Cannot read boot image\n");
8f627a10:	e3080a54 	movw	r0, #35412	; 0x8a54
8f627a14:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627a18:	eb002bd5 	bl	8f632974 <_dprintf>
		return -1;
8f627a1c:	e3e00000 	mvn	r0, #0
8f627a20:	eafffdb2 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
		dprintf(CRITICAL, "ERROR: Cannot read boot image header\n");
8f627a24:	e30808c0 	movw	r0, #35008	; 0x88c0
8f627a28:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627a2c:	eb002bd0 	bl	8f632974 <_dprintf>
                return -1;
8f627a30:	e3e00000 	mvn	r0, #0
8f627a34:	eafffdad 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
		dprintf(CRITICAL, "Image size is greater than partition size.\n");
8f627a38:	e308096c 	movw	r0, #35180	; 0x896c
8f627a3c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627a40:	eb002bcb 	bl	8f632974 <_dprintf>
		return -1;
8f627a44:	e3e03000 	mvn	r3, #0
8f627a48:	e1a00003 	mov	r0, r3
8f627a4c:	eafffda7 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
			dprintf(CRITICAL, "ERROR: Device tree contents are Invalid\n");
8f627a50:	e3080d04 	movw	r0, #36100	; 0x8d04
8f627a54:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627a58:	eb002bc5 	bl	8f632974 <_dprintf>
			return -1;
8f627a5c:	e3e00000 	mvn	r0, #0
8f627a60:	eafffda2 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
			dprintf(CRITICAL, "ERROR: Invalid Device Tree size \n");
8f627a64:	e3080cb4 	movw	r0, #36020	; 0x8cb4
8f627a68:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627a6c:	eb002bc0 	bl	8f632974 <_dprintf>
			return -1;
8f627a70:	e3e00000 	mvn	r0, #0
8f627a74:	eafffd9d 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
			dprintf(CRITICAL, "ERROR: Invalid page size\n");
8f627a78:	e308090c 	movw	r0, #35084	; 0x890c
8f627a7c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627a80:	eb002bbb 	bl	8f632974 <_dprintf>
			return -1;
8f627a84:	e3e00000 	mvn	r0, #0
8f627a88:	eafffd98 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
			dprintf(CRITICAL, "ERROR: Cannot validate Device Tree Table \n");
8f627a8c:	e3080c88 	movw	r0, #35976	; 0x8c88
8f627a90:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627a94:	eb002bb6 	bl	8f632974 <_dprintf>
			return -1;
8f627a98:	e3e00000 	mvn	r0, #0
8f627a9c:	eafffd93 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
			dprintf(CRITICAL, "ERROR: Getting device tree address failed\n");
8f627aa0:	e3080cd8 	movw	r0, #36056	; 0x8cd8
8f627aa4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627aa8:	eb002bb1 	bl	8f632974 <_dprintf>
			return -1;
8f627aac:	e3e00000 	mvn	r0, #0
8f627ab0:	eafffd8e 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
			dprintf(CRITICAL, "ERROR: Appended Device Tree Blob not found\n");
8f627ab4:	e3080dd8 	movw	r0, #36312	; 0x8dd8
8f627ab8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627abc:	eb002bac 	bl	8f632974 <_dprintf>
			return -1;
8f627ac0:	e3e00000 	mvn	r0, #0
8f627ac4:	eafffd89 	b	8f6270f0 <boot_linux_from_mmc+0x3b8>
}
8f627ac8:	eb002c3c 	bl	8f632bc0 <__stack_chk_fail>
8f627acc:	8f74221c 	.word	0x8f74221c

8f627ad0 <boot_linux_from_flash>:
{
8f627ad0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f627ad4:	e24dd054 	sub	r13, r13, #84	; 0x54
8f627ad8:	e59f280c 	ldr	r2, [pc, #2060]	; 8f6282ec <boot_linux_from_flash+0x81c>
	uint32_t dt_hdr_size = 0;
8f627adc:	e3a03000 	mov	r3, #0
8f627ae0:	e58de008 	str	r14, [r13, #8]
{
8f627ae4:	e5922000 	ldr	r2, [r2]
8f627ae8:	e58d204c 	str	r2, [r13, #76]	; 0x4c
8f627aec:	e3a02000 	mov	r2, #0
	uint32_t dt_hdr_size = 0;
8f627af0:	e58d3020 	str	r3, [r13, #32]
	if (target_is_emmc_boot()) {
8f627af4:	ebffe7e1 	bl	8f621a80 <target_is_emmc_boot>
8f627af8:	e3500000 	cmp	r0, #0
8f627afc:	0a00001e 	beq	8f627b7c <boot_linux_from_flash+0xac>
		if (memcmp(hdr->magic, BOOT_MAGIC, BOOT_MAGIC_SIZE)) {
8f627b00:	e3a02008 	mov	r2, #8
8f627b04:	e308187c 	movw	r1, #34940	; 0x887c
8f627b08:	e3a00a0f 	mov	r0, #61440	; 0xf000
8f627b0c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f627b10:	e3480f6f 	movt	r0, #36719	; 0x8f6f
8f627b14:	eb00322f 	bl	8f6343d8 <memcmp>
8f627b18:	e3500000 	cmp	r0, #0
		hdr = (boot_img_hdr *)EMMC_BOOT_IMG_HEADER_ADDR;
8f627b1c:	03a04a0f 	moveq	r4, #61440	; 0xf000
8f627b20:	03484f6f 	movteq	r4, #36719	; 0x8f6f
		if (memcmp(hdr->magic, BOOT_MAGIC, BOOT_MAGIC_SIZE)) {
8f627b24:	1a0001a3 	bne	8f6281b8 <boot_linux_from_flash+0x6e8>
	boot_linux((void *)hdr->kernel_addr, (void *)hdr->tags_addr,
8f627b28:	e594500c 	ldr	r5, [r4, #12]
8f627b2c:	e5946020 	ldr	r6, [r4, #32]
8f627b30:	ebff6409 	bl	8f600b5c <board_machtype>
8f627b34:	e5942010 	ldr	r2, [r4, #16]
8f627b38:	e1a01006 	mov	r1, r6
8f627b3c:	e58d2004 	str	r2, [r13, #4]
8f627b40:	e2842040 	add	r2, r4, #64	; 0x40
8f627b44:	e594c014 	ldr	r12, [r4, #20]
8f627b48:	e58dc000 	str	r12, [r13]
8f627b4c:	e1a03000 	mov	r3, r0
8f627b50:	e1a00005 	mov	r0, r5
8f627b54:	ebfffbb1 	bl	8f626a20 <boot_linux>
	return 0;
8f627b58:	e3a00000 	mov	r0, #0
}
8f627b5c:	e59f3788 	ldr	r3, [pc, #1928]	; 8f6282ec <boot_linux_from_flash+0x81c>
8f627b60:	e5932000 	ldr	r2, [r3]
8f627b64:	e59d304c 	ldr	r3, [r13, #76]	; 0x4c
8f627b68:	e0332002 	eors	r2, r3, r2
8f627b6c:	e3a03000 	mov	r3, #0
8f627b70:	1a0001d2 	bne	8f6282c0 <boot_linux_from_flash+0x7f0>
8f627b74:	e28dd054 	add	r13, r13, #84	; 0x54
8f627b78:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	ptable = flash_get_ptable();
8f627b7c:	ebffad11 	bl	8f612fc8 <flash_get_ptable>
	if (ptable == NULL) {
8f627b80:	e3500000 	cmp	r0, #0
8f627b84:	0a0001be 	beq	8f628284 <boot_linux_from_flash+0x7b4>
	if(!boot_into_recovery)
8f627b88:	e301917c 	movw	r9, #4476	; 0x117c
8f627b8c:	e3489f74 	movt	r9, #36724	; 0x8f74
8f627b90:	e5993000 	ldr	r3, [r9]
8f627b94:	e3530000 	cmp	r3, #0
8f627b98:	0a00005a 	beq	8f627d08 <boot_linux_from_flash+0x238>
	        ptn = ptable_find(ptable, "recovery");
8f627b9c:	e3001d34 	movw	r1, #3380	; 0xd34
8f627ba0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f627ba4:	eb003b65 	bl	8f636940 <ptable_find>
	        if (ptn == NULL) {
8f627ba8:	e2503000 	subs	r3, r0, #0
8f627bac:	e58d3010 	str	r3, [r13, #16]
8f627bb0:	0a0001c8 	beq	8f6282d8 <boot_linux_from_flash+0x808>
	if (flash_read(ptn, offset, buf, page_size)) {
8f627bb4:	e3007684 	movw	r7, #1668	; 0x684
8f627bb8:	e3487f74 	movt	r7, #36724	; 0x8f74
int flash_write(struct ptentry *ptn, unsigned write_extra_bytes, const void *data,
		unsigned bytes);
static inline int flash_read(struct ptentry *ptn, unsigned offset, void *data,
			     unsigned bytes)
{
	return flash_read_ext(ptn, 0, offset, data, bytes);
8f627bbc:	e3044200 	movw	r4, #16896	; 0x4200
8f627bc0:	e3484f73 	movt	r4, #36723	; 0x8f73
8f627bc4:	e5973000 	ldr	r3, [r7]
8f627bc8:	e3a02000 	mov	r2, #0
8f627bcc:	e59d0010 	ldr	r0, [r13, #16]
8f627bd0:	e1a01002 	mov	r1, r2
8f627bd4:	e58d3000 	str	r3, [r13]
8f627bd8:	e1a03004 	mov	r3, r4
8f627bdc:	ebffad0c 	bl	8f613014 <flash_read_ext>
8f627be0:	e3500000 	cmp	r0, #0
8f627be4:	1a000192 	bne	8f628234 <boot_linux_from_flash+0x764>
	if (memcmp(hdr->magic, BOOT_MAGIC, BOOT_MAGIC_SIZE)) {
8f627be8:	e3a02008 	mov	r2, #8
8f627bec:	e308187c 	movw	r1, #34940	; 0x887c
8f627bf0:	e1a00004 	mov	r0, r4
8f627bf4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f627bf8:	eb0031f6 	bl	8f6343d8 <memcmp>
8f627bfc:	e2506000 	subs	r6, r0, #0
8f627c00:	1a00016c 	bne	8f6281b8 <boot_linux_from_flash+0x6e8>
	if (hdr->page_size != page_size) {
8f627c04:	e5942024 	ldr	r2, [r4, #36]	; 0x24
8f627c08:	e5971000 	ldr	r1, [r7]
8f627c0c:	e1520001 	cmp	r2, r1
8f627c10:	1a00016d 	bne	8f6281cc <boot_linux_from_flash+0x6fc>
	image_addr = (unsigned char *)target_get_scratch_address();
8f627c14:	ebff65ce 	bl	8f601354 <target_get_scratch_address>
	memcpy(image_addr, (void *)buf, page_size);
8f627c18:	e5972000 	ldr	r2, [r7]
8f627c1c:	e1a01004 	mov	r1, r4
	kernel_actual  = ROUND_TO_PAGE(hdr->kernel_size,  page_mask);
8f627c20:	e3005680 	movw	r5, #1664	; 0x680
8f627c24:	e3485f74 	movt	r5, #36724	; 0x8f74
	image_addr = (unsigned char *)target_get_scratch_address();
8f627c28:	e58d000c 	str	r0, [r13, #12]
	memcpy(image_addr, (void *)buf, page_size);
8f627c2c:	eb003161 	bl	8f6341b8 <memcpy>
		hdr->kernel_addr = ABOOT_FORCE_KERNEL_ADDR;
8f627c30:	ebff6d04 	bl	8f603048 <get_ddr_start>
8f627c34:	e2800902 	add	r0, r0, #32768	; 0x8000
8f627c38:	e584000c 	str	r0, [r4, #12]
	hdr->ramdisk_addr = ABOOT_FORCE_RAMDISK_ADDR;
8f627c3c:	ebff6d01 	bl	8f603048 <get_ddr_start>
8f627c40:	e2800636 	add	r0, r0, #56623104	; 0x3600000
8f627c44:	e5840014 	str	r0, [r4, #20]
	hdr->tags_addr = ABOOT_FORCE_TAGS_ADDR;
8f627c48:	ebff6cfe 	bl	8f603048 <get_ddr_start>
8f627c4c:	e280050d 	add	r0, r0, #54525952	; 0x3400000
8f627c50:	e5840020 	str	r0, [r4, #32]
	hdr->kernel_addr = VA((addr_t)(hdr->kernel_addr));
8f627c54:	e594000c 	ldr	r0, [r4, #12]
8f627c58:	ebff66cd 	bl	8f601794 <platform_get_phys_to_virt_mapping>
8f627c5c:	e584000c 	str	r0, [r4, #12]
	hdr->ramdisk_addr = VA((addr_t)(hdr->ramdisk_addr));
8f627c60:	e5940014 	ldr	r0, [r4, #20]
8f627c64:	ebff66ca 	bl	8f601794 <platform_get_phys_to_virt_mapping>
8f627c68:	e5840014 	str	r0, [r4, #20]
	hdr->tags_addr = VA((addr_t)(hdr->tags_addr));
8f627c6c:	e5940020 	ldr	r0, [r4, #32]
8f627c70:	ebff66c7 	bl	8f601794 <platform_get_phys_to_virt_mapping>
	kernel_actual  = ROUND_TO_PAGE(hdr->kernel_size,  page_mask);
8f627c74:	e5953000 	ldr	r3, [r5]
8f627c78:	e5942008 	ldr	r2, [r4, #8]
	hdr->cmdline[BOOT_ARGS_SIZE-1] = 0;
8f627c7c:	e5c4623f 	strb	r6, [r4, #575]	; 0x23f
	kernel_actual  = ROUND_TO_PAGE(hdr->kernel_size,  page_mask);
8f627c80:	e0826003 	add	r6, r2, r3
	second_actual = ROUND_TO_PAGE(hdr->second_size, page_mask);
8f627c84:	e5941018 	ldr	r1, [r4, #24]
	kernel_actual  = ROUND_TO_PAGE(hdr->kernel_size,  page_mask);
8f627c88:	e1c66003 	bic	r6, r6, r3
8f627c8c:	e1520006 	cmp	r2, r6
	second_actual = ROUND_TO_PAGE(hdr->second_size, page_mask);
8f627c90:	e0832001 	add	r2, r3, r1
	kernel_actual  = ROUND_TO_PAGE(hdr->kernel_size,  page_mask);
8f627c94:	83e06000 	mvnhi	r6, #0
	hdr->tags_addr = VA((addr_t)(hdr->tags_addr));
8f627c98:	e5840020 	str	r0, [r4, #32]
	ramdisk_actual = ROUND_TO_PAGE(hdr->ramdisk_size, page_mask);
8f627c9c:	e5940010 	ldr	r0, [r4, #16]
8f627ca0:	e0838000 	add	r8, r3, r0
8f627ca4:	e1c88003 	bic	r8, r8, r3
	second_actual = ROUND_TO_PAGE(hdr->second_size, page_mask);
8f627ca8:	e1c23003 	bic	r3, r2, r3
	ramdisk_actual = ROUND_TO_PAGE(hdr->ramdisk_size, page_mask);
8f627cac:	e1500008 	cmp	r0, r8
	if (check_aboot_addr_range_overlap(hdr->kernel_addr, kernel_actual) ||
8f627cb0:	e594000c 	ldr	r0, [r4, #12]
	ramdisk_actual = ROUND_TO_PAGE(hdr->ramdisk_size, page_mask);
8f627cb4:	83e08000 	mvnhi	r8, #0
	second_actual = ROUND_TO_PAGE(hdr->second_size, page_mask);
8f627cb8:	e1510003 	cmp	r1, r3
8f627cbc:	83e03000 	mvnhi	r3, #0
8f627cc0:	e58d3014 	str	r3, [r13, #20]
	if ((UINT_MAX - start) < size)
8f627cc4:	e1e03000 	mvn	r3, r0
8f627cc8:	e1560003 	cmp	r6, r3
8f627ccc:	8a000008 	bhi	8f627cf4 <boot_linux_from_flash+0x224>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f627cd0:	e30f3fff 	movw	r3, #65535	; 0xffff
8f627cd4:	e3483f5f 	movt	r3, #36703	; 0x8f5f
8f627cd8:	e1500003 	cmp	r0, r3
8f627cdc:	8a000014 	bhi	8f627d34 <boot_linux_from_flash+0x264>
8f627ce0:	e0802006 	add	r2, r0, r6
8f627ce4:	e3a03000 	mov	r3, #0
8f627ce8:	e3483f60 	movt	r3, #36704	; 0x8f60
8f627cec:	e1520003 	cmp	r2, r3
8f627cf0:	9a000011 	bls	8f627d3c <boot_linux_from_flash+0x26c>
		dprintf(CRITICAL, "kernel/ramdisk addresses are not valid.\n");
8f627cf4:	e3080c5c 	movw	r0, #35932	; 0x8c5c
8f627cf8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627cfc:	eb002b1c 	bl	8f632974 <_dprintf>
		return -1;
8f627d00:	e3e00000 	mvn	r0, #0
8f627d04:	eaffff94 	b	8f627b5c <boot_linux_from_flash+0x8c>
	        ptn = ptable_find(ptable, "boot");
8f627d08:	e30a1370 	movw	r1, #41840	; 0xa370
8f627d0c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f627d10:	eb003b0a 	bl	8f636940 <ptable_find>
	        if (ptn == NULL) {
8f627d14:	e2503000 	subs	r3, r0, #0
8f627d18:	e58d3010 	str	r3, [r13, #16]
8f627d1c:	1affffa4 	bne	8f627bb4 <boot_linux_from_flash+0xe4>
		        dprintf(CRITICAL, "ERROR: No boot partition found\n");
8f627d20:	e3080e28 	movw	r0, #36392	; 0x8e28
8f627d24:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627d28:	eb002b11 	bl	8f632974 <_dprintf>
		        return -1;
8f627d2c:	e3e00000 	mvn	r0, #0
8f627d30:	eaffff89 	b	8f627b5c <boot_linux_from_flash+0x8c>
	else if (start >= (MEMBASE + MEMSIZE))
8f627d34:	e3700217 	cmn	r0, #1879048193	; 0x70000001
8f627d38:	9affffed 	bls	8f627cf4 <boot_linux_from_flash+0x224>
		check_ddr_addr_range_bound(hdr->kernel_addr, kernel_actual) ||
8f627d3c:	e1a01006 	mov	r1, r6
8f627d40:	ebfffbd0 	bl	8f626c88 <check_ddr_addr_range_bound>
	if (check_aboot_addr_range_overlap(hdr->kernel_addr, kernel_actual) ||
8f627d44:	e3500000 	cmp	r0, #0
8f627d48:	1affffe9 	bne	8f627cf4 <boot_linux_from_flash+0x224>
		check_aboot_addr_range_overlap(hdr->ramdisk_addr, ramdisk_actual) ||
8f627d4c:	e5940014 	ldr	r0, [r4, #20]
	if ((UINT_MAX - start) < size)
8f627d50:	e1e03000 	mvn	r3, r0
8f627d54:	e1580003 	cmp	r8, r3
8f627d58:	8affffe5 	bhi	8f627cf4 <boot_linux_from_flash+0x224>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f627d5c:	e30f3fff 	movw	r3, #65535	; 0xffff
8f627d60:	e3483f5f 	movt	r3, #36703	; 0x8f5f
8f627d64:	e1500003 	cmp	r0, r3
8f627d68:	8a0000b7 	bhi	8f62804c <boot_linux_from_flash+0x57c>
8f627d6c:	e0802008 	add	r2, r0, r8
8f627d70:	e3a03000 	mov	r3, #0
8f627d74:	e3483f60 	movt	r3, #36704	; 0x8f60
8f627d78:	e1520003 	cmp	r2, r3
8f627d7c:	8affffdc 	bhi	8f627cf4 <boot_linux_from_flash+0x224>
		check_ddr_addr_range_bound(hdr->ramdisk_addr, ramdisk_actual))
8f627d80:	e1a01008 	mov	r1, r8
8f627d84:	ebfffbbf 	bl	8f626c88 <check_ddr_addr_range_bound>
		check_aboot_addr_range_overlap(hdr->ramdisk_addr, ramdisk_actual) ||
8f627d88:	e3500000 	cmp	r0, #0
8f627d8c:	1affffd8 	bne	8f627cf4 <boot_linux_from_flash+0x224>
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f627d90:	e5953000 	ldr	r3, [r5]
	if (UINT_MAX < ((uint64_t)kernel_actual + (uint64_t)ramdisk_actual+ (uint64_t)second_actual + (uint64_t)dt_actual + page_size)) {
8f627d94:	e3a0c000 	mov	r12, #0
	dt_size = hdr->dt_size;
8f627d98:	e5941028 	ldr	r1, [r4, #40]	; 0x28
	if (UINT_MAX < ((uint64_t)kernel_actual + (uint64_t)ramdisk_actual+ (uint64_t)second_actual + (uint64_t)dt_actual + page_size)) {
8f627d9c:	e3e0a000 	mvn	r10, #0
8f627da0:	e59de014 	ldr	r14, [r13, #20]
	dt_size = hdr->dt_size;
8f627da4:	e305b200 	movw	r11, #20992	; 0x5200
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f627da8:	e0815003 	add	r5, r1, r3
	dt_size = hdr->dt_size;
8f627dac:	e348bf73 	movt	r11, #36723	; 0x8f73
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f627db0:	e1c52003 	bic	r2, r5, r3
	if (UINT_MAX < ((uint64_t)kernel_actual + (uint64_t)ramdisk_actual+ (uint64_t)second_actual + (uint64_t)dt_actual + page_size)) {
8f627db4:	e5975000 	ldr	r5, [r7]
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f627db8:	e1510002 	cmp	r1, r2
	dt_size = hdr->dt_size;
8f627dbc:	e58b1000 	str	r1, [r11]
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f627dc0:	83e00000 	mvnhi	r0, #0
	if (UINT_MAX < ((uint64_t)kernel_actual + (uint64_t)ramdisk_actual+ (uint64_t)second_actual + (uint64_t)dt_actual + page_size)) {
8f627dc4:	91a00002 	movls	r0, r2
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f627dc8:	81a02000 	movhi	r2, r0
	if (UINT_MAX < ((uint64_t)kernel_actual + (uint64_t)ramdisk_actual+ (uint64_t)second_actual + (uint64_t)dt_actual + page_size)) {
8f627dcc:	e0965005 	adds	r5, r6, r5
8f627dd0:	e0ac300c 	adc	r3, r12, r12
8f627dd4:	e0955008 	adds	r5, r5, r8
8f627dd8:	e2a33000 	adc	r3, r3, #0
8f627ddc:	e095500e 	adds	r5, r5, r14
8f627de0:	e2a33000 	adc	r3, r3, #0
8f627de4:	e0950000 	adds	r0, r5, r0
8f627de8:	e2a33000 	adc	r3, r3, #0
8f627dec:	e15a0000 	cmp	r10, r0
8f627df0:	e0dc3003 	sbcs	r3, r12, r3
8f627df4:	3a000113 	bcc	8f628248 <boot_linux_from_flash+0x778>
	if (check_aboot_addr_range_overlap(hdr->tags_addr, dt_size) ||
8f627df8:	e5940020 	ldr	r0, [r4, #32]
	imagesize_actual = (page_size + kernel_actual + ramdisk_actual + second_actual + dt_actual);
8f627dfc:	e0855002 	add	r5, r5, r2
	if ((UINT_MAX - start) < size)
8f627e00:	e1e03000 	mvn	r3, r0
8f627e04:	e1510003 	cmp	r1, r3
8f627e08:	8a000008 	bhi	8f627e30 <boot_linux_from_flash+0x360>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f627e0c:	e30f3fff 	movw	r3, #65535	; 0xffff
8f627e10:	e3483f5f 	movt	r3, #36703	; 0x8f5f
8f627e14:	e1500003 	cmp	r0, r3
8f627e18:	8a000009 	bhi	8f627e44 <boot_linux_from_flash+0x374>
8f627e1c:	e0812000 	add	r2, r1, r0
8f627e20:	e3a03000 	mov	r3, #0
8f627e24:	e3483f60 	movt	r3, #36704	; 0x8f60
8f627e28:	e1520003 	cmp	r2, r3
8f627e2c:	9a000006 	bls	8f627e4c <boot_linux_from_flash+0x37c>
		dprintf(CRITICAL, "Device tree addresses are not valid.\n");
8f627e30:	e3080db0 	movw	r0, #36272	; 0x8db0
8f627e34:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627e38:	eb002acd 	bl	8f632974 <_dprintf>
		return -1;
8f627e3c:	e3e00000 	mvn	r0, #0
8f627e40:	eaffff45 	b	8f627b5c <boot_linux_from_flash+0x8c>
	else if (start >= (MEMBASE + MEMSIZE))
8f627e44:	e3700217 	cmn	r0, #1879048193	; 0x70000001
8f627e48:	9afffff8 	bls	8f627e30 <boot_linux_from_flash+0x360>
		check_ddr_addr_range_bound(hdr->tags_addr, dt_size))
8f627e4c:	ebfffb8d 	bl	8f626c88 <check_ddr_addr_range_bound>
	if (check_aboot_addr_range_overlap(hdr->tags_addr, dt_size) ||
8f627e50:	e2503000 	subs	r3, r0, #0
8f627e54:	e58d3018 	str	r3, [r13, #24]
8f627e58:	1afffff4 	bne	8f627e30 <boot_linux_from_flash+0x360>
	dprintf(INFO, "Loading (%s) image (%d): start\n",
8f627e5c:	e5991000 	ldr	r1, [r9]
8f627e60:	e300ad34 	movw	r10, #3380	; 0xd34
8f627e64:	e348af70 	movt	r10, #36720	; 0x8f70
8f627e68:	e30a3370 	movw	r3, #41840	; 0xa370
8f627e6c:	e3510000 	cmp	r1, #0
8f627e70:	e3483f70 	movt	r3, #36720	; 0x8f70
8f627e74:	e58d301c 	str	r3, [r13, #28]
8f627e78:	e1a02005 	mov	r2, r5
8f627e7c:	11a0300a 	movne	r3, r10
8f627e80:	e3080a04 	movw	r0, #35332	; 0x8a04
8f627e84:	e1a01003 	mov	r1, r3
8f627e88:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627e8c:	eb002ab8 	bl	8f632974 <_dprintf>
	bs_set_timestamp(BS_KERNEL_LOAD_START);
8f627e90:	e3a00004 	mov	r0, #4
8f627e94:	ebff7c93 	bl	8f6070e8 <bs_set_timestamp>
	if (UINT_MAX - page_size < imagesize_actual)
8f627e98:	e5973000 	ldr	r3, [r7]
8f627e9c:	e1e03003 	mvn	r3, r3
8f627ea0:	e1530005 	cmp	r3, r5
8f627ea4:	3a0000d2 	bcc	8f6281f4 <boot_linux_from_flash+0x724>
	if (target_get_max_flash_size() < (imagesize_actual + page_size))
8f627ea8:	ebff653b 	bl	8f60139c <target_get_max_flash_size>
8f627eac:	e5972000 	ldr	r2, [r7]
8f627eb0:	e0823005 	add	r3, r2, r5
8f627eb4:	e1500003 	cmp	r0, r3
8f627eb8:	3a0000c8 	bcc	8f6281e0 <boot_linux_from_flash+0x710>
	if (flash_read(ptn, offset, (void *)(image_addr + offset), imagesize_actual - page_size))
8f627ebc:	e0453002 	sub	r3, r5, r2
8f627ec0:	e58d3000 	str	r3, [r13]
8f627ec4:	e59d300c 	ldr	r3, [r13, #12]
8f627ec8:	e59d1018 	ldr	r1, [r13, #24]
8f627ecc:	e59d0010 	ldr	r0, [r13, #16]
8f627ed0:	e0833002 	add	r3, r3, r2
8f627ed4:	ebffac4e 	bl	8f613014 <flash_read_ext>
8f627ed8:	e3500000 	cmp	r0, #0
8f627edc:	1a0000de 	bne	8f62825c <boot_linux_from_flash+0x78c>
	dprintf(INFO, "Loading (%s) image (%d): done\n",
8f627ee0:	e5991000 	ldr	r1, [r9]
8f627ee4:	e1a02005 	mov	r2, r5
8f627ee8:	e59d301c 	ldr	r3, [r13, #28]
8f627eec:	e3080aa4 	movw	r0, #35492	; 0x8aa4
8f627ef0:	e3510000 	cmp	r1, #0
8f627ef4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f627ef8:	11a0300a 	movne	r3, r10
8f627efc:	e1a01003 	mov	r1, r3
8f627f00:	eb002a9b 	bl	8f632974 <_dprintf>
	bs_set_timestamp(BS_KERNEL_LOAD_DONE);
8f627f04:	e3a00005 	mov	r0, #5
8f627f08:	ebff7c76 	bl	8f6070e8 <bs_set_timestamp>
	if(target_use_signed_kernel() && (!device.is_unlocked))
8f627f0c:	ebffe6ec 	bl	8f621ac4 <target_use_signed_kernel>
8f627f10:	e3500000 	cmp	r0, #0
8f627f14:	0a000004 	beq	8f627f2c <boot_linux_from_flash+0x45c>
8f627f18:	e3013ad0 	movw	r3, #6864	; 0x1ad0
8f627f1c:	e3483f71 	movt	r3, #36721	; 0x8f71
8f627f20:	e5931010 	ldr	r1, [r3, #16]
8f627f24:	e3510000 	cmp	r1, #0
8f627f28:	0a000094 	beq	8f628180 <boot_linux_from_flash+0x6b0>
	if(hdr->second_size != 0) {
8f627f2c:	e5943018 	ldr	r3, [r4, #24]
	offset = page_size;
8f627f30:	e5971000 	ldr	r1, [r7]
	if(hdr->second_size != 0) {
8f627f34:	e3530000 	cmp	r3, #0
8f627f38:	0a00000e 	beq	8f627f78 <boot_linux_from_flash+0x4a8>
		if (UINT_MAX - offset < second_actual)
8f627f3c:	e59d3014 	ldr	r3, [r13, #20]
8f627f40:	e1e01001 	mvn	r1, r1
8f627f44:	e1510003 	cmp	r1, r3
8f627f48:	3a0000b1 	bcc	8f628214 <boot_linux_from_flash+0x744>
		ASSERT(0);
8f627f4c:	e59d0008 	ldr	r0, [r13, #8]
8f627f50:	e3073f64 	movw	r3, #32612	; 0x7f64
8f627f54:	e30824b0 	movw	r2, #33968	; 0x84b0
8f627f58:	e3483f70 	movt	r3, #36720	; 0x8f70
8f627f5c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f627f60:	e58d3000 	str	r3, [r13]
8f627f64:	e3001130 	movw	r1, #304	; 0x130
8f627f68:	e3003963 	movw	r3, #2403	; 0x963
8f627f6c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f627f70:	eb002ad1 	bl	8f632abc <_panic>
	memmove((void*) hdr->kernel_addr, (char*) (image_addr + page_size), hdr->kernel_size);
8f627f74:	e5971000 	ldr	r1, [r7]
8f627f78:	e59d500c 	ldr	r5, [r13, #12]
8f627f7c:	e5942008 	ldr	r2, [r4, #8]
8f627f80:	e0851001 	add	r1, r5, r1
8f627f84:	e594000c 	ldr	r0, [r4, #12]
8f627f88:	eb00308a 	bl	8f6341b8 <memcpy>
	memmove((void*) hdr->ramdisk_addr, (char*) (image_addr + page_size + kernel_actual), hdr->ramdisk_size);
8f627f8c:	e5971000 	ldr	r1, [r7]
8f627f90:	e5942010 	ldr	r2, [r4, #16]
8f627f94:	e0861001 	add	r1, r6, r1
8f627f98:	e5940014 	ldr	r0, [r4, #20]
8f627f9c:	e0851001 	add	r1, r5, r1
8f627fa0:	eb003084 	bl	8f6341b8 <memcpy>
	if(dt_size != 0) {
8f627fa4:	e59b3000 	ldr	r3, [r11]
8f627fa8:	e3530000 	cmp	r3, #0
8f627fac:	1a00002c 	bne	8f628064 <boot_linux_from_flash+0x594>
		if (check_aboot_addr_range_overlap(hdr->tags_addr, kernel_actual) ||
8f627fb0:	e5940020 	ldr	r0, [r4, #32]
	if ((UINT_MAX - start) < size)
8f627fb4:	e1e03000 	mvn	r3, r0
8f627fb8:	e1560003 	cmp	r6, r3
8f627fbc:	8affff9b 	bhi	8f627e30 <boot_linux_from_flash+0x360>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f627fc0:	e30f3fff 	movw	r3, #65535	; 0xffff
8f627fc4:	e3483f5f 	movt	r3, #36703	; 0x8f5f
8f627fc8:	e1500003 	cmp	r0, r3
8f627fcc:	8a000021 	bhi	8f628058 <boot_linux_from_flash+0x588>
8f627fd0:	e0802006 	add	r2, r0, r6
8f627fd4:	e3a03000 	mov	r3, #0
8f627fd8:	e3483f60 	movt	r3, #36704	; 0x8f60
8f627fdc:	e1520003 	cmp	r2, r3
8f627fe0:	8affff92 	bhi	8f627e30 <boot_linux_from_flash+0x360>
	        check_ddr_addr_range_bound(hdr->tags_addr, kernel_actual))
8f627fe4:	e1a01006 	mov	r1, r6
8f627fe8:	ebfffb26 	bl	8f626c88 <check_ddr_addr_range_bound>
		if (check_aboot_addr_range_overlap(hdr->tags_addr, kernel_actual) ||
8f627fec:	e2502000 	subs	r2, r0, #0
8f627ff0:	1affff8e 	bne	8f627e30 <boot_linux_from_flash+0x360>
		dtb = dev_tree_appended((void*)(image_addr + page_size ),hdr->kernel_size, dtb_offset, (void *)hdr->tags_addr);
8f627ff4:	e59d300c 	ldr	r3, [r13, #12]
8f627ff8:	e5970000 	ldr	r0, [r7]
8f627ffc:	e5941008 	ldr	r1, [r4, #8]
8f628000:	e0830000 	add	r0, r3, r0
8f628004:	e5943020 	ldr	r3, [r4, #32]
8f628008:	ebffbf50 	bl	8f617d50 <dev_tree_appended>
		if (!dtb) {
8f62800c:	e3500000 	cmp	r0, #0
8f628010:	0a0000ab 	beq	8f6282c4 <boot_linux_from_flash+0x7f4>
	if(target_use_signed_kernel() && (!device.is_unlocked))
8f628014:	ebffe6aa 	bl	8f621ac4 <target_use_signed_kernel>
8f628018:	e3500000 	cmp	r0, #0
8f62801c:	0a000007 	beq	8f628040 <boot_linux_from_flash+0x570>
8f628020:	e3013ad0 	movw	r3, #6864	; 0x1ad0
8f628024:	e3483f71 	movt	r3, #36721	; 0x8f71
8f628028:	e5932010 	ldr	r2, [r3, #16]
8f62802c:	e3520000 	cmp	r2, #0
8f628030:	1a000002 	bne	8f628040 <boot_linux_from_flash+0x570>
		if(device.is_tampered)
8f628034:	e5933014 	ldr	r3, [r3, #20]
8f628038:	e3530000 	cmp	r3, #0
8f62803c:	1a000049 	bne	8f628168 <boot_linux_from_flash+0x698>
	boot_img_hdr *hdr = (void*) buf;
8f628040:	e3044200 	movw	r4, #16896	; 0x4200
8f628044:	e3484f73 	movt	r4, #36723	; 0x8f73
8f628048:	eafffeb6 	b	8f627b28 <boot_linux_from_flash+0x58>
	else if (start >= (MEMBASE + MEMSIZE))
8f62804c:	e3700217 	cmn	r0, #1879048193	; 0x70000001
8f628050:	8affff4a 	bhi	8f627d80 <boot_linux_from_flash+0x2b0>
8f628054:	eaffff26 	b	8f627cf4 <boot_linux_from_flash+0x224>
8f628058:	e3700217 	cmn	r0, #1879048193	; 0x70000001
8f62805c:	8affffe0 	bhi	8f627fe4 <boot_linux_from_flash+0x514>
8f628060:	eaffff72 	b	8f627e30 <boot_linux_from_flash+0x360>
		dt_table_offset = ((uint32_t)image_addr + page_size + kernel_actual + ramdisk_actual + second_actual);
8f628064:	e59d300c 	ldr	r3, [r13, #12]
		if (dev_tree_validate(table, hdr->page_size, &dt_hdr_size) != 0) {
8f628068:	e28d2020 	add	r2, r13, #32
		dt_table_offset = ((uint32_t)image_addr + page_size + kernel_actual + ramdisk_actual + second_actual);
8f62806c:	e5970000 	ldr	r0, [r7]
		if (dev_tree_validate(table, hdr->page_size, &dt_hdr_size) != 0) {
8f628070:	e5941024 	ldr	r1, [r4, #36]	; 0x24
		dt_table_offset = ((uint32_t)image_addr + page_size + kernel_actual + ramdisk_actual + second_actual);
8f628074:	e0830000 	add	r0, r3, r0
8f628078:	e59d3014 	ldr	r3, [r13, #20]
8f62807c:	e0806006 	add	r6, r0, r6
8f628080:	e0868008 	add	r8, r6, r8
8f628084:	e0888003 	add	r8, r8, r3
		if (dev_tree_validate(table, hdr->page_size, &dt_hdr_size) != 0) {
8f628088:	e1a00008 	mov	r0, r8
8f62808c:	ebffc2ea 	bl	8f618c3c <dev_tree_validate>
8f628090:	e3500000 	cmp	r0, #0
8f628094:	1a00007f 	bne	8f628298 <boot_linux_from_flash+0x7c8>
		if (dt_hdr_size > ROUND_TO_PAGE(dt_size,hdr->page_size)) {
8f628098:	e5941024 	ldr	r1, [r4, #36]	; 0x24
8f62809c:	e59b2000 	ldr	r2, [r11]
8f6280a0:	e0813002 	add	r3, r1, r2
8f6280a4:	e1c33001 	bic	r3, r3, r1
8f6280a8:	e1520003 	cmp	r2, r3
8f6280ac:	9a00001f 	bls	8f628130 <boot_linux_from_flash+0x660>
		if(dev_tree_get_entry_info(table, &dt_entry) != 0){
8f6280b0:	e28d1024 	add	r1, r13, #36	; 0x24
8f6280b4:	e1a00008 	mov	r0, r8
8f6280b8:	ebffc313 	bl	8f618d0c <dev_tree_get_entry_info>
8f6280bc:	e3500000 	cmp	r0, #0
8f6280c0:	1a000079 	bne	8f6282ac <boot_linux_from_flash+0x7dc>
		if (check_aboot_addr_range_overlap(hdr->tags_addr, dt_entry.size) ||
8f6280c4:	e5940020 	ldr	r0, [r4, #32]
8f6280c8:	e59d1048 	ldr	r1, [r13, #72]	; 0x48
	if ((UINT_MAX - start) < size)
8f6280cc:	e1e03000 	mvn	r3, r0
8f6280d0:	e1510003 	cmp	r1, r3
8f6280d4:	8affff55 	bhi	8f627e30 <boot_linux_from_flash+0x360>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f6280d8:	e30f3fff 	movw	r3, #65535	; 0xffff
8f6280dc:	e3483f5f 	movt	r3, #36703	; 0x8f5f
8f6280e0:	e1500003 	cmp	r0, r3
8f6280e4:	9a000019 	bls	8f628150 <boot_linux_from_flash+0x680>
	else if (start >= (MEMBASE + MEMSIZE))
8f6280e8:	e3700217 	cmn	r0, #1879048193	; 0x70000001
8f6280ec:	9affff4f 	bls	8f627e30 <boot_linux_from_flash+0x360>
			check_ddr_addr_range_bound(hdr->tags_addr, dt_entry.size))
8f6280f0:	ebfffae4 	bl	8f626c88 <check_ddr_addr_range_bound>
		if (check_aboot_addr_range_overlap(hdr->tags_addr, dt_entry.size) ||
8f6280f4:	e3500000 	cmp	r0, #0
8f6280f8:	1affff4c 	bne	8f627e30 <boot_linux_from_flash+0x360>
		if(dt_entry.offset > (UINT_MAX - dt_entry.size)) {
8f6280fc:	e59d2048 	ldr	r2, [r13, #72]	; 0x48
8f628100:	e59d1044 	ldr	r1, [r13, #68]	; 0x44
8f628104:	e1e03002 	mvn	r3, r2
8f628108:	e1510003 	cmp	r1, r3
8f62810c:	8a000057 	bhi	8f628270 <boot_linux_from_flash+0x7a0>
		if ((dt_entry.offset + dt_entry.size) > dt_size) {
8f628110:	e59b3000 	ldr	r3, [r11]
8f628114:	e0810002 	add	r0, r1, r2
8f628118:	e1500003 	cmp	r0, r3
8f62811c:	8a000053 	bhi	8f628270 <boot_linux_from_flash+0x7a0>
		memmove((void *)hdr->tags_addr, (char *)best_match_dt_addr, dtb_size);
8f628120:	e5940020 	ldr	r0, [r4, #32]
8f628124:	e0881001 	add	r1, r8, r1
8f628128:	eb003022 	bl	8f6341b8 <memcpy>
8f62812c:	eaffffb8 	b	8f628014 <boot_linux_from_flash+0x544>
		if (dt_hdr_size > ROUND_TO_PAGE(dt_size,hdr->page_size)) {
8f628130:	e59d2020 	ldr	r2, [r13, #32]
8f628134:	e1530002 	cmp	r3, r2
8f628138:	2affffdc 	bcs	8f6280b0 <boot_linux_from_flash+0x5e0>
			dprintf(CRITICAL, "ERROR: Invalid Device Tree size \n");
8f62813c:	e3080cb4 	movw	r0, #36020	; 0x8cb4
8f628140:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628144:	eb002a0a 	bl	8f632974 <_dprintf>
			return -1;
8f628148:	e3e00000 	mvn	r0, #0
8f62814c:	eafffe82 	b	8f627b5c <boot_linux_from_flash+0x8c>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f628150:	e0802001 	add	r2, r0, r1
8f628154:	e3a03000 	mov	r3, #0
8f628158:	e3483f60 	movt	r3, #36704	; 0x8f60
8f62815c:	e1520003 	cmp	r2, r3
8f628160:	8affff32 	bhi	8f627e30 <boot_linux_from_flash+0x360>
8f628164:	eaffffe1 	b	8f6280f0 <boot_linux_from_flash+0x620>
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f628168:	e3070510 	movw	r0, #29968	; 0x7510
8f62816c:	e3480f70 	movt	r0, #36720	; 0x8f70
	boot_img_hdr *hdr = (void*) buf;
8f628170:	e3044200 	movw	r4, #16896	; 0x4200
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f628174:	eb0029fe 	bl	8f632974 <_dprintf>
	boot_img_hdr *hdr = (void*) buf;
8f628178:	e3484f73 	movt	r4, #36723	; 0x8f73
}
8f62817c:	eafffe69 	b	8f627b28 <boot_linux_from_flash+0x58>
8f628180:	e5973000 	ldr	r3, [r7]
8f628184:	e1a02005 	mov	r2, r5
8f628188:	e59d0010 	ldr	r0, [r13, #16]
8f62818c:	e58d3000 	str	r3, [r13]
8f628190:	e59d300c 	ldr	r3, [r13, #12]
8f628194:	e0833005 	add	r3, r3, r5
8f628198:	ebffab9d 	bl	8f613014 <flash_read_ext>
		if (flash_read(ptn, offset, (void *)(image_addr + offset), page_size))
8f62819c:	e3500000 	cmp	r0, #0
8f6281a0:	0affff61 	beq	8f627f2c <boot_linux_from_flash+0x45c>
			dprintf(CRITICAL, "ERROR: Cannot read boot image signature\n");
8f6281a4:	e3080b3c 	movw	r0, #35644	; 0x8b3c
8f6281a8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6281ac:	eb0029f0 	bl	8f632974 <_dprintf>
			return -1;
8f6281b0:	e3e00000 	mvn	r0, #0
8f6281b4:	eafffe68 	b	8f627b5c <boot_linux_from_flash+0x8c>
			dprintf(CRITICAL, "ERROR: Invalid boot image header\n");
8f6281b8:	e30808e8 	movw	r0, #35048	; 0x88e8
8f6281bc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6281c0:	eb0029eb 	bl	8f632974 <_dprintf>
			return -1;
8f6281c4:	e3e00000 	mvn	r0, #0
8f6281c8:	eafffe63 	b	8f627b5c <boot_linux_from_flash+0x8c>
		dprintf(CRITICAL, "ERROR: Invalid boot image pagesize. Device pagesize: %d, Image pagesize: %d\n",page_size,hdr->page_size);
8f6281cc:	e3080e6c 	movw	r0, #36460	; 0x8e6c
8f6281d0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6281d4:	eb0029e6 	bl	8f632974 <_dprintf>
		return -1;
8f6281d8:	e3e00000 	mvn	r0, #0
8f6281dc:	eafffe5e 	b	8f627b5c <boot_linux_from_flash+0x8c>
		dprintf(CRITICAL, "bootimage  size is greater than DDR can hold\n");
8f6281e0:	e3080f30 	movw	r0, #36656	; 0x8f30
8f6281e4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6281e8:	eb0029e1 	bl	8f632974 <_dprintf>
		return -1;
8f6281ec:	e3e00000 	mvn	r0, #0
8f6281f0:	eafffe59 	b	8f627b5c <boot_linux_from_flash+0x8c>
		dprintf(CRITICAL,"Integer overflow detected in bootimage header fields %u %s\n", __LINE__,__func__);
8f6281f4:	e3092f70 	movw	r2, #40816	; 0x9f70
8f6281f8:	e3001935 	movw	r1, #2357	; 0x935
8f6281fc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f628200:	e3080ef4 	movw	r0, #36596	; 0x8ef4
8f628204:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628208:	eb0029d9 	bl	8f632974 <_dprintf>
		return -1;
8f62820c:	e3e00000 	mvn	r0, #0
8f628210:	eafffe51 	b	8f627b5c <boot_linux_from_flash+0x8c>
			dprintf(CRITICAL, "ERROR: Integer overflow in boot image header %s\t%d\n",__func__,__LINE__);
8f628214:	e300295e 	movw	r2, #2398	; 0x95e
8f628218:	e3091f70 	movw	r1, #40816	; 0x9f70
8f62821c:	e3080f60 	movw	r0, #36704	; 0x8f60
8f628220:	e3481f70 	movt	r1, #36720	; 0x8f70
8f628224:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628228:	eb0029d1 	bl	8f632974 <_dprintf>
			return -1;
8f62822c:	e3e00000 	mvn	r0, #0
8f628230:	eafffe49 	b	8f627b5c <boot_linux_from_flash+0x8c>
		dprintf(CRITICAL, "ERROR: Cannot read boot image header\n");
8f628234:	e30808c0 	movw	r0, #35008	; 0x88c0
8f628238:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62823c:	eb0029cc 	bl	8f632974 <_dprintf>
		return -1;
8f628240:	e3e00000 	mvn	r0, #0
8f628244:	eafffe44 	b	8f627b5c <boot_linux_from_flash+0x8c>
		dprintf(CRITICAL, "Integer overflow detected in bootimage header fields\n");
8f628248:	e3080ebc 	movw	r0, #36540	; 0x8ebc
8f62824c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628250:	eb0029c7 	bl	8f632974 <_dprintf>
		return -1;
8f628254:	e1a0000a 	mov	r0, r10
8f628258:	eafffe3f 	b	8f627b5c <boot_linux_from_flash+0x8c>
		dprintf(CRITICAL, "ERROR: Cannot read boot image\n");
8f62825c:	e3080a54 	movw	r0, #35412	; 0x8a54
8f628260:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628264:	eb0029c2 	bl	8f632974 <_dprintf>
			return -1;
8f628268:	e3e00000 	mvn	r0, #0
8f62826c:	eafffe3a 	b	8f627b5c <boot_linux_from_flash+0x8c>
			dprintf(CRITICAL, "ERROR: Device tree contents are Invalid\n");
8f628270:	e3080d04 	movw	r0, #36100	; 0x8d04
8f628274:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628278:	eb0029bd 	bl	8f632974 <_dprintf>
			return -1;
8f62827c:	e3e00000 	mvn	r0, #0
8f628280:	eafffe35 	b	8f627b5c <boot_linux_from_flash+0x8c>
		dprintf(CRITICAL, "ERROR: Partition table not found\n");
8f628284:	e3080e04 	movw	r0, #36356	; 0x8e04
8f628288:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62828c:	eb0029b8 	bl	8f632974 <_dprintf>
		return -1;
8f628290:	e3e00000 	mvn	r0, #0
8f628294:	eafffe30 	b	8f627b5c <boot_linux_from_flash+0x8c>
			dprintf(CRITICAL, "ERROR: Cannot validate Device Tree Table \n");
8f628298:	e3080c88 	movw	r0, #35976	; 0x8c88
8f62829c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6282a0:	eb0029b3 	bl	8f632974 <_dprintf>
			return -1;
8f6282a4:	e3e00000 	mvn	r0, #0
8f6282a8:	eafffe2b 	b	8f627b5c <boot_linux_from_flash+0x8c>
			dprintf(CRITICAL, "ERROR: Getting device tree address failed\n");
8f6282ac:	e3080cd8 	movw	r0, #36056	; 0x8cd8
8f6282b0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6282b4:	eb0029ae 	bl	8f632974 <_dprintf>
			return -1;
8f6282b8:	e3e00000 	mvn	r0, #0
8f6282bc:	eafffe26 	b	8f627b5c <boot_linux_from_flash+0x8c>
}
8f6282c0:	eb002a3e 	bl	8f632bc0 <__stack_chk_fail>
			dprintf(CRITICAL, "ERROR: Appended Device Tree Blob not found\n");
8f6282c4:	e3080dd8 	movw	r0, #36312	; 0x8dd8
8f6282c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6282cc:	eb0029a8 	bl	8f632974 <_dprintf>
			return -1;
8f6282d0:	e3e00000 	mvn	r0, #0
8f6282d4:	eafffe20 	b	8f627b5c <boot_linux_from_flash+0x8c>
		        dprintf(CRITICAL, "ERROR: No recovery partition found\n");
8f6282d8:	e3080e48 	movw	r0, #36424	; 0x8e48
8f6282dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6282e0:	eb0029a3 	bl	8f632974 <_dprintf>
		        return -1;
8f6282e4:	e3e00000 	mvn	r0, #0
8f6282e8:	eafffe1b 	b	8f627b5c <boot_linux_from_flash+0x8c>
8f6282ec:	8f74221c 	.word	0x8f74221c

8f6282f0 <cmd_continue>:
{
8f6282f0:	e59f307c 	ldr	r3, [pc, #124]	; 8f628374 <cmd_continue+0x84>
	fastboot_okay("");
8f6282f4:	e3070138 	movw	r0, #28984	; 0x7138
{
8f6282f8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	fastboot_okay("");
8f6282fc:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f628300:	e24dd00c 	sub	r13, r13, #12
8f628304:	e5933000 	ldr	r3, [r3]
8f628308:	e58d3004 	str	r3, [r13, #4]
8f62830c:	e3a03000 	mov	r3, #0
	fastboot_okay("");
8f628310:	eb001321 	bl	8f62cf9c <fastboot_okay>
	fastboot_stop();
8f628314:	eb00149c 	bl	8f62d58c <fastboot_stop>
	if (target_is_emmc_boot())
8f628318:	ebffe5d8 	bl	8f621a80 <target_is_emmc_boot>
8f62831c:	e3500000 	cmp	r0, #0
8f628320:	0a000009 	beq	8f62834c <cmd_continue+0x5c>
		exit_menu_keys_detection();
8f628324:	ebff9695 	bl	8f60dd80 <exit_menu_keys_detection>
		boot_linux_from_mmc();
8f628328:	e59f3044 	ldr	r3, [pc, #68]	; 8f628374 <cmd_continue+0x84>
8f62832c:	e5932000 	ldr	r2, [r3]
8f628330:	e59d3004 	ldr	r3, [r13, #4]
8f628334:	e0332002 	eors	r2, r3, r2
8f628338:	e3a03000 	mov	r3, #0
8f62833c:	1a00000b 	bne	8f628370 <cmd_continue+0x80>
}
8f628340:	e28dd00c 	add	r13, r13, #12
8f628344:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		boot_linux_from_mmc();
8f628348:	eafffa7a 	b	8f626d38 <boot_linux_from_mmc>
		boot_linux_from_flash();
8f62834c:	e59f3020 	ldr	r3, [pc, #32]	; 8f628374 <cmd_continue+0x84>
8f628350:	e5932000 	ldr	r2, [r3]
8f628354:	e59d3004 	ldr	r3, [r13, #4]
8f628358:	e0332002 	eors	r2, r3, r2
8f62835c:	e3a03000 	mov	r3, #0
8f628360:	1a000002 	bne	8f628370 <cmd_continue+0x80>
}
8f628364:	e28dd00c 	add	r13, r13, #12
8f628368:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		boot_linux_from_flash();
8f62836c:	eafffdd7 	b	8f627ad0 <boot_linux_from_flash>
8f628370:	eb002a12 	bl	8f632bc0 <__stack_chk_fail>
8f628374:	8f74221c 	.word	0x8f74221c

8f628378 <read_device_info_mmc>:
{
8f628378:	e59f317c 	ldr	r3, [pc, #380]	; 8f6284fc <read_device_info_mmc+0x184>
	if ((index = partition_get_index("devinfo")) < 0)
8f62837c:	e3080f94 	movw	r0, #36756	; 0x8f94
{
8f628380:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	if ((index = partition_get_index("devinfo")) < 0)
8f628384:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f628388:	e24dd014 	sub	r13, r13, #20
8f62838c:	e1a0600e 	mov	r6, r14
8f628390:	e5933000 	ldr	r3, [r3]
8f628394:	e58d300c 	str	r3, [r13, #12]
8f628398:	e3a03000 	mov	r3, #0
	if ((index = partition_get_index("devinfo")) < 0)
8f62839c:	ebff6e3a 	bl	8f603c8c <partition_get_index>
8f6283a0:	e2504000 	subs	r4, r0, #0
8f6283a4:	ba000038 	blt	8f62848c <read_device_info_mmc+0x114>
	ptn = partition_get_offset(index);
8f6283a8:	e1a00004 	mov	r0, r4
8f6283ac:	ebff7142 	bl	8f6048bc <partition_get_offset>
	if(ptn == 0)
8f6283b0:	e1903001 	orrs	r3, r0, r1
	ptn = partition_get_offset(index);
8f6283b4:	e1a05000 	mov	r5, r0
8f6283b8:	e1a07001 	mov	r7, r1
	if(ptn == 0)
8f6283bc:	1a000007 	bne	8f6283e0 <read_device_info_mmc+0x68>
}
8f6283c0:	e59f3134 	ldr	r3, [pc, #308]	; 8f6284fc <read_device_info_mmc+0x184>
8f6283c4:	e5932000 	ldr	r2, [r3]
8f6283c8:	e59d300c 	ldr	r3, [r13, #12]
8f6283cc:	e0332002 	eors	r2, r3, r2
8f6283d0:	e3a03000 	mov	r3, #0
8f6283d4:	1a000047 	bne	8f6284f8 <read_device_info_mmc+0x180>
8f6283d8:	e28dd014 	add	r13, r13, #20
8f6283dc:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
	mmc_set_lun(partition_get_lun(index));
8f6283e0:	e1a00004 	mov	r0, r4
8f6283e4:	ebff7155 	bl	8f604940 <partition_get_lun>
8f6283e8:	ebff9411 	bl	8f60d434 <mmc_set_lun>
	size = partition_get_size(index);
8f6283ec:	e1a00004 	mov	r0, r4
8f6283f0:	ebff7110 	bl	8f604838 <partition_get_size>
	device_info_sz = ROUND_TO_PAGE(sizeof(struct device_info),
8f6283f4:	e30f364c 	movw	r3, #63052	; 0xf64c
8f6283f8:	e3483f73 	movt	r3, #36723	; 0x8f73
	if (device_info_sz == UINT_MAX)
8f6283fc:	e3e0ce9f 	mvn	r12, #2544	; 0x9f0
	device_info_sz = ROUND_TO_PAGE(sizeof(struct device_info),
8f628400:	e5932000 	ldr	r2, [r3]
8f628404:	e2823e9f 	add	r3, r2, #2544	; 0x9f0
8f628408:	e1c33002 	bic	r3, r3, r2
	if (device_info_sz == UINT_MAX)
8f62840c:	e2432e9f 	sub	r2, r3, #2544	; 0x9f0
8f628410:	e152000c 	cmp	r2, r12
8f628414:	2a00002c 	bcs	8f6284cc <read_device_info_mmc+0x154>
	if (devinfo_present)
8f628418:	e30224c0 	movw	r2, #9408	; 0x24c0
8f62841c:	e3482f71 	movt	r2, #36721	; 0x8f71
8f628420:	e5922000 	ldr	r2, [r2]
8f628424:	e3520000 	cmp	r2, #0
8f628428:	1a000020 	bne	8f6284b0 <read_device_info_mmc+0x138>
		ret = mmc_read((ptn + size - device_info_sz), (void *)info_buf, device_info_sz);
8f62842c:	e0555003 	subs	r5, r5, r3
8f628430:	e3022cfc 	movw	r2, #11516	; 0x2cfc
8f628434:	e3482f74 	movt	r2, #36724	; 0x8f74
8f628438:	e2c77000 	sbc	r7, r7, #0
8f62843c:	e0950000 	adds	r0, r5, r0
8f628440:	e5922000 	ldr	r2, [r2]
8f628444:	e0a11007 	adc	r1, r1, r7
8f628448:	ebff920e 	bl	8f60cc88 <mmc_read>
	if (ret)
8f62844c:	e3500000 	cmp	r0, #0
8f628450:	0affffda 	beq	8f6283c0 <read_device_info_mmc+0x48>
		dprintf(CRITICAL, "ERROR: Cannot read device info\n");
8f628454:	e3080fc0 	movw	r0, #36800	; 0x8fc0
8f628458:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62845c:	eb002944 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f628460:	e307cf64 	movw	r12, #32612	; 0x7f64
8f628464:	e30824b0 	movw	r2, #33968	; 0x84b0
8f628468:	e348cf70 	movt	r12, #36720	; 0x8f70
8f62846c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f628470:	e3001130 	movw	r1, #304	; 0x130
8f628474:	e3003a1e 	movw	r3, #2590	; 0xa1e
8f628478:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62847c:	e1a00006 	mov	r0, r6
8f628480:	e58dc000 	str	r12, [r13]
8f628484:	eb00298c 	bl	8f632abc <_panic>
8f628488:	eaffffcc 	b	8f6283c0 <read_device_info_mmc+0x48>
		devinfo_present = false;
8f62848c:	e30234c0 	movw	r3, #9408	; 0x24c0
8f628490:	e3483f71 	movt	r3, #36721	; 0x8f71
		index = partition_get_index("aboot");
8f628494:	e3000d0c 	movw	r0, #3340	; 0xd0c
8f628498:	e3480f70 	movt	r0, #36720	; 0x8f70
		devinfo_present = false;
8f62849c:	e3a02000 	mov	r2, #0
8f6284a0:	e5832000 	str	r2, [r3]
		index = partition_get_index("aboot");
8f6284a4:	ebff6df8 	bl	8f603c8c <partition_get_index>
8f6284a8:	e1a04000 	mov	r4, r0
8f6284ac:	eaffffbd 	b	8f6283a8 <read_device_info_mmc+0x30>
		ret = mmc_read(ptn, (void *)info_buf, device_info_sz);
8f6284b0:	e3022cfc 	movw	r2, #11516	; 0x2cfc
8f6284b4:	e3482f74 	movt	r2, #36724	; 0x8f74
8f6284b8:	e1a00005 	mov	r0, r5
8f6284bc:	e1a01007 	mov	r1, r7
8f6284c0:	e5922000 	ldr	r2, [r2]
8f6284c4:	ebff91ef 	bl	8f60cc88 <mmc_read>
8f6284c8:	eaffffdf 	b	8f62844c <read_device_info_mmc+0xd4>
		dprintf(CRITICAL, "ERROR: Incorrect blocksize of card\n");
8f6284cc:	e59f3028 	ldr	r3, [pc, #40]	; 8f6284fc <read_device_info_mmc+0x184>
8f6284d0:	e5932000 	ldr	r2, [r3]
8f6284d4:	e59d300c 	ldr	r3, [r13, #12]
8f6284d8:	e0332002 	eors	r2, r3, r2
8f6284dc:	e3a03000 	mov	r3, #0
8f6284e0:	1a000004 	bne	8f6284f8 <read_device_info_mmc+0x180>
8f6284e4:	e3080f9c 	movw	r0, #36764	; 0x8f9c
8f6284e8:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f6284ec:	e28dd014 	add	r13, r13, #20
8f6284f0:	e8bd40f0 	pop	{r4, r5, r6, r7, r14}
		dprintf(CRITICAL, "ERROR: Incorrect blocksize of card\n");
8f6284f4:	ea00291e 	b	8f632974 <_dprintf>
}
8f6284f8:	eb0029b0 	bl	8f632bc0 <__stack_chk_fail>
8f6284fc:	8f74221c 	.word	0x8f74221c

8f628500 <read_device_info_flash>:
{
8f628500:	e59f31b4 	ldr	r3, [pc, #436]	; 8f6286bc <read_device_info_flash+0x1bc>
	struct device_info *info = memalign(PAGE_SIZE, ROUNDUP(BOOT_IMG_MAX_PAGE_SIZE, PAGE_SIZE));
8f628504:	e3a01a01 	mov	r1, #4096	; 0x1000
{
8f628508:	e92d4070 	push	{r4, r5, r6, r14}
8f62850c:	e1a06000 	mov	r6, r0
8f628510:	e24dd010 	sub	r13, r13, #16
	struct device_info *info = memalign(PAGE_SIZE, ROUNDUP(BOOT_IMG_MAX_PAGE_SIZE, PAGE_SIZE));
8f628514:	e1a00001 	mov	r0, r1
{
8f628518:	e5933000 	ldr	r3, [r3]
8f62851c:	e58d300c 	str	r3, [r13, #12]
8f628520:	e3a03000 	mov	r3, #0
	struct device_info *info = memalign(PAGE_SIZE, ROUNDUP(BOOT_IMG_MAX_PAGE_SIZE, PAGE_SIZE));
8f628524:	e1a0500e 	mov	r5, r14
8f628528:	eb002ec5 	bl	8f634044 <memalign>
	if(info == NULL)
8f62852c:	e2504000 	subs	r4, r0, #0
8f628530:	0a000053 	beq	8f628684 <read_device_info_flash+0x184>
	info_buf = info;
8f628534:	e3025cfc 	movw	r5, #11516	; 0x2cfc
8f628538:	e3485f74 	movt	r5, #36724	; 0x8f74
8f62853c:	e5854000 	str	r4, [r5]
	ptable = flash_get_ptable();
8f628540:	ebffaaa0 	bl	8f612fc8 <flash_get_ptable>
	if (ptable == NULL)
8f628544:	e3500000 	cmp	r0, #0
8f628548:	0a00002e 	beq	8f628608 <read_device_info_flash+0x108>
	ptn = ptable_find(ptable, "devinfo");
8f62854c:	e3081f94 	movw	r1, #36756	; 0x8f94
8f628550:	e3481f70 	movt	r1, #36720	; 0x8f70
8f628554:	eb0038f9 	bl	8f636940 <ptable_find>
	if (ptn == NULL)
8f628558:	e3500000 	cmp	r0, #0
8f62855c:	0a000034 	beq	8f628634 <read_device_info_flash+0x134>
	if (flash_read(ptn, 0, (void *)info_buf, page_size))
8f628560:	e3002684 	movw	r2, #1668	; 0x684
8f628564:	e3482f74 	movt	r2, #36724	; 0x8f74
8f628568:	e5953000 	ldr	r3, [r5]
8f62856c:	e5922000 	ldr	r2, [r2]
8f628570:	e58d2000 	str	r2, [r13]
8f628574:	e3a02000 	mov	r2, #0
8f628578:	e1a01002 	mov	r1, r2
8f62857c:	ebffaaa4 	bl	8f613014 <flash_read_ext>
8f628580:	e2505000 	subs	r5, r0, #0
8f628584:	1a000033 	bne	8f628658 <read_device_info_flash+0x158>
	if (memcmp(info->magic, DEVICE_MAGIC, DEVICE_MAGIC_SIZE))
8f628588:	e3a0200d 	mov	r2, #13
8f62858c:	e3091028 	movw	r1, #36904	; 0x9028
8f628590:	e1a00004 	mov	r0, r4
8f628594:	e3481f70 	movt	r1, #36720	; 0x8f70
8f628598:	eb002f8e 	bl	8f6343d8 <memcmp>
8f62859c:	e3500000 	cmp	r0, #0
8f6285a0:	1a00000d 	bne	8f6285dc <read_device_info_flash+0xdc>
	memcpy(dev, info, sizeof(device_info));
8f6285a4:	e3a02e9f 	mov	r2, #2544	; 0x9f0
8f6285a8:	e1a01004 	mov	r1, r4
8f6285ac:	e1a00006 	mov	r0, r6
8f6285b0:	eb002f00 	bl	8f6341b8 <memcpy>
	free(info);
8f6285b4:	e59f3100 	ldr	r3, [pc, #256]	; 8f6286bc <read_device_info_flash+0x1bc>
8f6285b8:	e5932000 	ldr	r2, [r3]
8f6285bc:	e59d300c 	ldr	r3, [r13, #12]
8f6285c0:	e0332002 	eors	r2, r3, r2
8f6285c4:	e3a03000 	mov	r3, #0
8f6285c8:	1a000021 	bne	8f628654 <read_device_info_flash+0x154>
8f6285cc:	e1a00004 	mov	r0, r4
}
8f6285d0:	e28dd010 	add	r13, r13, #16
8f6285d4:	e8bd4070 	pop	{r4, r5, r6, r14}
	free(info);
8f6285d8:	ea002ecb 	b	8f63410c <free>
		memcpy(info->magic, DEVICE_MAGIC, DEVICE_MAGIC_SIZE);
8f6285dc:	e3a0200d 	mov	r2, #13
8f6285e0:	e1a00004 	mov	r0, r4
8f6285e4:	e3091028 	movw	r1, #36904	; 0x9028
8f6285e8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6285ec:	eb002ef1 	bl	8f6341b8 <memcpy>
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f6285f0:	e3070510 	movw	r0, #29968	; 0x7510
		info->is_unlocked = 0;
8f6285f4:	e5845010 	str	r5, [r4, #16]
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f6285f8:	e3480f70 	movt	r0, #36720	; 0x8f70
		info->is_tampered = 0;
8f6285fc:	e5845014 	str	r5, [r4, #20]
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f628600:	eb0028db 	bl	8f632974 <_dprintf>
}
8f628604:	eaffffe6 	b	8f6285a4 <read_device_info_flash+0xa4>
		dprintf(CRITICAL, "ERROR: Partition table not found\n");
8f628608:	e59f30ac 	ldr	r3, [pc, #172]	; 8f6286bc <read_device_info_flash+0x1bc>
8f62860c:	e5932000 	ldr	r2, [r3]
8f628610:	e59d300c 	ldr	r3, [r13, #12]
8f628614:	e0332002 	eors	r2, r3, r2
8f628618:	e3a03000 	mov	r3, #0
8f62861c:	03080e04 	movweq	r0, #36356	; 0x8e04
8f628620:	03480f70 	movteq	r0, #36720	; 0x8f70
8f628624:	1a00000a 	bne	8f628654 <read_device_info_flash+0x154>
}
8f628628:	e28dd010 	add	r13, r13, #16
8f62862c:	e8bd4070 	pop	{r4, r5, r6, r14}
		dprintf(CRITICAL, "ERROR: No devinfo partition found\n");
8f628630:	ea0028cf 	b	8f632974 <_dprintf>
8f628634:	e59f3080 	ldr	r3, [pc, #128]	; 8f6286bc <read_device_info_flash+0x1bc>
8f628638:	e5932000 	ldr	r2, [r3]
8f62863c:	e59d300c 	ldr	r3, [r13, #12]
8f628640:	e0332002 	eors	r2, r3, r2
8f628644:	e3a03000 	mov	r3, #0
8f628648:	03080fe0 	movweq	r0, #36832	; 0x8fe0
8f62864c:	03480f70 	movteq	r0, #36720	; 0x8f70
8f628650:	0afffff4 	beq	8f628628 <read_device_info_flash+0x128>
	free(info);
8f628654:	eb002959 	bl	8f632bc0 <__stack_chk_fail>
		dprintf(CRITICAL, "ERROR: Cannot write device info\n");
8f628658:	e59f305c 	ldr	r3, [pc, #92]	; 8f6286bc <read_device_info_flash+0x1bc>
8f62865c:	e5932000 	ldr	r2, [r3]
8f628660:	e59d300c 	ldr	r3, [r13, #12]
8f628664:	e0332002 	eors	r2, r3, r2
8f628668:	e3a03000 	mov	r3, #0
8f62866c:	03090004 	movweq	r0, #36868	; 0x9004
8f628670:	03480f70 	movteq	r0, #36720	; 0x8f70
8f628674:	1afffff6 	bne	8f628654 <read_device_info_flash+0x154>
}
8f628678:	e28dd010 	add	r13, r13, #16
8f62867c:	e8bd4070 	pop	{r4, r5, r6, r14}
		dprintf(CRITICAL, "ERROR: No devinfo partition found\n");
8f628680:	ea0028bb 	b	8f632974 <_dprintf>
		dprintf(CRITICAL, "Failed to allocate memory for device info struct\n");
8f628684:	e308047c 	movw	r0, #33916	; 0x847c
8f628688:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62868c:	eb0028b8 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f628690:	e3071f64 	movw	r1, #32612	; 0x7f64
8f628694:	e30824b0 	movw	r2, #33968	; 0x84b0
8f628698:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62869c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6286a0:	e58d1000 	str	r1, [r13]
8f6286a4:	e3003aa7 	movw	r3, #2727	; 0xaa7
8f6286a8:	e1a00005 	mov	r0, r5
8f6286ac:	e3001130 	movw	r1, #304	; 0x130
8f6286b0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6286b4:	eb002900 	bl	8f632abc <_panic>
8f6286b8:	eaffff9d 	b	8f628534 <read_device_info_flash+0x34>
8f6286bc:	8f74221c 	.word	0x8f74221c

8f6286c0 <store_userkey>:
        if (!devinfo_present) {
8f6286c0:	e30234c0 	movw	r3, #9408	; 0x24c0
8f6286c4:	e3483f71 	movt	r3, #36721	; 0x8f71
{
8f6286c8:	e59f20bc 	ldr	r2, [pc, #188]	; 8f62878c <store_userkey+0xcc>
        if (!devinfo_present) {
8f6286cc:	e5933000 	ldr	r3, [r3]
{
8f6286d0:	e92d4030 	push	{r4, r5, r14}
        if (!devinfo_present) {
8f6286d4:	e3530000 	cmp	r3, #0
{
8f6286d8:	e24dd00c 	sub	r13, r13, #12
8f6286dc:	e5922000 	ldr	r2, [r2]
8f6286e0:	e58d2004 	str	r2, [r13, #4]
8f6286e4:	e3a02000 	mov	r2, #0
        if (!devinfo_present) {
8f6286e8:	0a000021 	beq	8f628774 <store_userkey+0xb4>
        if (user_key_size > ARRAY_SIZE(device.user_public_key)) {
8f6286ec:	e3510b02 	cmp	r1, #2048	; 0x800
8f6286f0:	e1a04001 	mov	r4, r1
8f6286f4:	8a000019 	bhi	8f628760 <store_userkey+0xa0>
        memcpy(device.user_public_key, user_key, user_key_size);
8f6286f8:	e3015ad0 	movw	r5, #6864	; 0x1ad0
8f6286fc:	e3485f71 	movt	r5, #36721	; 0x8f71
8f628700:	e1a01000 	mov	r1, r0
8f628704:	e1a02004 	mov	r2, r4
8f628708:	e2850f7b 	add	r0, r5, #492	; 0x1ec
8f62870c:	eb002ea9 	bl	8f6341b8 <memcpy>
        device.user_public_key_length = user_key_size;
8f628710:	e58541e8 	str	r4, [r5, #488]	; 0x1e8
	if(target_is_emmc_boot())
8f628714:	ebffe4d9 	bl	8f621a80 <target_is_emmc_boot>
8f628718:	e2504000 	subs	r4, r0, #0
8f62871c:	1a00000b 	bne	8f628750 <store_userkey+0x90>
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f628720:	e3070510 	movw	r0, #29968	; 0x7510
8f628724:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628728:	eb002891 	bl	8f632974 <_dprintf>
}
8f62872c:	e59f3058 	ldr	r3, [pc, #88]	; 8f62878c <store_userkey+0xcc>
8f628730:	e5932000 	ldr	r2, [r3]
8f628734:	e59d3004 	ldr	r3, [r13, #4]
8f628738:	e0332002 	eors	r2, r3, r2
8f62873c:	e3a03000 	mov	r3, #0
8f628740:	1a000010 	bne	8f628788 <store_userkey+0xc8>
8f628744:	e1a00004 	mov	r0, r4
8f628748:	e28dd00c 	add	r13, r13, #12
8f62874c:	e8bd8030 	pop	{r4, r5, r15}
8f628750:	e1a00005 	mov	r0, r5
        return 0;
8f628754:	e3a04000 	mov	r4, #0
8f628758:	ebfff536 	bl	8f625c38 <write_device_info.part.0>
8f62875c:	eafffff2 	b	8f62872c <store_userkey+0x6c>
                dprintf(CRITICAL, "StoreUserKey, UserKeySize too large!\n");
8f628760:	e3090084 	movw	r0, #36996	; 0x9084
8f628764:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628768:	eb002881 	bl	8f632974 <_dprintf>
                return -ENODEV;
8f62876c:	e3e04012 	mvn	r4, #18
8f628770:	eaffffed 	b	8f62872c <store_userkey+0x6c>
                dprintf(CRITICAL, "DeviceInfo not initalized \n");
8f628774:	e3090038 	movw	r0, #36920	; 0x9038
8f628778:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62877c:	eb00287c 	bl	8f632974 <_dprintf>
                return -EINVAL;
8f628780:	e3e04015 	mvn	r4, #21
8f628784:	eaffffe8 	b	8f62872c <store_userkey+0x6c>
}
8f628788:	eb00290c 	bl	8f632bc0 <__stack_chk_fail>
8f62878c:	8f74221c 	.word	0x8f74221c

8f628790 <erase_userkey>:
        if (!devinfo_present) {
8f628790:	e30234c0 	movw	r3, #9408	; 0x24c0
8f628794:	e3483f71 	movt	r3, #36721	; 0x8f71
{
8f628798:	e59f20a0 	ldr	r2, [pc, #160]	; 8f628840 <erase_userkey+0xb0>
        if (!devinfo_present) {
8f62879c:	e5933000 	ldr	r3, [r3]
{
8f6287a0:	e92d4070 	push	{r4, r5, r6, r14}
        if (!devinfo_present) {
8f6287a4:	e3530000 	cmp	r3, #0
{
8f6287a8:	e24dd008 	sub	r13, r13, #8
8f6287ac:	e5922000 	ldr	r2, [r2]
8f6287b0:	e58d2004 	str	r2, [r13, #4]
8f6287b4:	e3a02000 	mov	r2, #0
        if (!devinfo_present) {
8f6287b8:	0a00001a 	beq	8f628828 <erase_userkey+0x98>
        memset(device.user_public_key, 0, ARRAY_SIZE(device.user_public_key));
8f6287bc:	e3015ad0 	movw	r5, #6864	; 0x1ad0
8f6287c0:	e3485f71 	movt	r5, #36721	; 0x8f71
8f6287c4:	e3a01000 	mov	r1, #0
8f6287c8:	e3a02b02 	mov	r2, #2048	; 0x800
8f6287cc:	e2850f7b 	add	r0, r5, #492	; 0x1ec
        device.user_public_key_length = 0;
8f6287d0:	e1a06001 	mov	r6, r1
        memset(device.user_public_key, 0, ARRAY_SIZE(device.user_public_key));
8f6287d4:	eb002eba 	bl	8f6342c4 <memset>
        device.user_public_key_length = 0;
8f6287d8:	e58561e8 	str	r6, [r5, #488]	; 0x1e8
	if(target_is_emmc_boot())
8f6287dc:	ebffe4a7 	bl	8f621a80 <target_is_emmc_boot>
8f6287e0:	e2504000 	subs	r4, r0, #0
8f6287e4:	1a00000b 	bne	8f628818 <erase_userkey+0x88>
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f6287e8:	e3070510 	movw	r0, #29968	; 0x7510
8f6287ec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6287f0:	eb00285f 	bl	8f632974 <_dprintf>
}
8f6287f4:	e59f3044 	ldr	r3, [pc, #68]	; 8f628840 <erase_userkey+0xb0>
8f6287f8:	e5932000 	ldr	r2, [r3]
8f6287fc:	e59d3004 	ldr	r3, [r13, #4]
8f628800:	e0332002 	eors	r2, r3, r2
8f628804:	e3a03000 	mov	r3, #0
8f628808:	1a00000b 	bne	8f62883c <erase_userkey+0xac>
8f62880c:	e1a00004 	mov	r0, r4
8f628810:	e28dd008 	add	r13, r13, #8
8f628814:	e8bd8070 	pop	{r4, r5, r6, r15}
8f628818:	e1a00005 	mov	r0, r5
        return 0;
8f62881c:	e1a04006 	mov	r4, r6
8f628820:	ebfff504 	bl	8f625c38 <write_device_info.part.0>
8f628824:	eafffff2 	b	8f6287f4 <erase_userkey+0x64>
                dprintf(CRITICAL, "DeviceInfo not initalized \n");
8f628828:	e3090038 	movw	r0, #36920	; 0x9038
8f62882c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628830:	eb00284f 	bl	8f632974 <_dprintf>
                return -EINVAL;
8f628834:	e3e04015 	mvn	r4, #21
8f628838:	eaffffed 	b	8f6287f4 <erase_userkey+0x64>
}
8f62883c:	eb0028df 	bl	8f632bc0 <__stack_chk_fail>
8f628840:	8f74221c 	.word	0x8f74221c

8f628844 <read_device_info>:
{
8f628844:	e59f31d0 	ldr	r3, [pc, #464]	; 8f628a1c <read_device_info+0x1d8>
8f628848:	e92d4070 	push	{r4, r5, r6, r14}
8f62884c:	e24dd010 	sub	r13, r13, #16
8f628850:	e5933000 	ldr	r3, [r3]
8f628854:	e58d300c 	str	r3, [r13, #12]
8f628858:	e3a03000 	mov	r3, #0
	if(target_is_emmc_boot())
8f62885c:	e1a0600e 	mov	r6, r14
{
8f628860:	e1a05000 	mov	r5, r0
	if(target_is_emmc_boot())
8f628864:	ebffe485 	bl	8f621a80 <target_is_emmc_boot>
8f628868:	e3500000 	cmp	r0, #0
8f62886c:	0a00002b 	beq	8f628920 <read_device_info+0xdc>
		struct device_info *info = memalign(PAGE_SIZE, ROUNDUP(BOOT_IMG_MAX_PAGE_SIZE, PAGE_SIZE));
8f628870:	e3a01a01 	mov	r1, #4096	; 0x1000
8f628874:	e1a00001 	mov	r0, r1
8f628878:	eb002df1 	bl	8f634044 <memalign>
		if(info == NULL)
8f62887c:	e2504000 	subs	r4, r0, #0
8f628880:	0a000056 	beq	8f6289e0 <read_device_info+0x19c>
		info_buf = info;
8f628884:	e3023cfc 	movw	r3, #11516	; 0x2cfc
8f628888:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62888c:	e5834000 	str	r4, [r3]
		if (VB_M <= target_get_vb_version() &&
8f628890:	ebffe588 	bl	8f621eb8 <target_get_vb_version>
8f628894:	e3500001 	cmp	r0, #1
8f628898:	da000002 	ble	8f6288a8 <read_device_info+0x64>
			is_secure_boot_enable()) {
8f62889c:	ebffb256 	bl	8f6151fc <is_secure_boot_enable>
		if (VB_M <= target_get_vb_version() &&
8f6288a0:	e3500000 	cmp	r0, #0
8f6288a4:	1a000027 	bne	8f628948 <read_device_info+0x104>
			read_device_info_mmc(info);
8f6288a8:	e1a00004 	mov	r0, r4
8f6288ac:	ebfffeb1 	bl	8f628378 <read_device_info_mmc>
		if (memcmp(info->magic, DEVICE_MAGIC, DEVICE_MAGIC_SIZE))
8f6288b0:	e3a0200d 	mov	r2, #13
8f6288b4:	e3091028 	movw	r1, #36904	; 0x9028
8f6288b8:	e1a00004 	mov	r0, r4
8f6288bc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6288c0:	eb002ec4 	bl	8f6343d8 <memcmp>
8f6288c4:	e3500000 	cmp	r0, #0
8f6288c8:	1a00002e 	bne	8f628988 <read_device_info+0x144>
		memcpy(dev, info, sizeof(device_info));
8f6288cc:	e3a02e9f 	mov	r2, #2544	; 0x9f0
8f6288d0:	e1a01004 	mov	r1, r4
8f6288d4:	e1a00005 	mov	r0, r5
8f6288d8:	eb002e36 	bl	8f6341b8 <memcpy>
		free(info);
8f6288dc:	e1a00004 	mov	r0, r4
8f6288e0:	eb002e09 	bl	8f63410c <free>
	if (lk2nd_dev.bootloader) {
8f6288e4:	e301313c 	movw	r3, #4412	; 0x113c
8f6288e8:	e3483f74 	movt	r3, #36724	; 0x8f74
8f6288ec:	e5931010 	ldr	r1, [r3, #16]
		strcpy(dev->bootloader_version, lk2nd_dev.bootloader);
8f6288f0:	e59f3124 	ldr	r3, [pc, #292]	; 8f628a1c <read_device_info+0x1d8>
	if (lk2nd_dev.bootloader) {
8f6288f4:	e3510000 	cmp	r1, #0
8f6288f8:	0a00000b 	beq	8f62892c <read_device_info+0xe8>
		strcpy(dev->bootloader_version, lk2nd_dev.bootloader);
8f6288fc:	e5932000 	ldr	r2, [r3]
8f628900:	e59d300c 	ldr	r3, [r13, #12]
8f628904:	e0332002 	eors	r2, r3, r2
8f628908:	e3a03000 	mov	r3, #0
8f62890c:	1a000041 	bne	8f628a18 <read_device_info+0x1d4>
8f628910:	e2850060 	add	r0, r5, #96	; 0x60
}
8f628914:	e28dd010 	add	r13, r13, #16
8f628918:	e8bd4070 	pop	{r4, r5, r6, r14}
		strcpy(dev->bootloader_version, lk2nd_dev.bootloader);
8f62891c:	ea002f1c 	b	8f634594 <strcpy>
		read_device_info_flash(dev);
8f628920:	e1a00005 	mov	r0, r5
8f628924:	ebfffef5 	bl	8f628500 <read_device_info_flash>
8f628928:	eaffffed 	b	8f6288e4 <read_device_info+0xa0>
}
8f62892c:	e5932000 	ldr	r2, [r3]
8f628930:	e59d300c 	ldr	r3, [r13, #12]
8f628934:	e0332002 	eors	r2, r3, r2
8f628938:	e3a03000 	mov	r3, #0
8f62893c:	1a000035 	bne	8f628a18 <read_device_info+0x1d4>
8f628940:	e28dd010 	add	r13, r13, #16
8f628944:	e8bd8070 	pop	{r4, r5, r6, r15}
				if((read_device_info_rpmb((void*) info, PAGE_SIZE)) < 0)
8f628948:	e3a01a01 	mov	r1, #4096	; 0x1000
8f62894c:	e1a00004 	mov	r0, r4
8f628950:	ebffdf62 	bl	8f6206e0 <read_device_info_rpmb>
8f628954:	e3500000 	cmp	r0, #0
8f628958:	aaffffd4 	bge	8f6288b0 <read_device_info+0x6c>
					ASSERT(0);
8f62895c:	e3072f64 	movw	r2, #32612	; 0x7f64
8f628960:	e3003b43 	movw	r3, #2883	; 0xb43
8f628964:	e3482f70 	movt	r2, #36720	; 0x8f70
8f628968:	e1a00006 	mov	r0, r6
8f62896c:	e58d2000 	str	r2, [r13]
8f628970:	e3001130 	movw	r1, #304	; 0x130
8f628974:	e30824b0 	movw	r2, #33968	; 0x84b0
8f628978:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62897c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f628980:	eb00284d 	bl	8f632abc <_panic>
8f628984:	eaffffc9 	b	8f6288b0 <read_device_info+0x6c>
			memcpy(info->magic, DEVICE_MAGIC, DEVICE_MAGIC_SIZE);
8f628988:	e3a0200d 	mov	r2, #13
8f62898c:	e3091028 	movw	r1, #36904	; 0x9028
8f628990:	e1a00004 	mov	r0, r4
8f628994:	e3481f70 	movt	r1, #36720	; 0x8f70
8f628998:	eb002e06 	bl	8f6341b8 <memcpy>
			if (is_secure_boot_enable()) {
8f62899c:	ebffb216 	bl	8f6151fc <is_secure_boot_enable>
			info->is_tampered = 0;
8f6289a0:	e3a03000 	mov	r3, #0
8f6289a4:	e5843014 	str	r3, [r4, #20]
			info->charger_screen_enabled = 0;
8f6289a8:	e584301c 	str	r3, [r4, #28]
			if (is_secure_boot_enable()) {
8f6289ac:	e16f0f10 	clz	r0, r0
8f6289b0:	e1a002a0 	lsr	r0, r0, #5
8f6289b4:	e5840010 	str	r0, [r4, #16]
	if(target_is_emmc_boot())
8f6289b8:	ebffe430 	bl	8f621a80 <target_is_emmc_boot>
8f6289bc:	e3500000 	cmp	r0, #0
8f6289c0:	0a000002 	beq	8f6289d0 <read_device_info+0x18c>
8f6289c4:	e1a00004 	mov	r0, r4
8f6289c8:	ebfff49a 	bl	8f625c38 <write_device_info.part.0>
8f6289cc:	eaffffbe 	b	8f6288cc <read_device_info+0x88>
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f6289d0:	e3070510 	movw	r0, #29968	; 0x7510
8f6289d4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6289d8:	eb0027e5 	bl	8f632974 <_dprintf>
}
8f6289dc:	eaffffba 	b	8f6288cc <read_device_info+0x88>
			dprintf(CRITICAL, "Failed to allocate memory for device info struct\n");
8f6289e0:	e308047c 	movw	r0, #33916	; 0x847c
8f6289e4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6289e8:	eb0027e1 	bl	8f632974 <_dprintf>
			ASSERT(0);
8f6289ec:	e3071f64 	movw	r1, #32612	; 0x7f64
8f6289f0:	e30824b0 	movw	r2, #33968	; 0x84b0
8f6289f4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6289f8:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6289fc:	e58d1000 	str	r1, [r13]
8f628a00:	e3003b3b 	movw	r3, #2875	; 0xb3b
8f628a04:	e3001130 	movw	r1, #304	; 0x130
8f628a08:	e1a00006 	mov	r0, r6
8f628a0c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f628a10:	eb002829 	bl	8f632abc <_panic>
8f628a14:	eaffff9a 	b	8f628884 <read_device_info+0x40>
}
8f628a18:	eb002868 	bl	8f632bc0 <__stack_chk_fail>
8f628a1c:	8f74221c 	.word	0x8f74221c

8f628a20 <reset_device_info>:
{
8f628a20:	e92d4010 	push	{r4, r14}
	device.is_tampered = 0;
8f628a24:	e3014ad0 	movw	r4, #6864	; 0x1ad0
{
8f628a28:	e59f3084 	ldr	r3, [pc, #132]	; 8f628ab4 <reset_device_info+0x94>
	device.is_tampered = 0;
8f628a2c:	e3484f71 	movt	r4, #36721	; 0x8f71
{
8f628a30:	e24dd008 	sub	r13, r13, #8
	dprintf(ALWAYS, "reset_device_info called.");
8f628a34:	e30900ac 	movw	r0, #37036	; 0x90ac
8f628a38:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f628a3c:	e5933000 	ldr	r3, [r3]
8f628a40:	e58d3004 	str	r3, [r13, #4]
8f628a44:	e3a03000 	mov	r3, #0
	dprintf(ALWAYS, "reset_device_info called.");
8f628a48:	eb0027c9 	bl	8f632974 <_dprintf>
	device.is_tampered = 0;
8f628a4c:	e3a03000 	mov	r3, #0
8f628a50:	e5843014 	str	r3, [r4, #20]
	if(target_is_emmc_boot())
8f628a54:	ebffe409 	bl	8f621a80 <target_is_emmc_boot>
8f628a58:	e59f3054 	ldr	r3, [pc, #84]	; 8f628ab4 <reset_device_info+0x94>
8f628a5c:	e3500000 	cmp	r0, #0
8f628a60:	0a000008 	beq	8f628a88 <reset_device_info+0x68>
8f628a64:	e5932000 	ldr	r2, [r3]
8f628a68:	e59d3004 	ldr	r3, [r13, #4]
8f628a6c:	e0332002 	eors	r2, r3, r2
8f628a70:	e3a03000 	mov	r3, #0
8f628a74:	1a00000d 	bne	8f628ab0 <reset_device_info+0x90>
8f628a78:	e1a00004 	mov	r0, r4
}
8f628a7c:	e28dd008 	add	r13, r13, #8
8f628a80:	e8bd4010 	pop	{r4, r14}
8f628a84:	eafff46b 	b	8f625c38 <write_device_info.part.0>
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f628a88:	e5932000 	ldr	r2, [r3]
8f628a8c:	e59d3004 	ldr	r3, [r13, #4]
8f628a90:	e0332002 	eors	r2, r3, r2
8f628a94:	e3a03000 	mov	r3, #0
8f628a98:	1a000004 	bne	8f628ab0 <reset_device_info+0x90>
8f628a9c:	e3070510 	movw	r0, #29968	; 0x7510
8f628aa0:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f628aa4:	e28dd008 	add	r13, r13, #8
8f628aa8:	e8bd4010 	pop	{r4, r14}
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f628aac:	ea0027b0 	b	8f632974 <_dprintf>
8f628ab0:	eb002842 	bl	8f632bc0 <__stack_chk_fail>
8f628ab4:	8f74221c 	.word	0x8f74221c

8f628ab8 <set_device_root>:
{
8f628ab8:	e92d4010 	push	{r4, r14}
	device.is_tampered = 1;
8f628abc:	e3014ad0 	movw	r4, #6864	; 0x1ad0
{
8f628ac0:	e59f3084 	ldr	r3, [pc, #132]	; 8f628b4c <set_device_root+0x94>
	device.is_tampered = 1;
8f628ac4:	e3484f71 	movt	r4, #36721	; 0x8f71
{
8f628ac8:	e24dd008 	sub	r13, r13, #8
	dprintf(ALWAYS, "set_device_root called.");
8f628acc:	e30900c8 	movw	r0, #37064	; 0x90c8
8f628ad0:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f628ad4:	e5933000 	ldr	r3, [r3]
8f628ad8:	e58d3004 	str	r3, [r13, #4]
8f628adc:	e3a03000 	mov	r3, #0
	dprintf(ALWAYS, "set_device_root called.");
8f628ae0:	eb0027a3 	bl	8f632974 <_dprintf>
	device.is_tampered = 1;
8f628ae4:	e3a03001 	mov	r3, #1
8f628ae8:	e5843014 	str	r3, [r4, #20]
	if(target_is_emmc_boot())
8f628aec:	ebffe3e3 	bl	8f621a80 <target_is_emmc_boot>
8f628af0:	e59f3054 	ldr	r3, [pc, #84]	; 8f628b4c <set_device_root+0x94>
8f628af4:	e3500000 	cmp	r0, #0
8f628af8:	0a000008 	beq	8f628b20 <set_device_root+0x68>
8f628afc:	e5932000 	ldr	r2, [r3]
8f628b00:	e59d3004 	ldr	r3, [r13, #4]
8f628b04:	e0332002 	eors	r2, r3, r2
8f628b08:	e3a03000 	mov	r3, #0
8f628b0c:	1a00000d 	bne	8f628b48 <set_device_root+0x90>
8f628b10:	e1a00004 	mov	r0, r4
}
8f628b14:	e28dd008 	add	r13, r13, #8
8f628b18:	e8bd4010 	pop	{r4, r14}
8f628b1c:	eafff445 	b	8f625c38 <write_device_info.part.0>
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f628b20:	e5932000 	ldr	r2, [r3]
8f628b24:	e59d3004 	ldr	r3, [r13, #4]
8f628b28:	e0332002 	eors	r2, r3, r2
8f628b2c:	e3a03000 	mov	r3, #0
8f628b30:	1a000004 	bne	8f628b48 <set_device_root+0x90>
8f628b34:	e3070510 	movw	r0, #29968	; 0x7510
8f628b38:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f628b3c:	e28dd008 	add	r13, r13, #8
8f628b40:	e8bd4010 	pop	{r4, r14}
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f628b44:	ea00278a 	b	8f632974 <_dprintf>
8f628b48:	eb00281c 	bl	8f632bc0 <__stack_chk_fail>
8f628b4c:	8f74221c 	.word	0x8f74221c

8f628b50 <set_device_unlock_value>:
{
8f628b50:	e59f3084 	ldr	r3, [pc, #132]	; 8f628bdc <set_device_unlock_value+0x8c>
	if (type == UNLOCK)
8f628b54:	e3500000 	cmp	r0, #0
{
8f628b58:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f628b5c:	e24dd00c 	sub	r13, r13, #12
8f628b60:	e5933000 	ldr	r3, [r3]
8f628b64:	e58d3004 	str	r3, [r13, #4]
8f628b68:	e3a03000 	mov	r3, #0
		device.is_unlocked = status;
8f628b6c:	03013ad0 	movweq	r3, #6864	; 0x1ad0
8f628b70:	03483f71 	movteq	r3, #36721	; 0x8f71
8f628b74:	05831010 	streq	r1, [r3, #16]
	if(target_is_emmc_boot())
8f628b78:	ebffe3c0 	bl	8f621a80 <target_is_emmc_boot>
8f628b7c:	e59f3058 	ldr	r3, [pc, #88]	; 8f628bdc <set_device_unlock_value+0x8c>
8f628b80:	e3500000 	cmp	r0, #0
8f628b84:	0a000009 	beq	8f628bb0 <set_device_unlock_value+0x60>
8f628b88:	e5932000 	ldr	r2, [r3]
8f628b8c:	e59d3004 	ldr	r3, [r13, #4]
8f628b90:	e0332002 	eors	r2, r3, r2
8f628b94:	e3a03000 	mov	r3, #0
8f628b98:	1a00000e 	bne	8f628bd8 <set_device_unlock_value+0x88>
8f628b9c:	e3010ad0 	movw	r0, #6864	; 0x1ad0
8f628ba0:	e3480f71 	movt	r0, #36721	; 0x8f71
}
8f628ba4:	e28dd00c 	add	r13, r13, #12
8f628ba8:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
8f628bac:	eafff421 	b	8f625c38 <write_device_info.part.0>
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f628bb0:	e5932000 	ldr	r2, [r3]
8f628bb4:	e59d3004 	ldr	r3, [r13, #4]
8f628bb8:	e0332002 	eors	r2, r3, r2
8f628bbc:	e3a03000 	mov	r3, #0
8f628bc0:	1a000004 	bne	8f628bd8 <set_device_unlock_value+0x88>
8f628bc4:	e3070510 	movw	r0, #29968	; 0x7510
8f628bc8:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f628bcc:	e28dd00c 	add	r13, r13, #12
8f628bd0:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f628bd4:	ea002766 	b	8f632974 <_dprintf>
8f628bd8:	eb0027f8 	bl	8f632bc0 <__stack_chk_fail>
8f628bdc:	8f74221c 	.word	0x8f74221c

8f628be0 <copy_dtb>:
{
8f628be0:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f628be4:	e1a05000 	mov	r5, r0
	dt_size = hdr->dt_size;
8f628be8:	e5900028 	ldr	r0, [r0, #40]	; 0x28
{
8f628bec:	e24dd044 	sub	r13, r13, #68	; 0x44
	uint32_t dt_hdr_size = 0;
8f628bf0:	e3a02000 	mov	r2, #0
{
8f628bf4:	e59f328c 	ldr	r3, [pc, #652]	; 8f628e88 <copy_dtb+0x2a8>
	dt_size = hdr->dt_size;
8f628bf8:	e3058200 	movw	r8, #20992	; 0x5200
	if(dt_size != 0) {
8f628bfc:	e1500002 	cmp	r0, r2
	dt_size = hdr->dt_size;
8f628c00:	e3488f73 	movt	r8, #36723	; 0x8f73
8f628c04:	e5880000 	str	r0, [r8]
{
8f628c08:	e5933000 	ldr	r3, [r3]
8f628c0c:	e58d303c 	str	r3, [r13, #60]	; 0x3c
8f628c10:	e3a03000 	mov	r3, #0
	uint32_t dt_hdr_size = 0;
8f628c14:	e58d2008 	str	r2, [r13, #8]
	unsigned int compressed_size = 0;
8f628c18:	e58d200c 	str	r2, [r13, #12]
	unsigned int dtb_size = 0;
8f628c1c:	e58d2010 	str	r2, [r13, #16]
	if(dt_size != 0) {
8f628c20:	0a00008b 	beq	8f628e54 <copy_dtb+0x274>
		dt_image_offset += page_size;
8f628c24:	e3003684 	movw	r3, #1668	; 0x684
8f628c28:	e3483f74 	movt	r3, #36724	; 0x8f74
		n = ROUND_TO_PAGE(hdr->kernel_size, page_mask);
8f628c2c:	e595c008 	ldr	r12, [r5, #8]
8f628c30:	e1a06001 	mov	r6, r1
		dt_image_offset += page_size;
8f628c34:	e5934000 	ldr	r4, [r3]
		n = ROUND_TO_PAGE(hdr->kernel_size, page_mask);
8f628c38:	e3003680 	movw	r3, #1664	; 0x680
8f628c3c:	e3483f74 	movt	r3, #36724	; 0x8f74
		n = ROUND_TO_PAGE(hdr->ramdisk_size, page_mask);
8f628c40:	e5950010 	ldr	r0, [r5, #16]
		if(hdr->second_size != 0) {
8f628c44:	e5951018 	ldr	r1, [r5, #24]
8f628c48:	e1a0700e 	mov	r7, r14
		n = ROUND_TO_PAGE(hdr->kernel_size, page_mask);
8f628c4c:	e5932000 	ldr	r2, [r3]
8f628c50:	e08c3002 	add	r3, r12, r2
8f628c54:	e1c33002 	bic	r3, r3, r2
8f628c58:	e15c0003 	cmp	r12, r3
8f628c5c:	83e03000 	mvnhi	r3, #0
		dt_image_offset += n;
8f628c60:	e0843003 	add	r3, r4, r3
		n = ROUND_TO_PAGE(hdr->ramdisk_size, page_mask);
8f628c64:	e0824000 	add	r4, r2, r0
8f628c68:	e1c44002 	bic	r4, r4, r2
8f628c6c:	e1500004 	cmp	r0, r4
8f628c70:	83e04000 	mvnhi	r4, #0
		if(hdr->second_size != 0) {
8f628c74:	e3510000 	cmp	r1, #0
		dt_image_offset += n;
8f628c78:	e0844003 	add	r4, r4, r3
		n = ROUND_TO_PAGE(hdr->kernel_size, page_mask);
8f628c7c:	e1e03002 	mvn	r3, r2
		if(hdr->second_size != 0) {
8f628c80:	1a000035 	bne	8f628d5c <copy_dtb+0x17c>
		table = (struct dt_table*)(boot_image_start + dt_image_offset);
8f628c84:	e0859004 	add	r9, r5, r4
		if (dev_tree_validate(table, hdr->page_size, &dt_hdr_size) != 0) {
8f628c88:	e5951024 	ldr	r1, [r5, #36]	; 0x24
8f628c8c:	e28d2008 	add	r2, r13, #8
8f628c90:	e1a00009 	mov	r0, r9
8f628c94:	ebffbfe8 	bl	8f618c3c <dev_tree_validate>
8f628c98:	e3500000 	cmp	r0, #0
8f628c9c:	1a000073 	bne	8f628e70 <copy_dtb+0x290>
		if (dt_hdr_size > ROUND_TO_PAGE(dt_size,hdr->page_size)) {
8f628ca0:	e5982000 	ldr	r2, [r8]
8f628ca4:	e5951024 	ldr	r1, [r5, #36]	; 0x24
8f628ca8:	e0813002 	add	r3, r1, r2
8f628cac:	e1c33001 	bic	r3, r3, r1
8f628cb0:	e1520003 	cmp	r2, r3
8f628cb4:	9a00002e 	bls	8f628d74 <copy_dtb+0x194>
		if(dev_tree_get_entry_info(table, &dt_entry) != 0){
8f628cb8:	e28d1014 	add	r1, r13, #20
8f628cbc:	e1a00009 	mov	r0, r9
8f628cc0:	ebffc011 	bl	8f618d0c <dev_tree_get_entry_info>
8f628cc4:	e3500000 	cmp	r0, #0
8f628cc8:	1a000063 	bne	8f628e5c <copy_dtb+0x27c>
		best_match_dt_addr = (unsigned char *)boot_image_start + dt_image_offset + dt_entry.offset;
8f628ccc:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
		if (is_gzip_package(best_match_dt_addr, dt_entry.size))
8f628cd0:	e59d1038 	ldr	r1, [r13, #56]	; 0x38
		best_match_dt_addr = (unsigned char *)boot_image_start + dt_image_offset + dt_entry.offset;
8f628cd4:	e0844003 	add	r4, r4, r3
8f628cd8:	e0854004 	add	r4, r5, r4
		if (is_gzip_package(best_match_dt_addr, dt_entry.size))
8f628cdc:	e1a00004 	mov	r0, r4
8f628ce0:	eb0049e9 	bl	8f63b48c <is_gzip_package>
8f628ce4:	e3500000 	cmp	r0, #0
			dtb_size = dt_entry.size;
8f628ce8:	059d1038 	ldreq	r1, [r13, #56]	; 0x38
8f628cec:	058d1010 	streq	r1, [r13, #16]
		if (is_gzip_package(best_match_dt_addr, dt_entry.size))
8f628cf0:	1a000031 	bne	8f628dbc <copy_dtb+0x1dc>
		if (check_aboot_addr_range_overlap(hdr->tags_addr, dtb_size) ||
8f628cf4:	e5950020 	ldr	r0, [r5, #32]
	if ((UINT_MAX - start) < size)
8f628cf8:	e1e03000 	mvn	r3, r0
8f628cfc:	e1530001 	cmp	r3, r1
8f628d00:	3a000028 	bcc	8f628da8 <copy_dtb+0x1c8>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f628d04:	e30f3fff 	movw	r3, #65535	; 0xffff
8f628d08:	e3483f5f 	movt	r3, #36703	; 0x8f5f
8f628d0c:	e1500003 	cmp	r0, r3
8f628d10:	9a00001f 	bls	8f628d94 <copy_dtb+0x1b4>
	else if (start >= (MEMBASE + MEMSIZE))
8f628d14:	e3700217 	cmn	r0, #1879048193	; 0x70000001
8f628d18:	9a000022 	bls	8f628da8 <copy_dtb+0x1c8>
			check_ddr_addr_range_bound(hdr->tags_addr, dtb_size))
8f628d1c:	ebfff7d9 	bl	8f626c88 <check_ddr_addr_range_bound>
		if (check_aboot_addr_range_overlap(hdr->tags_addr, dtb_size) ||
8f628d20:	e2506000 	subs	r6, r0, #0
8f628d24:	1a00001f 	bne	8f628da8 <copy_dtb+0x1c8>
		memmove((void*) hdr->tags_addr, (void *)best_match_dt_addr, dtb_size);
8f628d28:	e59d2010 	ldr	r2, [r13, #16]
8f628d2c:	e1a01004 	mov	r1, r4
8f628d30:	e5950020 	ldr	r0, [r5, #32]
8f628d34:	eb002d1f 	bl	8f6341b8 <memcpy>
}
8f628d38:	e59f3148 	ldr	r3, [pc, #328]	; 8f628e88 <copy_dtb+0x2a8>
8f628d3c:	e5932000 	ldr	r2, [r3]
8f628d40:	e59d303c 	ldr	r3, [r13, #60]	; 0x3c
8f628d44:	e0332002 	eors	r2, r3, r2
8f628d48:	e3a03000 	mov	r3, #0
8f628d4c:	1a00004c 	bne	8f628e84 <copy_dtb+0x2a4>
8f628d50:	e1a00006 	mov	r0, r6
8f628d54:	e28dd044 	add	r13, r13, #68	; 0x44
8f628d58:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
			n = ROUND_TO_PAGE(hdr->second_size, page_mask);
8f628d5c:	e0822001 	add	r2, r2, r1
8f628d60:	e0022003 	and	r2, r2, r3
8f628d64:	e1510002 	cmp	r1, r2
8f628d68:	83e02000 	mvnhi	r2, #0
			dt_image_offset += n;
8f628d6c:	e0844002 	add	r4, r4, r2
8f628d70:	eaffffc3 	b	8f628c84 <copy_dtb+0xa4>
		if (dt_hdr_size > ROUND_TO_PAGE(dt_size,hdr->page_size)) {
8f628d74:	e59d2008 	ldr	r2, [r13, #8]
8f628d78:	e1530002 	cmp	r3, r2
8f628d7c:	2affffcd 	bcs	8f628cb8 <copy_dtb+0xd8>
			dprintf(CRITICAL, "ERROR: Invalid Device Tree size \n");
8f628d80:	e3080cb4 	movw	r0, #36020	; 0x8cb4
8f628d84:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628d88:	eb0026f9 	bl	8f632974 <_dprintf>
			return -1;
8f628d8c:	e3e06000 	mvn	r6, #0
8f628d90:	eaffffe8 	b	8f628d38 <copy_dtb+0x158>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f628d94:	e0802001 	add	r2, r0, r1
8f628d98:	e3a03000 	mov	r3, #0
8f628d9c:	e3483f60 	movt	r3, #36704	; 0x8f60
8f628da0:	e1520003 	cmp	r2, r3
8f628da4:	9affffdc 	bls	8f628d1c <copy_dtb+0x13c>
			dprintf(CRITICAL, "Device tree addresses are not valid.\n");
8f628da8:	e3080db0 	movw	r0, #36272	; 0x8db0
8f628dac:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628db0:	eb0026ef 	bl	8f632974 <_dprintf>
			return -1;
8f628db4:	e3e06000 	mvn	r6, #0
8f628db8:	eaffffde 	b	8f628d38 <copy_dtb+0x158>
			out_addr = (unsigned char *)target_get_scratch_address() + scratch_offset;
8f628dbc:	ebff6164 	bl	8f601354 <target_get_scratch_address>
8f628dc0:	e0808006 	add	r8, r0, r6
			out_avai_len = target_get_max_flash_size() - scratch_offset;
8f628dc4:	ebff6174 	bl	8f60139c <target_get_max_flash_size>
8f628dc8:	e0406006 	sub	r6, r0, r6
			dprintf(INFO, "decompressing dtb: start\n");
8f628dcc:	e3080d30 	movw	r0, #36144	; 0x8d30
8f628dd0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628dd4:	eb0026e6 	bl	8f632974 <_dprintf>
			rc = decompress(best_match_dt_addr,
8f628dd8:	e28d2010 	add	r2, r13, #16
8f628ddc:	e59d1038 	ldr	r1, [r13, #56]	; 0x38
8f628de0:	e1a03006 	mov	r3, r6
8f628de4:	e58d2004 	str	r2, [r13, #4]
8f628de8:	e1a00004 	mov	r0, r4
8f628dec:	e28d200c 	add	r2, r13, #12
8f628df0:	e58d2000 	str	r2, [r13]
8f628df4:	e1a02008 	mov	r2, r8
8f628df8:	eb004931 	bl	8f63b2c4 <decompress>
			if (rc)
8f628dfc:	e3500000 	cmp	r0, #0
8f628e00:	1a000005 	bne	8f628e1c <copy_dtb+0x23c>
			dprintf(INFO, "decompressing dtb: done\n");
8f628e04:	e3080d6c 	movw	r0, #36204	; 0x8d6c
8f628e08:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628e0c:	eb0026d8 	bl	8f632974 <_dprintf>
			best_match_dt_addr = out_addr;
8f628e10:	e1a04008 	mov	r4, r8
		if (check_aboot_addr_range_overlap(hdr->tags_addr, dtb_size) ||
8f628e14:	e59d1010 	ldr	r1, [r13, #16]
8f628e18:	eaffffb5 	b	8f628cf4 <copy_dtb+0x114>
				dprintf(CRITICAL, "decompressing dtb failed!!!\n");
8f628e1c:	e3080d4c 	movw	r0, #36172	; 0x8d4c
8f628e20:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628e24:	eb0026d2 	bl	8f632974 <_dprintf>
				ASSERT(0);
8f628e28:	e3071f64 	movw	r1, #32612	; 0x7f64
8f628e2c:	e30824b0 	movw	r2, #33968	; 0x84b0
8f628e30:	e3481f70 	movt	r1, #36720	; 0x8f70
8f628e34:	e3482f70 	movt	r2, #36720	; 0x8f70
8f628e38:	e58d1000 	str	r1, [r13]
8f628e3c:	e3003c18 	movw	r3, #3096	; 0xc18
8f628e40:	e1a00007 	mov	r0, r7
8f628e44:	e3001130 	movw	r1, #304	; 0x130
8f628e48:	e3481f70 	movt	r1, #36720	; 0x8f70
8f628e4c:	eb00271a 	bl	8f632abc <_panic>
8f628e50:	eaffffeb 	b	8f628e04 <copy_dtb+0x224>
		return -1;
8f628e54:	e3e06000 	mvn	r6, #0
8f628e58:	eaffffb6 	b	8f628d38 <copy_dtb+0x158>
			dprintf(CRITICAL, "ERROR: Getting device tree address failed\n");
8f628e5c:	e3080cd8 	movw	r0, #36056	; 0x8cd8
8f628e60:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628e64:	eb0026c2 	bl	8f632974 <_dprintf>
			return -1;
8f628e68:	e3e06000 	mvn	r6, #0
8f628e6c:	eaffffb1 	b	8f628d38 <copy_dtb+0x158>
			dprintf(CRITICAL, "ERROR: Cannot validate Device Tree Table \n");
8f628e70:	e3080c88 	movw	r0, #35976	; 0x8c88
8f628e74:	e3480f70 	movt	r0, #36720	; 0x8f70
8f628e78:	eb0026bd 	bl	8f632974 <_dprintf>
			return -1;
8f628e7c:	e3e06000 	mvn	r6, #0
8f628e80:	eaffffac 	b	8f628d38 <copy_dtb+0x158>
}
8f628e84:	eb00274d 	bl	8f632bc0 <__stack_chk_fail>
8f628e88:	8f74221c 	.word	0x8f74221c

8f628e8c <cmd_boot>:
{
8f628e8c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	if (sz < sizeof(hdr)) {
8f628e90:	e3520003 	cmp	r2, #3
{
8f628e94:	e24dd024 	sub	r13, r13, #36	; 0x24
8f628e98:	e1a0b002 	mov	r11, r2
8f628e9c:	e59f24c0 	ldr	r2, [pc, #1216]	; 8f629364 <cmd_boot+0x4d8>
	unsigned int out_len = 0;
8f628ea0:	e3a03000 	mov	r3, #0
{
8f628ea4:	e5922000 	ldr	r2, [r2]
8f628ea8:	e58d201c 	str	r2, [r13, #28]
8f628eac:	e3a02000 	mov	r2, #0
	unsigned int out_len = 0;
8f628eb0:	e58d3014 	str	r3, [r13, #20]
	uint32_t dtb_offset = 0;
8f628eb4:	e58d3018 	str	r3, [r13, #24]
	if (sz < sizeof(hdr)) {
8f628eb8:	9a00007c 	bls	8f6290b0 <cmd_boot+0x224>
	hdr->cmdline[BOOT_ARGS_SIZE-1] = 0;
8f628ebc:	e5c1323f 	strb	r3, [r1, #575]	; 0x23f
	if(target_is_emmc_boot() && hdr->page_size) {
8f628ec0:	e1a0900e 	mov	r9, r14
8f628ec4:	e1a04001 	mov	r4, r1
8f628ec8:	ebffe2ec 	bl	8f621a80 <target_is_emmc_boot>
8f628ecc:	e3500000 	cmp	r0, #0
8f628ed0:	1a00006b 	bne	8f629084 <cmd_boot+0x1f8>
	kernel_actual = ROUND_TO_PAGE(hdr->kernel_size, page_mask);
8f628ed4:	e300a680 	movw	r10, #1664	; 0x680
	image_actual = ADD_OF(page_size, kernel_actual);
8f628ed8:	e3007684 	movw	r7, #1668	; 0x684
	kernel_actual = ROUND_TO_PAGE(hdr->kernel_size, page_mask);
8f628edc:	e348af74 	movt	r10, #36724	; 0x8f74
	image_actual = ADD_OF(page_size, kernel_actual);
8f628ee0:	e3487f74 	movt	r7, #36724	; 0x8f74
	kernel_actual = ROUND_TO_PAGE(hdr->kernel_size, page_mask);
8f628ee4:	e59a5000 	ldr	r5, [r10]
	image_actual = ADD_OF(page_size, kernel_actual);
8f628ee8:	e5971000 	ldr	r1, [r7]
	kernel_actual = ROUND_TO_PAGE(hdr->kernel_size, page_mask);
8f628eec:	e5943008 	ldr	r3, [r4, #8]
	dt_size = hdr->dt_size;
8f628ef0:	e3056200 	movw	r6, #20992	; 0x5200
8f628ef4:	e5940028 	ldr	r0, [r4, #40]	; 0x28
8f628ef8:	e3486f73 	movt	r6, #36723	; 0x8f73
	ramdisk_actual = ROUND_TO_PAGE(hdr->ramdisk_size, page_mask);
8f628efc:	e5942010 	ldr	r2, [r4, #16]
	kernel_actual = ROUND_TO_PAGE(hdr->kernel_size, page_mask);
8f628f00:	e0838005 	add	r8, r3, r5
8f628f04:	e1c88005 	bic	r8, r8, r5
8f628f08:	e1e0e005 	mvn	r14, r5
8f628f0c:	e1530008 	cmp	r3, r8
	second_actual = ROUND_TO_PAGE(hdr->second_size, page_mask);
8f628f10:	e5943018 	ldr	r3, [r4, #24]
	dt_size = hdr->dt_size;
8f628f14:	e5860000 	str	r0, [r6]
	ramdisk_actual = ROUND_TO_PAGE(hdr->ramdisk_size, page_mask);
8f628f18:	e0826005 	add	r6, r2, r5
8f628f1c:	e006600e 	and	r6, r6, r14
	image_actual = ADD_OF(page_size, kernel_actual);
8f628f20:	91e0c008 	mvnls	r12, r8
8f628f24:	83a0c000 	movhi	r12, #0
	kernel_actual = ROUND_TO_PAGE(hdr->kernel_size, page_mask);
8f628f28:	83e08000 	mvnhi	r8, #0
	ramdisk_actual = ROUND_TO_PAGE(hdr->ramdisk_size, page_mask);
8f628f2c:	e1520006 	cmp	r2, r6
	second_actual = ROUND_TO_PAGE(hdr->second_size, page_mask);
8f628f30:	e0832005 	add	r2, r3, r5
8f628f34:	e002200e 	and	r2, r2, r14
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f628f38:	e0805005 	add	r5, r0, r5
	ramdisk_actual = ROUND_TO_PAGE(hdr->ramdisk_size, page_mask);
8f628f3c:	83e06000 	mvnhi	r6, #0
	second_actual = ROUND_TO_PAGE(hdr->second_size, page_mask);
8f628f40:	e1530002 	cmp	r3, r2
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f628f44:	e005500e 	and	r5, r5, r14
	second_actual = ROUND_TO_PAGE(hdr->second_size, page_mask);
8f628f48:	83e02000 	mvnhi	r2, #0
	dt_actual = ROUND_TO_PAGE(dt_size, page_mask);
8f628f4c:	e1500005 	cmp	r0, r5
8f628f50:	83e05000 	mvnhi	r5, #0
	image_actual = ADD_OF(page_size, kernel_actual);
8f628f54:	e15c0001 	cmp	r12, r1
8f628f58:	9a00005f 	bls	8f6290dc <cmd_boot+0x250>
8f628f5c:	e0883001 	add	r3, r8, r1
	image_actual = ADD_OF(image_actual, ramdisk_actual);
8f628f60:	e1e01006 	mvn	r1, r6
8f628f64:	e1510003 	cmp	r1, r3
8f628f68:	9a00005b 	bls	8f6290dc <cmd_boot+0x250>
8f628f6c:	e0863003 	add	r3, r6, r3
	image_actual = ADD_OF(image_actual, second_actual);
8f628f70:	e1e01002 	mvn	r1, r2
8f628f74:	e1510003 	cmp	r1, r3
8f628f78:	9a000057 	bls	8f6290dc <cmd_boot+0x250>
8f628f7c:	e0823003 	add	r3, r2, r3
	image_actual = ADD_OF(image_actual, dt_actual);
8f628f80:	e1e02005 	mvn	r2, r5
8f628f84:	e1520003 	cmp	r2, r3
8f628f88:	9a000053 	bls	8f6290dc <cmd_boot+0x250>
8f628f8c:	e0855003 	add	r5, r5, r3
	if (image_actual > sz) {
8f628f90:	e155000b 	cmp	r5, r11
8f628f94:	8a000053 	bhi	8f6290e8 <cmd_boot+0x25c>
	if (target_use_signed_kernel() && (!device.is_unlocked)) {
8f628f98:	ebffe2c9 	bl	8f621ac4 <target_use_signed_kernel>
8f628f9c:	e3500000 	cmp	r0, #0
8f628fa0:	0a000004 	beq	8f628fb8 <cmd_boot+0x12c>
8f628fa4:	e3013ad0 	movw	r3, #6864	; 0x1ad0
8f628fa8:	e3483f71 	movt	r3, #36721	; 0x8f71
8f628fac:	e5933010 	ldr	r3, [r3, #16]
8f628fb0:	e3530000 	cmp	r3, #0
8f628fb4:	0a00004f 	beq	8f6290f8 <cmd_boot+0x26c>
	if ((target_get_max_flash_size() - page_size) < image_actual)
8f628fb8:	ebff60f7 	bl	8f60139c <target_get_max_flash_size>
8f628fbc:	e5973000 	ldr	r3, [r7]
8f628fc0:	e0400003 	sub	r0, r0, r3
8f628fc4:	e1500005 	cmp	r0, r5
8f628fc8:	3a0000c9 	bcc	8f6292f4 <cmd_boot+0x468>
	if (target_use_signed_kernel() && (!device.is_unlocked)) {
8f628fcc:	ebffe2bc 	bl	8f621ac4 <target_use_signed_kernel>
	if (is_gzip_package((unsigned char *)(data + page_size), hdr->kernel_size))
8f628fd0:	e5970000 	ldr	r0, [r7]
8f628fd4:	e5941008 	ldr	r1, [r4, #8]
8f628fd8:	e0840000 	add	r0, r4, r0
8f628fdc:	eb00492a 	bl	8f63b48c <is_gzip_package>
8f628fe0:	e3500000 	cmp	r0, #0
8f628fe4:	1a00004d 	bne	8f629120 <cmd_boot+0x294>
		kptr = (struct kernel64_hdr*)((char *)data + page_size);
8f628fe8:	e597b000 	ldr	r11, [r7]
		kernel_size = hdr->kernel_size;
8f628fec:	e5943008 	ldr	r3, [r4, #8]
		kptr = (struct kernel64_hdr*)((char *)data + page_size);
8f628ff0:	e084b00b 	add	r11, r4, r11
	update_ker_tags_rdisk_addr(hdr, kptr);
8f628ff4:	e1a0100b 	mov	r1, r11
8f628ff8:	e1a00004 	mov	r0, r4
8f628ffc:	e58d300c 	str	r3, [r13, #12]
8f629000:	ebfff0ff 	bl	8f625404 <update_ker_tags_rdisk_addr>
	hdr->kernel_addr = VA(hdr->kernel_addr);
8f629004:	e594000c 	ldr	r0, [r4, #12]
8f629008:	ebff61e1 	bl	8f601794 <platform_get_phys_to_virt_mapping>
8f62900c:	e584000c 	str	r0, [r4, #12]
	hdr->ramdisk_addr = VA(hdr->ramdisk_addr);
8f629010:	e5940014 	ldr	r0, [r4, #20]
8f629014:	ebff61de 	bl	8f601794 <platform_get_phys_to_virt_mapping>
8f629018:	e5840014 	str	r0, [r4, #20]
	hdr->tags_addr = VA(hdr->tags_addr);
8f62901c:	e5940020 	ldr	r0, [r4, #32]
8f629020:	ebff61db 	bl	8f601794 <platform_get_phys_to_virt_mapping>
	kernel_size  = ROUND_TO_PAGE(kernel_size,  page_mask);
8f629024:	e59d300c 	ldr	r3, [r13, #12]
8f629028:	e59a2000 	ldr	r2, [r10]
8f62902c:	e0829003 	add	r9, r2, r3
8f629030:	e1c99002 	bic	r9, r9, r2
8f629034:	e1590003 	cmp	r9, r3
8f629038:	33e09000 	mvncc	r9, #0
	hdr->tags_addr = VA(hdr->tags_addr);
8f62903c:	e5840020 	str	r0, [r4, #32]
	if (check_aboot_addr_range_overlap(hdr->kernel_addr, kernel_size) ||
8f629040:	e594000c 	ldr	r0, [r4, #12]
	if ((UINT_MAX - start) < size)
8f629044:	e1e03000 	mvn	r3, r0
8f629048:	e1590003 	cmp	r9, r3
8f62904c:	8a000008 	bhi	8f629074 <cmd_boot+0x1e8>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f629050:	e30f3fff 	movw	r3, #65535	; 0xffff
8f629054:	e3483f5f 	movt	r3, #36703	; 0x8f5f
8f629058:	e1500003 	cmp	r0, r3
8f62905c:	8a00004c 	bhi	8f629194 <cmd_boot+0x308>
8f629060:	e0802009 	add	r2, r0, r9
8f629064:	e3a03000 	mov	r3, #0
8f629068:	e3483f60 	movt	r3, #36704	; 0x8f60
8f62906c:	e1520003 	cmp	r2, r3
8f629070:	9a000049 	bls	8f62919c <cmd_boot+0x310>
		dprintf(CRITICAL, "kernel/ramdisk addresses are not valid.\n");
8f629074:	e3080c5c 	movw	r0, #35932	; 0x8c5c
8f629078:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62907c:	eb00263c 	bl	8f632974 <_dprintf>
		goto boot_failed;
8f629080:	ea00000d 	b	8f6290bc <cmd_boot+0x230>
	if(target_is_emmc_boot() && hdr->page_size) {
8f629084:	e5941024 	ldr	r1, [r4, #36]	; 0x24
8f629088:	e3510000 	cmp	r1, #0
8f62908c:	0affff90 	beq	8f628ed4 <cmd_boot+0x48>
		page_size = hdr->page_size;
8f629090:	e3007684 	movw	r7, #1668	; 0x684
		page_mask = page_size - 1;
8f629094:	e300a680 	movw	r10, #1664	; 0x680
		page_size = hdr->page_size;
8f629098:	e3487f74 	movt	r7, #36724	; 0x8f74
		page_mask = page_size - 1;
8f62909c:	e348af74 	movt	r10, #36724	; 0x8f74
8f6290a0:	e2415001 	sub	r5, r1, #1
		page_size = hdr->page_size;
8f6290a4:	e5871000 	str	r1, [r7]
		page_mask = page_size - 1;
8f6290a8:	e58a5000 	str	r5, [r10]
8f6290ac:	eaffff8e 	b	8f628eec <cmd_boot+0x60>
		fastboot_fail("invalid bootimage header");
8f6290b0:	e30900e0 	movw	r0, #37088	; 0x90e0
8f6290b4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6290b8:	eb000f94 	bl	8f62cf10 <fastboot_fail>
}
8f6290bc:	e59f32a0 	ldr	r3, [pc, #672]	; 8f629364 <cmd_boot+0x4d8>
8f6290c0:	e5932000 	ldr	r2, [r3]
8f6290c4:	e59d301c 	ldr	r3, [r13, #28]
8f6290c8:	e0332002 	eors	r2, r3, r2
8f6290cc:	e3a03000 	mov	r3, #0
8f6290d0:	1a0000a2 	bne	8f629360 <cmd_boot+0x4d4>
8f6290d4:	e28dd024 	add	r13, r13, #36	; 0x24
8f6290d8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	image_actual = ADD_OF(image_actual, dt_actual);
8f6290dc:	e3e05000 	mvn	r5, #0
	if (image_actual > sz) {
8f6290e0:	e155000b 	cmp	r5, r11
8f6290e4:	9affffab 	bls	8f628f98 <cmd_boot+0x10c>
		fastboot_fail("bootimage header fields are invalid");
8f6290e8:	e30900fc 	movw	r0, #37116	; 0x90fc
8f6290ec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6290f0:	eb000f86 	bl	8f62cf10 <fastboot_fail>
		goto boot_failed;
8f6290f4:	eafffff0 	b	8f6290bc <cmd_boot+0x230>
		sig_actual = read_der_message_length(
8f6290f8:	e04b1005 	sub	r1, r11, r5
8f6290fc:	e0840005 	add	r0, r4, r5
8f629100:	ebffe22b 	bl	8f6219b4 <read_der_message_length>
		chk = ADD_OF(image_actual, sig_actual);
8f629104:	e1e03000 	mvn	r3, r0
8f629108:	e1530005 	cmp	r3, r5
8f62910c:	80850000 	addhi	r0, r5, r0
8f629110:	93e00000 	mvnls	r0, #0
		if (chk > sz) {
8f629114:	e150000b 	cmp	r0, r11
8f629118:	9affffa6 	bls	8f628fb8 <cmd_boot+0x12c>
8f62911c:	eafffff1 	b	8f6290e8 <cmd_boot+0x25c>
		out_addr = (unsigned char *)target_get_scratch_address();
8f629120:	ebff608b 	bl	8f601354 <target_get_scratch_address>
		out_addr = (unsigned char *)(out_addr + image_actual + page_size);
8f629124:	e5973000 	ldr	r3, [r7]
8f629128:	e0853003 	add	r3, r5, r3
8f62912c:	e080b003 	add	r11, r0, r3
		out_avai_len = target_get_max_flash_size() - image_actual - page_size;
8f629130:	ebff6099 	bl	8f60139c <target_get_max_flash_size>
8f629134:	e5973000 	ldr	r3, [r7]
8f629138:	e0853003 	add	r3, r5, r3
8f62913c:	e0403003 	sub	r3, r0, r3
		dprintf(INFO, "decompressing kernel image: start\n");
8f629140:	e3080b68 	movw	r0, #35688	; 0x8b68
8f629144:	e3480f70 	movt	r0, #36720	; 0x8f70
		out_avai_len = target_get_max_flash_size() - image_actual - page_size;
8f629148:	e58d300c 	str	r3, [r13, #12]
		dprintf(INFO, "decompressing kernel image: start\n");
8f62914c:	eb002608 	bl	8f632974 <_dprintf>
		ret = decompress((unsigned char *)(ptr + page_size),
8f629150:	e5970000 	ldr	r0, [r7]
8f629154:	e5941008 	ldr	r1, [r4, #8]
8f629158:	e28d2014 	add	r2, r13, #20
8f62915c:	e59d300c 	ldr	r3, [r13, #12]
8f629160:	e0840000 	add	r0, r4, r0
8f629164:	e58d2004 	str	r2, [r13, #4]
8f629168:	e28d2018 	add	r2, r13, #24
8f62916c:	e58d2000 	str	r2, [r13]
8f629170:	e1a0200b 	mov	r2, r11
8f629174:	eb004852 	bl	8f63b2c4 <decompress>
		if (ret)
8f629178:	e3500000 	cmp	r0, #0
8f62917c:	1a000069 	bne	8f629328 <cmd_boot+0x49c>
		dprintf(INFO, "decompressing kernel image: done\n");
8f629180:	e3080bb4 	movw	r0, #35764	; 0x8bb4
8f629184:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629188:	eb0025f9 	bl	8f632974 <_dprintf>
		kernel_size = out_len;
8f62918c:	e59d3014 	ldr	r3, [r13, #20]
8f629190:	eaffff97 	b	8f628ff4 <cmd_boot+0x168>
	else if (start >= (MEMBASE + MEMSIZE))
8f629194:	e3700217 	cmn	r0, #1879048193	; 0x70000001
8f629198:	9affffb5 	bls	8f629074 <cmd_boot+0x1e8>
		check_ddr_addr_range_bound(hdr->kernel_addr, kernel_size) ||
8f62919c:	e1a01009 	mov	r1, r9
8f6291a0:	ebfff6b8 	bl	8f626c88 <check_ddr_addr_range_bound>
	if (check_aboot_addr_range_overlap(hdr->kernel_addr, kernel_size) ||
8f6291a4:	e3500000 	cmp	r0, #0
8f6291a8:	1affffb1 	bne	8f629074 <cmd_boot+0x1e8>
		check_aboot_addr_range_overlap(hdr->ramdisk_addr, ramdisk_actual) ||
8f6291ac:	e5940014 	ldr	r0, [r4, #20]
	if ((UINT_MAX - start) < size)
8f6291b0:	e1e03000 	mvn	r3, r0
8f6291b4:	e1560003 	cmp	r6, r3
8f6291b8:	8affffad 	bhi	8f629074 <cmd_boot+0x1e8>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f6291bc:	e30f3fff 	movw	r3, #65535	; 0xffff
8f6291c0:	e3483f5f 	movt	r3, #36703	; 0x8f5f
8f6291c4:	e1500003 	cmp	r0, r3
8f6291c8:	8a000046 	bhi	8f6292e8 <cmd_boot+0x45c>
8f6291cc:	e0802006 	add	r2, r0, r6
8f6291d0:	e3a03000 	mov	r3, #0
8f6291d4:	e3483f60 	movt	r3, #36704	; 0x8f60
8f6291d8:	e1520003 	cmp	r2, r3
8f6291dc:	8affffa4 	bhi	8f629074 <cmd_boot+0x1e8>
		check_ddr_addr_range_bound(hdr->ramdisk_addr, ramdisk_actual))
8f6291e0:	e1a01006 	mov	r1, r6
8f6291e4:	ebfff6a7 	bl	8f626c88 <check_ddr_addr_range_bound>
		check_aboot_addr_range_overlap(hdr->ramdisk_addr, ramdisk_actual) ||
8f6291e8:	e3500000 	cmp	r0, #0
8f6291ec:	1affffa0 	bne	8f629074 <cmd_boot+0x1e8>
	scratch_offset = image_actual + page_size + out_len;
8f6291f0:	e59d3014 	ldr	r3, [r13, #20]
	ret = copy_dtb(data, scratch_offset);
8f6291f4:	e1a00004 	mov	r0, r4
	scratch_offset = image_actual + page_size + out_len;
8f6291f8:	e5971000 	ldr	r1, [r7]
8f6291fc:	e0811003 	add	r1, r1, r3
	ret = copy_dtb(data, scratch_offset);
8f629200:	e0811005 	add	r1, r1, r5
8f629204:	ebfffe75 	bl	8f628be0 <copy_dtb>
	memmove((void*) hdr->ramdisk_addr, ptr + page_size + kernel_actual, hdr->ramdisk_size);
8f629208:	e5971000 	ldr	r1, [r7]
8f62920c:	e5942010 	ldr	r2, [r4, #16]
8f629210:	e0881001 	add	r1, r8, r1
8f629214:	e0841001 	add	r1, r4, r1
	ret = copy_dtb(data, scratch_offset);
8f629218:	e1a05000 	mov	r5, r0
	memmove((void*) hdr->ramdisk_addr, ptr + page_size + kernel_actual, hdr->ramdisk_size);
8f62921c:	e5940014 	ldr	r0, [r4, #20]
8f629220:	eb002be4 	bl	8f6341b8 <memcpy>
	memmove((void*) hdr->kernel_addr, (char*) (kernel_start_addr), kernel_size);
8f629224:	e594000c 	ldr	r0, [r4, #12]
8f629228:	e1a02009 	mov	r2, r9
8f62922c:	e1a0100b 	mov	r1, r11
8f629230:	eb002be0 	bl	8f6341b8 <memcpy>
	if (check_aboot_addr_range_overlap(hdr->tags_addr, kernel_actual) ||
8f629234:	e5940020 	ldr	r0, [r4, #32]
	if ((UINT_MAX - start) < size)
8f629238:	e1e03000 	mvn	r3, r0
8f62923c:	e1580003 	cmp	r8, r3
8f629240:	8a000034 	bhi	8f629318 <cmd_boot+0x48c>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f629244:	e30f3fff 	movw	r3, #65535	; 0xffff
8f629248:	e3483f5f 	movt	r3, #36703	; 0x8f5f
8f62924c:	e1500003 	cmp	r0, r3
8f629250:	9a00002b 	bls	8f629304 <cmd_boot+0x478>
	else if (start >= (MEMBASE + MEMSIZE))
8f629254:	e3700217 	cmn	r0, #1879048193	; 0x70000001
8f629258:	9a00002e 	bls	8f629318 <cmd_boot+0x48c>
		check_ddr_addr_range_bound(hdr->tags_addr, kernel_actual))
8f62925c:	e1a01008 	mov	r1, r8
8f629260:	ebfff688 	bl	8f626c88 <check_ddr_addr_range_bound>
	if (check_aboot_addr_range_overlap(hdr->tags_addr, kernel_actual) ||
8f629264:	e3500000 	cmp	r0, #0
8f629268:	1a00002a 	bne	8f629318 <cmd_boot+0x48c>
	if (!dtb_copied) {
8f62926c:	e3550000 	cmp	r5, #0
8f629270:	0a00000b 	beq	8f6292a4 <cmd_boot+0x418>
		dtb = dev_tree_appended((void*)(ptr + page_size),
8f629274:	e5970000 	ldr	r0, [r7]
8f629278:	e5943020 	ldr	r3, [r4, #32]
8f62927c:	e59d2018 	ldr	r2, [r13, #24]
8f629280:	e0840000 	add	r0, r4, r0
8f629284:	e5941008 	ldr	r1, [r4, #8]
8f629288:	ebffbab0 	bl	8f617d50 <dev_tree_appended>
		if (!dtb) {
8f62928c:	e3500000 	cmp	r0, #0
8f629290:	1a000003 	bne	8f6292a4 <cmd_boot+0x418>
			fastboot_fail("dtb not found");
8f629294:	e309019c 	movw	r0, #37276	; 0x919c
8f629298:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62929c:	eb000f1b 	bl	8f62cf10 <fastboot_fail>
			goto boot_failed;
8f6292a0:	eaffff85 	b	8f6290bc <cmd_boot+0x230>
	fastboot_okay("");
8f6292a4:	e3070138 	movw	r0, #28984	; 0x7138
8f6292a8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6292ac:	eb000f3a 	bl	8f62cf9c <fastboot_okay>
	fastboot_stop();
8f6292b0:	eb0010b5 	bl	8f62d58c <fastboot_stop>
	boot_linux((void*) hdr->kernel_addr, (void*) hdr->tags_addr,
8f6292b4:	e594500c 	ldr	r5, [r4, #12]
8f6292b8:	e5946020 	ldr	r6, [r4, #32]
8f6292bc:	ebff5e26 	bl	8f600b5c <board_machtype>
8f6292c0:	e5942010 	ldr	r2, [r4, #16]
8f6292c4:	e1a01006 	mov	r1, r6
8f6292c8:	e58d2004 	str	r2, [r13, #4]
8f6292cc:	e2842040 	add	r2, r4, #64	; 0x40
		   (void*) hdr->ramdisk_addr, hdr->ramdisk_size);
8f6292d0:	e594c014 	ldr	r12, [r4, #20]
	boot_linux((void*) hdr->kernel_addr, (void*) hdr->tags_addr,
8f6292d4:	e58dc000 	str	r12, [r13]
8f6292d8:	e1a03000 	mov	r3, r0
8f6292dc:	e1a00005 	mov	r0, r5
8f6292e0:	ebfff5ce 	bl	8f626a20 <boot_linux>
	return;
8f6292e4:	eaffff74 	b	8f6290bc <cmd_boot+0x230>
	else if (start >= (MEMBASE + MEMSIZE))
8f6292e8:	e3700217 	cmn	r0, #1879048193	; 0x70000001
8f6292ec:	8affffbb 	bhi	8f6291e0 <cmd_boot+0x354>
8f6292f0:	eaffff5f 	b	8f629074 <cmd_boot+0x1e8>
		fastboot_fail("booimage: size is greater than boot image buffer can hold");
8f6292f4:	e3090120 	movw	r0, #37152	; 0x9120
8f6292f8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6292fc:	eb000f03 	bl	8f62cf10 <fastboot_fail>
		goto boot_failed;
8f629300:	eaffff6d 	b	8f6290bc <cmd_boot+0x230>
	if ((start < MEMBASE) && ((start + size) <= MEMBASE))
8f629304:	e0802008 	add	r2, r0, r8
8f629308:	e3a03000 	mov	r3, #0
8f62930c:	e3483f60 	movt	r3, #36704	; 0x8f60
8f629310:	e1520003 	cmp	r2, r3
8f629314:	9affffd0 	bls	8f62925c <cmd_boot+0x3d0>
		dprintf(CRITICAL, "Tags addresses are not valid.\n");
8f629318:	e309017c 	movw	r0, #37244	; 0x917c
8f62931c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629320:	eb002593 	bl	8f632974 <_dprintf>
		goto boot_failed;
8f629324:	eaffff64 	b	8f6290bc <cmd_boot+0x230>
			dprintf(CRITICAL, "decompressing image failed!!!\n");
8f629328:	e309015c 	movw	r0, #37212	; 0x915c
8f62932c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629330:	eb00258f 	bl	8f632974 <_dprintf>
			ASSERT(0);
8f629334:	e1a00009 	mov	r0, r9
8f629338:	e3073f64 	movw	r3, #32612	; 0x7f64
8f62933c:	e30824b0 	movw	r2, #33968	; 0x84b0
8f629340:	e3483f70 	movt	r3, #36720	; 0x8f70
8f629344:	e3482f70 	movt	r2, #36720	; 0x8f70
8f629348:	e58d3000 	str	r3, [r13]
8f62934c:	e3001130 	movw	r1, #304	; 0x130
8f629350:	e3003d08 	movw	r3, #3336	; 0xd08
8f629354:	e3481f70 	movt	r1, #36720	; 0x8f70
8f629358:	eb0025d7 	bl	8f632abc <_panic>
8f62935c:	eaffff87 	b	8f629180 <cmd_boot+0x2f4>
}
8f629360:	eb002616 	bl	8f632bc0 <__stack_chk_fail>
8f629364:	8f74221c 	.word	0x8f74221c

8f629368 <cmd_erase_nand>:
{
8f629368:	e59f314c 	ldr	r3, [pc, #332]	; 8f6294bc <cmd_erase_nand+0x154>
8f62936c:	e92d4030 	push	{r4, r5, r14}
8f629370:	e24dd00c 	sub	r13, r13, #12
8f629374:	e5933000 	ldr	r3, [r3]
8f629378:	e58d3004 	str	r3, [r13, #4]
8f62937c:	e3a03000 	mov	r3, #0
8f629380:	e1a04000 	mov	r4, r0
	ptable = flash_get_ptable();
8f629384:	ebffa70f 	bl	8f612fc8 <flash_get_ptable>
	if (ptable == NULL) {
8f629388:	e3500000 	cmp	r0, #0
8f62938c:	0a00002d 	beq	8f629448 <cmd_erase_nand+0xe0>
	ptn = ptable_find(ptable, arg);
8f629390:	e1a01004 	mov	r1, r4
8f629394:	eb003569 	bl	8f636940 <ptable_find>
	if (ptn == NULL) {
8f629398:	e2505000 	subs	r5, r0, #0
8f62939c:	0a00003d 	beq	8f629498 <cmd_erase_nand+0x130>
	if (!strncmp(arg, "avb_custom_key", strlen("avb_custom_key"))) {
8f6293a0:	e30901e4 	movw	r0, #37348	; 0x91e4
8f6293a4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6293a8:	eb002d16 	bl	8f634808 <strlen>
8f6293ac:	e30911e4 	movw	r1, #37348	; 0x91e4
8f6293b0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6293b4:	e1a02000 	mov	r2, r0
8f6293b8:	e1a00004 	mov	r0, r4
8f6293bc:	eb002d2a 	bl	8f63486c <strncmp>
8f6293c0:	e3500000 	cmp	r0, #0
8f6293c4:	0a00000e 	beq	8f629404 <cmd_erase_nand+0x9c>
	if (flash_erase(ptn)) {
8f6293c8:	e1a00005 	mov	r0, r5
8f6293cc:	ebffa7b3 	bl	8f6132a0 <flash_erase>
8f6293d0:	e3500000 	cmp	r0, #0
8f6293d4:	1a000024 	bne	8f62946c <cmd_erase_nand+0x104>
			fastboot_okay("");
8f6293d8:	e59f30dc 	ldr	r3, [pc, #220]	; 8f6294bc <cmd_erase_nand+0x154>
8f6293dc:	e5932000 	ldr	r2, [r3]
8f6293e0:	e59d3004 	ldr	r3, [r13, #4]
8f6293e4:	e0332002 	eors	r2, r3, r2
8f6293e8:	e3a03000 	mov	r3, #0
8f6293ec:	1a00001d 	bne	8f629468 <cmd_erase_nand+0x100>
8f6293f0:	e3070138 	movw	r0, #28984	; 0x7138
8f6293f4:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f6293f8:	e28dd00c 	add	r13, r13, #12
8f6293fc:	e8bd4030 	pop	{r4, r5, r14}
			fastboot_okay("");
8f629400:	ea000ee5 	b	8f62cf9c <fastboot_okay>
		dprintf(INFO, "erasing avb_custom_key\n");
8f629404:	e30901f4 	movw	r0, #37364	; 0x91f4
8f629408:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62940c:	eb002558 	bl	8f632974 <_dprintf>
		if (erase_userkey()) {
8f629410:	ebfffcde 	bl	8f628790 <erase_userkey>
8f629414:	e3500000 	cmp	r0, #0
8f629418:	0affffee 	beq	8f6293d8 <cmd_erase_nand+0x70>
			fastboot_fail("Erasing avb_custom_key failed");
8f62941c:	e59f3098 	ldr	r3, [pc, #152]	; 8f6294bc <cmd_erase_nand+0x154>
8f629420:	e5932000 	ldr	r2, [r3]
8f629424:	e59d3004 	ldr	r3, [r13, #4]
8f629428:	e0332002 	eors	r2, r3, r2
8f62942c:	e3a03000 	mov	r3, #0
8f629430:	0309020c 	movweq	r0, #37388	; 0x920c
8f629434:	03480f70 	movteq	r0, #36720	; 0x8f70
8f629438:	1a00000a 	bne	8f629468 <cmd_erase_nand+0x100>
}
8f62943c:	e28dd00c 	add	r13, r13, #12
8f629440:	e8bd4030 	pop	{r4, r5, r14}
		fastboot_fail("failed to erase partition");
8f629444:	ea000eb1 	b	8f62cf10 <fastboot_fail>
		fastboot_fail("partition table doesn't exist");
8f629448:	e59f306c 	ldr	r3, [pc, #108]	; 8f6294bc <cmd_erase_nand+0x154>
8f62944c:	e5932000 	ldr	r2, [r3]
8f629450:	e59d3004 	ldr	r3, [r13, #4]
8f629454:	e0332002 	eors	r2, r3, r2
8f629458:	e3a03000 	mov	r3, #0
8f62945c:	030901ac 	movweq	r0, #37292	; 0x91ac
8f629460:	03480f70 	movteq	r0, #36720	; 0x8f70
8f629464:	0afffff4 	beq	8f62943c <cmd_erase_nand+0xd4>
		fastboot_fail("failed to erase partition");
8f629468:	eb0025d4 	bl	8f632bc0 <__stack_chk_fail>
8f62946c:	e59f3048 	ldr	r3, [pc, #72]	; 8f6294bc <cmd_erase_nand+0x154>
8f629470:	e5932000 	ldr	r2, [r3]
8f629474:	e59d3004 	ldr	r3, [r13, #4]
8f629478:	e0332002 	eors	r2, r3, r2
8f62947c:	e3a03000 	mov	r3, #0
8f629480:	0309022c 	movweq	r0, #37420	; 0x922c
8f629484:	03480f70 	movteq	r0, #36720	; 0x8f70
8f629488:	1afffff6 	bne	8f629468 <cmd_erase_nand+0x100>
}
8f62948c:	e28dd00c 	add	r13, r13, #12
8f629490:	e8bd4030 	pop	{r4, r5, r14}
		fastboot_fail("failed to erase partition");
8f629494:	ea000e9d 	b	8f62cf10 <fastboot_fail>
		fastboot_fail("unknown partition name");
8f629498:	e59f301c 	ldr	r3, [pc, #28]	; 8f6294bc <cmd_erase_nand+0x154>
8f62949c:	e5932000 	ldr	r2, [r3]
8f6294a0:	e59d3004 	ldr	r3, [r13, #4]
8f6294a4:	e0332002 	eors	r2, r3, r2
8f6294a8:	e3a03000 	mov	r3, #0
8f6294ac:	030901cc 	movweq	r0, #37324	; 0x91cc
8f6294b0:	03480f70 	movteq	r0, #36720	; 0x8f70
8f6294b4:	0affffe0 	beq	8f62943c <cmd_erase_nand+0xd4>
8f6294b8:	eaffffea 	b	8f629468 <cmd_erase_nand+0x100>
8f6294bc:	8f74221c 	.word	0x8f74221c

8f6294c0 <cmd_erase_mmc>:
{
8f6294c0:	e59f3250 	ldr	r3, [pc, #592]	; 8f629718 <cmd_erase_mmc+0x258>
8f6294c4:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f6294c8:	e24dd00c 	sub	r13, r13, #12
8f6294cc:	e5933000 	ldr	r3, [r3]
8f6294d0:	e58d3004 	str	r3, [r13, #4]
8f6294d4:	e3a03000 	mov	r3, #0
8f6294d8:	e1a07000 	mov	r7, r0
	index = partition_get_index(arg);
8f6294dc:	ebff69ea 	bl	8f603c8c <partition_get_index>
8f6294e0:	e1a05000 	mov	r5, r0
	ptn = partition_get_offset(index);
8f6294e4:	ebff6cf4 	bl	8f6048bc <partition_get_offset>
8f6294e8:	e1a04000 	mov	r4, r0
	size = partition_get_size(index);
8f6294ec:	e1a00005 	mov	r0, r5
	ptn = partition_get_offset(index);
8f6294f0:	e1a06001 	mov	r6, r1
	size = partition_get_size(index);
8f6294f4:	ebff6ccf 	bl	8f604838 <partition_get_size>
8f6294f8:	e1a08000 	mov	r8, r0
	if (!strncmp(arg, "avb_custom_key", strlen("avb_custom_key"))) {
8f6294fc:	e30901e4 	movw	r0, #37348	; 0x91e4
8f629500:	e3480f70 	movt	r0, #36720	; 0x8f70
	size = partition_get_size(index);
8f629504:	e1a09001 	mov	r9, r1
	if (!strncmp(arg, "avb_custom_key", strlen("avb_custom_key"))) {
8f629508:	eb002cbe 	bl	8f634808 <strlen>
8f62950c:	e30911e4 	movw	r1, #37348	; 0x91e4
8f629510:	e3481f70 	movt	r1, #36720	; 0x8f70
8f629514:	e1a02000 	mov	r2, r0
8f629518:	e1a00007 	mov	r0, r7
8f62951c:	eb002cd2 	bl	8f63486c <strncmp>
8f629520:	e3500000 	cmp	r0, #0
8f629524:	0a00004d 	beq	8f629660 <cmd_erase_mmc+0x1a0>
	if(ptn == 0) {
8f629528:	e1943006 	orrs	r3, r4, r6
8f62952c:	0a000040 	beq	8f629634 <cmd_erase_mmc+0x174>
	lun = partition_get_lun(index);
8f629530:	e1a00005 	mov	r0, r5
8f629534:	ebff6d01 	bl	8f604940 <partition_get_lun>
	mmc_set_lun(lun);
8f629538:	ebff8fbd 	bl	8f60d434 <mmc_set_lun>
	if (platform_boot_dev_isemmc())
8f62953c:	ebffe0e9 	bl	8f6218e8 <platform_boot_dev_isemmc>
8f629540:	e3500000 	cmp	r0, #0
8f629544:	0a000011 	beq	8f629590 <cmd_erase_mmc+0xd0>
		if (mmc_erase_card(ptn, size)) {
8f629548:	e1a02008 	mov	r2, r8
8f62954c:	e1a03009 	mov	r3, r9
8f629550:	e1a00004 	mov	r0, r4
8f629554:	e1a01006 	mov	r1, r6
8f629558:	ebff8e8e 	bl	8f60cf98 <mmc_erase_card>
8f62955c:	e3500000 	cmp	r0, #0
8f629560:	1a000056 	bne	8f6296c0 <cmd_erase_mmc+0x200>
                        fastboot_okay("");
8f629564:	e59f31ac 	ldr	r3, [pc, #428]	; 8f629718 <cmd_erase_mmc+0x258>
8f629568:	e5932000 	ldr	r2, [r3]
8f62956c:	e59d3004 	ldr	r3, [r13, #4]
8f629570:	e0332002 	eors	r2, r3, r2
8f629574:	e3a03000 	mov	r3, #0
8f629578:	1a000046 	bne	8f629698 <cmd_erase_mmc+0x1d8>
8f62957c:	e3070138 	movw	r0, #28984	; 0x7138
8f629580:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f629584:	e28dd00c 	add	r13, r13, #12
8f629588:	e8bd43f0 	pop	{r4, r5, r6, r7, r8, r9, r14}
                        fastboot_okay("");
8f62958c:	ea000e82 	b	8f62cf9c <fastboot_okay>
		size = partition_get_size(index);
8f629590:	e1a00005 	mov	r0, r5
8f629594:	ebff6ca7 	bl	8f604838 <partition_get_size>
		if (mmc_write(ptn , size, (unsigned int *)out)) {
8f629598:	e2703a01 	rsbs	r3, r0, #4096	; 0x1000
8f62959c:	e1a02000 	mov	r2, r0
8f6295a0:	e2f13000 	rscs	r3, r1, #0
8f6295a4:	e1a00004 	mov	r0, r4
8f6295a8:	e30f3680 	movw	r3, #63104	; 0xf680
8f6295ac:	e1a01006 	mov	r1, r6
8f6295b0:	33a02a01 	movcc	r2, #4096	; 0x1000
8f6295b4:	e3483f73 	movt	r3, #36723	; 0x8f73
8f6295b8:	ebff8d18 	bl	8f60ca20 <mmc_write>
8f6295bc:	e3500000 	cmp	r0, #0
8f6295c0:	1a000035 	bne	8f62969c <cmd_erase_mmc+0x1dc>
		if(!(strncmp(arg, "userdata", 8)))
8f6295c4:	e1a00007 	mov	r0, r7
8f6295c8:	e3a02008 	mov	r2, #8
8f6295cc:	e3011288 	movw	r1, #4744	; 0x1288
8f6295d0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6295d4:	eb002ca4 	bl	8f63486c <strncmp>
8f6295d8:	e2507000 	subs	r7, r0, #0
8f6295dc:	1affffe0 	bne	8f629564 <cmd_erase_mmc+0xa4>
			footer = memalign(CACHE_LINE, FOOTER_SIZE);
8f6295e0:	e3a01901 	mov	r1, #16384	; 0x4000
8f6295e4:	e3a00040 	mov	r0, #64	; 0x40
8f6295e8:	eb002a95 	bl	8f634044 <memalign>
			memset((void *)footer, 0, FOOTER_SIZE);
8f6295ec:	e1a01007 	mov	r1, r7
8f6295f0:	e3a02901 	mov	r2, #16384	; 0x4000
			footer = memalign(CACHE_LINE, FOOTER_SIZE);
8f6295f4:	e1a07000 	mov	r7, r0
			memset((void *)footer, 0, FOOTER_SIZE);
8f6295f8:	eb002b31 	bl	8f6342c4 <memset>
			size = partition_get_size(index);
8f6295fc:	e1a00005 	mov	r0, r5
8f629600:	ebff6c8c 	bl	8f604838 <partition_get_size>
			if (mmc_write((ptn + size) - FOOTER_SIZE , FOOTER_SIZE, (unsigned int *)footer)) {
8f629604:	e2544901 	subs	r4, r4, #16384	; 0x4000
8f629608:	e2c66000 	sbc	r6, r6, #0
8f62960c:	e1a03007 	mov	r3, r7
8f629610:	e3a02901 	mov	r2, #16384	; 0x4000
8f629614:	e0940000 	adds	r0, r4, r0
8f629618:	e0a61001 	adc	r1, r6, r1
8f62961c:	ebff8cff 	bl	8f60ca20 <mmc_write>
8f629620:	e3500000 	cmp	r0, #0
8f629624:	1a00002e 	bne	8f6296e4 <cmd_erase_mmc+0x224>
			free(footer);
8f629628:	e1a00007 	mov	r0, r7
8f62962c:	eb002ab6 	bl	8f63410c <free>
8f629630:	eaffffcb 	b	8f629564 <cmd_erase_mmc+0xa4>
		fastboot_fail("Partition table doesn't exist\n");
8f629634:	e59f30dc 	ldr	r3, [pc, #220]	; 8f629718 <cmd_erase_mmc+0x258>
8f629638:	e5932000 	ldr	r2, [r3]
8f62963c:	e59d3004 	ldr	r3, [r13, #4]
8f629640:	e0332002 	eors	r2, r3, r2
8f629644:	e3a03000 	mov	r3, #0
8f629648:	03090248 	movweq	r0, #37448	; 0x9248
8f62964c:	03480f70 	movteq	r0, #36720	; 0x8f70
8f629650:	1a000010 	bne	8f629698 <cmd_erase_mmc+0x1d8>
}
8f629654:	e28dd00c 	add	r13, r13, #12
8f629658:	e8bd43f0 	pop	{r4, r5, r6, r7, r8, r9, r14}
		fastboot_fail("Partition table doesn't exist\n");
8f62965c:	ea000e2b 	b	8f62cf10 <fastboot_fail>
                dprintf(INFO, "erasing avb_custom_key\n");
8f629660:	e30901f4 	movw	r0, #37364	; 0x91f4
8f629664:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629668:	eb0024c1 	bl	8f632974 <_dprintf>
                if (erase_userkey()) {
8f62966c:	ebfffc47 	bl	8f628790 <erase_userkey>
8f629670:	e3500000 	cmp	r0, #0
8f629674:	0affffba 	beq	8f629564 <cmd_erase_mmc+0xa4>
                        fastboot_fail("Erasing avb_custom_key failed");
8f629678:	e59f3098 	ldr	r3, [pc, #152]	; 8f629718 <cmd_erase_mmc+0x258>
8f62967c:	e5932000 	ldr	r2, [r3]
8f629680:	e59d3004 	ldr	r3, [r13, #4]
8f629684:	e0332002 	eors	r2, r3, r2
8f629688:	e3a03000 	mov	r3, #0
8f62968c:	0309020c 	movweq	r0, #37388	; 0x920c
8f629690:	03480f70 	movteq	r0, #36720	; 0x8f70
8f629694:	0affffee 	beq	8f629654 <cmd_erase_mmc+0x194>
				free(footer);
8f629698:	eb002548 	bl	8f632bc0 <__stack_chk_fail>
			fastboot_fail("failed to erase partition");
8f62969c:	e59f3074 	ldr	r3, [pc, #116]	; 8f629718 <cmd_erase_mmc+0x258>
8f6296a0:	e5932000 	ldr	r2, [r3]
8f6296a4:	e59d3004 	ldr	r3, [r13, #4]
8f6296a8:	e0332002 	eors	r2, r3, r2
8f6296ac:	e3a03000 	mov	r3, #0
8f6296b0:	0309022c 	movweq	r0, #37420	; 0x922c
8f6296b4:	03480f70 	movteq	r0, #36720	; 0x8f70
8f6296b8:	0affffe5 	beq	8f629654 <cmd_erase_mmc+0x194>
8f6296bc:	eafffff5 	b	8f629698 <cmd_erase_mmc+0x1d8>
			fastboot_fail("failed to erase partition\n");
8f6296c0:	e59f3050 	ldr	r3, [pc, #80]	; 8f629718 <cmd_erase_mmc+0x258>
8f6296c4:	e5932000 	ldr	r2, [r3]
8f6296c8:	e59d3004 	ldr	r3, [r13, #4]
8f6296cc:	e0332002 	eors	r2, r3, r2
8f6296d0:	e3a03000 	mov	r3, #0
8f6296d4:	03090268 	movweq	r0, #37480	; 0x9268
8f6296d8:	03480f70 	movteq	r0, #36720	; 0x8f70
8f6296dc:	0affffdc 	beq	8f629654 <cmd_erase_mmc+0x194>
8f6296e0:	eaffffec 	b	8f629698 <cmd_erase_mmc+0x1d8>
				fastboot_fail("failed to erase userdata footer");
8f6296e4:	e3090284 	movw	r0, #37508	; 0x9284
8f6296e8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6296ec:	eb000e07 	bl	8f62cf10 <fastboot_fail>
				free(footer);
8f6296f0:	e59f3020 	ldr	r3, [pc, #32]	; 8f629718 <cmd_erase_mmc+0x258>
8f6296f4:	e5932000 	ldr	r2, [r3]
8f6296f8:	e59d3004 	ldr	r3, [r13, #4]
8f6296fc:	e0332002 	eors	r2, r3, r2
8f629700:	e3a03000 	mov	r3, #0
8f629704:	1affffe3 	bne	8f629698 <cmd_erase_mmc+0x1d8>
8f629708:	e1a00007 	mov	r0, r7
}
8f62970c:	e28dd00c 	add	r13, r13, #12
8f629710:	e8bd43f0 	pop	{r4, r5, r6, r7, r8, r9, r14}
				free(footer);
8f629714:	ea002a7c 	b	8f63410c <free>
8f629718:	8f74221c 	.word	0x8f74221c

8f62971c <cmd_erase>:
{
8f62971c:	e59f3088 	ldr	r3, [pc, #136]	; 8f6297ac <cmd_erase+0x90>
8f629720:	e92d4070 	push	{r4, r5, r6, r14}
8f629724:	e24dd008 	sub	r13, r13, #8
8f629728:	e5933000 	ldr	r3, [r3]
8f62972c:	e58d3004 	str	r3, [r13, #4]
8f629730:	e3a03000 	mov	r3, #0
8f629734:	e1a04000 	mov	r4, r0
8f629738:	e1a05001 	mov	r5, r1
8f62973c:	e1a06002 	mov	r6, r2
	if(target_is_emmc_boot())
8f629740:	ebffe0ce 	bl	8f621a80 <target_is_emmc_boot>
		cmd_erase_mmc(arg, data, sz);
8f629744:	e59f3060 	ldr	r3, [pc, #96]	; 8f6297ac <cmd_erase+0x90>
	if(target_is_emmc_boot())
8f629748:	e3500000 	cmp	r0, #0
8f62974c:	0a00000a 	beq	8f62977c <cmd_erase+0x60>
		cmd_erase_mmc(arg, data, sz);
8f629750:	e5932000 	ldr	r2, [r3]
8f629754:	e59d3004 	ldr	r3, [r13, #4]
8f629758:	e0332002 	eors	r2, r3, r2
8f62975c:	e3a03000 	mov	r3, #0
8f629760:	1a000010 	bne	8f6297a8 <cmd_erase+0x8c>
8f629764:	e1a02006 	mov	r2, r6
8f629768:	e1a01005 	mov	r1, r5
8f62976c:	e1a00004 	mov	r0, r4
}
8f629770:	e28dd008 	add	r13, r13, #8
8f629774:	e8bd4070 	pop	{r4, r5, r6, r14}
		cmd_erase_mmc(arg, data, sz);
8f629778:	eaffff50 	b	8f6294c0 <cmd_erase_mmc>
		cmd_erase_nand(arg, data, sz);
8f62977c:	e5932000 	ldr	r2, [r3]
8f629780:	e59d3004 	ldr	r3, [r13, #4]
8f629784:	e0332002 	eors	r2, r3, r2
8f629788:	e3a03000 	mov	r3, #0
8f62978c:	1a000005 	bne	8f6297a8 <cmd_erase+0x8c>
8f629790:	e1a02006 	mov	r2, r6
8f629794:	e1a01005 	mov	r1, r5
8f629798:	e1a00004 	mov	r0, r4
}
8f62979c:	e28dd008 	add	r13, r13, #8
8f6297a0:	e8bd4070 	pop	{r4, r5, r6, r14}
		cmd_erase_nand(arg, data, sz);
8f6297a4:	eafffeef 	b	8f629368 <cmd_erase_nand>
8f6297a8:	eb002504 	bl	8f632bc0 <__stack_chk_fail>
8f6297ac:	8f74221c 	.word	0x8f74221c

8f6297b0 <cmd_flash_mmc_img>:
{
8f6297b0:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
8f6297b4:	e24dd008 	sub	r13, r13, #8
8f6297b8:	e59f3290 	ldr	r3, [pc, #656]	; 8f629a50 <cmd_flash_mmc_img+0x2a0>
8f6297bc:	e1a06002 	mov	r6, r2
8f6297c0:	e1a07001 	mov	r7, r1
	token = strtok_r((char *)arg, ":", &sp);
8f6297c4:	e1a0200d 	mov	r2, r13
8f6297c8:	e30a1354 	movw	r1, #41812	; 0xa354
8f6297cc:	e3481f70 	movt	r1, #36720	; 0x8f70
{
8f6297d0:	e5933000 	ldr	r3, [r3]
8f6297d4:	e58d3004 	str	r3, [r13, #4]
8f6297d8:	e3a03000 	mov	r3, #0
	token = strtok_r((char *)arg, ":", &sp);
8f6297dc:	eb002cd8 	bl	8f634b44 <strtok_r>
	token = strtok_r(NULL, ":", &sp);
8f6297e0:	e1a0200d 	mov	r2, r13
8f6297e4:	e30a1354 	movw	r1, #41812	; 0xa354
8f6297e8:	e3481f70 	movt	r1, #36720	; 0x8f70
	token = strtok_r((char *)arg, ":", &sp);
8f6297ec:	e1a04000 	mov	r4, r0
	token = strtok_r(NULL, ":", &sp);
8f6297f0:	e3a00000 	mov	r0, #0
8f6297f4:	eb002cd2 	bl	8f634b44 <strtok_r>
	if(token)
8f6297f8:	e250c000 	subs	r12, r0, #0
	bool lun_set = false;
8f6297fc:	01a0500c 	moveq	r5, r12
	if(token)
8f629800:	0a000003 	beq	8f629814 <cmd_flash_mmc_img+0x64>
		lun = atoi(token);
8f629804:	eb0026af 	bl	8f6332c8 <atoi>
		lun_set = true;
8f629808:	e3a05001 	mov	r5, #1
		mmc_set_lun(lun);
8f62980c:	e6ef0070 	uxtb	r0, r0
8f629810:	ebff8f07 	bl	8f60d434 <mmc_set_lun>
	if (pname)
8f629814:	e3540000 	cmp	r4, #0
8f629818:	0a000020 	beq	8f6298a0 <cmd_flash_mmc_img+0xf0>
		if (!strncmp(pname, "frp-unlock", strlen("frp-unlock")))
8f62981c:	e30902a4 	movw	r0, #37540	; 0x92a4
8f629820:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629824:	eb002bf7 	bl	8f634808 <strlen>
8f629828:	e30912a4 	movw	r1, #37540	; 0x92a4
8f62982c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f629830:	e1a02000 	mov	r2, r0
8f629834:	e1a00004 	mov	r0, r4
8f629838:	eb002c0b 	bl	8f63486c <strncmp>
8f62983c:	e3500000 	cmp	r0, #0
8f629840:	0a000066 	beq	8f6299e0 <cmd_flash_mmc_img+0x230>
		if (!strcmp(pname, "partition"))
8f629844:	e309123c 	movw	r1, #37436	; 0x923c
8f629848:	e1a00004 	mov	r0, r4
8f62984c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f629850:	eb002b33 	bl	8f634524 <strcmp>
8f629854:	e3500000 	cmp	r0, #0
8f629858:	1a00001b 	bne	8f6298cc <cmd_flash_mmc_img+0x11c>
			dprintf(INFO, "Attempt to write partition image.\n");
8f62985c:	e30902f4 	movw	r0, #37620	; 0x92f4
8f629860:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629864:	eb002442 	bl	8f632974 <_dprintf>
			if (write_partition(sz, (unsigned char *) data)) {
8f629868:	e1a01007 	mov	r1, r7
8f62986c:	e1a00006 	mov	r0, r6
8f629870:	ebff68ee 	bl	8f603c30 <write_partition>
8f629874:	e3500000 	cmp	r0, #0
8f629878:	1a00005c 	bne	8f6299f0 <cmd_flash_mmc_img+0x240>
			publish_getvar_partition_info(part_info, partition_get_partition_count());
8f62987c:	ebff68c5 	bl	8f603b98 <partition_get_partition_count>
8f629880:	e6ef0070 	uxtb	r0, r0
8f629884:	ebfff132 	bl	8f625d54 <publish_getvar_partition_info.constprop.0>
			if (partition_scan_for_multislot())
8f629888:	ebff6d5d 	bl	8f604e04 <partition_scan_for_multislot>
8f62988c:	e3500000 	cmp	r0, #0
	int current_active_slot = INVALID;
8f629890:	03e04000 	mvneq	r4, #0
			if (partition_scan_for_multislot())
8f629894:	1a000048 	bne	8f6299bc <cmd_flash_mmc_img+0x20c>
			partition_mark_active_slot(current_active_slot);
8f629898:	e1a00004 	mov	r0, r4
8f62989c:	ebff6e13 	bl	8f6050f0 <partition_mark_active_slot>
	fastboot_okay("");
8f6298a0:	e3070138 	movw	r0, #28984	; 0x7138
8f6298a4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6298a8:	eb000dbb 	bl	8f62cf9c <fastboot_okay>
}
8f6298ac:	e59f319c 	ldr	r3, [pc, #412]	; 8f629a50 <cmd_flash_mmc_img+0x2a0>
8f6298b0:	e5932000 	ldr	r2, [r3]
8f6298b4:	e59d3004 	ldr	r3, [r13, #4]
8f6298b8:	e0332002 	eors	r2, r3, r2
8f6298bc:	e3a03000 	mov	r3, #0
8f6298c0:	1a000061 	bne	8f629a4c <cmd_flash_mmc_img+0x29c>
8f6298c4:	e28dd008 	add	r13, r13, #8
8f6298c8:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
			index = partition_get_index(pname);
8f6298cc:	e1a00004 	mov	r0, r4
8f6298d0:	ebff68ed 	bl	8f603c8c <partition_get_index>
8f6298d4:	e1a0a000 	mov	r10, r0
			ptn = partition_get_offset(index);
8f6298d8:	ebff6bf7 	bl	8f6048bc <partition_get_offset>
			if(ptn == 0) {
8f6298dc:	e1903001 	orrs	r3, r0, r1
			ptn = partition_get_offset(index);
8f6298e0:	e1a09000 	mov	r9, r0
8f6298e4:	e1a08001 	mov	r8, r1
			if(ptn == 0) {
8f6298e8:	0a000048 	beq	8f629a10 <cmd_flash_mmc_img+0x260>
			if (!strncmp(pname, "boot", strlen("boot"))
8f6298ec:	e30a0370 	movw	r0, #41840	; 0xa370
8f6298f0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6298f4:	eb002bc3 	bl	8f634808 <strlen>
8f6298f8:	e30a1370 	movw	r1, #41840	; 0xa370
8f6298fc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f629900:	e1a02000 	mov	r2, r0
8f629904:	e1a00004 	mov	r0, r4
8f629908:	eb002bd7 	bl	8f63486c <strncmp>
8f62990c:	e3500000 	cmp	r0, #0
8f629910:	1a000022 	bne	8f6299a0 <cmd_flash_mmc_img+0x1f0>
				if (memcmp((void *)data, BOOT_MAGIC, BOOT_MAGIC_SIZE)) {
8f629914:	e3a02008 	mov	r2, #8
8f629918:	e308187c 	movw	r1, #34940	; 0x887c
8f62991c:	e1a00007 	mov	r0, r7
8f629920:	e3481f70 	movt	r1, #36720	; 0x8f70
8f629924:	eb002aab 	bl	8f6343d8 <memcmp>
8f629928:	e3500000 	cmp	r0, #0
8f62992c:	1a000033 	bne	8f629a00 <cmd_flash_mmc_img+0x250>
				if (partition_multislot_is_supported())
8f629930:	ebff6f75 	bl	8f60570c <partition_multislot_is_supported>
8f629934:	e3500000 	cmp	r0, #0
8f629938:	1a000040 	bne	8f629a40 <cmd_flash_mmc_img+0x290>
			if(!lun_set)
8f62993c:	e3550000 	cmp	r5, #0
8f629940:	0a00003a 	beq	8f629a30 <cmd_flash_mmc_img+0x280>
			size = partition_get_size(index);
8f629944:	e1a0000a 	mov	r0, r10
8f629948:	ebff6bba 	bl	8f604838 <partition_get_size>
			if (ROUND_TO_PAGE(sz, mmc_blocksize_mask) > size) {
8f62994c:	e30f364c 	movw	r3, #63052	; 0xf64c
8f629950:	e3483f73 	movt	r3, #36723	; 0x8f73
8f629954:	e5932000 	ldr	r2, [r3]
8f629958:	e0823006 	add	r3, r2, r6
8f62995c:	e1c33002 	bic	r3, r3, r2
8f629960:	e1530006 	cmp	r3, r6
8f629964:	33e03000 	mvncc	r3, #0
8f629968:	e1500003 	cmp	r0, r3
8f62996c:	e2d13000 	sbcs	r3, r1, #0
8f629970:	3a00002a 	bcc	8f629a20 <cmd_flash_mmc_img+0x270>
			else if (mmc_write(ptn , sz, (unsigned int *)data)) {
8f629974:	e1a03007 	mov	r3, r7
8f629978:	e1a02006 	mov	r2, r6
8f62997c:	e1a00009 	mov	r0, r9
8f629980:	e1a01008 	mov	r1, r8
8f629984:	ebff8c25 	bl	8f60ca20 <mmc_write>
8f629988:	e3500000 	cmp	r0, #0
8f62998c:	0affffc3 	beq	8f6298a0 <cmd_flash_mmc_img+0xf0>
				fastboot_fail("flash write failure");
8f629990:	e3090384 	movw	r0, #37764	; 0x9384
8f629994:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629998:	eb000d5c 	bl	8f62cf10 <fastboot_fail>
				return;
8f62999c:	eaffffc2 	b	8f6298ac <cmd_flash_mmc_img+0xfc>
					|| !strcmp(pname, "recovery"))
8f6299a0:	e1a00004 	mov	r0, r4
8f6299a4:	e3001d34 	movw	r1, #3380	; 0xd34
8f6299a8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6299ac:	eb002adc 	bl	8f634524 <strcmp>
8f6299b0:	e3500000 	cmp	r0, #0
8f6299b4:	1affffe0 	bne	8f62993c <cmd_flash_mmc_img+0x18c>
8f6299b8:	eaffffd5 	b	8f629914 <cmd_flash_mmc_img+0x164>
				current_active_slot = partition_find_active_slot();
8f6299bc:	ebff6d82 	bl	8f604fcc <partition_find_active_slot>
				dprintf(INFO, "Multislot supported: Slot %s active",
8f6299c0:	e30132e0 	movw	r3, #4832	; 0x12e0
8f6299c4:	e3483f71 	movt	r3, #36721	; 0x8f71
				current_active_slot = partition_find_active_slot();
8f6299c8:	e1a04000 	mov	r4, r0
				dprintf(INFO, "Multislot supported: Slot %s active",
8f6299cc:	e3090334 	movw	r0, #37684	; 0x9334
8f6299d0:	e7931104 	ldr	r1, [r3, r4, lsl #2]
8f6299d4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6299d8:	eb0023e5 	bl	8f632974 <_dprintf>
8f6299dc:	eaffffad 	b	8f629898 <cmd_flash_mmc_img+0xe8>
				fastboot_fail("Secret key is invalid, please update the bootloader with secret key");
8f6299e0:	e30902b0 	movw	r0, #37552	; 0x92b0
8f6299e4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6299e8:	eb000d48 	bl	8f62cf10 <fastboot_fail>
			return;
8f6299ec:	eaffffae 	b	8f6298ac <cmd_flash_mmc_img+0xfc>
				fastboot_fail("failed to write partition");
8f6299f0:	e3090318 	movw	r0, #37656	; 0x9318
8f6299f4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6299f8:	eb000d44 	bl	8f62cf10 <fastboot_fail>
				return;
8f6299fc:	eaffffaa 	b	8f6298ac <cmd_flash_mmc_img+0xfc>
					fastboot_fail("image is not a boot image");
8f629a00:	e3090358 	movw	r0, #37720	; 0x9358
8f629a04:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629a08:	eb000d40 	bl	8f62cf10 <fastboot_fail>
					return;
8f629a0c:	eaffffa6 	b	8f6298ac <cmd_flash_mmc_img+0xfc>
				fastboot_fail("partition table doesn't exist");
8f629a10:	e30901ac 	movw	r0, #37292	; 0x91ac
8f629a14:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629a18:	eb000d3c 	bl	8f62cf10 <fastboot_fail>
				return;
8f629a1c:	eaffffa2 	b	8f6298ac <cmd_flash_mmc_img+0xfc>
				fastboot_fail("size too large");
8f629a20:	e3090374 	movw	r0, #37748	; 0x9374
8f629a24:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629a28:	eb000d38 	bl	8f62cf10 <fastboot_fail>
				return;
8f629a2c:	eaffff9e 	b	8f6298ac <cmd_flash_mmc_img+0xfc>
				lun = partition_get_lun(index);
8f629a30:	e1a0000a 	mov	r0, r10
8f629a34:	ebff6bc1 	bl	8f604940 <partition_get_lun>
				mmc_set_lun(lun);
8f629a38:	ebff8e7d 	bl	8f60d434 <mmc_set_lun>
8f629a3c:	eaffffc0 	b	8f629944 <cmd_flash_mmc_img+0x194>
					partition_reset_attributes(index);
8f629a40:	e1a0000a 	mov	r0, r10
8f629a44:	ebff6e9c 	bl	8f6054bc <partition_reset_attributes>
8f629a48:	eaffffbb 	b	8f62993c <cmd_flash_mmc_img+0x18c>
}
8f629a4c:	eb00245b 	bl	8f632bc0 <__stack_chk_fail>
8f629a50:	8f74221c 	.word	0x8f74221c

8f629a54 <cmd_flash_meta_img>:
	if( (UINT_MAX - sz) > (uintptr_t)data )
8f629a54:	e1e03002 	mvn	r3, r2
8f629a58:	e1530001 	cmp	r3, r1
{
8f629a5c:	e59f3218 	ldr	r3, [pc, #536]	; 8f629c7c <cmd_flash_meta_img+0x228>
8f629a60:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f629a64:	e24dd00c 	sub	r13, r13, #12
8f629a68:	e5933000 	ldr	r3, [r3]
8f629a6c:	e58d3004 	str	r3, [r13, #4]
8f629a70:	e3a03000 	mov	r3, #0
	if( (UINT_MAX - sz) > (uintptr_t)data )
8f629a74:	9a000068 	bls	8f629c1c <cmd_flash_meta_img+0x1c8>
		data_end  = (uintptr_t)data + sz;
8f629a78:	e0816002 	add	r6, r1, r2
	if( data_end < ((uintptr_t)data + sizeof(meta_header_t)))
8f629a7c:	e281404c 	add	r4, r1, #76	; 0x4c
8f629a80:	e1540006 	cmp	r4, r6
8f629a84:	e1a05001 	mov	r5, r1
8f629a88:	8a000063 	bhi	8f629c1c <cmd_flash_meta_img+0x1c8>
	if( data_end < ((uintptr_t)data + meta_header->img_hdr_sz))
8f629a8c:	e1d174ba 	ldrh	r7, [r1, #74]	; 0x4a
8f629a90:	e0873001 	add	r3, r7, r1
8f629a94:	e1530006 	cmp	r3, r6
8f629a98:	8a00005f 	bhi	8f629c1c <cmd_flash_meta_img+0x1c8>
	images = meta_header->img_hdr_sz / sizeof(img_header_entry_t);
8f629a9c:	e30c3ccd 	movw	r3, #52429	; 0xcccd
8f629aa0:	e34c3ccc 	movt	r3, #52428	; 0xcccc
	for (i=0; i<images; i++) {
8f629aa4:	e357004f 	cmp	r7, #79	; 0x4f
8f629aa8:	e1a08000 	mov	r8, r0
	images = meta_header->img_hdr_sz / sizeof(img_header_entry_t);
8f629aac:	e0873793 	umull	r3, r7, r3, r7
8f629ab0:	e1a07327 	lsr	r7, r7, #6
	for (i=0; i<images; i++) {
8f629ab4:	9a00001b 	bls	8f629b28 <cmd_flash_meta_img+0xd4>
		if((img_header_entry[i].ptn_name == NULL) ||
8f629ab8:	e3540000 	cmp	r4, #0
8f629abc:	0a000019 	beq	8f629b28 <cmd_flash_meta_img+0xd4>
	for (i=0; i<images; i++) {
8f629ac0:	e3a09000 	mov	r9, #0
8f629ac4:	ea000014 	b	8f629b1c <cmd_flash_meta_img+0xc8>
			(img_header_entry[i].size == 0))
8f629ac8:	e594204c 	ldr	r2, [r4, #76]	; 0x4c
			(img_header_entry[i].start_offset == 0) ||
8f629acc:	e3520000 	cmp	r2, #0
8f629ad0:	0a000014 	beq	8f629b28 <cmd_flash_meta_img+0xd4>
		if ((UINT_MAX - img_header_entry[i].start_offset) < (uintptr_t)data) {
8f629ad4:	e1e01003 	mvn	r1, r3
8f629ad8:	e1550001 	cmp	r5, r1
8f629adc:	8a000059 	bhi	8f629c48 <cmd_flash_meta_img+0x1f4>
		else if ((UINT_MAX - (img_header_entry[i].start_offset + (uintptr_t)data)) < img_header_entry[i].size) {
8f629ae0:	e0851003 	add	r1, r5, r3
8f629ae4:	e1e03001 	mvn	r3, r1
8f629ae8:	e1520003 	cmp	r2, r3
8f629aec:	8a000059 	bhi	8f629c58 <cmd_flash_meta_img+0x204>
						+ img_header_entry[i].size) )
8f629af0:	e0823001 	add	r3, r2, r1
		if( data_end < ((uintptr_t)data + img_header_entry[i].start_offset
8f629af4:	e1530006 	cmp	r3, r6
8f629af8:	8a00005a 	bhi	8f629c68 <cmd_flash_meta_img+0x214>
	for (i=0; i<images; i++) {
8f629afc:	e2899001 	add	r9, r9, #1
		cmd_flash_mmc_img(img_header_entry[i].ptn_name,
8f629b00:	e1a00004 	mov	r0, r4
8f629b04:	ebffff29 	bl	8f6297b0 <cmd_flash_mmc_img>
	for (i=0; i<images; i++) {
8f629b08:	e1570009 	cmp	r7, r9
8f629b0c:	0a000005 	beq	8f629b28 <cmd_flash_meta_img+0xd4>
		if((img_header_entry[i].ptn_name == NULL) ||
8f629b10:	e3740050 	cmn	r4, #80	; 0x50
8f629b14:	e2844050 	add	r4, r4, #80	; 0x50
8f629b18:	0a000002 	beq	8f629b28 <cmd_flash_meta_img+0xd4>
			(img_header_entry[i].start_offset == 0) ||
8f629b1c:	e5943048 	ldr	r3, [r4, #72]	; 0x48
		if((img_header_entry[i].ptn_name == NULL) ||
8f629b20:	e3530000 	cmp	r3, #0
8f629b24:	1affffe7 	bne	8f629ac8 <cmd_flash_meta_img+0x74>
	if (!strncmp(arg, "bootloader", strlen("bootloader")))
8f629b28:	e30a03d0 	movw	r0, #41936	; 0xa3d0
8f629b2c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629b30:	eb002b34 	bl	8f634808 <strlen>
8f629b34:	e30a13d0 	movw	r1, #41936	; 0xa3d0
8f629b38:	e3481f70 	movt	r1, #36720	; 0x8f70
8f629b3c:	e1a02000 	mov	r2, r0
8f629b40:	e1a00008 	mov	r0, r8
8f629b44:	eb002b48 	bl	8f63486c <strncmp>
		strlcpy(device.bootloader_version, TARGET(BOARD), MAX_VERSION_LEN);
8f629b48:	e3a02040 	mov	r2, #64	; 0x40
	if (!strncmp(arg, "bootloader", strlen("bootloader")))
8f629b4c:	e3500000 	cmp	r0, #0
8f629b50:	0a00001d 	beq	8f629bcc <cmd_flash_meta_img+0x178>
		strlcpy(device.radio_version, TARGET(BOARD), MAX_VERSION_LEN);
8f629b54:	e59f0124 	ldr	r0, [pc, #292]	; 8f629c80 <cmd_flash_meta_img+0x22c>
8f629b58:	e3091440 	movw	r1, #37952	; 0x9440
8f629b5c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f629b60:	eb002af2 	bl	8f634730 <strlcpy>
		strlcat(device.radio_version, "-", MAX_VERSION_LEN);
8f629b64:	e3a02040 	mov	r2, #64	; 0x40
8f629b68:	e59f0110 	ldr	r0, [pc, #272]	; 8f629c80 <cmd_flash_meta_img+0x22c>
8f629b6c:	e30a1f74 	movw	r1, #44916	; 0xaf74
8f629b70:	e3481f70 	movt	r1, #36720	; 0x8f70
8f629b74:	eb002ab6 	bl	8f634654 <strlcat>
		strlcat(device.radio_version, meta_header->img_version, MAX_VERSION_LEN);
8f629b78:	e2851008 	add	r1, r5, #8
8f629b7c:	e3a02040 	mov	r2, #64	; 0x40
8f629b80:	e59f00f8 	ldr	r0, [pc, #248]	; 8f629c80 <cmd_flash_meta_img+0x22c>
8f629b84:	eb002ab2 	bl	8f634654 <strlcat>
	if(target_is_emmc_boot())
8f629b88:	ebffdfbc 	bl	8f621a80 <target_is_emmc_boot>
8f629b8c:	e3500000 	cmp	r0, #0
8f629b90:	0a00001d 	beq	8f629c0c <cmd_flash_meta_img+0x1b8>
8f629b94:	e3010ad0 	movw	r0, #6864	; 0x1ad0
8f629b98:	e3480f71 	movt	r0, #36721	; 0x8f71
8f629b9c:	ebfff025 	bl	8f625c38 <write_device_info.part.0>
	fastboot_okay("");
8f629ba0:	e59f30d4 	ldr	r3, [pc, #212]	; 8f629c7c <cmd_flash_meta_img+0x228>
8f629ba4:	e5932000 	ldr	r2, [r3]
8f629ba8:	e59d3004 	ldr	r3, [r13, #4]
8f629bac:	e0332002 	eors	r2, r3, r2
8f629bb0:	e3a03000 	mov	r3, #0
8f629bb4:	1a00002f 	bne	8f629c78 <cmd_flash_meta_img+0x224>
8f629bb8:	e3070138 	movw	r0, #28984	; 0x7138
8f629bbc:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f629bc0:	e28dd00c 	add	r13, r13, #12
8f629bc4:	e8bd43f0 	pop	{r4, r5, r6, r7, r8, r9, r14}
	fastboot_okay("");
8f629bc8:	ea000cf3 	b	8f62cf9c <fastboot_okay>
		strlcpy(device.bootloader_version, TARGET(BOARD), MAX_VERSION_LEN);
8f629bcc:	e59f00b0 	ldr	r0, [pc, #176]	; 8f629c84 <cmd_flash_meta_img+0x230>
8f629bd0:	e3091440 	movw	r1, #37952	; 0x9440
8f629bd4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f629bd8:	eb002ad4 	bl	8f634730 <strlcpy>
		strlcat(device.bootloader_version, "-", MAX_VERSION_LEN);
8f629bdc:	e3a02040 	mov	r2, #64	; 0x40
8f629be0:	e59f009c 	ldr	r0, [pc, #156]	; 8f629c84 <cmd_flash_meta_img+0x230>
8f629be4:	e30a1f74 	movw	r1, #44916	; 0xaf74
8f629be8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f629bec:	eb002a98 	bl	8f634654 <strlcat>
		strlcat(device.bootloader_version, meta_header->img_version, MAX_VERSION_LEN);
8f629bf0:	e2851008 	add	r1, r5, #8
8f629bf4:	e3a02040 	mov	r2, #64	; 0x40
8f629bf8:	e59f0084 	ldr	r0, [pc, #132]	; 8f629c84 <cmd_flash_meta_img+0x230>
8f629bfc:	eb002a94 	bl	8f634654 <strlcat>
	if(target_is_emmc_boot())
8f629c00:	ebffdf9e 	bl	8f621a80 <target_is_emmc_boot>
8f629c04:	e3500000 	cmp	r0, #0
8f629c08:	1affffe1 	bne	8f629b94 <cmd_flash_meta_img+0x140>
	dprintf(CRITICAL, "Ignoring attempt to write device info\n");
8f629c0c:	e3070510 	movw	r0, #29968	; 0x7510
8f629c10:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629c14:	eb002356 	bl	8f632974 <_dprintf>
}
8f629c18:	eaffffe0 	b	8f629ba0 <cmd_flash_meta_img+0x14c>
		fastboot_fail("Cannot  flash: image header corrupt");
8f629c1c:	e59f3058 	ldr	r3, [pc, #88]	; 8f629c7c <cmd_flash_meta_img+0x228>
8f629c20:	e5932000 	ldr	r2, [r3]
8f629c24:	e59d3004 	ldr	r3, [r13, #4]
8f629c28:	e0332002 	eors	r2, r3, r2
8f629c2c:	e3a03000 	mov	r3, #0
8f629c30:	1a000010 	bne	8f629c78 <cmd_flash_meta_img+0x224>
8f629c34:	e3090398 	movw	r0, #37784	; 0x9398
8f629c38:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f629c3c:	e28dd00c 	add	r13, r13, #12
8f629c40:	e8bd43f0 	pop	{r4, r5, r6, r7, r8, r9, r14}
		fastboot_fail("Cannot  flash: image header corrupt");
8f629c44:	ea000cb1 	b	8f62cf10 <fastboot_fail>
			fastboot_fail("Integer overflow detected in start_offset of img");
8f629c48:	e30903bc 	movw	r0, #37820	; 0x93bc
8f629c4c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629c50:	eb000cae 	bl	8f62cf10 <fastboot_fail>
			break;
8f629c54:	eaffffb3 	b	8f629b28 <cmd_flash_meta_img+0xd4>
			fastboot_fail("Integer overflow detected in size of img");
8f629c58:	e30903f0 	movw	r0, #37872	; 0x93f0
8f629c5c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629c60:	eb000caa 	bl	8f62cf10 <fastboot_fail>
			break;
8f629c64:	eaffffaf 	b	8f629b28 <cmd_flash_meta_img+0xd4>
			fastboot_fail("Cannot  flash: image size mismatch");
8f629c68:	e309041c 	movw	r0, #37916	; 0x941c
8f629c6c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629c70:	eb000ca6 	bl	8f62cf10 <fastboot_fail>
			break;
8f629c74:	eaffffab 	b	8f629b28 <cmd_flash_meta_img+0xd4>
	fastboot_okay("");
8f629c78:	eb0023d0 	bl	8f632bc0 <__stack_chk_fail>
8f629c7c:	8f74221c 	.word	0x8f74221c
8f629c80:	8f711b70 	.word	0x8f711b70
8f629c84:	8f711b30 	.word	0x8f711b30

8f629c88 <cmd_flash_mmc_sparse_img>:
{
8f629c88:	e59f3800 	ldr	r3, [pc, #2048]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f629c8c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f629c90:	e24dd01c 	sub	r13, r13, #28
8f629c94:	e5933000 	ldr	r3, [r3]
8f629c98:	e58d3014 	str	r3, [r13, #20]
8f629c9c:	e3a03000 	mov	r3, #0
8f629ca0:	e1a04001 	mov	r4, r1
8f629ca4:	e1a09002 	mov	r9, r2
	index = partition_get_index(arg);
8f629ca8:	ebff67f7 	bl	8f603c8c <partition_get_index>
8f629cac:	e1a05000 	mov	r5, r0
	ptn = partition_get_offset(index);
8f629cb0:	ebff6b01 	bl	8f6048bc <partition_get_offset>
	if(ptn == 0) {
8f629cb4:	e1903001 	orrs	r3, r0, r1
8f629cb8:	0a000030 	beq	8f629d80 <cmd_flash_mmc_sparse_img+0xf8>
8f629cbc:	e1a06000 	mov	r6, r0
	size = partition_get_size(index);
8f629cc0:	e1a00005 	mov	r0, r5
8f629cc4:	e1a07001 	mov	r7, r1
8f629cc8:	ebff6ada 	bl	8f604838 <partition_get_size>
8f629ccc:	e1a0b000 	mov	r11, r0
	lun = partition_get_lun(index);
8f629cd0:	e1a00005 	mov	r0, r5
	size = partition_get_size(index);
8f629cd4:	e1a08001 	mov	r8, r1
	lun = partition_get_lun(index);
8f629cd8:	ebff6b18 	bl	8f604940 <partition_get_lun>
	mmc_set_lun(lun);
8f629cdc:	ebff8dd4 	bl	8f60d434 <mmc_set_lun>
	if (sz < sizeof(sparse_header_t)) {
8f629ce0:	e359001b 	cmp	r9, #27
8f629ce4:	9a00005b 	bls	8f629e58 <cmd_flash_mmc_sparse_img+0x1d0>
	if (!sparse_header->blk_sz || (sparse_header->blk_sz % 4)){
8f629ce8:	e594300c 	ldr	r3, [r4, #12]
8f629cec:	e3530000 	cmp	r3, #0
8f629cf0:	0a000017 	beq	8f629d54 <cmd_flash_mmc_sparse_img+0xcc>
8f629cf4:	e3130003 	tst	r3, #3
8f629cf8:	1a000015 	bne	8f629d54 <cmd_flash_mmc_sparse_img+0xcc>
	if (((uint64_t)sparse_header->total_blks * (uint64_t)sparse_header->blk_sz) > size) {
8f629cfc:	e5942010 	ldr	r2, [r4, #16]
8f629d00:	e0823293 	umull	r3, r2, r3, r2
8f629d04:	e15b0003 	cmp	r11, r3
8f629d08:	e0d83002 	sbcs	r3, r8, r2
8f629d0c:	3a0000b5 	bcc	8f629fe8 <cmd_flash_mmc_sparse_img+0x360>
	uintptr_t data_end = (uintptr_t)data + sz;
8f629d10:	e0843009 	add	r3, r4, r9
	data += sizeof(sparse_header_t);
8f629d14:	e284901c 	add	r9, r4, #28
	if (data_end < (uintptr_t)data) {
8f629d18:	e1590003 	cmp	r9, r3
	uintptr_t data_end = (uintptr_t)data + sz;
8f629d1c:	e58d3000 	str	r3, [r13]
	if (data_end < (uintptr_t)data) {
8f629d20:	8a000043 	bhi	8f629e34 <cmd_flash_mmc_sparse_img+0x1ac>
	if(sparse_header->file_hdr_sz != sizeof(sparse_header_t))
8f629d24:	e1d430b8 	ldrh	r3, [r4, #8]
8f629d28:	e353001c 	cmp	r3, #28
8f629d2c:	0a000054 	beq	8f629e84 <cmd_flash_mmc_sparse_img+0x1fc>
		fastboot_fail("sparse header size mismatch");
8f629d30:	e59f3758 	ldr	r3, [pc, #1880]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f629d34:	e5932000 	ldr	r2, [r3]
8f629d38:	e59d3014 	ldr	r3, [r13, #20]
8f629d3c:	e0332002 	eors	r2, r3, r2
8f629d40:	e3a03000 	mov	r3, #0
8f629d44:	030904b0 	movweq	r0, #38064	; 0x94b0
8f629d48:	03480f70 	movteq	r0, #36720	; 0x8f70
8f629d4c:	0a000008 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
	fastboot_okay("");
8f629d50:	eb00239a 	bl	8f632bc0 <__stack_chk_fail>
		fastboot_fail("Invalid block size\n");
8f629d54:	e59f3734 	ldr	r3, [pc, #1844]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f629d58:	e5932000 	ldr	r2, [r3]
8f629d5c:	e59d3014 	ldr	r3, [r13, #20]
8f629d60:	e0332002 	eors	r2, r3, r2
8f629d64:	e3a03000 	mov	r3, #0
8f629d68:	03090464 	movweq	r0, #37988	; 0x9464
8f629d6c:	03480f70 	movteq	r0, #36720	; 0x8f70
8f629d70:	1afffff6 	bne	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
}
8f629d74:	e28dd01c 	add	r13, r13, #28
8f629d78:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
		fastboot_fail("size too low");
8f629d7c:	ea000c63 	b	8f62cf10 <fastboot_fail>
		fastboot_fail("partition table doesn't exist");
8f629d80:	e59f3708 	ldr	r3, [pc, #1800]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f629d84:	e5932000 	ldr	r2, [r3]
8f629d88:	e59d3014 	ldr	r3, [r13, #20]
8f629d8c:	e0332002 	eors	r2, r3, r2
8f629d90:	e3a03000 	mov	r3, #0
8f629d94:	030901ac 	movweq	r0, #37292	; 0x91ac
8f629d98:	03480f70 	movteq	r0, #36720	; 0x8f70
8f629d9c:	1affffeb 	bne	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
}
8f629da0:	e28dd01c 	add	r13, r13, #28
8f629da4:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
		fastboot_fail("size too low");
8f629da8:	ea000c58 	b	8f62cf10 <fastboot_fail>
			if(chunk_header->total_sz != sparse_header->chunk_hdr_sz)
8f629dac:	e5993008 	ldr	r3, [r9, #8]
8f629db0:	e353000c 	cmp	r3, #12
8f629db4:	1a000196 	bne	8f62a414 <cmd_flash_mmc_sparse_img+0x78c>
			if(total_blocks > (UINT_MAX - chunk_header->chunk_sz)) {
8f629db8:	e1e03001 	mvn	r3, r1
8f629dbc:	e1530005 	cmp	r3, r5
8f629dc0:	3a00018a 	bcc	8f62a3f0 <cmd_flash_mmc_sparse_img+0x768>
			if ((uintptr_t)data > UINT_MAX - chunk_data_sz) {
8f629dc4:	e1e03002 	mvn	r3, r2
8f629dc8:	e26ee000 	rsb	r14, r14, #0
8f629dcc:	e1530006 	cmp	r3, r6
			total_blocks += chunk_header->chunk_sz;
8f629dd0:	e0855001 	add	r5, r5, r1
			if ((uintptr_t)data > UINT_MAX - chunk_data_sz) {
8f629dd4:	e2de3000 	sbcs	r3, r14, #0
8f629dd8:	3a000141 	bcc	8f62a2e4 <cmd_flash_mmc_sparse_img+0x65c>
			if (data_end < (uintptr_t)data) {
8f629ddc:	e59d3000 	ldr	r3, [r13]
			data += (uint32_t)chunk_data_sz;
8f629de0:	e0869002 	add	r9, r6, r2
			if (data_end < (uintptr_t)data) {
8f629de4:	e1590003 	cmp	r9, r3
8f629de8:	8a000011 	bhi	8f629e34 <cmd_flash_mmc_sparse_img+0x1ac>
	for (chunk=0; chunk<sparse_header->total_chunks; chunk++)
8f629dec:	e59d3008 	ldr	r3, [r13, #8]
8f629df0:	e2833001 	add	r3, r3, #1
8f629df4:	e58d3008 	str	r3, [r13, #8]
8f629df8:	e1a02003 	mov	r2, r3
8f629dfc:	e5943014 	ldr	r3, [r4, #20]
8f629e00:	e1530002 	cmp	r3, r2
8f629e04:	9a000108 	bls	8f62a22c <cmd_flash_mmc_sparse_img+0x5a4>
		if(((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz) >= size) {
8f629e08:	e594300c 	ldr	r3, [r4, #12]
8f629e0c:	e1a0a005 	mov	r10, r5
8f629e10:	e3a07000 	mov	r7, #0
8f629e14:	e0823395 	umull	r3, r2, r5, r3
8f629e18:	e153000b 	cmp	r3, r11
8f629e1c:	e0d23008 	sbcs	r3, r2, r8
8f629e20:	2a000070 	bcs	8f629fe8 <cmd_flash_mmc_sparse_img+0x360>
		if (data_end < (uintptr_t)data) {
8f629e24:	e59d3000 	ldr	r3, [r13]
		data += sizeof(chunk_header_t);
8f629e28:	e289600c 	add	r6, r9, #12
		if (data_end < (uintptr_t)data) {
8f629e2c:	e1560003 	cmp	r6, r3
8f629e30:	9a000046 	bls	8f629f50 <cmd_flash_mmc_sparse_img+0x2c8>
		fastboot_fail("buffer overreads occured due to invalid sparse header");
8f629e34:	e59f3654 	ldr	r3, [pc, #1620]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f629e38:	e5932000 	ldr	r2, [r3]
8f629e3c:	e59d3014 	ldr	r3, [r13, #20]
8f629e40:	e0332002 	eors	r2, r3, r2
8f629e44:	e3a03000 	mov	r3, #0
8f629e48:	03090478 	movweq	r0, #38008	; 0x9478
8f629e4c:	03480f70 	movteq	r0, #36720	; 0x8f70
8f629e50:	0affffc7 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
8f629e54:	eaffffbd 	b	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
		fastboot_fail("size too low");
8f629e58:	e59f3630 	ldr	r3, [pc, #1584]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f629e5c:	e5932000 	ldr	r2, [r3]
8f629e60:	e59d3014 	ldr	r3, [r13, #20]
8f629e64:	e0332002 	eors	r2, r3, r2
8f629e68:	e3a03000 	mov	r3, #0
8f629e6c:	03090454 	movweq	r0, #37972	; 0x9454
8f629e70:	03480f70 	movteq	r0, #36720	; 0x8f70
8f629e74:	1affffb5 	bne	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
}
8f629e78:	e28dd01c 	add	r13, r13, #28
8f629e7c:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
		fastboot_fail("size too low");
8f629e80:	ea000c22 	b	8f62cf10 <fastboot_fail>
	dprintf (SPEW, "=== Sparse Image Header ===\n");
8f629e84:	e30904cc 	movw	r0, #38092	; 0x94cc
8f629e88:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629e8c:	eb0022b8 	bl	8f632974 <_dprintf>
	dprintf (SPEW, "magic: 0x%x\n", sparse_header->magic);
8f629e90:	e5941000 	ldr	r1, [r4]
8f629e94:	e30904ec 	movw	r0, #38124	; 0x94ec
8f629e98:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629e9c:	eb0022b4 	bl	8f632974 <_dprintf>
	dprintf (SPEW, "major_version: 0x%x\n", sparse_header->major_version);
8f629ea0:	e1d410b4 	ldrh	r1, [r4, #4]
8f629ea4:	e30904fc 	movw	r0, #38140	; 0x94fc
8f629ea8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629eac:	eb0022b0 	bl	8f632974 <_dprintf>
	dprintf (SPEW, "minor_version: 0x%x\n", sparse_header->minor_version);
8f629eb0:	e1d410b6 	ldrh	r1, [r4, #6]
8f629eb4:	e3090514 	movw	r0, #38164	; 0x9514
8f629eb8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629ebc:	eb0022ac 	bl	8f632974 <_dprintf>
	dprintf (SPEW, "file_hdr_sz: %d\n", sparse_header->file_hdr_sz);
8f629ec0:	e1d410b8 	ldrh	r1, [r4, #8]
8f629ec4:	e309052c 	movw	r0, #38188	; 0x952c
8f629ec8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629ecc:	eb0022a8 	bl	8f632974 <_dprintf>
	dprintf (SPEW, "chunk_hdr_sz: %d\n", sparse_header->chunk_hdr_sz);
8f629ed0:	e1d410ba 	ldrh	r1, [r4, #10]
8f629ed4:	e3090540 	movw	r0, #38208	; 0x9540
8f629ed8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629edc:	eb0022a4 	bl	8f632974 <_dprintf>
	dprintf (SPEW, "blk_sz: %d\n", sparse_header->blk_sz);
8f629ee0:	e594100c 	ldr	r1, [r4, #12]
8f629ee4:	e3090554 	movw	r0, #38228	; 0x9554
8f629ee8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629eec:	eb0022a0 	bl	8f632974 <_dprintf>
	dprintf (SPEW, "total_blks: %d\n", sparse_header->total_blks);
8f629ef0:	e5941010 	ldr	r1, [r4, #16]
8f629ef4:	e3090560 	movw	r0, #38240	; 0x9560
8f629ef8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629efc:	eb00229c 	bl	8f632974 <_dprintf>
	dprintf (SPEW, "total_chunks: %d\n", sparse_header->total_chunks);
8f629f00:	e5941014 	ldr	r1, [r4, #20]
8f629f04:	e3090570 	movw	r0, #38256	; 0x9570
8f629f08:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629f0c:	eb002298 	bl	8f632974 <_dprintf>
	for (chunk=0; chunk<sparse_header->total_chunks; chunk++)
8f629f10:	e5945014 	ldr	r5, [r4, #20]
8f629f14:	e3550000 	cmp	r5, #0
8f629f18:	0a0000c3 	beq	8f62a22c <cmd_flash_mmc_sparse_img+0x5a4>
		if(((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz) >= size) {
8f629f1c:	e19b3008 	orrs	r3, r11, r8
8f629f20:	0a000030 	beq	8f629fe8 <cmd_flash_mmc_sparse_img+0x360>
		if (data_end < (uintptr_t)data) {
8f629f24:	e59d2000 	ldr	r2, [r13]
		data += sizeof(chunk_header_t);
8f629f28:	e2843028 	add	r3, r4, #40	; 0x28
		if (data_end < (uintptr_t)data) {
8f629f2c:	e1520003 	cmp	r2, r3
8f629f30:	3affffbf 	bcc	8f629e34 <cmd_flash_mmc_sparse_img+0x1ac>
	uint32_t total_blocks = 0;
8f629f34:	e3a05000 	mov	r5, #0
8f629f38:	e58d600c 	str	r6, [r13, #12]
8f629f3c:	e58d7004 	str	r7, [r13, #4]
		if(((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz) >= size) {
8f629f40:	e1a0a005 	mov	r10, r5
8f629f44:	e1a06003 	mov	r6, r3
8f629f48:	e1a07005 	mov	r7, r5
	for (chunk=0; chunk<sparse_header->total_chunks; chunk++)
8f629f4c:	e58d5008 	str	r5, [r13, #8]
		dprintf (SPEW, "=== Chunk Header ===\n");
8f629f50:	e3090584 	movw	r0, #38276	; 0x9584
8f629f54:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629f58:	eb002285 	bl	8f632974 <_dprintf>
		dprintf (SPEW, "chunk_type: 0x%x\n", chunk_header->chunk_type);
8f629f5c:	e1d910b0 	ldrh	r1, [r9]
8f629f60:	e309059c 	movw	r0, #38300	; 0x959c
8f629f64:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629f68:	eb002281 	bl	8f632974 <_dprintf>
		dprintf (SPEW, "chunk_data_sz: 0x%x\n", chunk_header->chunk_sz);
8f629f6c:	e5991004 	ldr	r1, [r9, #4]
8f629f70:	e30905b0 	movw	r0, #38320	; 0x95b0
8f629f74:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629f78:	eb00227d 	bl	8f632974 <_dprintf>
		dprintf (SPEW, "total_size: 0x%x\n", chunk_header->total_sz);
8f629f7c:	e5991008 	ldr	r1, [r9, #8]
8f629f80:	e30905c8 	movw	r0, #38344	; 0x95c8
8f629f84:	e3480f70 	movt	r0, #36720	; 0x8f70
8f629f88:	eb002279 	bl	8f632974 <_dprintf>
		if(sparse_header->chunk_hdr_sz != sizeof(chunk_header_t))
8f629f8c:	e1d430ba 	ldrh	r3, [r4, #10]
8f629f90:	e353000c 	cmp	r3, #12
8f629f94:	1a0000c3 	bne	8f62a2a8 <cmd_flash_mmc_sparse_img+0x620>
		chunk_data_sz = (uint64_t)sparse_header->blk_sz * chunk_header->chunk_sz;
8f629f98:	e594300c 	ldr	r3, [r4, #12]
8f629f9c:	e5991004 	ldr	r1, [r9, #4]
		if ((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz + chunk_data_sz > size)
8f629fa0:	e08a0a93 	umull	r0, r10, r3, r10
		chunk_data_sz = (uint64_t)sparse_header->blk_sz * chunk_header->chunk_sz;
8f629fa4:	e08e2193 	umull	r2, r14, r3, r1
		if ((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz + chunk_data_sz > size)
8f629fa8:	e02aa793 	mla	r10, r3, r7, r10
8f629fac:	e0907002 	adds	r7, r0, r2
8f629fb0:	e0aac00e 	adc	r12, r10, r14
8f629fb4:	e15b0007 	cmp	r11, r7
8f629fb8:	e0d8c00c 	sbcs	r12, r8, r12
8f629fbc:	3a0000b0 	bcc	8f62a284 <cmd_flash_mmc_sparse_img+0x5fc>
		switch (chunk_header->chunk_type)
8f629fc0:	e1d970b0 	ldrh	r7, [r9]
8f629fc4:	e247ccca 	sub	r12, r7, #51712	; 0xca00
8f629fc8:	e24cc0c1 	sub	r12, r12, #193	; 0xc1
8f629fcc:	e35c0003 	cmp	r12, #3
8f629fd0:	979ff10c 	ldrls	r15, [r15, r12, lsl #2]
8f629fd4:	ea000120 	b	8f62a45c <cmd_flash_mmc_sparse_img+0x7d4>
8f629fd8:	8f62a024 	.word	0x8f62a024
8f629fdc:	8f62a098 	.word	0x8f62a098
8f629fe0:	8f62a00c 	.word	0x8f62a00c
8f629fe4:	8f629dac 	.word	0x8f629dac
		fastboot_fail("size too large");
8f629fe8:	e59f34a0 	ldr	r3, [pc, #1184]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f629fec:	e5932000 	ldr	r2, [r3]
8f629ff0:	e59d3014 	ldr	r3, [r13, #20]
8f629ff4:	e0332002 	eors	r2, r3, r2
8f629ff8:	e3a03000 	mov	r3, #0
8f629ffc:	03090374 	movweq	r0, #37748	; 0x9374
8f62a000:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a004:	0affff5a 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
8f62a008:	eaffff50 	b	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
			if(total_blocks > (UINT_MAX - chunk_header->chunk_sz)) {
8f62a00c:	e1e03001 	mvn	r3, r1
8f62a010:	e1530005 	cmp	r3, r5
8f62a014:	3a0000ec 	bcc	8f62a3cc <cmd_flash_mmc_sparse_img+0x744>
			total_blocks += chunk_header->chunk_sz;
8f62a018:	e0855001 	add	r5, r5, r1
			break;
8f62a01c:	e1a09006 	mov	r9, r6
8f62a020:	eaffff71 	b	8f629dec <cmd_flash_mmc_sparse_img+0x164>
			if((uint64_t)chunk_header->total_sz != ((uint64_t)sparse_header->chunk_hdr_sz +
8f62a024:	e292100c 	adds	r1, r2, #12
8f62a028:	e599c008 	ldr	r12, [r9, #8]
8f62a02c:	e2ae3000 	adc	r3, r14, #0
8f62a030:	e3a07000 	mov	r7, #0
8f62a034:	e1570003 	cmp	r7, r3
8f62a038:	015c0001 	cmpeq	r12, r1
8f62a03c:	1a0000c3 	bne	8f62a350 <cmd_flash_mmc_sparse_img+0x6c8>
			if (data_end < (uintptr_t)data + chunk_data_sz) {
8f62a040:	e59d3000 	ldr	r3, [r13]
8f62a044:	e0967002 	adds	r7, r6, r2
8f62a048:	e2aee000 	adc	r14, r14, #0
8f62a04c:	e1530007 	cmp	r3, r7
8f62a050:	e3a03000 	mov	r3, #0
8f62a054:	e0d3300e 	sbcs	r3, r3, r14
8f62a058:	3affff75 	bcc	8f629e34 <cmd_flash_mmc_sparse_img+0x1ac>
			if(mmc_write(ptn + ((uint64_t)total_blocks*sparse_header->blk_sz),
8f62a05c:	e59d300c 	ldr	r3, [r13, #12]
8f62a060:	e59d1004 	ldr	r1, [r13, #4]
8f62a064:	e0900003 	adds	r0, r0, r3
8f62a068:	e1a03006 	mov	r3, r6
8f62a06c:	e0aa1001 	adc	r1, r10, r1
8f62a070:	ebff8a6a 	bl	8f60ca20 <mmc_write>
8f62a074:	e3500000 	cmp	r0, #0
8f62a078:	1a0000ab 	bne	8f62a32c <cmd_flash_mmc_sparse_img+0x6a4>
			if(total_blocks > (UINT_MAX - chunk_header->chunk_sz)) {
8f62a07c:	e5993004 	ldr	r3, [r9, #4]
8f62a080:	e1e02003 	mvn	r2, r3
8f62a084:	e1520005 	cmp	r2, r5
8f62a088:	3a00009e 	bcc	8f62a308 <cmd_flash_mmc_sparse_img+0x680>
			total_blocks += chunk_header->chunk_sz;
8f62a08c:	e0855003 	add	r5, r5, r3
			data += (uint32_t)chunk_data_sz;
8f62a090:	e1a09007 	mov	r9, r7
			break;
8f62a094:	eaffff54 	b	8f629dec <cmd_flash_mmc_sparse_img+0x164>
			if(chunk_header->total_sz != (sparse_header->chunk_hdr_sz +
8f62a098:	e5992008 	ldr	r2, [r9, #8]
8f62a09c:	e3520010 	cmp	r2, #16
8f62a0a0:	1a0000c0 	bne	8f62a3a8 <cmd_flash_mmc_sparse_img+0x720>
			blk_sz_actual = ROUNDUP(sparse_header->blk_sz, CACHE_LINE);
8f62a0a4:	e283103f 	add	r1, r3, #63	; 0x3f
8f62a0a8:	e3c1103f 	bic	r1, r1, #63	; 0x3f
			if (blk_sz_actual < sparse_header->blk_sz)
8f62a0ac:	e1530001 	cmp	r3, r1
8f62a0b0:	8a0000b3 	bhi	8f62a384 <cmd_flash_mmc_sparse_img+0x6fc>
			fill_buf = (uint32_t *)memalign(CACHE_LINE, blk_sz_actual);
8f62a0b4:	e3a00040 	mov	r0, #64	; 0x40
8f62a0b8:	eb0027e1 	bl	8f634044 <memalign>
			if (!fill_buf)
8f62a0bc:	e250a000 	subs	r10, r0, #0
8f62a0c0:	0a0000dc 	beq	8f62a438 <cmd_flash_mmc_sparse_img+0x7b0>
			if (data_end < (uintptr_t)data + sizeof(uint32_t)) {
8f62a0c4:	e59d3000 	ldr	r3, [r13]
8f62a0c8:	e2866004 	add	r6, r6, #4
8f62a0cc:	e1560003 	cmp	r6, r3
8f62a0d0:	8a0000a7 	bhi	8f62a374 <cmd_flash_mmc_sparse_img+0x6ec>
			for (i = 0; i < (sparse_header->blk_sz / sizeof(fill_val)); i++)
8f62a0d4:	e594200c 	ldr	r2, [r4, #12]
			fill_val = *(uint32_t *)data;
8f62a0d8:	e599000c 	ldr	r0, [r9, #12]
			for (i = 0; i < (sparse_header->blk_sz / sizeof(fill_val)); i++)
8f62a0dc:	e1b01122 	lsrs	r1, r2, #2
8f62a0e0:	0a000004 	beq	8f62a0f8 <cmd_flash_mmc_sparse_img+0x470>
8f62a0e4:	e08a1101 	add	r1, r10, r1, lsl #2
8f62a0e8:	e1a0300a 	mov	r3, r10
				fill_buf[i] = fill_val;
8f62a0ec:	e4830004 	str	r0, [r3], #4
			for (i = 0; i < (sparse_header->blk_sz / sizeof(fill_val)); i++)
8f62a0f0:	e1530001 	cmp	r3, r1
8f62a0f4:	1afffffc 	bne	8f62a0ec <cmd_flash_mmc_sparse_img+0x464>
			if(total_blocks > (UINT_MAX - chunk_header->chunk_sz))
8f62a0f8:	e5993004 	ldr	r3, [r9, #4]
8f62a0fc:	e1e01003 	mvn	r1, r3
8f62a100:	e1510005 	cmp	r1, r5
8f62a104:	3a000072 	bcc	8f62a2d4 <cmd_flash_mmc_sparse_img+0x64c>
			for (i = 0; i < chunk_header->chunk_sz; i++)
8f62a108:	e3530000 	cmp	r3, #0
8f62a10c:	0a00003d 	beq	8f62a208 <cmd_flash_mmc_sparse_img+0x580>
				if ((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz + sparse_header->blk_sz > size)
8f62a110:	e2957001 	adds	r7, r5, #1
8f62a114:	e3a03000 	mov	r3, #0
8f62a118:	e2a31000 	adc	r1, r3, #0
8f62a11c:	e0830297 	umull	r0, r3, r7, r2
8f62a120:	e15b0000 	cmp	r11, r0
8f62a124:	e0233192 	mla	r3, r2, r1, r3
8f62a128:	e0d83003 	sbcs	r3, r8, r3
8f62a12c:	3a000066 	bcc	8f62a2cc <cmd_flash_mmc_sparse_img+0x644>
8f62a130:	e1a01005 	mov	r1, r5
			for (i = 0; i < chunk_header->chunk_sz; i++)
8f62a134:	e3a06000 	mov	r6, #0
8f62a138:	e1a0500b 	mov	r5, r11
8f62a13c:	e1a0b004 	mov	r11, r4
8f62a140:	e1a0400a 	mov	r4, r10
8f62a144:	e1a0a008 	mov	r10, r8
8f62a148:	e1a08007 	mov	r8, r7
8f62a14c:	e59d700c 	ldr	r7, [r13, #12]
8f62a150:	ea00000c 	b	8f62a188 <cmd_flash_mmc_sparse_img+0x500>
8f62a154:	e5992004 	ldr	r2, [r9, #4]
8f62a158:	e0881006 	add	r1, r8, r6
8f62a15c:	e2866001 	add	r6, r6, #1
8f62a160:	e1520006 	cmp	r2, r6
8f62a164:	9a000022 	bls	8f62a1f4 <cmd_flash_mmc_sparse_img+0x56c>
				if ((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz + sparse_header->blk_sz > size)
8f62a168:	e59b200c 	ldr	r2, [r11, #12]
8f62a16c:	e291c001 	adds	r12, r1, #1
8f62a170:	e2a00000 	adc	r0, r0, #0
8f62a174:	e08ec29c 	umull	r12, r14, r12, r2
8f62a178:	e155000c 	cmp	r5, r12
8f62a17c:	e020e092 	mla	r0, r2, r0, r14
8f62a180:	e0da3000 	sbcs	r3, r10, r0
8f62a184:	3a000023 	bcc	8f62a218 <cmd_flash_mmc_sparse_img+0x590>
				if(mmc_write(ptn + ((uint64_t)total_blocks*sparse_header->blk_sz),
8f62a188:	e3a03000 	mov	r3, #0
8f62a18c:	e00c0391 	mul	r12, r1, r3
8f62a190:	e02cc392 	mla	r12, r2, r3, r12
8f62a194:	e59d3004 	ldr	r3, [r13, #4]
8f62a198:	e0810291 	umull	r0, r1, r1, r2
8f62a19c:	e0900007 	adds	r0, r0, r7
8f62a1a0:	e08c1001 	add	r1, r12, r1
8f62a1a4:	e0a11003 	adc	r1, r1, r3
8f62a1a8:	e1a03004 	mov	r3, r4
8f62a1ac:	ebff8a1b 	bl	8f60ca20 <mmc_write>
8f62a1b0:	e3500000 	cmp	r0, #0
8f62a1b4:	0affffe6 	beq	8f62a154 <cmd_flash_mmc_sparse_img+0x4cc>
					fastboot_fail("flash write failure");
8f62a1b8:	e3090384 	movw	r0, #37764	; 0x9384
8f62a1bc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a1c0:	e58d4000 	str	r4, [r13]
8f62a1c4:	eb000b51 	bl	8f62cf10 <fastboot_fail>
					free(fill_buf);
8f62a1c8:	e59f22c0 	ldr	r2, [pc, #704]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f62a1cc:	e59d3000 	ldr	r3, [r13]
8f62a1d0:	e5921000 	ldr	r1, [r2]
8f62a1d4:	e59d2014 	ldr	r2, [r13, #20]
8f62a1d8:	e0321001 	eors	r1, r2, r1
8f62a1dc:	e3a02000 	mov	r2, #0
8f62a1e0:	1afffeda 	bne	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
8f62a1e4:	e1a00003 	mov	r0, r3
}
8f62a1e8:	e28dd01c 	add	r13, r13, #28
8f62a1ec:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
					free(fill_buf);
8f62a1f0:	ea0027c5 	b	8f63410c <free>
8f62a1f4:	e1a0800a 	mov	r8, r10
8f62a1f8:	e1a0a004 	mov	r10, r4
8f62a1fc:	e1a0400b 	mov	r4, r11
8f62a200:	e1a0b005 	mov	r11, r5
8f62a204:	e1a05001 	mov	r5, r1
			free(fill_buf);
8f62a208:	e1a0000a 	mov	r0, r10
			data = (char *) data + sizeof(uint32_t);
8f62a20c:	e2899010 	add	r9, r9, #16
			free(fill_buf);
8f62a210:	eb0027bd 	bl	8f63410c <free>
			break;
8f62a214:	eafffef4 	b	8f629dec <cmd_flash_mmc_sparse_img+0x164>
8f62a218:	e1a03004 	mov	r3, r4
					fastboot_fail("Chunk data size for fill type exceeds partition size");
8f62a21c:	e30906e4 	movw	r0, #38628	; 0x96e4
8f62a220:	e58d3000 	str	r3, [r13]
8f62a224:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a228:	eaffffe5 	b	8f62a1c4 <cmd_flash_mmc_sparse_img+0x53c>
	dprintf(INFO, "Wrote %d blocks, expected to write %d blocks\n",
8f62a22c:	e5942010 	ldr	r2, [r4, #16]
8f62a230:	e1a01005 	mov	r1, r5
8f62a234:	e30907cc 	movw	r0, #38860	; 0x97cc
8f62a238:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a23c:	eb0021cc 	bl	8f632974 <_dprintf>
	if(total_blocks != sparse_header->total_blks)
8f62a240:	e5943010 	ldr	r3, [r4, #16]
8f62a244:	e1530005 	cmp	r3, r5
8f62a248:	0a000002 	beq	8f62a258 <cmd_flash_mmc_sparse_img+0x5d0>
		fastboot_fail("sparse image write failure");
8f62a24c:	e30907fc 	movw	r0, #38908	; 0x97fc
8f62a250:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a254:	eb000b2d 	bl	8f62cf10 <fastboot_fail>
	fastboot_okay("");
8f62a258:	e59f3230 	ldr	r3, [pc, #560]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f62a25c:	e5932000 	ldr	r2, [r3]
8f62a260:	e59d3014 	ldr	r3, [r13, #20]
8f62a264:	e0332002 	eors	r2, r3, r2
8f62a268:	e3a03000 	mov	r3, #0
8f62a26c:	1afffeb7 	bne	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
8f62a270:	e3070138 	movw	r0, #28984	; 0x7138
8f62a274:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f62a278:	e28dd01c 	add	r13, r13, #28
8f62a27c:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	fastboot_okay("");
8f62a280:	ea000b45 	b	8f62cf9c <fastboot_okay>
			fastboot_fail("Chunk data size exceeds partition size");
8f62a284:	e59f3204 	ldr	r3, [pc, #516]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f62a288:	e5932000 	ldr	r2, [r3]
8f62a28c:	e59d3014 	ldr	r3, [r13, #20]
8f62a290:	e0332002 	eors	r2, r3, r2
8f62a294:	e3a03000 	mov	r3, #0
8f62a298:	030905f8 	movweq	r0, #38392	; 0x95f8
8f62a29c:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a2a0:	0afffeb3 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
8f62a2a4:	eafffea9 	b	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
			fastboot_fail("chunk header size mismatch");
8f62a2a8:	e59f31e0 	ldr	r3, [pc, #480]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f62a2ac:	e5932000 	ldr	r2, [r3]
8f62a2b0:	e59d3014 	ldr	r3, [r13, #20]
8f62a2b4:	e0332002 	eors	r2, r3, r2
8f62a2b8:	e3a03000 	mov	r3, #0
8f62a2bc:	030905dc 	movweq	r0, #38364	; 0x95dc
8f62a2c0:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a2c4:	0afffeaa 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
8f62a2c8:	eafffea0 	b	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
8f62a2cc:	e1a0300a 	mov	r3, r10
8f62a2d0:	eaffffd1 	b	8f62a21c <cmd_flash_mmc_sparse_img+0x594>
				fastboot_fail("bogus size for chunk FILL type");
8f62a2d4:	e30906c4 	movw	r0, #38596	; 0x96c4
8f62a2d8:	e58da000 	str	r10, [r13]
8f62a2dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a2e0:	eaffffb7 	b	8f62a1c4 <cmd_flash_mmc_sparse_img+0x53c>
				fastboot_fail("integer overflow occured");
8f62a2e4:	e59f31a4 	ldr	r3, [pc, #420]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f62a2e8:	e5932000 	ldr	r2, [r3]
8f62a2ec:	e59d3014 	ldr	r3, [r13, #20]
8f62a2f0:	e0332002 	eors	r2, r3, r2
8f62a2f4:	e3a03000 	mov	r3, #0
8f62a2f8:	03090784 	movweq	r0, #38788	; 0x9784
8f62a2fc:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a300:	0afffe9b 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
8f62a304:	eafffe91 	b	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
				fastboot_fail("Bogus size for RAW chunk type");
8f62a308:	e59f3180 	ldr	r3, [pc, #384]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f62a30c:	e5932000 	ldr	r2, [r3]
8f62a310:	e59d3014 	ldr	r3, [r13, #20]
8f62a314:	e0332002 	eors	r2, r3, r2
8f62a318:	e3a03000 	mov	r3, #0
8f62a31c:	03090644 	movweq	r0, #38468	; 0x9644
8f62a320:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a324:	0afffe92 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
8f62a328:	eafffe88 	b	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
				fastboot_fail("flash write failure");
8f62a32c:	e59f315c 	ldr	r3, [pc, #348]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f62a330:	e5932000 	ldr	r2, [r3]
8f62a334:	e59d3014 	ldr	r3, [r13, #20]
8f62a338:	e0332002 	eors	r2, r3, r2
8f62a33c:	e3a03000 	mov	r3, #0
8f62a340:	03090384 	movweq	r0, #37764	; 0x9384
8f62a344:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a348:	0afffe89 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
8f62a34c:	eafffe7f 	b	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
				fastboot_fail("Bogus chunk size for chunk type Raw");
8f62a350:	e59f3138 	ldr	r3, [pc, #312]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f62a354:	e5932000 	ldr	r2, [r3]
8f62a358:	e59d3014 	ldr	r3, [r13, #20]
8f62a35c:	e0332002 	eors	r2, r3, r2
8f62a360:	e3a03000 	mov	r3, #0
8f62a364:	03090620 	movweq	r0, #38432	; 0x9620
8f62a368:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a36c:	0afffe80 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
8f62a370:	eafffe76 	b	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
				fastboot_fail("buffer overreads occured due to invalid sparse header");
8f62a374:	e3090478 	movw	r0, #38008	; 0x9478
8f62a378:	e58da000 	str	r10, [r13]
8f62a37c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a380:	eaffff8f 	b	8f62a1c4 <cmd_flash_mmc_sparse_img+0x53c>
				fastboot_fail("Invalid block size");
8f62a384:	e59f3104 	ldr	r3, [pc, #260]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f62a388:	e5932000 	ldr	r2, [r3]
8f62a38c:	e59d3014 	ldr	r3, [r13, #20]
8f62a390:	e0332002 	eors	r2, r3, r2
8f62a394:	e3a03000 	mov	r3, #0
8f62a398:	0309068c 	movweq	r0, #38540	; 0x968c
8f62a39c:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a3a0:	0afffe73 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
8f62a3a4:	eafffe69 	b	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
				fastboot_fail("Bogus chunk size for chunk type FILL");
8f62a3a8:	e59f30e0 	ldr	r3, [pc, #224]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f62a3ac:	e5932000 	ldr	r2, [r3]
8f62a3b0:	e59d3014 	ldr	r3, [r13, #20]
8f62a3b4:	e0332002 	eors	r2, r3, r2
8f62a3b8:	e3a03000 	mov	r3, #0
8f62a3bc:	03090664 	movweq	r0, #38500	; 0x9664
8f62a3c0:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a3c4:	0afffe6a 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
8f62a3c8:	eafffe60 	b	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
				fastboot_fail("bogus size for chunk DONT CARE type");
8f62a3cc:	e59f30bc 	ldr	r3, [pc, #188]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f62a3d0:	e5932000 	ldr	r2, [r3]
8f62a3d4:	e59d3014 	ldr	r3, [r13, #20]
8f62a3d8:	e0332002 	eors	r2, r3, r2
8f62a3dc:	e3a03000 	mov	r3, #0
8f62a3e0:	0309071c 	movweq	r0, #38684	; 0x971c
8f62a3e4:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a3e8:	0afffe61 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
8f62a3ec:	eafffe57 	b	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
				fastboot_fail("bogus size for chunk CRC type");
8f62a3f0:	e59f3098 	ldr	r3, [pc, #152]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f62a3f4:	e5932000 	ldr	r2, [r3]
8f62a3f8:	e59d3014 	ldr	r3, [r13, #20]
8f62a3fc:	e0332002 	eors	r2, r3, r2
8f62a400:	e3a03000 	mov	r3, #0
8f62a404:	03090764 	movweq	r0, #38756	; 0x9764
8f62a408:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a40c:	0afffe58 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
8f62a410:	eafffe4e 	b	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
				fastboot_fail("Bogus chunk size for chunk type CRC");
8f62a414:	e59f3074 	ldr	r3, [pc, #116]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f62a418:	e5932000 	ldr	r2, [r3]
8f62a41c:	e59d3014 	ldr	r3, [r13, #20]
8f62a420:	e0332002 	eors	r2, r3, r2
8f62a424:	e3a03000 	mov	r3, #0
8f62a428:	03090740 	movweq	r0, #38720	; 0x9740
8f62a42c:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a430:	0afffe4f 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
8f62a434:	eafffe45 	b	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
				fastboot_fail("Malloc failed for: CHUNK_TYPE_FILL");
8f62a438:	e59f3050 	ldr	r3, [pc, #80]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f62a43c:	e5932000 	ldr	r2, [r3]
8f62a440:	e59d3014 	ldr	r3, [r13, #20]
8f62a444:	e0332002 	eors	r2, r3, r2
8f62a448:	e3a03000 	mov	r3, #0
8f62a44c:	030906a0 	movweq	r0, #38560	; 0x96a0
8f62a450:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a454:	0afffe46 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
8f62a458:	eafffe3c 	b	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
			dprintf(CRITICAL, "Unkown chunk type: %x\n",chunk_header->chunk_type);
8f62a45c:	e30907a0 	movw	r0, #38816	; 0x97a0
8f62a460:	e1a01007 	mov	r1, r7
8f62a464:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a468:	eb002141 	bl	8f632974 <_dprintf>
			fastboot_fail("Unknown chunk type");
8f62a46c:	e59f301c 	ldr	r3, [pc, #28]	; 8f62a490 <cmd_flash_mmc_sparse_img+0x808>
8f62a470:	e5932000 	ldr	r2, [r3]
8f62a474:	e59d3014 	ldr	r3, [r13, #20]
8f62a478:	e0332002 	eors	r2, r3, r2
8f62a47c:	e3a03000 	mov	r3, #0
8f62a480:	030907b8 	movweq	r0, #38840	; 0x97b8
8f62a484:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a488:	0afffe39 	beq	8f629d74 <cmd_flash_mmc_sparse_img+0xec>
8f62a48c:	eafffe2f 	b	8f629d50 <cmd_flash_mmc_sparse_img+0xc8>
8f62a490:	8f74221c 	.word	0x8f74221c

8f62a494 <cmd_flash_mmc>:
{
8f62a494:	e92d4030 	push	{r4, r5, r14}
8f62a498:	e24dd01c 	sub	r13, r13, #28
8f62a49c:	e59f3264 	ldr	r3, [pc, #612]	; 8f62a708 <cmd_flash_mmc+0x274>
	unsigned int *magic_number = (unsigned int *) data;
8f62a4a0:	e1a05001 	mov	r5, r1
{
8f62a4a4:	e58d1004 	str	r1, [r13, #4]
8f62a4a8:	e1a04000 	mov	r4, r0
	ret = scm_svc_version(&major_version,&minor_version);
8f62a4ac:	e28d1010 	add	r1, r13, #16
8f62a4b0:	e28d000c 	add	r0, r13, #12
	uint32           major_version=0;
8f62a4b4:	e3a0c000 	mov	r12, #0
{
8f62a4b8:	e58d2000 	str	r2, [r13]
8f62a4bc:	e5933000 	ldr	r3, [r3]
8f62a4c0:	e58d3014 	str	r3, [r13, #20]
8f62a4c4:	e3a03000 	mov	r3, #0
	uint32           major_version=0;
8f62a4c8:	e58dc00c 	str	r12, [r13, #12]
	uint32           minor_version=0;
8f62a4cc:	e58dc010 	str	r12, [r13, #16]
	ret = scm_svc_version(&major_version,&minor_version);
8f62a4d0:	ebffa816 	bl	8f614530 <scm_svc_version>
	if(!ret)
8f62a4d4:	e3500000 	cmp	r0, #0
8f62a4d8:	1a00004f 	bne	8f62a61c <cmd_flash_mmc+0x188>
		if(major_version >= 2)
8f62a4dc:	e59d300c 	ldr	r3, [r13, #12]
8f62a4e0:	e3530001 	cmp	r3, #1
8f62a4e4:	9a000035 	bls	8f62a5c0 <cmd_flash_mmc+0x12c>
			if( !strcmp(arg, "ssd") || !strcmp(arg, "tqs") )
8f62a4e8:	e3001020 	movw	r1, #32
8f62a4ec:	e1a00004 	mov	r0, r4
8f62a4f0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62a4f4:	eb00280a 	bl	8f634524 <strcmp>
8f62a4f8:	e3500000 	cmp	r0, #0
8f62a4fc:	0a000005 	beq	8f62a518 <cmd_flash_mmc+0x84>
8f62a500:	e3091818 	movw	r1, #38936	; 0x9818
8f62a504:	e1a00004 	mov	r0, r4
8f62a508:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62a50c:	eb002804 	bl	8f634524 <strcmp>
8f62a510:	e3500000 	cmp	r0, #0
8f62a514:	1a00006d 	bne	8f62a6d0 <cmd_flash_mmc+0x23c>
				ret = encrypt_scm((uint32 **) &data, &sz);
8f62a518:	e28d0004 	add	r0, r13, #4
8f62a51c:	e1a0100d 	mov	r1, r13
8f62a520:	ebffa634 	bl	8f613df8 <encrypt_scm>
				if (ret != 0) {
8f62a524:	e3500000 	cmp	r0, #0
8f62a528:	1a000037 	bne	8f62a60c <cmd_flash_mmc+0x178>
				if (!strcmp(arg, "ssd")) {
8f62a52c:	e3001020 	movw	r1, #32
8f62a530:	e1a00004 	mov	r0, r4
8f62a534:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62a538:	eb0027f9 	bl	8f634524 <strcmp>
8f62a53c:	e3500000 	cmp	r0, #0
8f62a540:	0a000039 	beq	8f62a62c <cmd_flash_mmc+0x198>
	if (!strncmp(arg, "avb_custom_key", strlen("avb_custom_key"))) {
8f62a544:	e30901e4 	movw	r0, #37348	; 0x91e4
8f62a548:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a54c:	eb0028ad 	bl	8f634808 <strlen>
8f62a550:	e30911e4 	movw	r1, #37348	; 0x91e4
8f62a554:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62a558:	e1a02000 	mov	r2, r0
8f62a55c:	e1a00004 	mov	r0, r4
8f62a560:	eb0028c1 	bl	8f63486c <strncmp>
8f62a564:	e3500000 	cmp	r0, #0
8f62a568:	0a00003a 	beq	8f62a658 <cmd_flash_mmc+0x1c4>
	sparse_header = (sparse_header_t *) data;
8f62a56c:	e59d1004 	ldr	r1, [r13, #4]
	if (sparse_header->magic == SPARSE_HEADER_MAGIC)
8f62a570:	e30f3f3a 	movw	r3, #65338	; 0xff3a
8f62a574:	e34e3d26 	movt	r3, #60710	; 0xed26
8f62a578:	e5912000 	ldr	r2, [r1]
8f62a57c:	e1520003 	cmp	r2, r3
8f62a580:	0a00004e 	beq	8f62a6c0 <cmd_flash_mmc+0x22c>
	else if (meta_header->magic == META_HEADER_MAGIC)
8f62a584:	e30d363c 	movw	r3, #54844	; 0xd63c
8f62a588:	e34c3e1a 	movt	r3, #52762	; 0xce1a
8f62a58c:	e1520003 	cmp	r2, r3
		cmd_flash_meta_img(arg, data, sz);
8f62a590:	e1a00004 	mov	r0, r4
8f62a594:	e59d2000 	ldr	r2, [r13]
	else if (meta_header->magic == META_HEADER_MAGIC)
8f62a598:	0a00002c 	beq	8f62a650 <cmd_flash_mmc+0x1bc>
		cmd_flash_mmc_img(arg, data, sz);
8f62a59c:	ebfffc83 	bl	8f6297b0 <cmd_flash_mmc_img>
}
8f62a5a0:	e59f3160 	ldr	r3, [pc, #352]	; 8f62a708 <cmd_flash_mmc+0x274>
8f62a5a4:	e5932000 	ldr	r2, [r3]
8f62a5a8:	e59d3014 	ldr	r3, [r13, #20]
8f62a5ac:	e0332002 	eors	r2, r3, r2
8f62a5b0:	e3a03000 	mov	r3, #0
8f62a5b4:	1a000052 	bne	8f62a704 <cmd_flash_mmc+0x270>
8f62a5b8:	e28dd01c 	add	r13, r13, #28
8f62a5bc:	e8bd8030 	pop	{r4, r5, r15}
			if (magic_number[0] == DECRYPT_MAGIC_0 &&
8f62a5c0:	e5952000 	ldr	r2, [r5]
8f62a5c4:	e3073a74 	movw	r3, #31348	; 0x7a74
8f62a5c8:	e3473373 	movt	r3, #29555	; 0x7373
8f62a5cc:	e1520003 	cmp	r2, r3
8f62a5d0:	0a00002c 	beq	8f62a688 <cmd_flash_mmc+0x1f4>
			else if (magic_number[0] == ENCRYPT_MAGIC_0 &&
8f62a5d4:	e3073373 	movw	r3, #29555	; 0x7373
8f62a5d8:	e3463b64 	movt	r3, #27492	; 0x6b64
8f62a5dc:	e1520003 	cmp	r2, r3
8f62a5e0:	1affffd7 	bne	8f62a544 <cmd_flash_mmc+0xb0>
8f62a5e4:	e5952004 	ldr	r2, [r5, #4]
8f62a5e8:	e3063973 	movw	r3, #26995	; 0x6973
8f62a5ec:	e346376d 	movt	r3, #26477	; 0x676d
8f62a5f0:	e1520003 	cmp	r2, r3
8f62a5f4:	1affffd2 	bne	8f62a544 <cmd_flash_mmc+0xb0>
				ret = encrypt_scm((uint32 **) &data, &sz);
8f62a5f8:	e28d0004 	add	r0, r13, #4
8f62a5fc:	e1a0100d 	mov	r1, r13
8f62a600:	ebffa5fc 	bl	8f613df8 <encrypt_scm>
				if (ret != 0) {
8f62a604:	e3500000 	cmp	r0, #0
8f62a608:	0affffcd 	beq	8f62a544 <cmd_flash_mmc+0xb0>
					dprintf(CRITICAL, "ERROR: Encryption Failure\n");
8f62a60c:	e309081c 	movw	r0, #38940	; 0x981c
8f62a610:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a614:	eb0020d6 	bl	8f632974 <_dprintf>
					return;
8f62a618:	eaffffe0 	b	8f62a5a0 <cmd_flash_mmc+0x10c>
		dprintf(CRITICAL,"INVALID SVC Version\n");
8f62a61c:	e3090898 	movw	r0, #39064	; 0x9898
8f62a620:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a624:	eb0020d2 	bl	8f632974 <_dprintf>
		return;
8f62a628:	eaffffdc 	b	8f62a5a0 <cmd_flash_mmc+0x10c>
					ret = scm_protect_keystore((uint32 *) data, sz);
8f62a62c:	e59d1000 	ldr	r1, [r13]
8f62a630:	e59d0004 	ldr	r0, [r13, #4]
8f62a634:	ebffa806 	bl	8f614654 <scm_protect_keystore>
					if (ret != 0) {
8f62a638:	e3500000 	cmp	r0, #0
8f62a63c:	0affffc0 	beq	8f62a544 <cmd_flash_mmc+0xb0>
						dprintf(CRITICAL, "ERROR: scm_protect_keystore Failed\n");
8f62a640:	e3090838 	movw	r0, #38968	; 0x9838
8f62a644:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a648:	eb0020c9 	bl	8f632974 <_dprintf>
						return;
8f62a64c:	eaffffd3 	b	8f62a5a0 <cmd_flash_mmc+0x10c>
		cmd_flash_meta_img(arg, data, sz);
8f62a650:	ebfffcff 	bl	8f629a54 <cmd_flash_meta_img>
8f62a654:	eaffffd1 	b	8f62a5a0 <cmd_flash_mmc+0x10c>
		dprintf(INFO, "flashing avb_custom_key\n");
8f62a658:	e30908b0 	movw	r0, #39088	; 0x98b0
8f62a65c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a660:	eb0020c3 	bl	8f632974 <_dprintf>
		if (store_userkey(data, sz)) {
8f62a664:	e59d1000 	ldr	r1, [r13]
8f62a668:	e59d0004 	ldr	r0, [r13, #4]
8f62a66c:	ebfff813 	bl	8f6286c0 <store_userkey>
8f62a670:	e3500000 	cmp	r0, #0
8f62a674:	0a00001e 	beq	8f62a6f4 <cmd_flash_mmc+0x260>
			fastboot_fail("Flashing avb_custom_key failed");
8f62a678:	e30908cc 	movw	r0, #39116	; 0x98cc
8f62a67c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a680:	eb000a22 	bl	8f62cf10 <fastboot_fail>
8f62a684:	eaffffc5 	b	8f62a5a0 <cmd_flash_mmc+0x10c>
			if (magic_number[0] == DECRYPT_MAGIC_0 &&
8f62a688:	e5952004 	ldr	r2, [r5, #4]
8f62a68c:	e3063964 	movw	r3, #26980	; 0x6964
8f62a690:	e346376d 	movt	r3, #26477	; 0x676d
8f62a694:	e1520003 	cmp	r2, r3
8f62a698:	1affffa9 	bne	8f62a544 <cmd_flash_mmc+0xb0>
				ret = decrypt_scm((uint32 **) &data, &sz);
8f62a69c:	e28d0004 	add	r0, r13, #4
8f62a6a0:	e1a0100d 	mov	r1, r13
8f62a6a4:	ebffa627 	bl	8f613f48 <decrypt_scm>
				if (ret != 0) {
8f62a6a8:	e3500000 	cmp	r0, #0
8f62a6ac:	0affffa4 	beq	8f62a544 <cmd_flash_mmc+0xb0>
					dprintf(CRITICAL, "ERROR: Invalid secure image\n");
8f62a6b0:	e3090878 	movw	r0, #39032	; 0x9878
8f62a6b4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a6b8:	eb0020ad 	bl	8f632974 <_dprintf>
					return;
8f62a6bc:	eaffffb7 	b	8f62a5a0 <cmd_flash_mmc+0x10c>
		cmd_flash_mmc_sparse_img(arg, data, sz);
8f62a6c0:	e59d2000 	ldr	r2, [r13]
8f62a6c4:	e1a00004 	mov	r0, r4
8f62a6c8:	ebfffd6e 	bl	8f629c88 <cmd_flash_mmc_sparse_img>
8f62a6cc:	eaffffb3 	b	8f62a5a0 <cmd_flash_mmc+0x10c>
				ret = decrypt_scm_v2((uint32 **) &data, &sz);
8f62a6d0:	e28d0004 	add	r0, r13, #4
8f62a6d4:	e1a0100d 	mov	r1, r13
8f62a6d8:	ebffa704 	bl	8f6142f0 <decrypt_scm_v2>
				if(ret != 0)
8f62a6dc:	e3500000 	cmp	r0, #0
8f62a6e0:	0affff97 	beq	8f62a544 <cmd_flash_mmc+0xb0>
					dprintf(CRITICAL,"ERROR: Decryption Failure\n");
8f62a6e4:	e309085c 	movw	r0, #39004	; 0x985c
8f62a6e8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a6ec:	eb0020a0 	bl	8f632974 <_dprintf>
					return;
8f62a6f0:	eaffffaa 	b	8f62a5a0 <cmd_flash_mmc+0x10c>
			fastboot_okay("");
8f62a6f4:	e3070138 	movw	r0, #28984	; 0x7138
8f62a6f8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a6fc:	eb000a26 	bl	8f62cf9c <fastboot_okay>
8f62a700:	eaffffa6 	b	8f62a5a0 <cmd_flash_mmc+0x10c>
}
8f62a704:	eb00212d 	bl	8f632bc0 <__stack_chk_fail>
8f62a708:	8f74221c 	.word	0x8f74221c

8f62a70c <cmd_updatevol>:
{
8f62a70c:	e59f3108 	ldr	r3, [pc, #264]	; 8f62a81c <cmd_updatevol+0x110>
8f62a710:	e92d4070 	push	{r4, r5, r6, r14}
8f62a714:	e24dd008 	sub	r13, r13, #8
8f62a718:	e5933000 	ldr	r3, [r3]
8f62a71c:	e58d3004 	str	r3, [r13, #4]
8f62a720:	e3a03000 	mov	r3, #0
8f62a724:	e1a05000 	mov	r5, r0
8f62a728:	e1a06001 	mov	r6, r1
8f62a72c:	e1a04002 	mov	r4, r2
	ptable = flash_get_ptable();
8f62a730:	ebffa224 	bl	8f612fc8 <flash_get_ptable>
	if (ptable == NULL) {
8f62a734:	e3500000 	cmp	r0, #0
8f62a738:	0a000025 	beq	8f62a7d4 <cmd_updatevol+0xc8>
	sys_ptn = ptable_find(ptable, "system");
8f62a73c:	e3011280 	movw	r1, #4736	; 0x1280
8f62a740:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62a744:	eb00307d 	bl	8f636940 <ptable_find>
	if (sys_ptn == NULL) {
8f62a748:	e3500000 	cmp	r0, #0
8f62a74c:	0a000029 	beq	8f62a7f8 <cmd_updatevol+0xec>
	sz = ROUND_TO_PAGE(sz, page_mask);
8f62a750:	e3003680 	movw	r3, #1664	; 0x680
8f62a754:	e3483f74 	movt	r3, #36724	; 0x8f74
	if (update_ubi_vol(sys_ptn, vol_name, data, sz))
8f62a758:	e1a02006 	mov	r2, r6
8f62a75c:	e1a01005 	mov	r1, r5
	sz = ROUND_TO_PAGE(sz, page_mask);
8f62a760:	e593c000 	ldr	r12, [r3]
8f62a764:	e08c3004 	add	r3, r12, r4
8f62a768:	e1c3300c 	bic	r3, r3, r12
8f62a76c:	e1530004 	cmp	r3, r4
	if (update_ubi_vol(sys_ptn, vol_name, data, sz))
8f62a770:	33e03000 	mvncc	r3, #0
8f62a774:	ebffdcb0 	bl	8f621a3c <update_ubi_vol>
		fastboot_fail("update_ubi_vol failed");
8f62a778:	e59f309c 	ldr	r3, [pc, #156]	; 8f62a81c <cmd_updatevol+0x110>
	if (update_ubi_vol(sys_ptn, vol_name, data, sz))
8f62a77c:	e3500000 	cmp	r0, #0
8f62a780:	0a000009 	beq	8f62a7ac <cmd_updatevol+0xa0>
		fastboot_fail("update_ubi_vol failed");
8f62a784:	e5932000 	ldr	r2, [r3]
8f62a788:	e59d3004 	ldr	r3, [r13, #4]
8f62a78c:	e0332002 	eors	r2, r3, r2
8f62a790:	e3a03000 	mov	r3, #0
8f62a794:	03090908 	movweq	r0, #39176	; 0x9908
8f62a798:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a79c:	1a000014 	bne	8f62a7f4 <cmd_updatevol+0xe8>
}
8f62a7a0:	e28dd008 	add	r13, r13, #8
8f62a7a4:	e8bd4070 	pop	{r4, r5, r6, r14}
		fastboot_fail("system partition not found");
8f62a7a8:	ea0009d8 	b	8f62cf10 <fastboot_fail>
		fastboot_okay("");
8f62a7ac:	e5932000 	ldr	r2, [r3]
8f62a7b0:	e59d3004 	ldr	r3, [r13, #4]
8f62a7b4:	e0332002 	eors	r2, r3, r2
8f62a7b8:	e3a03000 	mov	r3, #0
8f62a7bc:	1a00000c 	bne	8f62a7f4 <cmd_updatevol+0xe8>
8f62a7c0:	e3070138 	movw	r0, #28984	; 0x7138
8f62a7c4:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f62a7c8:	e28dd008 	add	r13, r13, #8
8f62a7cc:	e8bd4070 	pop	{r4, r5, r6, r14}
		fastboot_okay("");
8f62a7d0:	ea0009f1 	b	8f62cf9c <fastboot_okay>
		fastboot_fail("partition table doesn't exist");
8f62a7d4:	e59f3040 	ldr	r3, [pc, #64]	; 8f62a81c <cmd_updatevol+0x110>
8f62a7d8:	e5932000 	ldr	r2, [r3]
8f62a7dc:	e59d3004 	ldr	r3, [r13, #4]
8f62a7e0:	e0332002 	eors	r2, r3, r2
8f62a7e4:	e3a03000 	mov	r3, #0
8f62a7e8:	030901ac 	movweq	r0, #37292	; 0x91ac
8f62a7ec:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a7f0:	0affffea 	beq	8f62a7a0 <cmd_updatevol+0x94>
		fastboot_okay("");
8f62a7f4:	eb0020f1 	bl	8f632bc0 <__stack_chk_fail>
		fastboot_fail("system partition not found");
8f62a7f8:	e59f301c 	ldr	r3, [pc, #28]	; 8f62a81c <cmd_updatevol+0x110>
8f62a7fc:	e5932000 	ldr	r2, [r3]
8f62a800:	e59d3004 	ldr	r3, [r13, #4]
8f62a804:	e0332002 	eors	r2, r3, r2
8f62a808:	e3a03000 	mov	r3, #0
8f62a80c:	030908ec 	movweq	r0, #39148	; 0x98ec
8f62a810:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62a814:	0affffe1 	beq	8f62a7a0 <cmd_updatevol+0x94>
8f62a818:	eafffff5 	b	8f62a7f4 <cmd_updatevol+0xe8>
8f62a81c:	8f74221c 	.word	0x8f74221c

8f62a820 <cmd_flash_nand>:
	if((uintptr_t)data > (UINT_MAX - sz)) {
8f62a820:	e1e03002 	mvn	r3, r2
8f62a824:	e1530001 	cmp	r3, r1
{
8f62a828:	e59f3488 	ldr	r3, [pc, #1160]	; 8f62acb8 <cmd_flash_nand+0x498>
8f62a82c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
8f62a830:	e24dd008 	sub	r13, r13, #8
8f62a834:	e5933000 	ldr	r3, [r3]
8f62a838:	e58d3004 	str	r3, [r13, #4]
8f62a83c:	e3a03000 	mov	r3, #0
	if((uintptr_t)data > (UINT_MAX - sz)) {
8f62a840:	3a000072 	bcc	8f62aa10 <cmd_flash_nand+0x1f0>
	ptable = flash_get_ptable();
8f62a844:	e1a04002 	mov	r4, r2
8f62a848:	e1a05001 	mov	r5, r1
8f62a84c:	e1a06000 	mov	r6, r0
8f62a850:	ebffa1dc 	bl	8f612fc8 <flash_get_ptable>
	if (ptable == NULL) {
8f62a854:	e3500000 	cmp	r0, #0
8f62a858:	0a00008b 	beq	8f62aa8c <cmd_flash_nand+0x26c>
	ptn = ptable_find(ptable, arg);
8f62a85c:	e1a01006 	mov	r1, r6
8f62a860:	eb003036 	bl	8f636940 <ptable_find>
	if (ptn == NULL) {
8f62a864:	e2507000 	subs	r7, r0, #0
8f62a868:	0a000077 	beq	8f62aa4c <cmd_flash_nand+0x22c>
	if (!strncmp(arg, "avb_custom_key", strlen("avb_custom_key"))) {
8f62a86c:	e30901e4 	movw	r0, #37348	; 0x91e4
8f62a870:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a874:	eb0027e3 	bl	8f634808 <strlen>
8f62a878:	e30911e4 	movw	r1, #37348	; 0x91e4
8f62a87c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62a880:	e1a02000 	mov	r2, r0
8f62a884:	e1a00006 	mov	r0, r6
8f62a888:	eb0027f7 	bl	8f63486c <strncmp>
8f62a88c:	e3500000 	cmp	r0, #0
8f62a890:	0a000088 	beq	8f62aab8 <cmd_flash_nand+0x298>
	if (!strcmp(ptn->name, "boot") || !strcmp(ptn->name, "recovery")) {
8f62a894:	e30a1370 	movw	r1, #41840	; 0xa370
8f62a898:	e1a00007 	mov	r0, r7
8f62a89c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62a8a0:	eb00271f 	bl	8f634524 <strcmp>
8f62a8a4:	e3500000 	cmp	r0, #0
8f62a8a8:	0a000044 	beq	8f62a9c0 <cmd_flash_nand+0x1a0>
8f62a8ac:	e3001d34 	movw	r1, #3380	; 0xd34
8f62a8b0:	e1a00007 	mov	r0, r7
8f62a8b4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62a8b8:	eb002719 	bl	8f634524 <strcmp>
8f62a8bc:	e3500000 	cmp	r0, #0
8f62a8c0:	0a00003e 	beq	8f62a9c0 <cmd_flash_nand+0x1a0>
	if (!strcmp(ptn->name, "system")
8f62a8c4:	e3011280 	movw	r1, #4736	; 0x1280
8f62a8c8:	e1a00007 	mov	r0, r7
8f62a8cc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62a8d0:	eb002713 	bl	8f634524 <strcmp>
8f62a8d4:	e3500000 	cmp	r0, #0
8f62a8d8:	0a00000b 	beq	8f62a90c <cmd_flash_nand+0xec>
		|| !strcmp(ptn->name, "userdata")
8f62a8dc:	e3011288 	movw	r1, #4744	; 0x1288
8f62a8e0:	e1a00007 	mov	r0, r7
8f62a8e4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62a8e8:	eb00270d 	bl	8f634524 <strcmp>
8f62a8ec:	e3500000 	cmp	r0, #0
8f62a8f0:	0a000005 	beq	8f62a90c <cmd_flash_nand+0xec>
		|| !strcmp(ptn->name, "persist")
8f62a8f4:	e3011294 	movw	r1, #4756	; 0x1294
8f62a8f8:	e1a00007 	mov	r0, r7
8f62a8fc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62a900:	eb002707 	bl	8f634524 <strcmp>
8f62a904:	e3500000 	cmp	r0, #0
8f62a908:	1a0000a2 	bne	8f62ab98 <cmd_flash_nand+0x378>
		extra = 1;
8f62a90c:	e3a08001 	mov	r8, #1
	if (ptn->length && flash_num_pages_per_blk() && page_size) {
8f62a910:	e5973014 	ldr	r3, [r7, #20]
8f62a914:	e3530000 	cmp	r3, #0
8f62a918:	1a000080 	bne	8f62ab20 <cmd_flash_nand+0x300>
	return 0;
8f62a91c:	e3a03000 	mov	r3, #0
8f62a920:	e1a02003 	mov	r2, r3
	if (sz > partition_size) {
8f62a924:	e1530004 	cmp	r3, r4
8f62a928:	e2d23000 	sbcs	r3, r2, #0
8f62a92c:	3a000072 	bcc	8f62aafc <cmd_flash_nand+0x2dc>
	dprintf(INFO, "writing %d bytes to '%s'\n", sz, ptn->name);
8f62a930:	e1a02007 	mov	r2, r7
8f62a934:	e1a01004 	mov	r1, r4
8f62a938:	e3090a24 	movw	r0, #39460	; 0x9a24
8f62a93c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a940:	eb00200b 	bl	8f632974 <_dprintf>
	if ((sz > UBI_EC_HDR_SIZE) &&
8f62a944:	e3540040 	cmp	r4, #64	; 0x40
8f62a948:	9a000006 	bls	8f62a968 <cmd_flash_nand+0x148>
		(!memcmp((void *)data, UBI_MAGIC, UBI_MAGIC_SIZE))) {
8f62a94c:	e3a02004 	mov	r2, #4
8f62a950:	e3091a40 	movw	r1, #39488	; 0x9a40
8f62a954:	e1a00005 	mov	r0, r5
8f62a958:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62a95c:	eb00269d 	bl	8f6343d8 <memcmp>
	if ((sz > UBI_EC_HDR_SIZE) &&
8f62a960:	e3500000 	cmp	r0, #0
8f62a964:	0a0000b2 	beq	8f62ac34 <cmd_flash_nand+0x414>
		if (flash_write(ptn, extra, data, sz)) {
8f62a968:	e1a03004 	mov	r3, r4
8f62a96c:	e1a02005 	mov	r2, r5
8f62a970:	e1a01008 	mov	r1, r8
8f62a974:	e1a00007 	mov	r0, r7
8f62a978:	ebffa276 	bl	8f613358 <flash_write>
8f62a97c:	e3500000 	cmp	r0, #0
8f62a980:	1a0000b1 	bne	8f62ac4c <cmd_flash_nand+0x42c>
	dprintf(INFO, "partition '%s' updated\n", ptn->name);
8f62a984:	e3090a48 	movw	r0, #39496	; 0x9a48
8f62a988:	e1a01007 	mov	r1, r7
8f62a98c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62a990:	eb001ff7 	bl	8f632974 <_dprintf>
	fastboot_okay("");
8f62a994:	e59f331c 	ldr	r3, [pc, #796]	; 8f62acb8 <cmd_flash_nand+0x498>
8f62a998:	e5932000 	ldr	r2, [r3]
8f62a99c:	e59d3004 	ldr	r3, [r13, #4]
8f62a9a0:	e0332002 	eors	r2, r3, r2
8f62a9a4:	e3a03000 	mov	r3, #0
8f62a9a8:	1a000052 	bne	8f62aaf8 <cmd_flash_nand+0x2d8>
8f62a9ac:	e3070138 	movw	r0, #28984	; 0x7138
8f62a9b0:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f62a9b4:	e28dd008 	add	r13, r13, #8
8f62a9b8:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r14}
	fastboot_okay("");
8f62a9bc:	ea000976 	b	8f62cf9c <fastboot_okay>
		if((sz > BOOT_MAGIC_SIZE) && (!memcmp((void *)data, BOOT_MAGIC, BOOT_MAGIC_SIZE))) {
8f62a9c0:	e3540008 	cmp	r4, #8
8f62a9c4:	9a000006 	bls	8f62a9e4 <cmd_flash_nand+0x1c4>
8f62a9c8:	e3a02008 	mov	r2, #8
8f62a9cc:	e308187c 	movw	r1, #34940	; 0x887c
8f62a9d0:	e1a00005 	mov	r0, r5
8f62a9d4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62a9d8:	eb00267e 	bl	8f6343d8 <memcmp>
8f62a9dc:	e3500000 	cmp	r0, #0
8f62a9e0:	0a000015 	beq	8f62aa3c <cmd_flash_nand+0x21c>
			fastboot_fail("Image is not a boot image");
8f62a9e4:	e59f32cc 	ldr	r3, [pc, #716]	; 8f62acb8 <cmd_flash_nand+0x498>
8f62a9e8:	e5932000 	ldr	r2, [r3]
8f62a9ec:	e59d3004 	ldr	r3, [r13, #4]
8f62a9f0:	e0332002 	eors	r2, r3, r2
8f62a9f4:	e3a03000 	mov	r3, #0
8f62a9f8:	030909a0 	movweq	r0, #39328	; 0x99a0
8f62a9fc:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62aa00:	1a00003c 	bne	8f62aaf8 <cmd_flash_nand+0x2d8>
}
8f62aa04:	e28dd008 	add	r13, r13, #8
8f62aa08:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r14}
		fastboot_fail("partition table doesn't exist");
8f62aa0c:	ea00093f 	b	8f62cf10 <fastboot_fail>
		fastboot_fail("Cannot flash: image header corrupt");
8f62aa10:	e59f32a0 	ldr	r3, [pc, #672]	; 8f62acb8 <cmd_flash_nand+0x498>
8f62aa14:	e5932000 	ldr	r2, [r3]
8f62aa18:	e59d3004 	ldr	r3, [r13, #4]
8f62aa1c:	e0332002 	eors	r2, r3, r2
8f62aa20:	e3a03000 	mov	r3, #0
8f62aa24:	03090920 	movweq	r0, #39200	; 0x9920
8f62aa28:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62aa2c:	1a000031 	bne	8f62aaf8 <cmd_flash_nand+0x2d8>
}
8f62aa30:	e28dd008 	add	r13, r13, #8
8f62aa34:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r14}
		fastboot_fail("partition table doesn't exist");
8f62aa38:	ea000934 	b	8f62cf10 <fastboot_fail>
			dprintf(INFO, "Verified the BOOT_MAGIC in image header  \n");
8f62aa3c:	e3090974 	movw	r0, #39284	; 0x9974
8f62aa40:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62aa44:	eb001fca 	bl	8f632974 <_dprintf>
8f62aa48:	eaffff9d 	b	8f62a8c4 <cmd_flash_nand+0xa4>
		dprintf(INFO, "unknown partition name (%s). Trying updatevol\n",
8f62aa4c:	e3090944 	movw	r0, #39236	; 0x9944
8f62aa50:	e1a01006 	mov	r1, r6
8f62aa54:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62aa58:	eb001fc5 	bl	8f632974 <_dprintf>
		cmd_updatevol(arg, data, sz);
8f62aa5c:	e59f3254 	ldr	r3, [pc, #596]	; 8f62acb8 <cmd_flash_nand+0x498>
8f62aa60:	e5932000 	ldr	r2, [r3]
8f62aa64:	e59d3004 	ldr	r3, [r13, #4]
8f62aa68:	e0332002 	eors	r2, r3, r2
8f62aa6c:	e3a03000 	mov	r3, #0
8f62aa70:	1a000020 	bne	8f62aaf8 <cmd_flash_nand+0x2d8>
8f62aa74:	e1a02004 	mov	r2, r4
8f62aa78:	e1a01005 	mov	r1, r5
8f62aa7c:	e1a00006 	mov	r0, r6
}
8f62aa80:	e28dd008 	add	r13, r13, #8
8f62aa84:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r14}
		cmd_updatevol(arg, data, sz);
8f62aa88:	eaffff1f 	b	8f62a70c <cmd_updatevol>
		fastboot_fail("partition table doesn't exist");
8f62aa8c:	e59f3224 	ldr	r3, [pc, #548]	; 8f62acb8 <cmd_flash_nand+0x498>
8f62aa90:	e5932000 	ldr	r2, [r3]
8f62aa94:	e59d3004 	ldr	r3, [r13, #4]
8f62aa98:	e0332002 	eors	r2, r3, r2
8f62aa9c:	e3a03000 	mov	r3, #0
8f62aaa0:	030901ac 	movweq	r0, #37292	; 0x91ac
8f62aaa4:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62aaa8:	1a000012 	bne	8f62aaf8 <cmd_flash_nand+0x2d8>
}
8f62aaac:	e28dd008 	add	r13, r13, #8
8f62aab0:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r14}
		fastboot_fail("partition table doesn't exist");
8f62aab4:	ea000915 	b	8f62cf10 <fastboot_fail>
		dprintf(INFO, "flashing avb_custom_key\n");
8f62aab8:	e30908b0 	movw	r0, #39088	; 0x98b0
8f62aabc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62aac0:	eb001fab 	bl	8f632974 <_dprintf>
		if (store_userkey(data, sz)) {
8f62aac4:	e1a01004 	mov	r1, r4
8f62aac8:	e1a00005 	mov	r0, r5
8f62aacc:	ebfff6fb 	bl	8f6286c0 <store_userkey>
			fastboot_fail("Flashing avb_custom_key failed");
8f62aad0:	e59f31e0 	ldr	r3, [pc, #480]	; 8f62acb8 <cmd_flash_nand+0x498>
		if (store_userkey(data, sz)) {
8f62aad4:	e3500000 	cmp	r0, #0
8f62aad8:	0affffae 	beq	8f62a998 <cmd_flash_nand+0x178>
			fastboot_fail("Flashing avb_custom_key failed");
8f62aadc:	e5932000 	ldr	r2, [r3]
8f62aae0:	e59d3004 	ldr	r3, [r13, #4]
8f62aae4:	e0332002 	eors	r2, r3, r2
8f62aae8:	e3a03000 	mov	r3, #0
8f62aaec:	030908cc 	movweq	r0, #39116	; 0x98cc
8f62aaf0:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62aaf4:	0affffcd 	beq	8f62aa30 <cmd_flash_nand+0x210>
	fastboot_okay("");
8f62aaf8:	eb002030 	bl	8f632bc0 <__stack_chk_fail>
		fastboot_fail("Image size too large");
8f62aafc:	e59f31b4 	ldr	r3, [pc, #436]	; 8f62acb8 <cmd_flash_nand+0x498>
8f62ab00:	e5932000 	ldr	r2, [r3]
8f62ab04:	e59d3004 	ldr	r3, [r13, #4]
8f62ab08:	e0332002 	eors	r2, r3, r2
8f62ab0c:	e3a03000 	mov	r3, #0
8f62ab10:	03090a0c 	movweq	r0, #39436	; 0x9a0c
8f62ab14:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62ab18:	0affffc4 	beq	8f62aa30 <cmd_flash_nand+0x210>
8f62ab1c:	eafffff5 	b	8f62aaf8 <cmd_flash_nand+0x2d8>
	if (ptn->length && flash_num_pages_per_blk() && page_size) {
8f62ab20:	ebffa115 	bl	8f612f7c <flash_num_pages_per_blk>
8f62ab24:	e3500000 	cmp	r0, #0
8f62ab28:	0affff7b 	beq	8f62a91c <cmd_flash_nand+0xfc>
8f62ab2c:	e3009684 	movw	r9, #1668	; 0x684
8f62ab30:	e3489f74 	movt	r9, #36724	; 0x8f74
8f62ab34:	e5993000 	ldr	r3, [r9]
8f62ab38:	e3530000 	cmp	r3, #0
8f62ab3c:	0affff76 	beq	8f62a91c <cmd_flash_nand+0xfc>
		if ((ptn->length < ( UINT_MAX / flash_num_pages_per_blk())) && ((ptn->length * flash_num_pages_per_blk()) < ( UINT_MAX / page_size))) {
8f62ab40:	e5976014 	ldr	r6, [r7, #20]
8f62ab44:	ebffa10c 	bl	8f612f7c <flash_num_pages_per_blk>
8f62ab48:	e1a01000 	mov	r1, r0
8f62ab4c:	e3e00000 	mvn	r0, #0
8f62ab50:	fa004820 	blx	8f63cbd8 <__udivsi3>
8f62ab54:	e1560000 	cmp	r6, r0
8f62ab58:	2affff6f 	bcs	8f62a91c <cmd_flash_nand+0xfc>
8f62ab5c:	e5976014 	ldr	r6, [r7, #20]
8f62ab60:	ebffa105 	bl	8f612f7c <flash_num_pages_per_blk>
8f62ab64:	e5991000 	ldr	r1, [r9]
8f62ab68:	e0060690 	mul	r6, r0, r6
8f62ab6c:	e3e00000 	mvn	r0, #0
8f62ab70:	fa004818 	blx	8f63cbd8 <__udivsi3>
8f62ab74:	e1560000 	cmp	r6, r0
8f62ab78:	2affff67 	bcs	8f62a91c <cmd_flash_nand+0xfc>
			return ptn->length * flash_num_pages_per_blk() * page_size;
8f62ab7c:	e5976014 	ldr	r6, [r7, #20]
8f62ab80:	ebffa0fd 	bl	8f612f7c <flash_num_pages_per_blk>
8f62ab84:	e5993000 	ldr	r3, [r9]
8f62ab88:	e3a02000 	mov	r2, #0
8f62ab8c:	e0030693 	mul	r3, r3, r6
8f62ab90:	e0030390 	mul	r3, r0, r3
8f62ab94:	eaffff62 	b	8f62a924 <cmd_flash_nand+0x104>
		|| !strcmp(ptn->name, "recoveryfs")
8f62ab98:	e30919bc 	movw	r1, #39356	; 0x99bc
8f62ab9c:	e1a00007 	mov	r0, r7
8f62aba0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62aba4:	eb00265e 	bl	8f634524 <strcmp>
8f62aba8:	e3500000 	cmp	r0, #0
8f62abac:	0affff56 	beq	8f62a90c <cmd_flash_nand+0xec>
		|| !strcmp(ptn->name, "modem"))
8f62abb0:	e3011274 	movw	r1, #4724	; 0x1274
8f62abb4:	e1a00007 	mov	r0, r7
8f62abb8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62abbc:	eb002658 	bl	8f634524 <strcmp>
8f62abc0:	e3500000 	cmp	r0, #0
8f62abc4:	0affff50 	beq	8f62a90c <cmd_flash_nand+0xec>
		rounded_size = ROUNDUP(sz, page_size);
8f62abc8:	e3003684 	movw	r3, #1668	; 0x684
8f62abcc:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62abd0:	e5933000 	ldr	r3, [r3]
8f62abd4:	e2436001 	sub	r6, r3, #1
8f62abd8:	e2633000 	rsb	r3, r3, #0
8f62abdc:	e0866004 	add	r6, r6, r4
8f62abe0:	e0066003 	and	r6, r6, r3
		if (bytes_to_round_page) {
8f62abe4:	e0568004 	subs	r8, r6, r4
8f62abe8:	0affff48 	beq	8f62a910 <cmd_flash_nand+0xf0>
			if (((uintptr_t)data + sz ) > (UINT_MAX - bytes_to_round_page)) {
8f62abec:	e0854004 	add	r4, r5, r4
8f62abf0:	e1e03008 	mvn	r3, r8
8f62abf4:	e1540003 	cmp	r4, r3
8f62abf8:	8a00001c 	bhi	8f62ac70 <cmd_flash_nand+0x450>
				((uintptr_t)target_get_scratch_address() + target_get_max_flash_size())) {
8f62abfc:	ebff59d4 	bl	8f601354 <target_get_scratch_address>
			if (((uintptr_t)data + sz + bytes_to_round_page) >
8f62ac00:	e085a006 	add	r10, r5, r6
				((uintptr_t)target_get_scratch_address() + target_get_max_flash_size())) {
8f62ac04:	e1a09000 	mov	r9, r0
8f62ac08:	ebff59e3 	bl	8f60139c <target_get_max_flash_size>
8f62ac0c:	e0899000 	add	r9, r9, r0
			if (((uintptr_t)data + sz + bytes_to_round_page) >
8f62ac10:	e15a0009 	cmp	r10, r9
8f62ac14:	8a00001e 	bhi	8f62ac94 <cmd_flash_nand+0x474>
				memset(data + sz, 0, bytes_to_round_page);
8f62ac18:	e1a02008 	mov	r2, r8
8f62ac1c:	e1a00004 	mov	r0, r4
8f62ac20:	e3a01000 	mov	r1, #0
				sz = rounded_size;
8f62ac24:	e1a04006 	mov	r4, r6
				memset(data + sz, 0, bytes_to_round_page);
8f62ac28:	eb0025a5 	bl	8f6342c4 <memset>
	unsigned extra = 0;
8f62ac2c:	e3a08000 	mov	r8, #0
8f62ac30:	eaffff36 	b	8f62a910 <cmd_flash_nand+0xf0>
		if (flash_ubi_img(ptn, data, sz)) {
8f62ac34:	e1a02004 	mov	r2, r4
8f62ac38:	e1a01005 	mov	r1, r5
8f62ac3c:	e1a00007 	mov	r0, r7
8f62ac40:	ebffdb6c 	bl	8f6219f8 <flash_ubi_img>
8f62ac44:	e3500000 	cmp	r0, #0
8f62ac48:	0affff4d 	beq	8f62a984 <cmd_flash_nand+0x164>
			fastboot_fail("flash write failure");
8f62ac4c:	e59f3064 	ldr	r3, [pc, #100]	; 8f62acb8 <cmd_flash_nand+0x498>
8f62ac50:	e5932000 	ldr	r2, [r3]
8f62ac54:	e59d3004 	ldr	r3, [r13, #4]
8f62ac58:	e0332002 	eors	r2, r3, r2
8f62ac5c:	e3a03000 	mov	r3, #0
8f62ac60:	03090384 	movweq	r0, #37764	; 0x9384
8f62ac64:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62ac68:	0affff70 	beq	8f62aa30 <cmd_flash_nand+0x210>
8f62ac6c:	eaffffa1 	b	8f62aaf8 <cmd_flash_nand+0x2d8>
				fastboot_fail("Integer overflow detected");
8f62ac70:	e59f3040 	ldr	r3, [pc, #64]	; 8f62acb8 <cmd_flash_nand+0x498>
8f62ac74:	e5932000 	ldr	r2, [r3]
8f62ac78:	e59d3004 	ldr	r3, [r13, #4]
8f62ac7c:	e0332002 	eors	r2, r3, r2
8f62ac80:	e3a03000 	mov	r3, #0
8f62ac84:	030909c8 	movweq	r0, #39368	; 0x99c8
8f62ac88:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62ac8c:	0affff67 	beq	8f62aa30 <cmd_flash_nand+0x210>
8f62ac90:	eaffff98 	b	8f62aaf8 <cmd_flash_nand+0x2d8>
				fastboot_fail("Buffer size is not aligned to page_size");
8f62ac94:	e59f301c 	ldr	r3, [pc, #28]	; 8f62acb8 <cmd_flash_nand+0x498>
8f62ac98:	e5932000 	ldr	r2, [r3]
8f62ac9c:	e59d3004 	ldr	r3, [r13, #4]
8f62aca0:	e0332002 	eors	r2, r3, r2
8f62aca4:	e3a03000 	mov	r3, #0
8f62aca8:	030909e4 	movweq	r0, #39396	; 0x99e4
8f62acac:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62acb0:	0affff5e 	beq	8f62aa30 <cmd_flash_nand+0x210>
8f62acb4:	eaffff8f 	b	8f62aaf8 <cmd_flash_nand+0x2d8>
8f62acb8:	8f74221c 	.word	0x8f74221c

8f62acbc <cmd_flash>:
{
8f62acbc:	e59f3088 	ldr	r3, [pc, #136]	; 8f62ad4c <cmd_flash+0x90>
8f62acc0:	e92d4070 	push	{r4, r5, r6, r14}
8f62acc4:	e24dd008 	sub	r13, r13, #8
8f62acc8:	e5933000 	ldr	r3, [r3]
8f62accc:	e58d3004 	str	r3, [r13, #4]
8f62acd0:	e3a03000 	mov	r3, #0
8f62acd4:	e1a04000 	mov	r4, r0
8f62acd8:	e1a05001 	mov	r5, r1
8f62acdc:	e1a06002 	mov	r6, r2
	if(target_is_emmc_boot())
8f62ace0:	ebffdb66 	bl	8f621a80 <target_is_emmc_boot>
		cmd_flash_mmc(arg, data, sz);
8f62ace4:	e59f3060 	ldr	r3, [pc, #96]	; 8f62ad4c <cmd_flash+0x90>
	if(target_is_emmc_boot())
8f62ace8:	e3500000 	cmp	r0, #0
8f62acec:	0a00000a 	beq	8f62ad1c <cmd_flash+0x60>
		cmd_flash_mmc(arg, data, sz);
8f62acf0:	e5932000 	ldr	r2, [r3]
8f62acf4:	e59d3004 	ldr	r3, [r13, #4]
8f62acf8:	e0332002 	eors	r2, r3, r2
8f62acfc:	e3a03000 	mov	r3, #0
8f62ad00:	1a000010 	bne	8f62ad48 <cmd_flash+0x8c>
8f62ad04:	e1a02006 	mov	r2, r6
8f62ad08:	e1a01005 	mov	r1, r5
8f62ad0c:	e1a00004 	mov	r0, r4
}
8f62ad10:	e28dd008 	add	r13, r13, #8
8f62ad14:	e8bd4070 	pop	{r4, r5, r6, r14}
		cmd_flash_mmc(arg, data, sz);
8f62ad18:	eafffddd 	b	8f62a494 <cmd_flash_mmc>
		cmd_flash_nand(arg, data, sz);
8f62ad1c:	e5932000 	ldr	r2, [r3]
8f62ad20:	e59d3004 	ldr	r3, [r13, #4]
8f62ad24:	e0332002 	eors	r2, r3, r2
8f62ad28:	e3a03000 	mov	r3, #0
8f62ad2c:	1a000005 	bne	8f62ad48 <cmd_flash+0x8c>
8f62ad30:	e1a02006 	mov	r2, r6
8f62ad34:	e1a01005 	mov	r1, r5
8f62ad38:	e1a00004 	mov	r0, r4
}
8f62ad3c:	e28dd008 	add	r13, r13, #8
8f62ad40:	e8bd4070 	pop	{r4, r5, r6, r14}
		cmd_flash_nand(arg, data, sz);
8f62ad44:	eafffeb5 	b	8f62a820 <cmd_flash_nand>
8f62ad48:	eb001f9c 	bl	8f632bc0 <__stack_chk_fail>
8f62ad4c:	8f74221c 	.word	0x8f74221c

8f62ad50 <splash_screen_flash>:
{
8f62ad50:	e59f327c 	ldr	r3, [pc, #636]	; 8f62afd4 <splash_screen_flash+0x284>
8f62ad54:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f62ad58:	e24dd014 	sub	r13, r13, #20
8f62ad5c:	e5933000 	ldr	r3, [r3]
8f62ad60:	e58d300c 	str	r3, [r13, #12]
8f62ad64:	e3a03000 	mov	r3, #0
	ptable = flash_get_ptable();
8f62ad68:	ebffa096 	bl	8f612fc8 <flash_get_ptable>
	if (ptable == NULL) {
8f62ad6c:	e3500000 	cmp	r0, #0
8f62ad70:	0a000081 	beq	8f62af7c <splash_screen_flash+0x22c>
	ptn = ptable_find(ptable, "splash");
8f62ad74:	e3091a6c 	movw	r1, #39532	; 0x9a6c
8f62ad78:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62ad7c:	eb002eef 	bl	8f636940 <ptable_find>
	if (ptn == NULL) {
8f62ad80:	e2506000 	subs	r6, r0, #0
8f62ad84:	0a000081 	beq	8f62af90 <splash_screen_flash+0x240>
8f62ad88:	e30f4448 	movw	r4, #62536	; 0xf448
8f62ad8c:	e3484f73 	movt	r4, #36723	; 0x8f73
8f62ad90:	e3a02000 	mov	r2, #0
8f62ad94:	e3a03c02 	mov	r3, #512	; 0x200
8f62ad98:	e1a01002 	mov	r1, r2
8f62ad9c:	e58d3000 	str	r3, [r13]
8f62ada0:	e1a03004 	mov	r3, r4
8f62ada4:	ebffa09a 	bl	8f613014 <flash_read_ext>
	if (flash_read(ptn, 0, (void *)logo_header, LOGO_IMG_HEADER_SIZE)) {
8f62ada8:	e3500000 	cmp	r0, #0
8f62adac:	1a00006d 	bne	8f62af68 <splash_screen_flash+0x218>
	if (memcmp(header->magic, LOGO_IMG_MAGIC, 8))
8f62adb0:	e3a02008 	mov	r2, #8
8f62adb4:	e3091a60 	movw	r1, #39520	; 0x9a60
8f62adb8:	e1a00004 	mov	r0, r4
8f62adbc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62adc0:	eb002584 	bl	8f6343d8 <memcmp>
8f62adc4:	e2505000 	subs	r5, r0, #0
8f62adc8:	1a000057 	bne	8f62af2c <splash_screen_flash+0x1dc>
	if (header->width == 0 || header->height == 0)
8f62adcc:	e5943008 	ldr	r3, [r4, #8]
8f62add0:	e3530000 	cmp	r3, #0
8f62add4:	0a000054 	beq	8f62af2c <splash_screen_flash+0x1dc>
8f62add8:	e594300c 	ldr	r3, [r4, #12]
8f62addc:	e3530000 	cmp	r3, #0
8f62ade0:	0a000051 	beq	8f62af2c <splash_screen_flash+0x1dc>
	fb_display = fbcon_display();
8f62ade4:	eb0015e3 	bl	8f630578 <fbcon_display>
	if (fb_display) {
8f62ade8:	e3500000 	cmp	r0, #0
8f62adec:	0a000021 	beq	8f62ae78 <splash_screen_flash+0x128>
		if (header->type && (header->blocks != 0) &&
8f62adf0:	e5943010 	ldr	r3, [r4, #16]
8f62adf4:	e3530000 	cmp	r3, #0
8f62adf8:	1a000027 	bne	8f62ae9c <splash_screen_flash+0x14c>
				((header->blocks * 512) <=  (fb_display->width *
8f62adfc:	e590e004 	ldr	r14, [r0, #4]
		if ((header->width > fb_display->width) || (header->height > fb_display->height)) {
8f62ae00:	e5941008 	ldr	r1, [r4, #8]
8f62ae04:	e151000e 	cmp	r1, r14
8f62ae08:	8a00004c 	bhi	8f62af40 <splash_screen_flash+0x1f0>
8f62ae0c:	e594300c 	ldr	r3, [r4, #12]
8f62ae10:	e5902008 	ldr	r2, [r0, #8]
8f62ae14:	e1530002 	cmp	r3, r2
8f62ae18:	8a000048 	bhi	8f62af40 <splash_screen_flash+0x1f0>
		uint32_t splash_size = ((((header->width * header->height *
8f62ae1c:	e0010193 	mul	r1, r3, r1
		uint32_t fb_size = ROUNDUP(fb_display->width *
8f62ae20:	e590c010 	ldr	r12, [r0, #16]
		uint8_t *base = (uint8_t *) fb_display->base;
8f62ae24:	e5903000 	ldr	r3, [r0]
		uint32_t splash_size = ((((header->width * header->height *
8f62ae28:	e000019c 	mul	r0, r12, r1
		uint32_t fb_size = ROUNDUP(fb_display->width *
8f62ae2c:	e1a0c1ac 	lsr	r12, r12, #3
					fb_display->bpp/8) + 511) >> 9) << 9);
8f62ae30:	e30011ff 	movw	r1, #511	; 0x1ff
		uint32_t fb_size = ROUNDUP(fb_display->width *
8f62ae34:	e00c0c92 	mul	r12, r2, r12
8f62ae38:	e3002fff 	movw	r2, #4095	; 0xfff
					fb_display->bpp/8) + 511) >> 9) << 9);
8f62ae3c:	e08111a0 	add	r1, r1, r0, lsr #3
		uint32_t splash_size = ((((header->width * header->height *
8f62ae40:	e3c11f7f 	bic	r1, r1, #508	; 0x1fc
8f62ae44:	e3c11003 	bic	r1, r1, #3
		uint32_t fb_size = ROUNDUP(fb_display->width *
8f62ae48:	e0222c9e 	mla	r2, r14, r12, r2
8f62ae4c:	e3c22eff 	bic	r2, r2, #4080	; 0xff0
8f62ae50:	e3c2200f 	bic	r2, r2, #15
		if (splash_size > fb_size) {
8f62ae54:	e1520001 	cmp	r2, r1
8f62ae58:	3a00003d 	bcc	8f62af54 <splash_screen_flash+0x204>
8f62ae5c:	e3a02000 	mov	r2, #0
8f62ae60:	e58d1000 	str	r1, [r13]
8f62ae64:	e2860901 	add	r0, r6, #16384	; 0x4000
8f62ae68:	e1a01002 	mov	r1, r2
8f62ae6c:	ebffa068 	bl	8f613014 <flash_read_ext>
		if (flash_read(ptn + LOGO_IMG_HEADER_SIZE, 0,
8f62ae70:	e3500000 	cmp	r0, #0
8f62ae74:	1a00004a 	bne	8f62afa4 <splash_screen_flash+0x254>
}
8f62ae78:	e59f3154 	ldr	r3, [pc, #340]	; 8f62afd4 <splash_screen_flash+0x284>
8f62ae7c:	e5932000 	ldr	r2, [r3]
8f62ae80:	e59d300c 	ldr	r3, [r13, #12]
8f62ae84:	e0332002 	eors	r2, r3, r2
8f62ae88:	e3a03000 	mov	r3, #0
8f62ae8c:	1a00004f 	bne	8f62afd0 <splash_screen_flash+0x280>
8f62ae90:	e1a00005 	mov	r0, r5
8f62ae94:	e28dd014 	add	r13, r13, #20
8f62ae98:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		if (header->type && (header->blocks != 0) &&
8f62ae9c:	e5943014 	ldr	r3, [r4, #20]
8f62aea0:	e3530000 	cmp	r3, #0
8f62aea4:	0affffd4 	beq	8f62adfc <splash_screen_flash+0xac>
				((header->blocks * 512) <=  (fb_display->width *
8f62aea8:	e590e004 	ldr	r14, [r0, #4]
8f62aeac:	e1a0c483 	lsl	r12, r3, #9
				fb_display->height * (fb_display->bpp / 8)))) {
8f62aeb0:	e5902008 	ldr	r2, [r0, #8]
8f62aeb4:	e5903010 	ldr	r3, [r0, #16]
				((header->blocks * 512) <=  (fb_display->width *
8f62aeb8:	e0010e92 	mul	r1, r2, r14
				fb_display->height * (fb_display->bpp / 8)))) {
8f62aebc:	e1a031a3 	lsr	r3, r3, #3
8f62aec0:	e0030391 	mul	r3, r1, r3
				(UINT_MAX >= header->blocks * 512) &&
8f62aec4:	e15c0003 	cmp	r12, r3
8f62aec8:	8affffcc 	bhi	8f62ae00 <splash_screen_flash+0xb0>
			if ((header->width != fb_display->width)
8f62aecc:	e5943008 	ldr	r3, [r4, #8]
			uint8_t *base = (uint8_t *) fb_display->base + LOGO_IMG_OFFSET;
8f62aed0:	e5907000 	ldr	r7, [r0]
			if ((header->width != fb_display->width)
8f62aed4:	e15e0003 	cmp	r14, r3
			uint8_t *base = (uint8_t *) fb_display->base + LOGO_IMG_OFFSET;
8f62aed8:	e2877503 	add	r7, r7, #12582912	; 0xc00000
			if ((header->width != fb_display->width)
8f62aedc:	1a000002 	bne	8f62aeec <splash_screen_flash+0x19c>
						|| (header->height != fb_display->height))
8f62aee0:	e594300c 	ldr	r3, [r4, #12]
8f62aee4:	e1520003 	cmp	r2, r3
8f62aee8:	0a000002 	beq	8f62aef8 <splash_screen_flash+0x1a8>
					fbcon_clear();
8f62aeec:	eb00143d 	bl	8f62ffe8 <fbcon_clear>
			if (flash_read(ptn + LOGO_IMG_HEADER_SIZE, 0,
8f62aef0:	e5943014 	ldr	r3, [r4, #20]
8f62aef4:	e1a0c483 	lsl	r12, r3, #9
8f62aef8:	e3a02000 	mov	r2, #0
8f62aefc:	e2860901 	add	r0, r6, #16384	; 0x4000
8f62af00:	e1a03007 	mov	r3, r7
8f62af04:	e1a01002 	mov	r1, r2
8f62af08:	e58dc000 	str	r12, [r13]
8f62af0c:	ebffa040 	bl	8f613014 <flash_read_ext>
8f62af10:	e2505000 	subs	r5, r0, #0
8f62af14:	1a000028 	bne	8f62afbc <splash_screen_flash+0x26c>
			fbcon_extract_to_screen(header, base);
8f62af18:	e1a01007 	mov	r1, r7
8f62af1c:	e30f0448 	movw	r0, #62536	; 0xf448
8f62af20:	e3480f73 	movt	r0, #36723	; 0x8f73
8f62af24:	eb0015a6 	bl	8f6305c4 <fbcon_extract_to_screen>
			return 0;
8f62af28:	eaffffd2 	b	8f62ae78 <splash_screen_flash+0x128>
		dprintf(CRITICAL, "ERROR: Boot image header invalid\n");
8f62af2c:	e3090a98 	movw	r0, #39576	; 0x9a98
8f62af30:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62af34:	eb001e8e 	bl	8f632974 <_dprintf>
		return -1;
8f62af38:	e3e05000 	mvn	r5, #0
8f62af3c:	eaffffcd 	b	8f62ae78 <splash_screen_flash+0x128>
			dprintf(CRITICAL, "Logo config greater than fb config. Fall back default logo\n");
8f62af40:	e3090aec 	movw	r0, #39660	; 0x9aec
8f62af44:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62af48:	eb001e89 	bl	8f632974 <_dprintf>
			return -1;
8f62af4c:	e3e05000 	mvn	r5, #0
8f62af50:	eaffffc8 	b	8f62ae78 <splash_screen_flash+0x128>
			dprintf(CRITICAL, "ERROR: Splash image size invalid\n");
8f62af54:	e3090b28 	movw	r0, #39720	; 0x9b28
8f62af58:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62af5c:	eb001e84 	bl	8f632974 <_dprintf>
			return -1;
8f62af60:	e3e05000 	mvn	r5, #0
8f62af64:	eaffffc3 	b	8f62ae78 <splash_screen_flash+0x128>
		dprintf(CRITICAL, "ERROR: Cannot read boot image header\n");
8f62af68:	e30808c0 	movw	r0, #35008	; 0x88c0
8f62af6c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62af70:	eb001e7f 	bl	8f632974 <_dprintf>
		return -1;
8f62af74:	e3e05000 	mvn	r5, #0
8f62af78:	eaffffbe 	b	8f62ae78 <splash_screen_flash+0x128>
		dprintf(CRITICAL, "ERROR: Partition table not found\n");
8f62af7c:	e3080e04 	movw	r0, #36356	; 0x8e04
8f62af80:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62af84:	eb001e7a 	bl	8f632974 <_dprintf>
		return -1;
8f62af88:	e3e05000 	mvn	r5, #0
8f62af8c:	eaffffb9 	b	8f62ae78 <splash_screen_flash+0x128>
		dprintf(CRITICAL, "ERROR: splash Partition not found\n");
8f62af90:	e3090a74 	movw	r0, #39540	; 0x9a74
8f62af94:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62af98:	eb001e75 	bl	8f632974 <_dprintf>
		return -1;
8f62af9c:	e3e05000 	mvn	r5, #0
8f62afa0:	eaffffb4 	b	8f62ae78 <splash_screen_flash+0x128>
			fbcon_clear();
8f62afa4:	eb00140f 	bl	8f62ffe8 <fbcon_clear>
			dprintf(CRITICAL, "ERROR: Cannot read splash image from partition\n");
8f62afa8:	e3090abc 	movw	r0, #39612	; 0x9abc
8f62afac:	e3480f70 	movt	r0, #36720	; 0x8f70
			return -1;
8f62afb0:	e3e05000 	mvn	r5, #0
			dprintf(CRITICAL, "ERROR: Cannot read splash image from partition\n");
8f62afb4:	eb001e6e 	bl	8f632974 <_dprintf>
			return -1;
8f62afb8:	eaffffae 	b	8f62ae78 <splash_screen_flash+0x128>
				dprintf(CRITICAL, "ERROR: Cannot read splash image from partition\n");
8f62afbc:	e3090abc 	movw	r0, #39612	; 0x9abc
8f62afc0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62afc4:	eb001e6a 	bl	8f632974 <_dprintf>
				return -1;
8f62afc8:	e3e05000 	mvn	r5, #0
8f62afcc:	eaffffa9 	b	8f62ae78 <splash_screen_flash+0x128>
}
8f62afd0:	eb001efa 	bl	8f632bc0 <__stack_chk_fail>
8f62afd4:	8f74221c 	.word	0x8f74221c

8f62afd8 <splash_screen_mmc>:
{
8f62afd8:	e59f3340 	ldr	r3, [pc, #832]	; 8f62b320 <splash_screen_mmc+0x348>
	index = partition_get_index("splash");
8f62afdc:	e3090a6c 	movw	r0, #39532	; 0x9a6c
{
8f62afe0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	index = partition_get_index("splash");
8f62afe4:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f62afe8:	e24dd014 	sub	r13, r13, #20
8f62afec:	e5933000 	ldr	r3, [r3]
8f62aff0:	e58d300c 	str	r3, [r13, #12]
8f62aff4:	e3a03000 	mov	r3, #0
	index = partition_get_index("splash");
8f62aff8:	ebff6323 	bl	8f603c8c <partition_get_index>
	if (index == 0) {
8f62affc:	e2504000 	subs	r4, r0, #0
8f62b000:	0a000095 	beq	8f62b25c <splash_screen_mmc+0x284>
	ptn = partition_get_offset(index);
8f62b004:	ebff662c 	bl	8f6048bc <partition_get_offset>
	if (ptn == 0) {
8f62b008:	e1903001 	orrs	r3, r0, r1
	ptn = partition_get_offset(index);
8f62b00c:	e1a05000 	mov	r5, r0
8f62b010:	e1a07001 	mov	r7, r1
	if (ptn == 0) {
8f62b014:	0a000096 	beq	8f62b274 <splash_screen_mmc+0x29c>
	mmc_set_lun(partition_get_lun(index));
8f62b018:	e1a00004 	mov	r0, r4
8f62b01c:	ebff6647 	bl	8f604940 <partition_get_lun>
8f62b020:	ebff8903 	bl	8f60d434 <mmc_set_lun>
	blocksize = mmc_get_device_blocksize();
8f62b024:	ebff88d4 	bl	8f60d37c <mmc_get_device_blocksize>
	if (blocksize == 0) {
8f62b028:	e2508000 	subs	r8, r0, #0
8f62b02c:	0a000096 	beq	8f62b28c <splash_screen_mmc+0x2b4>
	fb_display = fbcon_display();
8f62b030:	eb001550 	bl	8f630578 <fbcon_display>
	if (!fb_display)
8f62b034:	e2504000 	subs	r4, r0, #0
8f62b038:	0a0000ab 	beq	8f62b2ec <splash_screen_mmc+0x314>
	base = (uint8_t *) fb_display->base;
8f62b03c:	e594a000 	ldr	r10, [r4]
	if (mmc_read(ptn + PLL_CODES_OFFSET, (uint32_t *)(base + LOGO_IMG_OFFSET), blocksize)) {
8f62b040:	e2959a01 	adds	r9, r5, #4096	; 0x1000
8f62b044:	e2a7b000 	adc	r11, r7, #0
8f62b048:	e1a03008 	mov	r3, r8
8f62b04c:	e28a6503 	add	r6, r10, #12582912	; 0xc00000
8f62b050:	e1a00009 	mov	r0, r9
8f62b054:	e1a0100b 	mov	r1, r11
8f62b058:	e1a02006 	mov	r2, r6
8f62b05c:	ebff8709 	bl	8f60cc88 <mmc_read>
8f62b060:	e3500000 	cmp	r0, #0
8f62b064:	1a000094 	bne	8f62b2bc <splash_screen_mmc+0x2e4>
	if (memcmp(header->magic, LOGO_IMG_MAGIC, 8))
8f62b068:	e3a02008 	mov	r2, #8
8f62b06c:	e3091a60 	movw	r1, #39520	; 0x9a60
8f62b070:	e1a00006 	mov	r0, r6
8f62b074:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62b078:	eb0024d6 	bl	8f6343d8 <memcmp>
8f62b07c:	e2503000 	subs	r3, r0, #0
8f62b080:	e58d3000 	str	r3, [r13]
8f62b084:	1a000092 	bne	8f62b2d4 <splash_screen_mmc+0x2fc>
	if (header->width == 0 || header->height == 0)
8f62b088:	e5962008 	ldr	r2, [r6, #8]
8f62b08c:	e3520000 	cmp	r2, #0
8f62b090:	0a00008f 	beq	8f62b2d4 <splash_screen_mmc+0x2fc>
8f62b094:	e596100c 	ldr	r1, [r6, #12]
8f62b098:	e3510000 	cmp	r1, #0
8f62b09c:	0a00008c 	beq	8f62b2d4 <splash_screen_mmc+0x2fc>
		if (header->type && (header->blocks != 0) &&
8f62b0a0:	e5960010 	ldr	r0, [r6, #16]
8f62b0a4:	e3500000 	cmp	r0, #0
8f62b0a8:	1a000026 	bne	8f62b148 <splash_screen_mmc+0x170>
			((header->blocks * 512) <=  (fb_display->width *
8f62b0ac:	e594c004 	ldr	r12, [r4, #4]
			if ((header->width > fb_display->width) || (header->height > fb_display->height)) {
8f62b0b0:	e152000c 	cmp	r2, r12
8f62b0b4:	8a000062 	bhi	8f62b244 <splash_screen_mmc+0x26c>
8f62b0b8:	e5940008 	ldr	r0, [r4, #8]
8f62b0bc:	e1500001 	cmp	r0, r1
8f62b0c0:	3a00005f 	bcc	8f62b244 <splash_screen_mmc+0x26c>
			realsize =  header->width * header->height * fb_display->bpp / 8;
8f62b0c4:	e0020291 	mul	r2, r1, r2
8f62b0c8:	e5944010 	ldr	r4, [r4, #16]
			readsize =  ROUNDUP((realsize + LOGO_IMG_HEADER_SIZE), blocksize) - blocksize;
8f62b0cc:	e2681000 	rsb	r1, r8, #0
			if (blocksize == LOGO_IMG_HEADER_SIZE) { /* read the content directly */
8f62b0d0:	e3580c02 	cmp	r8, #512	; 0x200
			realsize =  header->width * header->height * fb_display->bpp / 8;
8f62b0d4:	e0040294 	mul	r4, r4, r2
			readsize =  ROUNDUP((realsize + LOGO_IMG_HEADER_SIZE), blocksize) - blocksize;
8f62b0d8:	e2882f7f 	add	r2, r8, #508	; 0x1fc
8f62b0dc:	e2822003 	add	r2, r2, #3
			realsize =  header->width * header->height * fb_display->bpp / 8;
8f62b0e0:	e1a041a4 	lsr	r4, r4, #3
			readsize =  ROUNDUP((realsize + LOGO_IMG_HEADER_SIZE), blocksize) - blocksize;
8f62b0e4:	e0822004 	add	r2, r2, r4
8f62b0e8:	e0022001 	and	r2, r2, r1
8f62b0ec:	e042c008 	sub	r12, r2, r8
			if (blocksize == LOGO_IMG_HEADER_SIZE) { /* read the content directly */
8f62b0f0:	0a000045 	beq	8f62b20c <splash_screen_mmc+0x234>
				if (mmc_read(ptn + PLL_CODES_OFFSET + blocksize ,
8f62b0f4:	e0980009 	adds	r0, r8, r9
						(uint32_t *)(base + LOGO_IMG_OFFSET + blocksize), readsize)) {
8f62b0f8:	e2882503 	add	r2, r8, #12582912	; 0xc00000
				if (mmc_read(ptn + PLL_CODES_OFFSET + blocksize ,
8f62b0fc:	e2ab1000 	adc	r1, r11, #0
8f62b100:	e08a2002 	add	r2, r10, r2
8f62b104:	e1a0300c 	mov	r3, r12
8f62b108:	ebff86de 	bl	8f60cc88 <mmc_read>
8f62b10c:	e3500000 	cmp	r0, #0
8f62b110:	1a000063 	bne	8f62b2a4 <splash_screen_mmc+0x2cc>
				memmove(base, (base + LOGO_IMG_OFFSET + LOGO_IMG_HEADER_SIZE), realsize);
8f62b114:	e2861c02 	add	r1, r6, #512	; 0x200
8f62b118:	e1a02004 	mov	r2, r4
8f62b11c:	e1a0000a 	mov	r0, r10
8f62b120:	eb002424 	bl	8f6341b8 <memcpy>
}
8f62b124:	e59f31f4 	ldr	r3, [pc, #500]	; 8f62b320 <splash_screen_mmc+0x348>
8f62b128:	e5932000 	ldr	r2, [r3]
8f62b12c:	e59d300c 	ldr	r3, [r13, #12]
8f62b130:	e0332002 	eors	r2, r3, r2
8f62b134:	e3a03000 	mov	r3, #0
8f62b138:	1a000077 	bne	8f62b31c <splash_screen_mmc+0x344>
8f62b13c:	e59d0000 	ldr	r0, [r13]
8f62b140:	e28dd014 	add	r13, r13, #20
8f62b144:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		if (header->type && (header->blocks != 0) &&
8f62b148:	e5960014 	ldr	r0, [r6, #20]
8f62b14c:	e3500000 	cmp	r0, #0
8f62b150:	0affffd5 	beq	8f62b0ac <splash_screen_mmc+0xd4>
			fb_display->height * (fb_display->bpp / 8)))) {
8f62b154:	e5943008 	ldr	r3, [r4, #8]
			((header->blocks * 512) <=  (fb_display->width *
8f62b158:	e1a0e480 	lsl	r14, r0, #9
			fb_display->height * (fb_display->bpp / 8)))) {
8f62b15c:	e5940010 	ldr	r0, [r4, #16]
			((header->blocks * 512) <=  (fb_display->width *
8f62b160:	e594c004 	ldr	r12, [r4, #4]
			fb_display->height * (fb_display->bpp / 8)))) {
8f62b164:	e58d3004 	str	r3, [r13, #4]
8f62b168:	e1a031a0 	lsr	r3, r0, #3
			((header->blocks * 512) <=  (fb_display->width *
8f62b16c:	e59d0004 	ldr	r0, [r13, #4]
8f62b170:	e0000c90 	mul	r0, r0, r12
			fb_display->height * (fb_display->bpp / 8)))) {
8f62b174:	e0000390 	mul	r0, r0, r3
			(UINT_MAX >= header->blocks * 512 + LOGO_IMG_HEADER_SIZE) &&
8f62b178:	e15e0000 	cmp	r14, r0
8f62b17c:	8affffcb 	bhi	8f62b0b0 <splash_screen_mmc+0xd8>
			readsize =  ROUNDUP((realsize + LOGO_IMG_HEADER_SIZE), blocksize) - blocksize;
8f62b180:	e2885f7f 	add	r5, r8, #508	; 0x1fc
			if ((header->width != fb_display->width)
8f62b184:	e15c0002 	cmp	r12, r2
			readsize =  ROUNDUP((realsize + LOGO_IMG_HEADER_SIZE), blocksize) - blocksize;
8f62b188:	e2855003 	add	r5, r5, #3
8f62b18c:	e2682000 	rsb	r2, r8, #0
8f62b190:	e085500e 	add	r5, r5, r14
8f62b194:	e0055002 	and	r5, r5, r2
8f62b198:	e0455008 	sub	r5, r5, r8
			if ((header->width != fb_display->width)
8f62b19c:	1a000002 	bne	8f62b1ac <splash_screen_mmc+0x1d4>
						|| (header->height != fb_display->height))
8f62b1a0:	e59d3004 	ldr	r3, [r13, #4]
8f62b1a4:	e1530001 	cmp	r3, r1
8f62b1a8:	0a000005 	beq	8f62b1c4 <splash_screen_mmc+0x1ec>
				fbcon_clear();
8f62b1ac:	eb00138d 	bl	8f62ffe8 <fbcon_clear>
			uint32_t fb_size = ROUNDUP(fb_display->width *
8f62b1b0:	e9944001 	ldmib	r4, {r0, r14}
8f62b1b4:	e000009e 	mul	r0, r14, r0
8f62b1b8:	e594e010 	ldr	r14, [r4, #16]
8f62b1bc:	e1a0e1ae 	lsr	r14, r14, #3
8f62b1c0:	e000009e 	mul	r0, r14, r0
8f62b1c4:	e2800eff 	add	r0, r0, #4080	; 0xff0
8f62b1c8:	e280000f 	add	r0, r0, #15
8f62b1cc:	e3c00eff 	bic	r0, r0, #4080	; 0xff0
8f62b1d0:	e3c0000f 	bic	r0, r0, #15
			if (readsize > fb_size) {
8f62b1d4:	e1550000 	cmp	r5, r0
8f62b1d8:	8a000049 	bhi	8f62b304 <splash_screen_mmc+0x32c>
			if (mmc_read(ptn + PLL_CODES_OFFSET + blocksize, (uint32_t *)(base + blocksize), readsize)) {
8f62b1dc:	e0980009 	adds	r0, r8, r9
8f62b1e0:	e2882503 	add	r2, r8, #12582912	; 0xc00000
8f62b1e4:	e2ab1000 	adc	r1, r11, #0
8f62b1e8:	e08a2002 	add	r2, r10, r2
8f62b1ec:	e1a03005 	mov	r3, r5
8f62b1f0:	ebff86a4 	bl	8f60cc88 <mmc_read>
8f62b1f4:	e3500000 	cmp	r0, #0
8f62b1f8:	1a000029 	bne	8f62b2a4 <splash_screen_mmc+0x2cc>
			fbcon_extract_to_screen(header, (base + LOGO_IMG_HEADER_SIZE));
8f62b1fc:	e2861c02 	add	r1, r6, #512	; 0x200
8f62b200:	e1a00006 	mov	r0, r6
8f62b204:	eb0014ee 	bl	8f6305c4 <fbcon_extract_to_screen>
			fb_display->height * (fb_display->bpp / 8)))) {
8f62b208:	eaffffc5 	b	8f62b124 <splash_screen_mmc+0x14c>
				if (mmc_read((ptn + PLL_CODES_OFFSET + LOGO_IMG_HEADER_SIZE), (uint32_t *)base, readsize)) {
8f62b20c:	e2950c12 	adds	r0, r5, #4608	; 0x1200
8f62b210:	e1a0300c 	mov	r3, r12
8f62b214:	e2a71000 	adc	r1, r7, #0
8f62b218:	e1a0200a 	mov	r2, r10
8f62b21c:	ebff8699 	bl	8f60cc88 <mmc_read>
8f62b220:	e3500000 	cmp	r0, #0
8f62b224:	0affffbe 	beq	8f62b124 <splash_screen_mmc+0x14c>
					fbcon_clear();
8f62b228:	eb00136e 	bl	8f62ffe8 <fbcon_clear>
					dprintf(CRITICAL, "ERROR: Cannot read splash image from partition\n");
8f62b22c:	e3090abc 	movw	r0, #39612	; 0x9abc
8f62b230:	e3480f70 	movt	r0, #36720	; 0x8f70
					return -1;
8f62b234:	e3e03000 	mvn	r3, #0
8f62b238:	e58d3000 	str	r3, [r13]
					dprintf(CRITICAL, "ERROR: Cannot read splash image from partition\n");
8f62b23c:	eb001dcc 	bl	8f632974 <_dprintf>
					return -1;
8f62b240:	eaffffb7 	b	8f62b124 <splash_screen_mmc+0x14c>
				dprintf(CRITICAL, "Logo config greater than fb config. Fall back default logo\n");
8f62b244:	e3090aec 	movw	r0, #39660	; 0x9aec
8f62b248:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b24c:	eb001dc8 	bl	8f632974 <_dprintf>
				return -1;
8f62b250:	e3e03000 	mvn	r3, #0
8f62b254:	e58d3000 	str	r3, [r13]
8f62b258:	eaffffb1 	b	8f62b124 <splash_screen_mmc+0x14c>
		dprintf(CRITICAL, "ERROR: splash Partition table not found\n");
8f62b25c:	e3090b4c 	movw	r0, #39756	; 0x9b4c
8f62b260:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b264:	eb001dc2 	bl	8f632974 <_dprintf>
		return -1;
8f62b268:	e3e03000 	mvn	r3, #0
8f62b26c:	e58d3000 	str	r3, [r13]
8f62b270:	eaffffab 	b	8f62b124 <splash_screen_mmc+0x14c>
		dprintf(CRITICAL, "ERROR: splash Partition invalid\n");
8f62b274:	e3090b78 	movw	r0, #39800	; 0x9b78
8f62b278:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b27c:	eb001dbc 	bl	8f632974 <_dprintf>
		return -1;
8f62b280:	e3e03000 	mvn	r3, #0
8f62b284:	e58d3000 	str	r3, [r13]
8f62b288:	eaffffa5 	b	8f62b124 <splash_screen_mmc+0x14c>
		dprintf(CRITICAL, "ERROR:splash Partition invalid blocksize\n");
8f62b28c:	e3090b9c 	movw	r0, #39836	; 0x9b9c
8f62b290:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b294:	eb001db6 	bl	8f632974 <_dprintf>
		return -1;
8f62b298:	e3e03000 	mvn	r3, #0
8f62b29c:	e58d3000 	str	r3, [r13]
8f62b2a0:	eaffff9f 	b	8f62b124 <splash_screen_mmc+0x14c>
				dprintf(CRITICAL, "ERROR: Cannot read splash image from partition\n");
8f62b2a4:	e3090abc 	movw	r0, #39612	; 0x9abc
8f62b2a8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b2ac:	eb001db0 	bl	8f632974 <_dprintf>
				return -1;
8f62b2b0:	e3e03000 	mvn	r3, #0
8f62b2b4:	e58d3000 	str	r3, [r13]
8f62b2b8:	eaffff99 	b	8f62b124 <splash_screen_mmc+0x14c>
		dprintf(CRITICAL, "ERROR: Cannot read splash image header\n");
8f62b2bc:	e3090bec 	movw	r0, #39916	; 0x9bec
8f62b2c0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b2c4:	eb001daa 	bl	8f632974 <_dprintf>
		return -1;
8f62b2c8:	e3e03000 	mvn	r3, #0
8f62b2cc:	e58d3000 	str	r3, [r13]
8f62b2d0:	eaffff93 	b	8f62b124 <splash_screen_mmc+0x14c>
		dprintf(CRITICAL, "ERROR: Splash image header invalid\n");
8f62b2d4:	e3090c14 	movw	r0, #39956	; 0x9c14
8f62b2d8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b2dc:	eb001da4 	bl	8f632974 <_dprintf>
		return -1;
8f62b2e0:	e3e03000 	mvn	r3, #0
8f62b2e4:	e58d3000 	str	r3, [r13]
8f62b2e8:	eaffff8d 	b	8f62b124 <splash_screen_mmc+0x14c>
		dprintf(CRITICAL, "ERROR: fb config is not allocated\n");
8f62b2ec:	e3090bc8 	movw	r0, #39880	; 0x9bc8
8f62b2f0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b2f4:	eb001d9e 	bl	8f632974 <_dprintf>
		return -1;
8f62b2f8:	e3e03000 	mvn	r3, #0
8f62b2fc:	e58d3000 	str	r3, [r13]
8f62b300:	eaffff87 	b	8f62b124 <splash_screen_mmc+0x14c>
				dprintf(CRITICAL, "ERROR: Splash image size invalid\n");
8f62b304:	e3090b28 	movw	r0, #39720	; 0x9b28
8f62b308:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b30c:	eb001d98 	bl	8f632974 <_dprintf>
				return -1;
8f62b310:	e3e03000 	mvn	r3, #0
8f62b314:	e58d3000 	str	r3, [r13]
8f62b318:	eaffff81 	b	8f62b124 <splash_screen_mmc+0x14c>
}
8f62b31c:	eb001e27 	bl	8f632bc0 <__stack_chk_fail>
8f62b320:	8f74221c 	.word	0x8f74221c

8f62b324 <fetch_image_from_partition>:
{
8f62b324:	e59f3064 	ldr	r3, [pc, #100]	; 8f62b390 <fetch_image_from_partition+0x6c>
8f62b328:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62b32c:	e24dd00c 	sub	r13, r13, #12
8f62b330:	e5933000 	ldr	r3, [r3]
8f62b334:	e58d3004 	str	r3, [r13, #4]
8f62b338:	e3a03000 	mov	r3, #0
	if (target_is_emmc_boot()) {
8f62b33c:	ebffd9cf 	bl	8f621a80 <target_is_emmc_boot>
		return splash_screen_mmc();
8f62b340:	e59f3048 	ldr	r3, [pc, #72]	; 8f62b390 <fetch_image_from_partition+0x6c>
	if (target_is_emmc_boot()) {
8f62b344:	e3500000 	cmp	r0, #0
8f62b348:	0a000007 	beq	8f62b36c <fetch_image_from_partition+0x48>
		return splash_screen_mmc();
8f62b34c:	e5932000 	ldr	r2, [r3]
8f62b350:	e59d3004 	ldr	r3, [r13, #4]
8f62b354:	e0332002 	eors	r2, r3, r2
8f62b358:	e3a03000 	mov	r3, #0
8f62b35c:	1a00000a 	bne	8f62b38c <fetch_image_from_partition+0x68>
}
8f62b360:	e28dd00c 	add	r13, r13, #12
8f62b364:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		return splash_screen_mmc();
8f62b368:	eaffff1a 	b	8f62afd8 <splash_screen_mmc>
		return splash_screen_flash();
8f62b36c:	e5932000 	ldr	r2, [r3]
8f62b370:	e59d3004 	ldr	r3, [r13, #4]
8f62b374:	e0332002 	eors	r2, r3, r2
8f62b378:	e3a03000 	mov	r3, #0
8f62b37c:	1a000002 	bne	8f62b38c <fetch_image_from_partition+0x68>
}
8f62b380:	e28dd00c 	add	r13, r13, #12
8f62b384:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		return splash_screen_flash();
8f62b388:	eafffe70 	b	8f62ad50 <splash_screen_flash>
8f62b38c:	eb001e0b 	bl	8f632bc0 <__stack_chk_fail>
8f62b390:	8f74221c 	.word	0x8f74221c

8f62b394 <get_product_name>:

void get_product_name(unsigned char *buf)
{
8f62b394:	e59f304c 	ldr	r3, [pc, #76]	; 8f62b3e8 <get_product_name+0x54>
8f62b398:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62b39c:	e24dd00c 	sub	r13, r13, #12
8f62b3a0:	e5933000 	ldr	r3, [r3]
8f62b3a4:	e58d3004 	str	r3, [r13, #4]
8f62b3a8:	e3a03000 	mov	r3, #0
	snprintf((char*)buf, MAX_RSP_SIZE, "%s",  TARGET(BOARD));
8f62b3ac:	e59f3034 	ldr	r3, [pc, #52]	; 8f62b3e8 <get_product_name+0x54>
8f62b3b0:	e5932000 	ldr	r2, [r3]
8f62b3b4:	e59d3004 	ldr	r3, [r13, #4]
8f62b3b8:	e0332002 	eors	r2, r3, r2
8f62b3bc:	e3a03000 	mov	r3, #0
8f62b3c0:	1a000007 	bne	8f62b3e4 <get_product_name+0x50>
8f62b3c4:	e3093440 	movw	r3, #37952	; 0x9440
8f62b3c8:	e3082348 	movw	r2, #33608	; 0x8348
8f62b3cc:	e3483f70 	movt	r3, #36720	; 0x8f70
8f62b3d0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62b3d4:	e3a01040 	mov	r1, #64	; 0x40
	return;
}
8f62b3d8:	e28dd00c 	add	r13, r13, #12
8f62b3dc:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	snprintf((char*)buf, MAX_RSP_SIZE, "%s",  TARGET(BOARD));
8f62b3e0:	ea0022d6 	b	8f633f40 <snprintf>
8f62b3e4:	eb001df5 	bl	8f632bc0 <__stack_chk_fail>
8f62b3e8:	8f74221c 	.word	0x8f74221c

8f62b3ec <get_bootloader_version>:
	return;
}
#endif

void get_bootloader_version(unsigned char *buf)
{
8f62b3ec:	e59f3048 	ldr	r3, [pc, #72]	; 8f62b43c <get_bootloader_version+0x50>
8f62b3f0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62b3f4:	e24dd00c 	sub	r13, r13, #12
8f62b3f8:	e5933000 	ldr	r3, [r3]
8f62b3fc:	e58d3004 	str	r3, [r13, #4]
8f62b400:	e3a03000 	mov	r3, #0
	snprintf((char*)buf, MAX_RSP_SIZE, "%s",  device.bootloader_version);
8f62b404:	e59f3030 	ldr	r3, [pc, #48]	; 8f62b43c <get_bootloader_version+0x50>
8f62b408:	e5932000 	ldr	r2, [r3]
8f62b40c:	e59d3004 	ldr	r3, [r13, #4]
8f62b410:	e0332002 	eors	r2, r3, r2
8f62b414:	e3a03000 	mov	r3, #0
8f62b418:	1a000006 	bne	8f62b438 <get_bootloader_version+0x4c>
8f62b41c:	e59f301c 	ldr	r3, [pc, #28]	; 8f62b440 <get_bootloader_version+0x54>
8f62b420:	e3082348 	movw	r2, #33608	; 0x8348
8f62b424:	e3a01040 	mov	r1, #64	; 0x40
8f62b428:	e3482f70 	movt	r2, #36720	; 0x8f70
	return;
}
8f62b42c:	e28dd00c 	add	r13, r13, #12
8f62b430:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	snprintf((char*)buf, MAX_RSP_SIZE, "%s",  device.bootloader_version);
8f62b434:	ea0022c1 	b	8f633f40 <snprintf>
8f62b438:	eb001de0 	bl	8f632bc0 <__stack_chk_fail>
8f62b43c:	8f74221c 	.word	0x8f74221c
8f62b440:	8f711b30 	.word	0x8f711b30

8f62b444 <get_baseband_version>:

void get_baseband_version(unsigned char *buf)
{
8f62b444:	e59f3048 	ldr	r3, [pc, #72]	; 8f62b494 <get_baseband_version+0x50>
8f62b448:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62b44c:	e24dd00c 	sub	r13, r13, #12
8f62b450:	e5933000 	ldr	r3, [r3]
8f62b454:	e58d3004 	str	r3, [r13, #4]
8f62b458:	e3a03000 	mov	r3, #0
	snprintf((char*)buf, MAX_RSP_SIZE, "%s", device.radio_version);
8f62b45c:	e59f3030 	ldr	r3, [pc, #48]	; 8f62b494 <get_baseband_version+0x50>
8f62b460:	e5932000 	ldr	r2, [r3]
8f62b464:	e59d3004 	ldr	r3, [r13, #4]
8f62b468:	e0332002 	eors	r2, r3, r2
8f62b46c:	e3a03000 	mov	r3, #0
8f62b470:	1a000006 	bne	8f62b490 <get_baseband_version+0x4c>
8f62b474:	e59f301c 	ldr	r3, [pc, #28]	; 8f62b498 <get_baseband_version+0x54>
8f62b478:	e3082348 	movw	r2, #33608	; 0x8348
8f62b47c:	e3a01040 	mov	r1, #64	; 0x40
8f62b480:	e3482f70 	movt	r2, #36720	; 0x8f70
	return;
}
8f62b484:	e28dd00c 	add	r13, r13, #12
8f62b488:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	snprintf((char*)buf, MAX_RSP_SIZE, "%s", device.radio_version);
8f62b48c:	ea0022ab 	b	8f633f40 <snprintf>
8f62b490:	eb001dca 	bl	8f632bc0 <__stack_chk_fail>
8f62b494:	8f74221c 	.word	0x8f74221c
8f62b498:	8f711b70 	.word	0x8f711b70

8f62b49c <is_device_locked>:
        return device.is_unlock_critical ? false:true;
}

bool is_device_locked()
{
	return device.is_unlocked ? false:true;
8f62b49c:	e3013ad0 	movw	r3, #6864	; 0x1ad0
8f62b4a0:	e3483f71 	movt	r3, #36721	; 0x8f71
{
8f62b4a4:	e59f2040 	ldr	r2, [pc, #64]	; 8f62b4ec <is_device_locked+0x50>
8f62b4a8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62b4ac:	e24dd00c 	sub	r13, r13, #12
	return device.is_unlocked ? false:true;
8f62b4b0:	e5930010 	ldr	r0, [r3, #16]
{
8f62b4b4:	e5922000 	ldr	r2, [r2]
8f62b4b8:	e58d2004 	str	r2, [r13, #4]
8f62b4bc:	e3a02000 	mov	r2, #0
}
8f62b4c0:	e59f3024 	ldr	r3, [pc, #36]	; 8f62b4ec <is_device_locked+0x50>
8f62b4c4:	e5932000 	ldr	r2, [r3]
8f62b4c8:	e59d3004 	ldr	r3, [r13, #4]
8f62b4cc:	e0332002 	eors	r2, r3, r2
8f62b4d0:	e3a03000 	mov	r3, #0
8f62b4d4:	1a000003 	bne	8f62b4e8 <is_device_locked+0x4c>
8f62b4d8:	e16f0f10 	clz	r0, r0
8f62b4dc:	e1a002a0 	lsr	r0, r0, #5
8f62b4e0:	e28dd00c 	add	r13, r13, #12
8f62b4e4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f62b4e8:	eb001db4 	bl	8f632bc0 <__stack_chk_fail>
8f62b4ec:	8f74221c 	.word	0x8f74221c

8f62b4f0 <aboot_fastboot_register_commands>:
        return device.verity_mode ? true:false;
}

/* register commands and variables for fastboot */
void aboot_fastboot_register_commands(void)
{
8f62b4f0:	e92d4070 	push	{r4, r5, r6, r14}
8f62b4f4:	e24ddc01 	sub	r13, r13, #256	; 0x100
8f62b4f8:	e59f3320 	ldr	r3, [pc, #800]	; 8f62b820 <aboot_fastboot_register_commands+0x330>
	int i;
	char hw_platform_buf[MAX_RSP_SIZE];

	struct fastboot_cmd_desc cmd_list[] = {
8f62b4fc:	e28d000c 	add	r0, r13, #12
8f62b500:	e3a020b0 	mov	r2, #176	; 0xb0
8f62b504:	e3091ec0 	movw	r1, #40640	; 0x9ec0
8f62b508:	e3481f70 	movt	r1, #36720	; 0x8f70
{
8f62b50c:	e5933000 	ldr	r3, [r3]
8f62b510:	e58d30fc 	str	r3, [r13, #252]	; 0xfc
8f62b514:	e3a03000 	mov	r3, #0
	struct fastboot_cmd_desc cmd_list[] = {
8f62b518:	eb002326 	bl	8f6341b8 <memcpy>
#endif
#endif
						};

	int fastboot_cmds_count = sizeof(cmd_list)/sizeof(cmd_list[0]);
	for (i = 1; i < fastboot_cmds_count; i++)
8f62b51c:	e28d50b4 	add	r5, r13, #180	; 0xb4
8f62b520:	e28d400c 	add	r4, r13, #12
		fastboot_register(cmd_list[i].name,cmd_list[i].cb);
8f62b524:	e594100c 	ldr	r1, [r4, #12]
8f62b528:	e5b40008 	ldr	r0, [r4, #8]!
8f62b52c:	eb000397 	bl	8f62c390 <fastboot_register>
	for (i = 1; i < fastboot_cmds_count; i++)
8f62b530:	e1540005 	cmp	r4, r5
8f62b534:	1afffffa 	bne	8f62b524 <aboot_fastboot_register_commands+0x34>

	/* publish variables and their values */
	fastboot_publish("product",  TARGET(BOARD));
8f62b538:	e3091440 	movw	r1, #37952	; 0x9440
8f62b53c:	e3090c38 	movw	r0, #39992	; 0x9c38
8f62b540:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62b544:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b548:	eb0003b0 	bl	8f62c410 <fastboot_publish>
	fastboot_publish("kernel",   "lk");
8f62b54c:	e30018b0 	movw	r1, #2224	; 0x8b0
8f62b550:	e3090c40 	movw	r0, #40000	; 0x9c40
8f62b554:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62b558:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b55c:	eb0003ab 	bl	8f62c410 <fastboot_publish>
	fastboot_publish("serialno", sn_buf);
8f62b560:	e3021dc0 	movw	r1, #11712	; 0x2dc0
8f62b564:	e3090c48 	movw	r0, #40008	; 0x9c48
8f62b568:	e3481f74 	movt	r1, #36724	; 0x8f74
8f62b56c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b570:	eb0003a6 	bl	8f62c410 <fastboot_publish>

	/*publish hw-revision major(upper 16 bits) and minor(lower 16 bits)*/
	snprintf(soc_version_str, MAX_RSP_SIZE, "%x", board_soc_version());
8f62b574:	ebff93a6 	bl	8f610414 <board_soc_version>
8f62b578:	e3a01040 	mov	r1, #64	; 0x40
8f62b57c:	e30021fc 	movw	r2, #508	; 0x1fc
8f62b580:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62b584:	e1a03000 	mov	r3, r0
8f62b588:	e3020e94 	movw	r0, #11924	; 0x2e94
8f62b58c:	e3480f74 	movt	r0, #36724	; 0x8f74
8f62b590:	eb00226a 	bl	8f633f40 <snprintf>
	fastboot_publish("hw-revision", soc_version_str);
8f62b594:	e3021e94 	movw	r1, #11924	; 0x2e94
8f62b598:	e3090c54 	movw	r0, #40020	; 0x9c54
8f62b59c:	e3481f74 	movt	r1, #36724	; 0x8f74
8f62b5a0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b5a4:	eb000399 	bl	8f62c410 <fastboot_publish>
	 * partition info is supported only for emmc partitions
	 * Calling this for NAND prints some error messages which
	 * is harmless but misleading. Avoid calling this for NAND
	 * devices.
	 */
	if (target_is_emmc_boot())
8f62b5a8:	ebffd934 	bl	8f621a80 <target_is_emmc_boot>
8f62b5ac:	e3500000 	cmp	r0, #0
8f62b5b0:	1a000091 	bne	8f62b7fc <aboot_fastboot_register_commands+0x30c>
		publish_getvar_partition_info(part_info, partition_get_partition_count());

	if (partition_multislot_is_supported())
8f62b5b4:	ebff6854 	bl	8f60570c <partition_multislot_is_supported>
8f62b5b8:	e3500000 	cmp	r0, #0
8f62b5bc:	1a000094 	bne	8f62b814 <aboot_fastboot_register_commands+0x324>
		publish_getvar_multislot_vars();

	/* Max download size supported */
#if !VERIFIED_BOOT_2
	snprintf(max_download_size, MAX_RSP_SIZE, "\t0x%x",
8f62b5c0:	ebff5775 	bl	8f60139c <target_get_max_flash_size>
			SUB_SALT_BUFF_OFFSET(target_get_max_flash_size()));
#endif

	fastboot_publish("max-download-size", (const char *) max_download_size);
	/* Is the charger screen check enabled */
	snprintf(charger_screen_enabled, MAX_RSP_SIZE, "%d",
8f62b5c4:	e3014ad0 	movw	r4, #6864	; 0x1ad0
	snprintf(max_download_size, MAX_RSP_SIZE, "\t0x%x",
8f62b5c8:	e3a01040 	mov	r1, #64	; 0x40
	snprintf(charger_screen_enabled, MAX_RSP_SIZE, "%d",
8f62b5cc:	e3484f71 	movt	r4, #36721	; 0x8f71
	snprintf(max_download_size, MAX_RSP_SIZE, "\t0x%x",
8f62b5d0:	e3092c60 	movw	r2, #40032	; 0x9c60
8f62b5d4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62b5d8:	e1a03000 	mov	r3, r0
8f62b5dc:	e3020ed4 	movw	r0, #11988	; 0x2ed4
8f62b5e0:	e3480f74 	movt	r0, #36724	; 0x8f74
8f62b5e4:	eb002255 	bl	8f633f40 <snprintf>
	fastboot_publish("max-download-size", (const char *) max_download_size);
8f62b5e8:	e3021ed4 	movw	r1, #11988	; 0x2ed4
8f62b5ec:	e3090c68 	movw	r0, #40040	; 0x9c68
8f62b5f0:	e3481f74 	movt	r1, #36724	; 0x8f74
8f62b5f4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b5f8:	eb000384 	bl	8f62c410 <fastboot_publish>
	snprintf(charger_screen_enabled, MAX_RSP_SIZE, "%d",
8f62b5fc:	e594301c 	ldr	r3, [r4, #28]
8f62b600:	e3a01040 	mov	r1, #64	; 0x40
8f62b604:	e30a2b00 	movw	r2, #43776	; 0xab00
8f62b608:	e3020f14 	movw	r0, #12052	; 0x2f14
8f62b60c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62b610:	e3480f74 	movt	r0, #36724	; 0x8f74
8f62b614:	eb002249 	bl	8f633f40 <snprintf>
			device.charger_screen_enabled);
	fastboot_publish("charger-screen-enabled",
8f62b618:	e3021f14 	movw	r1, #12052	; 0x2f14
8f62b61c:	e3090c7c 	movw	r0, #40060	; 0x9c7c
8f62b620:	e3481f74 	movt	r1, #36724	; 0x8f74
8f62b624:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b628:	eb000378 	bl	8f62c410 <fastboot_publish>
			(const char *) charger_screen_enabled);
	fastboot_publish("off-mode-charge", (const char *) charger_screen_enabled);
8f62b62c:	e3021f14 	movw	r1, #12052	; 0x2f14
8f62b630:	e30802a4 	movw	r0, #33444	; 0x82a4
8f62b634:	e3481f74 	movt	r1, #36724	; 0x8f74
8f62b638:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b63c:	eb000373 	bl	8f62c410 <fastboot_publish>
	snprintf(panel_display_mode, MAX_RSP_SIZE, "%s",
8f62b640:	e2843020 	add	r3, r4, #32
8f62b644:	e3a01040 	mov	r1, #64	; 0x40
8f62b648:	e3082348 	movw	r2, #33608	; 0x8348
8f62b64c:	e3020d40 	movw	r0, #11584	; 0x2d40
8f62b650:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62b654:	e3480f74 	movt	r0, #36724	; 0x8f74
8f62b658:	eb002238 	bl	8f633f40 <snprintf>
			device.display_panel);
	fastboot_publish("display-panel",
8f62b65c:	e3021d40 	movw	r1, #11584	; 0x2d40
8f62b660:	e3090c94 	movw	r0, #40084	; 0x9c94
8f62b664:	e3481f74 	movt	r1, #36724	; 0x8f74
8f62b668:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b66c:	eb000367 	bl	8f62c410 <fastboot_publish>
			(const char *) panel_display_mode);

        if (target_is_emmc_boot())
8f62b670:	ebffd902 	bl	8f621a80 <target_is_emmc_boot>
8f62b674:	e3500000 	cmp	r0, #0
8f62b678:	0a000059 	beq	8f62b7e4 <aboot_fastboot_register_commands+0x2f4>
        {
		mmc_blocksize = mmc_get_device_blocksize();
8f62b67c:	ebff873e 	bl	8f60d37c <mmc_get_device_blocksize>
8f62b680:	e30f2648 	movw	r2, #63048	; 0xf648
8f62b684:	e3482f73 	movt	r2, #36723	; 0x8f73
8f62b688:	e1a03000 	mov	r3, r0
8f62b68c:	e5820000 	str	r0, [r2]
        }
        else
        {
		mmc_blocksize = flash_block_size();
        }
	snprintf(block_size_string, MAX_RSP_SIZE, "0x%x", mmc_blocksize);
8f62b690:	e3a01040 	mov	r1, #64	; 0x40
8f62b694:	e3092ca4 	movw	r2, #40100	; 0x9ca4
8f62b698:	e3020d80 	movw	r0, #11648	; 0x2d80
8f62b69c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62b6a0:	e3480f74 	movt	r0, #36724	; 0x8f74
	fastboot_publish("version-baseband", "N/A");
#else
	fastboot_publish("version-bootloader", (const char *) device.bootloader_version);
	fastboot_publish("version-baseband", (const char *) device.radio_version);
#endif
	fastboot_publish("secure", is_secure_boot_enable()? "yes":"no");
8f62b6a4:	e30866c0 	movw	r6, #34496	; 0x86c0
	snprintf(block_size_string, MAX_RSP_SIZE, "0x%x", mmc_blocksize);
8f62b6a8:	eb002224 	bl	8f633f40 <snprintf>
	fastboot_publish("erase-block-size", (const char *) block_size_string);
8f62b6ac:	e3021d80 	movw	r1, #11648	; 0x2d80
8f62b6b0:	e3090cac 	movw	r0, #40108	; 0x9cac
8f62b6b4:	e3481f74 	movt	r1, #36724	; 0x8f74
8f62b6b8:	e3480f70 	movt	r0, #36720	; 0x8f70
	fastboot_publish("secure", is_secure_boot_enable()? "yes":"no");
8f62b6bc:	e3486f70 	movt	r6, #36720	; 0x8f70
	fastboot_publish("erase-block-size", (const char *) block_size_string);
8f62b6c0:	eb000352 	bl	8f62c410 <fastboot_publish>
	fastboot_publish("logical-block-size", (const char *) block_size_string);
8f62b6c4:	e3021d80 	movw	r1, #11648	; 0x2d80
8f62b6c8:	e3090cc0 	movw	r0, #40128	; 0x9cc0
8f62b6cc:	e3481f74 	movt	r1, #36724	; 0x8f74
8f62b6d0:	e3480f70 	movt	r0, #36720	; 0x8f70
	fastboot_publish("secure", is_secure_boot_enable()? "yes":"no");
8f62b6d4:	e30856c4 	movw	r5, #34500	; 0x86c4
	fastboot_publish("logical-block-size", (const char *) block_size_string);
8f62b6d8:	eb00034c 	bl	8f62c410 <fastboot_publish>
	fastboot_publish("version-bootloader", (const char *) device.bootloader_version);
8f62b6dc:	e59f1140 	ldr	r1, [pc, #320]	; 8f62b824 <aboot_fastboot_register_commands+0x334>
8f62b6e0:	e3090cd4 	movw	r0, #40148	; 0x9cd4
8f62b6e4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b6e8:	eb000348 	bl	8f62c410 <fastboot_publish>
	fastboot_publish("version-baseband", (const char *) device.radio_version);
8f62b6ec:	e59f1134 	ldr	r1, [pc, #308]	; 8f62b828 <aboot_fastboot_register_commands+0x338>
8f62b6f0:	e3090ce8 	movw	r0, #40168	; 0x9ce8
8f62b6f4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b6f8:	eb000344 	bl	8f62c410 <fastboot_publish>
	fastboot_publish("secure", is_secure_boot_enable()? "yes":"no");
8f62b6fc:	e3485f70 	movt	r5, #36720	; 0x8f70
8f62b700:	ebffa6bd 	bl	8f6151fc <is_secure_boot_enable>
8f62b704:	e1a01000 	mov	r1, r0
8f62b708:	e3510000 	cmp	r1, #0
8f62b70c:	e3090cfc 	movw	r0, #40188	; 0x9cfc
8f62b710:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b714:	11a01006 	movne	r1, r6
8f62b718:	01a01005 	moveq	r1, r5
8f62b71c:	eb00033b 	bl	8f62c410 <fastboot_publish>
	fastboot_publish("unlocked", device.is_unlocked ? "yes":"no");
8f62b720:	e5941010 	ldr	r1, [r4, #16]
8f62b724:	e30306b8 	movw	r0, #14008	; 0x36b8
8f62b728:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b72c:	e3510000 	cmp	r1, #0
8f62b730:	11a01006 	movne	r1, r6
8f62b734:	01a01005 	moveq	r1, r5
8f62b738:	eb000334 	bl	8f62c410 <fastboot_publish>
	smem_get_hw_platform_name((unsigned char *) hw_platform_buf, sizeof(hw_platform_buf));
8f62b73c:	e3a01040 	mov	r1, #64	; 0x40
8f62b740:	e28d00bc 	add	r0, r13, #188	; 0xbc
8f62b744:	ebff5d0e 	bl	8f602b84 <smem_get_hw_platform_name>
	snprintf(get_variant, MAX_RSP_SIZE, "%s %s", hw_platform_buf,
		target_is_emmc_boot()? "eMMC":"UFS");
8f62b748:	ebffd8cc 	bl	8f621a80 <target_is_emmc_boot>
	snprintf(get_variant, MAX_RSP_SIZE, "%s %s", hw_platform_buf,
8f62b74c:	e3032690 	movw	r2, #13968	; 0x3690
8f62b750:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62b754:	e28d30bc 	add	r3, r13, #188	; 0xbc
8f62b758:	e3a01040 	mov	r1, #64	; 0x40
8f62b75c:	e303c698 	movw	r12, #13976	; 0x3698
8f62b760:	e348cf70 	movt	r12, #36720	; 0x8f70
8f62b764:	e3500000 	cmp	r0, #0
8f62b768:	e3090394 	movw	r0, #37780	; 0x9394
8f62b76c:	e3480f75 	movt	r0, #36725	; 0x8f75
8f62b770:	11a0c002 	movne	r12, r2
8f62b774:	e3092d04 	movw	r2, #40196	; 0x9d04
8f62b778:	e58dc000 	str	r12, [r13]
8f62b77c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62b780:	eb0021ee 	bl	8f633f40 <snprintf>
	fastboot_publish("variant", (const char *) get_variant);
8f62b784:	e3091394 	movw	r1, #37780	; 0x9394
8f62b788:	e3090d0c 	movw	r0, #40204	; 0x9d0c
8f62b78c:	e3481f75 	movt	r1, #36725	; 0x8f75
8f62b790:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b794:	eb00031d 	bl	8f62c410 <fastboot_publish>
#if CHECK_BAT_VOLTAGE
	update_battery_status();
8f62b798:	ebffebe0 	bl	8f626720 <update_battery_status>
	fastboot_publish("battery-voltage", (const char *) battery_voltage);
8f62b79c:	e3021d00 	movw	r1, #11520	; 0x2d00
8f62b7a0:	e3090d14 	movw	r0, #40212	; 0x9d14
8f62b7a4:	e3481f74 	movt	r1, #36724	; 0x8f74
8f62b7a8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b7ac:	eb000317 	bl	8f62c410 <fastboot_publish>
	fastboot_publish("battery-soc-ok", (const char *) battery_soc_ok);
8f62b7b0:	e3091354 	movw	r1, #37716	; 0x9354
8f62b7b4:	e3090d24 	movw	r0, #40228	; 0x9d24
8f62b7b8:	e3481f75 	movt	r1, #36725	; 0x8f75
8f62b7bc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b7c0:	eb000312 	bl	8f62c410 <fastboot_publish>
#endif
}
8f62b7c4:	e59f3054 	ldr	r3, [pc, #84]	; 8f62b820 <aboot_fastboot_register_commands+0x330>
8f62b7c8:	e5932000 	ldr	r2, [r3]
8f62b7cc:	e59d30fc 	ldr	r3, [r13, #252]	; 0xfc
8f62b7d0:	e0332002 	eors	r2, r3, r2
8f62b7d4:	e3a03000 	mov	r3, #0
8f62b7d8:	1a00000f 	bne	8f62b81c <aboot_fastboot_register_commands+0x32c>
8f62b7dc:	e28ddc01 	add	r13, r13, #256	; 0x100
8f62b7e0:	e8bd8070 	pop	{r4, r5, r6, r15}
		mmc_blocksize = flash_block_size();
8f62b7e4:	ebff9dd1 	bl	8f612f30 <flash_block_size>
8f62b7e8:	e30f2648 	movw	r2, #63048	; 0xf648
8f62b7ec:	e3482f73 	movt	r2, #36723	; 0x8f73
8f62b7f0:	e1a03000 	mov	r3, r0
8f62b7f4:	e5820000 	str	r0, [r2]
8f62b7f8:	eaffffa4 	b	8f62b690 <aboot_fastboot_register_commands+0x1a0>
		publish_getvar_partition_info(part_info, partition_get_partition_count());
8f62b7fc:	ebff60e5 	bl	8f603b98 <partition_get_partition_count>
8f62b800:	e6ef0070 	uxtb	r0, r0
8f62b804:	ebffe952 	bl	8f625d54 <publish_getvar_partition_info.constprop.0>
	if (partition_multislot_is_supported())
8f62b808:	ebff67bf 	bl	8f60570c <partition_multislot_is_supported>
8f62b80c:	e3500000 	cmp	r0, #0
8f62b810:	0affff6a 	beq	8f62b5c0 <aboot_fastboot_register_commands+0xd0>
		publish_getvar_multislot_vars();
8f62b814:	ebffe7d6 	bl	8f625774 <publish_getvar_multislot_vars>
8f62b818:	eaffff68 	b	8f62b5c0 <aboot_fastboot_register_commands+0xd0>
}
8f62b81c:	eb001ce7 	bl	8f632bc0 <__stack_chk_fail>
8f62b820:	8f74221c 	.word	0x8f74221c
8f62b824:	8f711b30 	.word	0x8f711b30
8f62b828:	8f711b70 	.word	0x8f711b70

8f62b82c <aboot_init>:

void aboot_init(const struct app_descriptor *app)
{
8f62b82c:	e92d4bf0 	push	{r4, r5, r6, r7, r8, r9, r11, r14}
8f62b830:	e28db01c 	add	r11, r13, #28
8f62b834:	e24dd008 	sub	r13, r13, #8
8f62b838:	e59f3430 	ldr	r3, [pc, #1072]	; 8f62bc70 <aboot_init+0x444>
8f62b83c:	e5933000 	ldr	r3, [r3]
8f62b840:	e50b3020 	str	r3, [r11, #-32]	; 0xffffffe0
8f62b844:	e3a03000 	mov	r3, #0
#if WDOG_SUPPORT
	msm_wdog_init();
#endif

	/* Setup page size information for nv storage */
	if (target_is_emmc_boot())
8f62b848:	ebffd88c 	bl	8f621a80 <target_is_emmc_boot>
8f62b84c:	e3500000 	cmp	r0, #0
8f62b850:	0a00009c 	beq	8f62bac8 <aboot_init+0x29c>
	{
		page_size = mmc_page_size();
8f62b854:	ebff86e0 	bl	8f60d3dc <mmc_page_size>
8f62b858:	e3002684 	movw	r2, #1668	; 0x684
		page_mask = page_size - 1;
8f62b85c:	e3003680 	movw	r3, #1664	; 0x680
		page_size = mmc_page_size();
8f62b860:	e3482f74 	movt	r2, #36724	; 0x8f74
		page_mask = page_size - 1;
8f62b864:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62b868:	e2401001 	sub	r1, r0, #1
		page_size = mmc_page_size();
8f62b86c:	e5820000 	str	r0, [r2]
		page_mask = page_size - 1;
8f62b870:	e5831000 	str	r1, [r3]
		mmc_blocksize = mmc_get_device_blocksize();
8f62b874:	ebff86c0 	bl	8f60d37c <mmc_get_device_blocksize>
8f62b878:	e30f2648 	movw	r2, #63048	; 0xf648
		mmc_blocksize_mask = mmc_blocksize - 1;
8f62b87c:	e30f364c 	movw	r3, #63052	; 0xf64c
		mmc_blocksize = mmc_get_device_blocksize();
8f62b880:	e3482f73 	movt	r2, #36723	; 0x8f73
		mmc_blocksize_mask = mmc_blocksize - 1;
8f62b884:	e3483f73 	movt	r3, #36723	; 0x8f73
8f62b888:	e2401001 	sub	r1, r0, #1
		mmc_blocksize = mmc_get_device_blocksize();
8f62b88c:	e5820000 	str	r0, [r2]
		mmc_blocksize_mask = mmc_blocksize - 1;
8f62b890:	e5831000 	str	r1, [r3]
		page_size = flash_page_size();
		page_mask = page_size - 1;
	}
	ASSERT((MEMBASE + MEMSIZE) > MEMBASE);

	lk2nd_init();
8f62b894:	eb0008ec 	bl	8f62dc4c <lk2nd_init>
	read_device_info(&device);
8f62b898:	e3010ad0 	movw	r0, #6864	; 0x1ad0
8f62b89c:	e3480f71 	movt	r0, #36721	; 0x8f71
{
8f62b8a0:	e1a0700d 	mov	r7, r13
	read_device_info(&device);
8f62b8a4:	ebfff3e6 	bl	8f628844 <read_device_info>
	unsigned blocksize = mmc_get_device_blocksize();
8f62b8a8:	ebff86b3 	bl	8f60d37c <mmc_get_device_blocksize>
	STACKBUF_DMA_ALIGN(buf, blocksize);
8f62b8ac:	e280307f 	add	r3, r0, #127	; 0x7f
	unsigned blocksize = mmc_get_device_blocksize();
8f62b8b0:	e1a05000 	mov	r5, r0
	STACKBUF_DMA_ALIGN(buf, blocksize);
8f62b8b4:	e3c33007 	bic	r3, r3, #7
	index = partition_get_index(frp_ptns[0]);
8f62b8b8:	e30204c4 	movw	r0, #9412	; 0x24c4
	STACKBUF_DMA_ALIGN(buf, blocksize);
8f62b8bc:	e04dd003 	sub	r13, r13, r3
	index = partition_get_index(frp_ptns[0]);
8f62b8c0:	e3480f71 	movt	r0, #36721	; 0x8f71
8f62b8c4:	ebff60f0 	bl	8f603c8c <partition_get_index>
	STACKBUF_DMA_ALIGN(buf, blocksize);
8f62b8c8:	e28d603f 	add	r6, r13, #63	; 0x3f
8f62b8cc:	e3c6603f 	bic	r6, r6, #63	; 0x3f
	if (index == INVALID_PTN)
8f62b8d0:	e3700001 	cmn	r0, #1
	index = partition_get_index(frp_ptns[0]);
8f62b8d4:	e1a04000 	mov	r4, r0
	if (index == INVALID_PTN)
8f62b8d8:	0a000083 	beq	8f62baec <aboot_init+0x2c0>
	ptn = partition_get_offset(index);
8f62b8dc:	e1a00004 	mov	r0, r4
8f62b8e0:	ebff63f5 	bl	8f6048bc <partition_get_offset>
8f62b8e4:	e1a08000 	mov	r8, r0
	ptn_size = partition_get_size(index);
8f62b8e8:	e1a00004 	mov	r0, r4
	ptn = partition_get_offset(index);
8f62b8ec:	e1a09001 	mov	r9, r1
	ptn_size = partition_get_size(index);
8f62b8f0:	ebff63d0 	bl	8f604838 <partition_get_size>
8f62b8f4:	e1a03000 	mov	r3, r0
	mmc_set_lun(partition_get_lun(index));
8f62b8f8:	e1a00004 	mov	r0, r4
	offset = ptn_size - blocksize;
8f62b8fc:	e0434005 	sub	r4, r3, r5
	mmc_set_lun(partition_get_lun(index));
8f62b900:	ebff640e 	bl	8f604940 <partition_get_lun>
8f62b904:	ebff86ca 	bl	8f60d434 <mmc_set_lun>
	if (mmc_read(ptn + offset, (void *)buf, blocksize))
8f62b908:	e0940008 	adds	r0, r4, r8
8f62b90c:	e2a91000 	adc	r1, r9, #0
8f62b910:	e1a03005 	mov	r3, r5
8f62b914:	e1a02006 	mov	r2, r6
8f62b918:	ebff84da 	bl	8f60cc88 <mmc_read>
8f62b91c:	e3500000 	cmp	r0, #0
8f62b920:	1a0000cd 	bne	8f62bc5c <aboot_init+0x430>
	is_allow_unlock = buf[blocksize-1] & 0x01;
8f62b924:	e0865005 	add	r5, r6, r5
8f62b928:	e30f3444 	movw	r3, #62532	; 0xf444
8f62b92c:	e3483f73 	movt	r3, #36723	; 0x8f73
8f62b930:	e5552001 	ldrb	r2, [r5, #-1]
8f62b934:	e2022001 	and	r2, r2, #1
8f62b938:	e5832000 	str	r2, [r3]
	return 0;
8f62b93c:	e1a0d007 	mov	r13, r7
	read_allow_oem_unlock(&device);

	/* Detect multi-slot support */
	if (partition_multislot_is_supported())
8f62b940:	ebff6771 	bl	8f60570c <partition_multislot_is_supported>
8f62b944:	e3500000 	cmp	r0, #0
8f62b948:	1a000081 	bne	8f62bb54 <aboot_init+0x328>
8f62b94c:	e30441d4 	movw	r4, #16852	; 0x41d4
8f62b950:	e3484f73 	movt	r4, #36723	; 0x8f73
	/* Display splash screen if enabled */
#if DISPLAY_SPLASH_SCREEN
#if NO_ALARM_DISPLAY
	if (!check_alarm_boot()) {
#endif
		dprintf(SPEW, "Display Init: Start\n");
8f62b954:	e3090d9c 	movw	r0, #40348	; 0x9d9c
8f62b958:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b95c:	eb001c04 	bl	8f632974 <_dprintf>
		if (!pm_appsbl_display_init_done())
			target_display_init(device.display_panel);
		else
			display_image_on_screen();
#else
		target_display_init(device.display_panel);
8f62b960:	e59f030c 	ldr	r0, [pc, #780]	; 8f62bc74 <aboot_init+0x448>
8f62b964:	ebffdb14 	bl	8f6225bc <target_display_init>
#endif
		dprintf(SPEW, "Display Init: Done\n");
8f62b968:	e3090db4 	movw	r0, #40372	; 0x9db4
8f62b96c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b970:	eb001bff 	bl	8f632974 <_dprintf>
#if NO_ALARM_DISPLAY
	}
#endif
#endif

	target_serialno((unsigned char *) sn_buf);
8f62b974:	e3020dc0 	movw	r0, #11712	; 0x2dc0
8f62b978:	e3480f74 	movt	r0, #36724	; 0x8f74
8f62b97c:	ebff5453 	bl	8f600ad0 <target_serialno>
	dprintf(SPEW,"serial number: %s\n",sn_buf);
8f62b980:	e3021dc0 	movw	r1, #11712	; 0x2dc0
8f62b984:	e3090dc8 	movw	r0, #40392	; 0x9dc8
8f62b988:	e3481f74 	movt	r1, #36724	; 0x8f74
8f62b98c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62b990:	eb001bf7 	bl	8f632974 <_dprintf>

	memset(display_panel_buf, '\0', MAX_PANEL_BUF_SIZE);
8f62b994:	e3a020c4 	mov	r2, #196	; 0xc4
8f62b998:	e3a01000 	mov	r1, #0
8f62b99c:	e3020dd0 	movw	r0, #11728	; 0x2dd0
8f62b9a0:	e3480f74 	movt	r0, #36724	; 0x8f74
8f62b9a4:	eb002246 	bl	8f6342c4 <memset>

	/* Check if we should do something other than booting up */
	if (keys_get_state(KEY_VOLUMEUP) && keys_get_state(KEY_VOLUMEDOWN))
8f62b9a8:	e3000115 	movw	r0, #277	; 0x115
8f62b9ac:	eb00148f 	bl	8f630bf0 <keys_get_state>
8f62b9b0:	e3500000 	cmp	r0, #0
8f62b9b4:	1a000057 	bne	8f62bb18 <aboot_init+0x2ec>
		reboot_device(EMERGENCY_DLOAD);
		dprintf(CRITICAL,"Failed to reboot into dload mode\n");

		boot_into_fastboot = true;
	}
	if (!boot_into_fastboot)
8f62b9b8:	e5945000 	ldr	r5, [r4]
8f62b9bc:	e3550000 	cmp	r5, #0
8f62b9c0:	0a000071 	beq	8f62bb8c <aboot_init+0x360>
	if (fastboot_trigger())
		boot_into_fastboot = true;
	#endif

#if USE_PON_REBOOT_REG
	reboot_mode = check_hard_reboot_mode();
8f62b9c4:	ebffd23c 	bl	8f6202bc <check_hard_reboot_mode>
#else
	reboot_mode = check_reboot_mode();
#endif
	if (reboot_mode == RECOVERY_MODE)
8f62b9c8:	e3500001 	cmp	r0, #1
	{
		boot_into_recovery = 1;
8f62b9cc:	0301317c 	movweq	r3, #4476	; 0x117c
8f62b9d0:	03483f74 	movteq	r3, #36724	; 0x8f74
8f62b9d4:	05830000 	streq	r0, [r3]
	if (reboot_mode == RECOVERY_MODE)
8f62b9d8:	0a000003 	beq	8f62b9ec <aboot_init+0x1c0>
	}
	else if(reboot_mode == FASTBOOT_MODE)
8f62b9dc:	e3500002 	cmp	r0, #2
	{
		boot_into_fastboot = true;
8f62b9e0:	03a03001 	moveq	r3, #1
8f62b9e4:	05843000 	streq	r3, [r4]
	else if(reboot_mode == FASTBOOT_MODE)
8f62b9e8:	0a000002 	beq	8f62b9f8 <aboot_init+0x1cc>
		}
	}
#endif

normal_boot:
	if (!boot_into_fastboot)
8f62b9ec:	e5944000 	ldr	r4, [r4]
8f62b9f0:	e3540000 	cmp	r4, #0
8f62b9f4:	0a000012 	beq	8f62ba44 <aboot_init+0x218>

fastboot:
	/* We are here means regular boot did not happen. Start fastboot. */

	/* register aboot specific fastboot commands */
	aboot_fastboot_register_commands();
8f62b9f8:	ebfffebc 	bl	8f62b4f0 <aboot_fastboot_register_commands>
	fastboot_lk2nd_register_commands();
8f62b9fc:	eb00075a 	bl	8f62d76c <fastboot_lk2nd_register_commands>

	/* dump partition table for debug info */
	partition_dump();
8f62ba00:	ebff63e4 	bl	8f604998 <partition_dump>

	/* Log stuff for fs-boot */
	fsboot_test();
8f62ba04:	eb000ce8 	bl	8f62edac <fsboot_test>

	/* initialize and start fastboot */
#if !VERIFIED_BOOT_2
	fastboot_init(target_get_scratch_address(), target_get_max_flash_size());
8f62ba08:	ebff5651 	bl	8f601354 <target_get_scratch_address>
8f62ba0c:	e1a04000 	mov	r4, r0
8f62ba10:	ebff5661 	bl	8f60139c <target_get_max_flash_size>
8f62ba14:	e1a01000 	mov	r1, r0
8f62ba18:	e1a00004 	mov	r0, r4
8f62ba1c:	eb0005d0 	bl	8f62d164 <fastboot_init>
	/* Add salt buffer offset at start of image address to copy VB salt */
	fastboot_init(ADD_SALT_BUFF_OFFSET(target_get_scratch_address()),
		SUB_SALT_BUFF_OFFSET(target_get_max_flash_size()));
#endif
#if FBCON_DISPLAY_MSG
	display_fastboot_menu();
8f62ba20:	ebff8b7a 	bl	8f60e810 <display_fastboot_menu>
#endif
}
8f62ba24:	e59f3244 	ldr	r3, [pc, #580]	; 8f62bc70 <aboot_init+0x444>
8f62ba28:	e5932000 	ldr	r2, [r3]
8f62ba2c:	e51b3020 	ldr	r3, [r11, #-32]	; 0xffffffe0
8f62ba30:	e0332002 	eors	r2, r3, r2
8f62ba34:	e3a03000 	mov	r3, #0
8f62ba38:	1a00008b 	bne	8f62bc6c <aboot_init+0x440>
8f62ba3c:	e24bd01c 	sub	r13, r11, #28
8f62ba40:	e8bd8bf0 	pop	{r4, r5, r6, r7, r8, r9, r11, r15}
		if (target_is_emmc_boot())
8f62ba44:	ebffd80d 	bl	8f621a80 <target_is_emmc_boot>
8f62ba48:	e3500000 	cmp	r0, #0
8f62ba4c:	0a00005d 	beq	8f62bbc8 <aboot_init+0x39c>
			ssize_t loaded_file = fsboot_boot_first(target_get_scratch_address(), target_get_max_flash_size());
8f62ba50:	ebff563f 	bl	8f601354 <target_get_scratch_address>
8f62ba54:	e1a05000 	mov	r5, r0
8f62ba58:	ebff564f 	bl	8f60139c <target_get_max_flash_size>
8f62ba5c:	e1a01000 	mov	r1, r0
8f62ba60:	e1a00005 	mov	r0, r5
8f62ba64:	eb000ceb 	bl	8f62ee18 <fsboot_boot_first>
			if (loaded_file > 0)
8f62ba68:	e3500000 	cmp	r0, #0
8f62ba6c:	da000006 	ble	8f62ba8c <aboot_init+0x260>
				cmd_boot(NULL, target_get_scratch_address(), target_get_max_flash_size());
8f62ba70:	ebff5637 	bl	8f601354 <target_get_scratch_address>
8f62ba74:	e1a05000 	mov	r5, r0
8f62ba78:	ebff5647 	bl	8f60139c <target_get_max_flash_size>
8f62ba7c:	e1a01005 	mov	r1, r5
8f62ba80:	e1a02000 	mov	r2, r0
8f62ba84:	e1a00004 	mov	r0, r4
8f62ba88:	ebfff4ff 	bl	8f628e8c <cmd_boot>
			dprintf(CRITICAL, "Unable to load boot.img from ext2. Continuing legacy boot\n");
8f62ba8c:	e3090e24 	movw	r0, #40484	; 0x9e24
8f62ba90:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62ba94:	eb001bb6 	bl	8f632974 <_dprintf>
			if(emmc_recovery_init())
8f62ba98:	ebff5499 	bl	8f600d04 <emmc_recovery_init>
8f62ba9c:	e3500000 	cmp	r0, #0
8f62baa0:	1a000069 	bne	8f62bc4c <aboot_init+0x420>
			if(target_use_signed_kernel())
8f62baa4:	ebffd806 	bl	8f621ac4 <target_use_signed_kernel>
			if (partition_multislot_is_supported())
8f62baa8:	ebff6717 	bl	8f60570c <partition_multislot_is_supported>
8f62baac:	e3500000 	cmp	r0, #0
8f62bab0:	0a000002 	beq	8f62bac0 <aboot_init+0x294>
				boot_slot = partition_find_boot_slot();
8f62bab4:	ebff66cb 	bl	8f6055e8 <partition_find_boot_slot>
				if (boot_slot == INVALID)
8f62bab8:	e3700001 	cmn	r0, #1
8f62babc:	0affffcd 	beq	8f62b9f8 <aboot_init+0x1cc>
			boot_err_type = boot_linux_from_mmc();
8f62bac0:	ebffec9c 	bl	8f626d38 <boot_linux_from_mmc>
					break;
8f62bac4:	ea000041 	b	8f62bbd0 <aboot_init+0x3a4>
		page_size = flash_page_size();
8f62bac8:	ebff9d05 	bl	8f612ee4 <flash_page_size>
8f62bacc:	e3002684 	movw	r2, #1668	; 0x684
		page_mask = page_size - 1;
8f62bad0:	e3003680 	movw	r3, #1664	; 0x680
		page_size = flash_page_size();
8f62bad4:	e3482f74 	movt	r2, #36724	; 0x8f74
		page_mask = page_size - 1;
8f62bad8:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62badc:	e2401001 	sub	r1, r0, #1
		page_size = flash_page_size();
8f62bae0:	e5820000 	str	r0, [r2]
		page_mask = page_size - 1;
8f62bae4:	e5831000 	str	r1, [r3]
8f62bae8:	eaffff69 	b	8f62b894 <aboot_init+0x68>
		index = partition_get_index(frp_ptns[1]);
8f62baec:	e59f0184 	ldr	r0, [pc, #388]	; 8f62bc78 <aboot_init+0x44c>
8f62baf0:	ebff6065 	bl	8f603c8c <partition_get_index>
		if (index == INVALID_PTN)
8f62baf4:	e3700001 	cmn	r0, #1
		index = partition_get_index(frp_ptns[1]);
8f62baf8:	e1a04000 	mov	r4, r0
		if (index == INVALID_PTN)
8f62bafc:	1affff76 	bne	8f62b8dc <aboot_init+0xb0>
			dprintf(CRITICAL, "Neither '%s' nor '%s' partition found\n", frp_ptns[0],frp_ptns[1]);
8f62bb00:	e59f2170 	ldr	r2, [pc, #368]	; 8f62bc78 <aboot_init+0x44c>
8f62bb04:	e3090d34 	movw	r0, #40244	; 0x9d34
8f62bb08:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62bb0c:	e2421008 	sub	r1, r2, #8
8f62bb10:	eb001b97 	bl	8f632974 <_dprintf>
			return -1;
8f62bb14:	eaffff88 	b	8f62b93c <aboot_init+0x110>
	if (keys_get_state(KEY_VOLUMEUP) && keys_get_state(KEY_VOLUMEDOWN))
8f62bb18:	e3000116 	movw	r0, #278	; 0x116
8f62bb1c:	eb001433 	bl	8f630bf0 <keys_get_state>
8f62bb20:	e3500000 	cmp	r0, #0
8f62bb24:	0affffa3 	beq	8f62b9b8 <aboot_init+0x18c>
		dprintf(ALWAYS,"dload mode key sequence detected\n");
8f62bb28:	e3090ddc 	movw	r0, #40412	; 0x9ddc
8f62bb2c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62bb30:	eb001b8f 	bl	8f632974 <_dprintf>
		reboot_device(EMERGENCY_DLOAD);
8f62bb34:	e3a0022f 	mov	r0, #-268435454	; 0xf0000002
8f62bb38:	ebffd1f6 	bl	8f620318 <reboot_device>
		dprintf(CRITICAL,"Failed to reboot into dload mode\n");
8f62bb3c:	e3090e00 	movw	r0, #40448	; 0x9e00
8f62bb40:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62bb44:	eb001b8a 	bl	8f632974 <_dprintf>
		boot_into_fastboot = true;
8f62bb48:	e3a03001 	mov	r3, #1
8f62bb4c:	e5843000 	str	r3, [r4]
	if (!boot_into_fastboot)
8f62bb50:	eaffff9b 	b	8f62b9c4 <aboot_init+0x198>
		boot_slot = partition_find_active_slot();
8f62bb54:	ebff651c 	bl	8f604fcc <partition_find_active_slot>
		if (boot_slot == INVALID)
8f62bb58:	e3700001 	cmn	r0, #1
		boot_slot = partition_find_active_slot();
8f62bb5c:	e1a05000 	mov	r5, r0
		if (boot_slot == INVALID)
8f62bb60:	0a00001e 	beq	8f62bbe0 <aboot_init+0x3b4>
			partition_mark_active_slot(boot_slot);
8f62bb64:	ebff6561 	bl	8f6050f0 <partition_mark_active_slot>
			dprintf(INFO, "Active Slot: (%s)\n", SUFFIX_SLOT(boot_slot));
8f62bb68:	e30132e0 	movw	r3, #4832	; 0x12e0
8f62bb6c:	e3483f71 	movt	r3, #36721	; 0x8f71
8f62bb70:	e3090d88 	movw	r0, #40328	; 0x9d88
8f62bb74:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62bb78:	e30441d4 	movw	r4, #16852	; 0x41d4
8f62bb7c:	e7931105 	ldr	r1, [r3, r5, lsl #2]
8f62bb80:	e3484f73 	movt	r4, #36723	; 0x8f73
8f62bb84:	eb001b7a 	bl	8f632974 <_dprintf>
8f62bb88:	eaffff71 	b	8f62b954 <aboot_init+0x128>
		if (keys_get_state(KEY_HOME) || keys_get_state(KEY_VOLUMEUP))
8f62bb8c:	e3000122 	movw	r0, #290	; 0x122
8f62bb90:	eb001416 	bl	8f630bf0 <keys_get_state>
8f62bb94:	e3500000 	cmp	r0, #0
8f62bb98:	0a000018 	beq	8f62bc00 <aboot_init+0x3d4>
			boot_into_recovery = 1;
8f62bb9c:	e301317c 	movw	r3, #4476	; 0x117c
8f62bba0:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62bba4:	e3a02001 	mov	r2, #1
8f62bba8:	e5832000 	str	r2, [r3]
				lk2nd_dev.dev_mode)
8f62bbac:	e301313c 	movw	r3, #4412	; 0x113c
8f62bbb0:	e3483f74 	movt	r3, #36724	; 0x8f74
		if ((!boot_into_recovery &&
8f62bbb4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
8f62bbb8:	e1550003 	cmp	r5, r3
			boot_into_fastboot = true;
8f62bbbc:	13a03001 	movne	r3, #1
8f62bbc0:	15843000 	strne	r3, [r4]
8f62bbc4:	eaffff7e 	b	8f62b9c4 <aboot_init+0x198>
			recovery_init();
8f62bbc8:	eb000d2c 	bl	8f62f080 <recovery_init>
			boot_linux_from_flash();
8f62bbcc:	ebffefbf 	bl	8f627ad0 <boot_linux_from_flash>
		dprintf(CRITICAL, "ERROR: Could not do normal boot. Reverting "
8f62bbd0:	e3090e80 	movw	r0, #40576	; 0x9e80
8f62bbd4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62bbd8:	eb001b65 	bl	8f632974 <_dprintf>
8f62bbdc:	eaffff85 	b	8f62b9f8 <aboot_init+0x1cc>
			boot_into_fastboot = true;
8f62bbe0:	e30441d4 	movw	r4, #16852	; 0x41d4
8f62bbe4:	e3484f73 	movt	r4, #36723	; 0x8f73
			dprintf(INFO, "Active Slot: (INVALID)\n");
8f62bbe8:	e3090d70 	movw	r0, #40304	; 0x9d70
8f62bbec:	e3480f70 	movt	r0, #36720	; 0x8f70
			boot_into_fastboot = true;
8f62bbf0:	e3a03001 	mov	r3, #1
8f62bbf4:	e5843000 	str	r3, [r4]
			dprintf(INFO, "Active Slot: (INVALID)\n");
8f62bbf8:	eb001b5d 	bl	8f632974 <_dprintf>
8f62bbfc:	eaffff54 	b	8f62b954 <aboot_init+0x128>
		if (keys_get_state(KEY_HOME) || keys_get_state(KEY_VOLUMEUP))
8f62bc00:	e3000115 	movw	r0, #277	; 0x115
8f62bc04:	eb0013f9 	bl	8f630bf0 <keys_get_state>
8f62bc08:	e3500000 	cmp	r0, #0
8f62bc0c:	1affffe2 	bne	8f62bb9c <aboot_init+0x370>
		if ((!boot_into_recovery &&
8f62bc10:	e301317c 	movw	r3, #4476	; 0x117c
8f62bc14:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62bc18:	e5933000 	ldr	r3, [r3]
8f62bc1c:	e3530000 	cmp	r3, #0
8f62bc20:	1affffe1 	bne	8f62bbac <aboot_init+0x380>
			(keys_get_state(KEY_BACK) || keys_get_state(KEY_VOLUMEDOWN))) !=
8f62bc24:	e3000123 	movw	r0, #291	; 0x123
8f62bc28:	eb0013f0 	bl	8f630bf0 <keys_get_state>
		if ((!boot_into_recovery &&
8f62bc2c:	e3500000 	cmp	r0, #0
8f62bc30:	13a05001 	movne	r5, #1
8f62bc34:	1affffdc 	bne	8f62bbac <aboot_init+0x380>
			(keys_get_state(KEY_BACK) || keys_get_state(KEY_VOLUMEDOWN))) !=
8f62bc38:	e3000116 	movw	r0, #278	; 0x116
8f62bc3c:	eb0013eb 	bl	8f630bf0 <keys_get_state>
8f62bc40:	e2505000 	subs	r5, r0, #0
8f62bc44:	13a05001 	movne	r5, #1
8f62bc48:	eaffffd7 	b	8f62bbac <aboot_init+0x380>
				dprintf(ALWAYS,"error in emmc_recovery_init\n");
8f62bc4c:	e3090e60 	movw	r0, #40544	; 0x9e60
8f62bc50:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62bc54:	eb001b46 	bl	8f632974 <_dprintf>
8f62bc58:	eaffff91 	b	8f62baa4 <aboot_init+0x278>
		dprintf(CRITICAL, "Reading MMC failed\n");
8f62bc5c:	e3090d5c 	movw	r0, #40284	; 0x9d5c
8f62bc60:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62bc64:	eb001b42 	bl	8f632974 <_dprintf>
		return -1;
8f62bc68:	eaffff33 	b	8f62b93c <aboot_init+0x110>
}
8f62bc6c:	eb001bd3 	bl	8f632bc0 <__stack_chk_fail>
8f62bc70:	8f74221c 	.word	0x8f74221c
8f62bc74:	8f711af0 	.word	0x8f711af0
8f62bc78:	8f7124cc 	.word	0x8f7124cc

8f62bc7c <get_page_size>:

uint32_t get_page_size()
{
	return page_size;
8f62bc7c:	e3003684 	movw	r3, #1668	; 0x684
8f62bc80:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f62bc84:	e59f2038 	ldr	r2, [pc, #56]	; 8f62bcc4 <get_page_size+0x48>
8f62bc88:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62bc8c:	e24dd00c 	sub	r13, r13, #12
	return page_size;
8f62bc90:	e5930000 	ldr	r0, [r3]
{
8f62bc94:	e5922000 	ldr	r2, [r2]
8f62bc98:	e58d2004 	str	r2, [r13, #4]
8f62bc9c:	e3a02000 	mov	r2, #0
}
8f62bca0:	e59f301c 	ldr	r3, [pc, #28]	; 8f62bcc4 <get_page_size+0x48>
8f62bca4:	e5932000 	ldr	r2, [r3]
8f62bca8:	e59d3004 	ldr	r3, [r13, #4]
8f62bcac:	e0332002 	eors	r2, r3, r2
8f62bcb0:	e3a03000 	mov	r3, #0
8f62bcb4:	1a000001 	bne	8f62bcc0 <get_page_size+0x44>
8f62bcb8:	e28dd00c 	add	r13, r13, #12
8f62bcbc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f62bcc0:	eb001bbe 	bl	8f632bc0 <__stack_chk_fail>
8f62bcc4:	8f74221c 	.word	0x8f74221c

8f62bcc8 <req_complete>:
#define STATE_ERROR	3

static unsigned fastboot_state = STATE_OFFLINE;

static void req_complete(struct udc_request *req, unsigned actual, int status)
{
8f62bcc8:	e59fc054 	ldr	r12, [pc, #84]	; 8f62bd24 <req_complete+0x5c>
	txn_status = status;
8f62bccc:	e30933d4 	movw	r3, #37844	; 0x93d4
8f62bcd0:	e3483f75 	movt	r3, #36725	; 0x8f75
{
8f62bcd4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62bcd8:	e24dd00c 	sub	r13, r13, #12
8f62bcdc:	e59cc000 	ldr	r12, [r12]
8f62bce0:	e58dc004 	str	r12, [r13, #4]
8f62bce4:	e3a0c000 	mov	r12, #0
	txn_status = status;
8f62bce8:	e5832000 	str	r2, [r3]
	req->length = actual;

	event_signal(&txn_done, 0);
8f62bcec:	e59f3030 	ldr	r3, [pc, #48]	; 8f62bd24 <req_complete+0x5c>
	req->length = actual;
8f62bcf0:	e5801004 	str	r1, [r0, #4]
	event_signal(&txn_done, 0);
8f62bcf4:	e5932000 	ldr	r2, [r3]
8f62bcf8:	e59d3004 	ldr	r3, [r13, #4]
8f62bcfc:	e0332002 	eors	r2, r3, r2
8f62bd00:	e3a03000 	mov	r3, #0
8f62bd04:	1a000005 	bne	8f62bd20 <req_complete+0x58>
8f62bd08:	e30100fc 	movw	r0, #4348	; 0x10fc
8f62bd0c:	e3a01000 	mov	r1, #0
8f62bd10:	e3480f74 	movt	r0, #36724	; 0x8f74
}
8f62bd14:	e28dd00c 	add	r13, r13, #12
8f62bd18:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	event_signal(&txn_done, 0);
8f62bd1c:	eaffdba2 	b	8f622bac <event_signal>
8f62bd20:	eb001ba6 	bl	8f632bc0 <__stack_chk_fail>
8f62bd24:	8f74221c 	.word	0x8f74221c

8f62bd28 <hsusb_usb_write>:
	fastboot_state = STATE_ERROR;
	return -1;
}

static int hsusb_usb_write(void *buf, unsigned len)
{
8f62bd28:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	int r;
	uint32_t xfer;
	unsigned char *_buf = buf;
	int count = 0;

	if (fastboot_state == STATE_ERROR)
8f62bd2c:	e301b0ec 	movw	r11, #4332	; 0x10ec
8f62bd30:	e348bf74 	movt	r11, #36724	; 0x8f74
{
8f62bd34:	e59f2114 	ldr	r2, [pc, #276]	; 8f62be50 <hsusb_usb_write+0x128>
8f62bd38:	e24dd00c 	sub	r13, r13, #12
	if (fastboot_state == STATE_ERROR)
8f62bd3c:	e59b3000 	ldr	r3, [r11]
{
8f62bd40:	e5922000 	ldr	r2, [r2]
8f62bd44:	e58d2004 	str	r2, [r13, #4]
8f62bd48:	e3a02000 	mov	r2, #0
	if (fastboot_state == STATE_ERROR)
8f62bd4c:	e3530003 	cmp	r3, #3
8f62bd50:	0a000032 	beq	8f62be20 <hsusb_usb_write+0xf8>
		goto oops;

	while (len > 0) {
		xfer = (len > MAX_USBFS_BULK_SIZE) ? MAX_USBFS_BULK_SIZE : len;
		req->buf = (unsigned char *)PA((addr_t)_buf);
8f62bd54:	e30170f8 	movw	r7, #4344	; 0x10f8
		req->length = xfer;
		req->complete = req_complete;
8f62bd58:	e30bacc8 	movw	r10, #48328	; 0xbcc8
		r = udc_request_queue(in, req);
8f62bd5c:	e30190f0 	movw	r9, #4336	; 0x10f0
		req->buf = (unsigned char *)PA((addr_t)_buf);
8f62bd60:	e3487f74 	movt	r7, #36724	; 0x8f74
		req->complete = req_complete;
8f62bd64:	e348af62 	movt	r10, #36706	; 0x8f62
		r = udc_request_queue(in, req);
8f62bd68:	e3489f74 	movt	r9, #36724	; 0x8f74
8f62bd6c:	e1a05000 	mov	r5, r0
8f62bd70:	e1a04001 	mov	r4, r1
	int count = 0;
8f62bd74:	e3a08000 	mov	r8, #0
8f62bd78:	ea00001a 	b	8f62bde8 <hsusb_usb_write+0xc0>
		xfer = (len > MAX_USBFS_BULK_SIZE) ? MAX_USBFS_BULK_SIZE : len;
8f62bd7c:	e3540902 	cmp	r4, #32768	; 0x8000
		req->buf = (unsigned char *)PA((addr_t)_buf);
8f62bd80:	e1a00005 	mov	r0, r5
		xfer = (len > MAX_USBFS_BULK_SIZE) ? MAX_USBFS_BULK_SIZE : len;
8f62bd84:	31a06004 	movcc	r6, r4
8f62bd88:	23a06902 	movcs	r6, #32768	; 0x8000
		req->buf = (unsigned char *)PA((addr_t)_buf);
8f62bd8c:	ebff5670 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f62bd90:	e5971000 	ldr	r1, [r7]
8f62bd94:	e1a03000 	mov	r3, r0
		r = udc_request_queue(in, req);
8f62bd98:	e5990000 	ldr	r0, [r9]
		req->complete = req_complete;
8f62bd9c:	e8810448 	stm	r1, {r3, r6, r10}
		r = udc_request_queue(in, req);
8f62bda0:	ebff68d0 	bl	8f6060e8 <udc_request_queue>
		if (r < 0) {
8f62bda4:	e3500000 	cmp	r0, #0
8f62bda8:	ba000019 	blt	8f62be14 <hsusb_usb_write+0xec>
			dprintf(INFO, "usb_write() queue failed\n");
			goto oops;
		}
		event_wait(&txn_done);
8f62bdac:	e30100fc 	movw	r0, #4348	; 0x10fc
8f62bdb0:	e3480f74 	movt	r0, #36724	; 0x8f74
8f62bdb4:	ebffdb3d 	bl	8f622ab0 <event_wait>
		if (txn_status < 0) {
8f62bdb8:	e30933d4 	movw	r3, #37844	; 0x93d4
8f62bdbc:	e3483f75 	movt	r3, #36725	; 0x8f75
8f62bdc0:	e5933000 	ldr	r3, [r3]
8f62bdc4:	e3530000 	cmp	r3, #0
8f62bdc8:	ba000018 	blt	8f62be30 <hsusb_usb_write+0x108>
			dprintf(INFO, "usb_write() transaction failed\n");
			goto oops;
		}

		count += req->length;
8f62bdcc:	e5973000 	ldr	r3, [r7]
8f62bdd0:	e5933004 	ldr	r3, [r3, #4]
		_buf += req->length;
		len -= req->length;

		/* short transfer? */
		if (req->length != xfer) break;
8f62bdd4:	e1530006 	cmp	r3, r6
		count += req->length;
8f62bdd8:	e0888003 	add	r8, r8, r3
		_buf += req->length;
8f62bddc:	e0855003 	add	r5, r5, r3
		len -= req->length;
8f62bde0:	e0444003 	sub	r4, r4, r3
		if (req->length != xfer) break;
8f62bde4:	1a000001 	bne	8f62bdf0 <hsusb_usb_write+0xc8>
	while (len > 0) {
8f62bde8:	e3540000 	cmp	r4, #0
8f62bdec:	1affffe2 	bne	8f62bd7c <hsusb_usb_write+0x54>
	return count;

oops:
	fastboot_state = STATE_ERROR;
	return -1;
}
8f62bdf0:	e59f3058 	ldr	r3, [pc, #88]	; 8f62be50 <hsusb_usb_write+0x128>
8f62bdf4:	e5932000 	ldr	r2, [r3]
8f62bdf8:	e59d3004 	ldr	r3, [r13, #4]
8f62bdfc:	e0332002 	eors	r2, r3, r2
8f62be00:	e3a03000 	mov	r3, #0
8f62be04:	1a000010 	bne	8f62be4c <hsusb_usb_write+0x124>
8f62be08:	e1a00008 	mov	r0, r8
8f62be0c:	e28dd00c 	add	r13, r13, #12
8f62be10:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
			dprintf(INFO, "usb_write() queue failed\n");
8f62be14:	e3090f88 	movw	r0, #40840	; 0x9f88
8f62be18:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62be1c:	eb001ad4 	bl	8f632974 <_dprintf>
	fastboot_state = STATE_ERROR;
8f62be20:	e3a03003 	mov	r3, #3
	return -1;
8f62be24:	e3e08000 	mvn	r8, #0
	fastboot_state = STATE_ERROR;
8f62be28:	e58b3000 	str	r3, [r11]
	return -1;
8f62be2c:	eaffffef 	b	8f62bdf0 <hsusb_usb_write+0xc8>
			dprintf(INFO, "usb_write() transaction failed\n");
8f62be30:	e3090fa4 	movw	r0, #40868	; 0x9fa4
8f62be34:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62be38:	eb001acd 	bl	8f632974 <_dprintf>
	return -1;
8f62be3c:	e3e08000 	mvn	r8, #0
	fastboot_state = STATE_ERROR;
8f62be40:	e3a03003 	mov	r3, #3
8f62be44:	e58b3000 	str	r3, [r11]
	return -1;
8f62be48:	eaffffe8 	b	8f62bdf0 <hsusb_usb_write+0xc8>
}
8f62be4c:	eb001b5b 	bl	8f632bc0 <__stack_chk_fail>
8f62be50:	8f74221c 	.word	0x8f74221c

8f62be54 <hsusb_usb_read>:
{
8f62be54:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	if (fastboot_state == STATE_ERROR)
8f62be58:	e301a0ec 	movw	r10, #4332	; 0x10ec
8f62be5c:	e348af74 	movt	r10, #36724	; 0x8f74
{
8f62be60:	e24dd014 	sub	r13, r13, #20
8f62be64:	e59f3118 	ldr	r3, [pc, #280]	; 8f62bf84 <hsusb_usb_read+0x130>
	if (fastboot_state == STATE_ERROR)
8f62be68:	e59a2000 	ldr	r2, [r10]
{
8f62be6c:	e58d0004 	str	r0, [r13, #4]
8f62be70:	e5933000 	ldr	r3, [r3]
8f62be74:	e58d300c 	str	r3, [r13, #12]
8f62be78:	e3a03000 	mov	r3, #0
	if (fastboot_state == STATE_ERROR)
8f62be7c:	e3520003 	cmp	r2, #3
8f62be80:	0a00002e 	beq	8f62bf40 <hsusb_usb_read+0xec>
		req->buf = (unsigned char *)PA((addr_t)buf);
8f62be84:	e30160f8 	movw	r6, #4344	; 0x10f8
		req->complete = req_complete;
8f62be88:	e30b9cc8 	movw	r9, #48328	; 0xbcc8
		r = udc_request_queue(out, req);
8f62be8c:	e30180f4 	movw	r8, #4340	; 0x10f4
		req->buf = (unsigned char *)PA((addr_t)buf);
8f62be90:	e3486f74 	movt	r6, #36724	; 0x8f74
		req->complete = req_complete;
8f62be94:	e3489f62 	movt	r9, #36706	; 0x8f62
		r = udc_request_queue(out, req);
8f62be98:	e3488f74 	movt	r8, #36724	; 0x8f74
8f62be9c:	e1a0b001 	mov	r11, r1
	unsigned char *buf = _buf;
8f62bea0:	e1a04000 	mov	r4, r0
	int count = 0;
8f62bea4:	e3a07000 	mov	r7, #0
8f62bea8:	ea00001a 	b	8f62bf18 <hsusb_usb_read+0xc4>
		xfer = (len > MAX_USBFS_BULK_SIZE) ? MAX_USBFS_BULK_SIZE : len;
8f62beac:	e35b0902 	cmp	r11, #32768	; 0x8000
		req->buf = (unsigned char *)PA((addr_t)buf);
8f62beb0:	e1a00004 	mov	r0, r4
		xfer = (len > MAX_USBFS_BULK_SIZE) ? MAX_USBFS_BULK_SIZE : len;
8f62beb4:	31a0500b 	movcc	r5, r11
8f62beb8:	23a05902 	movcs	r5, #32768	; 0x8000
		req->buf = (unsigned char *)PA((addr_t)buf);
8f62bebc:	ebff5624 	bl	8f601754 <platform_get_virt_to_phys_mapping>
8f62bec0:	e5961000 	ldr	r1, [r6]
8f62bec4:	e1a02000 	mov	r2, r0
		r = udc_request_queue(out, req);
8f62bec8:	e5980000 	ldr	r0, [r8]
		req->complete = req_complete;
8f62becc:	e8810224 	stm	r1, {r2, r5, r9}
		r = udc_request_queue(out, req);
8f62bed0:	ebff6884 	bl	8f6060e8 <udc_request_queue>
		if (r < 0) {
8f62bed4:	e3500000 	cmp	r0, #0
8f62bed8:	ba000015 	blt	8f62bf34 <hsusb_usb_read+0xe0>
		event_wait(&txn_done);
8f62bedc:	e30100fc 	movw	r0, #4348	; 0x10fc
8f62bee0:	e3480f74 	movt	r0, #36724	; 0x8f74
8f62bee4:	ebffdaf1 	bl	8f622ab0 <event_wait>
		if (txn_status < 0) {
8f62bee8:	e30923d4 	movw	r2, #37844	; 0x93d4
8f62beec:	e3482f75 	movt	r2, #36725	; 0x8f75
8f62bef0:	e5922000 	ldr	r2, [r2]
8f62bef4:	e3520000 	cmp	r2, #0
8f62bef8:	ba00001c 	blt	8f62bf70 <hsusb_usb_read+0x11c>
		count += req->length;
8f62befc:	e5962000 	ldr	r2, [r6]
8f62bf00:	e5922004 	ldr	r2, [r2, #4]
		if (req->length != xfer) break;
8f62bf04:	e1520005 	cmp	r2, r5
		count += req->length;
8f62bf08:	e0877002 	add	r7, r7, r2
		buf += req->length;
8f62bf0c:	e0844002 	add	r4, r4, r2
		len -= req->length;
8f62bf10:	e04bb002 	sub	r11, r11, r2
		if (req->length != xfer) break;
8f62bf14:	1a000001 	bne	8f62bf20 <hsusb_usb_read+0xcc>
	while (len > 0) {
8f62bf18:	e35b0000 	cmp	r11, #0
8f62bf1c:	1affffe2 	bne	8f62beac <hsusb_usb_read+0x58>
	arch_invalidate_cache_range((addr_t)_buf, ROUNDUP(count, CACHE_LINE));
8f62bf20:	e287103f 	add	r1, r7, #63	; 0x3f
8f62bf24:	e59d0004 	ldr	r0, [r13, #4]
8f62bf28:	e3c1103f 	bic	r1, r1, #63	; 0x3f
8f62bf2c:	ebffd425 	bl	8f620fc8 <arch_invalidate_cache_range>
	return count;
8f62bf30:	ea000005 	b	8f62bf4c <hsusb_usb_read+0xf8>
			dprintf(INFO, "usb_read() queue failed\n");
8f62bf34:	e3090fc4 	movw	r0, #40900	; 0x9fc4
8f62bf38:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62bf3c:	eb001a8c 	bl	8f632974 <_dprintf>
	return -1;
8f62bf40:	e3e07000 	mvn	r7, #0
	fastboot_state = STATE_ERROR;
8f62bf44:	e3a03003 	mov	r3, #3
8f62bf48:	e58a3000 	str	r3, [r10]
}
8f62bf4c:	e59f3030 	ldr	r3, [pc, #48]	; 8f62bf84 <hsusb_usb_read+0x130>
8f62bf50:	e5932000 	ldr	r2, [r3]
8f62bf54:	e59d300c 	ldr	r3, [r13, #12]
8f62bf58:	e0332002 	eors	r2, r3, r2
8f62bf5c:	e3a03000 	mov	r3, #0
8f62bf60:	1a000006 	bne	8f62bf80 <hsusb_usb_read+0x12c>
8f62bf64:	e1a00007 	mov	r0, r7
8f62bf68:	e28dd014 	add	r13, r13, #20
8f62bf6c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
			dprintf(INFO, "usb_read() transaction failed\n");
8f62bf70:	e3090fe0 	movw	r0, #40928	; 0x9fe0
8f62bf74:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62bf78:	eb001a7d 	bl	8f632974 <_dprintf>
			goto oops;
8f62bf7c:	eaffffef 	b	8f62bf40 <hsusb_usb_read+0xec>
}
8f62bf80:	eb001b0e 	bl	8f632bc0 <__stack_chk_fail>
8f62bf84:	8f74221c 	.word	0x8f74221c

8f62bf88 <usb30_usb_write>:
{
8f62bf88:	e92d4070 	push	{r4, r5, r6, r14}
	ASSERT(buf);
8f62bf8c:	e2505000 	subs	r5, r0, #0
{
8f62bf90:	e59f3188 	ldr	r3, [pc, #392]	; 8f62c120 <usb30_usb_write+0x198>
8f62bf94:	e24dd020 	sub	r13, r13, #32
8f62bf98:	e1a0600e 	mov	r6, r14
8f62bf9c:	e1a04001 	mov	r4, r1
8f62bfa0:	e5933000 	ldr	r3, [r3]
8f62bfa4:	e58d301c 	str	r3, [r13, #28]
8f62bfa8:	e3a03000 	mov	r3, #0
	ASSERT(buf);
8f62bfac:	0a000033 	beq	8f62c080 <usb30_usb_write+0xf8>
	ASSERT(len);
8f62bfb0:	e3540000 	cmp	r4, #0
8f62bfb4:	0a00003d 	beq	8f62c0b0 <usb30_usb_write+0x128>
	if (fastboot_state == STATE_ERROR)
8f62bfb8:	e30160ec 	movw	r6, #4332	; 0x10ec
8f62bfbc:	e3486f74 	movt	r6, #36724	; 0x8f74
8f62bfc0:	e5963000 	ldr	r3, [r6]
8f62bfc4:	e3530003 	cmp	r3, #3
8f62bfc8:	0a000047 	beq	8f62c0ec <usb30_usb_write+0x164>
	dprintf(SPEW, "usb_write(): len = %d str = %s\n", len, (char *) buf);
8f62bfcc:	e1a02005 	mov	r2, r5
8f62bfd0:	e1a01004 	mov	r1, r4
8f62bfd4:	e30a001c 	movw	r0, #40988	; 0xa01c
8f62bfd8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62bfdc:	eb001a64 	bl	8f632974 <_dprintf>
	arch_clean_invalidate_cache_range((addr_t) buf, len);
8f62bfe0:	e1a01004 	mov	r1, r4
8f62bfe4:	e1a00005 	mov	r0, r5
8f62bfe8:	ebffd3ec 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	req.buf      = (void*) PA((addr_t)buf);
8f62bfec:	e1a00005 	mov	r0, r5
8f62bff0:	ebff55d7 	bl	8f601754 <platform_get_virt_to_phys_mapping>
	r = usb30_udc_request_queue(in, &req);
8f62bff4:	e30120f0 	movw	r2, #4336	; 0x10f0
8f62bff8:	e3482f74 	movt	r2, #36724	; 0x8f74
8f62bffc:	e28d100c 	add	r1, r13, #12
	req.complete = req_complete;
8f62c000:	e30b3cc8 	movw	r3, #48328	; 0xbcc8
	req.length   = len;
8f62c004:	e58d4010 	str	r4, [r13, #16]
	req.complete = req_complete;
8f62c008:	e3483f62 	movt	r3, #36706	; 0x8f62
8f62c00c:	e58d3014 	str	r3, [r13, #20]
	req.buf      = (void*) PA((addr_t)buf);
8f62c010:	e58d000c 	str	r0, [r13, #12]
	r = usb30_udc_request_queue(in, &req);
8f62c014:	e5920000 	ldr	r0, [r2]
8f62c018:	ebffce4e 	bl	8f61f958 <usb30_udc_request_queue>
	if (r < 0) {
8f62c01c:	e3500000 	cmp	r0, #0
8f62c020:	ba00002d 	blt	8f62c0dc <usb30_usb_write+0x154>
	event_wait(&txn_done);
8f62c024:	e30100fc 	movw	r0, #4348	; 0x10fc
8f62c028:	e3480f74 	movt	r0, #36724	; 0x8f74
8f62c02c:	ebffda9f 	bl	8f622ab0 <event_wait>
	dprintf(SPEW, "usb_write(): DONE: len = %d req->length = %d str = %s\n",
8f62c030:	e1a03005 	mov	r3, r5
8f62c034:	e1a01004 	mov	r1, r4
8f62c038:	e59d2010 	ldr	r2, [r13, #16]
8f62c03c:	e30a0060 	movw	r0, #41056	; 0xa060
8f62c040:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62c044:	eb001a4a 	bl	8f632974 <_dprintf>
	if (txn_status < 0) {
8f62c048:	e30933d4 	movw	r3, #37844	; 0x93d4
8f62c04c:	e3483f75 	movt	r3, #36725	; 0x8f75
8f62c050:	e5931000 	ldr	r1, [r3]
8f62c054:	e3510000 	cmp	r1, #0
	return req.length;
8f62c058:	a59d0010 	ldrge	r0, [r13, #16]
	if (txn_status < 0) {
8f62c05c:	ba00002a 	blt	8f62c10c <usb30_usb_write+0x184>
}
8f62c060:	e59f30b8 	ldr	r3, [pc, #184]	; 8f62c120 <usb30_usb_write+0x198>
8f62c064:	e5932000 	ldr	r2, [r3]
8f62c068:	e59d301c 	ldr	r3, [r13, #28]
8f62c06c:	e0332002 	eors	r2, r3, r2
8f62c070:	e3a03000 	mov	r3, #0
8f62c074:	1a000028 	bne	8f62c11c <usb30_usb_write+0x194>
8f62c078:	e28dd020 	add	r13, r13, #32
8f62c07c:	e8bd8070 	pop	{r4, r5, r6, r15}
	ASSERT(buf);
8f62c080:	e3041214 	movw	r1, #16916	; 0x4214
8f62c084:	e30a2000 	movw	r2, #40960	; 0xa000
8f62c088:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62c08c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62c090:	e58d1000 	str	r1, [r13]
8f62c094:	e300310a 	movw	r3, #266	; 0x10a
8f62c098:	e3001130 	movw	r1, #304	; 0x130
8f62c09c:	e1a0000e 	mov	r0, r14
8f62c0a0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62c0a4:	eb001a84 	bl	8f632abc <_panic>
	ASSERT(len);
8f62c0a8:	e3540000 	cmp	r4, #0
8f62c0ac:	1affffc1 	bne	8f62bfb8 <usb30_usb_write+0x30>
8f62c0b0:	e30a1018 	movw	r1, #40984	; 0xa018
8f62c0b4:	e30a2000 	movw	r2, #40960	; 0xa000
8f62c0b8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62c0bc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62c0c0:	e58d1000 	str	r1, [r13]
8f62c0c4:	e300310b 	movw	r3, #267	; 0x10b
8f62c0c8:	e1a00006 	mov	r0, r6
8f62c0cc:	e3001130 	movw	r1, #304	; 0x130
8f62c0d0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62c0d4:	eb001a78 	bl	8f632abc <_panic>
8f62c0d8:	eaffffb6 	b	8f62bfb8 <usb30_usb_write+0x30>
		dprintf(CRITICAL, "usb_write() queue failed. r = %d\n", r);
8f62c0dc:	e1a01000 	mov	r1, r0
8f62c0e0:	e30a003c 	movw	r0, #41020	; 0xa03c
8f62c0e4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62c0e8:	eb001a21 	bl	8f632974 <_dprintf>
	dprintf(CRITICAL, "usb_write(): DONE: ERROR: len = %d\n", len);
8f62c0ec:	e1a01004 	mov	r1, r4
8f62c0f0:	e30a00cc 	movw	r0, #41164	; 0xa0cc
8f62c0f4:	e3480f70 	movt	r0, #36720	; 0x8f70
	fastboot_state = STATE_ERROR;
8f62c0f8:	e3a03003 	mov	r3, #3
8f62c0fc:	e5863000 	str	r3, [r6]
	dprintf(CRITICAL, "usb_write(): DONE: ERROR: len = %d\n", len);
8f62c100:	eb001a1b 	bl	8f632974 <_dprintf>
	return -1;
8f62c104:	e3e00000 	mvn	r0, #0
8f62c108:	eaffffd4 	b	8f62c060 <usb30_usb_write+0xd8>
		dprintf(CRITICAL, "usb_write() transaction failed. txn_status = %d\n",
8f62c10c:	e30a0098 	movw	r0, #41112	; 0xa098
8f62c110:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62c114:	eb001a16 	bl	8f632974 <_dprintf>
		goto oops;
8f62c118:	eafffff3 	b	8f62c0ec <usb30_usb_write+0x164>
}
8f62c11c:	eb001aa7 	bl	8f632bc0 <__stack_chk_fail>
8f62c120:	8f74221c 	.word	0x8f74221c

8f62c124 <usb30_usb_read>:
{
8f62c124:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f62c128:	e24dd02c 	sub	r13, r13, #44	; 0x2c
	ASSERT(buf);
8f62c12c:	e2503000 	subs	r3, r0, #0
8f62c130:	e1a0400e 	mov	r4, r14
8f62c134:	e58d3008 	str	r3, [r13, #8]
{
8f62c138:	e1a08001 	mov	r8, r1
8f62c13c:	e59f31d4 	ldr	r3, [pc, #468]	; 8f62c318 <usb30_usb_read+0x1f4>
8f62c140:	e5933000 	ldr	r3, [r3]
8f62c144:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f62c148:	e3a03000 	mov	r3, #0
	ASSERT(buf);
8f62c14c:	0a000063 	beq	8f62c2e0 <usb30_usb_read+0x1bc>
	ASSERT(len);
8f62c150:	e3580000 	cmp	r8, #0
8f62c154:	0a000056 	beq	8f62c2b4 <usb30_usb_read+0x190>
	if (fastboot_state == STATE_ERROR)
8f62c158:	e30130ec 	movw	r3, #4332	; 0x10ec
8f62c15c:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62c160:	e58d300c 	str	r3, [r13, #12]
8f62c164:	e5933000 	ldr	r3, [r3]
8f62c168:	e3530003 	cmp	r3, #3
8f62c16c:	0a000066 	beq	8f62c30c <usb30_usb_read+0x1e8>
	dprintf(SPEW, "usb_read(): len = %d\n", len);
8f62c170:	e1a01008 	mov	r1, r8
8f62c174:	e30a00f0 	movw	r0, #41200	; 0xa0f0
8f62c178:	e3480f70 	movt	r0, #36720	; 0x8f70
		req.complete = req_complete;
8f62c17c:	e30bacc8 	movw	r10, #48328	; 0xbcc8
	dprintf(SPEW, "usb_read(): len = %d\n", len);
8f62c180:	eb0019fb 	bl	8f632974 <_dprintf>
		r = usb30_udc_request_queue(out, &req);
8f62c184:	e30190f4 	movw	r9, #4340	; 0x10f4
		event_wait(&txn_done);
8f62c188:	e301b0fc 	movw	r11, #4348	; 0x10fc
	while (len > 0)
8f62c18c:	e59d5008 	ldr	r5, [r13, #8]
		req.complete = req_complete;
8f62c190:	e348af62 	movt	r10, #36706	; 0x8f62
		r = usb30_udc_request_queue(out, &req);
8f62c194:	e3489f74 	movt	r9, #36724	; 0x8f74
		event_wait(&txn_done);
8f62c198:	e348bf74 	movt	r11, #36724	; 0x8f74
	while (len > 0)
8f62c19c:	e1a04008 	mov	r4, r8
	int count = 0;
8f62c1a0:	e3a07000 	mov	r7, #0
	while (len > 0)
8f62c1a4:	ea000022 	b	8f62c234 <usb30_usb_read+0x110>
		xfer = (len > MAX_USBSS_BULK_SIZE) ? MAX_USBSS_BULK_SIZE : len;
8f62c1a8:	e3540401 	cmp	r4, #16777216	; 0x1000000
		req.buf      = (void*) PA((addr_t)buf);
8f62c1ac:	e1a00005 	mov	r0, r5
		xfer = (len > MAX_USBSS_BULK_SIZE) ? MAX_USBSS_BULK_SIZE : len;
8f62c1b0:	31a06004 	movcc	r6, r4
8f62c1b4:	23a06401 	movcs	r6, #16777216	; 0x1000000
		req.buf      = (void*) PA((addr_t)buf);
8f62c1b8:	ebff5565 	bl	8f601754 <platform_get_virt_to_phys_mapping>
		r = usb30_udc_request_queue(out, &req);
8f62c1bc:	e28d1014 	add	r1, r13, #20
		req.length   = xfer;
8f62c1c0:	e58d6018 	str	r6, [r13, #24]
		req.complete = req_complete;
8f62c1c4:	e58da01c 	str	r10, [r13, #28]
		req.buf      = (void*) PA((addr_t)buf);
8f62c1c8:	e1a03000 	mov	r3, r0
		r = usb30_udc_request_queue(out, &req);
8f62c1cc:	e5990000 	ldr	r0, [r9]
		req.buf      = (void*) PA((addr_t)buf);
8f62c1d0:	e58d3014 	str	r3, [r13, #20]
		r = usb30_udc_request_queue(out, &req);
8f62c1d4:	ebffcddf 	bl	8f61f958 <usb30_udc_request_queue>
		if (r < 0)
8f62c1d8:	e3500000 	cmp	r0, #0
8f62c1dc:	ba000023 	blt	8f62c270 <usb30_usb_read+0x14c>
		event_wait(&txn_done);
8f62c1e0:	e1a0000b 	mov	r0, r11
8f62c1e4:	ebffda31 	bl	8f622ab0 <event_wait>
		if (txn_status < 0)
8f62c1e8:	e30933d4 	movw	r3, #37844	; 0x93d4
8f62c1ec:	e3483f75 	movt	r3, #36725	; 0x8f75
8f62c1f0:	e5931000 	ldr	r1, [r3]
8f62c1f4:	e3510000 	cmp	r1, #0
8f62c1f8:	ba000029 	blt	8f62c2a4 <usb30_usb_read+0x180>
		count += req.length;
8f62c1fc:	e59d1018 	ldr	r1, [r13, #24]
		dprintf(SPEW, "usb_read(): DONE. req.length = %d\n\n", req.length);
8f62c200:	e30a015c 	movw	r0, #41308	; 0xa15c
8f62c204:	e3480f70 	movt	r0, #36720	; 0x8f70
		count += req.length;
8f62c208:	e0877001 	add	r7, r7, r1
		buf += req.length;
8f62c20c:	e0855001 	add	r5, r5, r1
		len -= req.length;
8f62c210:	e0444001 	sub	r4, r4, r1
		dprintf(SPEW, "usb_read(): DONE. req.length = %d\n\n", req.length);
8f62c214:	eb0019d6 	bl	8f632974 <_dprintf>
		if (req.length != xfer && trans_len == MAX_RSP_SIZE) break;
8f62c218:	e59d3018 	ldr	r3, [r13, #24]
8f62c21c:	e0536006 	subs	r6, r3, r6
8f62c220:	13a06001 	movne	r6, #1
8f62c224:	e3580040 	cmp	r8, #64	; 0x40
8f62c228:	13a06000 	movne	r6, #0
8f62c22c:	e3560000 	cmp	r6, #0
8f62c230:	1a000001 	bne	8f62c23c <usb30_usb_read+0x118>
	while (len > 0)
8f62c234:	e3540000 	cmp	r4, #0
8f62c238:	1affffda 	bne	8f62c1a8 <usb30_usb_read+0x84>
	arch_invalidate_cache_range((addr_t) _buf, ROUNDUP(count, CACHE_LINE));
8f62c23c:	e287103f 	add	r1, r7, #63	; 0x3f
8f62c240:	e59d0008 	ldr	r0, [r13, #8]
8f62c244:	e3c1103f 	bic	r1, r1, #63	; 0x3f
8f62c248:	ebffd35e 	bl	8f620fc8 <arch_invalidate_cache_range>
}
8f62c24c:	e59f30c4 	ldr	r3, [pc, #196]	; 8f62c318 <usb30_usb_read+0x1f4>
8f62c250:	e5932000 	ldr	r2, [r3]
8f62c254:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f62c258:	e0332002 	eors	r2, r3, r2
8f62c25c:	e3a03000 	mov	r3, #0
8f62c260:	1a00002b 	bne	8f62c314 <usb30_usb_read+0x1f0>
8f62c264:	e1a00007 	mov	r0, r7
8f62c268:	e28dd02c 	add	r13, r13, #44	; 0x2c
8f62c26c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
			dprintf(CRITICAL, "usb_read() queue failed. r = %d\n", r);
8f62c270:	e1a01000 	mov	r1, r0
8f62c274:	e30a0108 	movw	r0, #41224	; 0xa108
8f62c278:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62c27c:	eb0019bc 	bl	8f632974 <_dprintf>
	fastboot_state = STATE_ERROR;
8f62c280:	e59d200c 	ldr	r2, [r13, #12]
	dprintf(CRITICAL, "usb_read(): DONE: ERROR: len = %d\n", len);
8f62c284:	e1a01004 	mov	r1, r4
8f62c288:	e30a0180 	movw	r0, #41344	; 0xa180
8f62c28c:	e3480f70 	movt	r0, #36720	; 0x8f70
	fastboot_state = STATE_ERROR;
8f62c290:	e3a03003 	mov	r3, #3
	return -1;
8f62c294:	e3e07000 	mvn	r7, #0
	fastboot_state = STATE_ERROR;
8f62c298:	e5823000 	str	r3, [r2]
	dprintf(CRITICAL, "usb_read(): DONE: ERROR: len = %d\n", len);
8f62c29c:	eb0019b4 	bl	8f632974 <_dprintf>
	return -1;
8f62c2a0:	eaffffe9 	b	8f62c24c <usb30_usb_read+0x128>
			dprintf(CRITICAL, "usb_read() transaction failed. txn_status = %d\n",
8f62c2a4:	e30a012c 	movw	r0, #41260	; 0xa12c
8f62c2a8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62c2ac:	eb0019b0 	bl	8f632974 <_dprintf>
			goto oops;
8f62c2b0:	eafffff2 	b	8f62c280 <usb30_usb_read+0x15c>
	ASSERT(len);
8f62c2b4:	e30a1018 	movw	r1, #40984	; 0xa018
8f62c2b8:	e30a2000 	movw	r2, #40960	; 0xa000
8f62c2bc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62c2c0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62c2c4:	e58d1000 	str	r1, [r13]
8f62c2c8:	e3a030c8 	mov	r3, #200	; 0xc8
8f62c2cc:	e1a00004 	mov	r0, r4
8f62c2d0:	e3001130 	movw	r1, #304	; 0x130
8f62c2d4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62c2d8:	eb0019f7 	bl	8f632abc <_panic>
8f62c2dc:	eaffff9d 	b	8f62c158 <usb30_usb_read+0x34>
	ASSERT(buf);
8f62c2e0:	e3041214 	movw	r1, #16916	; 0x4214
8f62c2e4:	e30a2000 	movw	r2, #40960	; 0xa000
8f62c2e8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62c2ec:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62c2f0:	e58d1000 	str	r1, [r13]
8f62c2f4:	e3a030c7 	mov	r3, #199	; 0xc7
8f62c2f8:	e3001130 	movw	r1, #304	; 0x130
8f62c2fc:	e1a0000e 	mov	r0, r14
8f62c300:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62c304:	eb0019ec 	bl	8f632abc <_panic>
8f62c308:	eaffff90 	b	8f62c150 <usb30_usb_read+0x2c>
8f62c30c:	e1a04008 	mov	r4, r8
8f62c310:	eaffffda 	b	8f62c280 <usb30_usb_read+0x15c>
}
8f62c314:	eb001a29 	bl	8f632bc0 <__stack_chk_fail>
8f62c318:	8f74221c 	.word	0x8f74221c

8f62c31c <fastboot_notify>:
	}
	return 0;
}

static void fastboot_notify(struct udc_gadget *gadget, unsigned event)
{
8f62c31c:	e59f3068 	ldr	r3, [pc, #104]	; 8f62c38c <fastboot_notify+0x70>
	if (event == UDC_EVENT_ONLINE) {
8f62c320:	e3510001 	cmp	r1, #1
{
8f62c324:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62c328:	e24dd00c 	sub	r13, r13, #12
8f62c32c:	e5933000 	ldr	r3, [r3]
8f62c330:	e58d3004 	str	r3, [r13, #4]
8f62c334:	e3a03000 	mov	r3, #0
		event_signal(&usb_online, 0);
8f62c338:	e59f304c 	ldr	r3, [pc, #76]	; 8f62c38c <fastboot_notify+0x70>
	if (event == UDC_EVENT_ONLINE) {
8f62c33c:	0a000006 	beq	8f62c35c <fastboot_notify+0x40>
	}
}
8f62c340:	e5932000 	ldr	r2, [r3]
8f62c344:	e59d3004 	ldr	r3, [r13, #4]
8f62c348:	e0332002 	eors	r2, r3, r2
8f62c34c:	e3a03000 	mov	r3, #0
8f62c350:	1a00000c 	bne	8f62c388 <fastboot_notify+0x6c>
8f62c354:	e28dd00c 	add	r13, r13, #12
8f62c358:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		event_signal(&usb_online, 0);
8f62c35c:	e5932000 	ldr	r2, [r3]
8f62c360:	e59d3004 	ldr	r3, [r13, #4]
8f62c364:	e0332002 	eors	r2, r3, r2
8f62c368:	e3a03000 	mov	r3, #0
8f62c36c:	1a000005 	bne	8f62c388 <fastboot_notify+0x6c>
8f62c370:	e301011c 	movw	r0, #4380	; 0x111c
8f62c374:	e3a01000 	mov	r1, #0
8f62c378:	e3480f74 	movt	r0, #36724	; 0x8f74
}
8f62c37c:	e28dd00c 	add	r13, r13, #12
8f62c380:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		event_signal(&usb_online, 0);
8f62c384:	eaffda08 	b	8f622bac <event_signal>
}
8f62c388:	eb001a0c 	bl	8f632bc0 <__stack_chk_fail>
8f62c38c:	8f74221c 	.word	0x8f74221c

8f62c390 <fastboot_register>:
{
8f62c390:	e59f3074 	ldr	r3, [pc, #116]	; 8f62c40c <fastboot_register+0x7c>
8f62c394:	e92d4070 	push	{r4, r5, r6, r14}
8f62c398:	e1a05000 	mov	r5, r0
8f62c39c:	e24dd008 	sub	r13, r13, #8
	cmd = malloc(sizeof(*cmd));
8f62c3a0:	e3a00010 	mov	r0, #16
{
8f62c3a4:	e5933000 	ldr	r3, [r3]
8f62c3a8:	e58d3004 	str	r3, [r13, #4]
8f62c3ac:	e3a03000 	mov	r3, #0
8f62c3b0:	e1a06001 	mov	r6, r1
	cmd = malloc(sizeof(*cmd));
8f62c3b4:	eb001f10 	bl	8f633ffc <malloc>
	if (cmd) {
8f62c3b8:	e2504000 	subs	r4, r0, #0
8f62c3bc:	0a000009 	beq	8f62c3e8 <fastboot_register+0x58>
		cmd->prefix_len = strlen(prefix);
8f62c3c0:	e1a00005 	mov	r0, r5
		cmd->prefix = prefix;
8f62c3c4:	e5845004 	str	r5, [r4, #4]
		cmd->prefix_len = strlen(prefix);
8f62c3c8:	eb00210e 	bl	8f634808 <strlen>
		cmd->next = cmdlist;
8f62c3cc:	e30130d4 	movw	r3, #4308	; 0x10d4
8f62c3d0:	e3483f74 	movt	r3, #36724	; 0x8f74
		cmd->handle = handle;
8f62c3d4:	e584600c 	str	r6, [r4, #12]
		cmd->next = cmdlist;
8f62c3d8:	e5932000 	ldr	r2, [r3]
		cmdlist = cmd;
8f62c3dc:	e5834000 	str	r4, [r3]
		cmd->next = cmdlist;
8f62c3e0:	e5842000 	str	r2, [r4]
		cmd->prefix_len = strlen(prefix);
8f62c3e4:	e5840008 	str	r0, [r4, #8]
}
8f62c3e8:	e59f301c 	ldr	r3, [pc, #28]	; 8f62c40c <fastboot_register+0x7c>
8f62c3ec:	e5932000 	ldr	r2, [r3]
8f62c3f0:	e59d3004 	ldr	r3, [r13, #4]
8f62c3f4:	e0332002 	eors	r2, r3, r2
8f62c3f8:	e3a03000 	mov	r3, #0
8f62c3fc:	1a000001 	bne	8f62c408 <fastboot_register+0x78>
8f62c400:	e28dd008 	add	r13, r13, #8
8f62c404:	e8bd8070 	pop	{r4, r5, r6, r15}
8f62c408:	eb0019ec 	bl	8f632bc0 <__stack_chk_fail>
8f62c40c:	8f74221c 	.word	0x8f74221c

8f62c410 <fastboot_publish>:
{
8f62c410:	e59f3068 	ldr	r3, [pc, #104]	; 8f62c480 <fastboot_publish+0x70>
8f62c414:	e92d4030 	push	{r4, r5, r14}
8f62c418:	e1a05000 	mov	r5, r0
8f62c41c:	e24dd00c 	sub	r13, r13, #12
	var = malloc(sizeof(*var));
8f62c420:	e3a0000c 	mov	r0, #12
{
8f62c424:	e5933000 	ldr	r3, [r3]
8f62c428:	e58d3004 	str	r3, [r13, #4]
8f62c42c:	e3a03000 	mov	r3, #0
8f62c430:	e1a04001 	mov	r4, r1
	var = malloc(sizeof(*var));
8f62c434:	eb001ef0 	bl	8f633ffc <malloc>
	if (var) {
8f62c438:	e2503000 	subs	r3, r0, #0
8f62c43c:	0a000006 	beq	8f62c45c <fastboot_publish+0x4c>
		var->next = varlist;
8f62c440:	e3012138 	movw	r2, #4408	; 0x1138
8f62c444:	e3482f74 	movt	r2, #36724	; 0x8f74
		var->name = name;
8f62c448:	e5835004 	str	r5, [r3, #4]
		var->next = varlist;
8f62c44c:	e5921000 	ldr	r1, [r2]
		var->value = value;
8f62c450:	e5834008 	str	r4, [r3, #8]
		varlist = var;
8f62c454:	e5823000 	str	r3, [r2]
		var->next = varlist;
8f62c458:	e5831000 	str	r1, [r3]
}
8f62c45c:	e59f301c 	ldr	r3, [pc, #28]	; 8f62c480 <fastboot_publish+0x70>
8f62c460:	e5932000 	ldr	r2, [r3]
8f62c464:	e59d3004 	ldr	r3, [r13, #4]
8f62c468:	e0332002 	eors	r2, r3, r2
8f62c46c:	e3a03000 	mov	r3, #0
8f62c470:	1a000001 	bne	8f62c47c <fastboot_publish+0x6c>
8f62c474:	e28dd00c 	add	r13, r13, #12
8f62c478:	e8bd8030 	pop	{r4, r5, r15}
8f62c47c:	eb0019cf 	bl	8f632bc0 <__stack_chk_fail>
8f62c480:	8f74221c 	.word	0x8f74221c

8f62c484 <fastboot_ack>:
{
8f62c484:	e92d4030 	push	{r4, r5, r14}
	if (fastboot_state != STATE_COMMAND)
8f62c488:	e30150ec 	movw	r5, #4332	; 0x10ec
8f62c48c:	e3485f74 	movt	r5, #36724	; 0x8f74
{
8f62c490:	e24dd0cc 	sub	r13, r13, #204	; 0xcc
	if (fastboot_state != STATE_COMMAND)
8f62c494:	e5952000 	ldr	r2, [r5]
8f62c498:	e3520001 	cmp	r2, #1
{
8f62c49c:	e59f2090 	ldr	r2, [pc, #144]	; 8f62c534 <fastboot_ack+0xb0>
8f62c4a0:	e5922000 	ldr	r2, [r2]
8f62c4a4:	e58d20c4 	str	r2, [r13, #196]	; 0xc4
8f62c4a8:	e3a02000 	mov	r2, #0
	if (fastboot_state != STATE_COMMAND)
8f62c4ac:	1a000017 	bne	8f62c510 <fastboot_ack+0x8c>
	if (reason == 0)
8f62c4b0:	e28d4047 	add	r4, r13, #71	; 0x47
		reason = "";
8f62c4b4:	e3510000 	cmp	r1, #0
8f62c4b8:	e3c4403f 	bic	r4, r4, #63	; 0x3f
8f62c4bc:	e3072138 	movw	r2, #28984	; 0x7138
8f62c4c0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62c4c4:	e1a0c001 	mov	r12, r1
8f62c4c8:	e1a03000 	mov	r3, r0
	snprintf((char *)response, MAX_RSP_SIZE, "%s%s", code, reason);
8f62c4cc:	e3a01040 	mov	r1, #64	; 0x40
		reason = "";
8f62c4d0:	01a0c002 	moveq	r12, r2
	snprintf((char *)response, MAX_RSP_SIZE, "%s%s", code, reason);
8f62c4d4:	e1a00004 	mov	r0, r4
8f62c4d8:	e58dc000 	str	r12, [r13]
8f62c4dc:	e30a21a4 	movw	r2, #41380	; 0xa1a4
8f62c4e0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62c4e4:	eb001e95 	bl	8f633f40 <snprintf>
	usb_if.usb_write(response, strlen((const char *)response));
8f62c4e8:	e30933d8 	movw	r3, #37848	; 0x93d8
8f62c4ec:	e3483f75 	movt	r3, #36725	; 0x8f75
8f62c4f0:	e1a00004 	mov	r0, r4
	fastboot_state = STATE_COMPLETE;
8f62c4f4:	e3a02002 	mov	r2, #2
8f62c4f8:	e5852000 	str	r2, [r5]
	usb_if.usb_write(response, strlen((const char *)response));
8f62c4fc:	e5935024 	ldr	r5, [r3, #36]	; 0x24
8f62c500:	eb0020c0 	bl	8f634808 <strlen>
8f62c504:	e1a01000 	mov	r1, r0
8f62c508:	e1a00004 	mov	r0, r4
8f62c50c:	e12fff35 	blx	r5
}
8f62c510:	e59f301c 	ldr	r3, [pc, #28]	; 8f62c534 <fastboot_ack+0xb0>
8f62c514:	e5932000 	ldr	r2, [r3]
8f62c518:	e59d30c4 	ldr	r3, [r13, #196]	; 0xc4
8f62c51c:	e0332002 	eors	r2, r3, r2
8f62c520:	e3a03000 	mov	r3, #0
8f62c524:	1a000001 	bne	8f62c530 <fastboot_ack+0xac>
8f62c528:	e28dd0cc 	add	r13, r13, #204	; 0xcc
8f62c52c:	e8bd8030 	pop	{r4, r5, r15}
8f62c530:	eb0019a2 	bl	8f632bc0 <__stack_chk_fail>
8f62c534:	8f74221c 	.word	0x8f74221c

8f62c538 <cmd_upload>:
{
8f62c538:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
	if (!sz) {
8f62c53c:	e2526000 	subs	r6, r2, #0
{
8f62c540:	e59f3140 	ldr	r3, [pc, #320]	; 8f62c688 <cmd_upload+0x150>
8f62c544:	e24dd0c0 	sub	r13, r13, #192	; 0xc0
8f62c548:	e5933000 	ldr	r3, [r3]
8f62c54c:	e58d30bc 	str	r3, [r13, #188]	; 0xbc
8f62c550:	e3a03000 	mov	r3, #0
	if (!sz) {
8f62c554:	0a000026 	beq	8f62c5f4 <cmd_upload+0xbc>
	snprintf(response, MAX_RSP_SIZE, "DATA%08x", sz);
8f62c558:	e28d403f 	add	r4, r13, #63	; 0x3f
8f62c55c:	e1a03006 	mov	r3, r6
8f62c560:	e3c4403f 	bic	r4, r4, #63	; 0x3f
8f62c564:	e1a07001 	mov	r7, r1
8f62c568:	e30a21c4 	movw	r2, #41412	; 0xa1c4
8f62c56c:	e3a01040 	mov	r1, #64	; 0x40
8f62c570:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62c574:	e1a00004 	mov	r0, r4
8f62c578:	eb001e70 	bl	8f633f40 <snprintf>
	if (usb_if.usb_write(response, strlen(response)) < 0)
8f62c57c:	e1a00004 	mov	r0, r4
8f62c580:	eb0020a0 	bl	8f634808 <strlen>
8f62c584:	e30953d8 	movw	r5, #37848	; 0x93d8
8f62c588:	e3485f75 	movt	r5, #36725	; 0x8f75
8f62c58c:	e5958024 	ldr	r8, [r5, #36]	; 0x24
8f62c590:	e1a01000 	mov	r1, r0
8f62c594:	e1a00004 	mov	r0, r4
8f62c598:	e12fff38 	blx	r8
8f62c59c:	e3500000 	cmp	r0, #0
8f62c5a0:	ba00000b 	blt	8f62c5d4 <cmd_upload+0x9c>
	r = usb_if.usb_write(data, sz);
8f62c5a4:	e5953024 	ldr	r3, [r5, #36]	; 0x24
8f62c5a8:	e1a01006 	mov	r1, r6
8f62c5ac:	e1a00007 	mov	r0, r7
8f62c5b0:	e12fff33 	blx	r3
	if ((r < 0) || ((unsigned) r != sz)) {
8f62c5b4:	e0503006 	subs	r3, r0, r6
8f62c5b8:	13a03001 	movne	r3, #1
8f62c5bc:	e1933fa0 	orrs	r3, r3, r0, lsr #31
8f62c5c0:	0a00001d 	beq	8f62c63c <cmd_upload+0x104>
		fastboot_state = STATE_ERROR;
8f62c5c4:	e30130ec 	movw	r3, #4332	; 0x10ec
8f62c5c8:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62c5cc:	e3a02003 	mov	r2, #3
8f62c5d0:	e5832000 	str	r2, [r3]
}
8f62c5d4:	e59f30ac 	ldr	r3, [pc, #172]	; 8f62c688 <cmd_upload+0x150>
8f62c5d8:	e5932000 	ldr	r2, [r3]
8f62c5dc:	e59d30bc 	ldr	r3, [r13, #188]	; 0xbc
8f62c5e0:	e0332002 	eors	r2, r3, r2
8f62c5e4:	e3a03000 	mov	r3, #0
8f62c5e8:	1a000025 	bne	8f62c684 <cmd_upload+0x14c>
8f62c5ec:	e28dd0c0 	add	r13, r13, #192	; 0xc0
8f62c5f0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
	if (fastboot_state != STATE_COMMAND) {
8f62c5f4:	e30130ec 	movw	r3, #4332	; 0x10ec
8f62c5f8:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62c5fc:	e5933000 	ldr	r3, [r3]
8f62c600:	e3530001 	cmp	r3, #1
		dprintf(CRITICAL, "%s\n", reason);
8f62c604:	e59f307c 	ldr	r3, [pc, #124]	; 8f62c688 <cmd_upload+0x150>
	if (fastboot_state != STATE_COMMAND) {
8f62c608:	0a000011 	beq	8f62c654 <cmd_upload+0x11c>
		dprintf(CRITICAL, "%s\n", reason);
8f62c60c:	e5932000 	ldr	r2, [r3]
8f62c610:	e59d30bc 	ldr	r3, [r13, #188]	; 0xbc
8f62c614:	e0332002 	eors	r2, r3, r2
8f62c618:	e3a03000 	mov	r3, #0
8f62c61c:	1a000018 	bne	8f62c684 <cmd_upload+0x14c>
8f62c620:	e30a11ac 	movw	r1, #41388	; 0xa1ac
8f62c624:	e30306e0 	movw	r0, #14048	; 0x36e0
8f62c628:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62c62c:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f62c630:	e28dd0c0 	add	r13, r13, #192	; 0xc0
8f62c634:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, r14}
		dprintf(CRITICAL, "%s\n", reason);
8f62c638:	ea0018cd 	b	8f632974 <_dprintf>
	fastboot_ack("OKAY", info);
8f62c63c:	e3071138 	movw	r1, #28984	; 0x7138
8f62c640:	e30a01d0 	movw	r0, #41424	; 0xa1d0
8f62c644:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62c648:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62c64c:	ebffff8c 	bl	8f62c484 <fastboot_ack>
8f62c650:	eaffffdf 	b	8f62c5d4 <cmd_upload+0x9c>
	fastboot_ack("FAIL", reason);
8f62c654:	e5932000 	ldr	r2, [r3]
8f62c658:	e59d30bc 	ldr	r3, [r13, #188]	; 0xbc
8f62c65c:	e0332002 	eors	r2, r3, r2
8f62c660:	e3a03000 	mov	r3, #0
8f62c664:	1a000006 	bne	8f62c684 <cmd_upload+0x14c>
8f62c668:	e30a11ac 	movw	r1, #41388	; 0xa1ac
8f62c66c:	e30a01bc 	movw	r0, #41404	; 0xa1bc
8f62c670:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62c674:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f62c678:	e28dd0c0 	add	r13, r13, #192	; 0xc0
8f62c67c:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, r14}
	fastboot_ack("FAIL", reason);
8f62c680:	eaffff7f 	b	8f62c484 <fastboot_ack>
}
8f62c684:	eb00194d 	bl	8f632bc0 <__stack_chk_fail>
8f62c688:	8f74221c 	.word	0x8f74221c

8f62c68c <cmd_download>:
{
8f62c68c:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f62c690:	e24dd0c0 	sub	r13, r13, #192	; 0xc0
    while(*x) {
8f62c694:	e5d02000 	ldrb	r2, [r0]
{
8f62c698:	e28d503f 	add	r5, r13, #63	; 0x3f
8f62c69c:	e59f31e0 	ldr	r3, [pc, #480]	; 8f62c884 <cmd_download+0x1f8>
8f62c6a0:	e3c5503f 	bic	r5, r5, #63	; 0x3f
    while(*x) {
8f62c6a4:	e3520000 	cmp	r2, #0
{
8f62c6a8:	e5933000 	ldr	r3, [r3]
8f62c6ac:	e58d30bc 	str	r3, [r13, #188]	; 0xbc
8f62c6b0:	e3a03000 	mov	r3, #0
    while(*x) {
8f62c6b4:	0a00006c 	beq	8f62c86c <cmd_download+0x1e0>
    unsigned n = 0;
8f62c6b8:	e3a04000 	mov	r4, #0
        switch(*x) {
8f62c6bc:	e3520046 	cmp	r2, #70	; 0x46
8f62c6c0:	8a00003c 	bhi	8f62c7b8 <cmd_download+0x12c>
8f62c6c4:	e3520040 	cmp	r2, #64	; 0x40
8f62c6c8:	8a000040 	bhi	8f62c7d0 <cmd_download+0x144>
8f62c6cc:	e2422030 	sub	r2, r2, #48	; 0x30
8f62c6d0:	e6ef3072 	uxtb	r3, r2
8f62c6d4:	e3530009 	cmp	r3, #9
8f62c6d8:	8a000003 	bhi	8f62c6ec <cmd_download+0x60>
            n = (n << 4) | (*x - 'A' + 10);
8f62c6dc:	e1824204 	orr	r4, r2, r4, lsl #4
    while(*x) {
8f62c6e0:	e5f02001 	ldrb	r2, [r0, #1]!
8f62c6e4:	e3520000 	cmp	r2, #0
8f62c6e8:	1afffff3 	bne	8f62c6bc <cmd_download+0x30>
	if (len > download_max) {
8f62c6ec:	e30130dc 	movw	r3, #4316	; 0x10dc
8f62c6f0:	e3483f74 	movt	r3, #36724	; 0x8f74
	download_size = 0;
8f62c6f4:	e30160e0 	movw	r6, #4320	; 0x10e0
8f62c6f8:	e3486f74 	movt	r6, #36724	; 0x8f74
	if (len > download_max) {
8f62c6fc:	e5933000 	ldr	r3, [r3]
	download_size = 0;
8f62c700:	e3a02000 	mov	r2, #0
8f62c704:	e5862000 	str	r2, [r6]
	if (len > download_max) {
8f62c708:	e1530004 	cmp	r3, r4
8f62c70c:	3a000031 	bcc	8f62c7d8 <cmd_download+0x14c>
	snprintf((char *)response, MAX_RSP_SIZE, "DATA%08x", len);
8f62c710:	e1a03004 	mov	r3, r4
8f62c714:	e3a01040 	mov	r1, #64	; 0x40
8f62c718:	e30a21c4 	movw	r2, #41412	; 0xa1c4
8f62c71c:	e1a00005 	mov	r0, r5
8f62c720:	e3482f70 	movt	r2, #36720	; 0x8f70
	if (usb_if.usb_write(response, strlen((const char *)response)) < 0)
8f62c724:	e30973d8 	movw	r7, #37848	; 0x93d8
	snprintf((char *)response, MAX_RSP_SIZE, "DATA%08x", len);
8f62c728:	eb001e04 	bl	8f633f40 <snprintf>
	if (usb_if.usb_write(response, strlen((const char *)response)) < 0)
8f62c72c:	e1a00005 	mov	r0, r5
8f62c730:	eb002034 	bl	8f634808 <strlen>
8f62c734:	e3487f75 	movt	r7, #36725	; 0x8f75
8f62c738:	e5978024 	ldr	r8, [r7, #36]	; 0x24
8f62c73c:	e1a01000 	mov	r1, r0
8f62c740:	e1a00005 	mov	r0, r5
8f62c744:	e12fff38 	blx	r8
8f62c748:	e3500000 	cmp	r0, #0
8f62c74c:	ba000011 	blt	8f62c798 <cmd_download+0x10c>
	arch_invalidate_cache_range((addr_t) download_base, ROUNDUP(len, CACHE_LINE));
8f62c750:	e30150d8 	movw	r5, #4312	; 0x10d8
8f62c754:	e3485f74 	movt	r5, #36724	; 0x8f74
8f62c758:	e284103f 	add	r1, r4, #63	; 0x3f
8f62c75c:	e5950000 	ldr	r0, [r5]
8f62c760:	e3c1103f 	bic	r1, r1, #63	; 0x3f
8f62c764:	ebffd217 	bl	8f620fc8 <arch_invalidate_cache_range>
	r = usb_if.usb_read(download_base, len);
8f62c768:	e5973020 	ldr	r3, [r7, #32]
8f62c76c:	e5950000 	ldr	r0, [r5]
8f62c770:	e1a01004 	mov	r1, r4
8f62c774:	e12fff33 	blx	r3
	if ((r < 0) || ((unsigned) r != len)) {
8f62c778:	e0503004 	subs	r3, r0, r4
8f62c77c:	13a03001 	movne	r3, #1
8f62c780:	e1933fa0 	orrs	r3, r3, r0, lsr #31
8f62c784:	0a000025 	beq	8f62c820 <cmd_download+0x194>
		fastboot_state = STATE_ERROR;
8f62c788:	e30130ec 	movw	r3, #4332	; 0x10ec
8f62c78c:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62c790:	e3a02003 	mov	r2, #3
8f62c794:	e5832000 	str	r2, [r3]
}
8f62c798:	e59f30e4 	ldr	r3, [pc, #228]	; 8f62c884 <cmd_download+0x1f8>
8f62c79c:	e5932000 	ldr	r2, [r3]
8f62c7a0:	e59d30bc 	ldr	r3, [r13, #188]	; 0xbc
8f62c7a4:	e0332002 	eors	r2, r3, r2
8f62c7a8:	e3a03000 	mov	r3, #0
8f62c7ac:	1a000033 	bne	8f62c880 <cmd_download+0x1f4>
8f62c7b0:	e28dd0c0 	add	r13, r13, #192	; 0xc0
8f62c7b4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
        switch(*x) {
8f62c7b8:	e2423061 	sub	r3, r2, #97	; 0x61
8f62c7bc:	e3530005 	cmp	r3, #5
8f62c7c0:	8affffc9 	bhi	8f62c6ec <cmd_download+0x60>
            n = (n << 4) | (*x - 'a' + 10);
8f62c7c4:	e2422057 	sub	r2, r2, #87	; 0x57
8f62c7c8:	e1824204 	orr	r4, r2, r4, lsl #4
            break;
8f62c7cc:	eaffffc3 	b	8f62c6e0 <cmd_download+0x54>
            n = (n << 4) | (*x - 'A' + 10);
8f62c7d0:	e2422037 	sub	r2, r2, #55	; 0x37
8f62c7d4:	eaffffc0 	b	8f62c6dc <cmd_download+0x50>
	if (fastboot_state != STATE_COMMAND) {
8f62c7d8:	e30130ec 	movw	r3, #4332	; 0x10ec
8f62c7dc:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62c7e0:	e5933000 	ldr	r3, [r3]
8f62c7e4:	e3530001 	cmp	r3, #1
		dprintf(CRITICAL, "%s\n", reason);
8f62c7e8:	e59f3094 	ldr	r3, [pc, #148]	; 8f62c884 <cmd_download+0x1f8>
	if (fastboot_state != STATE_COMMAND) {
8f62c7ec:	0a000012 	beq	8f62c83c <cmd_download+0x1b0>
		dprintf(CRITICAL, "%s\n", reason);
8f62c7f0:	e5932000 	ldr	r2, [r3]
8f62c7f4:	e59d30bc 	ldr	r3, [r13, #188]	; 0xbc
8f62c7f8:	e0332002 	eors	r2, r3, r2
8f62c7fc:	e3a03000 	mov	r3, #0
8f62c800:	1a00001e 	bne	8f62c880 <cmd_download+0x1f4>
8f62c804:	e30a11d8 	movw	r1, #41432	; 0xa1d8
8f62c808:	e30306e0 	movw	r0, #14048	; 0x36e0
8f62c80c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62c810:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f62c814:	e28dd0c0 	add	r13, r13, #192	; 0xc0
8f62c818:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, r14}
		dprintf(CRITICAL, "%s\n", reason);
8f62c81c:	ea001854 	b	8f632974 <_dprintf>
	fastboot_ack("OKAY", info);
8f62c820:	e3071138 	movw	r1, #28984	; 0x7138
8f62c824:	e30a01d0 	movw	r0, #41424	; 0xa1d0
8f62c828:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62c82c:	e3480f70 	movt	r0, #36720	; 0x8f70
	download_size = len;
8f62c830:	e5864000 	str	r4, [r6]
	fastboot_ack("OKAY", info);
8f62c834:	ebffff12 	bl	8f62c484 <fastboot_ack>
8f62c838:	eaffffd6 	b	8f62c798 <cmd_download+0x10c>
	fastboot_ack("FAIL", reason);
8f62c83c:	e5932000 	ldr	r2, [r3]
8f62c840:	e59d30bc 	ldr	r3, [r13, #188]	; 0xbc
8f62c844:	e0332002 	eors	r2, r3, r2
8f62c848:	e3a03000 	mov	r3, #0
8f62c84c:	1a00000b 	bne	8f62c880 <cmd_download+0x1f4>
8f62c850:	e30a11d8 	movw	r1, #41432	; 0xa1d8
8f62c854:	e30a01bc 	movw	r0, #41404	; 0xa1bc
8f62c858:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62c85c:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f62c860:	e28dd0c0 	add	r13, r13, #192	; 0xc0
8f62c864:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, r14}
	fastboot_ack("FAIL", reason);
8f62c868:	eaffff05 	b	8f62c484 <fastboot_ack>
	download_size = 0;
8f62c86c:	e30160e0 	movw	r6, #4320	; 0x10e0
8f62c870:	e3486f74 	movt	r6, #36724	; 0x8f74
    unsigned n = 0;
8f62c874:	e1a04002 	mov	r4, r2
	download_size = 0;
8f62c878:	e5862000 	str	r2, [r6]
	if (len > download_max) {
8f62c87c:	eaffffa3 	b	8f62c710 <cmd_download+0x84>
}
8f62c880:	eb0018ce 	bl	8f632bc0 <__stack_chk_fail>
8f62c884:	8f74221c 	.word	0x8f74221c

8f62c888 <fastboot_info>:
	if (fastboot_state != STATE_COMMAND) {
8f62c888:	e30130ec 	movw	r3, #4332	; 0x10ec
8f62c88c:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f62c890:	e92d4030 	push	{r4, r5, r14}
8f62c894:	e24dd0c4 	sub	r13, r13, #196	; 0xc4
	if (fastboot_state != STATE_COMMAND) {
8f62c898:	e5931000 	ldr	r1, [r3]
{
8f62c89c:	e28d203f 	add	r2, r13, #63	; 0x3f
8f62c8a0:	e3c2403f 	bic	r4, r2, #63	; 0x3f
8f62c8a4:	e59f20a4 	ldr	r2, [pc, #164]	; 8f62c950 <fastboot_info+0xc8>
	if (fastboot_state != STATE_COMMAND) {
8f62c8a8:	e3510001 	cmp	r1, #1
{
8f62c8ac:	e1a03000 	mov	r3, r0
8f62c8b0:	e5922000 	ldr	r2, [r2]
8f62c8b4:	e58d20bc 	str	r2, [r13, #188]	; 0xbc
8f62c8b8:	e3a02000 	mov	r2, #0
	if (fastboot_state != STATE_COMMAND) {
8f62c8bc:	1a000016 	bne	8f62c91c <fastboot_info+0x94>
	if (reason == 0)
8f62c8c0:	e3500000 	cmp	r0, #0
8f62c8c4:	0a00000c 	beq	8f62c8fc <fastboot_info+0x74>
	snprintf((char *)response, MAX_RSP_SIZE, "INFO%s", reason);
8f62c8c8:	e3a01040 	mov	r1, #64	; 0x40
8f62c8cc:	e30a21e8 	movw	r2, #41448	; 0xa1e8
8f62c8d0:	e1a00004 	mov	r0, r4
8f62c8d4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62c8d8:	eb001d98 	bl	8f633f40 <snprintf>
	usb_if.usb_write(response, strlen((const char *)response));
8f62c8dc:	e30933d8 	movw	r3, #37848	; 0x93d8
8f62c8e0:	e3483f75 	movt	r3, #36725	; 0x8f75
8f62c8e4:	e1a00004 	mov	r0, r4
8f62c8e8:	e5935024 	ldr	r5, [r3, #36]	; 0x24
8f62c8ec:	eb001fc5 	bl	8f634808 <strlen>
8f62c8f0:	e1a01000 	mov	r1, r0
8f62c8f4:	e1a00004 	mov	r0, r4
8f62c8f8:	e12fff35 	blx	r5
}
8f62c8fc:	e59f304c 	ldr	r3, [pc, #76]	; 8f62c950 <fastboot_info+0xc8>
8f62c900:	e5932000 	ldr	r2, [r3]
8f62c904:	e59d30bc 	ldr	r3, [r13, #188]	; 0xbc
8f62c908:	e0332002 	eors	r2, r3, r2
8f62c90c:	e3a03000 	mov	r3, #0
8f62c910:	1a00000d 	bne	8f62c94c <fastboot_info+0xc4>
8f62c914:	e28dd0c4 	add	r13, r13, #196	; 0xc4
8f62c918:	e8bd8030 	pop	{r4, r5, r15}
		dprintf(INFO, "%s\n", reason);
8f62c91c:	e59f202c 	ldr	r2, [pc, #44]	; 8f62c950 <fastboot_info+0xc8>
8f62c920:	e5921000 	ldr	r1, [r2]
8f62c924:	e59d20bc 	ldr	r2, [r13, #188]	; 0xbc
8f62c928:	e0321001 	eors	r1, r2, r1
8f62c92c:	e3a02000 	mov	r2, #0
8f62c930:	1a000005 	bne	8f62c94c <fastboot_info+0xc4>
8f62c934:	e30306e0 	movw	r0, #14048	; 0x36e0
8f62c938:	e1a01003 	mov	r1, r3
8f62c93c:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f62c940:	e28dd0c4 	add	r13, r13, #196	; 0xc4
8f62c944:	e8bd4030 	pop	{r4, r5, r14}
		dprintf(INFO, "%s\n", reason);
8f62c948:	ea001809 	b	8f632974 <_dprintf>
}
8f62c94c:	eb00189b 	bl	8f632bc0 <__stack_chk_fail>
8f62c950:	8f74221c 	.word	0x8f74221c

8f62c954 <fastboot_handler>:
{
8f62c954:	e92d4880 	push	{r7, r11, r14}
8f62c958:	e24dd03c 	sub	r13, r13, #60	; 0x3c
8f62c95c:	e3073f64 	movw	r3, #32612	; 0x7f64
8f62c960:	e30160ec 	movw	r6, #4332	; 0x10ec
8f62c964:	e3483f70 	movt	r3, #36720	; 0x8f70
8f62c968:	e309a3d8 	movw	r10, #37848	; 0x93d8
8f62c96c:	e58d3028 	str	r3, [r13, #40]	; 0x28
8f62c970:	e3486f74 	movt	r6, #36724	; 0x8f74
8f62c974:	e59f3348 	ldr	r3, [pc, #840]	; 8f62ccc4 <fastboot_handler+0x370>
8f62c978:	e348af75 	movt	r10, #36725	; 0x8f75
8f62c97c:	e30120d4 	movw	r2, #4308	; 0x10d4
8f62c980:	e58de024 	str	r14, [r13, #36]	; 0x24
8f62c984:	e3482f74 	movt	r2, #36724	; 0x8f74
8f62c988:	e58d2010 	str	r2, [r13, #16]
8f62c98c:	e5933000 	ldr	r3, [r3]
8f62c990:	e58d3034 	str	r3, [r13, #52]	; 0x34
8f62c994:	e3a03000 	mov	r3, #0
8f62c998:	e30130e0 	movw	r3, #4320	; 0x10e0
8f62c99c:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62c9a0:	e58d3014 	str	r3, [r13, #20]
8f62c9a4:	e30130d8 	movw	r3, #4312	; 0x10d8
8f62c9a8:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62c9ac:	e58d3018 	str	r3, [r13, #24]
		event_wait(&usb_online);
8f62c9b0:	e301311c 	movw	r3, #4380	; 0x111c
8f62c9b4:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62c9b8:	e58d301c 	str	r3, [r13, #28]
	dprintf(INFO,"fastboot: processing commands\n");
8f62c9bc:	e30a31f0 	movw	r3, #41456	; 0xa1f0
8f62c9c0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f62c9c4:	e58d3020 	str	r3, [r13, #32]
		dprintf(CRITICAL, "Could not allocate memory for fastboot buffer\n.");
8f62c9c8:	e30a3210 	movw	r3, #41488	; 0xa210
8f62c9cc:	e3483f70 	movt	r3, #36720	; 0x8f70
8f62c9d0:	e58d302c 	str	r3, [r13, #44]	; 0x2c
		event_wait(&usb_online);
8f62c9d4:	e59d001c 	ldr	r0, [r13, #28]
8f62c9d8:	ebffd834 	bl	8f622ab0 <event_wait>
	dprintf(INFO,"fastboot: processing commands\n");
8f62c9dc:	e59d0020 	ldr	r0, [r13, #32]
8f62c9e0:	eb0017e3 	bl	8f632974 <_dprintf>
	uint8_t *buffer = (uint8_t *)memalign(CACHE_LINE, ROUNDUP(4096, CACHE_LINE));
8f62c9e4:	e3a01a01 	mov	r1, #4096	; 0x1000
8f62c9e8:	e3a00040 	mov	r0, #64	; 0x40
8f62c9ec:	eb001d94 	bl	8f634044 <memalign>
	if (!buffer)
8f62c9f0:	e2504000 	subs	r4, r0, #0
8f62c9f4:	0a0000a6 	beq	8f62cc94 <fastboot_handler+0x340>
	while (fastboot_state != STATE_ERROR) {
8f62c9f8:	e5963000 	ldr	r3, [r6]
8f62c9fc:	e3530003 	cmp	r3, #3
8f62ca00:	0a00005f 	beq	8f62cb84 <fastboot_handler+0x230>
		dprintf(INFO,"fastboot: %s\n", buffer);
8f62ca04:	e30a8254 	movw	r8, #41556	; 0xa254
		if (!strncmp((const char*) buffer, "getvar:partition-type", 21))
8f62ca08:	e30a7264 	movw	r7, #41572	; 0xa264
		dprintf(INFO,"fastboot: %s\n", buffer);
8f62ca0c:	e3488f70 	movt	r8, #36720	; 0x8f70
		if (!strncmp((const char*) buffer, "getvar:partition-type", 21))
8f62ca10:	e3487f70 	movt	r7, #36720	; 0x8f70
		arch_clean_invalidate_cache_range((addr_t) buffer, MAX_RSP_SIZE);
8f62ca14:	e3a05000 	mov	r5, #0
		memset(buffer, 0, MAX_RSP_SIZE);
8f62ca18:	e3a02040 	mov	r2, #64	; 0x40
8f62ca1c:	e3a01000 	mov	r1, #0
8f62ca20:	e1a00004 	mov	r0, r4
8f62ca24:	eb001e26 	bl	8f6342c4 <memset>
		arch_clean_invalidate_cache_range((addr_t) buffer, MAX_RSP_SIZE);
8f62ca28:	e3a01040 	mov	r1, #64	; 0x40
8f62ca2c:	e1a00004 	mov	r0, r4
8f62ca30:	ebffd15a 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
		r = usb_if.usb_read(buffer, MAX_RSP_SIZE);
8f62ca34:	e59a3020 	ldr	r3, [r10, #32]
8f62ca38:	e3a01040 	mov	r1, #64	; 0x40
8f62ca3c:	e1a00004 	mov	r0, r4
8f62ca40:	e12fff33 	blx	r3
		if (r < 0) break;
8f62ca44:	e3500000 	cmp	r0, #0
8f62ca48:	ba00004d 	blt	8f62cb84 <fastboot_handler+0x230>
		buffer[r] = 0;
8f62ca4c:	e3a03000 	mov	r3, #0
		dprintf(INFO,"fastboot: %s\n", buffer);
8f62ca50:	e1a01004 	mov	r1, r4
		buffer[r] = 0;
8f62ca54:	e7c43000 	strb	r3, [r4, r0]
		dprintf(INFO,"fastboot: %s\n", buffer);
8f62ca58:	e1a00008 	mov	r0, r8
8f62ca5c:	eb0017c4 	bl	8f632974 <_dprintf>
		if (!strncmp((const char*) buffer, "getvar:partition-type", 21))
8f62ca60:	e3a02015 	mov	r2, #21
8f62ca64:	e1a01007 	mov	r1, r7
8f62ca68:	e1a00004 	mov	r0, r4
8f62ca6c:	eb001f7e 	bl	8f63486c <strncmp>
		if (is_first_erase_flash) {
8f62ca70:	e2055001 	and	r5, r5, #1
8f62ca74:	e3500000 	cmp	r0, #0
8f62ca78:	03855001 	orreq	r5, r5, #1
8f62ca7c:	e3550000 	cmp	r5, #0
8f62ca80:	0a00007a 	beq	8f62cc70 <fastboot_handler+0x31c>
			if (!strncmp((const char*) buffer, "erase", 5) ||
8f62ca84:	e3a02005 	mov	r2, #5
8f62ca88:	e30a127c 	movw	r1, #41596	; 0xa27c
8f62ca8c:	e1a00004 	mov	r0, r4
8f62ca90:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62ca94:	eb001f74 	bl	8f63486c <strncmp>
8f62ca98:	e3500000 	cmp	r0, #0
8f62ca9c:	0a000006 	beq	8f62cabc <fastboot_handler+0x168>
				!strncmp((const char*) buffer, "flash", 5)) {
8f62caa0:	e3a02005 	mov	r2, #5
8f62caa4:	e30a1284 	movw	r1, #41604	; 0xa284
8f62caa8:	e1a00004 	mov	r0, r4
8f62caac:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62cab0:	eb001f6d 	bl	8f63486c <strncmp>
			if (!strncmp((const char*) buffer, "erase", 5) ||
8f62cab4:	e3500000 	cmp	r0, #0
8f62cab8:	1a000002 	bne	8f62cac8 <fastboot_handler+0x174>
				if (!target_battery_soc_ok()) {
8f62cabc:	ebffd6a0 	bl	8f622544 <target_battery_soc_ok>
8f62cac0:	e3500000 	cmp	r0, #0
8f62cac4:	0a000054 	beq	8f62cc1c <fastboot_handler+0x2c8>
		arch_clean_invalidate_cache_range((addr_t) buffer, MAX_RSP_SIZE);
8f62cac8:	e3a03001 	mov	r3, #1
8f62cacc:	e58d300c 	str	r3, [r13, #12]
		for (cmd = cmdlist; cmd; cmd = cmd->next) {
8f62cad0:	e59d3010 	ldr	r3, [r13, #16]
		fastboot_state = STATE_COMMAND;
8f62cad4:	e3a02001 	mov	r2, #1
8f62cad8:	e5862000 	str	r2, [r6]
		for (cmd = cmdlist; cmd; cmd = cmd->next) {
8f62cadc:	e593b000 	ldr	r11, [r3]
8f62cae0:	e35b0000 	cmp	r11, #0
8f62cae4:	0a000014 	beq	8f62cb3c <fastboot_handler+0x1e8>
			size_t cmdlen = strlen((char*)buffer);
8f62cae8:	e1a00004 	mov	r0, r4
8f62caec:	eb001f45 	bl	8f634808 <strlen>
8f62caf0:	e1a05000 	mov	r5, r0
			if (memcmp(buffer, cmd->prefix, cmd->prefix_len))
8f62caf4:	e99b0202 	ldmib	r11, {r1, r9}
8f62caf8:	e1a00004 	mov	r0, r4
8f62cafc:	e1a02009 	mov	r2, r9
8f62cb00:	eb001e34 	bl	8f6343d8 <memcmp>
8f62cb04:	e3500000 	cmp	r0, #0
			if (cmdlen>cmd->prefix_len && buffer[cmd->prefix_len]!=' ' && buffer[cmd->prefix_len-1]!=':')
8f62cb08:	e0840009 	add	r0, r4, r9
			if (memcmp(buffer, cmd->prefix, cmd->prefix_len))
8f62cb0c:	1a000007 	bne	8f62cb30 <fastboot_handler+0x1dc>
			if (cmdlen>cmd->prefix_len && buffer[cmd->prefix_len]!=' ' && buffer[cmd->prefix_len-1]!=':')
8f62cb10:	e1550009 	cmp	r5, r9
8f62cb14:	9a000022 	bls	8f62cba4 <fastboot_handler+0x250>
8f62cb18:	e7d43009 	ldrb	r3, [r4, r9]
8f62cb1c:	e3530020 	cmp	r3, #32
8f62cb20:	0a000023 	beq	8f62cbb4 <fastboot_handler+0x260>
8f62cb24:	e5503001 	ldrb	r3, [r0, #-1]
8f62cb28:	e353003a 	cmp	r3, #58	; 0x3a
8f62cb2c:	0a000021 	beq	8f62cbb8 <fastboot_handler+0x264>
		for (cmd = cmdlist; cmd; cmd = cmd->next) {
8f62cb30:	e59bb000 	ldr	r11, [r11]
8f62cb34:	e35b0000 	cmp	r11, #0
8f62cb38:	1affffed 	bne	8f62caf4 <fastboot_handler+0x1a0>
		fastboot_info("unknown command");
8f62cb3c:	e30a02e8 	movw	r0, #41704	; 0xa2e8
8f62cb40:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62cb44:	ebffff4f 	bl	8f62c888 <fastboot_info>
		fastboot_info("See 'fastboot oem help'");
8f62cb48:	e30a02f8 	movw	r0, #41720	; 0xa2f8
8f62cb4c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62cb50:	ebffff4c 	bl	8f62c888 <fastboot_info>
	if (fastboot_state != STATE_COMMAND) {
8f62cb54:	e5963000 	ldr	r3, [r6]
		dprintf(CRITICAL, "%s\n", reason);
8f62cb58:	e3071138 	movw	r1, #28984	; 0x7138
		return;
8f62cb5c:	e59d500c 	ldr	r5, [r13, #12]
	if (fastboot_state != STATE_COMMAND) {
8f62cb60:	e3530001 	cmp	r3, #1
		dprintf(CRITICAL, "%s\n", reason);
8f62cb64:	e3481f70 	movt	r1, #36720	; 0x8f70
	if (fastboot_state != STATE_COMMAND) {
8f62cb68:	0a00003b 	beq	8f62cc5c <fastboot_handler+0x308>
		dprintf(CRITICAL, "%s\n", reason);
8f62cb6c:	e30306e0 	movw	r0, #14048	; 0x36e0
8f62cb70:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62cb74:	eb00177e 	bl	8f632974 <_dprintf>
	while (fastboot_state != STATE_ERROR) {
8f62cb78:	e596b000 	ldr	r11, [r6]
8f62cb7c:	e35b0003 	cmp	r11, #3
8f62cb80:	1affffa4 	bne	8f62ca18 <fastboot_handler+0xc4>
	dprintf(INFO,"fastboot: oops!\n");
8f62cb84:	e30a0240 	movw	r0, #41536	; 0xa240
8f62cb88:	e3480f70 	movt	r0, #36720	; 0x8f70
	fastboot_state = STATE_OFFLINE;
8f62cb8c:	e3a03000 	mov	r3, #0
8f62cb90:	e5863000 	str	r3, [r6]
	dprintf(INFO,"fastboot: oops!\n");
8f62cb94:	eb001776 	bl	8f632974 <_dprintf>
	free(buffer);
8f62cb98:	e1a00004 	mov	r0, r4
8f62cb9c:	eb001d5a 	bl	8f63410c <free>
}
8f62cba0:	eaffff8b 	b	8f62c9d4 <fastboot_handler+0x80>
			if(arg[0]==' ')
8f62cba4:	e7d41009 	ldrb	r1, [r4, r9]
			const char* arg = (const char*) buffer + cmd->prefix_len;
8f62cba8:	e0840009 	add	r0, r4, r9
			if(arg[0]==' ')
8f62cbac:	e3510020 	cmp	r1, #32
8f62cbb0:	1a000000 	bne	8f62cbb8 <fastboot_handler+0x264>
				arg++;
8f62cbb4:	e2800001 	add	r0, r0, #1
			cmd->handle(arg,
8f62cbb8:	e59d2014 	ldr	r2, [r13, #20]
8f62cbbc:	e59d1018 	ldr	r1, [r13, #24]
8f62cbc0:	e59b300c 	ldr	r3, [r11, #12]
8f62cbc4:	e5922000 	ldr	r2, [r2]
8f62cbc8:	e5911000 	ldr	r1, [r1]
8f62cbcc:	e12fff33 	blx	r3
			if (fastboot_state == STATE_COMMAND)
8f62cbd0:	e596b000 	ldr	r11, [r6]
8f62cbd4:	e35b0001 	cmp	r11, #1
8f62cbd8:	0a000026 	beq	8f62cc78 <fastboot_handler+0x324>
			if (!strncmp((const char*) buffer, "erase", 5) ||
8f62cbdc:	e3a02005 	mov	r2, #5
8f62cbe0:	e30a127c 	movw	r1, #41596	; 0xa27c
8f62cbe4:	e1a00004 	mov	r0, r4
8f62cbe8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62cbec:	eb001f1e 	bl	8f63486c <strncmp>
8f62cbf0:	e2505000 	subs	r5, r0, #0
8f62cbf4:	0affffe0 	beq	8f62cb7c <fastboot_handler+0x228>
				!strncmp((const char*) buffer, "flash", 5)) {
8f62cbf8:	e3a02005 	mov	r2, #5
8f62cbfc:	e30a1284 	movw	r1, #41604	; 0xa284
8f62cc00:	e1a00004 	mov	r0, r4
8f62cc04:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62cc08:	eb001f17 	bl	8f63486c <strncmp>
8f62cc0c:	e59d300c 	ldr	r3, [r13, #12]
8f62cc10:	e2505000 	subs	r5, r0, #0
8f62cc14:	11a05003 	movne	r5, r3
8f62cc18:	eaffffd7 	b	8f62cb7c <fastboot_handler+0x228>
					dprintf(INFO,"fastboot: battery voltage: %d\n",
8f62cc1c:	ebffd5d7 	bl	8f622380 <target_get_battery_voltage>
8f62cc20:	e1a01000 	mov	r1, r0
8f62cc24:	e30a028c 	movw	r0, #41612	; 0xa28c
8f62cc28:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62cc2c:	eb001750 	bl	8f632974 <_dprintf>
	if (fastboot_state != STATE_COMMAND) {
8f62cc30:	e5965000 	ldr	r5, [r6]
		dprintf(CRITICAL, "%s\n", reason);
8f62cc34:	e30a12ac 	movw	r1, #41644	; 0xa2ac
8f62cc38:	e3481f70 	movt	r1, #36720	; 0x8f70
	if (fastboot_state != STATE_COMMAND) {
8f62cc3c:	e3550001 	cmp	r5, #1
8f62cc40:	0a000005 	beq	8f62cc5c <fastboot_handler+0x308>
		dprintf(CRITICAL, "%s\n", reason);
8f62cc44:	e30306e0 	movw	r0, #14048	; 0x36e0
8f62cc48:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62cc4c:	eb001748 	bl	8f632974 <_dprintf>
		return;
8f62cc50:	e3a05001 	mov	r5, #1
	while (fastboot_state != STATE_ERROR) {
8f62cc54:	e596b000 	ldr	r11, [r6]
		return;
8f62cc58:	eaffffc7 	b	8f62cb7c <fastboot_handler+0x228>
	fastboot_ack("FAIL", reason);
8f62cc5c:	e30a01bc 	movw	r0, #41404	; 0xa1bc
8f62cc60:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62cc64:	ebfffe06 	bl	8f62c484 <fastboot_ack>
	while (fastboot_state != STATE_ERROR) {
8f62cc68:	e596b000 	ldr	r11, [r6]
8f62cc6c:	eaffffc2 	b	8f62cb7c <fastboot_handler+0x228>
8f62cc70:	e58d500c 	str	r5, [r13, #12]
8f62cc74:	eaffff95 	b	8f62cad0 <fastboot_handler+0x17c>
	fastboot_ack("FAIL", reason);
8f62cc78:	e30a12d8 	movw	r1, #41688	; 0xa2d8
8f62cc7c:	e30a01bc 	movw	r0, #41404	; 0xa1bc
8f62cc80:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62cc84:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62cc88:	ebfffdfd 	bl	8f62c484 <fastboot_ack>
	while (fastboot_state != STATE_ERROR) {
8f62cc8c:	e596b000 	ldr	r11, [r6]
8f62cc90:	eaffffd1 	b	8f62cbdc <fastboot_handler+0x288>
		dprintf(CRITICAL, "Could not allocate memory for fastboot buffer\n.");
8f62cc94:	e59d002c 	ldr	r0, [r13, #44]	; 0x2c
8f62cc98:	eb001735 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f62cc9c:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f62cca0:	e59d0024 	ldr	r0, [r13, #36]	; 0x24
8f62cca4:	e30a2000 	movw	r2, #40960	; 0xa000
8f62cca8:	e3001130 	movw	r1, #304	; 0x130
8f62ccac:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62ccb0:	e58d3000 	str	r3, [r13]
8f62ccb4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62ccb8:	e3003249 	movw	r3, #585	; 0x249
8f62ccbc:	eb00177e 	bl	8f632abc <_panic>
8f62ccc0:	eaffff4c 	b	8f62c9f8 <fastboot_handler+0xa4>
8f62ccc4:	8f74221c 	.word	0x8f74221c

8f62ccc8 <cmd_getvar>:
{
8f62ccc8:	e59f315c 	ldr	r3, [pc, #348]	; 8f62ce2c <cmd_getvar+0x164>
8f62cccc:	e92d4030 	push	{r4, r5, r14}
8f62ccd0:	e1a05000 	mov	r5, r0
8f62ccd4:	e24ddf43 	sub	r13, r13, #268	; 0x10c
8f62ccd8:	e5933000 	ldr	r3, [r3]
8f62ccdc:	e58d3104 	str	r3, [r13, #260]	; 0x104
8f62cce0:	e3a03000 	mov	r3, #0
	update_battery_status();
8f62cce4:	ebffe68d 	bl	8f626720 <update_battery_status>
	if (!strncmp("all", arg, strlen(arg)))
8f62cce8:	e1a00005 	mov	r0, r5
8f62ccec:	eb001ec5 	bl	8f634808 <strlen>
8f62ccf0:	e1a01005 	mov	r1, r5
8f62ccf4:	e1a02000 	mov	r2, r0
8f62ccf8:	e30a0310 	movw	r0, #41744	; 0xa310
8f62ccfc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62cd00:	eb001ed9 	bl	8f63486c <strncmp>
	for (var = varlist; var; var = var->next)
8f62cd04:	e3013138 	movw	r3, #4408	; 0x1138
8f62cd08:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62cd0c:	e5934000 	ldr	r4, [r3]
	if (!strncmp("all", arg, strlen(arg)))
8f62cd10:	e3500000 	cmp	r0, #0
8f62cd14:	1a000006 	bne	8f62cd34 <cmd_getvar+0x6c>
8f62cd18:	ea00001d 	b	8f62cd94 <cmd_getvar+0xcc>
		if (!strcmp(var->name, arg)) {
8f62cd1c:	e5940004 	ldr	r0, [r4, #4]
8f62cd20:	e1a01005 	mov	r1, r5
8f62cd24:	eb001dfe 	bl	8f634524 <strcmp>
8f62cd28:	e3500000 	cmp	r0, #0
8f62cd2c:	0a00000f 	beq	8f62cd70 <cmd_getvar+0xa8>
	for (var = varlist; var; var = var->next) {
8f62cd30:	e5944000 	ldr	r4, [r4]
8f62cd34:	e3540000 	cmp	r4, #0
8f62cd38:	1afffff7 	bne	8f62cd1c <cmd_getvar+0x54>
	fastboot_ack("OKAY", info);
8f62cd3c:	e59f30e8 	ldr	r3, [pc, #232]	; 8f62ce2c <cmd_getvar+0x164>
8f62cd40:	e5932000 	ldr	r2, [r3]
8f62cd44:	e59d3104 	ldr	r3, [r13, #260]	; 0x104
8f62cd48:	e0332002 	eors	r2, r3, r2
8f62cd4c:	e3a03000 	mov	r3, #0
8f62cd50:	03071138 	movweq	r1, #28984	; 0x7138
8f62cd54:	030a01d0 	movweq	r0, #41424	; 0xa1d0
8f62cd58:	03481f70 	movteq	r1, #36720	; 0x8f70
8f62cd5c:	1a00000b 	bne	8f62cd90 <cmd_getvar+0xc8>
8f62cd60:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f62cd64:	e28ddf43 	add	r13, r13, #268	; 0x10c
8f62cd68:	e8bd4030 	pop	{r4, r5, r14}
	fastboot_ack("OKAY", info);
8f62cd6c:	eafffdc4 	b	8f62c484 <fastboot_ack>
8f62cd70:	e59f30b4 	ldr	r3, [pc, #180]	; 8f62ce2c <cmd_getvar+0x164>
8f62cd74:	e5932000 	ldr	r2, [r3]
8f62cd78:	e59d3104 	ldr	r3, [r13, #260]	; 0x104
8f62cd7c:	e0332002 	eors	r2, r3, r2
8f62cd80:	e3a03000 	mov	r3, #0
8f62cd84:	05941008 	ldreq	r1, [r4, #8]
8f62cd88:	030a01d0 	movweq	r0, #41424	; 0xa1d0
8f62cd8c:	0afffff3 	beq	8f62cd60 <cmd_getvar+0x98>
}
8f62cd90:	eb00178a 	bl	8f632bc0 <__stack_chk_fail>
	for (var = varlist; var; var = var->next)
8f62cd94:	e3540000 	cmp	r4, #0
8f62cd98:	0a000016 	beq	8f62cdf8 <cmd_getvar+0x130>
		strlcat((char *) getvar_all, ":", sizeof(getvar_all));
8f62cd9c:	e30a5354 	movw	r5, #41812	; 0xa354
8f62cda0:	e3485f70 	movt	r5, #36720	; 0x8f70
		strlcpy((char *) getvar_all, var->name, sizeof(getvar_all));
8f62cda4:	e5941004 	ldr	r1, [r4, #4]
8f62cda8:	e3a02c01 	mov	r2, #256	; 0x100
8f62cdac:	e28d0004 	add	r0, r13, #4
8f62cdb0:	eb001e5e 	bl	8f634730 <strlcpy>
		strlcat((char *) getvar_all, ":", sizeof(getvar_all));
8f62cdb4:	e3a02c01 	mov	r2, #256	; 0x100
8f62cdb8:	e1a01005 	mov	r1, r5
8f62cdbc:	e28d0004 	add	r0, r13, #4
8f62cdc0:	eb001e23 	bl	8f634654 <strlcat>
		strlcat((char *) getvar_all, var->value, sizeof(getvar_all));
8f62cdc4:	e5941008 	ldr	r1, [r4, #8]
8f62cdc8:	e3a02c01 	mov	r2, #256	; 0x100
8f62cdcc:	e28d0004 	add	r0, r13, #4
8f62cdd0:	eb001e1f 	bl	8f634654 <strlcat>
		fastboot_info(getvar_all);
8f62cdd4:	e28d0004 	add	r0, r13, #4
8f62cdd8:	ebfffeaa 	bl	8f62c888 <fastboot_info>
		memset((void *) getvar_all, '\0', sizeof(getvar_all));
8f62cddc:	e28d0004 	add	r0, r13, #4
8f62cde0:	e3a02c01 	mov	r2, #256	; 0x100
8f62cde4:	e3a01000 	mov	r1, #0
8f62cde8:	eb001d35 	bl	8f6342c4 <memset>
	for (var = varlist; var; var = var->next)
8f62cdec:	e5944000 	ldr	r4, [r4]
8f62cdf0:	e3540000 	cmp	r4, #0
8f62cdf4:	1affffea 	bne	8f62cda4 <cmd_getvar+0xdc>
	fastboot_ack("OKAY", info);
8f62cdf8:	e3071138 	movw	r1, #28984	; 0x7138
8f62cdfc:	e30a01d0 	movw	r0, #41424	; 0xa1d0
8f62ce00:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62ce04:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62ce08:	ebfffd9d 	bl	8f62c484 <fastboot_ack>
}
8f62ce0c:	e59f3018 	ldr	r3, [pc, #24]	; 8f62ce2c <cmd_getvar+0x164>
8f62ce10:	e5932000 	ldr	r2, [r3]
8f62ce14:	e59d3104 	ldr	r3, [r13, #260]	; 0x104
8f62ce18:	e0332002 	eors	r2, r3, r2
8f62ce1c:	e3a03000 	mov	r3, #0
8f62ce20:	1affffda 	bne	8f62cd90 <cmd_getvar+0xc8>
8f62ce24:	e28ddf43 	add	r13, r13, #268	; 0x10c
8f62ce28:	e8bd8030 	pop	{r4, r5, r15}
8f62ce2c:	8f74221c 	.word	0x8f74221c

8f62ce30 <cmd_help>:
{
8f62ce30:	e92d48f0 	push	{r4, r5, r6, r7, r11, r14}
8f62ce34:	e28db014 	add	r11, r13, #20
8f62ce38:	e24dd088 	sub	r13, r13, #136	; 0x88
8f62ce3c:	e59f30c8 	ldr	r3, [pc, #200]	; 8f62cf0c <cmd_help+0xdc>
	fastboot_info("commands:");
8f62ce40:	e30a0314 	movw	r0, #41748	; 0xa314
8f62ce44:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f62ce48:	e5933000 	ldr	r3, [r3]
8f62ce4c:	e50b3018 	str	r3, [r11, #-24]	; 0xffffffe8
8f62ce50:	e3a03000 	mov	r3, #0
	fastboot_info("commands:");
8f62ce54:	ebfffe8b 	bl	8f62c888 <fastboot_info>
	for (cmd = cmdlist; cmd; cmd = cmd->next) {
8f62ce58:	e30130d4 	movw	r3, #4308	; 0x10d4
8f62ce5c:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62ce60:	e5934000 	ldr	r4, [r3]
8f62ce64:	e3540000 	cmp	r4, #0
8f62ce68:	0a000019 	beq	8f62ced4 <cmd_help+0xa4>
		snprintf(response, sizeof(response), "\t%s", buf);
8f62ce6c:	e30a6320 	movw	r6, #41760	; 0xa320
8f62ce70:	e3486f70 	movt	r6, #36720	; 0x8f70
		buf[cmd->prefix_len] = '\0';
8f62ce74:	e3a07000 	mov	r7, #0
		char buf[cmd->prefix_len+1];
8f62ce78:	e5942008 	ldr	r2, [r4, #8]
	for (cmd = cmdlist; cmd; cmd = cmd->next) {
8f62ce7c:	e1a0500d 	mov	r5, r13
		if (!memcpy(buf, cmd->prefix, cmd->prefix_len))
8f62ce80:	e5941004 	ldr	r1, [r4, #4]
		char buf[cmd->prefix_len+1];
8f62ce84:	e2823008 	add	r3, r2, #8
8f62ce88:	e3c33007 	bic	r3, r3, #7
8f62ce8c:	e04dd003 	sub	r13, r13, r3
		if (!memcpy(buf, cmd->prefix, cmd->prefix_len))
8f62ce90:	e1a0000d 	mov	r0, r13
8f62ce94:	eb001cc7 	bl	8f6341b8 <memcpy>
8f62ce98:	e3500000 	cmp	r0, #0
8f62ce9c:	0a000008 	beq	8f62cec4 <cmd_help+0x94>
		buf[cmd->prefix_len] = '\0';
8f62cea0:	e594c008 	ldr	r12, [r4, #8]
		snprintf(response, sizeof(response), "\t%s", buf);
8f62cea4:	e24b0098 	sub	r0, r11, #152	; 0x98
8f62cea8:	e1a0300d 	mov	r3, r13
8f62ceac:	e1a02006 	mov	r2, r6
8f62ceb0:	e3a01080 	mov	r1, #128	; 0x80
		buf[cmd->prefix_len] = '\0';
8f62ceb4:	e7cd700c 	strb	r7, [r13, r12]
		snprintf(response, sizeof(response), "\t%s", buf);
8f62ceb8:	eb001c20 	bl	8f633f40 <snprintf>
		fastboot_info(response);
8f62cebc:	e24b0098 	sub	r0, r11, #152	; 0x98
8f62cec0:	ebfffe70 	bl	8f62c888 <fastboot_info>
	for (cmd = cmdlist; cmd; cmd = cmd->next) {
8f62cec4:	e5944000 	ldr	r4, [r4]
8f62cec8:	e1a0d005 	mov	r13, r5
8f62cecc:	e3540000 	cmp	r4, #0
8f62ced0:	1affffe8 	bne	8f62ce78 <cmd_help+0x48>
	fastboot_ack("OKAY", info);
8f62ced4:	e3071138 	movw	r1, #28984	; 0x7138
8f62ced8:	e30a01d0 	movw	r0, #41424	; 0xa1d0
8f62cedc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62cee0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62cee4:	ebfffd66 	bl	8f62c484 <fastboot_ack>
}
8f62cee8:	e59f301c 	ldr	r3, [pc, #28]	; 8f62cf0c <cmd_help+0xdc>
8f62ceec:	e5932000 	ldr	r2, [r3]
8f62cef0:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
8f62cef4:	e0332002 	eors	r2, r3, r2
8f62cef8:	e3a03000 	mov	r3, #0
8f62cefc:	1a000001 	bne	8f62cf08 <cmd_help+0xd8>
8f62cf00:	e24bd014 	sub	r13, r11, #20
8f62cf04:	e8bd88f0 	pop	{r4, r5, r6, r7, r11, r15}
8f62cf08:	eb00172c 	bl	8f632bc0 <__stack_chk_fail>
8f62cf0c:	8f74221c 	.word	0x8f74221c

8f62cf10 <fastboot_fail>:
	if (fastboot_state != STATE_COMMAND) {
8f62cf10:	e30130ec 	movw	r3, #4332	; 0x10ec
8f62cf14:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f62cf18:	e59f2078 	ldr	r2, [pc, #120]	; 8f62cf98 <fastboot_fail+0x88>
8f62cf1c:	e1a01000 	mov	r1, r0
	if (fastboot_state != STATE_COMMAND) {
8f62cf20:	e5933000 	ldr	r3, [r3]
{
8f62cf24:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	if (fastboot_state != STATE_COMMAND) {
8f62cf28:	e3530001 	cmp	r3, #1
{
8f62cf2c:	e24dd00c 	sub	r13, r13, #12
		dprintf(CRITICAL, "%s\n", reason);
8f62cf30:	e59f3060 	ldr	r3, [pc, #96]	; 8f62cf98 <fastboot_fail+0x88>
{
8f62cf34:	e5922000 	ldr	r2, [r2]
8f62cf38:	e58d2004 	str	r2, [r13, #4]
8f62cf3c:	e3a02000 	mov	r2, #0
	if (fastboot_state != STATE_COMMAND) {
8f62cf40:	0a000009 	beq	8f62cf6c <fastboot_fail+0x5c>
		dprintf(CRITICAL, "%s\n", reason);
8f62cf44:	e5932000 	ldr	r2, [r3]
8f62cf48:	e59d3004 	ldr	r3, [r13, #4]
8f62cf4c:	e0332002 	eors	r2, r3, r2
8f62cf50:	e3a03000 	mov	r3, #0
8f62cf54:	1a00000e 	bne	8f62cf94 <fastboot_fail+0x84>
8f62cf58:	e30306e0 	movw	r0, #14048	; 0x36e0
8f62cf5c:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f62cf60:	e28dd00c 	add	r13, r13, #12
8f62cf64:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		dprintf(CRITICAL, "%s\n", reason);
8f62cf68:	ea001681 	b	8f632974 <_dprintf>
	fastboot_ack("FAIL", reason);
8f62cf6c:	e5932000 	ldr	r2, [r3]
8f62cf70:	e59d3004 	ldr	r3, [r13, #4]
8f62cf74:	e0332002 	eors	r2, r3, r2
8f62cf78:	e3a03000 	mov	r3, #0
8f62cf7c:	1a000004 	bne	8f62cf94 <fastboot_fail+0x84>
8f62cf80:	e30a01bc 	movw	r0, #41404	; 0xa1bc
8f62cf84:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f62cf88:	e28dd00c 	add	r13, r13, #12
8f62cf8c:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	fastboot_ack("FAIL", reason);
8f62cf90:	eafffd3b 	b	8f62c484 <fastboot_ack>
8f62cf94:	eb001709 	bl	8f632bc0 <__stack_chk_fail>
8f62cf98:	8f74221c 	.word	0x8f74221c

8f62cf9c <fastboot_okay>:
{
8f62cf9c:	e92d4030 	push	{r4, r5, r14}
	if (fastboot_state != STATE_COMMAND)
8f62cfa0:	e30150ec 	movw	r5, #4332	; 0x10ec
8f62cfa4:	e3485f74 	movt	r5, #36724	; 0x8f74
{
8f62cfa8:	e59f209c 	ldr	r2, [pc, #156]	; 8f62d04c <fastboot_okay+0xb0>
8f62cfac:	e24dd0cc 	sub	r13, r13, #204	; 0xcc
	if (fastboot_state != STATE_COMMAND)
8f62cfb0:	e5953000 	ldr	r3, [r5]
{
8f62cfb4:	e5922000 	ldr	r2, [r2]
8f62cfb8:	e58d20c4 	str	r2, [r13, #196]	; 0xc4
8f62cfbc:	e3a02000 	mov	r2, #0
	if (fastboot_state != STATE_COMMAND)
8f62cfc0:	e3530001 	cmp	r3, #1
8f62cfc4:	1a000017 	bne	8f62d028 <fastboot_okay+0x8c>
	if (reason == 0)
8f62cfc8:	e28d4047 	add	r4, r13, #71	; 0x47
		reason = "";
8f62cfcc:	e3500000 	cmp	r0, #0
8f62cfd0:	e3c4403f 	bic	r4, r4, #63	; 0x3f
8f62cfd4:	e3073138 	movw	r3, #28984	; 0x7138
8f62cfd8:	e3483f70 	movt	r3, #36720	; 0x8f70
	snprintf((char *)response, MAX_RSP_SIZE, "%s%s", code, reason);
8f62cfdc:	e3a01040 	mov	r1, #64	; 0x40
8f62cfe0:	e30a21a4 	movw	r2, #41380	; 0xa1a4
8f62cfe4:	e3482f70 	movt	r2, #36720	; 0x8f70
		reason = "";
8f62cfe8:	01a00003 	moveq	r0, r3
	snprintf((char *)response, MAX_RSP_SIZE, "%s%s", code, reason);
8f62cfec:	e30a31d0 	movw	r3, #41424	; 0xa1d0
8f62cff0:	e58d0000 	str	r0, [r13]
8f62cff4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f62cff8:	e1a00004 	mov	r0, r4
8f62cffc:	eb001bcf 	bl	8f633f40 <snprintf>
	usb_if.usb_write(response, strlen((const char *)response));
8f62d000:	e30933d8 	movw	r3, #37848	; 0x93d8
8f62d004:	e3483f75 	movt	r3, #36725	; 0x8f75
8f62d008:	e1a00004 	mov	r0, r4
	fastboot_state = STATE_COMPLETE;
8f62d00c:	e3a02002 	mov	r2, #2
8f62d010:	e5852000 	str	r2, [r5]
	usb_if.usb_write(response, strlen((const char *)response));
8f62d014:	e5935024 	ldr	r5, [r3, #36]	; 0x24
8f62d018:	eb001dfa 	bl	8f634808 <strlen>
8f62d01c:	e1a01000 	mov	r1, r0
8f62d020:	e1a00004 	mov	r0, r4
8f62d024:	e12fff35 	blx	r5
}
8f62d028:	e59f301c 	ldr	r3, [pc, #28]	; 8f62d04c <fastboot_okay+0xb0>
8f62d02c:	e5932000 	ldr	r2, [r3]
8f62d030:	e59d30c4 	ldr	r3, [r13, #196]	; 0xc4
8f62d034:	e0332002 	eors	r2, r3, r2
8f62d038:	e3a03000 	mov	r3, #0
8f62d03c:	1a000001 	bne	8f62d048 <fastboot_okay+0xac>
8f62d040:	e28dd0cc 	add	r13, r13, #204	; 0xcc
8f62d044:	e8bd8030 	pop	{r4, r5, r15}
8f62d048:	eb0016dc 	bl	8f632bc0 <__stack_chk_fail>
8f62d04c:	8f74221c 	.word	0x8f74221c

8f62d050 <fastboot_stage>:
{
8f62d050:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	arch_invalidate_cache_range((addr_t) download_base, download_size);
8f62d054:	e30140e0 	movw	r4, #4320	; 0x10e0
8f62d058:	e30160d8 	movw	r6, #4312	; 0x10d8
8f62d05c:	e3484f74 	movt	r4, #36724	; 0x8f74
8f62d060:	e3486f74 	movt	r6, #36724	; 0x8f74
{
8f62d064:	e59f30f4 	ldr	r3, [pc, #244]	; 8f62d160 <fastboot_stage+0x110>
8f62d068:	e24dd00c 	sub	r13, r13, #12
8f62d06c:	e1a05001 	mov	r5, r1
8f62d070:	e1a07000 	mov	r7, r0
	arch_invalidate_cache_range((addr_t) download_base, download_size);
8f62d074:	e5941000 	ldr	r1, [r4]
8f62d078:	e5960000 	ldr	r0, [r6]
{
8f62d07c:	e5933000 	ldr	r3, [r3]
8f62d080:	e58d3004 	str	r3, [r13, #4]
8f62d084:	e3a03000 	mov	r3, #0
	arch_invalidate_cache_range((addr_t) download_base, download_size);
8f62d088:	ebffcfce 	bl	8f620fc8 <arch_invalidate_cache_range>
	download_size = 0;
8f62d08c:	e3a03000 	mov	r3, #0
8f62d090:	e5843000 	str	r3, [r4]
	if (sz > download_max) {
8f62d094:	e30130dc 	movw	r3, #4316	; 0x10dc
8f62d098:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62d09c:	e5933000 	ldr	r3, [r3]
8f62d0a0:	e1530005 	cmp	r3, r5
8f62d0a4:	3a000011 	bcc	8f62d0f0 <fastboot_stage+0xa0>
	memcpy(download_base, data, sz);
8f62d0a8:	e1a01007 	mov	r1, r7
8f62d0ac:	e1a02005 	mov	r2, r5
8f62d0b0:	e5960000 	ldr	r0, [r6]
8f62d0b4:	eb001c3f 	bl	8f6341b8 <memcpy>
	fastboot_ack("OKAY", info);
8f62d0b8:	e59f30a0 	ldr	r3, [pc, #160]	; 8f62d160 <fastboot_stage+0x110>
	download_size = sz;
8f62d0bc:	e5845000 	str	r5, [r4]
	fastboot_ack("OKAY", info);
8f62d0c0:	e5932000 	ldr	r2, [r3]
8f62d0c4:	e59d3004 	ldr	r3, [r13, #4]
8f62d0c8:	e0332002 	eors	r2, r3, r2
8f62d0cc:	e3a03000 	mov	r3, #0
8f62d0d0:	03071138 	movweq	r1, #28984	; 0x7138
8f62d0d4:	030a01d0 	movweq	r0, #41424	; 0xa1d0
8f62d0d8:	03481f70 	movteq	r1, #36720	; 0x8f70
8f62d0dc:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62d0e0:	1a00001d 	bne	8f62d15c <fastboot_stage+0x10c>
}
8f62d0e4:	e28dd00c 	add	r13, r13, #12
8f62d0e8:	e8bd40f0 	pop	{r4, r5, r6, r7, r14}
	fastboot_ack("OKAY", info);
8f62d0ec:	eafffce4 	b	8f62c484 <fastboot_ack>
	if (fastboot_state != STATE_COMMAND) {
8f62d0f0:	e30130ec 	movw	r3, #4332	; 0x10ec
8f62d0f4:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62d0f8:	e5933000 	ldr	r3, [r3]
8f62d0fc:	e3530001 	cmp	r3, #1
		dprintf(CRITICAL, "%s\n", reason);
8f62d100:	e59f3058 	ldr	r3, [pc, #88]	; 8f62d160 <fastboot_stage+0x110>
	if (fastboot_state != STATE_COMMAND) {
8f62d104:	0a00000b 	beq	8f62d138 <fastboot_stage+0xe8>
		dprintf(CRITICAL, "%s\n", reason);
8f62d108:	e5932000 	ldr	r2, [r3]
8f62d10c:	e59d3004 	ldr	r3, [r13, #4]
8f62d110:	e0332002 	eors	r2, r3, r2
8f62d114:	e3a03000 	mov	r3, #0
8f62d118:	1a00000f 	bne	8f62d15c <fastboot_stage+0x10c>
8f62d11c:	e30a11d8 	movw	r1, #41432	; 0xa1d8
8f62d120:	e30306e0 	movw	r0, #14048	; 0x36e0
8f62d124:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62d128:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f62d12c:	e28dd00c 	add	r13, r13, #12
8f62d130:	e8bd40f0 	pop	{r4, r5, r6, r7, r14}
		dprintf(CRITICAL, "%s\n", reason);
8f62d134:	ea00160e 	b	8f632974 <_dprintf>
	fastboot_ack("FAIL", reason);
8f62d138:	e5932000 	ldr	r2, [r3]
8f62d13c:	e59d3004 	ldr	r3, [r13, #4]
8f62d140:	e0332002 	eors	r2, r3, r2
8f62d144:	e3a03000 	mov	r3, #0
8f62d148:	030a11d8 	movweq	r1, #41432	; 0xa1d8
8f62d14c:	030a01bc 	movweq	r0, #41404	; 0xa1bc
8f62d150:	03481f70 	movteq	r1, #36720	; 0x8f70
8f62d154:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62d158:	0affffe1 	beq	8f62d0e4 <fastboot_stage+0x94>
	fastboot_ack("OKAY", info);
8f62d15c:	eb001697 	bl	8f632bc0 <__stack_chk_fail>
8f62d160:	8f74221c 	.word	0x8f74221c

8f62d164 <fastboot_init>:

int fastboot_init(void *base, unsigned size)
{
8f62d164:	e59f341c 	ldr	r3, [pc, #1052]	; 8f62d588 <fastboot_init+0x424>
8f62d168:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f62d16c:	e1a05000 	mov	r5, r0
8f62d170:	e24dd020 	sub	r13, r13, #32
	char sn_buf[13];
	thread_t *thr;
	dprintf(INFO, "fastboot_init()\n");
8f62d174:	e30a0324 	movw	r0, #41764	; 0xa324
8f62d178:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f62d17c:	e1a06001 	mov	r6, r1

	/* target specific initialization before going into fastboot. */
	target_fastboot_init();

	/* setup serialno */
	target_serialno((unsigned char *) sn_buf);
8f62d180:	e28d400c 	add	r4, r13, #12
{
8f62d184:	e5933000 	ldr	r3, [r3]
8f62d188:	e58d301c 	str	r3, [r13, #28]
8f62d18c:	e3a03000 	mov	r3, #0
	dprintf(INFO, "fastboot_init()\n");
8f62d190:	eb0015f7 	bl	8f632974 <_dprintf>
	download_base = base;
8f62d194:	e30120d8 	movw	r2, #4312	; 0x10d8
	download_max = size;
8f62d198:	e30130dc 	movw	r3, #4316	; 0x10dc
	download_base = base;
8f62d19c:	e3482f74 	movt	r2, #36724	; 0x8f74
	download_max = size;
8f62d1a0:	e3483f74 	movt	r3, #36724	; 0x8f74
	download_base = base;
8f62d1a4:	e5825000 	str	r5, [r2]
	dprintf(SPEW,"serial number: %s\n",sn_buf);
	surf_udc_device.serialno = sn_buf;
8f62d1a8:	e303500c 	movw	r5, #12300	; 0x300c
	download_max = size;
8f62d1ac:	e5836000 	str	r6, [r3]
	surf_udc_device.serialno = sn_buf;
8f62d1b0:	e3485f71 	movt	r5, #36721	; 0x8f71
	target_fastboot_init();
8f62d1b4:	ebff4f81 	bl	8f600fc0 <target_fastboot_init>
	target_serialno((unsigned char *) sn_buf);
8f62d1b8:	e1a00004 	mov	r0, r4
8f62d1bc:	ebff4e43 	bl	8f600ad0 <target_serialno>
	dprintf(SPEW,"serial number: %s\n",sn_buf);
8f62d1c0:	e1a01004 	mov	r1, r4
8f62d1c4:	e3090dc8 	movw	r0, #40392	; 0x9dc8
8f62d1c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62d1cc:	eb0015e8 	bl	8f632974 <_dprintf>
	surf_udc_device.serialno = sn_buf;
8f62d1d0:	e5854010 	str	r4, [r5, #16]

	if(!strcmp(target_usb_controller(), "dwc"))
8f62d1d4:	ebff4f67 	bl	8f600f78 <target_usb_controller>
8f62d1d8:	e3001258 	movw	r1, #600	; 0x258
8f62d1dc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62d1e0:	eb001ccf 	bl	8f634524 <strcmp>
8f62d1e4:	e3500000 	cmp	r0, #0
8f62d1e8:	0a0000bb 	beq	8f62d4dc <fastboot_init+0x378>
#endif
	}
	else
	{
		/* initialize udc functions to use the default chipidea controller */
		usb_if.udc_init            = udc_init;
8f62d1ec:	e3062ad8 	movw	r2, #27352	; 0x6ad8
8f62d1f0:	e30943d8 	movw	r4, #37848	; 0x93d8
8f62d1f4:	e3482f60 	movt	r2, #36704	; 0x8f60
8f62d1f8:	e3484f75 	movt	r4, #36725	; 0x8f75
		usb_if.udc_register_gadget = udc_register_gadget;
8f62d1fc:	e3061cb0 	movw	r1, #27824	; 0x6cb0
		usb_if.udc_start           = udc_start;
8f62d200:	e3060d24 	movw	r0, #27940	; 0x6d24
		usb_if.udc_register_gadget = udc_register_gadget;
8f62d204:	e3481f60 	movt	r1, #36704	; 0x8f60
		usb_if.udc_start           = udc_start;
8f62d208:	e3480f60 	movt	r0, #36704	; 0x8f60
		usb_if.udc_endpoint_alloc  = udc_endpoint_alloc;
		usb_if.udc_request_alloc   = udc_request_alloc;
		usb_if.udc_request_free    = udc_request_free;

		usb_if.usb_read            = hsusb_usb_read;
		usb_if.usb_write           = hsusb_usb_write;
8f62d20c:	e1a03002 	mov	r3, r2
		usb_if.udc_init            = udc_init;
8f62d210:	e5842000 	str	r2, [r4]
		usb_if.udc_register_gadget = udc_register_gadget;
8f62d214:	e5841004 	str	r1, [r4, #4]
		usb_if.udc_stop            = udc_stop;
8f62d218:	e3072064 	movw	r2, #28772	; 0x7064
		usb_if.udc_endpoint_alloc  = udc_endpoint_alloc;
8f62d21c:	e3051f4c 	movw	r1, #24396	; 0x5f4c
		usb_if.udc_stop            = udc_stop;
8f62d220:	e3482f60 	movt	r2, #36704	; 0x8f60
		usb_if.udc_endpoint_alloc  = udc_endpoint_alloc;
8f62d224:	e3481f60 	movt	r1, #36704	; 0x8f60
		usb_if.udc_start           = udc_start;
8f62d228:	e5840008 	str	r0, [r4, #8]
		usb_if.udc_stop            = udc_stop;
8f62d22c:	e584200c 	str	r2, [r4, #12]
		usb_if.udc_request_free    = udc_request_free;
8f62d230:	e30600a4 	movw	r0, #24740	; 0x60a4
		usb_if.udc_request_alloc   = udc_request_alloc;
8f62d234:	e3062000 	movw	r2, #24576	; 0x6000
		usb_if.udc_request_free    = udc_request_free;
8f62d238:	e3480f60 	movt	r0, #36704	; 0x8f60
		usb_if.udc_request_alloc   = udc_request_alloc;
8f62d23c:	e3482f60 	movt	r2, #36704	; 0x8f60
		usb_if.udc_endpoint_alloc  = udc_endpoint_alloc;
8f62d240:	e5841010 	str	r1, [r4, #16]
		usb_if.udc_request_alloc   = udc_request_alloc;
8f62d244:	e5842018 	str	r2, [r4, #24]
		usb_if.usb_read            = hsusb_usb_read;
8f62d248:	e30b1e54 	movw	r1, #48724	; 0xbe54
		usb_if.usb_write           = hsusb_usb_write;
8f62d24c:	e30b2d28 	movw	r2, #48424	; 0xbd28
		usb_if.usb_read            = hsusb_usb_read;
8f62d250:	e3481f62 	movt	r1, #36706	; 0x8f62
		usb_if.usb_write           = hsusb_usb_write;
8f62d254:	e3482f62 	movt	r2, #36706	; 0x8f62
		usb_if.usb_read            = hsusb_usb_read;
8f62d258:	e1c401fc 	strd	r0, [r4, #28]
		usb_if.usb_write           = hsusb_usb_write;
8f62d25c:	e5842024 	str	r2, [r4, #36]	; 0x24
	}

	/* register udc device */
	usb_if.udc_init(&surf_udc_device);
8f62d260:	e303000c 	movw	r0, #12300	; 0x300c
8f62d264:	e3480f71 	movt	r0, #36721	; 0x8f71
8f62d268:	e12fff33 	blx	r3

	event_init(&usb_online, 0, EVENT_FLAG_AUTOUNSIGNAL);
8f62d26c:	e3a02001 	mov	r2, #1
8f62d270:	e3a01000 	mov	r1, #0
8f62d274:	e301011c 	movw	r0, #4380	; 0x111c
8f62d278:	e3480f74 	movt	r0, #36724	; 0x8f74
	event_init(&txn_done, 0, EVENT_FLAG_AUTOUNSIGNAL);

	in = usb_if.udc_endpoint_alloc(UDC_TYPE_BULK_IN, 512);
8f62d27c:	e30150f0 	movw	r5, #4336	; 0x10f0
	event_init(&usb_online, 0, EVENT_FLAG_AUTOUNSIGNAL);
8f62d280:	ebffd5f3 	bl	8f622a54 <event_init>
	event_init(&txn_done, 0, EVENT_FLAG_AUTOUNSIGNAL);
8f62d284:	e3a02001 	mov	r2, #1
8f62d288:	e3a01000 	mov	r1, #0
8f62d28c:	e30100fc 	movw	r0, #4348	; 0x10fc
8f62d290:	e3480f74 	movt	r0, #36724	; 0x8f74
	in = usb_if.udc_endpoint_alloc(UDC_TYPE_BULK_IN, 512);
8f62d294:	e3485f74 	movt	r5, #36724	; 0x8f74
	event_init(&txn_done, 0, EVENT_FLAG_AUTOUNSIGNAL);
8f62d298:	ebffd5ed 	bl	8f622a54 <event_init>
	in = usb_if.udc_endpoint_alloc(UDC_TYPE_BULK_IN, 512);
8f62d29c:	e5943010 	ldr	r3, [r4, #16]
8f62d2a0:	e3a01c02 	mov	r1, #512	; 0x200
8f62d2a4:	e3a00001 	mov	r0, #1
8f62d2a8:	e12fff33 	blx	r3
	if (!in)
8f62d2ac:	e3500000 	cmp	r0, #0
	in = usb_if.udc_endpoint_alloc(UDC_TYPE_BULK_IN, 512);
8f62d2b0:	e5850000 	str	r0, [r5]
	if (!in)
8f62d2b4:	0a0000b0 	beq	8f62d57c <fastboot_init+0x418>
		goto fail_alloc_in;
	out = usb_if.udc_endpoint_alloc(UDC_TYPE_BULK_OUT, 512);
8f62d2b8:	e5943010 	ldr	r3, [r4, #16]
8f62d2bc:	e3a01c02 	mov	r1, #512	; 0x200
8f62d2c0:	e3a00002 	mov	r0, #2
8f62d2c4:	e30170f4 	movw	r7, #4340	; 0x10f4
8f62d2c8:	e12fff33 	blx	r3
8f62d2cc:	e3487f74 	movt	r7, #36724	; 0x8f74
	if (!out)
8f62d2d0:	e3500000 	cmp	r0, #0
	out = usb_if.udc_endpoint_alloc(UDC_TYPE_BULK_OUT, 512);
8f62d2d4:	e5870000 	str	r0, [r7]
	if (!out)
8f62d2d8:	0a0000a4 	beq	8f62d570 <fastboot_init+0x40c>
		goto fail_alloc_out;

	fastboot_endpoints[0] = in;
8f62d2dc:	e5951000 	ldr	r1, [r5]
8f62d2e0:	e30130e4 	movw	r3, #4324	; 0x10e4
8f62d2e4:	e3483f74 	movt	r3, #36724	; 0x8f74
	fastboot_endpoints[1] = out;

	req = usb_if.udc_request_alloc();
8f62d2e8:	e5942018 	ldr	r2, [r4, #24]
8f62d2ec:	e30180f8 	movw	r8, #4344	; 0x10f8
8f62d2f0:	e3488f74 	movt	r8, #36724	; 0x8f74
	fastboot_endpoints[1] = out;
8f62d2f4:	e5830004 	str	r0, [r3, #4]
	fastboot_endpoints[0] = in;
8f62d2f8:	e5831000 	str	r1, [r3]
	req = usb_if.udc_request_alloc();
8f62d2fc:	e12fff32 	blx	r2
	if (!req)
8f62d300:	e3500000 	cmp	r0, #0
	req = usb_if.udc_request_alloc();
8f62d304:	e5880000 	str	r0, [r8]
	if (!req)
8f62d308:	0a000095 	beq	8f62d564 <fastboot_init+0x400>
		goto fail_alloc_req;

	/* register gadget */
	if (usb_if.udc_register_gadget(&fastboot_gadget))
8f62d30c:	e5943004 	ldr	r3, [r4, #4]
8f62d310:	e3020ff4 	movw	r0, #12276	; 0x2ff4
8f62d314:	e3480f71 	movt	r0, #36721	; 0x8f71
8f62d318:	e12fff33 	blx	r3
8f62d31c:	e2506000 	subs	r6, r0, #0
8f62d320:	1a00008c 	bne	8f62d558 <fastboot_init+0x3f4>
	cmd = malloc(sizeof(*cmd));
8f62d324:	e3a00010 	mov	r0, #16
8f62d328:	eb001b33 	bl	8f633ffc <malloc>
	if (cmd) {
8f62d32c:	e2505000 	subs	r5, r0, #0
8f62d330:	0a00000c 	beq	8f62d368 <fastboot_init+0x204>
		cmd->prefix = prefix;
8f62d334:	e30a0338 	movw	r0, #41784	; 0xa338
8f62d338:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62d33c:	e5850004 	str	r0, [r5, #4]
		cmd->prefix_len = strlen(prefix);
8f62d340:	eb001d30 	bl	8f634808 <strlen>
		cmd->next = cmdlist;
8f62d344:	e30130d4 	movw	r3, #4308	; 0x10d4
8f62d348:	e3483f74 	movt	r3, #36724	; 0x8f74
		cmd->handle = handle;
8f62d34c:	e30c2e30 	movw	r2, #52784	; 0xce30
8f62d350:	e3482f62 	movt	r2, #36706	; 0x8f62
8f62d354:	e585200c 	str	r2, [r5, #12]
		cmd->next = cmdlist;
8f62d358:	e5932000 	ldr	r2, [r3]
		cmdlist = cmd;
8f62d35c:	e5835000 	str	r5, [r3]
		cmd->next = cmdlist;
8f62d360:	e5852000 	str	r2, [r5]
		cmd->prefix_len = strlen(prefix);
8f62d364:	e5850008 	str	r0, [r5, #8]
	cmd = malloc(sizeof(*cmd));
8f62d368:	e3a00010 	mov	r0, #16
8f62d36c:	eb001b22 	bl	8f633ffc <malloc>
	if (cmd) {
8f62d370:	e2505000 	subs	r5, r0, #0
8f62d374:	0a00000c 	beq	8f62d3ac <fastboot_init+0x248>
		cmd->prefix = prefix;
8f62d378:	e30a0344 	movw	r0, #41796	; 0xa344
8f62d37c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62d380:	e5850004 	str	r0, [r5, #4]
		cmd->prefix_len = strlen(prefix);
8f62d384:	eb001d1f 	bl	8f634808 <strlen>
		cmd->next = cmdlist;
8f62d388:	e30130d4 	movw	r3, #4308	; 0x10d4
8f62d38c:	e3483f74 	movt	r3, #36724	; 0x8f74
		cmd->handle = handle;
8f62d390:	e30c2cc8 	movw	r2, #52424	; 0xccc8
8f62d394:	e3482f62 	movt	r2, #36706	; 0x8f62
8f62d398:	e585200c 	str	r2, [r5, #12]
		cmd->next = cmdlist;
8f62d39c:	e5932000 	ldr	r2, [r3]
		cmdlist = cmd;
8f62d3a0:	e5835000 	str	r5, [r3]
		cmd->next = cmdlist;
8f62d3a4:	e5852000 	str	r2, [r5]
		cmd->prefix_len = strlen(prefix);
8f62d3a8:	e5850008 	str	r0, [r5, #8]
	cmd = malloc(sizeof(*cmd));
8f62d3ac:	e3a00010 	mov	r0, #16
8f62d3b0:	eb001b11 	bl	8f633ffc <malloc>
	if (cmd) {
8f62d3b4:	e2505000 	subs	r5, r0, #0
8f62d3b8:	0a00000c 	beq	8f62d3f0 <fastboot_init+0x28c>
		cmd->prefix = prefix;
8f62d3bc:	e30a034c 	movw	r0, #41804	; 0xa34c
8f62d3c0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62d3c4:	e5850004 	str	r0, [r5, #4]
		cmd->prefix_len = strlen(prefix);
8f62d3c8:	eb001d0e 	bl	8f634808 <strlen>
		cmd->next = cmdlist;
8f62d3cc:	e30130d4 	movw	r3, #4308	; 0x10d4
8f62d3d0:	e3483f74 	movt	r3, #36724	; 0x8f74
		cmd->handle = handle;
8f62d3d4:	e30c268c 	movw	r2, #50828	; 0xc68c
8f62d3d8:	e3482f62 	movt	r2, #36706	; 0x8f62
8f62d3dc:	e585200c 	str	r2, [r5, #12]
		cmd->next = cmdlist;
8f62d3e0:	e5932000 	ldr	r2, [r3]
		cmdlist = cmd;
8f62d3e4:	e5835000 	str	r5, [r3]
		cmd->next = cmdlist;
8f62d3e8:	e5852000 	str	r2, [r5]
		cmd->prefix_len = strlen(prefix);
8f62d3ec:	e5850008 	str	r0, [r5, #8]
	cmd = malloc(sizeof(*cmd));
8f62d3f0:	e3a00010 	mov	r0, #16
8f62d3f4:	eb001b00 	bl	8f633ffc <malloc>
	if (cmd) {
8f62d3f8:	e2505000 	subs	r5, r0, #0
8f62d3fc:	0a00000c 	beq	8f62d434 <fastboot_init+0x2d0>
		cmd->prefix = prefix;
8f62d400:	e30a0358 	movw	r0, #41816	; 0xa358
8f62d404:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62d408:	e5850004 	str	r0, [r5, #4]
		cmd->prefix_len = strlen(prefix);
8f62d40c:	eb001cfd 	bl	8f634808 <strlen>
		cmd->next = cmdlist;
8f62d410:	e30130d4 	movw	r3, #4308	; 0x10d4
8f62d414:	e3483f74 	movt	r3, #36724	; 0x8f74
		cmd->handle = handle;
8f62d418:	e30c2538 	movw	r2, #50488	; 0xc538
8f62d41c:	e3482f62 	movt	r2, #36706	; 0x8f62
8f62d420:	e585200c 	str	r2, [r5, #12]
		cmd->next = cmdlist;
8f62d424:	e5932000 	ldr	r2, [r3]
		cmdlist = cmd;
8f62d428:	e5835000 	str	r5, [r3]
		cmd->next = cmdlist;
8f62d42c:	e5852000 	str	r2, [r5]
		cmd->prefix_len = strlen(prefix);
8f62d430:	e5850008 	str	r0, [r5, #8]
	var = malloc(sizeof(*var));
8f62d434:	e3a0000c 	mov	r0, #12
8f62d438:	eb001aef 	bl	8f633ffc <malloc>
	if (var) {
8f62d43c:	e3500000 	cmp	r0, #0
8f62d440:	0a00000a 	beq	8f62d470 <fastboot_init+0x30c>
		var->next = varlist;
8f62d444:	e3013138 	movw	r3, #4408	; 0x1138
8f62d448:	e3483f74 	movt	r3, #36724	; 0x8f74
		var->name = name;
8f62d44c:	e30a2360 	movw	r2, #41824	; 0xa360
8f62d450:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62d454:	e5802004 	str	r2, [r0, #4]
		var->value = value;
8f62d458:	e30a2368 	movw	r2, #41832	; 0xa368
8f62d45c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62d460:	e5802008 	str	r2, [r0, #8]
		var->next = varlist;
8f62d464:	e5932000 	ldr	r2, [r3]
		varlist = var;
8f62d468:	e5830000 	str	r0, [r3]
		var->next = varlist;
8f62d46c:	e5802000 	str	r2, [r0]
	fastboot_register("getvar:", cmd_getvar);
	fastboot_register("download:", cmd_download);
	fastboot_register("upload", cmd_upload);
	fastboot_publish("version", "0.5");

	thr = thread_create("fastboot", fastboot_handler, 0, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
8f62d470:	e3a01a03 	mov	r1, #12288	; 0x3000
8f62d474:	e3a03010 	mov	r3, #16
8f62d478:	e58d1000 	str	r1, [r13]
8f62d47c:	e3a02000 	mov	r2, #0
8f62d480:	e30c1954 	movw	r1, #51540	; 0xc954
8f62d484:	e30a036c 	movw	r0, #41836	; 0xa36c
8f62d488:	e3481f62 	movt	r1, #36706	; 0x8f62
8f62d48c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62d490:	ebffd979 	bl	8f623a7c <thread_create>
	if (!thr)
8f62d494:	e3500000 	cmp	r0, #0
8f62d498:	0a000037 	beq	8f62d57c <fastboot_init+0x418>
	{
		goto fail_alloc_in;
	}
	thread_resume(thr);
8f62d49c:	ebffda67 	bl	8f623e40 <thread_resume>

	usb_if.udc_start();
8f62d4a0:	e5943008 	ldr	r3, [r4, #8]
8f62d4a4:	e12fff33 	blx	r3
	udc_started = true;
8f62d4a8:	e3013118 	movw	r3, #4376	; 0x1118
8f62d4ac:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62d4b0:	e3a02001 	mov	r2, #1
8f62d4b4:	e5832000 	str	r2, [r3]
	usb_if.udc_endpoint_free(out);
fail_alloc_out:
	usb_if.udc_endpoint_free(in);
fail_alloc_in:
	return -1;
}
8f62d4b8:	e59f30c8 	ldr	r3, [pc, #200]	; 8f62d588 <fastboot_init+0x424>
8f62d4bc:	e5932000 	ldr	r2, [r3]
8f62d4c0:	e59d301c 	ldr	r3, [r13, #28]
8f62d4c4:	e0332002 	eors	r2, r3, r2
8f62d4c8:	e3a03000 	mov	r3, #0
8f62d4cc:	1a00002c 	bne	8f62d584 <fastboot_init+0x420>
8f62d4d0:	e1a00006 	mov	r0, r6
8f62d4d4:	e28dd020 	add	r13, r13, #32
8f62d4d8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
		surf_udc_device.t_usb_if = target_usb30_init();
8f62d4dc:	ebff4e76 	bl	8f600ebc <target_usb30_init>
		usb_if.udc_init            = usb30_udc_init;
8f62d4e0:	e30943d8 	movw	r4, #37848	; 0x93d8
8f62d4e4:	e3484f75 	movt	r4, #36725	; 0x8f75
8f62d4e8:	e30f3074 	movw	r3, #61556	; 0xf074
		usb_if.udc_register_gadget = usb30_udc_register_gadget;
8f62d4ec:	e30f2664 	movw	r2, #63076	; 0xf664
		usb_if.udc_init            = usb30_udc_init;
8f62d4f0:	e3483f61 	movt	r3, #36705	; 0x8f61
		usb_if.udc_register_gadget = usb30_udc_register_gadget;
8f62d4f4:	e3482f61 	movt	r2, #36705	; 0x8f61
		usb_if.udc_endpoint_alloc  = usb30_udc_endpoint_alloc;
8f62d4f8:	e30f1a3c 	movw	r1, #64060	; 0xfa3c
		usb_if.udc_register_gadget = usb30_udc_register_gadget;
8f62d4fc:	e5842004 	str	r2, [r4, #4]
		usb_if.udc_endpoint_alloc  = usb30_udc_endpoint_alloc;
8f62d500:	e3481f61 	movt	r1, #36705	; 0x8f61
		usb_if.udc_stop            = usb30_udc_stop;
8f62d504:	e30f2cb8 	movw	r2, #64696	; 0xfcb8
		usb_if.udc_endpoint_alloc  = usb30_udc_endpoint_alloc;
8f62d508:	e5841010 	str	r1, [r4, #16]
		usb_if.udc_stop            = usb30_udc_stop;
8f62d50c:	e3482f61 	movt	r2, #36705	; 0x8f61
		usb_if.usb_read            = usb30_usb_read;
8f62d510:	e30c1124 	movw	r1, #49444	; 0xc124
		usb_if.udc_stop            = usb30_udc_stop;
8f62d514:	e584200c 	str	r2, [r4, #12]
		usb_if.usb_read            = usb30_usb_read;
8f62d518:	e3481f62 	movt	r1, #36706	; 0x8f62
		usb_if.udc_request_alloc   = usb30_udc_request_alloc;
8f62d51c:	e30f2bdc 	movw	r2, #64476	; 0xfbdc
		usb_if.udc_init            = usb30_udc_init;
8f62d520:	e5843000 	str	r3, [r4]
		usb_if.udc_request_alloc   = usb30_udc_request_alloc;
8f62d524:	e3482f61 	movt	r2, #36705	; 0x8f61
8f62d528:	e5842018 	str	r2, [r4, #24]
		usb_if.usb_write           = usb30_usb_write;
8f62d52c:	e30b2f88 	movw	r2, #49032	; 0xbf88
8f62d530:	e3482f62 	movt	r2, #36706	; 0x8f62
8f62d534:	e5842024 	str	r2, [r4, #36]	; 0x24
		surf_udc_device.t_usb_if = target_usb30_init();
8f62d538:	e5850014 	str	r0, [r5, #20]
		usb_if.udc_start           = usb30_udc_start;
8f62d53c:	e30f08fc 	movw	r0, #63740	; 0xf8fc
8f62d540:	e3480f61 	movt	r0, #36705	; 0x8f61
8f62d544:	e5840008 	str	r0, [r4, #8]
		usb_if.udc_request_free    = usb30_udc_request_free;
8f62d548:	e30f0c74 	movw	r0, #64628	; 0xfc74
8f62d54c:	e3480f61 	movt	r0, #36705	; 0x8f61
		usb_if.usb_read            = usb30_usb_read;
8f62d550:	e1c401fc 	strd	r0, [r4, #28]
		usb_if.usb_write           = usb30_usb_write;
8f62d554:	eaffff41 	b	8f62d260 <fastboot_init+0xfc>
	usb_if.udc_request_free(req);
8f62d558:	e594301c 	ldr	r3, [r4, #28]
8f62d55c:	e5980000 	ldr	r0, [r8]
8f62d560:	e12fff33 	blx	r3
	usb_if.udc_endpoint_free(out);
8f62d564:	e5943014 	ldr	r3, [r4, #20]
8f62d568:	e5970000 	ldr	r0, [r7]
8f62d56c:	e12fff33 	blx	r3
	usb_if.udc_endpoint_free(in);
8f62d570:	e5943014 	ldr	r3, [r4, #20]
8f62d574:	e5950000 	ldr	r0, [r5]
8f62d578:	e12fff33 	blx	r3
	return -1;
8f62d57c:	e3e06000 	mvn	r6, #0
8f62d580:	eaffffcc 	b	8f62d4b8 <fastboot_init+0x354>
}
8f62d584:	eb00158d 	bl	8f632bc0 <__stack_chk_fail>
8f62d588:	8f74221c 	.word	0x8f74221c

8f62d58c <fastboot_stop>:

void fastboot_stop(void)
{
8f62d58c:	e92d4010 	push	{r4, r14}
	if (!udc_started)
8f62d590:	e3014118 	movw	r4, #4376	; 0x1118
{
8f62d594:	e59f3058 	ldr	r3, [pc, #88]	; 8f62d5f4 <fastboot_stop+0x68>
	if (!udc_started)
8f62d598:	e3484f74 	movt	r4, #36724	; 0x8f74
{
8f62d59c:	e24dd008 	sub	r13, r13, #8
8f62d5a0:	e5933000 	ldr	r3, [r3]
8f62d5a4:	e58d3004 	str	r3, [r13, #4]
8f62d5a8:	e3a03000 	mov	r3, #0
	if (!udc_started)
8f62d5ac:	e5943000 	ldr	r3, [r4]
8f62d5b0:	e3530000 	cmp	r3, #0
8f62d5b4:	0a000005 	beq	8f62d5d0 <fastboot_stop+0x44>
		return;

	usb_if.udc_stop();
8f62d5b8:	e30933d8 	movw	r3, #37848	; 0x93d8
8f62d5bc:	e3483f75 	movt	r3, #36725	; 0x8f75
8f62d5c0:	e593300c 	ldr	r3, [r3, #12]
8f62d5c4:	e12fff33 	blx	r3
	udc_started = false;
8f62d5c8:	e3a03000 	mov	r3, #0
8f62d5cc:	e5843000 	str	r3, [r4]
}
8f62d5d0:	e59f301c 	ldr	r3, [pc, #28]	; 8f62d5f4 <fastboot_stop+0x68>
8f62d5d4:	e5932000 	ldr	r2, [r3]
8f62d5d8:	e59d3004 	ldr	r3, [r13, #4]
8f62d5dc:	e0332002 	eors	r2, r3, r2
8f62d5e0:	e3a03000 	mov	r3, #0
8f62d5e4:	1a000001 	bne	8f62d5f0 <fastboot_stop+0x64>
8f62d5e8:	e28dd008 	add	r13, r13, #8
8f62d5ec:	e8bd8010 	pop	{r4, r15}
8f62d5f0:	eb001572 	bl	8f632bc0 <__stack_chk_fail>
8f62d5f4:	8f74221c 	.word	0x8f74221c

8f62d5f8 <cmd_oem_cmdline>:
	fastboot_stage(lk2nd_dev.pstore, lk2nd_dev.pstore_size);
}

static void cmd_oem_cmdline(const char *arg, void *data, unsigned sz)
{
	fastboot_stage(lk2nd_dev.cmdline, strlen(lk2nd_dev.cmdline));
8f62d5f8:	e301313c 	movw	r3, #4412	; 0x113c
8f62d5fc:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f62d600:	e92d4010 	push	{r4, r14}
8f62d604:	e24dd008 	sub	r13, r13, #8
	fastboot_stage(lk2nd_dev.cmdline, strlen(lk2nd_dev.cmdline));
8f62d608:	e5934008 	ldr	r4, [r3, #8]
{
8f62d60c:	e59f2040 	ldr	r2, [pc, #64]	; 8f62d654 <cmd_oem_cmdline+0x5c>
	fastboot_stage(lk2nd_dev.cmdline, strlen(lk2nd_dev.cmdline));
8f62d610:	e1a00004 	mov	r0, r4
{
8f62d614:	e5922000 	ldr	r2, [r2]
8f62d618:	e58d2004 	str	r2, [r13, #4]
8f62d61c:	e3a02000 	mov	r2, #0
	fastboot_stage(lk2nd_dev.cmdline, strlen(lk2nd_dev.cmdline));
8f62d620:	eb001c78 	bl	8f634808 <strlen>
8f62d624:	e59f3028 	ldr	r3, [pc, #40]	; 8f62d654 <cmd_oem_cmdline+0x5c>
8f62d628:	e5932000 	ldr	r2, [r3]
8f62d62c:	e59d3004 	ldr	r3, [r13, #4]
8f62d630:	e0332002 	eors	r2, r3, r2
8f62d634:	e3a03000 	mov	r3, #0
8f62d638:	1a000004 	bne	8f62d650 <cmd_oem_cmdline+0x58>
8f62d63c:	e1a01000 	mov	r1, r0
8f62d640:	e1a00004 	mov	r0, r4
}
8f62d644:	e28dd008 	add	r13, r13, #8
8f62d648:	e8bd4010 	pop	{r4, r14}
	fastboot_stage(lk2nd_dev.cmdline, strlen(lk2nd_dev.cmdline));
8f62d64c:	eafffe7f 	b	8f62d050 <fastboot_stage>
8f62d650:	eb00155a 	bl	8f632bc0 <__stack_chk_fail>
8f62d654:	8f74221c 	.word	0x8f74221c

8f62d658 <cmd_oem_pstore>:
{
8f62d658:	e59f3044 	ldr	r3, [pc, #68]	; 8f62d6a4 <cmd_oem_pstore+0x4c>
8f62d65c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62d660:	e24dd00c 	sub	r13, r13, #12
8f62d664:	e5933000 	ldr	r3, [r3]
8f62d668:	e58d3004 	str	r3, [r13, #4]
8f62d66c:	e3a03000 	mov	r3, #0
	fastboot_stage(lk2nd_dev.pstore, lk2nd_dev.pstore_size);
8f62d670:	e59f302c 	ldr	r3, [pc, #44]	; 8f62d6a4 <cmd_oem_pstore+0x4c>
8f62d674:	e5932000 	ldr	r2, [r3]
8f62d678:	e59d3004 	ldr	r3, [r13, #4]
8f62d67c:	e0332002 	eors	r2, r3, r2
8f62d680:	e3a03000 	mov	r3, #0
8f62d684:	1a000005 	bne	8f62d6a0 <cmd_oem_pstore+0x48>
8f62d688:	e301313c 	movw	r3, #4412	; 0x113c
8f62d68c:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62d690:	e1c302d4 	ldrd	r0, [r3, #36]	; 0x24
}
8f62d694:	e28dd00c 	add	r13, r13, #12
8f62d698:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	fastboot_stage(lk2nd_dev.pstore, lk2nd_dev.pstore_size);
8f62d69c:	eafffe6b 	b	8f62d050 <fastboot_stage>
8f62d6a0:	eb001546 	bl	8f632bc0 <__stack_chk_fail>
8f62d6a4:	8f74221c 	.word	0x8f74221c

8f62d6a8 <cmd_oem_dtb>:
	fastboot_stage(lk2nd_dev.fdt, fdt_totalsize(lk2nd_dev.fdt));
8f62d6a8:	e301313c 	movw	r3, #4412	; 0x113c
8f62d6ac:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f62d6b0:	e59f2058 	ldr	r2, [pc, #88]	; 8f62d710 <cmd_oem_dtb+0x68>
8f62d6b4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62d6b8:	e24dd00c 	sub	r13, r13, #12
	fastboot_stage(lk2nd_dev.fdt, fdt_totalsize(lk2nd_dev.fdt));
8f62d6bc:	e5930000 	ldr	r0, [r3]
{
8f62d6c0:	e5922000 	ldr	r2, [r2]
8f62d6c4:	e58d2004 	str	r2, [r13, #4]
8f62d6c8:	e3a02000 	mov	r2, #0
	fastboot_stage(lk2nd_dev.fdt, fdt_totalsize(lk2nd_dev.fdt));
8f62d6cc:	e59f303c 	ldr	r3, [pc, #60]	; 8f62d710 <cmd_oem_dtb+0x68>
8f62d6d0:	e5932000 	ldr	r2, [r3]
8f62d6d4:	e59d3004 	ldr	r3, [r13, #4]
8f62d6d8:	e0332002 	eors	r2, r3, r2
8f62d6dc:	e3a03000 	mov	r3, #0
8f62d6e0:	e5901004 	ldr	r1, [r0, #4]
8f62d6e4:	1a000008 	bne	8f62d70c <cmd_oem_dtb+0x64>
8f62d6e8:	e7e72451 	ubfx	r2, r1, #8, #8
8f62d6ec:	e1a03c21 	lsr	r3, r1, #24
8f62d6f0:	e1833c01 	orr	r3, r3, r1, lsl #24
8f62d6f4:	e7e71851 	ubfx	r1, r1, #16, #8
8f62d6f8:	e1833802 	orr	r3, r3, r2, lsl #16
8f62d6fc:	e1831401 	orr	r1, r3, r1, lsl #8
}
8f62d700:	e28dd00c 	add	r13, r13, #12
8f62d704:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	fastboot_stage(lk2nd_dev.fdt, fdt_totalsize(lk2nd_dev.fdt));
8f62d708:	eafffe50 	b	8f62d050 <fastboot_stage>
8f62d70c:	eb00152b 	bl	8f632bc0 <__stack_chk_fail>
8f62d710:	8f74221c 	.word	0x8f74221c

8f62d714 <cmd_oem_lk_log>:
{
8f62d714:	e59f304c 	ldr	r3, [pc, #76]	; 8f62d768 <cmd_oem_lk_log+0x54>
8f62d718:	e92d4010 	push	{r4, r14}
8f62d71c:	e24dd008 	sub	r13, r13, #8
8f62d720:	e5933000 	ldr	r3, [r3]
8f62d724:	e58d3004 	str	r3, [r13, #4]
8f62d728:	e3a03000 	mov	r3, #0
	fastboot_stage(lk_log_getbuf(), lk_log_getsize());
8f62d72c:	ebff53df 	bl	8f6026b0 <lk_log_getbuf>
8f62d730:	e1a04000 	mov	r4, r0
8f62d734:	ebff53ef 	bl	8f6026f8 <lk_log_getsize>
8f62d738:	e59f3028 	ldr	r3, [pc, #40]	; 8f62d768 <cmd_oem_lk_log+0x54>
8f62d73c:	e5932000 	ldr	r2, [r3]
8f62d740:	e59d3004 	ldr	r3, [r13, #4]
8f62d744:	e0332002 	eors	r2, r3, r2
8f62d748:	e3a03000 	mov	r3, #0
8f62d74c:	1a000004 	bne	8f62d764 <cmd_oem_lk_log+0x50>
8f62d750:	e1a01000 	mov	r1, r0
8f62d754:	e1a00004 	mov	r0, r4
}
8f62d758:	e28dd008 	add	r13, r13, #8
8f62d75c:	e8bd4010 	pop	{r4, r14}
	fastboot_stage(lk_log_getbuf(), lk_log_getsize());
8f62d760:	eafffe3a 	b	8f62d050 <fastboot_stage>
8f62d764:	eb001515 	bl	8f632bc0 <__stack_chk_fail>
8f62d768:	8f74221c 	.word	0x8f74221c

8f62d76c <fastboot_lk2nd_register_commands>:

void fastboot_lk2nd_register_commands(void) {
8f62d76c:	e92d4010 	push	{r4, r14}
#endif
#if WITH_DEBUG_LOG_BUF
	fastboot_register("oem lk_log", cmd_oem_lk_log);
#endif

	if (lk2nd_dev.fdt)
8f62d770:	e301413c 	movw	r4, #4412	; 0x113c
void fastboot_lk2nd_register_commands(void) {
8f62d774:	e59f30c4 	ldr	r3, [pc, #196]	; 8f62d840 <fastboot_lk2nd_register_commands+0xd4>
	if (lk2nd_dev.fdt)
8f62d778:	e3484f74 	movt	r4, #36724	; 0x8f74
void fastboot_lk2nd_register_commands(void) {
8f62d77c:	e24dd008 	sub	r13, r13, #8
	fastboot_register("oem lk_log", cmd_oem_lk_log);
8f62d780:	e30d1714 	movw	r1, #55060	; 0xd714
8f62d784:	e30a0388 	movw	r0, #41864	; 0xa388
8f62d788:	e3481f62 	movt	r1, #36706	; 0x8f62
8f62d78c:	e3480f70 	movt	r0, #36720	; 0x8f70
void fastboot_lk2nd_register_commands(void) {
8f62d790:	e5933000 	ldr	r3, [r3]
8f62d794:	e58d3004 	str	r3, [r13, #4]
8f62d798:	e3a03000 	mov	r3, #0
	fastboot_register("oem lk_log", cmd_oem_lk_log);
8f62d79c:	ebfffafb 	bl	8f62c390 <fastboot_register>
	if (lk2nd_dev.fdt)
8f62d7a0:	e5943000 	ldr	r3, [r4]
8f62d7a4:	e3530000 	cmp	r3, #0
8f62d7a8:	0a000004 	beq	8f62d7c0 <fastboot_lk2nd_register_commands+0x54>
		fastboot_register("oem dtb", cmd_oem_dtb);
8f62d7ac:	e30d16a8 	movw	r1, #54952	; 0xd6a8
8f62d7b0:	e30a0394 	movw	r0, #41876	; 0xa394
8f62d7b4:	e3481f62 	movt	r1, #36706	; 0x8f62
8f62d7b8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62d7bc:	ebfffaf3 	bl	8f62c390 <fastboot_register>

	if (lk2nd_dev.pstore)
8f62d7c0:	e5943024 	ldr	r3, [r4, #36]	; 0x24
8f62d7c4:	e3530000 	cmp	r3, #0
8f62d7c8:	0a000004 	beq	8f62d7e0 <fastboot_lk2nd_register_commands+0x74>
		fastboot_register("oem pstore", cmd_oem_pstore);
8f62d7cc:	e30d1658 	movw	r1, #54872	; 0xd658
8f62d7d0:	e30a039c 	movw	r0, #41884	; 0xa39c
8f62d7d4:	e3481f62 	movt	r1, #36706	; 0x8f62
8f62d7d8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62d7dc:	ebfffaeb 	bl	8f62c390 <fastboot_register>

	if (lk2nd_dev.cmdline)
8f62d7e0:	e5943008 	ldr	r3, [r4, #8]
8f62d7e4:	e3530000 	cmp	r3, #0
		fastboot_register("oem cmdline", cmd_oem_cmdline);
8f62d7e8:	e59f3050 	ldr	r3, [pc, #80]	; 8f62d840 <fastboot_lk2nd_register_commands+0xd4>
	if (lk2nd_dev.cmdline)
8f62d7ec:	0a00000b 	beq	8f62d820 <fastboot_lk2nd_register_commands+0xb4>
		fastboot_register("oem cmdline", cmd_oem_cmdline);
8f62d7f0:	e5932000 	ldr	r2, [r3]
8f62d7f4:	e59d3004 	ldr	r3, [r13, #4]
8f62d7f8:	e0332002 	eors	r2, r3, r2
8f62d7fc:	e3a03000 	mov	r3, #0
8f62d800:	1a00000d 	bne	8f62d83c <fastboot_lk2nd_register_commands+0xd0>
8f62d804:	e30d15f8 	movw	r1, #54776	; 0xd5f8
8f62d808:	e30a03a8 	movw	r0, #41896	; 0xa3a8
8f62d80c:	e3481f62 	movt	r1, #36706	; 0x8f62
8f62d810:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f62d814:	e28dd008 	add	r13, r13, #8
8f62d818:	e8bd4010 	pop	{r4, r14}
		fastboot_register("oem cmdline", cmd_oem_cmdline);
8f62d81c:	eafffadb 	b	8f62c390 <fastboot_register>
}
8f62d820:	e5932000 	ldr	r2, [r3]
8f62d824:	e59d3004 	ldr	r3, [r13, #4]
8f62d828:	e0332002 	eors	r2, r3, r2
8f62d82c:	e3a03000 	mov	r3, #0
8f62d830:	1a000001 	bne	8f62d83c <fastboot_lk2nd_register_commands+0xd0>
8f62d834:	e28dd008 	add	r13, r13, #8
8f62d838:	e8bd8010 	pop	{r4, r15}
8f62d83c:	eb0014df 	bl	8f632bc0 <__stack_chk_fail>
8f62d840:	8f74221c 	.word	0x8f74221c

8f62d844 <match_string>:
	}
	return result;
}

static bool match_string(const char *s, const char *match, size_t len)
{
8f62d844:	e92d4070 	push	{r4, r5, r6, r14}
8f62d848:	e1a04001 	mov	r4, r1
8f62d84c:	e59f30e8 	ldr	r3, [pc, #232]	; 8f62d93c <match_string+0xf8>
8f62d850:	e24dd010 	sub	r13, r13, #16
8f62d854:	e1a06000 	mov	r6, r0
	len = strnlen(match, len);
8f62d858:	e1a01002 	mov	r1, r2
8f62d85c:	e1a00004 	mov	r0, r4
{
8f62d860:	e5933000 	ldr	r3, [r3]
8f62d864:	e58d300c 	str	r3, [r13, #12]
8f62d868:	e3a03000 	mov	r3, #0
	len = strnlen(match, len);
8f62d86c:	eb001c21 	bl	8f6348f8 <strnlen>

	if (len > 0) {
8f62d870:	e2505000 	subs	r5, r0, #0
8f62d874:	0a000013 	beq	8f62d8c8 <match_string+0x84>
		if (match[len-1] == '*') {
8f62d878:	e2452001 	sub	r2, r5, #1
8f62d87c:	e7d43002 	ldrb	r3, [r4, r2]
8f62d880:	e353002a 	cmp	r3, #42	; 0x2a
8f62d884:	0a00001d 	beq	8f62d900 <match_string+0xbc>
				// *contains*
				return !!strstrl(s, match + 1, len - 2);

			// prefix* (starts with)
			len -= 2; // Don't match null terminator and '*'
		} else if (match[0] == '*') {
8f62d888:	e5d43000 	ldrb	r3, [r4]
8f62d88c:	e353002a 	cmp	r3, #42	; 0x2a
			++match; // Skip '*'
			s += slen - len; // Move to end of string
		}
	}

	return strncmp(s, match, len + 1) == 0;
8f62d890:	12852001 	addne	r2, r5, #1
		} else if (match[0] == '*') {
8f62d894:	1a00000c 	bne	8f62d8cc <match_string+0x88>
			size_t slen = strlen(s);
8f62d898:	e1a00006 	mov	r0, r6
8f62d89c:	e58d2004 	str	r2, [r13, #4]
8f62d8a0:	eb001bd8 	bl	8f634808 <strlen>
			if (slen < --len)
8f62d8a4:	e59d2004 	ldr	r2, [r13, #4]
8f62d8a8:	e1520000 	cmp	r2, r0
				return false;
8f62d8ac:	83a00000 	movhi	r0, #0
			if (slen < --len)
8f62d8b0:	8a00000a 	bhi	8f62d8e0 <match_string+0x9c>
			s += slen - len; // Move to end of string
8f62d8b4:	e0400002 	sub	r0, r0, r2
			++match; // Skip '*'
8f62d8b8:	e2844001 	add	r4, r4, #1
			s += slen - len; // Move to end of string
8f62d8bc:	e0866000 	add	r6, r6, r0
8f62d8c0:	e1a02005 	mov	r2, r5
8f62d8c4:	ea000000 	b	8f62d8cc <match_string+0x88>
8f62d8c8:	e3a02001 	mov	r2, #1
	return strncmp(s, match, len + 1) == 0;
8f62d8cc:	e1a01004 	mov	r1, r4
8f62d8d0:	e1a00006 	mov	r0, r6
8f62d8d4:	eb001be4 	bl	8f63486c <strncmp>
8f62d8d8:	e16f0f10 	clz	r0, r0
8f62d8dc:	e1a002a0 	lsr	r0, r0, #5
}
8f62d8e0:	e59f3054 	ldr	r3, [pc, #84]	; 8f62d93c <match_string+0xf8>
8f62d8e4:	e5932000 	ldr	r2, [r3]
8f62d8e8:	e59d300c 	ldr	r3, [r13, #12]
8f62d8ec:	e0332002 	eors	r2, r3, r2
8f62d8f0:	e3a03000 	mov	r3, #0
8f62d8f4:	1a00000f 	bne	8f62d938 <match_string+0xf4>
8f62d8f8:	e28dd010 	add	r13, r13, #16
8f62d8fc:	e8bd8070 	pop	{r4, r5, r6, r15}
			if (len > 1 && match[0] == '*')
8f62d900:	e3550001 	cmp	r5, #1
8f62d904:	0a000009 	beq	8f62d930 <match_string+0xec>
8f62d908:	e5d43000 	ldrb	r3, [r4]
8f62d90c:	e353002a 	cmp	r3, #42	; 0x2a
8f62d910:	1affffed 	bne	8f62d8cc <match_string+0x88>
				return !!strstrl(s, match + 1, len - 2);
8f62d914:	e2452002 	sub	r2, r5, #2
8f62d918:	e2841001 	add	r1, r4, #1
8f62d91c:	e1a00006 	mov	r0, r6
8f62d920:	eb001c61 	bl	8f634aac <strstrl>
8f62d924:	e2500000 	subs	r0, r0, #0
8f62d928:	13a00001 	movne	r0, #1
8f62d92c:	eaffffeb 	b	8f62d8e0 <match_string+0x9c>
8f62d930:	e3a02000 	mov	r2, #0
8f62d934:	eaffffe4 	b	8f62d8cc <match_string+0x88>
}
8f62d938:	eb0014a0 	bl	8f632bc0 <__stack_chk_fail>
8f62d93c:	8f74221c 	.word	0x8f74221c

8f62d940 <lk2nd_find_device_offset>:

	return true; // No match property
}

static int lk2nd_find_device_offset(const void *fdt)
{
8f62d940:	e59f31e8 	ldr	r3, [pc, #488]	; 8f62db30 <lk2nd_find_device_offset+0x1f0>
	int offset;

	offset = fdt_node_offset_by_compatible(fdt, -1, "lk2nd,device");
8f62d944:	e30a23b4 	movw	r2, #41908	; 0xa3b4
{
8f62d948:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
	offset = fdt_node_offset_by_compatible(fdt, -1, "lk2nd,device");
8f62d94c:	e3482f70 	movt	r2, #36720	; 0x8f70
{
8f62d950:	e24dd00c 	sub	r13, r13, #12
	offset = fdt_node_offset_by_compatible(fdt, -1, "lk2nd,device");
8f62d954:	e3e01000 	mvn	r1, #0
{
8f62d958:	e5933000 	ldr	r3, [r3]
8f62d95c:	e58d3004 	str	r3, [r13, #4]
8f62d960:	e3a03000 	mov	r3, #0
8f62d964:	e1a05000 	mov	r5, r0
	offset = fdt_node_offset_by_compatible(fdt, -1, "lk2nd,device");
8f62d968:	eb00204e 	bl	8f635aa8 <fdt_node_offset_by_compatible>
	while (offset >= 0) {
8f62d96c:	e2504000 	subs	r4, r0, #0
8f62d970:	ba00004e 	blt	8f62dab0 <lk2nd_find_device_offset+0x170>
	val = fdt_getprop(fdt, offset, "lk2nd,match-bootloader", &len);
8f62d974:	e30a63c4 	movw	r6, #41924	; 0xa3c4
	val = fdt_getprop(fdt, offset, "lk2nd,match-cmdline", &len);
8f62d978:	e30a7400 	movw	r7, #41984	; 0xa400
	val = fdt_getprop(fdt, offset, "lk2nd,match-device", &len);
8f62d97c:	e30a8414 	movw	r8, #42004	; 0xa414
	val = fdt_getprop(fdt, offset, "lk2nd,match-bootloader", &len);
8f62d980:	e3486f70 	movt	r6, #36720	; 0x8f70
	val = fdt_getprop(fdt, offset, "lk2nd,match-cmdline", &len);
8f62d984:	e3487f70 	movt	r7, #36720	; 0x8f70
	val = fdt_getprop(fdt, offset, "lk2nd,match-device", &len);
8f62d988:	e3488f70 	movt	r8, #36720	; 0x8f70
8f62d98c:	ea00000e 	b	8f62d9cc <lk2nd_find_device_offset+0x8c>
		if (!lk2nd_dev.bootloader) {
8f62d990:	e301313c 	movw	r3, #4412	; 0x113c
8f62d994:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62d998:	e5930010 	ldr	r0, [r3, #16]
8f62d99c:	e3500000 	cmp	r0, #0
8f62d9a0:	0a000032 	beq	8f62da70 <lk2nd_find_device_offset+0x130>
		return match_string(lk2nd_dev.device, val, len);
8f62d9a4:	ebffffa6 	bl	8f62d844 <match_string>
		if (lk2nd_device_match(fdt, offset))
8f62d9a8:	e3500000 	cmp	r0, #0
8f62d9ac:	1a00003f 	bne	8f62dab0 <lk2nd_find_device_offset+0x170>
			return offset;

		offset = fdt_node_offset_by_compatible(fdt, offset, "lk2nd,device");
8f62d9b0:	e1a01004 	mov	r1, r4
8f62d9b4:	e30a23b4 	movw	r2, #41908	; 0xa3b4
8f62d9b8:	e1a00005 	mov	r0, r5
8f62d9bc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62d9c0:	eb002038 	bl	8f635aa8 <fdt_node_offset_by_compatible>
	while (offset >= 0) {
8f62d9c4:	e2504000 	subs	r4, r0, #0
8f62d9c8:	ba000038 	blt	8f62dab0 <lk2nd_find_device_offset+0x170>
	val = fdt_getprop(fdt, offset, "lk2nd,match-bootloader", &len);
8f62d9cc:	e1a01004 	mov	r1, r4
8f62d9d0:	e1a0300d 	mov	r3, r13
8f62d9d4:	e1a02006 	mov	r2, r6
8f62d9d8:	e1a00005 	mov	r0, r5
8f62d9dc:	eb001fd3 	bl	8f635930 <fdt_getprop>
	if (val && len > 0) {
8f62d9e0:	e2501000 	subs	r1, r0, #0
8f62d9e4:	0a000002 	beq	8f62d9f4 <lk2nd_find_device_offset+0xb4>
8f62d9e8:	e59d2000 	ldr	r2, [r13]
8f62d9ec:	e3520000 	cmp	r2, #0
8f62d9f0:	caffffe6 	bgt	8f62d990 <lk2nd_find_device_offset+0x50>
	val = fdt_getprop(fdt, offset, "lk2nd,match-cmdline", &len);
8f62d9f4:	e1a01004 	mov	r1, r4
8f62d9f8:	e1a0300d 	mov	r3, r13
8f62d9fc:	e1a02007 	mov	r2, r7
8f62da00:	e1a00005 	mov	r0, r5
8f62da04:	eb001fc9 	bl	8f635930 <fdt_getprop>
	if (val && len > 0) {
8f62da08:	e2501000 	subs	r1, r0, #0
8f62da0c:	0a000008 	beq	8f62da34 <lk2nd_find_device_offset+0xf4>
8f62da10:	e59d2000 	ldr	r2, [r13]
8f62da14:	e3520000 	cmp	r2, #0
8f62da18:	da000005 	ble	8f62da34 <lk2nd_find_device_offset+0xf4>
		if (!lk2nd_dev.cmdline)
8f62da1c:	e301313c 	movw	r3, #4412	; 0x113c
8f62da20:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62da24:	e5930008 	ldr	r0, [r3, #8]
8f62da28:	e3500000 	cmp	r0, #0
8f62da2c:	1affffdc 	bne	8f62d9a4 <lk2nd_find_device_offset+0x64>
8f62da30:	eaffffde 	b	8f62d9b0 <lk2nd_find_device_offset+0x70>
	val = fdt_getprop(fdt, offset, "lk2nd,match-device", &len);
8f62da34:	e1a02008 	mov	r2, r8
8f62da38:	e1a01004 	mov	r1, r4
8f62da3c:	e1a0300d 	mov	r3, r13
8f62da40:	e1a00005 	mov	r0, r5
8f62da44:	eb001fb9 	bl	8f635930 <fdt_getprop>
	if (len >= 0) {
8f62da48:	e59d2000 	ldr	r2, [r13]
8f62da4c:	e3520000 	cmp	r2, #0
	val = fdt_getprop(fdt, offset, "lk2nd,match-device", &len);
8f62da50:	e1a01000 	mov	r1, r0
	if (len >= 0) {
8f62da54:	ba00000c 	blt	8f62da8c <lk2nd_find_device_offset+0x14c>
		if (!lk2nd_dev.device)
8f62da58:	e301313c 	movw	r3, #4412	; 0x113c
8f62da5c:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62da60:	e593000c 	ldr	r0, [r3, #12]
8f62da64:	e3500000 	cmp	r0, #0
8f62da68:	1affffcd 	bne	8f62d9a4 <lk2nd_find_device_offset+0x64>
8f62da6c:	eaffffcf 	b	8f62d9b0 <lk2nd_find_device_offset+0x70>
			if (lk2nd_dev.cmdline)
8f62da70:	e5933008 	ldr	r3, [r3, #8]
8f62da74:	e3530000 	cmp	r3, #0
8f62da78:	0affffcc 	beq	8f62d9b0 <lk2nd_find_device_offset+0x70>
				dprintf(CRITICAL, "Unknown bootloader, cannot match\n");
8f62da7c:	e30a03dc 	movw	r0, #41948	; 0xa3dc
8f62da80:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62da84:	eb0013ba 	bl	8f632974 <_dprintf>
8f62da88:	eaffffc8 	b	8f62d9b0 <lk2nd_find_device_offset+0x70>
	fdt_getprop(fdt, offset, "lk2nd,match-panel", &len);
8f62da8c:	e1a0300d 	mov	r3, r13
8f62da90:	e30a2428 	movw	r2, #42024	; 0xa428
8f62da94:	e1a01004 	mov	r1, r4
8f62da98:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62da9c:	e1a00005 	mov	r0, r5
8f62daa0:	eb001fa2 	bl	8f635930 <fdt_getprop>
	if (len >= 0) {
8f62daa4:	e59d3000 	ldr	r3, [r13]
8f62daa8:	e3530000 	cmp	r3, #0
8f62daac:	aa000008 	bge	8f62dad4 <lk2nd_find_device_offset+0x194>
	}

	return offset;
}
8f62dab0:	e59f3078 	ldr	r3, [pc, #120]	; 8f62db30 <lk2nd_find_device_offset+0x1f0>
8f62dab4:	e5932000 	ldr	r2, [r3]
8f62dab8:	e59d3004 	ldr	r3, [r13, #4]
8f62dabc:	e0332002 	eors	r2, r3, r2
8f62dac0:	e3a03000 	mov	r3, #0
8f62dac4:	1a000018 	bne	8f62db2c <lk2nd_find_device_offset+0x1ec>
8f62dac8:	e1a00004 	mov	r0, r4
8f62dacc:	e28dd00c 	add	r13, r13, #12
8f62dad0:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
		if (!lk2nd_dev.panel.name)
8f62dad4:	e301313c 	movw	r3, #4412	; 0x113c
8f62dad8:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62dadc:	e5939030 	ldr	r9, [r3, #48]	; 0x30
8f62dae0:	e3590000 	cmp	r9, #0
8f62dae4:	0affffb1 	beq	8f62d9b0 <lk2nd_find_device_offset+0x70>
	offset = fdt_subnode_offset(fdt, offset, "panel");
8f62dae8:	e1a01004 	mov	r1, r4
8f62daec:	e30a2434 	movw	r2, #42036	; 0xa434
8f62daf0:	e1a00005 	mov	r0, r5
8f62daf4:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62daf8:	eb001e5b 	bl	8f63546c <fdt_subnode_offset>
	if (offset < 0) {
8f62dafc:	e2501000 	subs	r1, r0, #0
8f62db00:	ba000005 	blt	8f62db1c <lk2nd_find_device_offset+0x1dc>
	return fdt_subnode_offset(fdt, offset, panel_name) >= 0;
8f62db04:	e1a02009 	mov	r2, r9
8f62db08:	e1a00005 	mov	r0, r5
8f62db0c:	eb001e56 	bl	8f63546c <fdt_subnode_offset>
8f62db10:	e1e00000 	mvn	r0, r0
8f62db14:	e1a00fa0 	lsr	r0, r0, #31
8f62db18:	eaffffa2 	b	8f62d9a8 <lk2nd_find_device_offset+0x68>
		dprintf(CRITICAL, "No panels defined, cannot match\n");
8f62db1c:	e30a043c 	movw	r0, #42044	; 0xa43c
8f62db20:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62db24:	eb001392 	bl	8f632974 <_dprintf>
		return false;
8f62db28:	eaffffa0 	b	8f62d9b0 <lk2nd_find_device_offset+0x70>
}
8f62db2c:	eb001423 	bl	8f632bc0 <__stack_chk_fail>
8f62db30:	8f74221c 	.word	0x8f74221c

8f62db34 <lk2nd_panic_hook>:

	arm_mmu_flush();
}

void lk2nd_panic_hook()
{
8f62db34:	e59f308c 	ldr	r3, [pc, #140]	; 8f62dbc8 <lk2nd_panic_hook+0x94>
8f62db38:	e92d4010 	push	{r4, r14}
8f62db3c:	e24dd008 	sub	r13, r13, #8
8f62db40:	e5933000 	ldr	r3, [r3]
8f62db44:	e58d3004 	str	r3, [r13, #4]
8f62db48:	e3a03000 	mov	r3, #0
	char *buf = lk_log_getbuf();
8f62db4c:	ebff52d7 	bl	8f6026b0 <lk_log_getbuf>
8f62db50:	e1a04000 	mov	r4, r0
	unsigned int size = lk_log_getsize();
8f62db54:	ebff52e7 	bl	8f6026f8 <lk_log_getsize>

	if (!lk2nd_dev.pstore)
8f62db58:	e301313c 	movw	r3, #4412	; 0x113c
8f62db5c:	e3483f74 	movt	r3, #36724	; 0x8f74
	unsigned int size = lk_log_getsize();
8f62db60:	e1a02000 	mov	r2, r0
	if (!lk2nd_dev.pstore)
8f62db64:	e5930024 	ldr	r0, [r3, #36]	; 0x24
8f62db68:	e3500000 	cmp	r0, #0
8f62db6c:	0a00000c 	beq	8f62dba4 <lk2nd_panic_hook+0x70>
		return;

	memcpy(lk2nd_dev.pstore, buf, MIN(size, lk2nd_dev.pstore_size));
8f62db70:	e59f1050 	ldr	r1, [pc, #80]	; 8f62dbc8 <lk2nd_panic_hook+0x94>
8f62db74:	e591c000 	ldr	r12, [r1]
8f62db78:	e59d1004 	ldr	r1, [r13, #4]
8f62db7c:	e031c00c 	eors	r12, r1, r12
8f62db80:	e3a01000 	mov	r1, #0
8f62db84:	1a00000e 	bne	8f62dbc4 <lk2nd_panic_hook+0x90>
8f62db88:	e5933028 	ldr	r3, [r3, #40]	; 0x28
8f62db8c:	e1a01004 	mov	r1, r4
8f62db90:	e1520003 	cmp	r2, r3
8f62db94:	21a02003 	movcs	r2, r3
}
8f62db98:	e28dd008 	add	r13, r13, #8
8f62db9c:	e8bd4010 	pop	{r4, r14}
	memcpy(lk2nd_dev.pstore, buf, MIN(size, lk2nd_dev.pstore_size));
8f62dba0:	ea001984 	b	8f6341b8 <memcpy>
}
8f62dba4:	e59f301c 	ldr	r3, [pc, #28]	; 8f62dbc8 <lk2nd_panic_hook+0x94>
8f62dba8:	e5932000 	ldr	r2, [r3]
8f62dbac:	e59d3004 	ldr	r3, [r13, #4]
8f62dbb0:	e0332002 	eors	r2, r3, r2
8f62dbb4:	e3a03000 	mov	r3, #0
8f62dbb8:	1a000001 	bne	8f62dbc4 <lk2nd_panic_hook+0x90>
8f62dbbc:	e28dd008 	add	r13, r13, #8
8f62dbc0:	e8bd8010 	pop	{r4, r15}
8f62dbc4:	eb0013fd 	bl	8f632bc0 <__stack_chk_fail>
8f62dbc8:	8f74221c 	.word	0x8f74221c

8f62dbcc <lk2nd_clear_pstore>:
	lk2nd_parse_device_node(fdt);
}

void lk2nd_clear_pstore()
{
	if (lk2nd_dev.pstore) {
8f62dbcc:	e301313c 	movw	r3, #4412	; 0x113c
8f62dbd0:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f62dbd4:	e59f206c 	ldr	r2, [pc, #108]	; 8f62dc48 <lk2nd_clear_pstore+0x7c>
	if (lk2nd_dev.pstore) {
8f62dbd8:	e5930024 	ldr	r0, [r3, #36]	; 0x24
{
8f62dbdc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	if (lk2nd_dev.pstore) {
8f62dbe0:	e3500000 	cmp	r0, #0
{
8f62dbe4:	e24dd00c 	sub	r13, r13, #12
8f62dbe8:	e5922000 	ldr	r2, [r2]
8f62dbec:	e58d2004 	str	r2, [r13, #4]
8f62dbf0:	e3a02000 	mov	r2, #0
	if (lk2nd_dev.pstore) {
8f62dbf4:	0a00000a 	beq	8f62dc24 <lk2nd_clear_pstore+0x58>
		memset(lk2nd_dev.pstore, '\n', lk2nd_dev.pstore_size);
8f62dbf8:	e59f2048 	ldr	r2, [pc, #72]	; 8f62dc48 <lk2nd_clear_pstore+0x7c>
8f62dbfc:	e5921000 	ldr	r1, [r2]
8f62dc00:	e59d2004 	ldr	r2, [r13, #4]
8f62dc04:	e0321001 	eors	r1, r2, r1
8f62dc08:	e3a02000 	mov	r2, #0
8f62dc0c:	1a00000c 	bne	8f62dc44 <lk2nd_clear_pstore+0x78>
8f62dc10:	e5932028 	ldr	r2, [r3, #40]	; 0x28
8f62dc14:	e3a0100a 	mov	r1, #10
	}
}
8f62dc18:	e28dd00c 	add	r13, r13, #12
8f62dc1c:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		memset(lk2nd_dev.pstore, '\n', lk2nd_dev.pstore_size);
8f62dc20:	ea0019a7 	b	8f6342c4 <memset>
}
8f62dc24:	e59f301c 	ldr	r3, [pc, #28]	; 8f62dc48 <lk2nd_clear_pstore+0x7c>
8f62dc28:	e5932000 	ldr	r2, [r3]
8f62dc2c:	e59d3004 	ldr	r3, [r13, #4]
8f62dc30:	e0332002 	eors	r2, r3, r2
8f62dc34:	e3a03000 	mov	r3, #0
8f62dc38:	1a000001 	bne	8f62dc44 <lk2nd_clear_pstore+0x78>
8f62dc3c:	e28dd00c 	add	r13, r13, #12
8f62dc40:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f62dc44:	eb0013dd 	bl	8f632bc0 <__stack_chk_fail>
8f62dc48:	8f74221c 	.word	0x8f74221c

8f62dc4c <lk2nd_init>:
		dprintf(CRITICAL, "ERROR: Couldn't determine slot suffix of %s\n", lk2nd_dev.slot_suffix);
	}
}

void lk2nd_init(void)
{
8f62dc4c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
	dprintf(INFO, "Board: platform: %u, foundry: %#x, platform_version: %#x, "
8f62dc50:	e3018320 	movw	r8, #4896	; 0x1320
{
8f62dc54:	e59f3830 	ldr	r3, [pc, #2096]	; 8f62e48c <lk2nd_init+0x840>
	dprintf(INFO, "Board: platform: %u, foundry: %#x, platform_version: %#x, "
8f62dc58:	e3488f71 	movt	r8, #36721	; 0x8f71
{
8f62dc5c:	e24dd03c 	sub	r13, r13, #60	; 0x3c
	dprintf(INFO, "Board: platform: %u, foundry: %#x, platform_version: %#x, "
8f62dc60:	e30a0460 	movw	r0, #42080	; 0xa460
{
8f62dc64:	e5933000 	ldr	r3, [r3]
8f62dc68:	e58d3034 	str	r3, [r13, #52]	; 0x34
8f62dc6c:	e3a03000 	mov	r3, #0
	dprintf(INFO, "Board: platform: %u, foundry: %#x, platform_version: %#x, "
8f62dc70:	e5981050 	ldr	r1, [r8, #80]	; 0x50
8f62dc74:	e1c821d8 	ldrd	r2, [r8, #24]
8f62dc78:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62dc7c:	e58de018 	str	r14, [r13, #24]
		dprintf(INFO, "pmic_info[%u]: type: %#x, version: %#x, target: %#x\n",
8f62dc80:	e30a64fc 	movw	r6, #42236	; 0xa4fc
	dprintf(INFO, "Board: platform: %u, foundry: %#x, platform_version: %#x, "
8f62dc84:	e58d1010 	str	r1, [r13, #16]
		dprintf(INFO, "pmic_info[%u]: type: %#x, version: %#x, target: %#x\n",
8f62dc88:	e3486f70 	movt	r6, #36720	; 0x8f70
	dprintf(INFO, "Board: platform: %u, foundry: %#x, platform_version: %#x, "
8f62dc8c:	e58d300c 	str	r3, [r13, #12]
8f62dc90:	e1a04008 	mov	r4, r8
8f62dc94:	e5983014 	ldr	r3, [r8, #20]
	for (i = 0; i < MAX_PMIC_DEVICES; ++i) {
8f62dc98:	e3a05000 	mov	r5, #0
	dprintf(INFO, "Board: platform: %u, foundry: %#x, platform_version: %#x, "
8f62dc9c:	e5981010 	ldr	r1, [r8, #16]
8f62dca0:	e58d2008 	str	r2, [r13, #8]
8f62dca4:	e58d3004 	str	r3, [r13, #4]
8f62dca8:	e598300c 	ldr	r3, [r8, #12]
8f62dcac:	e5982004 	ldr	r2, [r8, #4]
8f62dcb0:	e58d1000 	str	r1, [r13]
8f62dcb4:	e5981000 	ldr	r1, [r8]
8f62dcb8:	eb00132d 	bl	8f632974 <_dprintf>
		if (board.pmic_info[i].pmic_type == PMIC_IS_INVALID)
8f62dcbc:	e5942020 	ldr	r2, [r4, #32]
8f62dcc0:	e3720106 	cmn	r2, #-2147483647	; 0x80000001
8f62dcc4:	0a000005 	beq	8f62dce0 <lk2nd_init+0x94>
		dprintf(INFO, "pmic_info[%u]: type: %#x, version: %#x, target: %#x\n",
8f62dcc8:	e594c028 	ldr	r12, [r4, #40]	; 0x28
8f62dccc:	e1a01005 	mov	r1, r5
8f62dcd0:	e5943024 	ldr	r3, [r4, #36]	; 0x24
8f62dcd4:	e1a00006 	mov	r0, r6
8f62dcd8:	e58dc000 	str	r12, [r13]
8f62dcdc:	eb001324 	bl	8f632974 <_dprintf>
	for (i = 0; i < MAX_PMIC_DEVICES; ++i) {
8f62dce0:	e2855001 	add	r5, r5, #1
8f62dce4:	e284400c 	add	r4, r4, #12
8f62dce8:	e3550004 	cmp	r5, #4
8f62dcec:	1afffff2 	bne	8f62dcbc <lk2nd_init+0x70>
	void *fdt = (void*) lk_boot_args[2];
8f62dcf0:	e300307c 	movw	r3, #124	; 0x7c
8f62dcf4:	e3483f60 	movt	r3, #36704	; 0x8f60
8f62dcf8:	e5937008 	ldr	r7, [r3, #8]
	if (!fdt)
8f62dcfc:	e3570000 	cmp	r7, #0
8f62dd00:	1a000029 	bne	8f62ddac <lk2nd_init+0x160>
	if (!partition_multislot_is_supported())
8f62dd04:	ebff5e80 	bl	8f60570c <partition_multislot_is_supported>
8f62dd08:	e3500000 	cmp	r0, #0
8f62dd0c:	0a000152 	beq	8f62e25c <lk2nd_init+0x610>
	if (strcmp(lk2nd_dev.slot_suffix, "_a") == 0) {
8f62dd10:	e301313c 	movw	r3, #4412	; 0x113c
8f62dd14:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62dd18:	e30113fc 	movw	r1, #5116	; 0x13fc
8f62dd1c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62dd20:	e5935020 	ldr	r5, [r3, #32]
8f62dd24:	e1a00005 	mov	r0, r5
8f62dd28:	eb0019fd 	bl	8f634524 <strcmp>
8f62dd2c:	e2504000 	subs	r4, r0, #0
8f62dd30:	0a000012 	beq	8f62dd80 <lk2nd_init+0x134>
	} else if (strcmp(lk2nd_dev.slot_suffix, "_b") == 0) {
8f62dd34:	e3011400 	movw	r1, #5120	; 0x1400
8f62dd38:	e1a00005 	mov	r0, r5
8f62dd3c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62dd40:	eb0019f7 	bl	8f634524 <strcmp>
8f62dd44:	e3500000 	cmp	r0, #0
8f62dd48:	1a00014b 	bne	8f62e27c <lk2nd_init+0x630>
		dprintf(INFO, "Marking Slot B as successful.\n");
8f62dd4c:	e30a076c 	movw	r0, #42860	; 0xa76c
8f62dd50:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62dd54:	eb001306 	bl	8f632974 <_dprintf>
		partition_reset_retry_count(SLOT_B);
8f62dd58:	e59f372c 	ldr	r3, [pc, #1836]	; 8f62e48c <lk2nd_init+0x840>
8f62dd5c:	e5932000 	ldr	r2, [r3]
8f62dd60:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f62dd64:	e0332002 	eors	r2, r3, r2
8f62dd68:	e3a03000 	mov	r3, #0
8f62dd6c:	03a00001 	moveq	r0, #1
8f62dd70:	1a00000c 	bne	8f62dda8 <lk2nd_init+0x15c>
	dump_board();
	lk2nd_fdt_parse();
	lk2nd_handle_multislot();
}
8f62dd74:	e28dd03c 	add	r13, r13, #60	; 0x3c
8f62dd78:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
		partition_reset_retry_count(SLOT_B);
8f62dd7c:	eaff5c06 	b	8f604d9c <partition_reset_retry_count>
		dprintf(INFO, "Marking Slot A as successful.\n");
8f62dd80:	e30a074c 	movw	r0, #42828	; 0xa74c
8f62dd84:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62dd88:	eb0012f9 	bl	8f632974 <_dprintf>
		partition_reset_retry_count(SLOT_A);
8f62dd8c:	e59f36f8 	ldr	r3, [pc, #1784]	; 8f62e48c <lk2nd_init+0x840>
8f62dd90:	e5932000 	ldr	r2, [r3]
8f62dd94:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f62dd98:	e0332002 	eors	r2, r3, r2
8f62dd9c:	e3a03000 	mov	r3, #0
8f62dda0:	01a00004 	moveq	r0, r4
8f62dda4:	0afffff2 	beq	8f62dd74 <lk2nd_init+0x128>
}
8f62dda8:	eb001384 	bl	8f632bc0 <__stack_chk_fail>
	if (dev_tree_check_header(fdt)) {
8f62ddac:	e1a00007 	mov	r0, r7
8f62ddb0:	ebffaf0b 	bl	8f6199e4 <dev_tree_check_header>
8f62ddb4:	e3500000 	cmp	r0, #0
8f62ddb8:	1a000141 	bne	8f62e2c4 <lk2nd_init+0x678>
	lk2nd_dev.fdt = fdt;
8f62ddbc:	e301613c 	movw	r6, #4412	; 0x113c
8f62ddc0:	e3486f74 	movt	r6, #36724	; 0x8f74
	if (dev_tree_get_board_id(fdt, &board_id) == 0) {
8f62ddc4:	e28d102c 	add	r1, r13, #44	; 0x2c
8f62ddc8:	e1a00007 	mov	r0, r7
	lk2nd_dev.fdt = fdt;
8f62ddcc:	e5867000 	str	r7, [r6]
	if (dev_tree_get_board_id(fdt, &board_id) == 0) {
8f62ddd0:	ebffaf5a 	bl	8f619b40 <dev_tree_get_board_id>
8f62ddd4:	e3500000 	cmp	r0, #0
8f62ddd8:	0a00013d 	beq	8f62e2d4 <lk2nd_init+0x688>
	lk2nd_dev.cmdline = dev_tree_get_boot_args(fdt);
8f62dddc:	e1a00007 	mov	r0, r7
8f62dde0:	ebffaf19 	bl	8f619a4c <dev_tree_get_boot_args>
	if (lk2nd_dev.cmdline) {
8f62dde4:	e3500000 	cmp	r0, #0
	lk2nd_dev.cmdline = dev_tree_get_boot_args(fdt);
8f62dde8:	e5860008 	str	r0, [r6, #8]
	if (lk2nd_dev.cmdline) {
8f62ddec:	0a0000ad 	beq	8f62e0a8 <lk2nd_init+0x45c>
		dprintf(INFO, "Command line from primary bootloader: ");
8f62ddf0:	e30a05ec 	movw	r0, #42476	; 0xa5ec
8f62ddf4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62ddf8:	eb0012dd 	bl	8f632974 <_dprintf>
		dputs(INFO, lk2nd_dev.cmdline);
8f62ddfc:	e5960008 	ldr	r0, [r6, #8]
8f62de00:	eb0012c2 	bl	8f632910 <_dputs>
		dputc(INFO, '\n');
8f62de04:	e3a0000a 	mov	r0, #10
8f62de08:	ebff524d 	bl	8f602744 <_dputc>
	char *args = strdup(lk2nd_dev.cmdline);
8f62de0c:	e5960008 	ldr	r0, [r6, #8]
8f62de10:	eb0019f4 	bl	8f6345e8 <strdup>
	char *arg = strtok_r(args, " ", &saveptr);
8f62de14:	e28da028 	add	r10, r13, #40	; 0x28
8f62de18:	e3061c7c 	movw	r1, #27772	; 0x6c7c
8f62de1c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62de20:	e1a0200a 	mov	r2, r10
	char *args = strdup(lk2nd_dev.cmdline);
8f62de24:	e58d001c 	str	r0, [r13, #28]
	char *arg = strtok_r(args, " ", &saveptr);
8f62de28:	eb001b45 	bl	8f634b44 <strtok_r>
	while (arg) {
8f62de2c:	e2505000 	subs	r5, r0, #0
8f62de30:	0a00007e 	beq	8f62e030 <lk2nd_init+0x3e4>
	int len = strlen(pre);
8f62de34:	e30a8614 	movw	r8, #42516	; 0xa614
8f62de38:	e30ab668 	movw	r11, #42600	; 0xa668
8f62de3c:	e30a9624 	movw	r9, #42532	; 0xa624
8f62de40:	e3488f70 	movt	r8, #36720	; 0x8f70
8f62de44:	e348bf70 	movt	r11, #36720	; 0x8f70
8f62de48:	e3489f70 	movt	r9, #36720	; 0x8f70
8f62de4c:	ea000060 	b	8f62dfd4 <lk2nd_init+0x388>
		if (aboot) {
8f62de50:	e0954004 	adds	r4, r5, r4
8f62de54:	0a000067 	beq	8f62dff8 <lk2nd_init+0x3ac>
	int len = strlen(pre);
8f62de58:	e1a00009 	mov	r0, r9
8f62de5c:	eb001a69 	bl	8f634808 <strlen>
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62de60:	e1a01004 	mov	r1, r4
8f62de64:	e1a02000 	mov	r2, r0
	int len = strlen(pre);
8f62de68:	e1a05000 	mov	r5, r0
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62de6c:	e1a00009 	mov	r0, r9
8f62de70:	eb001a7d 	bl	8f63486c <strncmp>
8f62de74:	e3500000 	cmp	r0, #0
8f62de78:	1a000003 	bne	8f62de8c <lk2nd_init+0x240>
	if (val)
8f62de7c:	e0940005 	adds	r0, r4, r5
8f62de80:	0a000001 	beq	8f62de8c <lk2nd_init+0x240>
		*out = strdup(val);
8f62de84:	eb0019d7 	bl	8f6345e8 <strdup>
8f62de88:	e586000c 	str	r0, [r6, #12]
	int len = strlen(pre);
8f62de8c:	e30a062c 	movw	r0, #42540	; 0xa62c
8f62de90:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62de94:	eb001a5b 	bl	8f634808 <strlen>
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62de98:	e1a01004 	mov	r1, r4
8f62de9c:	e1a02000 	mov	r2, r0
	int len = strlen(pre);
8f62dea0:	e1a05000 	mov	r5, r0
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62dea4:	e30a062c 	movw	r0, #42540	; 0xa62c
8f62dea8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62deac:	eb001a6e 	bl	8f63486c <strncmp>
8f62deb0:	e3500000 	cmp	r0, #0
8f62deb4:	1a000003 	bne	8f62dec8 <lk2nd_init+0x27c>
	if (val)
8f62deb8:	e0940005 	adds	r0, r4, r5
8f62debc:	0a000001 	beq	8f62dec8 <lk2nd_init+0x27c>
		*out = strdup(val);
8f62dec0:	eb0019c8 	bl	8f6345e8 <strdup>
8f62dec4:	e5860010 	str	r0, [r6, #16]
	int len = strlen(pre);
8f62dec8:	e30a0638 	movw	r0, #42552	; 0xa638
8f62decc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62ded0:	eb001a4c 	bl	8f634808 <strlen>
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62ded4:	e1a01004 	mov	r1, r4
8f62ded8:	e1a02000 	mov	r2, r0
	int len = strlen(pre);
8f62dedc:	e1a05000 	mov	r5, r0
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62dee0:	e30a0638 	movw	r0, #42552	; 0xa638
8f62dee4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62dee8:	eb001a5f 	bl	8f63486c <strncmp>
8f62deec:	e3500000 	cmp	r0, #0
8f62def0:	1a000003 	bne	8f62df04 <lk2nd_init+0x2b8>
	if (val)
8f62def4:	e0940005 	adds	r0, r4, r5
8f62def8:	0a000001 	beq	8f62df04 <lk2nd_init+0x2b8>
		*out = strdup(val);
8f62defc:	eb0019b9 	bl	8f6345e8 <strdup>
8f62df00:	e5860014 	str	r0, [r6, #20]
	int len = strlen(pre);
8f62df04:	e30a0644 	movw	r0, #42564	; 0xa644
8f62df08:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62df0c:	eb001a3d 	bl	8f634808 <strlen>
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62df10:	e1a01004 	mov	r1, r4
8f62df14:	e1a02000 	mov	r2, r0
	int len = strlen(pre);
8f62df18:	e1a05000 	mov	r5, r0
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62df1c:	e30a0644 	movw	r0, #42564	; 0xa644
8f62df20:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62df24:	eb001a50 	bl	8f63486c <strncmp>
8f62df28:	e3500000 	cmp	r0, #0
8f62df2c:	1a000003 	bne	8f62df40 <lk2nd_init+0x2f4>
	if (val)
8f62df30:	e0940005 	adds	r0, r4, r5
8f62df34:	0a000001 	beq	8f62df40 <lk2nd_init+0x2f4>
		*out = strdup(val);
8f62df38:	eb0019aa 	bl	8f6345e8 <strdup>
8f62df3c:	e5860018 	str	r0, [r6, #24]
	int len = strlen(pre);
8f62df40:	e30a0650 	movw	r0, #42576	; 0xa650
8f62df44:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62df48:	eb001a2e 	bl	8f634808 <strlen>
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62df4c:	e1a01004 	mov	r1, r4
8f62df50:	e1a02000 	mov	r2, r0
	int len = strlen(pre);
8f62df54:	e1a05000 	mov	r5, r0
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62df58:	e30a0650 	movw	r0, #42576	; 0xa650
8f62df5c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62df60:	eb001a41 	bl	8f63486c <strncmp>
8f62df64:	e3500000 	cmp	r0, #0
8f62df68:	1a000003 	bne	8f62df7c <lk2nd_init+0x330>
	if (val)
8f62df6c:	e0940005 	adds	r0, r4, r5
8f62df70:	0a000001 	beq	8f62df7c <lk2nd_init+0x330>
		*out = strdup(val);
8f62df74:	eb00199b 	bl	8f6345e8 <strdup>
8f62df78:	e586001c 	str	r0, [r6, #28]
	int len = strlen(pre);
8f62df7c:	e30a0658 	movw	r0, #42584	; 0xa658
8f62df80:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62df84:	eb001a1f 	bl	8f634808 <strlen>
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62df88:	e1a01004 	mov	r1, r4
8f62df8c:	e1a02000 	mov	r2, r0
	int len = strlen(pre);
8f62df90:	e1a05000 	mov	r5, r0
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62df94:	e30a0658 	movw	r0, #42584	; 0xa658
8f62df98:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62df9c:	eb001a32 	bl	8f63486c <strncmp>
8f62dfa0:	e3500000 	cmp	r0, #0
8f62dfa4:	1a000003 	bne	8f62dfb8 <lk2nd_init+0x36c>
	if (val)
8f62dfa8:	e0940005 	adds	r0, r4, r5
8f62dfac:	0a000001 	beq	8f62dfb8 <lk2nd_init+0x36c>
		*out = strdup(val);
8f62dfb0:	eb00198c 	bl	8f6345e8 <strdup>
8f62dfb4:	e5860020 	str	r0, [r6, #32]
		arg = strtok_r(NULL, " ", &saveptr);
8f62dfb8:	e1a0200a 	mov	r2, r10
8f62dfbc:	e3061c7c 	movw	r1, #27772	; 0x6c7c
8f62dfc0:	e3a00000 	mov	r0, #0
8f62dfc4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62dfc8:	eb001add 	bl	8f634b44 <strtok_r>
	while (arg) {
8f62dfcc:	e2505000 	subs	r5, r0, #0
8f62dfd0:	0a000016 	beq	8f62e030 <lk2nd_init+0x3e4>
	int len = strlen(pre);
8f62dfd4:	e1a00008 	mov	r0, r8
8f62dfd8:	eb001a0a 	bl	8f634808 <strlen>
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62dfdc:	e1a01005 	mov	r1, r5
8f62dfe0:	e1a02000 	mov	r2, r0
	int len = strlen(pre);
8f62dfe4:	e1a04000 	mov	r4, r0
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62dfe8:	e1a00008 	mov	r0, r8
8f62dfec:	eb001a1e 	bl	8f63486c <strncmp>
8f62dff0:	e3500000 	cmp	r0, #0
8f62dff4:	0affff95 	beq	8f62de50 <lk2nd_init+0x204>
	int len = strlen(pre);
8f62dff8:	e1a0000b 	mov	r0, r11
8f62dffc:	eb001a01 	bl	8f634808 <strlen>
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62e000:	e1a01005 	mov	r1, r5
8f62e004:	e1a02000 	mov	r2, r0
	int len = strlen(pre);
8f62e008:	e1a04000 	mov	r4, r0
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62e00c:	e1a0000b 	mov	r0, r11
8f62e010:	eb001a15 	bl	8f63486c <strncmp>
8f62e014:	e3500000 	cmp	r0, #0
8f62e018:	1affffe6 	bne	8f62dfb8 <lk2nd_init+0x36c>
	if (val)
8f62e01c:	e0950004 	adds	r0, r5, r4
8f62e020:	0affffe4 	beq	8f62dfb8 <lk2nd_init+0x36c>
		*out = strdup(val);
8f62e024:	eb00196f 	bl	8f6345e8 <strdup>
8f62e028:	e5860030 	str	r0, [r6, #48]	; 0x30
8f62e02c:	eaffffe1 	b	8f62dfb8 <lk2nd_init+0x36c>
	free(args);
8f62e030:	e59d001c 	ldr	r0, [r13, #28]
8f62e034:	eb001834 	bl	8f63410c <free>
	lk2nd_dev.panel.name = parse_panel(lk2nd_dev.panel.name);
8f62e038:	e5964030 	ldr	r4, [r6, #48]	; 0x30
	if (!panel)
8f62e03c:	e3540000 	cmp	r4, #0
8f62e040:	0a0000cd 	beq	8f62e37c <lk2nd_init+0x730>
	int len = strlen(pre);
8f62e044:	e30a0678 	movw	r0, #42616	; 0xa678
8f62e048:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e04c:	eb0019ed 	bl	8f634808 <strlen>
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62e050:	e1a01004 	mov	r1, r4
8f62e054:	e1a02000 	mov	r2, r0
	int len = strlen(pre);
8f62e058:	e1a05000 	mov	r5, r0
	return strncmp(pre, str, len) == 0 ? str + len : NULL;
8f62e05c:	e30a0678 	movw	r0, #42616	; 0xa678
8f62e060:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e064:	eb001a00 	bl	8f63486c <strncmp>
8f62e068:	e2508000 	subs	r8, r0, #0
8f62e06c:	1a0000c2 	bne	8f62e37c <lk2nd_init+0x730>
	if (!panel_name) /* Some other format */
8f62e070:	e0944005 	adds	r4, r4, r5
8f62e074:	0a0000c0 	beq	8f62e37c <lk2nd_init+0x730>
	end = strchr(panel_name, ':');
8f62e078:	e3a0103a 	mov	r1, #58	; 0x3a
8f62e07c:	e1a00004 	mov	r0, r4
8f62e080:	eb00190c 	bl	8f6344b8 <strchr>
	if (strcmp(panel_name, "none") == 0)
8f62e084:	e3071e14 	movw	r1, #32276	; 0x7e14
8f62e088:	e3481f70 	movt	r1, #36720	; 0x8f70
	if (end)
8f62e08c:	e3500000 	cmp	r0, #0
		*end = 0;
8f62e090:	15c08000 	strbne	r8, [r0]
	if (strcmp(panel_name, "none") == 0)
8f62e094:	e1a00004 	mov	r0, r4
8f62e098:	eb001921 	bl	8f634524 <strcmp>
8f62e09c:	e3500000 	cmp	r0, #0
8f62e0a0:	0a0000b5 	beq	8f62e37c <lk2nd_init+0x730>
	lk2nd_dev.panel.name = parse_panel(lk2nd_dev.panel.name);
8f62e0a4:	e5864030 	str	r4, [r6, #48]	; 0x30
	int offset = lk2nd_find_device_offset(fdt);
8f62e0a8:	e1a00007 	mov	r0, r7
8f62e0ac:	ebfffe23 	bl	8f62d940 <lk2nd_find_device_offset>
	if (offset < 0) {
8f62e0b0:	e2504000 	subs	r4, r0, #0
		dprintf(CRITICAL, "Failed to find matching lk2nd,device node: %d\n", offset);
8f62e0b4:	e1a01004 	mov	r1, r4
	if (offset < 0) {
8f62e0b8:	ba0000b1 	blt	8f62e384 <lk2nd_init+0x738>
	lk2nd_samsung_muic_reset(fdt, offset);
8f62e0bc:	e1a00007 	mov	r0, r7
	val = fdt_getprop(fdt, offset, prop, &len);
8f62e0c0:	e28da028 	add	r10, r13, #40	; 0x28
	lk2nd_samsung_muic_reset(fdt, offset);
8f62e0c4:	eb0001ec 	bl	8f62e87c <lk2nd_samsung_muic_reset>
	lk2nd_motorola_smem_write_unit_info(fdt, offset);
8f62e0c8:	e1a01004 	mov	r1, r4
8f62e0cc:	e1a00007 	mov	r0, r7
8f62e0d0:	eb000152 	bl	8f62e620 <lk2nd_motorola_smem_write_unit_info>
	val = fdt_getprop(fdt, offset, prop, &len);
8f62e0d4:	e1a0300a 	mov	r3, r10
8f62e0d8:	e30528c8 	movw	r2, #22728	; 0x58c8
8f62e0dc:	e1a01004 	mov	r1, r4
8f62e0e0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62e0e4:	e1a00007 	mov	r0, r7
8f62e0e8:	eb001e10 	bl	8f635930 <fdt_getprop>
	if (val && len > 0) {
8f62e0ec:	e2508000 	subs	r8, r0, #0
8f62e0f0:	0a00006d 	beq	8f62e2ac <lk2nd_init+0x660>
8f62e0f4:	e59d0028 	ldr	r0, [r13, #40]	; 0x28
8f62e0f8:	e3500000 	cmp	r0, #0
8f62e0fc:	da00006a 	ble	8f62e2ac <lk2nd_init+0x660>
		result = malloc(len);
8f62e100:	eb0017bd 	bl	8f633ffc <malloc>
		ASSERT(result);
8f62e104:	e2505000 	subs	r5, r0, #0
8f62e108:	0a0000be 	beq	8f62e408 <lk2nd_init+0x7bc>
		strlcpy(result, val, len);
8f62e10c:	e1a01008 	mov	r1, r8
8f62e110:	e59d2028 	ldr	r2, [r13, #40]	; 0x28
8f62e114:	eb001985 	bl	8f634730 <strlcpy>
		dprintf(INFO, "Device model: %s\n", lk2nd_dev.model);
8f62e118:	e30a07bc 	movw	r0, #42940	; 0xa7bc
8f62e11c:	e1a01005 	mov	r1, r5
8f62e120:	e3480f70 	movt	r0, #36720	; 0x8f70
	lk2nd_dev.model = fdt_copyprop_str(fdt, offset, "model");
8f62e124:	e5865004 	str	r5, [r6, #4]
		dprintf(INFO, "Device model: %s\n", lk2nd_dev.model);
8f62e128:	eb001211 	bl	8f632974 <_dprintf>
	pstore = fdt_getprop(fdt, offset, "lk2nd,pstore", &len);
8f62e12c:	e28d3020 	add	r3, r13, #32
8f62e130:	e30a2704 	movw	r2, #42756	; 0xa704
8f62e134:	e1a01004 	mov	r1, r4
8f62e138:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62e13c:	e1a00007 	mov	r0, r7
8f62e140:	eb001dfa 	bl	8f635930 <fdt_getprop>
	if (pstore && len == 2 * sizeof(*pstore)) {
8f62e144:	e3500000 	cmp	r0, #0
8f62e148:	0a000002 	beq	8f62e158 <lk2nd_init+0x50c>
8f62e14c:	e59d3020 	ldr	r3, [r13, #32]
8f62e150:	e3530008 	cmp	r3, #8
8f62e154:	0a00008e 	beq	8f62e394 <lk2nd_init+0x748>
	if (lk2nd_dev.panel.name)
8f62e158:	e5963030 	ldr	r3, [r6, #48]	; 0x30
8f62e15c:	e3530000 	cmp	r3, #0
8f62e160:	0afffee7 	beq	8f62dd04 <lk2nd_init+0xb8>
	offset = fdt_subnode_offset(fdt, offset, "panel");
8f62e164:	e1a01004 	mov	r1, r4
8f62e168:	e30a2434 	movw	r2, #42036	; 0xa434
8f62e16c:	e1a00007 	mov	r0, r7
8f62e170:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62e174:	eb001cbc 	bl	8f63546c <fdt_subnode_offset>
	if (offset < 0)
8f62e178:	e2504000 	subs	r4, r0, #0
8f62e17c:	bafffee0 	blt	8f62dd04 <lk2nd_init+0xb8>
	val = fdt_getprop(fdt, offset, prop, len);
8f62e180:	e28d3024 	add	r3, r13, #36	; 0x24
8f62e184:	e30a2714 	movw	r2, #42772	; 0xa714
8f62e188:	e1a01004 	mov	r1, r4
8f62e18c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62e190:	e1a00007 	mov	r0, r7
8f62e194:	eb001de5 	bl	8f635930 <fdt_getprop>
	if (!val || *len < 1)
8f62e198:	e2505000 	subs	r5, r0, #0
8f62e19c:	0afffed8 	beq	8f62dd04 <lk2nd_init+0xb8>
8f62e1a0:	e59d1024 	ldr	r1, [r13, #36]	; 0x24
8f62e1a4:	e3510000 	cmp	r1, #0
8f62e1a8:	dafffed5 	ble	8f62dd04 <lk2nd_init+0xb8>
	*len = strnlen(val, *len);
8f62e1ac:	eb0019d1 	bl	8f6348f8 <strnlen>
	if (!old || old_len < 1)
8f62e1b0:	e3500000 	cmp	r0, #0
	*len = strnlen(val, *len);
8f62e1b4:	e58d0024 	str	r0, [r13, #36]	; 0x24
	if (!old || old_len < 1)
8f62e1b8:	dafffed1 	ble	8f62dd04 <lk2nd_init+0xb8>
	offset = fdt_subnode_offset(fdt, offset, panel->name);
8f62e1bc:	e1a01004 	mov	r1, r4
8f62e1c0:	e5962030 	ldr	r2, [r6, #48]	; 0x30
8f62e1c4:	e1a00007 	mov	r0, r7
8f62e1c8:	eb001ca7 	bl	8f63546c <fdt_subnode_offset>
	if (offset < 0) {
8f62e1cc:	e2501000 	subs	r1, r0, #0
8f62e1d0:	ba00009c 	blt	8f62e448 <lk2nd_init+0x7fc>
	val = fdt_getprop(fdt, offset, prop, len);
8f62e1d4:	e1a0300a 	mov	r3, r10
8f62e1d8:	e1a00007 	mov	r0, r7
8f62e1dc:	e30a2714 	movw	r2, #42772	; 0xa714
8f62e1e0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62e1e4:	eb001dd1 	bl	8f635930 <fdt_getprop>
	if (!val || *len < 1)
8f62e1e8:	e2504000 	subs	r4, r0, #0
8f62e1ec:	0afffec4 	beq	8f62dd04 <lk2nd_init+0xb8>
8f62e1f0:	e59d1028 	ldr	r1, [r13, #40]	; 0x28
8f62e1f4:	e3510000 	cmp	r1, #0
8f62e1f8:	dafffec1 	ble	8f62dd04 <lk2nd_init+0xb8>
	*len = strnlen(val, *len);
8f62e1fc:	eb0019bd 	bl	8f6348f8 <strnlen>
	if (!new || new_len < 1)
8f62e200:	e3500000 	cmp	r0, #0
8f62e204:	dafffebe 	ble	8f62dd04 <lk2nd_init+0xb8>
	panel->compatible_size = ++new_len + ++old_len;
8f62e208:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f62e20c:	e2800001 	add	r0, r0, #1
8f62e210:	e58d0028 	str	r0, [r13, #40]	; 0x28
8f62e214:	e2833001 	add	r3, r3, #1
8f62e218:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f62e21c:	e0800003 	add	r0, r0, r3
8f62e220:	e586003c 	str	r0, [r6, #60]	; 0x3c
	panel->compatible = malloc(panel->compatible_size);
8f62e224:	eb001774 	bl	8f633ffc <malloc>
	ASSERT(panel->compatible);
8f62e228:	e3500000 	cmp	r0, #0
	panel->compatible = malloc(panel->compatible_size);
8f62e22c:	e5860038 	str	r0, [r6, #56]	; 0x38
	ASSERT(panel->compatible);
8f62e230:	0a000089 	beq	8f62e45c <lk2nd_init+0x810>
	panel->old_compatible = panel->compatible + new_len;
8f62e234:	e59d2028 	ldr	r2, [r13, #40]	; 0x28
	strlcpy((char*) panel->compatible, new, new_len);
8f62e238:	e1a01004 	mov	r1, r4
	panel->old_compatible = panel->compatible + new_len;
8f62e23c:	e0803002 	add	r3, r0, r2
8f62e240:	e5863034 	str	r3, [r6, #52]	; 0x34
	strlcpy((char*) panel->compatible, new, new_len);
8f62e244:	eb001939 	bl	8f634730 <strlcpy>
	strlcpy((char*) panel->old_compatible, old, old_len);
8f62e248:	e59d2024 	ldr	r2, [r13, #36]	; 0x24
8f62e24c:	e5960034 	ldr	r0, [r6, #52]	; 0x34
8f62e250:	e1a01005 	mov	r1, r5
8f62e254:	eb001935 	bl	8f634730 <strlcpy>
8f62e258:	eafffea9 	b	8f62dd04 <lk2nd_init+0xb8>
}
8f62e25c:	e59f3228 	ldr	r3, [pc, #552]	; 8f62e48c <lk2nd_init+0x840>
8f62e260:	e5932000 	ldr	r2, [r3]
8f62e264:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f62e268:	e0332002 	eors	r2, r3, r2
8f62e26c:	e3a03000 	mov	r3, #0
8f62e270:	1afffecc 	bne	8f62dda8 <lk2nd_init+0x15c>
8f62e274:	e28dd03c 	add	r13, r13, #60	; 0x3c
8f62e278:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		dprintf(CRITICAL, "ERROR: Couldn't determine slot suffix of %s\n", lk2nd_dev.slot_suffix);
8f62e27c:	e59f3208 	ldr	r3, [pc, #520]	; 8f62e48c <lk2nd_init+0x840>
8f62e280:	e5932000 	ldr	r2, [r3]
8f62e284:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f62e288:	e0332002 	eors	r2, r3, r2
8f62e28c:	e3a03000 	mov	r3, #0
8f62e290:	1afffec4 	bne	8f62dda8 <lk2nd_init+0x15c>
8f62e294:	e30a078c 	movw	r0, #42892	; 0xa78c
8f62e298:	e1a01005 	mov	r1, r5
8f62e29c:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f62e2a0:	e28dd03c 	add	r13, r13, #60	; 0x3c
8f62e2a4:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
		dprintf(CRITICAL, "ERROR: Couldn't determine slot suffix of %s\n", lk2nd_dev.slot_suffix);
8f62e2a8:	ea0011b1 	b	8f632974 <_dprintf>
	lk2nd_dev.model = fdt_copyprop_str(fdt, offset, "model");
8f62e2ac:	e3a03000 	mov	r3, #0
8f62e2b0:	e5863004 	str	r3, [r6, #4]
		dprintf(CRITICAL, "Device node is missing 'model' property\n");
8f62e2b4:	e30a06d8 	movw	r0, #42712	; 0xa6d8
8f62e2b8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e2bc:	eb0011ac 	bl	8f632974 <_dprintf>
8f62e2c0:	eaffff99 	b	8f62e12c <lk2nd_init+0x4e0>
		dprintf(INFO, "Invalid device tree provided by primary bootloader\n");
8f62e2c4:	e30a0534 	movw	r0, #42292	; 0xa534
8f62e2c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e2cc:	eb0011a8 	bl	8f632974 <_dprintf>
		return;
8f62e2d0:	eafffe8b 	b	8f62dd04 <lk2nd_init+0xb8>
		update_board_id(&board_id);
8f62e2d4:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
	uint32_t hw_subtype = board_id->platform_subtype & 0xff;
8f62e2d8:	e5dd9030 	ldrb	r9, [r13, #48]	; 0x30
	uint32_t target_id = board_id->variant_id & 0xffff00;
8f62e2dc:	e3c344ff 	bic	r4, r3, #-16777216	; 0xff000000
	uint32_t hw_id = board_id->variant_id & 0xff;
8f62e2e0:	e6ef5073 	uxtb	r5, r3
	if (board_hardware_id() != hw_id) {
8f62e2e4:	ebff87de 	bl	8f610264 <board_hardware_id>
	uint32_t target_id = board_id->variant_id & 0xffff00;
8f62e2e8:	e3c440ff 	bic	r4, r4, #255	; 0xff
	if (board_hardware_id() != hw_id) {
8f62e2ec:	e1550000 	cmp	r5, r0
8f62e2f0:	0a000006 	beq	8f62e310 <lk2nd_init+0x6c4>
		dprintf(INFO, "Updating board hardware id: 0x%x -> 0x%x\n",
8f62e2f4:	ebff87da 	bl	8f610264 <board_hardware_id>
8f62e2f8:	e1a02005 	mov	r2, r5
8f62e2fc:	e1a01000 	mov	r1, r0
8f62e300:	e30a0568 	movw	r0, #42344	; 0xa568
8f62e304:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e308:	eb001199 	bl	8f632974 <_dprintf>
		board.platform_hw = hw_id;
8f62e30c:	e5885010 	str	r5, [r8, #16]
	if (board_hardware_subtype() != hw_subtype) {
8f62e310:	ebff87e6 	bl	8f6102b0 <board_hardware_subtype>
8f62e314:	e1590000 	cmp	r9, r0
8f62e318:	0a000006 	beq	8f62e338 <lk2nd_init+0x6ec>
		dprintf(INFO, "Updating board hardware subtype: 0x%x -> 0x%x\n",
8f62e31c:	ebff87e3 	bl	8f6102b0 <board_hardware_subtype>
8f62e320:	e1a02009 	mov	r2, r9
8f62e324:	e1a01000 	mov	r1, r0
8f62e328:	e30a0594 	movw	r0, #42388	; 0xa594
8f62e32c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e330:	eb00118f 	bl	8f632974 <_dprintf>
		board.platform_subtype = hw_subtype;
8f62e334:	e5889014 	str	r9, [r8, #20]
	if (!(target_id < (board_target_id() & 0xffff00))) {
8f62e338:	ebff87b6 	bl	8f610218 <board_target_id>
8f62e33c:	e3c004ff 	bic	r0, r0, #-16777216	; 0xff000000
8f62e340:	e3c000ff 	bic	r0, r0, #255	; 0xff
8f62e344:	e1540000 	cmp	r4, r0
8f62e348:	3afffea3 	bcc	8f62dddc <lk2nd_init+0x190>
		target_id |= board_target_id() & ~0xffff00;
8f62e34c:	ebff87b1 	bl	8f610218 <board_target_id>
8f62e350:	e3c038ff 	bic	r3, r0, #16711680	; 0xff0000
8f62e354:	e3c33cff 	bic	r3, r3, #65280	; 0xff00
8f62e358:	e1834004 	orr	r4, r3, r4
		dprintf(INFO, "Updating board target id: 0x%x -> 0x%x\n",
8f62e35c:	ebff87ad 	bl	8f610218 <board_target_id>
8f62e360:	e1a02004 	mov	r2, r4
8f62e364:	e1a01000 	mov	r1, r0
8f62e368:	e30a05c4 	movw	r0, #42436	; 0xa5c4
8f62e36c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e370:	eb00117f 	bl	8f632974 <_dprintf>
		board.target = target_id;
8f62e374:	e5884018 	str	r4, [r8, #24]
8f62e378:	eafffe97 	b	8f62dddc <lk2nd_init+0x190>
		return NULL;
8f62e37c:	e3a04000 	mov	r4, #0
8f62e380:	eaffff47 	b	8f62e0a4 <lk2nd_init+0x458>
		dprintf(CRITICAL, "Failed to find matching lk2nd,device node: %d\n", offset);
8f62e384:	e30a0684 	movw	r0, #42628	; 0xa684
8f62e388:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e38c:	eb001178 	bl	8f632974 <_dprintf>
		return;
8f62e390:	eafffe5b 	b	8f62dd04 <lk2nd_init+0xb8>
		lk2nd_pstore_map(fdt32_to_cpu(pstore[0]),
8f62e394:	e1c020d0 	ldrd	r2, [r0]
8f62e398:	e7e70452 	ubfx	r0, r2, #8, #8
8f62e39c:	e7e71453 	ubfx	r1, r3, #8, #8
8f62e3a0:	e1a05c22 	lsr	r5, r2, #24
8f62e3a4:	e1a08c23 	lsr	r8, r3, #24
8f62e3a8:	e1855c02 	orr	r5, r5, r2, lsl #24
8f62e3ac:	e1888c03 	orr	r8, r8, r3, lsl #24
8f62e3b0:	e7e72852 	ubfx	r2, r2, #16, #8
8f62e3b4:	e7e73853 	ubfx	r3, r3, #16, #8
8f62e3b8:	e1855800 	orr	r5, r5, r0, lsl #16
8f62e3bc:	e1888801 	orr	r8, r8, r1, lsl #16
8f62e3c0:	e1855402 	orr	r5, r5, r2, lsl #8
8f62e3c4:	e1888403 	orr	r8, r8, r3, lsl #8
	for ( ; phys < ((uint32_t) lk2nd_dev.pstore) + size; phys += 0x100000 ) {
8f62e3c8:	e0853008 	add	r3, r5, r8
	lk2nd_dev.pstore = (void *) phys;
8f62e3cc:	e5865024 	str	r5, [r6, #36]	; 0x24
	for ( ; phys < ((uint32_t) lk2nd_dev.pstore) + size; phys += 0x100000 ) {
8f62e3d0:	e1550003 	cmp	r5, r3
	lk2nd_dev.pstore_size = size;
8f62e3d4:	e5868028 	str	r8, [r6, #40]	; 0x28
	for ( ; phys < ((uint32_t) lk2nd_dev.pstore) + size; phys += 0x100000 ) {
8f62e3d8:	2a000008 	bcs	8f62e400 <lk2nd_init+0x7b4>
		arm_mmu_map_section(phys, phys, 0
8f62e3dc:	e1a01005 	mov	r1, r5
8f62e3e0:	e1a00005 	mov	r0, r5
8f62e3e4:	e3002c18 	movw	r2, #3096	; 0xc18
	for ( ; phys < ((uint32_t) lk2nd_dev.pstore) + size; phys += 0x100000 ) {
8f62e3e8:	e2855601 	add	r5, r5, #1048576	; 0x100000
		arm_mmu_map_section(phys, phys, 0
8f62e3ec:	ebffccaf 	bl	8f6216b0 <arm_mmu_map_section>
	for ( ; phys < ((uint32_t) lk2nd_dev.pstore) + size; phys += 0x100000 ) {
8f62e3f0:	e5963024 	ldr	r3, [r6, #36]	; 0x24
8f62e3f4:	e0833008 	add	r3, r3, r8
8f62e3f8:	e1550003 	cmp	r5, r3
8f62e3fc:	3afffff6 	bcc	8f62e3dc <lk2nd_init+0x790>
	arm_mmu_flush();
8f62e400:	ebffcced 	bl	8f6217bc <arm_mmu_flush>
}
8f62e404:	eaffff53 	b	8f62e158 <lk2nd_init+0x50c>
		ASSERT(result);
8f62e408:	e59d0018 	ldr	r0, [r13, #24]
8f62e40c:	e3a0308d 	mov	r3, #141	; 0x8d
8f62e410:	e30a26d0 	movw	r2, #42704	; 0xa6d0
8f62e414:	e3001130 	movw	r1, #304	; 0x130
8f62e418:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62e41c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62e420:	e58d2000 	str	r2, [r13]
8f62e424:	e30a26b4 	movw	r2, #42676	; 0xa6b4
8f62e428:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62e42c:	eb0011a2 	bl	8f632abc <_panic>
		strlcpy(result, val, len);
8f62e430:	e59d2028 	ldr	r2, [r13, #40]	; 0x28
8f62e434:	e1a01008 	mov	r1, r8
8f62e438:	e1a00005 	mov	r0, r5
8f62e43c:	eb0018bb 	bl	8f634730 <strlcpy>
	lk2nd_dev.model = fdt_copyprop_str(fdt, offset, "model");
8f62e440:	e5865004 	str	r5, [r6, #4]
	if (lk2nd_dev.model)
8f62e444:	eaffff9a 	b	8f62e2b4 <lk2nd_init+0x668>
		dprintf(CRITICAL, "Unsupported panel: %s\n", panel->name);
8f62e448:	e5961030 	ldr	r1, [r6, #48]	; 0x30
8f62e44c:	e30a0720 	movw	r0, #42784	; 0xa720
8f62e450:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e454:	eb001146 	bl	8f632974 <_dprintf>
		return;
8f62e458:	eafffe29 	b	8f62dd04 <lk2nd_init+0xb8>
	ASSERT(panel->compatible);
8f62e45c:	e59d0018 	ldr	r0, [r13, #24]
8f62e460:	e30a3738 	movw	r3, #42808	; 0xa738
8f62e464:	e30a26b4 	movw	r2, #42676	; 0xa6b4
8f62e468:	e3483f70 	movt	r3, #36720	; 0x8f70
8f62e46c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62e470:	e58d3000 	str	r3, [r13]
8f62e474:	e3001130 	movw	r1, #304	; 0x130
8f62e478:	e3a03e13 	mov	r3, #304	; 0x130
8f62e47c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62e480:	eb00118d 	bl	8f632abc <_panic>
	panel->old_compatible = panel->compatible + new_len;
8f62e484:	e5960038 	ldr	r0, [r6, #56]	; 0x38
8f62e488:	eaffff69 	b	8f62e234 <lk2nd_init+0x5e8>
8f62e48c:	8f74221c 	.word	0x8f74221c

8f62e490 <lk2nd_update_device_tree>:
	if (ret)
		dprintf(CRITICAL, "Failed to update panel compatible: %d\n", ret);
}

void lk2nd_update_device_tree(void *fdt, const char *cmdline)
{
8f62e490:	e1a02001 	mov	r2, r1
8f62e494:	e59f30f0 	ldr	r3, [pc, #240]	; 8f62e58c <lk2nd_update_device_tree+0xfc>
8f62e498:	e92d4030 	push	{r4, r5, r14}
	/* Don't touch lk2nd/downstream dtb */
	if (strstr(cmdline, "lk2nd"))
8f62e49c:	e3011004 	movw	r1, #4100	; 0x1004
{
8f62e4a0:	e24dd014 	sub	r13, r13, #20
	if (strstr(cmdline, "lk2nd"))
8f62e4a4:	e3481f70 	movt	r1, #36720	; 0x8f70
{
8f62e4a8:	e1a04000 	mov	r4, r0
	if (strstr(cmdline, "lk2nd"))
8f62e4ac:	e1a00002 	mov	r0, r2
{
8f62e4b0:	e5933000 	ldr	r3, [r3]
8f62e4b4:	e58d300c 	str	r3, [r13, #12]
8f62e4b8:	e3a03000 	mov	r3, #0
	if (strstr(cmdline, "lk2nd"))
8f62e4bc:	eb001951 	bl	8f634a08 <strstr>
8f62e4c0:	e3500000 	cmp	r0, #0
8f62e4c4:	0a000007 	beq	8f62e4e8 <lk2nd_update_device_tree+0x58>
		return;

	if (lk2nd_dev.panel.compatible)
		lk2nd_update_panel_compatible(fdt);
}
8f62e4c8:	e59f30bc 	ldr	r3, [pc, #188]	; 8f62e58c <lk2nd_update_device_tree+0xfc>
8f62e4cc:	e5932000 	ldr	r2, [r3]
8f62e4d0:	e59d300c 	ldr	r3, [r13, #12]
8f62e4d4:	e0332002 	eors	r2, r3, r2
8f62e4d8:	e3a03000 	mov	r3, #0
8f62e4dc:	1a000029 	bne	8f62e588 <lk2nd_update_device_tree+0xf8>
8f62e4e0:	e28dd014 	add	r13, r13, #20
8f62e4e4:	e8bd8030 	pop	{r4, r5, r15}
	if (lk2nd_dev.panel.compatible)
8f62e4e8:	e301513c 	movw	r5, #4412	; 0x113c
8f62e4ec:	e3485f74 	movt	r5, #36724	; 0x8f74
8f62e4f0:	e5953038 	ldr	r3, [r5, #56]	; 0x38
8f62e4f4:	e3530000 	cmp	r3, #0
8f62e4f8:	0afffff2 	beq	8f62e4c8 <lk2nd_update_device_tree+0x38>
	offset = fdt_node_offset_by_compatible(fdt, -1, panel->old_compatible);
8f62e4fc:	e3e01000 	mvn	r1, #0
8f62e500:	e5952034 	ldr	r2, [r5, #52]	; 0x34
8f62e504:	e1a00004 	mov	r0, r4
8f62e508:	eb001d66 	bl	8f635aa8 <fdt_node_offset_by_compatible>
	if (offset < 0) {
8f62e50c:	e2501000 	subs	r1, r0, #0
8f62e510:	ba000013 	blt	8f62e564 <lk2nd_update_device_tree+0xd4>
	ret = fdt_setprop(fdt, offset, "compatible", panel->compatible, panel->compatible_size);
8f62e514:	e595c03c 	ldr	r12, [r5, #60]	; 0x3c
8f62e518:	e30a2714 	movw	r2, #42772	; 0xa714
8f62e51c:	e5953038 	ldr	r3, [r5, #56]	; 0x38
8f62e520:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62e524:	e1a00004 	mov	r0, r4
8f62e528:	e58dc000 	str	r12, [r13]
8f62e52c:	eb001f31 	bl	8f6361f8 <fdt_setprop>
	if (ret)
8f62e530:	e2501000 	subs	r1, r0, #0
8f62e534:	0affffe3 	beq	8f62e4c8 <lk2nd_update_device_tree+0x38>
		dprintf(CRITICAL, "Failed to update panel compatible: %d\n", ret);
8f62e538:	e59f304c 	ldr	r3, [pc, #76]	; 8f62e58c <lk2nd_update_device_tree+0xfc>
8f62e53c:	e5932000 	ldr	r2, [r3]
8f62e540:	e59d300c 	ldr	r3, [r13, #12]
8f62e544:	e0332002 	eors	r2, r3, r2
8f62e548:	e3a03000 	mov	r3, #0
8f62e54c:	030a0800 	movweq	r0, #43008	; 0xa800
8f62e550:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62e554:	1a00000b 	bne	8f62e588 <lk2nd_update_device_tree+0xf8>
}
8f62e558:	e28dd014 	add	r13, r13, #20
8f62e55c:	e8bd4030 	pop	{r4, r5, r14}
		dprintf(CRITICAL, "Failed to update panel compatible: %d\n", ret);
8f62e560:	ea001103 	b	8f632974 <_dprintf>
		dprintf(CRITICAL, "Failed to find panel node with compatible: %s\n",
8f62e564:	e59f3020 	ldr	r3, [pc, #32]	; 8f62e58c <lk2nd_update_device_tree+0xfc>
8f62e568:	e5932000 	ldr	r2, [r3]
8f62e56c:	e59d300c 	ldr	r3, [r13, #12]
8f62e570:	e0332002 	eors	r2, r3, r2
8f62e574:	e3a03000 	mov	r3, #0
8f62e578:	030a07d0 	movweq	r0, #42960	; 0xa7d0
8f62e57c:	05951034 	ldreq	r1, [r5, #52]	; 0x34
8f62e580:	03480f70 	movteq	r0, #36720	; 0x8f70
8f62e584:	0afffff3 	beq	8f62e558 <lk2nd_update_device_tree+0xc8>
}
8f62e588:	eb00118c 	bl	8f632bc0 <__stack_chk_fail>
8f62e58c:	8f74221c 	.word	0x8f74221c

8f62e590 <fdt_getprop_u32>:

#define SMEM_ID_VENDOR0          0x86
#define SMEM_KERNEL_RESERVE      SMEM_ID_VENDOR0
#define SMEM_KERNEL_RESERVE_SIZE 1024

static void fdt_getprop_u32(const void *fdt, int offset, const char *name, uint32_t *val) {
8f62e590:	e92d4030 	push	{r4, r5, r14}
8f62e594:	e1a04003 	mov	r4, r3
8f62e598:	e24dd00c 	sub	r13, r13, #12
8f62e59c:	e59f3078 	ldr	r3, [pc, #120]	; 8f62e61c <fdt_getprop_u32+0x8c>
8f62e5a0:	e1a05002 	mov	r5, r2
8f62e5a4:	e5933000 	ldr	r3, [r3]
8f62e5a8:	e58d3004 	str	r3, [r13, #4]
8f62e5ac:	e3a03000 	mov	r3, #0
	int len;
	const uint32_t *prop = fdt_getprop(fdt, offset, name, &len);
8f62e5b0:	e1a0300d 	mov	r3, r13
8f62e5b4:	eb001cdd 	bl	8f635930 <fdt_getprop>
	if (len == sizeof(*val))
8f62e5b8:	e59d3000 	ldr	r3, [r13]
8f62e5bc:	e3530004 	cmp	r3, #4
8f62e5c0:	1a00000f 	bne	8f62e604 <fdt_getprop_u32+0x74>
		*val = fdt32_to_cpu(*prop);
8f62e5c4:	e5903000 	ldr	r3, [r0]
8f62e5c8:	e7e70453 	ubfx	r0, r3, #8, #8
8f62e5cc:	e7e71853 	ubfx	r1, r3, #16, #8
8f62e5d0:	e1a02c23 	lsr	r2, r3, #24
8f62e5d4:	e1822c03 	orr	r2, r2, r3, lsl #24
8f62e5d8:	e1822800 	orr	r2, r2, r0, lsl #16
8f62e5dc:	e1822401 	orr	r2, r2, r1, lsl #8
8f62e5e0:	e5842000 	str	r2, [r4]
	else
		dprintf(CRITICAL, "Failed to get prop %s in device tree\n", name);
}
8f62e5e4:	e59f3030 	ldr	r3, [pc, #48]	; 8f62e61c <fdt_getprop_u32+0x8c>
8f62e5e8:	e5932000 	ldr	r2, [r3]
8f62e5ec:	e59d3004 	ldr	r3, [r13, #4]
8f62e5f0:	e0332002 	eors	r2, r3, r2
8f62e5f4:	e3a03000 	mov	r3, #0
8f62e5f8:	1a000006 	bne	8f62e618 <fdt_getprop_u32+0x88>
8f62e5fc:	e28dd00c 	add	r13, r13, #12
8f62e600:	e8bd8030 	pop	{r4, r5, r15}
		dprintf(CRITICAL, "Failed to get prop %s in device tree\n", name);
8f62e604:	e30a0828 	movw	r0, #43048	; 0xa828
8f62e608:	e1a01005 	mov	r1, r5
8f62e60c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e610:	eb0010d7 	bl	8f632974 <_dprintf>
}
8f62e614:	eafffff2 	b	8f62e5e4 <fdt_getprop_u32+0x54>
8f62e618:	eb001168 	bl	8f632bc0 <__stack_chk_fail>
8f62e61c:	8f74221c 	.word	0x8f74221c

8f62e620 <lk2nd_motorola_smem_write_unit_info>:

void lk2nd_motorola_smem_write_unit_info(const void *fdt, int offset)
{
8f62e620:	e59f3250 	ldr	r3, [pc, #592]	; 8f62e878 <lk2nd_motorola_smem_write_unit_info+0x258>
	int chosen_offset, len, ret = 0;
	const char *baseband;
	struct mmi_unit_info *unit_info;

	fdt_getprop(fdt, offset, "lk2nd,motorola-unitinfo", &len);
8f62e624:	e30a2850 	movw	r2, #43088	; 0xa850
{
8f62e628:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
8f62e62c:	e24dd030 	sub	r13, r13, #48	; 0x30
8f62e630:	e5933000 	ldr	r3, [r3]
8f62e634:	e58d302c 	str	r3, [r13, #44]	; 0x2c
8f62e638:	e3a03000 	mov	r3, #0
	fdt_getprop(fdt, offset, "lk2nd,motorola-unitinfo", &len);
8f62e63c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62e640:	e28d3028 	add	r3, r13, #40	; 0x28
{
8f62e644:	e1a05000 	mov	r5, r0
	fdt_getprop(fdt, offset, "lk2nd,motorola-unitinfo", &len);
8f62e648:	eb001cb8 	bl	8f635930 <fdt_getprop>
	if (len < 0)
8f62e64c:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f62e650:	e3530000 	cmp	r3, #0
8f62e654:	ba000076 	blt	8f62e834 <lk2nd_motorola_smem_write_unit_info+0x214>
		return;

	chosen_offset = fdt_path_offset(fdt, "/chosen");
8f62e658:	e3061144 	movw	r1, #24900	; 0x6144
8f62e65c:	e1a00005 	mov	r0, r5
8f62e660:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62e664:	eb001c3a 	bl	8f635754 <fdt_path_offset>
	if (chosen_offset < 0) {
8f62e668:	e2506000 	subs	r6, r0, #0
8f62e66c:	ba00007c 	blt	8f62e864 <lk2nd_motorola_smem_write_unit_info+0x244>
		dprintf(CRITICAL, "Failed to get /chosen node in device tree\n");
		return;
	}

	unit_info = malloc(SMEM_KERNEL_RESERVE_SIZE);
8f62e670:	e3a00b01 	mov	r0, #1024	; 0x400
	memset(unit_info, 0, SMEM_KERNEL_RESERVE_SIZE);

	unit_info->version = MMI_UNIT_INFO_VER;

	if (lk2nd_dev.serialno)
8f62e674:	e301713c 	movw	r7, #4412	; 0x113c
	unit_info = malloc(SMEM_KERNEL_RESERVE_SIZE);
8f62e678:	eb00165f 	bl	8f633ffc <malloc>
	if (lk2nd_dev.serialno)
8f62e67c:	e3487f74 	movt	r7, #36724	; 0x8f74
	memset(unit_info, 0, SMEM_KERNEL_RESERVE_SIZE);
8f62e680:	e3a01000 	mov	r1, #0
8f62e684:	e3a02b01 	mov	r2, #1024	; 0x400
	unit_info = malloc(SMEM_KERNEL_RESERVE_SIZE);
8f62e688:	e1a04000 	mov	r4, r0
	memset(unit_info, 0, SMEM_KERNEL_RESERVE_SIZE);
8f62e68c:	eb00170c 	bl	8f6342c4 <memset>
	if (lk2nd_dev.serialno)
8f62e690:	e5971014 	ldr	r1, [r7, #20]
	unit_info->version = MMI_UNIT_INFO_VER;
8f62e694:	e3a03003 	mov	r3, #3
		strlcpy(unit_info->barcode, lk2nd_dev.serialno, BARCODE_MAX_LEN);
8f62e698:	e2848031 	add	r8, r4, #49	; 0x31
	unit_info->version = MMI_UNIT_INFO_VER;
8f62e69c:	e5843000 	str	r3, [r4]
	if (lk2nd_dev.serialno)
8f62e6a0:	e3510000 	cmp	r1, #0
8f62e6a4:	0a000002 	beq	8f62e6b4 <lk2nd_motorola_smem_write_unit_info+0x94>
		strlcpy(unit_info->barcode, lk2nd_dev.serialno, BARCODE_MAX_LEN);
8f62e6a8:	e3a02041 	mov	r2, #65	; 0x41
8f62e6ac:	e1a00008 	mov	r0, r8
8f62e6b0:	eb00181e 	bl	8f634730 <strlcpy>
	if (lk2nd_dev.carrier)
8f62e6b4:	e5971018 	ldr	r1, [r7, #24]
		strlcpy(unit_info->carrier, lk2nd_dev.carrier, CARRIER_MAX_LEN);
8f62e6b8:	e284a072 	add	r10, r4, #114	; 0x72
	if (lk2nd_dev.carrier)
8f62e6bc:	e3510000 	cmp	r1, #0
8f62e6c0:	0a000002 	beq	8f62e6d0 <lk2nd_motorola_smem_write_unit_info+0xb0>
		strlcpy(unit_info->carrier, lk2nd_dev.carrier, CARRIER_MAX_LEN);
8f62e6c4:	e3a02041 	mov	r2, #65	; 0x41
8f62e6c8:	e1a0000a 	mov	r0, r10
8f62e6cc:	eb001817 	bl	8f634730 <strlcpy>
	if (lk2nd_dev.device)
8f62e6d0:	e597100c 	ldr	r1, [r7, #12]
		strlcpy(unit_info->device, lk2nd_dev.device, DEVICE_MAX_LEN);
8f62e6d4:	e2849f45 	add	r9, r4, #276	; 0x114
	if (lk2nd_dev.device)
8f62e6d8:	e3510000 	cmp	r1, #0
8f62e6dc:	0a000002 	beq	8f62e6ec <lk2nd_motorola_smem_write_unit_info+0xcc>
		strlcpy(unit_info->device, lk2nd_dev.device, DEVICE_MAX_LEN);
8f62e6e0:	e3a02021 	mov	r2, #33	; 0x21
8f62e6e4:	e1a00009 	mov	r0, r9
8f62e6e8:	eb001810 	bl	8f634730 <strlcpy>
	if (lk2nd_dev.radio) {
8f62e6ec:	e597001c 	ldr	r0, [r7, #28]
8f62e6f0:	e3500000 	cmp	r0, #0
		unit_info->radio = atoui(lk2nd_dev.radio);
		strlcpy(unit_info->radio_str, lk2nd_dev.radio, RADIO_MAX_LEN);
8f62e6f4:	02847d05 	addeq	r7, r4, #320	; 0x140
	if (lk2nd_dev.radio) {
8f62e6f8:	0a000006 	beq	8f62e718 <lk2nd_motorola_smem_write_unit_info+0xf8>
		unit_info->radio = atoui(lk2nd_dev.radio);
8f62e6fc:	eb001347 	bl	8f633420 <atoui>
		strlcpy(unit_info->radio_str, lk2nd_dev.radio, RADIO_MAX_LEN);
8f62e700:	e597101c 	ldr	r1, [r7, #28]
8f62e704:	e2847d05 	add	r7, r4, #320	; 0x140
8f62e708:	e3a02021 	mov	r2, #33	; 0x21
		unit_info->radio = atoui(lk2nd_dev.radio);
8f62e70c:	e5840138 	str	r0, [r4, #312]	; 0x138
		strlcpy(unit_info->radio_str, lk2nd_dev.radio, RADIO_MAX_LEN);
8f62e710:	e1a00007 	mov	r0, r7
8f62e714:	eb001805 	bl	8f634730 <strlcpy>
	}

	fdt_getprop_u32(fdt, chosen_offset, "linux,hwrev", &unit_info->system_rev);
8f62e718:	e1a00005 	mov	r0, r5
8f62e71c:	e2843004 	add	r3, r4, #4
8f62e720:	e1a01006 	mov	r1, r6
8f62e724:	e30a2894 	movw	r2, #43156	; 0xa894
8f62e728:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62e72c:	ebffff97 	bl	8f62e590 <fdt_getprop_u32>
	fdt_getprop_u32(fdt, chosen_offset, "linux,seriallow", &unit_info->system_serial_low);
8f62e730:	e1a00005 	mov	r0, r5
8f62e734:	e2843008 	add	r3, r4, #8
8f62e738:	e1a01006 	mov	r1, r6
8f62e73c:	e30a28a0 	movw	r2, #43168	; 0xa8a0
8f62e740:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62e744:	ebffff91 	bl	8f62e590 <fdt_getprop_u32>
	fdt_getprop_u32(fdt, chosen_offset, "linux,serialhigh", &unit_info->system_serial_high);
8f62e748:	e1a00005 	mov	r0, r5
8f62e74c:	e284300c 	add	r3, r4, #12
8f62e750:	e1a01006 	mov	r1, r6
8f62e754:	e30a28b0 	movw	r2, #43184	; 0xa8b0
8f62e758:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62e75c:	ebffff8b 	bl	8f62e590 <fdt_getprop_u32>
	fdt_getprop_u32(fdt, chosen_offset, "mmi,powerup_reason", &unit_info->powerup_reason);
8f62e760:	e1a00005 	mov	r0, r5
8f62e764:	e2843f4f 	add	r3, r4, #316	; 0x13c
8f62e768:	e1a01006 	mov	r1, r6
8f62e76c:	e30a28c4 	movw	r2, #43204	; 0xa8c4
8f62e770:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62e774:	ebffff85 	bl	8f62e590 <fdt_getprop_u32>

	baseband = fdt_getprop(fdt, chosen_offset, "mmi,baseband", &len);
8f62e778:	e1a00005 	mov	r0, r5
8f62e77c:	e28d3028 	add	r3, r13, #40	; 0x28
8f62e780:	e1a01006 	mov	r1, r6
8f62e784:	e30a28d8 	movw	r2, #43224	; 0xa8d8
8f62e788:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62e78c:	eb001c67 	bl	8f635930 <fdt_getprop>
	if (len >= 0)
8f62e790:	e59d2028 	ldr	r2, [r13, #40]	; 0x28
8f62e794:	e3520000 	cmp	r2, #0
		strlcpy(unit_info->baseband, baseband, MIN(len, BASEBAND_MAX_LEN));
8f62e798:	b28450b3 	addlt	r5, r4, #179	; 0xb3
	if (len >= 0)
8f62e79c:	ba000005 	blt	8f62e7b8 <lk2nd_motorola_smem_write_unit_info+0x198>
		strlcpy(unit_info->baseband, baseband, MIN(len, BASEBAND_MAX_LEN));
8f62e7a0:	e3520061 	cmp	r2, #97	; 0x61
8f62e7a4:	e28450b3 	add	r5, r4, #179	; 0xb3
8f62e7a8:	e1a01000 	mov	r1, r0
8f62e7ac:	a3a02061 	movge	r2, #97	; 0x61
8f62e7b0:	e1a00005 	mov	r0, r5
8f62e7b4:	eb0017dd 	bl	8f634730 <strlcpy>

	dprintf(INFO, "Setting motorola unit info: version = 0x%02x, device = '%s', radio = 0x%x, radio_str = '%s', system_rev = 0x%04x, system_serial = 0x%08x%08x, machine = '%s', barcode = '%s', baseband = '%s', carrier = '%s', pu_reason = 0x%08x\n",
8f62e7b8:	e5943008 	ldr	r3, [r4, #8]
8f62e7bc:	e2841010 	add	r1, r4, #16
8f62e7c0:	e594000c 	ldr	r0, [r4, #12]
8f62e7c4:	e1a02009 	mov	r2, r9
8f62e7c8:	e594c13c 	ldr	r12, [r4, #316]	; 0x13c
8f62e7cc:	e58d1010 	str	r1, [r13, #16]
8f62e7d0:	e5941004 	ldr	r1, [r4, #4]
8f62e7d4:	e58d300c 	str	r3, [r13, #12]
8f62e7d8:	e58d0008 	str	r0, [r13, #8]
8f62e7dc:	e30a08e8 	movw	r0, #43240	; 0xa8e8
8f62e7e0:	e5943138 	ldr	r3, [r4, #312]	; 0x138
8f62e7e4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e7e8:	e58d1004 	str	r1, [r13, #4]
8f62e7ec:	e58dc020 	str	r12, [r13, #32]
8f62e7f0:	e5941000 	ldr	r1, [r4]
8f62e7f4:	e58da01c 	str	r10, [r13, #28]
8f62e7f8:	e58d5018 	str	r5, [r13, #24]
8f62e7fc:	e58d7000 	str	r7, [r13]
8f62e800:	e58d8014 	str	r8, [r13, #20]
8f62e804:	eb00105a 	bl	8f632974 <_dprintf>
		unit_info->system_serial_high, unit_info->system_serial_low,
		unit_info->machine, unit_info->barcode,
		unit_info->baseband, unit_info->carrier,
		unit_info->powerup_reason);

	ret = smem_alloc_write_entry(SMEM_KERNEL_RESERVE, unit_info, SMEM_KERNEL_RESERVE_SIZE);
8f62e808:	e1a01004 	mov	r1, r4
8f62e80c:	e3a02b01 	mov	r2, #1024	; 0x400
8f62e810:	e3a00086 	mov	r0, #134	; 0x86
8f62e814:	ebff508f 	bl	8f602a58 <smem_alloc_write_entry>
	if (ret != 0)
8f62e818:	e2501000 	subs	r1, r0, #0
8f62e81c:	0a00000c 	beq	8f62e854 <lk2nd_motorola_smem_write_unit_info+0x234>
		dprintf(CRITICAL, "Failed to write motorola unit info to smem: %d\n", ret);
8f62e820:	e30a09cc 	movw	r0, #43468	; 0xa9cc
8f62e824:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e828:	eb001051 	bl	8f632974 <_dprintf>
	else
		dprintf(INFO, "Wrote motorola unit info\n");

	free(unit_info);
8f62e82c:	e1a00004 	mov	r0, r4
8f62e830:	eb001635 	bl	8f63410c <free>
}
8f62e834:	e59f303c 	ldr	r3, [pc, #60]	; 8f62e878 <lk2nd_motorola_smem_write_unit_info+0x258>
8f62e838:	e5932000 	ldr	r2, [r3]
8f62e83c:	e59d302c 	ldr	r3, [r13, #44]	; 0x2c
8f62e840:	e0332002 	eors	r2, r3, r2
8f62e844:	e3a03000 	mov	r3, #0
8f62e848:	1a000009 	bne	8f62e874 <lk2nd_motorola_smem_write_unit_info+0x254>
8f62e84c:	e28dd030 	add	r13, r13, #48	; 0x30
8f62e850:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
		dprintf(INFO, "Wrote motorola unit info\n");
8f62e854:	e30a09fc 	movw	r0, #43516	; 0xa9fc
8f62e858:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e85c:	eb001044 	bl	8f632974 <_dprintf>
8f62e860:	eafffff1 	b	8f62e82c <lk2nd_motorola_smem_write_unit_info+0x20c>
		dprintf(CRITICAL, "Failed to get /chosen node in device tree\n");
8f62e864:	e30a0868 	movw	r0, #43112	; 0xa868
8f62e868:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e86c:	eb001040 	bl	8f632974 <_dprintf>
		return;
8f62e870:	eaffffef 	b	8f62e834 <lk2nd_motorola_smem_write_unit_info+0x214>
}
8f62e874:	eb0010d1 	bl	8f632bc0 <__stack_chk_fail>
8f62e878:	8f74221c 	.word	0x8f74221c

8f62e87c <lk2nd_samsung_muic_reset>:
	dprintf(INFO, "muic-reset: Successful, earlier UART log may be lost!\n");
}
#endif

void lk2nd_samsung_muic_reset(const void *fdt, int offset)
{
8f62e87c:	e59f3034 	ldr	r3, [pc, #52]	; 8f62e8b8 <lk2nd_samsung_muic_reset+0x3c>
8f62e880:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f62e884:	e24dd00c 	sub	r13, r13, #12
8f62e888:	e5933000 	ldr	r3, [r3]
8f62e88c:	e58d3004 	str	r3, [r13, #4]
8f62e890:	e3a03000 	mov	r3, #0
	}

	i2c_gpio_muic_reset(fdt32_to_cpu(i2c_gpios[0]), fdt32_to_cpu(i2c_gpios[1]),
			    fdt32_to_cpu(*i2c_addr));
#endif
}
8f62e894:	e59f301c 	ldr	r3, [pc, #28]	; 8f62e8b8 <lk2nd_samsung_muic_reset+0x3c>
8f62e898:	e5932000 	ldr	r2, [r3]
8f62e89c:	e59d3004 	ldr	r3, [r13, #4]
8f62e8a0:	e0332002 	eors	r2, r3, r2
8f62e8a4:	e3a03000 	mov	r3, #0
8f62e8a8:	1a000001 	bne	8f62e8b4 <lk2nd_samsung_muic_reset+0x38>
8f62e8ac:	e28dd00c 	add	r13, r13, #12
8f62e8b0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f62e8b4:	eb0010c1 	bl	8f632bc0 <__stack_chk_fail>
8f62e8b8:	8f74221c 	.word	0x8f74221c

8f62e8bc <fsboot_fs_load_img>:
static int fsboot_fs_load_img(char *dev_name, void* target, size_t sz)
{
	struct dirhandle *dirh;
	struct dirent dirent;

	char image_path[128] = "/mnt/";
8f62e8bc:	e30a3b38 	movw	r3, #43832	; 0xab38
8f62e8c0:	e3483f70 	movt	r3, #36720	; 0x8f70
{
8f62e8c4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f62e8c8:	e1a07000 	mov	r7, r0
8f62e8cc:	e1a04001 	mov	r4, r1
	char image_path[128] = "/mnt/";
8f62e8d0:	e8930003 	ldm	r3, {r0, r1}
{
8f62e8d4:	e24ddf43 	sub	r13, r13, #268	; 0x10c
8f62e8d8:	e59f31b4 	ldr	r3, [pc, #436]	; 8f62ea94 <fsboot_fs_load_img+0x1d8>
8f62e8dc:	e1a0b002 	mov	r11, r2
	char image_path[128] = "/mnt/";
8f62e8e0:	e3a0207a 	mov	r2, #122	; 0x7a
{
8f62e8e4:	e5933000 	ldr	r3, [r3]
8f62e8e8:	e58d3104 	str	r3, [r13, #260]	; 0x104
8f62e8ec:	e3a03000 	mov	r3, #0
	char image_path[128] = "/mnt/";
8f62e8f0:	e58d0084 	str	r0, [r13, #132]	; 0x84
8f62e8f4:	e1cd18b8 	strh	r1, [r13, #136]	; 0x88
8f62e8f8:	e28d008a 	add	r0, r13, #138	; 0x8a
8f62e8fc:	e3a01000 	mov	r1, #0
8f62e900:	eb00166f 	bl	8f6342c4 <memset>
	int ret = -1;
	bool path_valid = false;

	if (fs_mount("/mnt", "ext2", dev_name) < 0)
8f62e904:	e1a02007 	mov	r2, r7
8f62e908:	e30a1a18 	movw	r1, #43544	; 0xaa18
8f62e90c:	e30a0a20 	movw	r0, #43552	; 0xaa20
8f62e910:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62e914:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e918:	eb002627 	bl	8f6381bc <fs_mount>
8f62e91c:	e3500000 	cmp	r0, #0
8f62e920:	ba000058 	blt	8f62ea88 <fsboot_fs_load_img+0x1cc>
		return -1;

	ret = fs_open_dir("/mnt", &dirh);
8f62e924:	e1a0100d 	mov	r1, r13
8f62e928:	e30a0a20 	movw	r0, #43552	; 0xaa20
8f62e92c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e930:	eb0026d6 	bl	8f638490 <fs_open_dir>
	if (ret < 0) {
8f62e934:	e2509000 	subs	r9, r0, #0
8f62e938:	ba00004d 	blt	8f62ea74 <fsboot_fs_load_img+0x1b8>
			dprintf(SPEW, "| /%s/%s\n", dev_name, dirent.name);
		} else if (!path_valid && strncmp(dirent.name, "boot.img", 7) == 0) {
			strcpy(&image_path[strlen("/mnt/")], dirent.name);
			dprintf(INFO, "Found boot image: %s : %s\n", dev_name, image_path);
			path_valid = true;
		} else if (strncmp(dirent.name, "lk2nd_skip", 10) == 0) {
8f62e93c:	e30a6a7c 	movw	r6, #43644	; 0xaa7c
		} else if (!path_valid && strncmp(dirent.name, "boot.img", 7) == 0) {
8f62e940:	e30a8a4c 	movw	r8, #43596	; 0xaa4c
			strcpy(&image_path[strlen("/mnt/")], dirent.name);
8f62e944:	e30aaa58 	movw	r10, #43608	; 0xaa58
		} else if (strncmp(dirent.name, "lk2nd_skip", 10) == 0) {
8f62e948:	e3486f70 	movt	r6, #36720	; 0x8f70
		} else if (!path_valid && strncmp(dirent.name, "boot.img", 7) == 0) {
8f62e94c:	e3488f70 	movt	r8, #36720	; 0x8f70
			strcpy(&image_path[strlen("/mnt/")], dirent.name);
8f62e950:	e348af70 	movt	r10, #36720	; 0x8f70
	bool path_valid = false;
8f62e954:	e3a05000 	mov	r5, #0
	while (fs_read_dir(dirh, &dirent) >= 0) {
8f62e958:	e59d0000 	ldr	r0, [r13]
8f62e95c:	e28d1004 	add	r1, r13, #4
8f62e960:	eb0024f9 	bl	8f637d4c <fs_read_dir>
8f62e964:	e3500000 	cmp	r0, #0
8f62e968:	ba000034 	blt	8f62ea40 <fsboot_fs_load_img+0x184>
		if (!target) {
8f62e96c:	e3540000 	cmp	r4, #0
8f62e970:	0a00001f 	beq	8f62e9f4 <fsboot_fs_load_img+0x138>
		} else if (!path_valid && strncmp(dirent.name, "boot.img", 7) == 0) {
8f62e974:	e3550000 	cmp	r5, #0
8f62e978:	1a000005 	bne	8f62e994 <fsboot_fs_load_img+0xd8>
8f62e97c:	e28d0004 	add	r0, r13, #4
8f62e980:	e3a02007 	mov	r2, #7
8f62e984:	e1a01008 	mov	r1, r8
8f62e988:	eb0017b7 	bl	8f63486c <strncmp>
8f62e98c:	e3500000 	cmp	r0, #0
8f62e990:	0a00001d 	beq	8f62ea0c <fsboot_fs_load_img+0x150>
		} else if (strncmp(dirent.name, "lk2nd_skip", 10) == 0) {
8f62e994:	e28d0004 	add	r0, r13, #4
8f62e998:	e3a0200a 	mov	r2, #10
8f62e99c:	e1a01006 	mov	r1, r6
8f62e9a0:	eb0017b1 	bl	8f63486c <strncmp>
8f62e9a4:	e3500000 	cmp	r0, #0
8f62e9a8:	1affffea 	bne	8f62e958 <fsboot_fs_load_img+0x9c>
			dprintf(INFO, "Partition skipped: %s\n", dev_name);
8f62e9ac:	e1a01007 	mov	r1, r7
8f62e9b0:	e30a0a88 	movw	r0, #43656	; 0xaa88
8f62e9b4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e9b8:	eb000fed 	bl	8f632974 <_dprintf>
			fs_close_dir(dirh);
8f62e9bc:	e59d0000 	ldr	r0, [r13]
8f62e9c0:	eb002501 	bl	8f637dcc <fs_close_dir>
	if (target && path_valid) {
		ret = fs_load_file(image_path, target, sz);
	}

out:
	fs_unmount("/mnt");
8f62e9c4:	e30a0a20 	movw	r0, #43552	; 0xaa20
8f62e9c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62e9cc:	eb002628 	bl	8f638274 <fs_unmount>
	return ret;
}
8f62e9d0:	e59f30bc 	ldr	r3, [pc, #188]	; 8f62ea94 <fsboot_fs_load_img+0x1d8>
8f62e9d4:	e5932000 	ldr	r2, [r3]
8f62e9d8:	e59d3104 	ldr	r3, [r13, #260]	; 0x104
8f62e9dc:	e0332002 	eors	r2, r3, r2
8f62e9e0:	e3a03000 	mov	r3, #0
8f62e9e4:	1a000029 	bne	8f62ea90 <fsboot_fs_load_img+0x1d4>
8f62e9e8:	e1a00009 	mov	r0, r9
8f62e9ec:	e28ddf43 	add	r13, r13, #268	; 0x10c
8f62e9f0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
			dprintf(SPEW, "| /%s/%s\n", dev_name, dirent.name);
8f62e9f4:	e28d2004 	add	r2, r13, #4
8f62e9f8:	e1a01007 	mov	r1, r7
8f62e9fc:	e30a0a40 	movw	r0, #43584	; 0xaa40
8f62ea00:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62ea04:	eb000fda 	bl	8f632974 <_dprintf>
8f62ea08:	eaffffd2 	b	8f62e958 <fsboot_fs_load_img+0x9c>
			strcpy(&image_path[strlen("/mnt/")], dirent.name);
8f62ea0c:	e1a0000a 	mov	r0, r10
			path_valid = true;
8f62ea10:	e3a05001 	mov	r5, #1
			strcpy(&image_path[strlen("/mnt/")], dirent.name);
8f62ea14:	eb00177b 	bl	8f634808 <strlen>
8f62ea18:	e28d3084 	add	r3, r13, #132	; 0x84
8f62ea1c:	e28d1004 	add	r1, r13, #4
8f62ea20:	e0830000 	add	r0, r3, r0
8f62ea24:	eb0016da 	bl	8f634594 <strcpy>
			dprintf(INFO, "Found boot image: %s : %s\n", dev_name, image_path);
8f62ea28:	e28d2084 	add	r2, r13, #132	; 0x84
8f62ea2c:	e1a01007 	mov	r1, r7
8f62ea30:	e30a0a60 	movw	r0, #43616	; 0xaa60
8f62ea34:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62ea38:	eb000fcd 	bl	8f632974 <_dprintf>
			path_valid = true;
8f62ea3c:	eaffffc5 	b	8f62e958 <fsboot_fs_load_img+0x9c>
	fs_close_dir(dirh);
8f62ea40:	e59d0000 	ldr	r0, [r13]
	if (target && path_valid) {
8f62ea44:	e3540000 	cmp	r4, #0
8f62ea48:	03a05000 	moveq	r5, #0
8f62ea4c:	12055001 	andne	r5, r5, #1
	fs_close_dir(dirh);
8f62ea50:	eb0024dd 	bl	8f637dcc <fs_close_dir>
	if (target && path_valid) {
8f62ea54:	e3550000 	cmp	r5, #0
8f62ea58:	0affffd9 	beq	8f62e9c4 <fsboot_fs_load_img+0x108>
		ret = fs_load_file(image_path, target, sz);
8f62ea5c:	e28d0084 	add	r0, r13, #132	; 0x84
8f62ea60:	e1a0200b 	mov	r2, r11
8f62ea64:	e1a01004 	mov	r1, r4
8f62ea68:	eb002658 	bl	8f6383d0 <fs_load_file>
8f62ea6c:	e1a09000 	mov	r9, r0
8f62ea70:	eaffffd3 	b	8f62e9c4 <fsboot_fs_load_img+0x108>
		dprintf(SPEW, "fs_open_dir ret = %d\n", ret);
8f62ea74:	e1a01009 	mov	r1, r9
8f62ea78:	e30a0a28 	movw	r0, #43560	; 0xaa28
8f62ea7c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62ea80:	eb000fbb 	bl	8f632974 <_dprintf>
		goto out;
8f62ea84:	eaffffce 	b	8f62e9c4 <fsboot_fs_load_img+0x108>
		return -1;
8f62ea88:	e3e09000 	mvn	r9, #0
8f62ea8c:	eaffffcf 	b	8f62e9d0 <fsboot_fs_load_img+0x114>
}
8f62ea90:	eb00104a 	bl	8f632bc0 <__stack_chk_fail>
8f62ea94:	8f74221c 	.word	0x8f74221c

8f62ea98 <fsboot_find_and_boot>:

static int fsboot_find_and_boot(int bdev_id, void* target, size_t sz)
{
8f62ea98:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f62ea9c:	e24dd0a4 	sub	r13, r13, #164	; 0xa4
8f62eaa0:	e59f32f8 	ldr	r3, [pc, #760]	; 8f62eda0 <fsboot_find_and_boot+0x308>
	int i = 0, j = 0, ret = 0;
	char dev_name[128];
	bdev_t *dev = NULL;

	/* HACK: There is no hd1p0 for some reason */
	if (bdev_id == 1)
8f62eaa4:	e2605002 	rsb	r5, r0, #2
{
8f62eaa8:	e1a06000 	mov	r6, r0
8f62eaac:	e1a04001 	mov	r4, r1
8f62eab0:	e1a08002 	mov	r8, r2
		i = 1;

	sprintf(dev_name, "hd%d", bdev_id);
8f62eab4:	e3021e0c 	movw	r1, #11788	; 0x2e0c
8f62eab8:	e1a02000 	mov	r2, r0
8f62eabc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62eac0:	e28d001c 	add	r0, r13, #28
{
8f62eac4:	e5933000 	ldr	r3, [r3]
8f62eac8:	e58d309c 	str	r3, [r13, #156]	; 0x9c
8f62eacc:	e3a03000 	mov	r3, #0
	sprintf(dev_name, "hd%d", bdev_id);
8f62ead0:	eb001531 	bl	8f633f9c <sprintf>
	dev = bio_open(dev_name);
8f62ead4:	e28d001c 	add	r0, r13, #28
8f62ead8:	eb00216a 	bl	8f637088 <bio_open>
	if (!dev) {
8f62eadc:	e3500000 	cmp	r0, #0
8f62eae0:	0a0000a7 	beq	8f62ed84 <fsboot_find_and_boot+0x2ec>
		dprintf(CRITICAL, "fs-boot: Can't open %s\n", dev_name);
		return -1;
	}
	bio_close(dev);
8f62eae4:	eb002194 	bl	8f63713c <bio_close>

	if (!target)
8f62eae8:	e3540000 	cmp	r4, #0
8f62eaec:	0a00009f 	beq	8f62ed70 <fsboot_find_and_boot+0x2d8>
		dprintf(SPEW, "fs-boot: Looking at %s:\n", dev_name);

	sprintf(dev_name, "hd%dp%d", bdev_id, i);
8f62eaf0:	e1a03005 	mov	r3, r5
8f62eaf4:	e28d001c 	add	r0, r13, #28
8f62eaf8:	e1a02006 	mov	r2, r6
8f62eafc:	e30a1ad4 	movw	r1, #43732	; 0xaad4
8f62eb00:	e3481f70 	movt	r1, #36720	; 0x8f70
			return ret;

		/* Only check subpartitions on emmc */
		if (ret < 0 && bdev_id == 1) {
			j = 0;
			sprintf(dev_name, "hd%dp%dp%d", bdev_id, i, j);
8f62eb04:	e30aaaf8 	movw	r10, #43768	; 0xaaf8
	sprintf(dev_name, "hd%dp%d", bdev_id, i);
8f62eb08:	eb001523 	bl	8f633f9c <sprintf>
	while (dev = bio_open(dev_name)) {
8f62eb0c:	e2667003 	rsb	r7, r6, #3
			while (dev = bio_open(dev_name)) {
				if (!target)
					dprintf(SPEW, "%.8s:  %.10s (%6llu MiB): \n",dev->name, dev->label, dev->size / (1024 * 1024));
8f62eb10:	e30a3adc 	movw	r3, #43740	; 0xaadc
			sprintf(dev_name, "hd%dp%dp%d", bdev_id, i, j);
8f62eb14:	e348af70 	movt	r10, #36720	; 0x8f70
					dprintf(SPEW, "%.8s:  %.10s (%6llu MiB): \n",dev->name, dev->label, dev->size / (1024 * 1024));
8f62eb18:	e3483f70 	movt	r3, #36720	; 0x8f70
8f62eb1c:	e58d3010 	str	r3, [r13, #16]
				j++;
				sprintf(dev_name, "hd%dp%dp%d", bdev_id, i, j);
			}
		}
		i++;
		sprintf(dev_name, "hd%dp%d", bdev_id, i);
8f62eb20:	e30a3ad4 	movw	r3, #43732	; 0xaad4
8f62eb24:	e3483f70 	movt	r3, #36720	; 0x8f70
8f62eb28:	e58d300c 	str	r3, [r13, #12]
	while (dev = bio_open(dev_name)) {
8f62eb2c:	ea000015 	b	8f62eb88 <fsboot_find_and_boot+0xf0>
		if (!target)
8f62eb30:	e3540000 	cmp	r4, #0
8f62eb34:	0a00002f 	beq	8f62ebf8 <fsboot_find_and_boot+0x160>
		bio_close(dev);
8f62eb38:	e1a00005 	mov	r0, r5
8f62eb3c:	eb00217e 	bl	8f63713c <bio_close>
		ret = fsboot_fs_load_img(dev_name, target, sz);
8f62eb40:	e28d001c 	add	r0, r13, #28
8f62eb44:	e1a02008 	mov	r2, r8
8f62eb48:	e1a01004 	mov	r1, r4
8f62eb4c:	ebffff5a 	bl	8f62e8bc <fsboot_fs_load_img>
		if (target && ret >= 0)
8f62eb50:	e3500000 	cmp	r0, #0
8f62eb54:	aa000073 	bge	8f62ed28 <fsboot_find_and_boot+0x290>
8f62eb58:	e3a0b001 	mov	r11, #1
		if (ret < 0 && bdev_id == 1) {
8f62eb5c:	e2463001 	sub	r3, r6, #1
8f62eb60:	e16f3f13 	clz	r3, r3
8f62eb64:	e1a032a3 	lsr	r3, r3, #5
8f62eb68:	e0133fa0 	ands	r3, r3, r0, lsr #31
8f62eb6c:	1a000037 	bne	8f62ec50 <fsboot_find_and_boot+0x1b8>
		sprintf(dev_name, "hd%dp%d", bdev_id, i);
8f62eb70:	e59d100c 	ldr	r1, [r13, #12]
8f62eb74:	e28d001c 	add	r0, r13, #28
8f62eb78:	e1a03007 	mov	r3, r7
8f62eb7c:	e1a02006 	mov	r2, r6
8f62eb80:	eb001505 	bl	8f633f9c <sprintf>
8f62eb84:	e2877001 	add	r7, r7, #1
	while (dev = bio_open(dev_name)) {
8f62eb88:	e28d001c 	add	r0, r13, #28
8f62eb8c:	e2479001 	sub	r9, r7, #1
8f62eb90:	eb00213c 	bl	8f637088 <bio_open>
8f62eb94:	e2505000 	subs	r5, r0, #0
8f62eb98:	0a000061 	beq	8f62ed24 <fsboot_find_and_boot+0x28c>
		if (bdev_id == 1 && !fsboot_bootable_part(dev->label)) {
8f62eb9c:	e3560001 	cmp	r6, #1
8f62eba0:	1affffe2 	bne	8f62eb30 <fsboot_find_and_boot+0x98>
8f62eba4:	e5952020 	ldr	r2, [r5, #32]
8f62eba8:	e3011280 	movw	r1, #4736	; 0x1280
8f62ebac:	e58d9014 	str	r9, [r13, #20]
8f62ebb0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62ebb4:	e59fb1e8 	ldr	r11, [pc, #488]	; 8f62eda4 <fsboot_find_and_boot+0x30c>
8f62ebb8:	e1a09002 	mov	r9, r2
		if (strcmp(label, bootable_parts[i]) == 0)
8f62ebbc:	e1a00009 	mov	r0, r9
8f62ebc0:	eb001657 	bl	8f634524 <strcmp>
8f62ebc4:	e3500000 	cmp	r0, #0
8f62ebc8:	0a000007 	beq	8f62ebec <fsboot_find_and_boot+0x154>
	for (i = 0; i < ARRAY_SIZE(bootable_parts); ++i)
8f62ebcc:	e59f31d4 	ldr	r3, [pc, #468]	; 8f62eda8 <fsboot_find_and_boot+0x310>
8f62ebd0:	e15b0003 	cmp	r11, r3
8f62ebd4:	0a00005d 	beq	8f62ed50 <fsboot_find_and_boot+0x2b8>
		if (strcmp(label, bootable_parts[i]) == 0)
8f62ebd8:	e49b1004 	ldr	r1, [r11], #4
8f62ebdc:	e1a00009 	mov	r0, r9
8f62ebe0:	eb00164f 	bl	8f634524 <strcmp>
8f62ebe4:	e3500000 	cmp	r0, #0
8f62ebe8:	1afffff7 	bne	8f62ebcc <fsboot_find_and_boot+0x134>
		if (!target)
8f62ebec:	e3540000 	cmp	r4, #0
8f62ebf0:	e59d9014 	ldr	r9, [r13, #20]
8f62ebf4:	1affffcf 	bne	8f62eb38 <fsboot_find_and_boot+0xa0>
			dprintf(SPEW, "%.8s:  %.10s (%6llu MiB): \n",dev->name, dev->label, dev->size / (1024 * 1024));
8f62ebf8:	e1c501d0 	ldrd	r0, [r5, #16]
		if (target && ret >= 0)
8f62ebfc:	e1a0b004 	mov	r11, r4
			dprintf(SPEW, "%.8s:  %.10s (%6llu MiB): \n",dev->name, dev->label, dev->size / (1024 * 1024));
8f62ec00:	e5952020 	ldr	r2, [r5, #32]
8f62ec04:	e1a03fc1 	asr	r3, r1, #31
8f62ec08:	e7f33053 	ubfx	r3, r3, #0, #20
8f62ec0c:	e0933000 	adds	r3, r3, r0
8f62ec10:	e2a11000 	adc	r1, r1, #0
8f62ec14:	e1a03a23 	lsr	r3, r3, #20
8f62ec18:	e1833601 	orr	r3, r3, r1, lsl #12
8f62ec1c:	e1a00a41 	asr	r0, r1, #20
8f62ec20:	e595100c 	ldr	r1, [r5, #12]
8f62ec24:	e58d3000 	str	r3, [r13]
8f62ec28:	e58d0004 	str	r0, [r13, #4]
8f62ec2c:	e59d0010 	ldr	r0, [r13, #16]
8f62ec30:	eb000f4f 	bl	8f632974 <_dprintf>
		bio_close(dev);
8f62ec34:	e1a00005 	mov	r0, r5
8f62ec38:	eb00213f 	bl	8f63713c <bio_close>
		ret = fsboot_fs_load_img(dev_name, target, sz);
8f62ec3c:	e28d001c 	add	r0, r13, #28
8f62ec40:	e1a02008 	mov	r2, r8
8f62ec44:	e1a01004 	mov	r1, r4
8f62ec48:	ebffff1b 	bl	8f62e8bc <fsboot_fs_load_img>
		if (target && ret >= 0)
8f62ec4c:	eaffffc2 	b	8f62eb5c <fsboot_find_and_boot+0xc4>
			sprintf(dev_name, "hd%dp%dp%d", bdev_id, i, j);
8f62ec50:	e28d001c 	add	r0, r13, #28
8f62ec54:	e3a05000 	mov	r5, #0
8f62ec58:	e1a03009 	mov	r3, r9
8f62ec5c:	e3a02001 	mov	r2, #1
8f62ec60:	e1a0100a 	mov	r1, r10
8f62ec64:	e58d5000 	str	r5, [r13]
8f62ec68:	eb0014cb 	bl	8f633f9c <sprintf>
			while (dev = bio_open(dev_name)) {
8f62ec6c:	e58d6014 	str	r6, [r13, #20]
8f62ec70:	ea000010 	b	8f62ecb8 <fsboot_find_and_boot+0x220>
				bio_close(dev);
8f62ec74:	eb002130 	bl	8f63713c <bio_close>
				ret = fsboot_fs_load_img(dev_name, target, sz);
8f62ec78:	e28d001c 	add	r0, r13, #28
8f62ec7c:	e1a02008 	mov	r2, r8
8f62ec80:	e1a01004 	mov	r1, r4
8f62ec84:	ebffff0c 	bl	8f62e8bc <fsboot_fs_load_img>
				if (target && ret >= 0)
8f62ec88:	e3500000 	cmp	r0, #0
8f62ec8c:	b3a03000 	movlt	r3, #0
8f62ec90:	a20b3001 	andge	r3, r11, #1
8f62ec94:	e3530000 	cmp	r3, #0
8f62ec98:	1a000022 	bne	8f62ed28 <fsboot_find_and_boot+0x290>
				j++;
8f62ec9c:	e2855001 	add	r5, r5, #1
				sprintf(dev_name, "hd%dp%dp%d", bdev_id, i, j);
8f62eca0:	e28d001c 	add	r0, r13, #28
8f62eca4:	e1a03009 	mov	r3, r9
8f62eca8:	e3a02001 	mov	r2, #1
8f62ecac:	e1a0100a 	mov	r1, r10
8f62ecb0:	e58d5000 	str	r5, [r13]
8f62ecb4:	eb0014b8 	bl	8f633f9c <sprintf>
			while (dev = bio_open(dev_name)) {
8f62ecb8:	e28d001c 	add	r0, r13, #28
8f62ecbc:	eb0020f1 	bl	8f637088 <bio_open>
8f62ecc0:	e2506000 	subs	r6, r0, #0
8f62ecc4:	0a00001f 	beq	8f62ed48 <fsboot_find_and_boot+0x2b0>
				if (!target)
8f62ecc8:	e3540000 	cmp	r4, #0
8f62eccc:	1affffe8 	bne	8f62ec74 <fsboot_find_and_boot+0x1dc>
					dprintf(SPEW, "%.8s:  %.10s (%6llu MiB): \n",dev->name, dev->label, dev->size / (1024 * 1024));
8f62ecd0:	e5961014 	ldr	r1, [r6, #20]
8f62ecd4:	e596c010 	ldr	r12, [r6, #16]
8f62ecd8:	e5962020 	ldr	r2, [r6, #32]
8f62ecdc:	e1a00fc1 	asr	r0, r1, #31
8f62ece0:	e7f30050 	ubfx	r0, r0, #0, #20
8f62ece4:	e090000c 	adds	r0, r0, r12
8f62ece8:	e2a11000 	adc	r1, r1, #0
8f62ecec:	e1a00a20 	lsr	r0, r0, #20
8f62ecf0:	e1a0ca41 	asr	r12, r1, #20
8f62ecf4:	e1800601 	orr	r0, r0, r1, lsl #12
8f62ecf8:	e596100c 	ldr	r1, [r6, #12]
8f62ecfc:	e88d1001 	stm	r13, {r0, r12}
8f62ed00:	e59d0010 	ldr	r0, [r13, #16]
8f62ed04:	eb000f1a 	bl	8f632974 <_dprintf>
				bio_close(dev);
8f62ed08:	e1a00006 	mov	r0, r6
8f62ed0c:	eb00210a 	bl	8f63713c <bio_close>
				ret = fsboot_fs_load_img(dev_name, target, sz);
8f62ed10:	e28d001c 	add	r0, r13, #28
8f62ed14:	e1a02008 	mov	r2, r8
8f62ed18:	e1a01004 	mov	r1, r4
8f62ed1c:	ebfffee6 	bl	8f62e8bc <fsboot_fs_load_img>
				if (target && ret >= 0)
8f62ed20:	eaffffdd 	b	8f62ec9c <fsboot_find_and_boot+0x204>
	}

	return -1;
8f62ed24:	e3e00000 	mvn	r0, #0
}
8f62ed28:	e59f3070 	ldr	r3, [pc, #112]	; 8f62eda0 <fsboot_find_and_boot+0x308>
8f62ed2c:	e5932000 	ldr	r2, [r3]
8f62ed30:	e59d309c 	ldr	r3, [r13, #156]	; 0x9c
8f62ed34:	e0332002 	eors	r2, r3, r2
8f62ed38:	e3a03000 	mov	r3, #0
8f62ed3c:	1a000016 	bne	8f62ed9c <fsboot_find_and_boot+0x304>
8f62ed40:	e28dd0a4 	add	r13, r13, #164	; 0xa4
8f62ed44:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
8f62ed48:	e59d6014 	ldr	r6, [r13, #20]
8f62ed4c:	eaffff87 	b	8f62eb70 <fsboot_find_and_boot+0xd8>
			bio_close(dev);
8f62ed50:	e1a00005 	mov	r0, r5
8f62ed54:	eb0020f8 	bl	8f63713c <bio_close>
			sprintf(dev_name, "hd%dp%d", bdev_id, i);
8f62ed58:	e59d100c 	ldr	r1, [r13, #12]
8f62ed5c:	e28d001c 	add	r0, r13, #28
8f62ed60:	e1a03007 	mov	r3, r7
8f62ed64:	e3a02001 	mov	r2, #1
8f62ed68:	eb00148b 	bl	8f633f9c <sprintf>
			continue;
8f62ed6c:	eaffff84 	b	8f62eb84 <fsboot_find_and_boot+0xec>
		dprintf(SPEW, "fs-boot: Looking at %s:\n", dev_name);
8f62ed70:	e28d101c 	add	r1, r13, #28
8f62ed74:	e30a0ab8 	movw	r0, #43704	; 0xaab8
8f62ed78:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62ed7c:	eb000efc 	bl	8f632974 <_dprintf>
8f62ed80:	eaffff5a 	b	8f62eaf0 <fsboot_find_and_boot+0x58>
		dprintf(CRITICAL, "fs-boot: Can't open %s\n", dev_name);
8f62ed84:	e28d101c 	add	r1, r13, #28
8f62ed88:	e30a0aa0 	movw	r0, #43680	; 0xaaa0
8f62ed8c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62ed90:	eb000ef7 	bl	8f632974 <_dprintf>
		return -1;
8f62ed94:	e3e00000 	mvn	r0, #0
8f62ed98:	eaffffe2 	b	8f62ed28 <fsboot_find_and_boot+0x290>
}
8f62ed9c:	eb000f87 	bl	8f632bc0 <__stack_chk_fail>
8f62eda0:	8f74221c 	.word	0x8f74221c
8f62eda4:	8f70abbc 	.word	0x8f70abbc
8f62eda8:	8f70abcc 	.word	0x8f70abcc

8f62edac <fsboot_test>:

void fsboot_test(void)
{
8f62edac:	e59f3060 	ldr	r3, [pc, #96]	; 8f62ee14 <fsboot_test+0x68>
	dprintf(SPEW, "fs-boot: Scanned devices:\n");
8f62edb0:	e30a0b04 	movw	r0, #43780	; 0xab04
{
8f62edb4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	dprintf(SPEW, "fs-boot: Scanned devices:\n");
8f62edb8:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f62edbc:	e24dd00c 	sub	r13, r13, #12
8f62edc0:	e5933000 	ldr	r3, [r3]
8f62edc4:	e58d3004 	str	r3, [r13, #4]
8f62edc8:	e3a03000 	mov	r3, #0
	dprintf(SPEW, "fs-boot: Scanned devices:\n");
8f62edcc:	eb000ee8 	bl	8f632974 <_dprintf>
	fsboot_find_and_boot(2, NULL, 0); // sdcard
8f62edd0:	e3a02000 	mov	r2, #0
8f62edd4:	e3a00002 	mov	r0, #2
8f62edd8:	e1a01002 	mov	r1, r2
8f62eddc:	ebffff2d 	bl	8f62ea98 <fsboot_find_and_boot>
	fsboot_find_and_boot(1, NULL, 0); // emmc
8f62ede0:	e59f302c 	ldr	r3, [pc, #44]	; 8f62ee14 <fsboot_test+0x68>
8f62ede4:	e5932000 	ldr	r2, [r3]
8f62ede8:	e59d3004 	ldr	r3, [r13, #4]
8f62edec:	e0332002 	eors	r2, r3, r2
8f62edf0:	e3a03000 	mov	r3, #0
8f62edf4:	1a000005 	bne	8f62ee10 <fsboot_test+0x64>
8f62edf8:	e3a02000 	mov	r2, #0
8f62edfc:	e3a00001 	mov	r0, #1
8f62ee00:	e1a01002 	mov	r1, r2
}
8f62ee04:	e28dd00c 	add	r13, r13, #12
8f62ee08:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	fsboot_find_and_boot(1, NULL, 0); // emmc
8f62ee0c:	eaffff21 	b	8f62ea98 <fsboot_find_and_boot>
8f62ee10:	eb000f6a 	bl	8f632bc0 <__stack_chk_fail>
8f62ee14:	8f74221c 	.word	0x8f74221c

8f62ee18 <fsboot_boot_first>:

int fsboot_boot_first(void* target, size_t sz)
{
8f62ee18:	e59f306c 	ldr	r3, [pc, #108]	; 8f62ee8c <fsboot_boot_first+0x74>
	int ret = -1;

	ret = fsboot_find_and_boot(2, target, sz); // sdcard
8f62ee1c:	e1a02001 	mov	r2, r1
{
8f62ee20:	e92d4030 	push	{r4, r5, r14}
8f62ee24:	e1a04000 	mov	r4, r0
8f62ee28:	e24dd00c 	sub	r13, r13, #12
8f62ee2c:	e1a05001 	mov	r5, r1
	ret = fsboot_find_and_boot(2, target, sz); // sdcard
8f62ee30:	e1a01000 	mov	r1, r0
8f62ee34:	e3a00002 	mov	r0, #2
{
8f62ee38:	e5933000 	ldr	r3, [r3]
8f62ee3c:	e58d3004 	str	r3, [r13, #4]
8f62ee40:	e3a03000 	mov	r3, #0
	ret = fsboot_find_and_boot(2, target, sz); // sdcard
8f62ee44:	ebffff13 	bl	8f62ea98 <fsboot_find_and_boot>
	if (ret > 0)
8f62ee48:	e3500000 	cmp	r0, #0
8f62ee4c:	ca000005 	bgt	8f62ee68 <fsboot_boot_first+0x50>
		return ret;

	ret = fsboot_find_and_boot(1, target, sz); // emmc
8f62ee50:	e1a02005 	mov	r2, r5
8f62ee54:	e1a01004 	mov	r1, r4
8f62ee58:	e3a00001 	mov	r0, #1
8f62ee5c:	ebffff0d 	bl	8f62ea98 <fsboot_find_and_boot>
	if (ret > 0)
		return ret;

	return -1;
8f62ee60:	e3500000 	cmp	r0, #0
8f62ee64:	d3e00000 	mvnle	r0, #0
}
8f62ee68:	e59f301c 	ldr	r3, [pc, #28]	; 8f62ee8c <fsboot_boot_first+0x74>
8f62ee6c:	e5932000 	ldr	r2, [r3]
8f62ee70:	e59d3004 	ldr	r3, [r13, #4]
8f62ee74:	e0332002 	eors	r2, r3, r2
8f62ee78:	e3a03000 	mov	r3, #0
8f62ee7c:	1a000001 	bne	8f62ee88 <fsboot_boot_first+0x70>
8f62ee80:	e28dd00c 	add	r13, r13, #12
8f62ee84:	e8bd8030 	pop	{r4, r5, r15}
8f62ee88:	eb000f4c 	bl	8f632bc0 <__stack_chk_fail>
8f62ee8c:	8f74221c 	.word	0x8f74221c

8f62ee90 <get_recovery_message>:
extern uint32_t get_page_size();
extern void reset_device_info();
extern void set_device_root();

int get_recovery_message(struct recovery_message *out)
{
8f62ee90:	e59f30d4 	ldr	r3, [pc, #212]	; 8f62ef6c <get_recovery_message+0xdc>
8f62ee94:	e92d4030 	push	{r4, r5, r14}
8f62ee98:	e24dd014 	sub	r13, r13, #20
8f62ee9c:	e5933000 	ldr	r3, [r3]
8f62eea0:	e58d300c 	str	r3, [r13, #12]
8f62eea4:	e3a03000 	mov	r3, #0
8f62eea8:	e1a05000 	mov	r5, r0
	struct ptentry *ptn;
	struct ptable *ptable;
	unsigned offset = 0;
	unsigned pagesize = flash_page_size();
8f62eeac:	ebff900c 	bl	8f612ee4 <flash_page_size>
8f62eeb0:	e1a04000 	mov	r4, r0

	ptable = flash_get_ptable();
8f62eeb4:	ebff9043 	bl	8f612fc8 <flash_get_ptable>

	if (ptable == NULL) {
8f62eeb8:	e3500000 	cmp	r0, #0
8f62eebc:	0a000024 	beq	8f62ef54 <get_recovery_message+0xc4>
		dprintf(CRITICAL, "ERROR: Partition table not found\n");
		return -1;
	}
	ptn = ptable_find(ptable, "misc");
8f62eec0:	e3001d40 	movw	r1, #3392	; 0xd40
8f62eec4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62eec8:	eb001e9c 	bl	8f636940 <ptable_find>

	if (ptn == NULL) {
8f62eecc:	e3500000 	cmp	r0, #0
8f62eed0:	0a00001a 	beq	8f62ef40 <get_recovery_message+0xb0>
8f62eed4:	e1a02004 	mov	r2, r4
8f62eed8:	e58d4000 	str	r4, [r13]
8f62eedc:	e3013180 	movw	r3, #4480	; 0x1180
8f62eee0:	e3a01000 	mov	r1, #0
8f62eee4:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62eee8:	ebff9049 	bl	8f613014 <flash_read_ext>
		dprintf(CRITICAL, "ERROR: No misc partition found\n");
		return -1;
	}

	offset += (pagesize * MISC_COMMAND_PAGE);
	if (flash_read(ptn, offset, (void *) buf, pagesize)) {
8f62eeec:	e2504000 	subs	r4, r0, #0
8f62eef0:	1a00000d 	bne	8f62ef2c <get_recovery_message+0x9c>
		dprintf(CRITICAL, "ERROR: Cannot read recovery_header\n");
		return -1;
	}
	memcpy(out, buf, sizeof(*out));
8f62eef4:	e3011180 	movw	r1, #4480	; 0x1180
8f62eef8:	e3a02d11 	mov	r2, #1088	; 0x440
8f62eefc:	e3481f74 	movt	r1, #36724	; 0x8f74
8f62ef00:	e1a00005 	mov	r0, r5
8f62ef04:	eb0014ab 	bl	8f6341b8 <memcpy>
	return 0;
}
8f62ef08:	e59f305c 	ldr	r3, [pc, #92]	; 8f62ef6c <get_recovery_message+0xdc>
8f62ef0c:	e5932000 	ldr	r2, [r3]
8f62ef10:	e59d300c 	ldr	r3, [r13, #12]
8f62ef14:	e0332002 	eors	r2, r3, r2
8f62ef18:	e3a03000 	mov	r3, #0
8f62ef1c:	1a000011 	bne	8f62ef68 <get_recovery_message+0xd8>
8f62ef20:	e1a00004 	mov	r0, r4
8f62ef24:	e28dd014 	add	r13, r13, #20
8f62ef28:	e8bd8030 	pop	{r4, r5, r15}
		dprintf(CRITICAL, "ERROR: Cannot read recovery_header\n");
8f62ef2c:	e30a0bec 	movw	r0, #44012	; 0xabec
8f62ef30:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62ef34:	eb000e8e 	bl	8f632974 <_dprintf>
		return -1;
8f62ef38:	e3e04000 	mvn	r4, #0
8f62ef3c:	eafffff1 	b	8f62ef08 <get_recovery_message+0x78>
		dprintf(CRITICAL, "ERROR: No misc partition found\n");
8f62ef40:	e30a0bcc 	movw	r0, #43980	; 0xabcc
8f62ef44:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62ef48:	eb000e89 	bl	8f632974 <_dprintf>
		return -1;
8f62ef4c:	e3e04000 	mvn	r4, #0
8f62ef50:	eaffffec 	b	8f62ef08 <get_recovery_message+0x78>
		dprintf(CRITICAL, "ERROR: Partition table not found\n");
8f62ef54:	e3080e04 	movw	r0, #36356	; 0x8e04
8f62ef58:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62ef5c:	eb000e84 	bl	8f632974 <_dprintf>
		return -1;
8f62ef60:	e3e04000 	mvn	r4, #0
8f62ef64:	eaffffe7 	b	8f62ef08 <get_recovery_message+0x78>
}
8f62ef68:	eb000f14 	bl	8f632bc0 <__stack_chk_fail>
8f62ef6c:	8f74221c 	.word	0x8f74221c

8f62ef70 <set_recovery_message>:

int set_recovery_message(const struct recovery_message *in)
{
8f62ef70:	e59f3104 	ldr	r3, [pc, #260]	; 8f62f07c <set_recovery_message+0x10c>
8f62ef74:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f62ef78:	e24dd014 	sub	r13, r13, #20
8f62ef7c:	e5933000 	ldr	r3, [r3]
8f62ef80:	e58d300c 	str	r3, [r13, #12]
8f62ef84:	e3a03000 	mov	r3, #0
8f62ef88:	e1a08000 	mov	r8, r0
	struct ptentry *ptn;
	struct ptable *ptable;
	unsigned offset = 0;
	unsigned pagesize = flash_page_size();
8f62ef8c:	ebff8fd4 	bl	8f612ee4 <flash_page_size>
8f62ef90:	e1a05000 	mov	r5, r0
	unsigned n = 0;
	void *scratch_addr = target_get_scratch_address();
8f62ef94:	ebff48ee 	bl	8f601354 <target_get_scratch_address>
8f62ef98:	e1a04000 	mov	r4, r0

	ptable = flash_get_ptable();
8f62ef9c:	ebff9009 	bl	8f612fc8 <flash_get_ptable>

	if (ptable == NULL) {
8f62efa0:	e3500000 	cmp	r0, #0
8f62efa4:	0a00002e 	beq	8f62f064 <set_recovery_message+0xf4>
		dprintf(CRITICAL, "ERROR: Partition table not found\n");
		return -1;
	}
	ptn = ptable_find(ptable, "misc");
8f62efa8:	e3001d40 	movw	r1, #3392	; 0xd40
8f62efac:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62efb0:	eb001e62 	bl	8f636940 <ptable_find>

	if (ptn == NULL) {
8f62efb4:	e2506000 	subs	r6, r0, #0
8f62efb8:	0a000024 	beq	8f62f050 <set_recovery_message+0xe0>
8f62efbc:	e3a02000 	mov	r2, #0
		dprintf(CRITICAL, "ERROR: No misc partition found\n");
		return -1;
	}

	n = pagesize * (MISC_COMMAND_PAGE + 1);
8f62efc0:	e1a09085 	lsl	r9, r5, #1
8f62efc4:	e1a03004 	mov	r3, r4
8f62efc8:	e1a01002 	mov	r1, r2
8f62efcc:	e58d9000 	str	r9, [r13]
8f62efd0:	ebff900f 	bl	8f613014 <flash_read_ext>

	if (flash_read(ptn, offset, scratch_addr, n)) {
8f62efd4:	e2507000 	subs	r7, r0, #0
8f62efd8:	1a000012 	bne	8f62f028 <set_recovery_message+0xb8>
		return -1;
	}

	offset += (pagesize * MISC_COMMAND_PAGE);
	offset += (unsigned) scratch_addr;
	memcpy((void *) offset, in, sizeof(*in));
8f62efdc:	e1a01008 	mov	r1, r8
8f62efe0:	e3a02d11 	mov	r2, #1088	; 0x440
8f62efe4:	e0840005 	add	r0, r4, r5
8f62efe8:	eb001472 	bl	8f6341b8 <memcpy>
	if (flash_write(ptn, 0, scratch_addr, n)) {
8f62efec:	e1a03009 	mov	r3, r9
8f62eff0:	e1a02004 	mov	r2, r4
8f62eff4:	e1a01007 	mov	r1, r7
8f62eff8:	e1a00006 	mov	r0, r6
8f62effc:	ebff90d5 	bl	8f613358 <flash_write>
8f62f000:	e3500000 	cmp	r0, #0
8f62f004:	1a00000c 	bne	8f62f03c <set_recovery_message+0xcc>
		dprintf(CRITICAL, "ERROR: flash write fail!\n");
		return -1;
	}
	return 0;
}
8f62f008:	e59f306c 	ldr	r3, [pc, #108]	; 8f62f07c <set_recovery_message+0x10c>
8f62f00c:	e5932000 	ldr	r2, [r3]
8f62f010:	e59d300c 	ldr	r3, [r13, #12]
8f62f014:	e0332002 	eors	r2, r3, r2
8f62f018:	e3a03000 	mov	r3, #0
8f62f01c:	1a000015 	bne	8f62f078 <set_recovery_message+0x108>
8f62f020:	e28dd014 	add	r13, r13, #20
8f62f024:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
		dprintf(CRITICAL, "ERROR: Cannot read recovery_header\n");
8f62f028:	e30a0bec 	movw	r0, #44012	; 0xabec
8f62f02c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f030:	eb000e4f 	bl	8f632974 <_dprintf>
		return -1;
8f62f034:	e3e00000 	mvn	r0, #0
8f62f038:	eafffff2 	b	8f62f008 <set_recovery_message+0x98>
		dprintf(CRITICAL, "ERROR: flash write fail!\n");
8f62f03c:	e30a0c10 	movw	r0, #44048	; 0xac10
8f62f040:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f044:	eb000e4a 	bl	8f632974 <_dprintf>
		return -1;
8f62f048:	e3e00000 	mvn	r0, #0
8f62f04c:	eaffffed 	b	8f62f008 <set_recovery_message+0x98>
		dprintf(CRITICAL, "ERROR: No misc partition found\n");
8f62f050:	e30a0bcc 	movw	r0, #43980	; 0xabcc
8f62f054:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f058:	eb000e45 	bl	8f632974 <_dprintf>
		return -1;
8f62f05c:	e3e00000 	mvn	r0, #0
8f62f060:	eaffffe8 	b	8f62f008 <set_recovery_message+0x98>
		dprintf(CRITICAL, "ERROR: Partition table not found\n");
8f62f064:	e3080e04 	movw	r0, #36356	; 0x8e04
8f62f068:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f06c:	eb000e40 	bl	8f632974 <_dprintf>
		return -1;
8f62f070:	e3e00000 	mvn	r0, #0
8f62f074:	eaffffe3 	b	8f62f008 <set_recovery_message+0x98>
}
8f62f078:	eb000ed0 	bl	8f632bc0 <__stack_chk_fail>
8f62f07c:	8f74221c 	.word	0x8f74221c

8f62f080 <recovery_init>:
 * The bootloader will not modify or erase the cache partition.
 * It is recovery's responsibility to clean up the mess afterwards.
 */

int recovery_init (void)
{
8f62f080:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f62f084:	e24dde47 	sub	r13, r13, #1136	; 0x470
8f62f088:	e24dd004 	sub	r13, r13, #4
8f62f08c:	e59f330c 	ldr	r3, [pc, #780]	; 8f62f3a0 <recovery_init+0x320>
	char partition_name[32];
	unsigned valid_command = 0;
	int update_status = 0;

	// get recovery message
	if (get_recovery_message(&msg))
8f62f090:	e28d000c 	add	r0, r13, #12
{
8f62f094:	e5933000 	ldr	r3, [r3]
8f62f098:	e58d346c 	str	r3, [r13, #1132]	; 0x46c
8f62f09c:	e3a03000 	mov	r3, #0
	if (get_recovery_message(&msg))
8f62f0a0:	ebffff7a 	bl	8f62ee90 <get_recovery_message>
8f62f0a4:	e2504000 	subs	r4, r0, #0
8f62f0a8:	1a00009b 	bne	8f62f31c <recovery_init+0x29c>
		return -1;
	msg.command[sizeof(msg.command)-1] = '\0'; //Ensure termination
	if (msg.command[0] != 0 && msg.command[0] != 255) {
8f62f0ac:	e5dd300c 	ldrb	r3, [r13, #12]
	msg.command[sizeof(msg.command)-1] = '\0'; //Ensure termination
8f62f0b0:	e5cd402b 	strb	r4, [r13, #43]	; 0x2b
	if (msg.command[0] != 0 && msg.command[0] != 255) {
8f62f0b4:	e2433001 	sub	r3, r3, #1
8f62f0b8:	e6ef3073 	uxtb	r3, r3
8f62f0bc:	e35300fd 	cmp	r3, #253	; 0xfd
8f62f0c0:	9a000061 	bls	8f62f24c <recovery_init+0x1cc>
		dprintf(INFO,"Recovery command: %d %s\n",
			sizeof(msg.command), msg.command);
	}

	if (!strcmp("boot-recovery",msg.command))
8f62f0c4:	e28d100c 	add	r1, r13, #12
8f62f0c8:	e30a0ca4 	movw	r0, #44196	; 0xaca4
8f62f0cc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f0d0:	eb001513 	bl	8f634524 <strcmp>
8f62f0d4:	e2505000 	subs	r5, r0, #0
8f62f0d8:	0a00004e 	beq	8f62f218 <recovery_init+0x198>
		}
		boot_into_recovery = 1;		// Boot in recovery mode
		return 0;
	}

	if (!strcmp("update-radio",msg.command)) {
8f62f0dc:	e28d100c 	add	r1, r13, #12
8f62f0e0:	e30a0cfc 	movw	r0, #44284	; 0xacfc
8f62f0e4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f0e8:	eb00150d 	bl	8f634524 <strcmp>
8f62f0ec:	e2505000 	subs	r5, r0, #0
8f62f0f0:	1a00003e 	bne	8f62f1f0 <recovery_init+0x170>
		dprintf(INFO,"start radio update\n");
8f62f0f4:	e30a0d0c 	movw	r0, #44300	; 0xad0c
8f62f0f8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f0fc:	eb000e1c 	bl	8f632974 <_dprintf>
		valid_command = 1;
		strlcpy(partition_name, "FOTA", sizeof(partition_name));
8f62f100:	e28d0d11 	add	r0, r13, #1088	; 0x440
8f62f104:	e3a02020 	mov	r2, #32
8f62f108:	e280000c 	add	r0, r0, #12
8f62f10c:	e30a1d20 	movw	r1, #44320	; 0xad20
8f62f110:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f114:	eb001585 	bl	8f634730 <strlcpy>
	unsigned pagesize = flash_page_size();
8f62f118:	ebff8f71 	bl	8f612ee4 <flash_page_size>
8f62f11c:	e1a06000 	mov	r6, r0
	ptable = flash_get_ptable();
8f62f120:	ebff8fa8 	bl	8f612fc8 <flash_get_ptable>
	if (ptable == NULL) {
8f62f124:	e2507000 	subs	r7, r0, #0
8f62f128:	0a000093 	beq	8f62f37c <recovery_init+0x2fc>
	ssd_cookie = malloc(pagesize);
8f62f12c:	e1a00006 	mov	r0, r6
8f62f130:	eb0013b1 	bl	8f633ffc <malloc>
	if (!ssd_cookie){
8f62f134:	e2504000 	subs	r4, r0, #0
8f62f138:	0a000094 	beq	8f62f390 <recovery_init+0x310>
	memset(ssd_cookie, 0, pagesize);
8f62f13c:	e1a02006 	mov	r2, r6
8f62f140:	e1a01005 	mov	r1, r5
8f62f144:	eb00145e 	bl	8f6342c4 <memset>
	ptn = ptable_find(ptable, name);
8f62f148:	e28d1d11 	add	r1, r13, #1088	; 0x440
8f62f14c:	e281100c 	add	r1, r1, #12
8f62f150:	e1a00007 	mov	r0, r7
	ssd_cookie[0] = 0x53534443;
8f62f154:	e3043443 	movw	r3, #17475	; 0x4443
8f62f158:	e3453353 	movt	r3, #21331	; 0x5353
8f62f15c:	e5843000 	str	r3, [r4]
	ssd_cookie[1] = 0x4F4F4B49;
8f62f160:	e3043b49 	movw	r3, #19273	; 0x4b49
8f62f164:	e3443f4f 	movt	r3, #20303	; 0x4f4f
8f62f168:	e5843004 	str	r3, [r4, #4]
	ptn = ptable_find(ptable, name);
8f62f16c:	eb001df3 	bl	8f636940 <ptable_find>
	if (ptn == NULL) {
8f62f170:	e3500000 	cmp	r0, #0
8f62f174:	0a00007a 	beq	8f62f364 <recovery_init+0x2e4>
	if (flash_write(ptn, 0, ssd_cookie, pagesize)) {
8f62f178:	e1a03006 	mov	r3, r6
8f62f17c:	e1a01005 	mov	r1, r5
8f62f180:	e1a02004 	mov	r2, r4
8f62f184:	ebff9073 	bl	8f613358 <flash_write>
8f62f188:	e3500000 	cmp	r0, #0
8f62f18c:	1a000064 	bne	8f62f324 <recovery_init+0x2a4>
	free(ssd_cookie);
8f62f190:	e1a00004 	mov	r0, r4
8f62f194:	eb0013dc 	bl	8f63410c <free>
	dprintf(INFO, "FOTA partition written successfully!");
8f62f198:	e30a0d4c 	movw	r0, #44364	; 0xad4c
8f62f19c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f1a0:	eb000df3 	bl	8f632974 <_dprintf>
		strlcpy(msg.status, "failed-update", sizeof(msg.status));
		goto SEND_RECOVERY_MSG;
	}
	else {
		/* Setting this to check the radio update status */
		strlcpy(msg.command, "boot-recovery", sizeof(msg.command));
8f62f1a4:	e3a02020 	mov	r2, #32
8f62f1a8:	e28d000c 	add	r0, r13, #12
8f62f1ac:	e30a1ca4 	movw	r1, #44196	; 0xaca4
8f62f1b0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f1b4:	eb00155d 	bl	8f634730 <strlcpy>
		strlcpy(msg.status, "RADIO", sizeof(msg.status));
8f62f1b8:	e30a1cb4 	movw	r1, #44212	; 0xacb4
8f62f1bc:	e28d002c 	add	r0, r13, #44	; 0x2c
8f62f1c0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f1c4:	e3a02020 	mov	r2, #32
8f62f1c8:	eb001558 	bl	8f634730 <strlcpy>
		goto SEND_RECOVERY_MSG;
	}
	strlcpy(msg.status, "OKAY", sizeof(msg.status));

SEND_RECOVERY_MSG:
	set_recovery_message(&msg);	// send recovery message
8f62f1cc:	e28d000c 	add	r0, r13, #12
	boot_into_recovery = 1;		// Boot in recovery mode
	reboot_device(0);
	return 0;
8f62f1d0:	e3a04000 	mov	r4, #0
	set_recovery_message(&msg);	// send recovery message
8f62f1d4:	ebffff65 	bl	8f62ef70 <set_recovery_message>
	boot_into_recovery = 1;		// Boot in recovery mode
8f62f1d8:	e301317c 	movw	r3, #4476	; 0x117c
8f62f1dc:	e3483f74 	movt	r3, #36724	; 0x8f74
	reboot_device(0);
8f62f1e0:	e1a00004 	mov	r0, r4
	boot_into_recovery = 1;		// Boot in recovery mode
8f62f1e4:	e3a02001 	mov	r2, #1
8f62f1e8:	e5832000 	str	r2, [r3]
	reboot_device(0);
8f62f1ec:	ebffc449 	bl	8f620318 <reboot_device>
}
8f62f1f0:	e59f31a8 	ldr	r3, [pc, #424]	; 8f62f3a0 <recovery_init+0x320>
8f62f1f4:	e5932000 	ldr	r2, [r3]
8f62f1f8:	e59d346c 	ldr	r3, [r13, #1132]	; 0x46c
8f62f1fc:	e0332002 	eors	r2, r3, r2
8f62f200:	e3a03000 	mov	r3, #0
8f62f204:	1a000060 	bne	8f62f38c <recovery_init+0x30c>
8f62f208:	e1a00004 	mov	r0, r4
8f62f20c:	e28dde47 	add	r13, r13, #1136	; 0x470
8f62f210:	e28dd004 	add	r13, r13, #4
8f62f214:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		if(!strcmp("RADIO",msg.status))
8f62f218:	e28d602c 	add	r6, r13, #44	; 0x2c
8f62f21c:	e30a0cb4 	movw	r0, #44212	; 0xacb4
8f62f220:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f224:	e1a01006 	mov	r1, r6
8f62f228:	eb0014bd 	bl	8f634524 <strcmp>
8f62f22c:	e2504000 	subs	r4, r0, #0
8f62f230:	0a00000b 	beq	8f62f264 <recovery_init+0x1e4>
		boot_into_recovery = 1;		// Boot in recovery mode
8f62f234:	e301317c 	movw	r3, #4476	; 0x117c
8f62f238:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62f23c:	e3a02001 	mov	r2, #1
		return 0;
8f62f240:	e1a04005 	mov	r4, r5
		boot_into_recovery = 1;		// Boot in recovery mode
8f62f244:	e5832000 	str	r2, [r3]
		return 0;
8f62f248:	eaffffe8 	b	8f62f1f0 <recovery_init+0x170>
		dprintf(INFO,"Recovery command: %d %s\n",
8f62f24c:	e28d200c 	add	r2, r13, #12
8f62f250:	e3a01020 	mov	r1, #32
8f62f254:	e30a0c88 	movw	r0, #44168	; 0xac88
8f62f258:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f25c:	eb000dc4 	bl	8f632974 <_dprintf>
8f62f260:	eaffff97 	b	8f62f0c4 <recovery_init+0x44>
	ret = smem_read_alloc_entry(SMEM_BOOT_INFO_FOR_APPS,
8f62f264:	e1a0100d 	mov	r1, r13
8f62f268:	e3a0200c 	mov	r2, #12
8f62f26c:	e30001a2 	movw	r0, #418	; 0x1a2
8f62f270:	ebff4d6a 	bl	8f602820 <smem_read_alloc_entry>
	if (ret)
8f62f274:	e2501000 	subs	r1, r0, #0
8f62f278:	1a00001a 	bne	8f62f2e8 <recovery_init+0x268>
	dprintf(INFO,"boot flag %x update status %x\n",apps_boot_info.boot_flags,
8f62f27c:	e89d0006 	ldm	r13, {r1, r2}
8f62f280:	e30a0c68 	movw	r0, #44136	; 0xac68
8f62f284:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f288:	eb000db9 	bl	8f632974 <_dprintf>
		*status = apps_boot_info.status.update_status;
8f62f28c:	e59d3004 	ldr	r3, [r13, #4]
			if(!ret && (update_status & 0x01))
8f62f290:	e3130001 	tst	r3, #1
8f62f294:	1a000017 	bne	8f62f2f8 <recovery_init+0x278>
				dprintf(INFO,"radio update failed\n");
8f62f298:	e30a0cd4 	movw	r0, #44244	; 0xacd4
8f62f29c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f2a0:	eb000db3 	bl	8f632974 <_dprintf>
				strlcpy(msg.status, "failed-update", sizeof(msg.status));
8f62f2a4:	e30a1cec 	movw	r1, #44268	; 0xacec
8f62f2a8:	e28d002c 	add	r0, r13, #44	; 0x2c
8f62f2ac:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f2b0:	e3a02020 	mov	r2, #32
8f62f2b4:	eb00151d 	bl	8f634730 <strlcpy>
			strlcpy(msg.command, "", sizeof(msg.command));	// clearing recovery command
8f62f2b8:	e3a02020 	mov	r2, #32
8f62f2bc:	e28d000c 	add	r0, r13, #12
8f62f2c0:	e3071138 	movw	r1, #28984	; 0x7138
8f62f2c4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f2c8:	eb001518 	bl	8f634730 <strlcpy>
			set_recovery_message(&msg);	// send recovery message
8f62f2cc:	e28d000c 	add	r0, r13, #12
8f62f2d0:	ebffff26 	bl	8f62ef70 <set_recovery_message>
			boot_into_recovery = 1;		// Boot in recovery mode
8f62f2d4:	e301317c 	movw	r3, #4476	; 0x117c
8f62f2d8:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62f2dc:	e3a02001 	mov	r2, #1
8f62f2e0:	e5832000 	str	r2, [r3]
			return 0;
8f62f2e4:	eaffffc1 	b	8f62f1f0 <recovery_init+0x170>
		dprintf(CRITICAL, "ERROR: unable to read shared memory for apps boot info %d\n",ret);
8f62f2e8:	e30a0c2c 	movw	r0, #44076	; 0xac2c
8f62f2ec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f2f0:	eb000d9f 	bl	8f632974 <_dprintf>
			if(!ret && (update_status & 0x01))
8f62f2f4:	eaffffe7 	b	8f62f298 <recovery_init+0x218>
				dprintf(INFO,"radio update success\n");
8f62f2f8:	e30a0cbc 	movw	r0, #44220	; 0xacbc
8f62f2fc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f300:	eb000d9b 	bl	8f632974 <_dprintf>
				strlcpy(msg.status, "OKAY", sizeof(msg.status));
8f62f304:	e3a02020 	mov	r2, #32
8f62f308:	e30a11d0 	movw	r1, #41424	; 0xa1d0
8f62f30c:	e1a00006 	mov	r0, r6
8f62f310:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f314:	eb001505 	bl	8f634730 <strlcpy>
8f62f318:	eaffffe6 	b	8f62f2b8 <recovery_init+0x238>
		return -1;
8f62f31c:	e3e04000 	mvn	r4, #0
8f62f320:	eaffffb2 	b	8f62f1f0 <recovery_init+0x170>
		dprintf(CRITICAL, "ERROR: flash write fail!\n");
8f62f324:	e30a0c10 	movw	r0, #44048	; 0xac10
8f62f328:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f32c:	eb000d90 	bl	8f632974 <_dprintf>
	free(ssd_cookie);
8f62f330:	e1a00004 	mov	r0, r4
8f62f334:	eb001374 	bl	8f63410c <free>
		strlcpy(msg.command, "", sizeof(msg.command));
8f62f338:	e28d000c 	add	r0, r13, #12
8f62f33c:	e3a02020 	mov	r2, #32
8f62f340:	e3071138 	movw	r1, #28984	; 0x7138
8f62f344:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f348:	eb0014f8 	bl	8f634730 <strlcpy>
		strlcpy(msg.status, "failed-update", sizeof(msg.status));
8f62f34c:	e28d002c 	add	r0, r13, #44	; 0x2c
8f62f350:	e30a1cec 	movw	r1, #44268	; 0xacec
8f62f354:	e3a02020 	mov	r2, #32
8f62f358:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f35c:	eb0014f3 	bl	8f634730 <strlcpy>
		goto SEND_RECOVERY_MSG;
8f62f360:	eaffff99 	b	8f62f1cc <recovery_init+0x14c>
		dprintf(CRITICAL, "ERROR: No %s partition found\n", name);
8f62f364:	e28d1d11 	add	r1, r13, #1088	; 0x440
8f62f368:	e30808a0 	movw	r0, #34976	; 0x88a0
8f62f36c:	e281100c 	add	r1, r1, #12
8f62f370:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f374:	eb000d7e 	bl	8f632974 <_dprintf>
		goto out;
8f62f378:	eaffffec 	b	8f62f330 <recovery_init+0x2b0>
		dprintf(CRITICAL, "ERROR: Partition table not found\n");
8f62f37c:	e3080e04 	movw	r0, #36356	; 0x8e04
8f62f380:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f384:	eb000d7a 	bl	8f632974 <_dprintf>
		return -1;
8f62f388:	eaffffea 	b	8f62f338 <recovery_init+0x2b8>
}
8f62f38c:	eb000e0b 	bl	8f632bc0 <__stack_chk_fail>
		dprintf(CRITICAL, "ERROR: Memory allocation failure\n");
8f62f390:	e30a0d28 	movw	r0, #44328	; 0xad28
8f62f394:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f398:	eb000d75 	bl	8f632974 <_dprintf>
		return -1;
8f62f39c:	eaffffe5 	b	8f62f338 <recovery_init+0x2b8>
8f62f3a0:	8f74221c 	.word	0x8f74221c

8f62f3a4 <_emmc_recovery_init>:

	return 0;
}

int _emmc_recovery_init(void)
{
8f62f3a4:	e59f338c 	ldr	r3, [pc, #908]	; 8f62f738 <_emmc_recovery_init+0x394>
8f62f3a8:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f62f3ac:	e24dd01c 	sub	r13, r13, #28
8f62f3b0:	e5933000 	ldr	r3, [r3]
8f62f3b4:	e58d3014 	str	r3, [r13, #20]
8f62f3b8:	e3a03000 	mov	r3, #0
	int update_status = 0;
	struct recovery_message *msg;
	uint32_t block_size = 0;

	block_size = mmc_get_device_blocksize();
8f62f3bc:	e1a0500e 	mov	r5, r14
8f62f3c0:	ebff77ed 	bl	8f60d37c <mmc_get_device_blocksize>
8f62f3c4:	e1a01000 	mov	r1, r0

	// get recovery message
	msg = (struct recovery_message *)memalign(CACHE_LINE, block_size);
8f62f3c8:	e3a00040 	mov	r0, #64	; 0x40
8f62f3cc:	eb00131c 	bl	8f634044 <memalign>
	ASSERT(msg);
8f62f3d0:	e2504000 	subs	r4, r0, #0
8f62f3d4:	0a0000a0 	beq	8f62f65c <_emmc_recovery_init+0x2b8>
	size = mmc_get_device_blocksize();
8f62f3d8:	ebff77e7 	bl	8f60d37c <mmc_get_device_blocksize>
8f62f3dc:	e1a07000 	mov	r7, r0
	index = partition_get_index((const char *) ptn_name);
8f62f3e0:	e3000d40 	movw	r0, #3392	; 0xd40
8f62f3e4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f3e8:	ebff5227 	bl	8f603c8c <partition_get_index>
	if (index < 0)
8f62f3ec:	e2505000 	subs	r5, r0, #0
8f62f3f0:	ba0000af 	blt	8f62f6b4 <_emmc_recovery_init+0x310>
	ptn = partition_get_offset(index);
8f62f3f4:	ebff5530 	bl	8f6048bc <partition_get_offset>
8f62f3f8:	e1a06000 	mov	r6, r0
	mmc_set_lun(partition_get_lun(index));
8f62f3fc:	e1a00005 	mov	r0, r5
	ptn = partition_get_offset(index);
8f62f400:	e1a05001 	mov	r5, r1
	mmc_set_lun(partition_get_lun(index));
8f62f404:	ebff554d 	bl	8f604940 <partition_get_lun>
8f62f408:	ebff7809 	bl	8f60d434 <mmc_set_lun>
	if(ptn == 0) {
8f62f40c:	e1963005 	orrs	r3, r6, r5
8f62f410:	0a00009c 	beq	8f62f688 <_emmc_recovery_init+0x2e4>
	if (mmc_read(ptn , (unsigned int*)in, size)) {
8f62f414:	e1a03007 	mov	r3, r7
8f62f418:	e1a00006 	mov	r0, r6
8f62f41c:	e1a01005 	mov	r1, r5
8f62f420:	e1a02004 	mov	r2, r4
8f62f424:	ebff7617 	bl	8f60cc88 <mmc_read>
8f62f428:	e3500000 	cmp	r0, #0
8f62f42c:	1a0000a6 	bne	8f62f6cc <_emmc_recovery_init+0x328>
			free(msg);
		return -1;
	}

	msg->command[sizeof(msg->command)-1] = '\0'; //Ensure termination
	if (msg->command[0] != 0 && msg->command[0] != 255) {
8f62f430:	e5d43000 	ldrb	r3, [r4]
	msg->command[sizeof(msg->command)-1] = '\0'; //Ensure termination
8f62f434:	e5c4001f 	strb	r0, [r4, #31]
	if (msg->command[0] != 0 && msg->command[0] != 255) {
8f62f438:	e2433001 	sub	r3, r3, #1
8f62f43c:	e6ef3073 	uxtb	r3, r3
8f62f440:	e35300fd 	cmp	r3, #253	; 0xfd
8f62f444:	9a000071 	bls	8f62f610 <_emmc_recovery_init+0x26c>
		dprintf(INFO,"Recovery command: %d %s\n",
			sizeof(msg->command), msg->command);
	}

	if (!strcmp(msg->command, "boot-recovery")) {
8f62f448:	e30a1ca4 	movw	r1, #44196	; 0xaca4
8f62f44c:	e1a00004 	mov	r0, r4
8f62f450:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f454:	eb001432 	bl	8f634524 <strcmp>
		boot_into_recovery = 1;
	}

	if (!strcmp("update-radio",msg->command))
8f62f458:	e1a01004 	mov	r1, r4
	if (!strcmp(msg->command, "boot-recovery")) {
8f62f45c:	e3500000 	cmp	r0, #0
	if (!strcmp("update-radio",msg->command))
8f62f460:	e30a0cfc 	movw	r0, #44284	; 0xacfc
8f62f464:	e3480f70 	movt	r0, #36720	; 0x8f70
		boot_into_recovery = 1;
8f62f468:	0301317c 	movweq	r3, #4476	; 0x117c
8f62f46c:	03483f74 	movteq	r3, #36724	; 0x8f74
8f62f470:	03a02001 	moveq	r2, #1
8f62f474:	05832000 	streq	r2, [r3]
	if (!strcmp("update-radio",msg->command))
8f62f478:	eb001429 	bl	8f634524 <strcmp>
8f62f47c:	e3500000 	cmp	r0, #0
8f62f480:	0a000047 	beq	8f62f5a4 <_emmc_recovery_init+0x200>
			dprintf(INFO,"radio update failed\n");
			strlcpy(msg->status, "failed-update", sizeof(msg->status));
		}
		boot_into_recovery = 1;		// Boot in recovery mode
	}
	if (!strcmp("reset-device-info",msg->command))
8f62f484:	e1a01004 	mov	r1, r4
8f62f488:	e30a0de0 	movw	r0, #44512	; 0xade0
8f62f48c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f490:	eb001423 	bl	8f634524 <strcmp>
8f62f494:	e3500000 	cmp	r0, #0
8f62f498:	0a00003f 	beq	8f62f59c <_emmc_recovery_init+0x1f8>
	{
		reset_device_info();
	}
	if (!strcmp("root-detect",msg->command))
8f62f49c:	e1a01004 	mov	r1, r4
8f62f4a0:	e30a0df4 	movw	r0, #44532	; 0xadf4
8f62f4a4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f4a8:	eb00141d 	bl	8f634524 <strcmp>
8f62f4ac:	e2507000 	subs	r7, r0, #0
8f62f4b0:	0a00000a 	beq	8f62f4e0 <_emmc_recovery_init+0x13c>
	strlcpy(msg->command, "", sizeof(msg->command));	// clearing recovery command
	emmc_set_recovery_msg(msg);	// send recovery message

out:
	if(msg)
		free(msg);
8f62f4b4:	e1a00004 	mov	r0, r4
8f62f4b8:	eb001313 	bl	8f63410c <free>
	return 0;
8f62f4bc:	e3a00000 	mov	r0, #0
}
8f62f4c0:	e59f3270 	ldr	r3, [pc, #624]	; 8f62f738 <_emmc_recovery_init+0x394>
8f62f4c4:	e5932000 	ldr	r2, [r3]
8f62f4c8:	e59d3014 	ldr	r3, [r13, #20]
8f62f4cc:	e0332002 	eors	r2, r3, r2
8f62f4d0:	e3a03000 	mov	r3, #0
8f62f4d4:	1a000090 	bne	8f62f71c <_emmc_recovery_init+0x378>
8f62f4d8:	e28dd01c 	add	r13, r13, #28
8f62f4dc:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
		set_device_root();
8f62f4e0:	ebffe574 	bl	8f628ab8 <set_device_root>
	strlcpy(msg->command, "", sizeof(msg->command));	// clearing recovery command
8f62f4e4:	e3a02020 	mov	r2, #32
8f62f4e8:	e3071138 	movw	r1, #28984	; 0x7138
8f62f4ec:	e1a00004 	mov	r0, r4
8f62f4f0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f4f4:	eb00148d 	bl	8f634730 <strlcpy>
	unsigned blocksize = mmc_get_device_blocksize();
8f62f4f8:	ebff779f 	bl	8f60d37c <mmc_get_device_blocksize>
	unsigned int size = ROUND_TO_PAGE(sizeof(*out), (unsigned)blocksize - 1);
8f62f4fc:	e2805e43 	add	r5, r0, #1072	; 0x430
8f62f500:	e2600000 	rsb	r0, r0, #0
8f62f504:	e285500f 	add	r5, r5, #15
8f62f508:	e0055000 	and	r5, r5, r0
8f62f50c:	e3550d11 	cmp	r5, #1088	; 0x440
8f62f510:	33e05000 	mvncc	r5, #0
	data = malloc(size);
8f62f514:	e1a00005 	mov	r0, r5
8f62f518:	eb0012b7 	bl	8f633ffc <malloc>
	if(!data)
8f62f51c:	e2506000 	subs	r6, r0, #0
8f62f520:	0a00007e 	beq	8f62f720 <_emmc_recovery_init+0x37c>
	index = partition_get_index((const char *) ptn_name);
8f62f524:	e3000d40 	movw	r0, #3392	; 0xd40
8f62f528:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f52c:	ebff51d6 	bl	8f603c8c <partition_get_index>
8f62f530:	e1a08000 	mov	r8, r0
	ptn = partition_get_offset(index);
8f62f534:	ebff54e0 	bl	8f6048bc <partition_get_offset>
8f62f538:	e1a09000 	mov	r9, r0
	mmc_set_lun(partition_get_lun(index));
8f62f53c:	e1a00008 	mov	r0, r8
	ptn = partition_get_offset(index);
8f62f540:	e1a08001 	mov	r8, r1
	mmc_set_lun(partition_get_lun(index));
8f62f544:	ebff54fd 	bl	8f604940 <partition_get_lun>
8f62f548:	ebff77b9 	bl	8f60d434 <mmc_set_lun>
	if(ptn == 0) {
8f62f54c:	e1993008 	orrs	r3, r9, r8
8f62f550:	0a000064 	beq	8f62f6e8 <_emmc_recovery_init+0x344>
	memset(data, 0, size);
8f62f554:	e1a01007 	mov	r1, r7
8f62f558:	e1a02005 	mov	r2, r5
8f62f55c:	e1a00006 	mov	r0, r6
8f62f560:	eb001357 	bl	8f6342c4 <memset>
	memcpy(data, out, sizeof(*out));
8f62f564:	e3a02d11 	mov	r2, #1088	; 0x440
8f62f568:	e1a01004 	mov	r1, r4
8f62f56c:	e1a00006 	mov	r0, r6
8f62f570:	eb001310 	bl	8f6341b8 <memcpy>
	if (mmc_write(ptn , size, (unsigned int*)data)) {
8f62f574:	e1a03006 	mov	r3, r6
8f62f578:	e1a02005 	mov	r2, r5
8f62f57c:	e1a00009 	mov	r0, r9
8f62f580:	e1a01008 	mov	r1, r8
8f62f584:	ebff7525 	bl	8f60ca20 <mmc_write>
8f62f588:	e3500000 	cmp	r0, #0
8f62f58c:	1a00005b 	bne	8f62f700 <_emmc_recovery_init+0x35c>
		free(data);
8f62f590:	e1a00006 	mov	r0, r6
8f62f594:	eb0012dc 	bl	8f63410c <free>
8f62f598:	eaffffc5 	b	8f62f4b4 <_emmc_recovery_init+0x110>
		reset_device_info();
8f62f59c:	ebffe51f 	bl	8f628a20 <reset_device_info>
8f62f5a0:	eaffffbd 	b	8f62f49c <_emmc_recovery_init+0xf8>
	ret = smem_read_alloc_entry(SMEM_BOOT_INFO_FOR_APPS,
8f62f5a4:	e28d1008 	add	r1, r13, #8
8f62f5a8:	e3a0200c 	mov	r2, #12
8f62f5ac:	e30001a2 	movw	r0, #418	; 0x1a2
8f62f5b0:	ebff4c9a 	bl	8f602820 <smem_read_alloc_entry>
	if (ret)
8f62f5b4:	e2501000 	subs	r1, r0, #0
8f62f5b8:	1a000023 	bne	8f62f64c <_emmc_recovery_init+0x2a8>
	dprintf(INFO,"boot flag %x update status %x\n",apps_boot_info.boot_flags,
8f62f5bc:	e59d200c 	ldr	r2, [r13, #12]
8f62f5c0:	e30a0c68 	movw	r0, #44136	; 0xac68
8f62f5c4:	e59d1008 	ldr	r1, [r13, #8]
8f62f5c8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f5cc:	eb000ce8 	bl	8f632974 <_dprintf>
		*status = apps_boot_info.status.update_status;
8f62f5d0:	e59d300c 	ldr	r3, [r13, #12]
		if(!ret && (update_status & 0x01))
8f62f5d4:	e3130001 	tst	r3, #1
8f62f5d8:	1a000012 	bne	8f62f628 <_emmc_recovery_init+0x284>
			dprintf(INFO,"radio update failed\n");
8f62f5dc:	e30a0cd4 	movw	r0, #44244	; 0xacd4
8f62f5e0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f5e4:	eb000ce2 	bl	8f632974 <_dprintf>
			strlcpy(msg->status, "failed-update", sizeof(msg->status));
8f62f5e8:	e30a1cec 	movw	r1, #44268	; 0xacec
8f62f5ec:	e2840020 	add	r0, r4, #32
8f62f5f0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f5f4:	e3a02020 	mov	r2, #32
8f62f5f8:	eb00144c 	bl	8f634730 <strlcpy>
		boot_into_recovery = 1;		// Boot in recovery mode
8f62f5fc:	e301317c 	movw	r3, #4476	; 0x117c
8f62f600:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62f604:	e3a02001 	mov	r2, #1
8f62f608:	e5832000 	str	r2, [r3]
8f62f60c:	eaffff9c 	b	8f62f484 <_emmc_recovery_init+0xe0>
		dprintf(INFO,"Recovery command: %d %s\n",
8f62f610:	e30a0c88 	movw	r0, #44168	; 0xac88
8f62f614:	e1a02004 	mov	r2, r4
8f62f618:	e3a01020 	mov	r1, #32
8f62f61c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f620:	eb000cd3 	bl	8f632974 <_dprintf>
8f62f624:	eaffff87 	b	8f62f448 <_emmc_recovery_init+0xa4>
			dprintf(INFO,"radio update success\n");
8f62f628:	e30a0cbc 	movw	r0, #44220	; 0xacbc
8f62f62c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f630:	eb000ccf 	bl	8f632974 <_dprintf>
			strlcpy(msg->status, "OKAY", sizeof(msg->status));
8f62f634:	e2840020 	add	r0, r4, #32
8f62f638:	e3a02020 	mov	r2, #32
8f62f63c:	e30a11d0 	movw	r1, #41424	; 0xa1d0
8f62f640:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f644:	eb001439 	bl	8f634730 <strlcpy>
8f62f648:	eaffffeb 	b	8f62f5fc <_emmc_recovery_init+0x258>
		dprintf(CRITICAL, "ERROR: unable to read shared memory for apps boot info %d\n",ret);
8f62f64c:	e30a0c2c 	movw	r0, #44076	; 0xac2c
8f62f650:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f654:	eb000cc6 	bl	8f632974 <_dprintf>
		if(!ret && (update_status & 0x01))
8f62f658:	eaffffdf 	b	8f62f5dc <_emmc_recovery_init+0x238>
	ASSERT(msg);
8f62f65c:	e30acd8c 	movw	r12, #44428	; 0xad8c
8f62f660:	e30a2d74 	movw	r2, #44404	; 0xad74
8f62f664:	e348cf70 	movt	r12, #36720	; 0x8f70
8f62f668:	e3482f70 	movt	r2, #36720	; 0x8f70
8f62f66c:	e3001130 	movw	r1, #304	; 0x130
8f62f670:	e300317e 	movw	r3, #382	; 0x17e
8f62f674:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f678:	e1a00005 	mov	r0, r5
8f62f67c:	e58dc000 	str	r12, [r13]
8f62f680:	eb000d0d 	bl	8f632abc <_panic>
8f62f684:	eaffff53 	b	8f62f3d8 <_emmc_recovery_init+0x34>
		dprintf(CRITICAL,"partition %s doesn't exist\n",ptn_name);
8f62f688:	e3001d40 	movw	r1, #3392	; 0xd40
8f62f68c:	e30a0dac 	movw	r0, #44460	; 0xadac
8f62f690:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f694:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f698:	eb000cb5 	bl	8f632974 <_dprintf>
		if(msg)
8f62f69c:	e3540000 	cmp	r4, #0
8f62f6a0:	0a000022 	beq	8f62f730 <_emmc_recovery_init+0x38c>
			free(msg);
8f62f6a4:	e1a00004 	mov	r0, r4
8f62f6a8:	eb001297 	bl	8f63410c <free>
		return -1;
8f62f6ac:	e3e00000 	mvn	r0, #0
8f62f6b0:	eaffff82 	b	8f62f4c0 <_emmc_recovery_init+0x11c>
		dprintf(CRITICAL, "%s: Partition not found\n", ptn_name);
8f62f6b4:	e3001d40 	movw	r1, #3392	; 0xd40
8f62f6b8:	e30a0d90 	movw	r0, #44432	; 0xad90
8f62f6bc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f6c0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f6c4:	eb000caa 	bl	8f632974 <_dprintf>
		return -1;
8f62f6c8:	eafffff3 	b	8f62f69c <_emmc_recovery_init+0x2f8>
		dprintf(CRITICAL,"mmc read failure %s %d\n",ptn_name, size);
8f62f6cc:	e1a02007 	mov	r2, r7
8f62f6d0:	e3001d40 	movw	r1, #3392	; 0xd40
8f62f6d4:	e30a0dc8 	movw	r0, #44488	; 0xadc8
8f62f6d8:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f6dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f6e0:	eb000ca3 	bl	8f632974 <_dprintf>
		return -1;
8f62f6e4:	eaffffec 	b	8f62f69c <_emmc_recovery_init+0x2f8>
		dprintf(CRITICAL,"partition %s doesn't exist\n",ptn_name);
8f62f6e8:	e3001d40 	movw	r1, #3392	; 0xd40
8f62f6ec:	e30a0dac 	movw	r0, #44460	; 0xadac
8f62f6f0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f6f4:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f6f8:	eb000c9d 	bl	8f632974 <_dprintf>
		goto out;
8f62f6fc:	eaffffa3 	b	8f62f590 <_emmc_recovery_init+0x1ec>
		dprintf(CRITICAL,"mmc write failure %s %d\n",ptn_name, sizeof(*out));
8f62f700:	e3a02d11 	mov	r2, #1088	; 0x440
8f62f704:	e3001d40 	movw	r1, #3392	; 0xd40
8f62f708:	e30a0e1c 	movw	r0, #44572	; 0xae1c
8f62f70c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f710:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f714:	eb000c96 	bl	8f632974 <_dprintf>
		goto out;
8f62f718:	eaffff9c 	b	8f62f590 <_emmc_recovery_init+0x1ec>
}
8f62f71c:	eb000d27 	bl	8f632bc0 <__stack_chk_fail>
		dprintf(CRITICAL,"memory allocation error \n");
8f62f720:	e30a0e00 	movw	r0, #44544	; 0xae00
8f62f724:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f728:	eb000c91 	bl	8f632974 <_dprintf>
	if (data)
8f62f72c:	eaffff60 	b	8f62f4b4 <_emmc_recovery_init+0x110>
		return -1;
8f62f730:	e3e00000 	mvn	r0, #0
8f62f734:	eaffff61 	b	8f62f4c0 <_emmc_recovery_init+0x11c>
8f62f738:	8f74221c 	.word	0x8f74221c

8f62f73c <write_misc>:

	return 0;
}

int write_misc(unsigned page_offset, void *buf, unsigned size)
{
8f62f73c:	e59f3250 	ldr	r3, [pc, #592]	; 8f62f994 <write_misc+0x258>
8f62f740:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f62f744:	e24dd014 	sub	r13, r13, #20
8f62f748:	e1a08001 	mov	r8, r1
8f62f74c:	e1a05002 	mov	r5, r2
8f62f750:	e5933000 	ldr	r3, [r3]
8f62f754:	e58d300c 	str	r3, [r13, #12]
8f62f758:	e3a03000 	mov	r3, #0
8f62f75c:	e1a04000 	mov	r4, r0
	const char *ptn_name = "misc";
	void *scratch_addr = target_get_scratch_address();
8f62f760:	ebff46fb 	bl	8f601354 <target_get_scratch_address>
	unsigned offset;
	unsigned aligned_size;

	if (size == 0 || buf == NULL || scratch_addr == NULL)
8f62f764:	e3580000 	cmp	r8, #0
8f62f768:	13550000 	cmpne	r5, #0
8f62f76c:	03a09001 	moveq	r9, #1
8f62f770:	13a09000 	movne	r9, #0
8f62f774:	e3500000 	cmp	r0, #0
8f62f778:	03899001 	orreq	r9, r9, #1
8f62f77c:	e3590000 	cmp	r9, #0
8f62f780:	1a000068 	bne	8f62f928 <write_misc+0x1ec>
		return -1;

	if (target_is_emmc_boot())
8f62f784:	e1a06000 	mov	r6, r0
8f62f788:	ebffc8bc 	bl	8f621a80 <target_is_emmc_boot>
8f62f78c:	e250a000 	subs	r10, r0, #0
8f62f790:	1a00002c 	bne	8f62f848 <write_misc+0x10c>
	}
	else
	{
		struct ptentry *ptn;
		struct ptable *ptable;
		unsigned pagesize = flash_page_size();
8f62f794:	ebff8dd2 	bl	8f612ee4 <flash_page_size>
8f62f798:	e1a09000 	mov	r9, r0

		ptable = flash_get_ptable();
8f62f79c:	ebff8e09 	bl	8f612fc8 <flash_get_ptable>
		if (ptable == NULL)
8f62f7a0:	e3500000 	cmp	r0, #0
8f62f7a4:	0a000074 	beq	8f62f97c <write_misc+0x240>
		{
			dprintf(CRITICAL, "Partition table not found\n");
			return -1;
		}

		ptn = ptable_find(ptable, ptn_name);
8f62f7a8:	e3001d40 	movw	r1, #3392	; 0xd40
8f62f7ac:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f7b0:	eb001c62 	bl	8f636940 <ptable_find>
		if (ptn == NULL)
8f62f7b4:	e250b000 	subs	r11, r0, #0
8f62f7b8:	0a000063 	beq	8f62f94c <write_misc+0x210>
			dprintf(CRITICAL, "No '%s' partition found\n", ptn_name);
			return -1;
		}

		offset = page_offset * pagesize;
		aligned_size = ROUND_TO_PAGE(size, pagesize - 1);
8f62f7bc:	e2457001 	sub	r7, r5, #1
		if (ptn->length < offset + aligned_size)
8f62f7c0:	e59b2014 	ldr	r2, [r11, #20]
		offset = page_offset * pagesize;
8f62f7c4:	e0040994 	mul	r4, r4, r9
		aligned_size = ROUND_TO_PAGE(size, pagesize - 1);
8f62f7c8:	e0877009 	add	r7, r7, r9
8f62f7cc:	e2699000 	rsb	r9, r9, #0
8f62f7d0:	e0077009 	and	r7, r7, r9
8f62f7d4:	e1570005 	cmp	r7, r5
8f62f7d8:	33e07000 	mvncc	r7, #0
		if (ptn->length < offset + aligned_size)
8f62f7dc:	e0873004 	add	r3, r7, r4
8f62f7e0:	e1520003 	cmp	r2, r3
8f62f7e4:	3a000051 	bcc	8f62f930 <write_misc+0x1f4>
			return -1;
		}

		/* This will ensure, we zeored out any extra bytes
		   we will push, to prevent information leak */
		if (aligned_size > size)
8f62f7e8:	e1570005 	cmp	r7, r5
8f62f7ec:	8a000048 	bhi	8f62f914 <write_misc+0x1d8>
			memset((scratch_addr + size), 0, (aligned_size-size));

		if (scratch_addr != buf)
8f62f7f0:	e1560008 	cmp	r6, r8
8f62f7f4:	0a000003 	beq	8f62f808 <write_misc+0xcc>
			memcpy(scratch_addr, buf, size);
8f62f7f8:	e1a02005 	mov	r2, r5
8f62f7fc:	e1a01008 	mov	r1, r8
8f62f800:	e1a00006 	mov	r0, r6
8f62f804:	eb00126b 	bl	8f6341b8 <memcpy>

		if (flash_write(ptn, offset, scratch_addr, aligned_size)) {
8f62f808:	e1a03007 	mov	r3, r7
8f62f80c:	e1a02006 	mov	r2, r6
8f62f810:	e1a01004 	mov	r1, r4
8f62f814:	e1a0000b 	mov	r0, r11
8f62f818:	ebff8ece 	bl	8f613358 <flash_write>
8f62f81c:	e3500000 	cmp	r0, #0
8f62f820:	1a000050 	bne	8f62f968 <write_misc+0x22c>
			dprintf(CRITICAL, "Writing flash failed\n");
			return -1;
		}
	}

	return 0;
8f62f824:	e3a00000 	mov	r0, #0
}
8f62f828:	e59f3164 	ldr	r3, [pc, #356]	; 8f62f994 <write_misc+0x258>
8f62f82c:	e5932000 	ldr	r2, [r3]
8f62f830:	e59d300c 	ldr	r3, [r13, #12]
8f62f834:	e0332002 	eors	r2, r3, r2
8f62f838:	e3a03000 	mov	r3, #0
8f62f83c:	1a000053 	bne	8f62f990 <write_misc+0x254>
8f62f840:	e28dd014 	add	r13, r13, #20
8f62f844:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		index = partition_get_index(ptn_name);
8f62f848:	e3000d40 	movw	r0, #3392	; 0xd40
8f62f84c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f850:	ebff510d 	bl	8f603c8c <partition_get_index>
		if (index == INVALID_PTN)
8f62f854:	e3700001 	cmn	r0, #1
		index = partition_get_index(ptn_name);
8f62f858:	e1a0a000 	mov	r10, r0
		if (index == INVALID_PTN)
8f62f85c:	0a00003a 	beq	8f62f94c <write_misc+0x210>
		ptn = partition_get_offset(index);
8f62f860:	ebff5415 	bl	8f6048bc <partition_get_offset>
		aligned_size = ROUND_TO_PAGE(size, (unsigned)BLOCK_SIZE - 1);
8f62f864:	e2857f7f 	add	r7, r5, #508	; 0x1fc
8f62f868:	e2877003 	add	r7, r7, #3
		offset = page_offset * BLOCK_SIZE;
8f62f86c:	e1a04484 	lsl	r4, r4, #9
		aligned_size = ROUND_TO_PAGE(size, (unsigned)BLOCK_SIZE - 1);
8f62f870:	e3c77f7f 	bic	r7, r7, #508	; 0x1fc
8f62f874:	e3c77003 	bic	r7, r7, #3
		ptn = partition_get_offset(index);
8f62f878:	e58d0004 	str	r0, [r13, #4]
		ptn_size = partition_get_size(index);
8f62f87c:	e1a0000a 	mov	r0, r10
		ptn = partition_get_offset(index);
8f62f880:	e1a0b001 	mov	r11, r1
		ptn_size = partition_get_size(index);
8f62f884:	ebff53eb 	bl	8f604838 <partition_get_size>
		aligned_size = ROUND_TO_PAGE(size, (unsigned)BLOCK_SIZE - 1);
8f62f888:	e1570005 	cmp	r7, r5
8f62f88c:	33e07000 	mvncc	r7, #0
		if (ptn_size < offset + aligned_size)
8f62f890:	e0873004 	add	r3, r7, r4
8f62f894:	e1500003 	cmp	r0, r3
8f62f898:	e2d13000 	sbcs	r3, r1, #0
8f62f89c:	3a000023 	bcc	8f62f930 <write_misc+0x1f4>
		if (aligned_size > size)
8f62f8a0:	e1570005 	cmp	r7, r5
8f62f8a4:	8a000015 	bhi	8f62f900 <write_misc+0x1c4>
		if (scratch_addr != buf)
8f62f8a8:	e1560008 	cmp	r6, r8
8f62f8ac:	0a000003 	beq	8f62f8c0 <write_misc+0x184>
			memcpy(scratch_addr, buf, size);
8f62f8b0:	e1a02005 	mov	r2, r5
8f62f8b4:	e1a01008 	mov	r1, r8
8f62f8b8:	e1a00006 	mov	r0, r6
8f62f8bc:	eb00123d 	bl	8f6341b8 <memcpy>
		mmc_set_lun(partition_get_lun(index));
8f62f8c0:	e1a0000a 	mov	r0, r10
8f62f8c4:	ebff541d 	bl	8f604940 <partition_get_lun>
8f62f8c8:	ebff76d9 	bl	8f60d434 <mmc_set_lun>
		if (mmc_write(ptn + offset, aligned_size, (unsigned int *)scratch_addr))
8f62f8cc:	e59d3004 	ldr	r3, [r13, #4]
8f62f8d0:	e1a02007 	mov	r2, r7
8f62f8d4:	e0940003 	adds	r0, r4, r3
8f62f8d8:	e1a03006 	mov	r3, r6
8f62f8dc:	e2ab1000 	adc	r1, r11, #0
8f62f8e0:	ebff744e 	bl	8f60ca20 <mmc_write>
8f62f8e4:	e3500000 	cmp	r0, #0
8f62f8e8:	0affffcd 	beq	8f62f824 <write_misc+0xe8>
			dprintf(CRITICAL, "Writing MMC failed\n");
8f62f8ec:	e30a0e7c 	movw	r0, #44668	; 0xae7c
8f62f8f0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f8f4:	eb000c1e 	bl	8f632974 <_dprintf>
			return -1;
8f62f8f8:	e3e00000 	mvn	r0, #0
8f62f8fc:	eaffffc9 	b	8f62f828 <write_misc+0xec>
			memset((scratch_addr + size), 0, (aligned_size-size));
8f62f900:	e0472005 	sub	r2, r7, r5
8f62f904:	e0860005 	add	r0, r6, r5
8f62f908:	e1a01009 	mov	r1, r9
8f62f90c:	eb00126c 	bl	8f6342c4 <memset>
8f62f910:	eaffffe4 	b	8f62f8a8 <write_misc+0x16c>
			memset((scratch_addr + size), 0, (aligned_size-size));
8f62f914:	e0472005 	sub	r2, r7, r5
8f62f918:	e0860005 	add	r0, r6, r5
8f62f91c:	e1a0100a 	mov	r1, r10
8f62f920:	eb001267 	bl	8f6342c4 <memset>
8f62f924:	eaffffb1 	b	8f62f7f0 <write_misc+0xb4>
		return -1;
8f62f928:	e3e00000 	mvn	r0, #0
8f62f92c:	eaffffbd 	b	8f62f828 <write_misc+0xec>
			dprintf(CRITICAL, "Write request out of '%s' boundaries\n",
8f62f930:	e3001d40 	movw	r1, #3392	; 0xd40
8f62f934:	e30a0e54 	movw	r0, #44628	; 0xae54
8f62f938:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f93c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f940:	eb000c0b 	bl	8f632974 <_dprintf>
			return -1;
8f62f944:	e3e00000 	mvn	r0, #0
8f62f948:	eaffffb6 	b	8f62f828 <write_misc+0xec>
			dprintf(CRITICAL, "No '%s' partition found\n", ptn_name);
8f62f94c:	e3001d40 	movw	r1, #3392	; 0xd40
8f62f950:	e30a0e38 	movw	r0, #44600	; 0xae38
8f62f954:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62f958:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f95c:	eb000c04 	bl	8f632974 <_dprintf>
			return -1;
8f62f960:	e3e00000 	mvn	r0, #0
8f62f964:	eaffffaf 	b	8f62f828 <write_misc+0xec>
			dprintf(CRITICAL, "Writing flash failed\n");
8f62f968:	e30a0eac 	movw	r0, #44716	; 0xaeac
8f62f96c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f970:	eb000bff 	bl	8f632974 <_dprintf>
			return -1;
8f62f974:	e3e00000 	mvn	r0, #0
8f62f978:	eaffffaa 	b	8f62f828 <write_misc+0xec>
			dprintf(CRITICAL, "Partition table not found\n");
8f62f97c:	e30a0e90 	movw	r0, #44688	; 0xae90
8f62f980:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62f984:	eb000bfa 	bl	8f632974 <_dprintf>
			return -1;
8f62f988:	e3e00000 	mvn	r0, #0
8f62f98c:	eaffffa5 	b	8f62f828 <write_misc+0xec>
}
8f62f990:	eb000c8a 	bl	8f632bc0 <__stack_chk_fail>
8f62f994:	8f74221c 	.word	0x8f74221c

8f62f998 <get_ffbm>:

int get_ffbm(char *ffbm, unsigned size)
{
8f62f998:	e59f31d4 	ldr	r3, [pc, #468]	; 8f62fb74 <get_ffbm+0x1dc>
8f62f99c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f62f9a0:	e24dd00c 	sub	r13, r13, #12
8f62f9a4:	e1a05001 	mov	r5, r1
8f62f9a8:	e5933000 	ldr	r3, [r3]
8f62f9ac:	e58d3004 	str	r3, [r13, #4]
8f62f9b0:	e3a03000 	mov	r3, #0
8f62f9b4:	e1a08000 	mov	r8, r0
	const char *ffbm_cmd = "ffbm-";
	uint32_t page_size = get_page_size();
8f62f9b8:	ebfff0af 	bl	8f62bc7c <get_page_size>
	char *ffbm_page_buffer = NULL;
	int retval = 0;
	if (size < FFBM_MODE_BUF_SIZE || size >= page_size)
8f62f9bc:	e1500005 	cmp	r0, r5
8f62f9c0:	83550007 	cmphi	r5, #7
8f62f9c4:	9a000047 	bls	8f62fae8 <get_ffbm+0x150>
	{
		dprintf(CRITICAL, "Invalid size argument passed to get_ffbm\n");
		retval = -1;
		goto cleanup;
	}
	ffbm_page_buffer = (char*)memalign(CACHE_LINE, page_size);
8f62f9c8:	e1a01000 	mov	r1, r0
8f62f9cc:	e1a04000 	mov	r4, r0
8f62f9d0:	e3a00040 	mov	r0, #64	; 0x40
8f62f9d4:	eb00119a 	bl	8f634044 <memalign>
	if (!ffbm_page_buffer)
8f62f9d8:	e2506000 	subs	r6, r0, #0
8f62f9dc:	0a00005f 	beq	8f62fb60 <get_ffbm+0x1c8>
	uint32_t pagesize = get_page_size();
8f62f9e0:	ebfff0a5 	bl	8f62bc7c <get_page_size>
	if (size == 0 || buf == NULL)
8f62f9e4:	e3540000 	cmp	r4, #0
8f62f9e8:	0a000046 	beq	8f62fb08 <get_ffbm+0x170>
	if (target_is_emmc_boot())
8f62f9ec:	ebffc823 	bl	8f621a80 <target_is_emmc_boot>
8f62f9f0:	e3500000 	cmp	r0, #0
8f62f9f4:	0a000040 	beq	8f62fafc <get_ffbm+0x164>
		index = partition_get_index(ptn_name);
8f62f9f8:	e3000d40 	movw	r0, #3392	; 0xd40
8f62f9fc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62fa00:	ebff50a1 	bl	8f603c8c <partition_get_index>
		if (index == INVALID_PTN)
8f62fa04:	e3700001 	cmn	r0, #1
		index = partition_get_index(ptn_name);
8f62fa08:	e1a07000 	mov	r7, r0
		if (index == INVALID_PTN)
8f62fa0c:	0a000048 	beq	8f62fb34 <get_ffbm+0x19c>
		ptn = partition_get_offset(index);
8f62fa10:	ebff53a9 	bl	8f6048bc <partition_get_offset>
8f62fa14:	e1a0a000 	mov	r10, r0
		ptn_size = partition_get_size(index);
8f62fa18:	e1a00007 	mov	r0, r7
		ptn = partition_get_offset(index);
8f62fa1c:	e1a09001 	mov	r9, r1
		ptn_size = partition_get_size(index);
8f62fa20:	ebff5384 	bl	8f604838 <partition_get_size>
8f62fa24:	e1a0b000 	mov	r11, r0
		mmc_set_lun(partition_get_lun(index));
8f62fa28:	e1a00007 	mov	r0, r7
		ptn_size = partition_get_size(index);
8f62fa2c:	e1a07001 	mov	r7, r1
		mmc_set_lun(partition_get_lun(index));
8f62fa30:	ebff53c2 	bl	8f604940 <partition_get_lun>
8f62fa34:	ebff767e 	bl	8f60d434 <mmc_set_lun>
		if (ptn_size < offset + size)
8f62fa38:	e15b0004 	cmp	r11, r4
8f62fa3c:	e2d73000 	sbcs	r3, r7, #0
8f62fa40:	3a000035 	bcc	8f62fb1c <get_ffbm+0x184>
		if (mmc_read(ptn + offset, (unsigned int *)buf, size))
8f62fa44:	e1a03004 	mov	r3, r4
8f62fa48:	e1a0000a 	mov	r0, r10
8f62fa4c:	e1a01009 	mov	r1, r9
8f62fa50:	e1a02006 	mov	r2, r6
8f62fa54:	ebff748b 	bl	8f60cc88 <mmc_read>
8f62fa58:	e2504000 	subs	r4, r0, #0
8f62fa5c:	1a00003a 	bne	8f62fb4c <get_ffbm+0x1b4>
		dprintf(CRITICAL, "Error reading MISC partition\n");
		retval = -1;
		goto cleanup;
	}
	ffbm_page_buffer[size] = '\0';
	if (strncmp(ffbm_cmd, ffbm_page_buffer, strlen(ffbm_cmd)))
8f62fa60:	e30a0f70 	movw	r0, #44912	; 0xaf70
	ffbm_page_buffer[size] = '\0';
8f62fa64:	e7c64005 	strb	r4, [r6, r5]
	if (strncmp(ffbm_cmd, ffbm_page_buffer, strlen(ffbm_cmd)))
8f62fa68:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62fa6c:	eb001365 	bl	8f634808 <strlen>
8f62fa70:	e1a01006 	mov	r1, r6
8f62fa74:	e1a02000 	mov	r2, r0
8f62fa78:	e30a0f70 	movw	r0, #44912	; 0xaf70
8f62fa7c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62fa80:	eb001379 	bl	8f63486c <strncmp>
8f62fa84:	e3500000 	cmp	r0, #0
8f62fa88:	0a00000a 	beq	8f62fab8 <get_ffbm+0x120>
		else
			retval = 1;
	}
cleanup:
	if(ffbm_page_buffer)
		free(ffbm_page_buffer);
8f62fa8c:	e1a00006 	mov	r0, r6
8f62fa90:	eb00119d 	bl	8f63410c <free>
	return retval;
}
8f62fa94:	e59f30d8 	ldr	r3, [pc, #216]	; 8f62fb74 <get_ffbm+0x1dc>
8f62fa98:	e5932000 	ldr	r2, [r3]
8f62fa9c:	e59d3004 	ldr	r3, [r13, #4]
8f62faa0:	e0332002 	eors	r2, r3, r2
8f62faa4:	e3a03000 	mov	r3, #0
8f62faa8:	1a00002b 	bne	8f62fb5c <get_ffbm+0x1c4>
8f62faac:	e1a00004 	mov	r0, r4
8f62fab0:	e28dd00c 	add	r13, r13, #12
8f62fab4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		if (strlcpy(ffbm, ffbm_page_buffer, size) <
8f62fab8:	e1a02005 	mov	r2, r5
8f62fabc:	e1a01006 	mov	r1, r6
8f62fac0:	e1a00008 	mov	r0, r8
8f62fac4:	eb001319 	bl	8f634730 <strlcpy>
8f62fac8:	e3500006 	cmp	r0, #6
			retval = 1;
8f62facc:	83a04001 	movhi	r4, #1
		if (strlcpy(ffbm, ffbm_page_buffer, size) <
8f62fad0:	8affffed 	bhi	8f62fa8c <get_ffbm+0xf4>
			dprintf(CRITICAL, "Invalid string in misc partition\n");
8f62fad4:	e30a0f98 	movw	r0, #44952	; 0xaf98
8f62fad8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62fadc:	eb000ba4 	bl	8f632974 <_dprintf>
			retval = -1;
8f62fae0:	e3e04000 	mvn	r4, #0
8f62fae4:	eaffffe8 	b	8f62fa8c <get_ffbm+0xf4>
		dprintf(CRITICAL, "Invalid size argument passed to get_ffbm\n");
8f62fae8:	e30a0ec4 	movw	r0, #44740	; 0xaec4
8f62faec:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62faf0:	eb000b9f 	bl	8f632974 <_dprintf>
		retval = -1;
8f62faf4:	e3e04000 	mvn	r4, #0
8f62faf8:	eaffffe5 	b	8f62fa94 <get_ffbm+0xfc>
		dprintf(CRITICAL, "Misc partition not supported for NAND targets.\n");
8f62fafc:	e30a0f40 	movw	r0, #44864	; 0xaf40
8f62fb00:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62fb04:	eb000b9a 	bl	8f632974 <_dprintf>
		dprintf(CRITICAL, "Error reading MISC partition\n");
8f62fb08:	e30a0f78 	movw	r0, #44920	; 0xaf78
8f62fb0c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62fb10:	eb000b97 	bl	8f632974 <_dprintf>
		retval = -1;
8f62fb14:	e3e04000 	mvn	r4, #0
		goto cleanup;
8f62fb18:	eaffffdb 	b	8f62fa8c <get_ffbm+0xf4>
			dprintf(CRITICAL, "Read request out of '%s' boundaries\n",
8f62fb1c:	e3001d40 	movw	r1, #3392	; 0xd40
8f62fb20:	e30a0f18 	movw	r0, #44824	; 0xaf18
8f62fb24:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62fb28:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62fb2c:	eb000b90 	bl	8f632974 <_dprintf>
			return -1;
8f62fb30:	eafffff4 	b	8f62fb08 <get_ffbm+0x170>
			dprintf(CRITICAL, "No '%s' partition found\n", ptn_name);
8f62fb34:	e3001d40 	movw	r1, #3392	; 0xd40
8f62fb38:	e30a0e38 	movw	r0, #44600	; 0xae38
8f62fb3c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f62fb40:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62fb44:	eb000b8a 	bl	8f632974 <_dprintf>
			return -1;
8f62fb48:	eaffffee 	b	8f62fb08 <get_ffbm+0x170>
			dprintf(CRITICAL, "Reading MMC failed\n");
8f62fb4c:	e3090d5c 	movw	r0, #40284	; 0x9d5c
8f62fb50:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62fb54:	eb000b86 	bl	8f632974 <_dprintf>
			return -1;
8f62fb58:	eaffffea 	b	8f62fb08 <get_ffbm+0x170>
}
8f62fb5c:	eb000c17 	bl	8f632bc0 <__stack_chk_fail>
		dprintf(CRITICAL, "Failed to alloc buffer for ffbm cookie\n");
8f62fb60:	e30a0ef0 	movw	r0, #44784	; 0xaef0
8f62fb64:	e3480f70 	movt	r0, #36720	; 0x8f70
8f62fb68:	eb000b81 	bl	8f632974 <_dprintf>
		retval = -1;
8f62fb6c:	e3e04000 	mvn	r4, #0
8f62fb70:	eaffffc7 	b	8f62fa94 <get_ffbm+0xfc>
8f62fb74:	8f74221c 	.word	0x8f74221c

8f62fb78 <fbcon_flush>:
	}
	fbcon_flush();
}

void fbcon_flush(void)
{
8f62fb78:	e92d4010 	push	{r4, r14}
	unsigned total_x, total_y;
	unsigned bytes_per_bpp;

	/* ignore anything that happens before fbcon is initialized */
	if (!config)
8f62fb7c:	e3024188 	movw	r4, #8584	; 0x2188
8f62fb80:	e3484f74 	movt	r4, #36724	; 0x8f74
{
8f62fb84:	e59f30b4 	ldr	r3, [pc, #180]	; 8f62fc40 <fbcon_flush+0xc8>
8f62fb88:	e24dd008 	sub	r13, r13, #8
	if (!config)
8f62fb8c:	e5942000 	ldr	r2, [r4]
{
8f62fb90:	e5933000 	ldr	r3, [r3]
8f62fb94:	e58d3004 	str	r3, [r13, #4]
8f62fb98:	e3a03000 	mov	r3, #0
	if (!config)
8f62fb9c:	e3520000 	cmp	r2, #0
8f62fba0:	0a00001d 	beq	8f62fc1c <fbcon_flush+0xa4>
		return;

	if (config->update_start)
8f62fba4:	e5923018 	ldr	r3, [r2, #24]
8f62fba8:	e3530000 	cmp	r3, #0
8f62fbac:	0a000001 	beq	8f62fbb8 <fbcon_flush+0x40>
		config->update_start();
8f62fbb0:	e12fff33 	blx	r3
	if (config->update_done)
8f62fbb4:	e5942000 	ldr	r2, [r4]
8f62fbb8:	e592301c 	ldr	r3, [r2, #28]
8f62fbbc:	e3530000 	cmp	r3, #0
8f62fbc0:	1a000002 	bne	8f62fbd0 <fbcon_flush+0x58>
8f62fbc4:	ea000005 	b	8f62fbe0 <fbcon_flush+0x68>
		while (!config->update_done());
8f62fbc8:	e5943000 	ldr	r3, [r4]
8f62fbcc:	e593301c 	ldr	r3, [r3, #28]
8f62fbd0:	e12fff33 	blx	r3
8f62fbd4:	e3500000 	cmp	r0, #0
8f62fbd8:	0afffffa 	beq	8f62fbc8 <fbcon_flush+0x50>

	total_x = config->width;
8f62fbdc:	e5942000 	ldr	r2, [r4]
	total_y = config->height;
	bytes_per_bpp = ((config->bpp) / 8);
	arch_clean_invalidate_cache_range((addr_t) config->base, (total_x * total_y * bytes_per_bpp));
8f62fbe0:	e59f3058 	ldr	r3, [pc, #88]	; 8f62fc40 <fbcon_flush+0xc8>
8f62fbe4:	e5931000 	ldr	r1, [r3]
8f62fbe8:	e59d3004 	ldr	r3, [r13, #4]
8f62fbec:	e0331001 	eors	r1, r3, r1
8f62fbf0:	e3a03000 	mov	r3, #0
8f62fbf4:	1a000010 	bne	8f62fc3c <fbcon_flush+0xc4>
8f62fbf8:	e9921008 	ldmib	r2, {r3, r12}
	bytes_per_bpp = ((config->bpp) / 8);
8f62fbfc:	e5921010 	ldr	r1, [r2, #16]
	arch_clean_invalidate_cache_range((addr_t) config->base, (total_x * total_y * bytes_per_bpp));
8f62fc00:	e5920000 	ldr	r0, [r2]
8f62fc04:	e003039c 	mul	r3, r12, r3
	bytes_per_bpp = ((config->bpp) / 8);
8f62fc08:	e1a011a1 	lsr	r1, r1, #3
	arch_clean_invalidate_cache_range((addr_t) config->base, (total_x * total_y * bytes_per_bpp));
8f62fc0c:	e0010391 	mul	r1, r1, r3
}
8f62fc10:	e28dd008 	add	r13, r13, #8
8f62fc14:	e8bd4010 	pop	{r4, r14}
	arch_clean_invalidate_cache_range((addr_t) config->base, (total_x * total_y * bytes_per_bpp));
8f62fc18:	eaffc4e0 	b	8f620fa0 <arch_clean_invalidate_cache_range>
}
8f62fc1c:	e59f301c 	ldr	r3, [pc, #28]	; 8f62fc40 <fbcon_flush+0xc8>
8f62fc20:	e5932000 	ldr	r2, [r3]
8f62fc24:	e59d3004 	ldr	r3, [r13, #4]
8f62fc28:	e0332002 	eors	r2, r3, r2
8f62fc2c:	e3a03000 	mov	r3, #0
8f62fc30:	1a000001 	bne	8f62fc3c <fbcon_flush+0xc4>
8f62fc34:	e28dd008 	add	r13, r13, #8
8f62fc38:	e8bd8010 	pop	{r4, r15}
8f62fc3c:	eb000bdf 	bl	8f632bc0 <__stack_chk_fail>
8f62fc40:	8f74221c 	.word	0x8f74221c

8f62fc44 <fbcon_draw_msg_background>:
	if (!config)
8f62fc44:	e302c188 	movw	r12, #8584	; 0x2188
8f62fc48:	e348cf74 	movt	r12, #36724	; 0x8f74
{
8f62fc4c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
8f62fc50:	e24dd008 	sub	r13, r13, #8
	if (!config)
8f62fc54:	e59c7000 	ldr	r7, [r12]
{
8f62fc58:	e59fc134 	ldr	r12, [pc, #308]	; 8f62fd94 <fbcon_draw_msg_background+0x150>
	if (!config)
8f62fc5c:	e3570000 	cmp	r7, #0
{
8f62fc60:	e59cc000 	ldr	r12, [r12]
8f62fc64:	e58dc004 	str	r12, [r13, #4]
8f62fc68:	e3a0c000 	mov	r12, #0
	if (!config)
8f62fc6c:	0a00003f 	beq	8f62fd70 <fbcon_draw_msg_background+0x12c>
	count = config->width * (FONT_HEIGHT * (y_end - y_start) - 1);
8f62fc70:	e0411000 	sub	r1, r1, r0
8f62fc74:	e3a0e00c 	mov	r14, #12
	pixels += y_start * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f62fc78:	e5974010 	ldr	r4, [r7, #16]
	if (update) {
8f62fc7c:	e3530000 	cmp	r3, #0
	count = config->width * (FONT_HEIGHT * (y_end - y_start) - 1);
8f62fc80:	e006019e 	mul	r6, r14, r1
8f62fc84:	e597c004 	ldr	r12, [r7, #4]
	pixels += y_start * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f62fc88:	e1a031a4 	lsr	r3, r4, #3
		check_color = old_paint;
8f62fc8c:	11a08002 	movne	r8, r2
		bg_color = old_paint;
8f62fc90:	01a09002 	moveq	r9, r2
		bg_color = SELECT_BGCOLOR;
8f62fc94:	13022184 	movwne	r2, #8580	; 0x2184
	count = config->width * (FONT_HEIGHT * (y_end - y_start) - 1);
8f62fc98:	e2466001 	sub	r6, r6, #1
		check_color = SELECT_BGCOLOR;
8f62fc9c:	03022184 	movweq	r2, #8580	; 0x2184
		bg_color = SELECT_BGCOLOR;
8f62fca0:	13482f74 	movtne	r2, #36724	; 0x8f74
		check_color = SELECT_BGCOLOR;
8f62fca4:	03482f74 	movteq	r2, #36724	; 0x8f74
	count = config->width * (FONT_HEIGHT * (y_end - y_start) - 1);
8f62fca8:	e006069c 	mul	r6, r12, r6
		bg_color = SELECT_BGCOLOR;
8f62fcac:	15929000 	ldrne	r9, [r2]
	pixels += y_start * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f62fcb0:	e00c039c 	mul	r12, r12, r3
		check_color = SELECT_BGCOLOR;
8f62fcb4:	05928000 	ldreq	r8, [r2]
	for (i = 0; i < count; i++) {
8f62fcb8:	e3560000 	cmp	r6, #0
8f62fcbc:	13a05000 	movne	r5, #0
	pixels += y_start * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f62fcc0:	e0010c90 	mul	r1, r0, r12
	pixels = config->base;
8f62fcc4:	e5970000 	ldr	r0, [r7]
	pixels += y_start * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f62fcc8:	e02e019e 	mla	r14, r14, r1, r0
	for (i = 0; i < count; i++) {
8f62fccc:	0a00001e 	beq	8f62fd4c <fbcon_draw_msg_background+0x108>
		for (j = 0; j < (config->bpp / 8); j++) {
8f62fcd0:	e3530000 	cmp	r3, #0
8f62fcd4:	0a00000c 	beq	8f62fd0c <fbcon_draw_msg_background+0xc8>
8f62fcd8:	e08ea003 	add	r10, r14, r3
8f62fcdc:	e24e2001 	sub	r2, r14, #1
8f62fce0:	e3a03000 	mov	r3, #0
8f62fce4:	e24ac001 	sub	r12, r10, #1
		tmp_color = 0;
8f62fce8:	e1a01003 	mov	r1, r3
			tmp_color |= *(pixels+j) << j*8;
8f62fcec:	e5f20001 	ldrb	r0, [r2, #1]!
		for (j = 0; j < (config->bpp / 8); j++) {
8f62fcf0:	e15c0002 	cmp	r12, r2
			tmp_color |= *(pixels+j) << j*8;
8f62fcf4:	e1811310 	orr	r1, r1, r0, lsl r3
		for (j = 0; j < (config->bpp / 8); j++) {
8f62fcf8:	e2833008 	add	r3, r3, #8
8f62fcfc:	1afffffa 	bne	8f62fcec <fbcon_draw_msg_background+0xa8>
		if (tmp_color == check_color) {
8f62fd00:	e1580001 	cmp	r8, r1
			pixels += config->bpp / 8;
8f62fd04:	11a0e00a 	movne	r14, r10
		if (tmp_color == check_color) {
8f62fd08:	0a000004 	beq	8f62fd20 <fbcon_draw_msg_background+0xdc>
	for (i = 0; i < count; i++) {
8f62fd0c:	e2855001 	add	r5, r5, #1
8f62fd10:	e1560005 	cmp	r6, r5
8f62fd14:	0a00000c 	beq	8f62fd4c <fbcon_draw_msg_background+0x108>
8f62fd18:	e1a031a4 	lsr	r3, r4, #3
8f62fd1c:	eaffffeb 	b	8f62fcd0 <fbcon_draw_msg_background+0x8c>
		if (tmp_color == check_color) {
8f62fd20:	e1a02009 	mov	r2, r9
8f62fd24:	e3a03000 	mov	r3, #0
				*pixels = (unsigned char) tmp1_color;
8f62fd28:	e4ce2001 	strb	r2, [r14], #1
			for (j = 0; j < (config->bpp / 8); j++) {
8f62fd2c:	e2833001 	add	r3, r3, #1
8f62fd30:	e5974010 	ldr	r4, [r7, #16]
				tmp1_color = tmp1_color >> 8;
8f62fd34:	e1a02422 	lsr	r2, r2, #8
			for (j = 0; j < (config->bpp / 8); j++) {
8f62fd38:	e15301a4 	cmp	r3, r4, lsr #3
8f62fd3c:	3afffff9 	bcc	8f62fd28 <fbcon_draw_msg_background+0xe4>
	for (i = 0; i < count; i++) {
8f62fd40:	e2855001 	add	r5, r5, #1
8f62fd44:	e1560005 	cmp	r6, r5
8f62fd48:	1afffff2 	bne	8f62fd18 <fbcon_draw_msg_background+0xd4>
	fbcon_flush();
8f62fd4c:	e59f3040 	ldr	r3, [pc, #64]	; 8f62fd94 <fbcon_draw_msg_background+0x150>
8f62fd50:	e5932000 	ldr	r2, [r3]
8f62fd54:	e59d3004 	ldr	r3, [r13, #4]
8f62fd58:	e0332002 	eors	r2, r3, r2
8f62fd5c:	e3a03000 	mov	r3, #0
8f62fd60:	1a00000a 	bne	8f62fd90 <fbcon_draw_msg_background+0x14c>
}
8f62fd64:	e28dd008 	add	r13, r13, #8
8f62fd68:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r14}
	fbcon_flush();
8f62fd6c:	eaffff81 	b	8f62fb78 <fbcon_flush>
}
8f62fd70:	e59f301c 	ldr	r3, [pc, #28]	; 8f62fd94 <fbcon_draw_msg_background+0x150>
8f62fd74:	e5932000 	ldr	r2, [r3]
8f62fd78:	e59d3004 	ldr	r3, [r13, #4]
8f62fd7c:	e0332002 	eors	r2, r3, r2
8f62fd80:	e3a03000 	mov	r3, #0
8f62fd84:	1a000001 	bne	8f62fd90 <fbcon_draw_msg_background+0x14c>
8f62fd88:	e28dd008 	add	r13, r13, #8
8f62fd8c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
8f62fd90:	eb000b8a 	bl	8f632bc0 <__stack_chk_fail>
8f62fd94:	8f74221c 	.word	0x8f74221c

8f62fd98 <fbcon_scroll_up>:

/* TODO: Take stride into account */
static void fbcon_scroll_up(void)
{
8f62fd98:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
	uint8_t *dst = NULL;
	uint8_t *src = NULL;
	unsigned count = 0;

	/* ignore anything that happens before fbcon is initialized */
	if (!config)
8f62fd9c:	e3027188 	movw	r7, #8584	; 0x2188
{
8f62fda0:	e59f30ec 	ldr	r3, [pc, #236]	; 8f62fe94 <fbcon_scroll_up+0xfc>
	if (!config)
8f62fda4:	e3487f74 	movt	r7, #36724	; 0x8f74
{
8f62fda8:	e24dd00c 	sub	r13, r13, #12
8f62fdac:	e5933000 	ldr	r3, [r3]
8f62fdb0:	e58d3004 	str	r3, [r13, #4]
8f62fdb4:	e3a03000 	mov	r3, #0
	if (!config)
8f62fdb8:	e5973000 	ldr	r3, [r7]
8f62fdbc:	e3530000 	cmp	r3, #0
8f62fdc0:	0a00002a 	beq	8f62fe70 <fbcon_scroll_up+0xd8>
		return;

	num_lines = max_pos.y-cur_pos.y;
8f62fdc4:	e3020198 	movw	r0, #8600	; 0x2198
8f62fdc8:	e302118c 	movw	r1, #8588	; 0x218c
8f62fdcc:	e3480f74 	movt	r0, #36724	; 0x8f74
8f62fdd0:	e3481f74 	movt	r1, #36724	; 0x8f74
	bpp = (config->bpp / 8);
	off_bytes = config->width * bpp * num_lines * FONT_HEIGHT;
8f62fdd4:	e5935004 	ldr	r5, [r3, #4]
	num_lines = max_pos.y-cur_pos.y;
8f62fdd8:	e5904004 	ldr	r4, [r0, #4]
8f62fddc:	e5911004 	ldr	r1, [r1, #4]
	bpp = (config->bpp / 8);
8f62fde0:	e5932010 	ldr	r2, [r3, #16]
	num_lines = max_pos.y-cur_pos.y;
8f62fde4:	e0444001 	sub	r4, r4, r1

	dst = config->base;
8f62fde8:	e5938000 	ldr	r8, [r3]
	off_bytes = config->width * bpp * num_lines * FONT_HEIGHT;
8f62fdec:	e0040495 	mul	r4, r5, r4
	bpp = (config->bpp / 8);
8f62fdf0:	e1a061a2 	lsr	r6, r2, #3
	src = dst + off_bytes;
	count = config->width*config->height*bpp - off_bytes;
8f62fdf4:	e5932008 	ldr	r2, [r3, #8]
	off_bytes = config->width * bpp * num_lines * FONT_HEIGHT;
8f62fdf8:	e3a0300c 	mov	r3, #12

	memmove(dst, src, count);
8f62fdfc:	e1a00008 	mov	r0, r8
	count = config->width*config->height*bpp - off_bytes;
8f62fe00:	e0050592 	mul	r5, r2, r5
	off_bytes = config->width * bpp * num_lines * FONT_HEIGHT;
8f62fe04:	e0040496 	mul	r4, r6, r4
	count = config->width*config->height*bpp - off_bytes;
8f62fe08:	e0050596 	mul	r5, r6, r5
	off_bytes = config->width * bpp * num_lines * FONT_HEIGHT;
8f62fe0c:	e0040493 	mul	r4, r3, r4
	count = config->width*config->height*bpp - off_bytes;
8f62fe10:	e0459004 	sub	r9, r5, r4
	memmove(dst, src, count);
8f62fe14:	e0881004 	add	r1, r8, r4
8f62fe18:	e1a02009 	mov	r2, r9
8f62fe1c:	eb0010e5 	bl	8f6341b8 <memcpy>
	memset(dst+count, BGCOLOR, config->width*config->height*bpp - count);
8f62fe20:	e597c000 	ldr	r12, [r7]
8f62fe24:	e3023180 	movw	r3, #8576	; 0x2180
8f62fe28:	e3483f74 	movt	r3, #36724	; 0x8f74
8f62fe2c:	e0880009 	add	r0, r8, r9
8f62fe30:	e5931000 	ldr	r1, [r3]
8f62fe34:	e1cc20d4 	ldrd	r2, [r12, #4]
8f62fe38:	e0020293 	mul	r2, r3, r2
8f62fe3c:	e0020296 	mul	r2, r6, r2
8f62fe40:	e0422005 	sub	r2, r2, r5
8f62fe44:	e0822004 	add	r2, r2, r4
8f62fe48:	eb00111d 	bl	8f6342c4 <memset>

	fbcon_flush();
8f62fe4c:	e59f3040 	ldr	r3, [pc, #64]	; 8f62fe94 <fbcon_scroll_up+0xfc>
8f62fe50:	e5932000 	ldr	r2, [r3]
8f62fe54:	e59d3004 	ldr	r3, [r13, #4]
8f62fe58:	e0332002 	eors	r2, r3, r2
8f62fe5c:	e3a03000 	mov	r3, #0
8f62fe60:	1a00000a 	bne	8f62fe90 <fbcon_scroll_up+0xf8>
}
8f62fe64:	e28dd00c 	add	r13, r13, #12
8f62fe68:	e8bd43f0 	pop	{r4, r5, r6, r7, r8, r9, r14}
	fbcon_flush();
8f62fe6c:	eaffff41 	b	8f62fb78 <fbcon_flush>
}
8f62fe70:	e59f301c 	ldr	r3, [pc, #28]	; 8f62fe94 <fbcon_scroll_up+0xfc>
8f62fe74:	e5932000 	ldr	r2, [r3]
8f62fe78:	e59d3004 	ldr	r3, [r13, #4]
8f62fe7c:	e0332002 	eors	r2, r3, r2
8f62fe80:	e3a03000 	mov	r3, #0
8f62fe84:	1a000001 	bne	8f62fe90 <fbcon_scroll_up+0xf8>
8f62fe88:	e28dd00c 	add	r13, r13, #12
8f62fe8c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
8f62fe90:	eb000b4a 	bl	8f632bc0 <__stack_chk_fail>
8f62fe94:	8f74221c 	.word	0x8f74221c

8f62fe98 <fbcon_draw_line>:
	char *pixels;
	uint32_t line_color, tmp_color;
	int i, j;

	/* ignore anything that happens before fbcon is initialized */
	if (!config)
8f62fe98:	e3023188 	movw	r3, #8584	; 0x2188
8f62fe9c:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f62fea0:	e59f213c 	ldr	r2, [pc, #316]	; 8f62ffe4 <fbcon_draw_line+0x14c>
	if (!config)
8f62fea4:	e593c000 	ldr	r12, [r3]
{
8f62fea8:	e92d4070 	push	{r4, r5, r6, r14}
	if (!config)
8f62feac:	e35c0000 	cmp	r12, #0
{
8f62feb0:	e24dd008 	sub	r13, r13, #8
8f62feb4:	e5922000 	ldr	r2, [r2]
8f62feb8:	e58d2004 	str	r2, [r13, #4]
8f62febc:	e3a02000 	mov	r2, #0
	if (!config)
8f62fec0:	0a00003e 	beq	8f62ffc0 <fbcon_draw_line+0x128>
		return;

	/* set line's color via diffrent type */
	line_color = fb_color_formats[type].fg;
8f62fec4:	e3022194 	movw	r2, #8596	; 0x2194
8f62fec8:	e3482f74 	movt	r2, #36724	; 0x8f74

	pixels = config->base;
	pixels += cur_pos.y * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f62fecc:	e302518c 	movw	r5, #8588	; 0x218c
8f62fed0:	e3485f74 	movt	r5, #36724	; 0x8f74
	line_color = fb_color_formats[type].fg;
8f62fed4:	e5922000 	ldr	r2, [r2]
	pixels += cur_pos.x * ((config->bpp / 8) * (FONT_WIDTH + 1));
8f62fed8:	e3a0e006 	mov	r14, #6
	pixels += cur_pos.y * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f62fedc:	e59c3004 	ldr	r3, [r12, #4]
8f62fee0:	e59c1010 	ldr	r1, [r12, #16]
	line_color = fb_color_formats[type].fg;
8f62fee4:	e7924180 	ldr	r4, [r2, r0, lsl #3]
	pixels += cur_pos.y * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f62fee8:	e3a0200c 	mov	r2, #12
	pixels += cur_pos.x * ((config->bpp / 8) * (FONT_WIDTH + 1));
8f62feec:	e8950041 	ldm	r5, {r0, r6}

	for (i = 0; i < (int)config->width; i++) {
8f62fef0:	e3530000 	cmp	r3, #0
	pixels += cur_pos.x * ((config->bpp / 8) * (FONT_WIDTH + 1));
8f62fef4:	e000009e 	mul	r0, r14, r0
	pixels += cur_pos.y * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f62fef8:	e00e0693 	mul	r14, r3, r6
	pixels += cur_pos.x * ((config->bpp / 8) * (FONT_WIDTH + 1));
8f62fefc:	e02e0e92 	mla	r14, r2, r14, r0
	pixels = config->base;
8f62ff00:	e59c0000 	ldr	r0, [r12]
	pixels += cur_pos.y * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f62ff04:	e1a021a1 	lsr	r2, r1, #3
	pixels += cur_pos.x * ((config->bpp / 8) * (FONT_WIDTH + 1));
8f62ff08:	e0200e92 	mla	r0, r2, r14, r0
	for (i = 0; i < (int)config->width; i++) {
8f62ff0c:	c3a0e000 	movgt	r14, #0
8f62ff10:	da00000e 	ble	8f62ff50 <fbcon_draw_line+0xb8>
		tmp_color = line_color;
		for (j = 0; j < (int)(config->bpp / 8); j++) {
8f62ff14:	e3520000 	cmp	r2, #0
		tmp_color = line_color;
8f62ff18:	11a02004 	movne	r2, r4
		for (j = 0; j < (int)(config->bpp / 8); j++) {
8f62ff1c:	13a03000 	movne	r3, #0
8f62ff20:	0a000006 	beq	8f62ff40 <fbcon_draw_line+0xa8>
			*pixels = (unsigned char) tmp_color;
8f62ff24:	e4c02001 	strb	r2, [r0], #1
		for (j = 0; j < (int)(config->bpp / 8); j++) {
8f62ff28:	e2833001 	add	r3, r3, #1
8f62ff2c:	e59c1010 	ldr	r1, [r12, #16]
			tmp_color = tmp_color >> 8;
8f62ff30:	e1a02422 	lsr	r2, r2, #8
		for (j = 0; j < (int)(config->bpp / 8); j++) {
8f62ff34:	e15301a1 	cmp	r3, r1, lsr #3
8f62ff38:	bafffff9 	blt	8f62ff24 <fbcon_draw_line+0x8c>
8f62ff3c:	e59c3004 	ldr	r3, [r12, #4]
	for (i = 0; i < (int)config->width; i++) {
8f62ff40:	e28ee001 	add	r14, r14, #1
8f62ff44:	e153000e 	cmp	r3, r14
8f62ff48:	c1a021a1 	lsrgt	r2, r1, #3
8f62ff4c:	cafffff0 	bgt	8f62ff14 <fbcon_draw_line+0x7c>
		}
	}

	cur_pos.y += 1;
	cur_pos.x = 0;
	if(cur_pos.y >= max_pos.y) {
8f62ff50:	e3022198 	movw	r2, #8600	; 0x2198
8f62ff54:	e3482f74 	movt	r2, #36724	; 0x8f74
	cur_pos.y += 1;
8f62ff58:	e2863001 	add	r3, r6, #1
	cur_pos.x = 0;
8f62ff5c:	e3a01000 	mov	r1, #0
	if(cur_pos.y >= max_pos.y) {
8f62ff60:	e5922004 	ldr	r2, [r2, #4]
	cur_pos.x = 0;
8f62ff64:	e885000a 	stm	r5, {r1, r3}
	if(cur_pos.y >= max_pos.y) {
8f62ff68:	e1530002 	cmp	r3, r2
8f62ff6c:	ba00000a 	blt	8f62ff9c <fbcon_draw_line+0x104>
		cur_pos.y = max_pos.y - 1;
		fbcon_scroll_up();
8f62ff70:	e59f306c 	ldr	r3, [pc, #108]	; 8f62ffe4 <fbcon_draw_line+0x14c>
		cur_pos.y = max_pos.y - 1;
8f62ff74:	e2422001 	sub	r2, r2, #1
8f62ff78:	e5852004 	str	r2, [r5, #4]
		fbcon_scroll_up();
8f62ff7c:	e5932000 	ldr	r2, [r3]
8f62ff80:	e59d3004 	ldr	r3, [r13, #4]
8f62ff84:	e0332002 	eors	r2, r3, r2
8f62ff88:	e3a03000 	mov	r3, #0
8f62ff8c:	1a000013 	bne	8f62ffe0 <fbcon_draw_line+0x148>
	} else
		fbcon_flush();
}
8f62ff90:	e28dd008 	add	r13, r13, #8
8f62ff94:	e8bd4070 	pop	{r4, r5, r6, r14}
		fbcon_scroll_up();
8f62ff98:	eaffff7e 	b	8f62fd98 <fbcon_scroll_up>
		fbcon_flush();
8f62ff9c:	e59f3040 	ldr	r3, [pc, #64]	; 8f62ffe4 <fbcon_draw_line+0x14c>
8f62ffa0:	e5932000 	ldr	r2, [r3]
8f62ffa4:	e59d3004 	ldr	r3, [r13, #4]
8f62ffa8:	e0332002 	eors	r2, r3, r2
8f62ffac:	e3a03000 	mov	r3, #0
8f62ffb0:	1a00000a 	bne	8f62ffe0 <fbcon_draw_line+0x148>
}
8f62ffb4:	e28dd008 	add	r13, r13, #8
8f62ffb8:	e8bd4070 	pop	{r4, r5, r6, r14}
		fbcon_flush();
8f62ffbc:	eafffeed 	b	8f62fb78 <fbcon_flush>
}
8f62ffc0:	e59f301c 	ldr	r3, [pc, #28]	; 8f62ffe4 <fbcon_draw_line+0x14c>
8f62ffc4:	e5932000 	ldr	r2, [r3]
8f62ffc8:	e59d3004 	ldr	r3, [r13, #4]
8f62ffcc:	e0332002 	eors	r2, r3, r2
8f62ffd0:	e3a03000 	mov	r3, #0
8f62ffd4:	1a000001 	bne	8f62ffe0 <fbcon_draw_line+0x148>
8f62ffd8:	e28dd008 	add	r13, r13, #8
8f62ffdc:	e8bd8070 	pop	{r4, r5, r6, r15}
8f62ffe0:	eb000af6 	bl	8f632bc0 <__stack_chk_fail>
8f62ffe4:	8f74221c 	.word	0x8f74221c

8f62ffe8 <fbcon_clear>:
	unsigned char *pixels = NULL;
	unsigned count;
	uint32_t bg_color;

	/* ignore anything that happens before fbcon is initialized */
	if (!config)
8f62ffe8:	e3023188 	movw	r3, #8584	; 0x2188
8f62ffec:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f62fff0:	e59f20c4 	ldr	r2, [pc, #196]	; 8f6300bc <fbcon_clear+0xd4>
	if (!config)
8f62fff4:	e593c000 	ldr	r12, [r3]
{
8f62fff8:	e92d4030 	push	{r4, r5, r14}
	if (!config)
8f62fffc:	e35c0000 	cmp	r12, #0
{
8f630000:	e24dd00c 	sub	r13, r13, #12
8f630004:	e5922000 	ldr	r2, [r2]
8f630008:	e58d2004 	str	r2, [r13, #4]
8f63000c:	e3a02000 	mov	r2, #0
	if (!config)
8f630010:	0a000020 	beq	8f630098 <fbcon_clear+0xb0>
		return;

	pixels = config->base;
	count =  config->width * config->height;
8f630014:	e59c1008 	ldr	r1, [r12, #8]
	BGCOLOR = fb_color_formats[type].bg;
8f630018:	e3022194 	movw	r2, #8596	; 0x2194
	count =  config->width * config->height;
8f63001c:	e59c4004 	ldr	r4, [r12, #4]
	BGCOLOR = fb_color_formats[type].bg;
8f630020:	e3482f74 	movt	r2, #36724	; 0x8f74
8f630024:	e3023180 	movw	r3, #8576	; 0x2180
8f630028:	e3483f74 	movt	r3, #36724	; 0x8f74
8f63002c:	e5922000 	ldr	r2, [r2]
	count =  config->width * config->height;
8f630030:	e0040491 	mul	r4, r1, r4
	pixels = config->base;
8f630034:	e59c0000 	ldr	r0, [r12]
	BGCOLOR = fb_color_formats[type].bg;
8f630038:	e5925004 	ldr	r5, [r2, #4]

	fbcon_set_colors(FBCON_COMMON_MSG);
	for (i = 0; i < count; i++) {
8f63003c:	e3540000 	cmp	r4, #0
	BGCOLOR = fb_color_formats[type].bg;
8f630040:	e5835000 	str	r5, [r3]
	for (i = 0; i < count; i++) {
8f630044:	159c1010 	ldrne	r1, [r12, #16]
8f630048:	13a0e000 	movne	r14, #0
8f63004c:	0a00000c 	beq	8f630084 <fbcon_clear+0x9c>
		bg_color = BGCOLOR;
		for (j = 0; j < (config->bpp / 8); j++) {
8f630050:	e1b031a1 	lsrs	r3, r1, #3
		bg_color = BGCOLOR;
8f630054:	11a02005 	movne	r2, r5
		for (j = 0; j < (config->bpp / 8); j++) {
8f630058:	13a03000 	movne	r3, #0
8f63005c:	0a000005 	beq	8f630078 <fbcon_clear+0x90>
			*pixels = (unsigned char) bg_color;
8f630060:	e4c02001 	strb	r2, [r0], #1
		for (j = 0; j < (config->bpp / 8); j++) {
8f630064:	e2833001 	add	r3, r3, #1
8f630068:	e59c1010 	ldr	r1, [r12, #16]
			bg_color = bg_color >> 8;
8f63006c:	e1a02422 	lsr	r2, r2, #8
		for (j = 0; j < (config->bpp / 8); j++) {
8f630070:	e15301a1 	cmp	r3, r1, lsr #3
8f630074:	3afffff9 	bcc	8f630060 <fbcon_clear+0x78>
	for (i = 0; i < count; i++) {
8f630078:	e28ee001 	add	r14, r14, #1
8f63007c:	e154000e 	cmp	r4, r14
8f630080:	1afffff2 	bne	8f630050 <fbcon_clear+0x68>
			pixels++;
		}
	}
	cur_pos.x = 0;
8f630084:	e302318c 	movw	r3, #8588	; 0x218c
8f630088:	e3483f74 	movt	r3, #36724	; 0x8f74
8f63008c:	e3a02000 	mov	r2, #0
8f630090:	e5832000 	str	r2, [r3]
	cur_pos.y = 0;
8f630094:	e5832004 	str	r2, [r3, #4]
}
8f630098:	e59f301c 	ldr	r3, [pc, #28]	; 8f6300bc <fbcon_clear+0xd4>
8f63009c:	e5932000 	ldr	r2, [r3]
8f6300a0:	e59d3004 	ldr	r3, [r13, #4]
8f6300a4:	e0332002 	eors	r2, r3, r2
8f6300a8:	e3a03000 	mov	r3, #0
8f6300ac:	1a000001 	bne	8f6300b8 <fbcon_clear+0xd0>
8f6300b0:	e28dd00c 	add	r13, r13, #12
8f6300b4:	e8bd8030 	pop	{r4, r5, r15}
8f6300b8:	eb000ac0 	bl	8f632bc0 <__stack_chk_fail>
8f6300bc:	8f74221c 	.word	0x8f74221c

8f6300c0 <fbcon_putc_factor>:
void fbcon_putc_factor(char c, int type, unsigned scale_factor)
{
	char *pixels;

	/* ignore anything that happens before fbcon is initialized */
	if (!config)
8f6300c0:	e3023188 	movw	r3, #8584	; 0x2188
8f6300c4:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f6300c8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f6300cc:	e1a0c001 	mov	r12, r1
	if (!config)
8f6300d0:	e593e000 	ldr	r14, [r3]
{
8f6300d4:	e1a01002 	mov	r1, r2
8f6300d8:	e59f2308 	ldr	r2, [pc, #776]	; 8f6303e8 <fbcon_putc_factor+0x328>
8f6300dc:	e24dd01c 	sub	r13, r13, #28
	if (!config)
8f6300e0:	e35e0000 	cmp	r14, #0
{
8f6300e4:	e5922000 	ldr	r2, [r2]
8f6300e8:	e58d2014 	str	r2, [r13, #20]
8f6300ec:	e3a02000 	mov	r2, #0
	if (!config)
8f6300f0:	0a000008 	beq	8f630118 <fbcon_putc_factor+0x58>
		return;

	if((unsigned char)c > 127)
8f6300f4:	e3100080 	tst	r0, #128	; 0x80
8f6300f8:	e1a03000 	mov	r3, r0
8f6300fc:	1a000005 	bne	8f630118 <fbcon_putc_factor+0x58>
		return;

	if((unsigned char)c < 32) {
8f630100:	e350001f 	cmp	r0, #31
8f630104:	8a00000b 	bhi	8f630138 <fbcon_putc_factor+0x78>
		if(c == '\n')
8f630108:	e350000a 	cmp	r0, #10
8f63010c:	0a0000ad 	beq	8f6303c8 <fbcon_putc_factor+0x308>
			goto newline;
		else if (c == '\r') {
8f630110:	e350000d 	cmp	r0, #13
8f630114:	0a0000a6 	beq	8f6303b4 <fbcon_putc_factor+0x2f4>
	if((uint32_t)cur_pos.y > max_pos.y-scale_factor) {
		cur_pos.y = max_pos.y - scale_factor;
		fbcon_scroll_up();
	} else
		fbcon_flush();
}
8f630118:	e59f32c8 	ldr	r3, [pc, #712]	; 8f6303e8 <fbcon_putc_factor+0x328>
8f63011c:	e5932000 	ldr	r2, [r3]
8f630120:	e59d3014 	ldr	r3, [r13, #20]
8f630124:	e0332002 	eors	r2, r3, r2
8f630128:	e3a03000 	mov	r3, #0
8f63012c:	1a0000ac 	bne	8f6303e4 <fbcon_putc_factor+0x324>
8f630130:	e28dd01c 	add	r13, r13, #28
8f630134:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	if (cur_pos.x == 0 && (unsigned char)c == ' ' &&
8f630138:	e302418c 	movw	r4, #8588	; 0x218c
8f63013c:	e3484f74 	movt	r4, #36724	; 0x8f74
8f630140:	e5942000 	ldr	r2, [r4]
8f630144:	e3520000 	cmp	r2, #0
8f630148:	e58d2000 	str	r2, [r13]
8f63014c:	1a000007 	bne	8f630170 <fbcon_putc_factor+0xb0>
		type != FBCON_SUBTITLE_MSG &&
8f630150:	e24c2002 	sub	r2, r12, #2
8f630154:	e3520001 	cmp	r2, #1
8f630158:	93a02000 	movls	r2, #0
8f63015c:	83a02001 	movhi	r2, #1
8f630160:	e3500020 	cmp	r0, #32
8f630164:	13a02000 	movne	r2, #0
8f630168:	e3520000 	cmp	r2, #0
8f63016c:	1affffe9 	bne	8f630118 <fbcon_putc_factor+0x58>
			font5x12 + (c - 32) * 2, scale_factor);
8f630170:	e2430020 	sub	r0, r3, #32
	pixels += cur_pos.y * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f630174:	e5943004 	ldr	r3, [r4, #4]
	pixels += cur_pos.x * scale_factor * ((config->bpp / 8) * (FONT_WIDTH + 1));
8f630178:	e3a06006 	mov	r6, #6
	BGCOLOR = fb_color_formats[type].bg;
8f63017c:	e3025194 	movw	r5, #8596	; 0x2194
8f630180:	e3485f74 	movt	r5, #36724	; 0x8f74
			pixels += (stride * bpp);
8f630184:	e58d6008 	str	r6, [r13, #8]
	pixels += cur_pos.y * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f630188:	e1a02003 	mov	r2, r3
8f63018c:	e58d3004 	str	r3, [r13, #4]
8f630190:	e59e3004 	ldr	r3, [r14, #4]
	BGCOLOR = fb_color_formats[type].bg;
8f630194:	e5955000 	ldr	r5, [r5]
	stride -= FONT_WIDTH * scale_factor;
8f630198:	e59e800c 	ldr	r8, [r14, #12]
	pixels += cur_pos.y * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f63019c:	e0020293 	mul	r2, r3, r2
	pixels += cur_pos.x * scale_factor * ((config->bpp / 8) * (FONT_WIDTH + 1));
8f6301a0:	e59d3000 	ldr	r3, [r13]
	BGCOLOR = fb_color_formats[type].bg;
8f6301a4:	e085718c 	add	r7, r5, r12, lsl #3
	pixels += cur_pos.x * scale_factor * ((config->bpp / 8) * (FONT_WIDTH + 1));
8f6301a8:	e0030391 	mul	r3, r1, r3
8f6301ac:	e0030396 	mul	r3, r6, r3
	pixels += cur_pos.y * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f6301b0:	e3a0600c 	mov	r6, #12
	pixels += cur_pos.x * scale_factor * ((config->bpp / 8) * (FONT_WIDTH + 1));
8f6301b4:	e0233296 	mla	r3, r6, r2, r3
	pixels += cur_pos.y * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f6301b8:	e59e2010 	ldr	r2, [r14, #16]
	FGCOLOR = fb_color_formats[type].fg;
8f6301bc:	e795618c 	ldr	r6, [r5, r12, lsl #3]
	pixels = config->base;
8f6301c0:	e59ec000 	ldr	r12, [r14]
	pixels += cur_pos.y * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f6301c4:	e1a021a2 	lsr	r2, r2, #3
	BGCOLOR = fb_color_formats[type].bg;
8f6301c8:	e5975004 	ldr	r5, [r7, #4]
	pixels += cur_pos.x * scale_factor * ((config->bpp / 8) * (FONT_WIDTH + 1));
8f6301cc:	e023c392 	mla	r3, r2, r3, r12
	stride -= FONT_WIDTH * scale_factor;
8f6301d0:	e081c101 	add	r12, r1, r1, lsl #2
8f6301d4:	e048800c 	sub	r8, r8, r12
	BGCOLOR = fb_color_formats[type].bg;
8f6301d8:	e302c180 	movw	r12, #8576	; 0x2180
8f6301dc:	e348cf74 	movt	r12, #36724	; 0x8f74
			pixels += (stride * bpp);
8f6301e0:	e0080892 	mul	r8, r2, r8
	BGCOLOR = fb_color_formats[type].bg;
8f6301e4:	e58c5000 	str	r5, [r12]
	fbcon_drawglyph(pixels, FGCOLOR, config->stride, (config->bpp / 8),
8f6301e8:	e0070291 	mul	r7, r1, r2
8f6301ec:	e303c0b4 	movw	r12, #12468	; 0x30b4
8f6301f0:	e348cf71 	movt	r12, #36721	; 0x8f71
8f6301f4:	e08ce180 	add	r14, r12, r0, lsl #3
8f6301f8:	e58de00c 	str	r14, [r13, #12]
	data = glyph[0];
8f6301fc:	e79cb180 	ldr	r11, [r12, r0, lsl #3]
		for (i = 0; i < scale_factor; i++) {
8f630200:	e3510000 	cmp	r1, #0
8f630204:	13a0a000 	movne	r10, #0
8f630208:	0a00000c 	beq	8f630240 <fbcon_putc_factor+0x180>
8f63020c:	e1a0e00b 	mov	r14, r11
8f630210:	e3a05005 	mov	r5, #5
				if (data & 1) {
8f630214:	e31e0001 	tst	r14, #1
8f630218:	1a00004f 	bne	8f63035c <fbcon_putc_factor+0x29c>
						pixels = pixels + bpp;
8f63021c:	e0833007 	add	r3, r3, r7
			for (x = 0; x < FONT_WIDTH; ++x) {
8f630220:	e2555001 	subs	r5, r5, #1
				data >>= 1;
8f630224:	e1a0e0ae 	lsr	r14, r14, #1
			for (x = 0; x < FONT_WIDTH; ++x) {
8f630228:	1afffff9 	bne	8f630214 <fbcon_putc_factor+0x154>
		for (i = 0; i < scale_factor; i++) {
8f63022c:	e28aa001 	add	r10, r10, #1
			pixels += (stride * bpp);
8f630230:	e0833008 	add	r3, r3, r8
		for (i = 0; i < scale_factor; i++) {
8f630234:	e151000a 	cmp	r1, r10
8f630238:	1afffff3 	bne	8f63020c <fbcon_putc_factor+0x14c>
				data >>= 1;
8f63023c:	e1a0b00e 	mov	r11, r14
	for (y = 0; y < FONT_HEIGHT / 2; ++y) {
8f630240:	e59d0008 	ldr	r0, [r13, #8]
8f630244:	e2500001 	subs	r0, r0, #1
8f630248:	e58d0008 	str	r0, [r13, #8]
8f63024c:	1affffeb 	bne	8f630200 <fbcon_putc_factor+0x140>
	data = glyph[1];
8f630250:	e59d000c 	ldr	r0, [r13, #12]
8f630254:	e590b004 	ldr	r11, [r0, #4]
8f630258:	e3a00006 	mov	r0, #6
8f63025c:	e58d0008 	str	r0, [r13, #8]
		for (i = 0; i < scale_factor; i++) {
8f630260:	e3510000 	cmp	r1, #0
8f630264:	13a0a000 	movne	r10, #0
8f630268:	0a00000c 	beq	8f6302a0 <fbcon_putc_factor+0x1e0>
8f63026c:	e1a0e00b 	mov	r14, r11
8f630270:	e3a05005 	mov	r5, #5
				if (data & 1) {
8f630274:	e31e0001 	tst	r14, #1
8f630278:	1a00002a 	bne	8f630328 <fbcon_putc_factor+0x268>
						pixels = pixels + bpp;
8f63027c:	e0833007 	add	r3, r3, r7
			for (x = 0; x < FONT_WIDTH; ++x) {
8f630280:	e2555001 	subs	r5, r5, #1
				data >>= 1;
8f630284:	e1a0e0ae 	lsr	r14, r14, #1
			for (x = 0; x < FONT_WIDTH; ++x) {
8f630288:	1afffff9 	bne	8f630274 <fbcon_putc_factor+0x1b4>
		for (i = 0; i < scale_factor; i++) {
8f63028c:	e28aa001 	add	r10, r10, #1
			pixels += (stride * bpp);
8f630290:	e0833008 	add	r3, r3, r8
		for (i = 0; i < scale_factor; i++) {
8f630294:	e151000a 	cmp	r1, r10
8f630298:	1afffff3 	bne	8f63026c <fbcon_putc_factor+0x1ac>
				data >>= 1;
8f63029c:	e1a0b00e 	mov	r11, r14
	for (y = 0; y < FONT_HEIGHT / 2; ++y) {
8f6302a0:	e59d0008 	ldr	r0, [r13, #8]
8f6302a4:	e2500001 	subs	r0, r0, #1
8f6302a8:	e58d0008 	str	r0, [r13, #8]
8f6302ac:	1affffeb 	bne	8f630260 <fbcon_putc_factor+0x1a0>
	if (cur_pos.x >= (int)(max_pos.x / scale_factor))
8f6302b0:	e3025198 	movw	r5, #8600	; 0x2198
8f6302b4:	e3485f74 	movt	r5, #36724	; 0x8f74
	cur_pos.x++;
8f6302b8:	e59d3000 	ldr	r3, [r13]
	if (cur_pos.x >= (int)(max_pos.x / scale_factor))
8f6302bc:	e5950000 	ldr	r0, [r5]
	cur_pos.x++;
8f6302c0:	e2836001 	add	r6, r3, #1
	if (cur_pos.x >= (int)(max_pos.x / scale_factor))
8f6302c4:	e58d1000 	str	r1, [r13]
	cur_pos.x++;
8f6302c8:	e5846000 	str	r6, [r4]
	if (cur_pos.x >= (int)(max_pos.x / scale_factor))
8f6302cc:	fa003241 	blx	8f63cbd8 <__udivsi3>
8f6302d0:	e59d1000 	ldr	r1, [r13]
8f6302d4:	e1560000 	cmp	r6, r0
8f6302d8:	baffff8e 	blt	8f630118 <fbcon_putc_factor+0x58>
	if((uint32_t)cur_pos.y > max_pos.y-scale_factor) {
8f6302dc:	e5952004 	ldr	r2, [r5, #4]
	cur_pos.x = 0;
8f6302e0:	e3a00000 	mov	r0, #0
	cur_pos.y += scale_factor;
8f6302e4:	e59d3004 	ldr	r3, [r13, #4]
	cur_pos.x = 0;
8f6302e8:	e5840000 	str	r0, [r4]
	cur_pos.y += scale_factor;
8f6302ec:	e0813003 	add	r3, r1, r3
	if((uint32_t)cur_pos.y > max_pos.y-scale_factor) {
8f6302f0:	e0421001 	sub	r1, r2, r1
8f6302f4:	e1530001 	cmp	r3, r1
	cur_pos.y += scale_factor;
8f6302f8:	e5843004 	str	r3, [r4, #4]
	if((uint32_t)cur_pos.y > max_pos.y-scale_factor) {
8f6302fc:	9a000023 	bls	8f630390 <fbcon_putc_factor+0x2d0>
		fbcon_scroll_up();
8f630300:	e59f30e0 	ldr	r3, [pc, #224]	; 8f6303e8 <fbcon_putc_factor+0x328>
		cur_pos.y = max_pos.y - scale_factor;
8f630304:	e5841004 	str	r1, [r4, #4]
		fbcon_scroll_up();
8f630308:	e5932000 	ldr	r2, [r3]
8f63030c:	e59d3014 	ldr	r3, [r13, #20]
8f630310:	e0332002 	eors	r2, r3, r2
8f630314:	e3a03000 	mov	r3, #0
8f630318:	1a000031 	bne	8f6303e4 <fbcon_putc_factor+0x324>
}
8f63031c:	e28dd01c 	add	r13, r13, #28
8f630320:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
		fbcon_scroll_up();
8f630324:	eafffe9b 	b	8f62fd98 <fbcon_scroll_up>
					for (j = 0; j < scale_factor; j++) {
8f630328:	e3a00000 	mov	r0, #0
						for (k = 0; k < bpp; k++) {
8f63032c:	e3520000 	cmp	r2, #0
8f630330:	10839002 	addne	r9, r3, r2
						fg_color = paint;
8f630334:	11a0c006 	movne	r12, r6
						for (k = 0; k < bpp; k++) {
8f630338:	0a000003 	beq	8f63034c <fbcon_putc_factor+0x28c>
							*pixels = (unsigned char) fg_color;
8f63033c:	e4c3c001 	strb	r12, [r3], #1
						for (k = 0; k < bpp; k++) {
8f630340:	e1530009 	cmp	r3, r9
							fg_color = fg_color >> 8;
8f630344:	e1a0c42c 	lsr	r12, r12, #8
						for (k = 0; k < bpp; k++) {
8f630348:	1afffffb 	bne	8f63033c <fbcon_putc_factor+0x27c>
					for (j = 0; j < scale_factor; j++) {
8f63034c:	e2800001 	add	r0, r0, #1
8f630350:	e1510000 	cmp	r1, r0
8f630354:	1afffff4 	bne	8f63032c <fbcon_putc_factor+0x26c>
8f630358:	eaffffc8 	b	8f630280 <fbcon_putc_factor+0x1c0>
					for (j = 0; j < scale_factor; j++) {
8f63035c:	e3a00000 	mov	r0, #0
						for (k = 0; k < bpp; k++) {
8f630360:	e3520000 	cmp	r2, #0
8f630364:	10839002 	addne	r9, r3, r2
						fg_color = paint;
8f630368:	11a0c006 	movne	r12, r6
						for (k = 0; k < bpp; k++) {
8f63036c:	0a000003 	beq	8f630380 <fbcon_putc_factor+0x2c0>
							*pixels = (unsigned char) fg_color;
8f630370:	e4c3c001 	strb	r12, [r3], #1
						for (k = 0; k < bpp; k++) {
8f630374:	e1530009 	cmp	r3, r9
							fg_color = fg_color >> 8;
8f630378:	e1a0c42c 	lsr	r12, r12, #8
						for (k = 0; k < bpp; k++) {
8f63037c:	1afffffb 	bne	8f630370 <fbcon_putc_factor+0x2b0>
					for (j = 0; j < scale_factor; j++) {
8f630380:	e2800001 	add	r0, r0, #1
8f630384:	e1510000 	cmp	r1, r0
8f630388:	1afffff4 	bne	8f630360 <fbcon_putc_factor+0x2a0>
8f63038c:	eaffffa3 	b	8f630220 <fbcon_putc_factor+0x160>
		fbcon_flush();
8f630390:	e59f3050 	ldr	r3, [pc, #80]	; 8f6303e8 <fbcon_putc_factor+0x328>
8f630394:	e5932000 	ldr	r2, [r3]
8f630398:	e59d3014 	ldr	r3, [r13, #20]
8f63039c:	e0332002 	eors	r2, r3, r2
8f6303a0:	e3a03000 	mov	r3, #0
8f6303a4:	1a00000e 	bne	8f6303e4 <fbcon_putc_factor+0x324>
}
8f6303a8:	e28dd01c 	add	r13, r13, #28
8f6303ac:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
		fbcon_flush();
8f6303b0:	eafffdf0 	b	8f62fb78 <fbcon_flush>
			cur_pos.x = 0;
8f6303b4:	e302318c 	movw	r3, #8588	; 0x218c
8f6303b8:	e3483f74 	movt	r3, #36724	; 0x8f74
8f6303bc:	e3a02000 	mov	r2, #0
8f6303c0:	e5832000 	str	r2, [r3]
			return;
8f6303c4:	eaffff53 	b	8f630118 <fbcon_putc_factor+0x58>
	pixels += cur_pos.y * ((config->bpp / 8) * FONT_HEIGHT * config->width);
8f6303c8:	e302418c 	movw	r4, #8588	; 0x218c
8f6303cc:	e3484f74 	movt	r4, #36724	; 0x8f74
8f6303d0:	e3025198 	movw	r5, #8600	; 0x2198
8f6303d4:	e3485f74 	movt	r5, #36724	; 0x8f74
8f6303d8:	e5943004 	ldr	r3, [r4, #4]
8f6303dc:	e58d3004 	str	r3, [r13, #4]
8f6303e0:	eaffffbd 	b	8f6302dc <fbcon_putc_factor+0x21c>
}
8f6303e4:	eb0009f5 	bl	8f632bc0 <__stack_chk_fail>
8f6303e8:	8f74221c 	.word	0x8f74221c

8f6303ec <fbcon_get_current_line>:
	fbcon_putc_factor(c, FBCON_COMMON_MSG, SCALE_FACTOR);
}

uint32_t fbcon_get_current_line(void)
{
	return cur_pos.y;
8f6303ec:	e302318c 	movw	r3, #8588	; 0x218c
8f6303f0:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f6303f4:	e59f2038 	ldr	r2, [pc, #56]	; 8f630434 <fbcon_get_current_line+0x48>
8f6303f8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6303fc:	e24dd00c 	sub	r13, r13, #12
	return cur_pos.y;
8f630400:	e5930004 	ldr	r0, [r3, #4]
{
8f630404:	e5922000 	ldr	r2, [r2]
8f630408:	e58d2004 	str	r2, [r13, #4]
8f63040c:	e3a02000 	mov	r2, #0
}
8f630410:	e59f301c 	ldr	r3, [pc, #28]	; 8f630434 <fbcon_get_current_line+0x48>
8f630414:	e5932000 	ldr	r2, [r3]
8f630418:	e59d3004 	ldr	r3, [r13, #4]
8f63041c:	e0332002 	eors	r2, r3, r2
8f630420:	e3a03000 	mov	r3, #0
8f630424:	1a000001 	bne	8f630430 <fbcon_get_current_line+0x44>
8f630428:	e28dd00c 	add	r13, r13, #12
8f63042c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f630430:	eb0009e2 	bl	8f632bc0 <__stack_chk_fail>
8f630434:	8f74221c 	.word	0x8f74221c

8f630438 <fbcon_get_max_x>:

uint32_t fbcon_get_max_x(void)
{
	return max_pos.x;
8f630438:	e3023198 	movw	r3, #8600	; 0x2198
8f63043c:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f630440:	e59f2038 	ldr	r2, [pc, #56]	; 8f630480 <fbcon_get_max_x+0x48>
8f630444:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f630448:	e24dd00c 	sub	r13, r13, #12
	return max_pos.x;
8f63044c:	e5930000 	ldr	r0, [r3]
{
8f630450:	e5922000 	ldr	r2, [r2]
8f630454:	e58d2004 	str	r2, [r13, #4]
8f630458:	e3a02000 	mov	r2, #0
}
8f63045c:	e59f301c 	ldr	r3, [pc, #28]	; 8f630480 <fbcon_get_max_x+0x48>
8f630460:	e5932000 	ldr	r2, [r3]
8f630464:	e59d3004 	ldr	r3, [r13, #4]
8f630468:	e0332002 	eors	r2, r3, r2
8f63046c:	e3a03000 	mov	r3, #0
8f630470:	1a000001 	bne	8f63047c <fbcon_get_max_x+0x44>
8f630474:	e28dd00c 	add	r13, r13, #12
8f630478:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f63047c:	eb0009cf 	bl	8f632bc0 <__stack_chk_fail>
8f630480:	8f74221c 	.word	0x8f74221c

8f630484 <fbcon_get_width>:

uint32_t fbcon_get_width(void)
{
	if (config)
8f630484:	e3023188 	movw	r3, #8584	; 0x2188
8f630488:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f63048c:	e59f2040 	ldr	r2, [pc, #64]	; 8f6304d4 <fbcon_get_width+0x50>
	if (config)
8f630490:	e5930000 	ldr	r0, [r3]
{
8f630494:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	if (config)
8f630498:	e3500000 	cmp	r0, #0
{
8f63049c:	e24dd00c 	sub	r13, r13, #12
		return config->width;
	else
		return 0;
}
8f6304a0:	e59f302c 	ldr	r3, [pc, #44]	; 8f6304d4 <fbcon_get_width+0x50>
{
8f6304a4:	e5922000 	ldr	r2, [r2]
8f6304a8:	e58d2004 	str	r2, [r13, #4]
8f6304ac:	e3a02000 	mov	r2, #0
		return config->width;
8f6304b0:	15900004 	ldrne	r0, [r0, #4]
}
8f6304b4:	e5932000 	ldr	r2, [r3]
8f6304b8:	e59d3004 	ldr	r3, [r13, #4]
8f6304bc:	e0332002 	eors	r2, r3, r2
8f6304c0:	e3a03000 	mov	r3, #0
8f6304c4:	1a000001 	bne	8f6304d0 <fbcon_get_width+0x4c>
8f6304c8:	e28dd00c 	add	r13, r13, #12
8f6304cc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6304d0:	eb0009ba 	bl	8f632bc0 <__stack_chk_fail>
8f6304d4:	8f74221c 	.word	0x8f74221c

8f6304d8 <fbcon_get_height>:

uint32_t fbcon_get_height(void)
{
	if (config)
8f6304d8:	e3023188 	movw	r3, #8584	; 0x2188
8f6304dc:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f6304e0:	e59f2040 	ldr	r2, [pc, #64]	; 8f630528 <fbcon_get_height+0x50>
	if (config)
8f6304e4:	e5930000 	ldr	r0, [r3]
{
8f6304e8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	if (config)
8f6304ec:	e3500000 	cmp	r0, #0
{
8f6304f0:	e24dd00c 	sub	r13, r13, #12
		return config->height;
	else
		return 0;
}
8f6304f4:	e59f302c 	ldr	r3, [pc, #44]	; 8f630528 <fbcon_get_height+0x50>
{
8f6304f8:	e5922000 	ldr	r2, [r2]
8f6304fc:	e58d2004 	str	r2, [r13, #4]
8f630500:	e3a02000 	mov	r2, #0
		return config->height;
8f630504:	15900008 	ldrne	r0, [r0, #8]
}
8f630508:	e5932000 	ldr	r2, [r3]
8f63050c:	e59d3004 	ldr	r3, [r13, #4]
8f630510:	e0332002 	eors	r2, r3, r2
8f630514:	e3a03000 	mov	r3, #0
8f630518:	1a000001 	bne	8f630524 <fbcon_get_height+0x4c>
8f63051c:	e28dd00c 	add	r13, r13, #12
8f630520:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f630524:	eb0009a5 	bl	8f632bc0 <__stack_chk_fail>
8f630528:	8f74221c 	.word	0x8f74221c

8f63052c <fbcon_get_current_bg>:

uint32_t fbcon_get_current_bg(void)
{
	return BGCOLOR;
8f63052c:	e3023180 	movw	r3, #8576	; 0x2180
8f630530:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f630534:	e59f2038 	ldr	r2, [pc, #56]	; 8f630574 <fbcon_get_current_bg+0x48>
8f630538:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f63053c:	e24dd00c 	sub	r13, r13, #12
	return BGCOLOR;
8f630540:	e5930000 	ldr	r0, [r3]
{
8f630544:	e5922000 	ldr	r2, [r2]
8f630548:	e58d2004 	str	r2, [r13, #4]
8f63054c:	e3a02000 	mov	r2, #0
}
8f630550:	e59f301c 	ldr	r3, [pc, #28]	; 8f630574 <fbcon_get_current_bg+0x48>
8f630554:	e5932000 	ldr	r2, [r3]
8f630558:	e59d3004 	ldr	r3, [r13, #4]
8f63055c:	e0332002 	eors	r2, r3, r2
8f630560:	e3a03000 	mov	r3, #0
8f630564:	1a000001 	bne	8f630570 <fbcon_get_current_bg+0x44>
8f630568:	e28dd00c 	add	r13, r13, #12
8f63056c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f630570:	eb000992 	bl	8f632bc0 <__stack_chk_fail>
8f630574:	8f74221c 	.word	0x8f74221c

8f630578 <fbcon_display>:

}

struct fbcon_config* fbcon_display(void)
{
	return config;
8f630578:	e3023188 	movw	r3, #8584	; 0x2188
8f63057c:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f630580:	e59f2038 	ldr	r2, [pc, #56]	; 8f6305c0 <fbcon_display+0x48>
8f630584:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f630588:	e24dd00c 	sub	r13, r13, #12
	return config;
8f63058c:	e5930000 	ldr	r0, [r3]
{
8f630590:	e5922000 	ldr	r2, [r2]
8f630594:	e58d2004 	str	r2, [r13, #4]
8f630598:	e3a02000 	mov	r2, #0
}
8f63059c:	e59f301c 	ldr	r3, [pc, #28]	; 8f6305c0 <fbcon_display+0x48>
8f6305a0:	e5932000 	ldr	r2, [r3]
8f6305a4:	e59d3004 	ldr	r3, [r13, #4]
8f6305a8:	e0332002 	eors	r2, r3, r2
8f6305ac:	e3a03000 	mov	r3, #0
8f6305b0:	1a000001 	bne	8f6305bc <fbcon_display+0x44>
8f6305b4:	e28dd00c 	add	r13, r13, #12
8f6305b8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6305bc:	eb00097f 	bl	8f632bc0 <__stack_chk_fail>
8f6305c0:	8f74221c 	.word	0x8f74221c

8f6305c4 <fbcon_extract_to_screen>:
	uint pos = 0, offset;
	uint count = 0;
	uint x = 0, y = 0;
	uint8_t *base, *p;

	if (!config || header->width > config->width
8f6305c4:	e3023188 	movw	r3, #8584	; 0x2188
8f6305c8:	e3483f74 	movt	r3, #36724	; 0x8f74
{
8f6305cc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f6305d0:	e24dd014 	sub	r13, r13, #20
	if (!config || header->width > config->width
8f6305d4:	e593a000 	ldr	r10, [r3]
{
8f6305d8:	e59f316c 	ldr	r3, [pc, #364]	; 8f63074c <fbcon_extract_to_screen+0x188>
	if (!config || header->width > config->width
8f6305dc:	e35a0000 	cmp	r10, #0
{
8f6305e0:	e5933000 	ldr	r3, [r3]
8f6305e4:	e58d300c 	str	r3, [r13, #12]
8f6305e8:	e3a03000 	mov	r3, #0
	if (!config || header->width > config->width
8f6305ec:	0a000042 	beq	8f6306fc <fbcon_extract_to_screen+0x138>
8f6305f0:	e1a07000 	mov	r7, r0
8f6305f4:	e59a3004 	ldr	r3, [r10, #4]
8f6305f8:	e1a00001 	mov	r0, r1
8f6305fc:	e5971008 	ldr	r1, [r7, #8]
8f630600:	e1510003 	cmp	r1, r3
8f630604:	8a00003c 	bhi	8f6306fc <fbcon_extract_to_screen+0x138>
				|| header->height > config->height) {
8f630608:	e597c00c 	ldr	r12, [r7, #12]
8f63060c:	e59a2008 	ldr	r2, [r10, #8]
8f630610:	e15c0002 	cmp	r12, r2
8f630614:	8a000038 	bhi	8f6306fc <fbcon_extract_to_screen+0x138>
	}

	base = (uint8_t *) config->base;

	/* put the logo to be center */
	offset = (config->height - header->height) / 2;
8f630618:	e042200c 	sub	r2, r2, r12
	base = (uint8_t *) config->base;
8f63061c:	e59ae000 	ldr	r14, [r10]
	if (offset)
8f630620:	e3520001 	cmp	r2, #1
	offset = (config->height - header->height) / 2;
8f630624:	81a020a2 	lsrhi	r2, r2, #1
		base += (offset * config->width) * 3;
	offset = (config->width - header->width ) / 2;

	x = offset;
	while (count < (uint)header->height * (uint)header->width) {
8f630628:	e00c019c 	mul	r12, r12, r1
	base = (uint8_t *) config->base;
8f63062c:	e58de004 	str	r14, [r13, #4]
		base += (offset * config->width) * 3;
8f630630:	80020293 	mulhi	r2, r3, r2
	offset = (config->width - header->width ) / 2;
8f630634:	e0431001 	sub	r1, r3, r1
8f630638:	e1a090a1 	lsr	r9, r1, #1
		base += (offset * config->width) * 3;
8f63063c:	80822082 	addhi	r2, r2, r2, lsl #1
8f630640:	808e2002 	addhi	r2, r14, r2
8f630644:	858d2004 	strhi	r2, [r13, #4]
	while (count < (uint)header->height * (uint)header->width) {
8f630648:	e35c0000 	cmp	r12, #0
8f63064c:	0a000035 	beq	8f630728 <fbcon_extract_to_screen+0x164>
	uint x = 0, y = 0;
8f630650:	e3a0b000 	mov	r11, #0
	x = offset;
8f630654:	e1a06009 	mov	r6, r9
	uint count = 0;
8f630658:	e1a0800b 	mov	r8, r11
	uint pos = 0, offset;
8f63065c:	e1a0100b 	mov	r1, r11
		uint runpos;

		/* consume the run byte */
		pos++;

		p = base + (y * config->width + x) * 3;
8f630660:	e0236b93 	mla	r3, r3, r11, r6
		uint8_t run = *(imagestart + pos);
8f630664:	e7d0e001 	ldrb	r14, [r0, r1]
		p = base + (y * config->width + x) * 3;
8f630668:	e59d2004 	ldr	r2, [r13, #4]
		pos++;
8f63066c:	e2811001 	add	r1, r1, #1
8f630670:	e20e507f 	and	r5, r14, #127	; 0x7f
8f630674:	e2855001 	add	r5, r5, #1
8f630678:	e6afe07e 	sxtb	r14, r14
		p = base + (y * config->width + x) * 3;
8f63067c:	e0833083 	add	r3, r3, r3, lsl #1
8f630680:	e0823003 	add	r3, r2, r3

		/* start of a run */
		for (runpos = 0; runpos < runlen; runpos++) {
8f630684:	e3a02003 	mov	r2, #3
8f630688:	e2833003 	add	r3, r3, #3
8f63068c:	e1043582 	smlabb	r4, r2, r5, r3
			*p++ = *(imagestart + pos);
8f630690:	e1a02000 	mov	r2, r0
8f630694:	e7f2c001 	ldrb	r12, [r2, r1]!
			count++;

			x++;

			/* if a run of raw pixels, consume an input pixel */
			if (!repeat_run)
8f630698:	e35e0000 	cmp	r14, #0
		for (runpos = 0; runpos < runlen; runpos++) {
8f63069c:	e2833003 	add	r3, r3, #3
				pos += 3;
8f6306a0:	a2811003 	addge	r1, r1, #3
			*p++ = *(imagestart + pos);
8f6306a4:	e543c006 	strb	r12, [r3, #-6]
			*p++ = *(imagestart + pos + 1);
8f6306a8:	e5d2c001 	ldrb	r12, [r2, #1]
8f6306ac:	e543c005 	strb	r12, [r3, #-5]
			*p++ = *(imagestart + pos + 2);
8f6306b0:	e5d22002 	ldrb	r2, [r2, #2]
8f6306b4:	e5432004 	strb	r2, [r3, #-4]
		for (runpos = 0; runpos < runlen; runpos++) {
8f6306b8:	e1540003 	cmp	r4, r3
8f6306bc:	1afffff3 	bne	8f630690 <fbcon_extract_to_screen+0xcc>
		if (repeat_run)
			pos += 3;

		/* the generator will keep compressing data line by line */
		/* don't cross the lines */
		if (x == header->width + offset) {
8f6306c0:	e5973008 	ldr	r3, [r7, #8]
		if (repeat_run)
8f6306c4:	e35e0000 	cmp	r14, #0
			x++;
8f6306c8:	e0866005 	add	r6, r6, r5
			pos += 3;
8f6306cc:	b2811003 	addlt	r1, r1, #3
		if (x == header->width + offset) {
8f6306d0:	e0832009 	add	r2, r3, r9
			count++;
8f6306d4:	e0888005 	add	r8, r8, r5
		if (x == header->width + offset) {
8f6306d8:	e1520006 	cmp	r2, r6
	while (count < (uint)header->height * (uint)header->width) {
8f6306dc:	e597200c 	ldr	r2, [r7, #12]
			y++;
8f6306e0:	028bb001 	addeq	r11, r11, #1
			x = offset;
8f6306e4:	01a06009 	moveq	r6, r9
	while (count < (uint)header->height * (uint)header->width) {
8f6306e8:	e0030392 	mul	r3, r2, r3
8f6306ec:	e1530008 	cmp	r3, r8
8f6306f0:	9a00000c 	bls	8f630728 <fbcon_extract_to_screen+0x164>
		p = base + (y * config->width + x) * 3;
8f6306f4:	e59a3004 	ldr	r3, [r10, #4]
8f6306f8:	eaffffd8 	b	8f630660 <fbcon_extract_to_screen+0x9c>
		dprintf(INFO, "the logo img is too large\n");
8f6306fc:	e59f3048 	ldr	r3, [pc, #72]	; 8f63074c <fbcon_extract_to_screen+0x188>
8f630700:	e5932000 	ldr	r2, [r3]
8f630704:	e59d300c 	ldr	r3, [r13, #12]
8f630708:	e0332002 	eors	r2, r3, r2
8f63070c:	e3a03000 	mov	r3, #0
8f630710:	1a00000c 	bne	8f630748 <fbcon_extract_to_screen+0x184>
8f630714:	e30a0fbc 	movw	r0, #44988	; 0xafbc
8f630718:	e3480f70 	movt	r0, #36720	; 0x8f70
		}
	}

}
8f63071c:	e28dd014 	add	r13, r13, #20
8f630720:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
		dprintf(INFO, "the logo img is too large\n");
8f630724:	ea000892 	b	8f632974 <_dprintf>
}
8f630728:	e59f301c 	ldr	r3, [pc, #28]	; 8f63074c <fbcon_extract_to_screen+0x188>
8f63072c:	e5932000 	ldr	r2, [r3]
8f630730:	e59d300c 	ldr	r3, [r13, #12]
8f630734:	e0332002 	eors	r2, r3, r2
8f630738:	e3a03000 	mov	r3, #0
8f63073c:	1a000001 	bne	8f630748 <fbcon_extract_to_screen+0x184>
8f630740:	e28dd014 	add	r13, r13, #20
8f630744:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
8f630748:	eb00091c 	bl	8f632bc0 <__stack_chk_fail>
8f63074c:	8f74221c 	.word	0x8f74221c

8f630750 <display_default_image_on_screen>:

void display_default_image_on_screen(void)
{
8f630750:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
	unsigned image_base;
#if DISPLAY_TYPE_MIPI
	char *image = NULL;
#endif

	if (!config) {
8f630754:	e3027188 	movw	r7, #8584	; 0x2188
8f630758:	e3487f74 	movt	r7, #36724	; 0x8f74
{
8f63075c:	e59f3138 	ldr	r3, [pc, #312]	; 8f63089c <display_default_image_on_screen+0x14c>
8f630760:	e24dd008 	sub	r13, r13, #8
	if (!config) {
8f630764:	e597a000 	ldr	r10, [r7]
{
8f630768:	e5933000 	ldr	r3, [r3]
8f63076c:	e58d3004 	str	r3, [r13, #4]
8f630770:	e3a03000 	mov	r3, #0
	if (!config) {
8f630774:	e35a0000 	cmp	r10, #0
8f630778:	0a00003b 	beq	8f63086c <display_default_image_on_screen+0x11c>
		dprintf(CRITICAL,"NULL configuration, image cannot be displayed\n");
		return;
	}

	fbcon_clear(); // clear screen with Black color
8f63077c:	ebfffe19 	bl	8f62ffe8 <fbcon_clear>

	total_x = config->width;
	total_y = config->height;
	bytes_per_bpp = ((config->bpp) / 8);
	image_base = ((((total_y/2) - (SPLASH_IMAGE_HEIGHT / 2) - 1) *
8f630780:	e59a6008 	ldr	r6, [r10, #8]
	total_x = config->width;
8f630784:	e59a0004 	ldr	r0, [r10, #4]
	bytes_per_bpp = ((config->bpp) / 8);
8f630788:	e59a2010 	ldr	r2, [r10, #16]
	image_base = ((((total_y/2) - (SPLASH_IMAGE_HEIGHT / 2) - 1) *
8f63078c:	e1a060a6 	lsr	r6, r6, #1
8f630790:	e246303f 	sub	r3, r6, #63	; 0x3f
			(config->width)) + (total_x/2 - (SPLASH_IMAGE_WIDTH / 2)));
8f630794:	e1a060a0 	lsr	r6, r0, #1
	bytes_per_bpp = ((config->bpp) / 8);
8f630798:	e1a021a2 	lsr	r2, r2, #3
	image_base = ((((total_y/2) - (SPLASH_IMAGE_HEIGHT / 2) - 1) *
8f63079c:	e2466038 	sub	r6, r6, #56	; 0x38
	image = (pm_appsbl_charging_in_progress() ? image_batt888 : imageBuffer_rgb888);
#else
	image = imageBuffer_rgb888;
#endif

	if (bytes_per_bpp == 3) {
8f6307a0:	e3520003 	cmp	r2, #3
	image_base = ((((total_y/2) - (SPLASH_IMAGE_HEIGHT / 2) - 1) *
8f6307a4:	e0266390 	mla	r6, r0, r3, r6
	if (bytes_per_bpp == 3) {
8f6307a8:	0a00001b 	beq	8f63081c <display_default_image_on_screen+0xcc>
			image + (i * SPLASH_IMAGE_WIDTH * bytes_per_bpp),
			SPLASH_IMAGE_WIDTH * bytes_per_bpp);
		}
	}

	if (bytes_per_bpp == 2) {
8f6307ac:	e3520002 	cmp	r2, #2
8f6307b0:	1a000010 	bne	8f6307f8 <display_default_image_on_screen+0xa8>
8f6307b4:	e30343b4 	movw	r4, #13236	; 0x33b4
8f6307b8:	e59f80e0 	ldr	r8, [pc, #224]	; 8f6308a0 <display_default_image_on_screen+0x150>
8f6307bc:	e3484f71 	movt	r4, #36721	; 0x8f71
		for (i = 0; i < SPLASH_IMAGE_HEIGHT; i++) {
8f6307c0:	e3a05000 	mov	r5, #0
8f6307c4:	ea000001 	b	8f6307d0 <display_default_image_on_screen+0x80>
			memcpy (config->base + ((image_base + (i * (config->width))) * bytes_per_bpp),
8f6307c8:	e597a000 	ldr	r10, [r7]
8f6307cc:	e59a0004 	ldr	r0, [r10, #4]
8f6307d0:	e0206590 	mla	r0, r0, r5, r6
8f6307d4:	e59a3000 	ldr	r3, [r10]
8f6307d8:	e1a01004 	mov	r1, r4
8f6307dc:	e3a020e2 	mov	r2, #226	; 0xe2
		for (i = 0; i < SPLASH_IMAGE_HEIGHT; i++) {
8f6307e0:	e0844002 	add	r4, r4, r2
			memcpy (config->base + ((image_base + (i * (config->width))) * bytes_per_bpp),
8f6307e4:	e2855001 	add	r5, r5, #1
8f6307e8:	e0830080 	add	r0, r3, r0, lsl #1
8f6307ec:	eb000e71 	bl	8f6341b8 <memcpy>
		for (i = 0; i < SPLASH_IMAGE_HEIGHT; i++) {
8f6307f0:	e1580004 	cmp	r8, r4
8f6307f4:	1afffff3 	bne	8f6307c8 <display_default_image_on_screen+0x78>
			imageBuffer + (i * SPLASH_IMAGE_WIDTH * bytes_per_bpp),
			SPLASH_IMAGE_WIDTH * bytes_per_bpp);
		}
	}

	fbcon_flush();
8f6307f8:	e59f309c 	ldr	r3, [pc, #156]	; 8f63089c <display_default_image_on_screen+0x14c>
8f6307fc:	e5932000 	ldr	r2, [r3]
8f630800:	e59d3004 	ldr	r3, [r13, #4]
8f630804:	e0332002 	eors	r2, r3, r2
8f630808:	e3a03000 	mov	r3, #0
8f63080c:	1a000021 	bne	8f630898 <display_default_image_on_screen+0x148>

#if DISPLAY_MIPI_PANEL_NOVATEK_BLUE
	if(is_cmd_mode_enabled())
		mipi_dsi_cmd_mode_trigger();
#endif
}
8f630810:	e28dd008 	add	r13, r13, #8
8f630814:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r14}
	fbcon_flush();
8f630818:	eafffcd6 	b	8f62fb78 <fbcon_flush>
8f63081c:	e30a412c 	movw	r4, #41260	; 0xa12c
8f630820:	e59f807c 	ldr	r8, [pc, #124]	; 8f6308a4 <display_default_image_on_screen+0x154>
8f630824:	e3484f71 	movt	r4, #36721	; 0x8f71
		for (i = 0; i < SPLASH_IMAGE_HEIGHT; i++) {
8f630828:	e3a09000 	mov	r9, #0
			memcpy (config->base + ((image_base + (i * (config->width))) * bytes_per_bpp),
8f63082c:	e3005153 	movw	r5, #339	; 0x153
8f630830:	ea000001 	b	8f63083c <display_default_image_on_screen+0xec>
8f630834:	e597a000 	ldr	r10, [r7]
8f630838:	e59a0004 	ldr	r0, [r10, #4]
8f63083c:	e0206990 	mla	r0, r0, r9, r6
8f630840:	e59a3000 	ldr	r3, [r10]
8f630844:	e1a01004 	mov	r1, r4
8f630848:	e3002153 	movw	r2, #339	; 0x153
		for (i = 0; i < SPLASH_IMAGE_HEIGHT; i++) {
8f63084c:	e0844005 	add	r4, r4, r5
			memcpy (config->base + ((image_base + (i * (config->width))) * bytes_per_bpp),
8f630850:	e2899001 	add	r9, r9, #1
8f630854:	e0800080 	add	r0, r0, r0, lsl #1
8f630858:	e0830000 	add	r0, r3, r0
8f63085c:	eb000e55 	bl	8f6341b8 <memcpy>
		for (i = 0; i < SPLASH_IMAGE_HEIGHT; i++) {
8f630860:	e1580004 	cmp	r8, r4
8f630864:	1afffff2 	bne	8f630834 <display_default_image_on_screen+0xe4>
8f630868:	eaffffe2 	b	8f6307f8 <display_default_image_on_screen+0xa8>
		dprintf(CRITICAL,"NULL configuration, image cannot be displayed\n");
8f63086c:	e59f3028 	ldr	r3, [pc, #40]	; 8f63089c <display_default_image_on_screen+0x14c>
8f630870:	e5932000 	ldr	r2, [r3]
8f630874:	e59d3004 	ldr	r3, [r13, #4]
8f630878:	e0332002 	eors	r2, r3, r2
8f63087c:	e3a03000 	mov	r3, #0
8f630880:	1a000004 	bne	8f630898 <display_default_image_on_screen+0x148>
8f630884:	e30a0fd8 	movw	r0, #45016	; 0xafd8
8f630888:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f63088c:	e28dd008 	add	r13, r13, #8
8f630890:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r14}
		dprintf(CRITICAL,"NULL configuration, image cannot be displayed\n");
8f630894:	ea000836 	b	8f632974 <_dprintf>
	fbcon_flush();
8f630898:	eb0008c8 	bl	8f632bc0 <__stack_chk_fail>
8f63089c:	8f74221c 	.word	0x8f74221c
8f6308a0:	8f71a12c 	.word	0x8f71a12c
8f6308a4:	8f724560 	.word	0x8f724560

8f6308a8 <fbcon_setup>:
{
8f6308a8:	e92d4070 	push	{r4, r5, r6, r14}
	ASSERT(_config);
8f6308ac:	e2504000 	subs	r4, r0, #0
{
8f6308b0:	e59f3190 	ldr	r3, [pc, #400]	; 8f630a48 <fbcon_setup+0x1a0>
8f6308b4:	e24dd010 	sub	r13, r13, #16
8f6308b8:	e1a0600e 	mov	r6, r14
8f6308bc:	e5933000 	ldr	r3, [r3]
8f6308c0:	e58d300c 	str	r3, [r13, #12]
8f6308c4:	e3a03000 	mov	r3, #0
	ASSERT(_config);
8f6308c8:	0a000052 	beq	8f630a18 <fbcon_setup+0x170>
	switch (config->format) {
8f6308cc:	e5943014 	ldr	r3, [r4, #20]
	config = _config;
8f6308d0:	e3025188 	movw	r5, #8584	; 0x2188
8f6308d4:	e3485f74 	movt	r5, #36724	; 0x8f74
	switch (config->format) {
8f6308d8:	e3530000 	cmp	r3, #0
	config = _config;
8f6308dc:	e5854000 	str	r4, [r5]
	switch (config->format) {
8f6308e0:	0a00003e 	beq	8f6309e0 <fbcon_setup+0x138>
8f6308e4:	e3530003 	cmp	r3, #3
8f6308e8:	0a000043 	beq	8f6309fc <fbcon_setup+0x154>
		dprintf(CRITICAL, "unknown framebuffer pixel format\n");
8f6308ec:	e30b0024 	movw	r0, #45092	; 0xb024
8f6308f0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6308f4:	eb00081e 	bl	8f632974 <_dprintf>
		ASSERT(0);
8f6308f8:	e3a03f6f 	mov	r3, #444	; 0x1bc
8f6308fc:	e3071f64 	movw	r1, #32612	; 0x7f64
8f630900:	e30b2008 	movw	r2, #45064	; 0xb008
8f630904:	e3481f70 	movt	r1, #36720	; 0x8f70
8f630908:	e3482f70 	movt	r2, #36720	; 0x8f70
8f63090c:	e58d1000 	str	r1, [r13]
8f630910:	e1a00006 	mov	r0, r6
8f630914:	e3001130 	movw	r1, #304	; 0x130
8f630918:	e3481f70 	movt	r1, #36720	; 0x8f70
8f63091c:	eb000866 	bl	8f632abc <_panic>
	SELECT_BGCOLOR = fb_color_formats[FBCON_SELECT_MSG_BG_COLOR].bg;
8f630920:	e3023194 	movw	r3, #8596	; 0x2194
8f630924:	e3483f74 	movt	r3, #36724	; 0x8f74
	max_pos.x = config->width / (FONT_WIDTH+1);
8f630928:	e5954000 	ldr	r4, [r5]
	SELECT_BGCOLOR = fb_color_formats[FBCON_SELECT_MSG_BG_COLOR].bg;
8f63092c:	e5933000 	ldr	r3, [r3]
8f630930:	e5932044 	ldr	r2, [r3, #68]	; 0x44
	max_pos.x = config->width / (FONT_WIDTH+1);
8f630934:	e30acaab 	movw	r12, #43691	; 0xaaab
	BGCOLOR = fb_color_formats[type].bg;
8f630938:	e593e004 	ldr	r14, [r3, #4]
	SELECT_BGCOLOR = fb_color_formats[FBCON_SELECT_MSG_BG_COLOR].bg;
8f63093c:	e3023184 	movw	r3, #8580	; 0x2184
8f630940:	e3483f74 	movt	r3, #36724	; 0x8f74
	max_pos.x = config->width / (FONT_WIDTH+1);
8f630944:	e34acaaa 	movt	r12, #43690	; 0xaaaa
	BGCOLOR = fb_color_formats[type].bg;
8f630948:	e3020180 	movw	r0, #8576	; 0x2180
8f63094c:	e3480f74 	movt	r0, #36724	; 0x8f74
	SELECT_BGCOLOR = fb_color_formats[FBCON_SELECT_MSG_BG_COLOR].bg;
8f630950:	e5832000 	str	r2, [r3]
	cur_pos.x = 0;
8f630954:	e302118c 	movw	r1, #8588	; 0x218c
	max_pos.y = (config->height - 1) / FONT_HEIGHT;
8f630958:	e1c420d4 	ldrd	r2, [r4, #4]
	cur_pos.x = 0;
8f63095c:	e3481f74 	movt	r1, #36724	; 0x8f74
	BGCOLOR = fb_color_formats[type].bg;
8f630960:	e580e000 	str	r14, [r0]
	max_pos.x = config->width / (FONT_WIDTH+1);
8f630964:	e3020198 	movw	r0, #8600	; 0x2198
	max_pos.y = (config->height - 1) / FONT_HEIGHT;
8f630968:	e2433001 	sub	r3, r3, #1
	max_pos.x = config->width / (FONT_WIDTH+1);
8f63096c:	e3480f74 	movt	r0, #36724	; 0x8f74
8f630970:	e082429c 	umull	r4, r2, r12, r2
	max_pos.y = (config->height - 1) / FONT_HEIGHT;
8f630974:	e083c39c 	umull	r12, r3, r12, r3
	max_pos.x = config->width / (FONT_WIDTH+1);
8f630978:	e1a02122 	lsr	r2, r2, #2
	max_pos.y = (config->height - 1) / FONT_HEIGHT;
8f63097c:	e1a031a3 	lsr	r3, r3, #3
8f630980:	e1c020f0 	strd	r2, [r0]
	cur_pos.x = 0;
8f630984:	e3a03000 	mov	r3, #0
8f630988:	e5813000 	str	r3, [r1]
	cur_pos.y = 0;
8f63098c:	e5813004 	str	r3, [r1, #4]
void display_image_on_screen(void)
{
#if DISPLAY_TYPE_MIPI
	int fetch_image_from_partition();

	if (fetch_image_from_partition() < 0) {
8f630990:	ebffea63 	bl	8f62b324 <fetch_image_from_partition>
		display_default_image_on_screen();
8f630994:	e59f30ac 	ldr	r3, [pc, #172]	; 8f630a48 <fbcon_setup+0x1a0>
	if (fetch_image_from_partition() < 0) {
8f630998:	e3500000 	cmp	r0, #0
8f63099c:	ba000007 	blt	8f6309c0 <fbcon_setup+0x118>
	} else {
		/* data has been put into the right place */
		fbcon_flush();
8f6309a0:	e5932000 	ldr	r2, [r3]
8f6309a4:	e59d300c 	ldr	r3, [r13, #12]
8f6309a8:	e0332002 	eors	r2, r3, r2
8f6309ac:	e3a03000 	mov	r3, #0
8f6309b0:	1a000023 	bne	8f630a44 <fbcon_setup+0x19c>
}
8f6309b4:	e28dd010 	add	r13, r13, #16
8f6309b8:	e8bd4070 	pop	{r4, r5, r6, r14}
		fbcon_flush();
8f6309bc:	eafffc6d 	b	8f62fb78 <fbcon_flush>
		display_default_image_on_screen();
8f6309c0:	e5932000 	ldr	r2, [r3]
8f6309c4:	e59d300c 	ldr	r3, [r13, #12]
8f6309c8:	e0332002 	eors	r2, r3, r2
8f6309cc:	e3a03000 	mov	r3, #0
8f6309d0:	1a00001b 	bne	8f630a44 <fbcon_setup+0x19c>
}
8f6309d4:	e28dd010 	add	r13, r13, #16
8f6309d8:	e8bd4070 	pop	{r4, r5, r6, r14}
		display_default_image_on_screen();
8f6309dc:	eaffff5b 	b	8f630750 <display_default_image_on_screen>
		fb_color_formats = fb_color_formats_555;
8f6309e0:	e3021194 	movw	r1, #8596	; 0x2194
8f6309e4:	e3032024 	movw	r2, #12324	; 0x3024
8f6309e8:	e3481f74 	movt	r1, #36724	; 0x8f74
8f6309ec:	e3482f71 	movt	r2, #36721	; 0x8f71
		break;
8f6309f0:	e1a03002 	mov	r3, r2
		fb_color_formats = fb_color_formats_555;
8f6309f4:	e5812000 	str	r2, [r1]
		break;
8f6309f8:	eaffffcc 	b	8f630930 <fbcon_setup+0x88>
		fb_color_formats = fb_color_formats_888;
8f6309fc:	e3021194 	movw	r1, #8596	; 0x2194
8f630a00:	e303206c 	movw	r2, #12396	; 0x306c
8f630a04:	e3481f74 	movt	r1, #36724	; 0x8f74
8f630a08:	e3482f71 	movt	r2, #36721	; 0x8f71
                break;
8f630a0c:	e1a03002 	mov	r3, r2
		fb_color_formats = fb_color_formats_888;
8f630a10:	e5812000 	str	r2, [r1]
                break;
8f630a14:	eaffffc5 	b	8f630930 <fbcon_setup+0x88>
	ASSERT(_config);
8f630a18:	e30b001c 	movw	r0, #45084	; 0xb01c
8f630a1c:	e30b2008 	movw	r2, #45064	; 0xb008
8f630a20:	e3480f70 	movt	r0, #36720	; 0x8f70
8f630a24:	e3482f70 	movt	r2, #36720	; 0x8f70
8f630a28:	e58d0000 	str	r0, [r13]
8f630a2c:	e3001130 	movw	r1, #304	; 0x130
8f630a30:	e30031af 	movw	r3, #431	; 0x1af
8f630a34:	e3481f70 	movt	r1, #36720	; 0x8f70
8f630a38:	e1a0000e 	mov	r0, r14
8f630a3c:	eb00081e 	bl	8f632abc <_panic>
8f630a40:	eaffffa1 	b	8f6308cc <fbcon_setup+0x24>
		fbcon_flush();
8f630a44:	eb00085d 	bl	8f632bc0 <__stack_chk_fail>
8f630a48:	8f74221c 	.word	0x8f74221c

8f630a4c <display_image_on_screen>:
{
8f630a4c:	e59f3064 	ldr	r3, [pc, #100]	; 8f630ab8 <display_image_on_screen+0x6c>
8f630a50:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f630a54:	e24dd00c 	sub	r13, r13, #12
8f630a58:	e5933000 	ldr	r3, [r3]
8f630a5c:	e58d3004 	str	r3, [r13, #4]
8f630a60:	e3a03000 	mov	r3, #0
	if (fetch_image_from_partition() < 0) {
8f630a64:	ebffea2e 	bl	8f62b324 <fetch_image_from_partition>
		display_default_image_on_screen();
8f630a68:	e59f3048 	ldr	r3, [pc, #72]	; 8f630ab8 <display_image_on_screen+0x6c>
	if (fetch_image_from_partition() < 0) {
8f630a6c:	e3500000 	cmp	r0, #0
8f630a70:	ba000007 	blt	8f630a94 <display_image_on_screen+0x48>
		fbcon_flush();
8f630a74:	e5932000 	ldr	r2, [r3]
8f630a78:	e59d3004 	ldr	r3, [r13, #4]
8f630a7c:	e0332002 	eors	r2, r3, r2
8f630a80:	e3a03000 	mov	r3, #0
8f630a84:	1a00000a 	bne	8f630ab4 <display_image_on_screen+0x68>
	}
#else
	display_default_image_on_screen();
#endif
}
8f630a88:	e28dd00c 	add	r13, r13, #12
8f630a8c:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		fbcon_flush();
8f630a90:	eafffc38 	b	8f62fb78 <fbcon_flush>
		display_default_image_on_screen();
8f630a94:	e5932000 	ldr	r2, [r3]
8f630a98:	e59d3004 	ldr	r3, [r13, #4]
8f630a9c:	e0332002 	eors	r2, r3, r2
8f630aa0:	e3a03000 	mov	r3, #0
8f630aa4:	1a000002 	bne	8f630ab4 <display_image_on_screen+0x68>
}
8f630aa8:	e28dd00c 	add	r13, r13, #12
8f630aac:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		display_default_image_on_screen();
8f630ab0:	eaffff26 	b	8f630750 <display_default_image_on_screen>
		fbcon_flush();
8f630ab4:	eb000841 	bl	8f632bc0 <__stack_chk_fail>
8f630ab8:	8f74221c 	.word	0x8f74221c

8f630abc <keys_init>:
#include <dev/keys.h>

static unsigned long key_bitmap[BITMAP_NUM_WORDS(MAX_KEYS)];

void keys_init(void)
{
8f630abc:	e59f3048 	ldr	r3, [pc, #72]	; 8f630b0c <keys_init+0x50>
8f630ac0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f630ac4:	e24dd00c 	sub	r13, r13, #12
8f630ac8:	e5933000 	ldr	r3, [r3]
8f630acc:	e58d3004 	str	r3, [r13, #4]
8f630ad0:	e3a03000 	mov	r3, #0
	memset(key_bitmap, 0, sizeof(key_bitmap));
8f630ad4:	e59f3030 	ldr	r3, [pc, #48]	; 8f630b0c <keys_init+0x50>
8f630ad8:	e5932000 	ldr	r2, [r3]
8f630adc:	e59d3004 	ldr	r3, [r13, #4]
8f630ae0:	e0332002 	eors	r2, r3, r2
8f630ae4:	e3a03000 	mov	r3, #0
8f630ae8:	1a000006 	bne	8f630b08 <keys_init+0x4c>
8f630aec:	e30201a0 	movw	r0, #8608	; 0x21a0
8f630af0:	e3a02040 	mov	r2, #64	; 0x40
8f630af4:	e3480f74 	movt	r0, #36724	; 0x8f74
8f630af8:	e3a01000 	mov	r1, #0
}
8f630afc:	e28dd00c 	add	r13, r13, #12
8f630b00:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	memset(key_bitmap, 0, sizeof(key_bitmap));
8f630b04:	ea000dee 	b	8f6342c4 <memset>
8f630b08:	eb00082c 	bl	8f632bc0 <__stack_chk_fail>
8f630b0c:	8f74221c 	.word	0x8f74221c

8f630b10 <keys_post_event>:

void keys_post_event(uint16_t code, int16_t value)
{
	if (code >= MAX_KEYS) {
8f630b10:	e30021fe 	movw	r2, #510	; 0x1fe
8f630b14:	e1500002 	cmp	r0, r2
{
8f630b18:	e59f20cc 	ldr	r2, [pc, #204]	; 8f630bec <keys_post_event+0xdc>
8f630b1c:	e1a03000 	mov	r3, r0
8f630b20:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f630b24:	e24dd00c 	sub	r13, r13, #12
8f630b28:	e5922000 	ldr	r2, [r2]
8f630b2c:	e58d2004 	str	r2, [r13, #4]
8f630b30:	e3a02000 	mov	r2, #0
		dprintf(INFO, "Invalid keycode posted: %d\n", code);
8f630b34:	e59f20b0 	ldr	r2, [pc, #176]	; 8f630bec <keys_post_event+0xdc>
	if (code >= MAX_KEYS) {
8f630b38:	8a00001f 	bhi	8f630bbc <keys_post_event+0xac>
		return;
	}

	/* TODO: Implement an actual event queue if it becomes necessary */
	if (value)
8f630b3c:	e3510000 	cmp	r1, #0
8f630b40:	0a00000e 	beq	8f630b80 <keys_post_event+0x70>
#define BITMAP_BIT_IN_WORD(x) ((x) & (BITMAP_BITS_PER_WORD - 1))

static inline int bitmap_set(unsigned long *bitmap, int bit)
{
	unsigned long mask = 1 << BITMAP_BIT_IN_WORD(bit);
	return atomic_or((int*)&bitmap[BITMAP_WORD(bit)], mask) & mask ? 1 : 0;
8f630b44:	e5921000 	ldr	r1, [r2]
8f630b48:	e59d2004 	ldr	r2, [r13, #4]
8f630b4c:	e0321001 	eors	r1, r2, r1
8f630b50:	e3a02000 	mov	r2, #0
8f630b54:	1a000023 	bne	8f630be8 <keys_post_event+0xd8>
8f630b58:	e1a002a0 	lsr	r0, r0, #5
	unsigned long mask = 1 << BITMAP_BIT_IN_WORD(bit);
8f630b5c:	e203301f 	and	r3, r3, #31
8f630b60:	e3a01001 	mov	r1, #1
	return atomic_or((int*)&bitmap[BITMAP_WORD(bit)], mask) & mask ? 1 : 0;
8f630b64:	e30221a0 	movw	r2, #8608	; 0x21a0
8f630b68:	e3482f74 	movt	r2, #36724	; 0x8f74
8f630b6c:	e1a01311 	lsl	r1, r1, r3
8f630b70:	e0820100 	add	r0, r2, r0, lsl #2
		bitmap_set(key_bitmap, code);
	else
		bitmap_clear(key_bitmap, code);

//	dprintf(INFO, "key state change: %d %d\n", code, value);
}
8f630b74:	e28dd00c 	add	r13, r13, #12
8f630b78:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
8f630b7c:	eaffc143 	b	8f621090 <atomic_or>

static inline int bitmap_clear(unsigned long *bitmap, int bit)
{
	unsigned long mask = 1 << BITMAP_BIT_IN_WORD(bit);

	return atomic_and((int*)&bitmap[BITMAP_WORD(bit)], ~mask) & mask ? 1:0;
8f630b80:	e5921000 	ldr	r1, [r2]
8f630b84:	e59d2004 	ldr	r2, [r13, #4]
8f630b88:	e0321001 	eors	r1, r2, r1
8f630b8c:	e3a02000 	mov	r2, #0
8f630b90:	1a000014 	bne	8f630be8 <keys_post_event+0xd8>
	unsigned long mask = 1 << BITMAP_BIT_IN_WORD(bit);
8f630b94:	e200201f 	and	r2, r0, #31
	return atomic_and((int*)&bitmap[BITMAP_WORD(bit)], ~mask) & mask ? 1:0;
8f630b98:	e1a032a0 	lsr	r3, r0, #5
	unsigned long mask = 1 << BITMAP_BIT_IN_WORD(bit);
8f630b9c:	e3a01001 	mov	r1, #1
	return atomic_and((int*)&bitmap[BITMAP_WORD(bit)], ~mask) & mask ? 1:0;
8f630ba0:	e30201a0 	movw	r0, #8608	; 0x21a0
8f630ba4:	e3480f74 	movt	r0, #36724	; 0x8f74
8f630ba8:	e1e01211 	mvn	r1, r1, lsl r2
8f630bac:	e0800103 	add	r0, r0, r3, lsl #2
8f630bb0:	e28dd00c 	add	r13, r13, #12
8f630bb4:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
8f630bb8:	eaffc12d 	b	8f621074 <atomic_and>
		dprintf(INFO, "Invalid keycode posted: %d\n", code);
8f630bbc:	e5921000 	ldr	r1, [r2]
8f630bc0:	e59d2004 	ldr	r2, [r13, #4]
8f630bc4:	e0321001 	eors	r1, r2, r1
8f630bc8:	e3a02000 	mov	r2, #0
8f630bcc:	1a000005 	bne	8f630be8 <keys_post_event+0xd8>
8f630bd0:	e30b0048 	movw	r0, #45128	; 0xb048
8f630bd4:	e1a01003 	mov	r1, r3
8f630bd8:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f630bdc:	e28dd00c 	add	r13, r13, #12
8f630be0:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		dprintf(INFO, "Invalid keycode posted: %d\n", code);
8f630be4:	ea000762 	b	8f632974 <_dprintf>
8f630be8:	eb0007f4 	bl	8f632bc0 <__stack_chk_fail>
8f630bec:	8f74221c 	.word	0x8f74221c

8f630bf0 <keys_get_state>:

int keys_get_state(uint16_t code)
{
	if (code >= MAX_KEYS) {
8f630bf0:	e30031fe 	movw	r3, #510	; 0x1fe
8f630bf4:	e1500003 	cmp	r0, r3
{
8f630bf8:	e59f3074 	ldr	r3, [pc, #116]	; 8f630c74 <keys_get_state+0x84>
8f630bfc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f630c00:	e24dd00c 	sub	r13, r13, #12
8f630c04:	e5933000 	ldr	r3, [r3]
8f630c08:	e58d3004 	str	r3, [r13, #4]
8f630c0c:	e3a03000 	mov	r3, #0
	if (code >= MAX_KEYS) {
8f630c10:	8a000010 	bhi	8f630c58 <keys_get_state+0x68>
}

static inline int bitmap_test(unsigned long *bitmap, int bit)
{
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
8f630c14:	e1a012a0 	lsr	r1, r0, #5
8f630c18:	e30231a0 	movw	r3, #8608	; 0x21a0
8f630c1c:	e3483f74 	movt	r3, #36724	; 0x8f74
8f630c20:	e200001f 	and	r0, r0, #31
8f630c24:	e3a02001 	mov	r2, #1
8f630c28:	e7933101 	ldr	r3, [r3, r1, lsl #2]
8f630c2c:	e0133012 	ands	r3, r3, r2, lsl r0
8f630c30:	11a00002 	movne	r0, r2
8f630c34:	03a00000 	moveq	r0, #0
		dprintf(INFO, "Invalid keycode requested: %d\n", code);
		return -1;
	}
	return bitmap_test(key_bitmap, code);
}
8f630c38:	e59f3034 	ldr	r3, [pc, #52]	; 8f630c74 <keys_get_state+0x84>
8f630c3c:	e5932000 	ldr	r2, [r3]
8f630c40:	e59d3004 	ldr	r3, [r13, #4]
8f630c44:	e0332002 	eors	r2, r3, r2
8f630c48:	e3a03000 	mov	r3, #0
8f630c4c:	1a000007 	bne	8f630c70 <keys_get_state+0x80>
8f630c50:	e28dd00c 	add	r13, r13, #12
8f630c54:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		dprintf(INFO, "Invalid keycode requested: %d\n", code);
8f630c58:	e1a01000 	mov	r1, r0
8f630c5c:	e30b0064 	movw	r0, #45156	; 0xb064
8f630c60:	e3480f70 	movt	r0, #36720	; 0x8f70
8f630c64:	eb000742 	bl	8f632974 <_dprintf>
		return -1;
8f630c68:	e3e00000 	mvn	r0, #0
8f630c6c:	eafffff1 	b	8f630c38 <keys_get_state+0x48>
}
8f630c70:	eb0007d2 	bl	8f632bc0 <__stack_chk_fail>
8f630c74:	8f74221c 	.word	0x8f74221c

8f630c78 <pm8x41_reg_read>:
{
	mpp_slave_id = slave_id;
}
/* SPMI helper functions */
uint8_t pm8x41_reg_read(uint32_t addr)
{
8f630c78:	e92d4010 	push	{r4, r14}
8f630c7c:	e24dd018 	sub	r13, r13, #24
8f630c80:	e1a03000 	mov	r3, r0
	cmd.priority = 0;

	param.buffer = &val;
	param.size   = 1;

	pmic_arb_read_cmd(&cmd, &param);
8f630c84:	e28d100c 	add	r1, r13, #12
	cmd.address  = PERIPH_ID(addr);
8f630c88:	e1a0c423 	lsr	r12, r3, #8
8f630c8c:	e5cdc007 	strb	r12, [r13, #7]
{
8f630c90:	e59fc060 	ldr	r12, [pc, #96]	; 8f630cf8 <pm8x41_reg_read+0x80>
	pmic_arb_read_cmd(&cmd, &param);
8f630c94:	e28d0004 	add	r0, r13, #4
	uint8_t val = 0;
8f630c98:	e3a02000 	mov	r2, #0
	cmd.slave_id = SLAVE_ID(addr);
8f630c9c:	e1a0e823 	lsr	r14, r3, #16
{
8f630ca0:	e59cc000 	ldr	r12, [r12]
8f630ca4:	e58dc014 	str	r12, [r13, #20]
8f630ca8:	e3a0c000 	mov	r12, #0
	param.buffer = &val;
8f630cac:	e28dc003 	add	r12, r13, #3
	uint8_t val = 0;
8f630cb0:	e5cd2003 	strb	r2, [r13, #3]
	cmd.offset   = REG_OFFSET(addr);
8f630cb4:	e5cd3008 	strb	r3, [r13, #8]
	param.size   = 1;
8f630cb8:	e3a03001 	mov	r3, #1
	cmd.priority = 0;
8f630cbc:	e5cd2005 	strb	r2, [r13, #5]
	param.size   = 1;
8f630cc0:	e5cd3010 	strb	r3, [r13, #16]
	cmd.slave_id = SLAVE_ID(addr);
8f630cc4:	e5cde006 	strb	r14, [r13, #6]
	param.buffer = &val;
8f630cc8:	e58dc00c 	str	r12, [r13, #12]
	pmic_arb_read_cmd(&cmd, &param);
8f630ccc:	ebff805f 	bl	8f610e50 <pmic_arb_read_cmd>

	return val;
}
8f630cd0:	e59f3020 	ldr	r3, [pc, #32]	; 8f630cf8 <pm8x41_reg_read+0x80>
	return val;
8f630cd4:	e5dd0003 	ldrb	r0, [r13, #3]
}
8f630cd8:	e5932000 	ldr	r2, [r3]
8f630cdc:	e59d3014 	ldr	r3, [r13, #20]
8f630ce0:	e0332002 	eors	r2, r3, r2
8f630ce4:	e3a03000 	mov	r3, #0
8f630ce8:	1a000001 	bne	8f630cf4 <pm8x41_reg_read+0x7c>
8f630cec:	e28dd018 	add	r13, r13, #24
8f630cf0:	e8bd8010 	pop	{r4, r15}
8f630cf4:	eb0007b1 	bl	8f632bc0 <__stack_chk_fail>
8f630cf8:	8f74221c 	.word	0x8f74221c

8f630cfc <spmi_reg_read>:

uint32_t spmi_reg_read(uint32_t slave_id, uint16_t addr, uint8_t *data, uint8_t priority)
{
8f630cfc:	e92d4010 	push	{r4, r14}
8f630d00:	e24dd018 	sub	r13, r13, #24
8f630d04:	e59fe05c 	ldr	r14, [pc, #92]	; 8f630d68 <spmi_reg_read+0x6c>
8f630d08:	e1a0c001 	mov	r12, r1
	struct pmic_arb_cmd cmd;
	struct pmic_arb_param param;

	cmd.address = PERIPH_ID(addr);
8f630d0c:	e1a01421 	lsr	r1, r1, #8
{
8f630d10:	e59ee000 	ldr	r14, [r14]
8f630d14:	e58de014 	str	r14, [r13, #20]
8f630d18:	e3a0e000 	mov	r14, #0
	cmd.address = PERIPH_ID(addr);
8f630d1c:	e5cd1007 	strb	r1, [r13, #7]
	cmd.offset = REG_OFFSET(addr);
	cmd.slave_id = slave_id;
8f630d20:	e5cd0006 	strb	r0, [r13, #6]
	cmd.priority = priority;

	param.buffer = data;
	param.size   = 1;

	return pmic_arb_read_cmd(&cmd, &param);
8f630d24:	e28d100c 	add	r1, r13, #12
8f630d28:	e28d0004 	add	r0, r13, #4
	param.size   = 1;
8f630d2c:	e3a0e001 	mov	r14, #1
	cmd.priority = priority;
8f630d30:	e5cd3005 	strb	r3, [r13, #5]
	param.buffer = data;
8f630d34:	e58d200c 	str	r2, [r13, #12]
	param.size   = 1;
8f630d38:	e5cde010 	strb	r14, [r13, #16]
	cmd.offset = REG_OFFSET(addr);
8f630d3c:	e5cdc008 	strb	r12, [r13, #8]
	return pmic_arb_read_cmd(&cmd, &param);
8f630d40:	ebff8042 	bl	8f610e50 <pmic_arb_read_cmd>
}
8f630d44:	e59f301c 	ldr	r3, [pc, #28]	; 8f630d68 <spmi_reg_read+0x6c>
8f630d48:	e5932000 	ldr	r2, [r3]
8f630d4c:	e59d3014 	ldr	r3, [r13, #20]
8f630d50:	e0332002 	eors	r2, r3, r2
8f630d54:	e3a03000 	mov	r3, #0
8f630d58:	1a000001 	bne	8f630d64 <spmi_reg_read+0x68>
8f630d5c:	e28dd018 	add	r13, r13, #24
8f630d60:	e8bd8010 	pop	{r4, r15}
8f630d64:	eb000795 	bl	8f632bc0 <__stack_chk_fail>
8f630d68:	8f74221c 	.word	0x8f74221c

8f630d6c <spmi_reg_write>:

uint32_t spmi_reg_write(uint32_t slave_id, uint16_t addr, uint8_t *data, uint8_t priority)
{
8f630d6c:	e92d4010 	push	{r4, r14}
8f630d70:	e24dd018 	sub	r13, r13, #24
8f630d74:	e59fe05c 	ldr	r14, [pc, #92]	; 8f630dd8 <spmi_reg_write+0x6c>
8f630d78:	e1a0c001 	mov	r12, r1
	struct pmic_arb_cmd cmd;
	struct pmic_arb_param param;

	cmd.address = PERIPH_ID(addr);
8f630d7c:	e1a01421 	lsr	r1, r1, #8
{
8f630d80:	e59ee000 	ldr	r14, [r14]
8f630d84:	e58de014 	str	r14, [r13, #20]
8f630d88:	e3a0e000 	mov	r14, #0
	cmd.address = PERIPH_ID(addr);
8f630d8c:	e5cd1007 	strb	r1, [r13, #7]
	cmd.offset = REG_OFFSET(addr);
	cmd.slave_id = slave_id;
8f630d90:	e5cd0006 	strb	r0, [r13, #6]
	cmd.priority = priority;

	param.buffer = data;
	param.size   = 1;

	return pmic_arb_write_cmd(&cmd, &param);
8f630d94:	e28d100c 	add	r1, r13, #12
8f630d98:	e28d0004 	add	r0, r13, #4
	param.size   = 1;
8f630d9c:	e3a0e001 	mov	r14, #1
	cmd.priority = priority;
8f630da0:	e5cd3005 	strb	r3, [r13, #5]
	param.buffer = data;
8f630da4:	e58d200c 	str	r2, [r13, #12]
	param.size   = 1;
8f630da8:	e5cde010 	strb	r14, [r13, #16]
	cmd.offset = REG_OFFSET(addr);
8f630dac:	e5cdc008 	strb	r12, [r13, #8]
	return pmic_arb_write_cmd(&cmd, &param);
8f630db0:	ebff7fc6 	bl	8f610cd0 <pmic_arb_write_cmd>
}
8f630db4:	e59f301c 	ldr	r3, [pc, #28]	; 8f630dd8 <spmi_reg_write+0x6c>
8f630db8:	e5932000 	ldr	r2, [r3]
8f630dbc:	e59d3014 	ldr	r3, [r13, #20]
8f630dc0:	e0332002 	eors	r2, r3, r2
8f630dc4:	e3a03000 	mov	r3, #0
8f630dc8:	1a000001 	bne	8f630dd4 <spmi_reg_write+0x68>
8f630dcc:	e28dd018 	add	r13, r13, #24
8f630dd0:	e8bd8010 	pop	{r4, r15}
8f630dd4:	eb000779 	bl	8f632bc0 <__stack_chk_fail>
8f630dd8:	8f74221c 	.word	0x8f74221c

8f630ddc <pm8x41_reg_write>:

	pmic_arb_write_cmd(&cmd, &param);
}

void pm8x41_reg_write(uint32_t addr, uint8_t val)
{
8f630ddc:	e92d4010 	push	{r4, r14}
8f630de0:	e24dd020 	sub	r13, r13, #32
8f630de4:	e1a0c001 	mov	r12, r1
8f630de8:	e1a03000 	mov	r3, r0
8f630dec:	e5cdc007 	strb	r12, [r13, #7]
	cmd.priority = 0;

	param.buffer = &val;
	param.size   = 1;

	pmic_arb_write_cmd(&cmd, &param);
8f630df0:	e28d1014 	add	r1, r13, #20
{
8f630df4:	e59fc060 	ldr	r12, [pc, #96]	; 8f630e5c <pm8x41_reg_write+0x80>
	pmic_arb_write_cmd(&cmd, &param);
8f630df8:	e28d000c 	add	r0, r13, #12
	cmd.address  = PERIPH_ID(addr);
8f630dfc:	e1a02423 	lsr	r2, r3, #8
	cmd.slave_id = SLAVE_ID(addr);
8f630e00:	e1a0e823 	lsr	r14, r3, #16
{
8f630e04:	e59cc000 	ldr	r12, [r12]
8f630e08:	e58dc01c 	str	r12, [r13, #28]
8f630e0c:	e3a0c000 	mov	r12, #0
	cmd.priority = 0;
8f630e10:	e3a0c000 	mov	r12, #0
	cmd.address  = PERIPH_ID(addr);
8f630e14:	e5cd200f 	strb	r2, [r13, #15]
	param.buffer = &val;
8f630e18:	e28d2007 	add	r2, r13, #7
	cmd.offset   = REG_OFFSET(addr);
8f630e1c:	e5cd3010 	strb	r3, [r13, #16]
	param.size   = 1;
8f630e20:	e3a03001 	mov	r3, #1
	param.buffer = &val;
8f630e24:	e58d2014 	str	r2, [r13, #20]
	param.size   = 1;
8f630e28:	e5cd3018 	strb	r3, [r13, #24]
	cmd.slave_id = SLAVE_ID(addr);
8f630e2c:	e5cde00e 	strb	r14, [r13, #14]
	cmd.priority = 0;
8f630e30:	e5cdc00d 	strb	r12, [r13, #13]
	pmic_arb_write_cmd(&cmd, &param);
8f630e34:	ebff7fa5 	bl	8f610cd0 <pmic_arb_write_cmd>
}
8f630e38:	e59f301c 	ldr	r3, [pc, #28]	; 8f630e5c <pm8x41_reg_write+0x80>
8f630e3c:	e5932000 	ldr	r2, [r3]
8f630e40:	e59d301c 	ldr	r3, [r13, #28]
8f630e44:	e0332002 	eors	r2, r3, r2
8f630e48:	e3a03000 	mov	r3, #0
8f630e4c:	1a000001 	bne	8f630e58 <pm8x41_reg_write+0x7c>
8f630e50:	e28dd020 	add	r13, r13, #32
8f630e54:	e8bd8010 	pop	{r4, r15}
8f630e58:	eb000758 	bl	8f632bc0 <__stack_chk_fail>
8f630e5c:	8f74221c 	.word	0x8f74221c

8f630e60 <pm8x41_resin_status>:
	return (rt_sts & BIT(RESIN_BARK_INT_BIT));
}

/* Resin pin status */
uint32_t pm8x41_resin_status()
{
8f630e60:	e92d4010 	push	{r4, r14}
8f630e64:	e24dd018 	sub	r13, r13, #24
8f630e68:	e59fe070 	ldr	r14, [pc, #112]	; 8f630ee0 <pm8x41_resin_status+0x80>
	pmic_arb_read_cmd(&cmd, &param);
8f630e6c:	e28d100c 	add	r1, r13, #12
8f630e70:	e28d0004 	add	r0, r13, #4
	uint8_t val = 0;
8f630e74:	e3a03000 	mov	r3, #0
{
8f630e78:	e59ee000 	ldr	r14, [r14]
8f630e7c:	e58de014 	str	r14, [r13, #20]
8f630e80:	e3a0e000 	mov	r14, #0
	param.buffer = &val;
8f630e84:	e28dc003 	add	r12, r13, #3
	cmd.address  = PERIPH_ID(addr);
8f630e88:	e3a02008 	mov	r2, #8
	uint8_t val = 0;
8f630e8c:	e5cd3003 	strb	r3, [r13, #3]
	cmd.address  = PERIPH_ID(addr);
8f630e90:	e5cd2007 	strb	r2, [r13, #7]
	cmd.offset   = REG_OFFSET(addr);
8f630e94:	e3a02010 	mov	r2, #16
	cmd.slave_id = SLAVE_ID(addr);
8f630e98:	e5cd3006 	strb	r3, [r13, #6]
	cmd.offset   = REG_OFFSET(addr);
8f630e9c:	e5cd2008 	strb	r2, [r13, #8]
	param.size   = 1;
8f630ea0:	e3a02001 	mov	r2, #1
	cmd.priority = 0;
8f630ea4:	e5cd3005 	strb	r3, [r13, #5]
	param.size   = 1;
8f630ea8:	e5cd2010 	strb	r2, [r13, #16]
	param.buffer = &val;
8f630eac:	e58dc00c 	str	r12, [r13, #12]
	pmic_arb_read_cmd(&cmd, &param);
8f630eb0:	ebff7fe6 	bl	8f610e50 <pmic_arb_read_cmd>
	uint8_t rt_sts = 0;

	rt_sts = REG_READ(PON_INT_RT_STS);

	return (rt_sts & BIT(RESIN_ON_INT_BIT));
}
8f630eb4:	e59f3024 	ldr	r3, [pc, #36]	; 8f630ee0 <pm8x41_resin_status+0x80>
	return val;
8f630eb8:	e5dd0003 	ldrb	r0, [r13, #3]
}
8f630ebc:	e5932000 	ldr	r2, [r3]
8f630ec0:	e59d3014 	ldr	r3, [r13, #20]
8f630ec4:	e0332002 	eors	r2, r3, r2
8f630ec8:	e3a03000 	mov	r3, #0
8f630ecc:	1a000002 	bne	8f630edc <pm8x41_resin_status+0x7c>
8f630ed0:	e2000002 	and	r0, r0, #2
8f630ed4:	e28dd018 	add	r13, r13, #24
8f630ed8:	e8bd8010 	pop	{r4, r15}
8f630edc:	eb000737 	bl	8f632bc0 <__stack_chk_fail>
8f630ee0:	8f74221c 	.word	0x8f74221c

8f630ee4 <pm8x41_get_pwrkey_is_pressed>:

/* Return 1 if power key is pressed */
uint32_t pm8x41_get_pwrkey_is_pressed()
{
8f630ee4:	e92d4010 	push	{r4, r14}
8f630ee8:	e24dd018 	sub	r13, r13, #24
8f630eec:	e59fe070 	ldr	r14, [pc, #112]	; 8f630f64 <pm8x41_get_pwrkey_is_pressed+0x80>
	pmic_arb_read_cmd(&cmd, &param);
8f630ef0:	e28d100c 	add	r1, r13, #12
8f630ef4:	e28d0004 	add	r0, r13, #4
	uint8_t val = 0;
8f630ef8:	e3a03000 	mov	r3, #0
{
8f630efc:	e59ee000 	ldr	r14, [r14]
8f630f00:	e58de014 	str	r14, [r13, #20]
8f630f04:	e3a0e000 	mov	r14, #0
	param.buffer = &val;
8f630f08:	e28dc003 	add	r12, r13, #3
	cmd.address  = PERIPH_ID(addr);
8f630f0c:	e3a02008 	mov	r2, #8
	uint8_t val = 0;
8f630f10:	e5cd3003 	strb	r3, [r13, #3]
	cmd.address  = PERIPH_ID(addr);
8f630f14:	e5cd2007 	strb	r2, [r13, #7]
	cmd.offset   = REG_OFFSET(addr);
8f630f18:	e3a02010 	mov	r2, #16
	cmd.slave_id = SLAVE_ID(addr);
8f630f1c:	e5cd3006 	strb	r3, [r13, #6]
	cmd.offset   = REG_OFFSET(addr);
8f630f20:	e5cd2008 	strb	r2, [r13, #8]
	param.size   = 1;
8f630f24:	e3a02001 	mov	r2, #1
	cmd.priority = 0;
8f630f28:	e5cd3005 	strb	r3, [r13, #5]
	param.size   = 1;
8f630f2c:	e5cd2010 	strb	r2, [r13, #16]
	param.buffer = &val;
8f630f30:	e58dc00c 	str	r12, [r13, #12]
	pmic_arb_read_cmd(&cmd, &param);
8f630f34:	ebff7fc5 	bl	8f610e50 <pmic_arb_read_cmd>

	if (pwr_sts & BIT(KPDPWR_ON_INT_BIT))
		return 1;
	else
		return 0;
}
8f630f38:	e59f3024 	ldr	r3, [pc, #36]	; 8f630f64 <pm8x41_get_pwrkey_is_pressed+0x80>
	return val;
8f630f3c:	e5dd0003 	ldrb	r0, [r13, #3]
}
8f630f40:	e5932000 	ldr	r2, [r3]
8f630f44:	e59d3014 	ldr	r3, [r13, #20]
8f630f48:	e0332002 	eors	r2, r3, r2
8f630f4c:	e3a03000 	mov	r3, #0
8f630f50:	1a000002 	bne	8f630f60 <pm8x41_get_pwrkey_is_pressed+0x7c>
8f630f54:	e2000001 	and	r0, r0, #1
8f630f58:	e28dd018 	add	r13, r13, #24
8f630f5c:	e8bd8010 	pop	{r4, r15}
8f630f60:	eb000716 	bl	8f632bc0 <__stack_chk_fail>
8f630f64:	8f74221c 	.word	0x8f74221c

8f630f68 <pmi632_reset_configure>:

void pmi632_reset_configure(uint8_t reset_type)
{
8f630f68:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f630f6c:	e24dd01c 	sub	r13, r13, #28
8f630f70:	e59f3178 	ldr	r3, [pc, #376]	; 8f6310f0 <pmi632_reset_configure+0x188>
8f630f74:	e1a05000 	mov	r5, r0
	pmic_arb_write_cmd(&cmd, &param);
8f630f78:	e28d100c 	add	r1, r13, #12
8f630f7c:	e28d0004 	add	r0, r13, #4
{
8f630f80:	e5933000 	ldr	r3, [r3]
8f630f84:	e58d3014 	str	r3, [r13, #20]
8f630f88:	e3a03000 	mov	r3, #0
	1. Disable the ps hold for pm8953 and pmi632
	2. set reset type for both pm8953 & pmi632
	3. Enable ps hold for pm8953 to trigger the reset
	*/
	/* disable PS_HOLD_RESET */
	pm8xxx_reg_write(slave_id[0], PON_PS_HOLD_RESET_CTL2, 0x0);
8f630f8c:	e3a04000 	mov	r4, #0
	cmd.address = PERIPH_ID(addr);
8f630f90:	e3a06008 	mov	r6, #8
	param.size   = 1;
8f630f94:	e3a07001 	mov	r7, #1
	param.buffer = &val;
8f630f98:	e28da003 	add	r10, r13, #3
	cmd.offset = REG_OFFSET(addr);
8f630f9c:	e3a0805b 	mov	r8, #91	; 0x5b
8f630fa0:	e5cd4003 	strb	r4, [r13, #3]
	cmd.slave_id = slave_id;
8f630fa4:	e3a0b002 	mov	r11, #2
	cmd.address = PERIPH_ID(addr);
8f630fa8:	e5cd6007 	strb	r6, [r13, #7]
	cmd.offset = REG_OFFSET(addr);
8f630fac:	e3a0905a 	mov	r9, #90	; 0x5a
	cmd.slave_id = slave_id;
8f630fb0:	e5cd4006 	strb	r4, [r13, #6]
	cmd.priority = 0;
8f630fb4:	e5cd4005 	strb	r4, [r13, #5]
	param.buffer = &val;
8f630fb8:	e58da00c 	str	r10, [r13, #12]
	param.size   = 1;
8f630fbc:	e5cd7010 	strb	r7, [r13, #16]
	cmd.offset = REG_OFFSET(addr);
8f630fc0:	e5cd8008 	strb	r8, [r13, #8]
	pmic_arb_write_cmd(&cmd, &param);
8f630fc4:	ebff7f41 	bl	8f610cd0 <pmic_arb_write_cmd>
8f630fc8:	e28d100c 	add	r1, r13, #12
8f630fcc:	e28d0004 	add	r0, r13, #4
8f630fd0:	e5cd4003 	strb	r4, [r13, #3]
	cmd.address = PERIPH_ID(addr);
8f630fd4:	e5cd6007 	strb	r6, [r13, #7]
	cmd.offset = REG_OFFSET(addr);
8f630fd8:	e5cd8008 	strb	r8, [r13, #8]
	cmd.priority = 0;
8f630fdc:	e5cd4005 	strb	r4, [r13, #5]
	param.buffer = &val;
8f630fe0:	e58da00c 	str	r10, [r13, #12]
	param.size   = 1;
8f630fe4:	e5cd7010 	strb	r7, [r13, #16]
	cmd.slave_id = slave_id;
8f630fe8:	e5cdb006 	strb	r11, [r13, #6]
	pmic_arb_write_cmd(&cmd, &param);
8f630fec:	ebff7f37 	bl	8f610cd0 <pmic_arb_write_cmd>
	pm8xxx_reg_write(slave_id[1], PON_PS_HOLD_RESET_CTL2, 0x0);

	/* Delay needed for disable to kick in. */
	udelay(300);
8f630ff0:	e3a00f4b 	mov	r0, #300	; 0x12c
8f630ff4:	ebff7758 	bl	8f60ed5c <udelay>
	pmic_arb_write_cmd(&cmd, &param);
8f630ff8:	e28d100c 	add	r1, r13, #12
8f630ffc:	e28d0004 	add	r0, r13, #4
8f631000:	e5cd5003 	strb	r5, [r13, #3]
	cmd.address = PERIPH_ID(addr);
8f631004:	e5cd6007 	strb	r6, [r13, #7]
	cmd.slave_id = slave_id;
8f631008:	e5cd4006 	strb	r4, [r13, #6]
	cmd.priority = 0;
8f63100c:	e5cd4005 	strb	r4, [r13, #5]
	param.buffer = &val;
8f631010:	e58da00c 	str	r10, [r13, #12]
	param.size   = 1;
8f631014:	e5cd7010 	strb	r7, [r13, #16]
	cmd.offset = REG_OFFSET(addr);
8f631018:	e5cd9008 	strb	r9, [r13, #8]
	pmic_arb_write_cmd(&cmd, &param);
8f63101c:	ebff7f2b 	bl	8f610cd0 <pmic_arb_write_cmd>
8f631020:	e28d100c 	add	r1, r13, #12
8f631024:	e28d0004 	add	r0, r13, #4
	cmd.offset = REG_OFFSET(addr);
8f631028:	e5cd9008 	strb	r9, [r13, #8]
8f63102c:	e5cd5003 	strb	r5, [r13, #3]
	cmd.address = PERIPH_ID(addr);
8f631030:	e5cd6007 	strb	r6, [r13, #7]
	cmd.slave_id = slave_id;
8f631034:	e5cdb006 	strb	r11, [r13, #6]
	cmd.priority = 0;
8f631038:	e5cd4005 	strb	r4, [r13, #5]
	param.buffer = &val;
8f63103c:	e58da00c 	str	r10, [r13, #12]
	param.size   = 1;
8f631040:	e5cd7010 	strb	r7, [r13, #16]
	pmic_arb_write_cmd(&cmd, &param);
8f631044:	ebff7f21 	bl	8f610cd0 <pmic_arb_write_cmd>

	/* configure reset type */
	for (i = 0; i < ARRAY_SIZE(slave_id); i++)
		pm8xxx_reg_write(slave_id[i], PON_PS_HOLD_RESET_CTL, reset_type);

	if (reset_type == PON_PSHOLD_WARM_RESET)
8f631048:	e1550007 	cmp	r5, r7
	cmd.address = PERIPH_ID(addr);
8f63104c:	e5cd6007 	strb	r6, [r13, #7]
	cmd.offset = REG_OFFSET(addr);
8f631050:	e5cd8008 	strb	r8, [r13, #8]
	if (reset_type == PON_PSHOLD_WARM_RESET)
8f631054:	1a00001a 	bne	8f6310c4 <pmi632_reset_configure+0x15c>
	pmic_arb_write_cmd(&cmd, &param);
8f631058:	e28d100c 	add	r1, r13, #12
8f63105c:	e28d0004 	add	r0, r13, #4
8f631060:	e3e0707f 	mvn	r7, #127	; 0x7f
	cmd.slave_id = slave_id;
8f631064:	e5cd4006 	strb	r4, [r13, #6]
	cmd.priority = 0;
8f631068:	e5cd4005 	strb	r4, [r13, #5]
	param.buffer = &val;
8f63106c:	e58da00c 	str	r10, [r13, #12]
	param.size   = 1;
8f631070:	e5cd5010 	strb	r5, [r13, #16]
8f631074:	e5cd7003 	strb	r7, [r13, #3]
	pmic_arb_write_cmd(&cmd, &param);
8f631078:	ebff7f14 	bl	8f610cd0 <pmic_arb_write_cmd>
8f63107c:	e28d100c 	add	r1, r13, #12
8f631080:	e28d0004 	add	r0, r13, #4
8f631084:	e5cd7003 	strb	r7, [r13, #3]
	cmd.address = PERIPH_ID(addr);
8f631088:	e5cd6007 	strb	r6, [r13, #7]
	cmd.offset = REG_OFFSET(addr);
8f63108c:	e5cd8008 	strb	r8, [r13, #8]
	cmd.slave_id = slave_id;
8f631090:	e5cdb006 	strb	r11, [r13, #6]
	cmd.priority = 0;
8f631094:	e5cd4005 	strb	r4, [r13, #5]
	param.buffer = &val;
8f631098:	e58da00c 	str	r10, [r13, #12]
	param.size   = 1;
8f63109c:	e5cd5010 	strb	r5, [r13, #16]
	pmic_arb_write_cmd(&cmd, &param);
8f6310a0:	ebff7f0a 	bl	8f610cd0 <pmic_arb_write_cmd>
	}
	else
	{
			pm8xxx_reg_write(slave_id[0], PON_PS_HOLD_RESET_CTL2, BIT(S2_RESET_EN_BIT));
	}
}
8f6310a4:	e59f3044 	ldr	r3, [pc, #68]	; 8f6310f0 <pmi632_reset_configure+0x188>
8f6310a8:	e5932000 	ldr	r2, [r3]
8f6310ac:	e59d3014 	ldr	r3, [r13, #20]
8f6310b0:	e0332002 	eors	r2, r3, r2
8f6310b4:	e3a03000 	mov	r3, #0
8f6310b8:	1a00000b 	bne	8f6310ec <pmi632_reset_configure+0x184>
8f6310bc:	e28dd01c 	add	r13, r13, #28
8f6310c0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	pmic_arb_write_cmd(&cmd, &param);
8f6310c4:	e28d100c 	add	r1, r13, #12
8f6310c8:	e28d0004 	add	r0, r13, #4
8f6310cc:	e3e0307f 	mvn	r3, #127	; 0x7f
	cmd.slave_id = slave_id;
8f6310d0:	e5cd4006 	strb	r4, [r13, #6]
	cmd.priority = 0;
8f6310d4:	e5cd4005 	strb	r4, [r13, #5]
	param.buffer = &val;
8f6310d8:	e58da00c 	str	r10, [r13, #12]
	param.size   = 1;
8f6310dc:	e5cd7010 	strb	r7, [r13, #16]
8f6310e0:	e5cd3003 	strb	r3, [r13, #3]
	pmic_arb_write_cmd(&cmd, &param);
8f6310e4:	ebff7ef9 	bl	8f610cd0 <pmic_arb_write_cmd>
}
8f6310e8:	eaffffed 	b	8f6310a4 <pmi632_reset_configure+0x13c>
8f6310ec:	eb0006b3 	bl	8f632bc0 <__stack_chk_fail>
8f6310f0:	8f74221c 	.word	0x8f74221c

8f6310f4 <pm8996_reset_configure>:
	for (i = 0; i < ARRAY_SIZE(slave_id); i++)
		pm8xxx_reg_write(slave_id[i], PON_PS_HOLD_RESET_CTL2, BIT(S2_RESET_EN_BIT));
}

void pm8996_reset_configure(uint8_t slave_id, uint8_t reset_type)
{
8f6310f4:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
8f6310f8:	e24dd018 	sub	r13, r13, #24
8f6310fc:	e59f30d0 	ldr	r3, [pc, #208]	; 8f6311d4 <pm8996_reset_configure+0xe0>
8f631100:	e1a04000 	mov	r4, r0
8f631104:	e1a09001 	mov	r9, r1
	pmic_arb_write_cmd(&cmd, &param);
8f631108:	e28d100c 	add	r1, r13, #12
{
8f63110c:	e5933000 	ldr	r3, [r3]
8f631110:	e58d3014 	str	r3, [r13, #20]
8f631114:	e3a03000 	mov	r3, #0
	cmd.slave_id = slave_id;
8f631118:	e5cd0006 	strb	r0, [r13, #6]
	pmic_arb_write_cmd(&cmd, &param);
8f63111c:	e28d0004 	add	r0, r13, #4
8f631120:	e3a05000 	mov	r5, #0
	param.buffer = &val;
8f631124:	e28d7003 	add	r7, r13, #3
	cmd.address = PERIPH_ID(addr);
8f631128:	e3a08008 	mov	r8, #8
	param.size   = 1;
8f63112c:	e3a06001 	mov	r6, #1
	cmd.offset = REG_OFFSET(addr);
8f631130:	e3a0a05b 	mov	r10, #91	; 0x5b
8f631134:	e5cd5003 	strb	r5, [r13, #3]
	cmd.address = PERIPH_ID(addr);
8f631138:	e5cd8007 	strb	r8, [r13, #7]
	cmd.offset = REG_OFFSET(addr);
8f63113c:	e5cda008 	strb	r10, [r13, #8]
	cmd.priority = 0;
8f631140:	e5cd5005 	strb	r5, [r13, #5]
	param.buffer = &val;
8f631144:	e58d700c 	str	r7, [r13, #12]
	param.size   = 1;
8f631148:	e5cd6010 	strb	r6, [r13, #16]
	pmic_arb_write_cmd(&cmd, &param);
8f63114c:	ebff7edf 	bl	8f610cd0 <pmic_arb_write_cmd>
	*/
	/* disable PS_HOLD_RESET */
	pm8xxx_reg_write(slave_id, PON_PS_HOLD_RESET_CTL2, 0x0);

	/* Delay needed for disable to kick in. */
	udelay(300);
8f631150:	e3a00f4b 	mov	r0, #300	; 0x12c
8f631154:	ebff7700 	bl	8f60ed5c <udelay>
	pmic_arb_write_cmd(&cmd, &param);
8f631158:	e28d100c 	add	r1, r13, #12
8f63115c:	e28d0004 	add	r0, r13, #4
	cmd.offset = REG_OFFSET(addr);
8f631160:	e3a0305a 	mov	r3, #90	; 0x5a
8f631164:	e5cd9003 	strb	r9, [r13, #3]
8f631168:	e5cd3008 	strb	r3, [r13, #8]
	cmd.address = PERIPH_ID(addr);
8f63116c:	e5cd8007 	strb	r8, [r13, #7]
	cmd.slave_id = slave_id;
8f631170:	e5cd4006 	strb	r4, [r13, #6]
	cmd.priority = 0;
8f631174:	e5cd5005 	strb	r5, [r13, #5]
	param.buffer = &val;
8f631178:	e58d700c 	str	r7, [r13, #12]
	param.size   = 1;
8f63117c:	e5cd6010 	strb	r6, [r13, #16]
	pmic_arb_write_cmd(&cmd, &param);
8f631180:	ebff7ed2 	bl	8f610cd0 <pmic_arb_write_cmd>
8f631184:	e28d100c 	add	r1, r13, #12
8f631188:	e28d0004 	add	r0, r13, #4
8f63118c:	e3e0307f 	mvn	r3, #127	; 0x7f
	cmd.address = PERIPH_ID(addr);
8f631190:	e5cd8007 	strb	r8, [r13, #7]
8f631194:	e5cd3003 	strb	r3, [r13, #3]
	cmd.offset = REG_OFFSET(addr);
8f631198:	e5cda008 	strb	r10, [r13, #8]
	cmd.slave_id = slave_id;
8f63119c:	e5cd4006 	strb	r4, [r13, #6]
	cmd.priority = 0;
8f6311a0:	e5cd5005 	strb	r5, [r13, #5]
	param.buffer = &val;
8f6311a4:	e58d700c 	str	r7, [r13, #12]
	param.size   = 1;
8f6311a8:	e5cd6010 	strb	r6, [r13, #16]
	pmic_arb_write_cmd(&cmd, &param);
8f6311ac:	ebff7ec7 	bl	8f610cd0 <pmic_arb_write_cmd>

	/* configure reset type */
	pm8xxx_reg_write(slave_id, PON_PS_HOLD_RESET_CTL, reset_type);
	/* enable PS_HOLD_RESET */
	pm8xxx_reg_write(slave_id, PON_PS_HOLD_RESET_CTL2, BIT(S2_RESET_EN_BIT));
}
8f6311b0:	e59f301c 	ldr	r3, [pc, #28]	; 8f6311d4 <pm8996_reset_configure+0xe0>
8f6311b4:	e5932000 	ldr	r2, [r3]
8f6311b8:	e59d3014 	ldr	r3, [r13, #20]
8f6311bc:	e0332002 	eors	r2, r3, r2
8f6311c0:	e3a03000 	mov	r3, #0
8f6311c4:	1a000001 	bne	8f6311d0 <pm8996_reset_configure+0xdc>
8f6311c8:	e28dd018 	add	r13, r13, #24
8f6311cc:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
8f6311d0:	eb00067a 	bl	8f632bc0 <__stack_chk_fail>
8f6311d4:	8f74221c 	.word	0x8f74221c

8f6311d8 <pm8950_get_pon_reason>:
{
	return REG_READ(PON_PON_REASON1);
}

uint8_t pm8950_get_pon_reason()
{
8f6311d8:	e92d4070 	push	{r4, r5, r6, r14}
8f6311dc:	e24dd018 	sub	r13, r13, #24
	cmd.address  = PERIPH_ID(addr);
8f6311e0:	e3a03013 	mov	r3, #19
	pmic_arb_read_cmd(&cmd, &param);
8f6311e4:	e28d100c 	add	r1, r13, #12
	cmd.address  = PERIPH_ID(addr);
8f6311e8:	e5cd3007 	strb	r3, [r13, #7]
	pmic_arb_read_cmd(&cmd, &param);
8f6311ec:	e28d0004 	add	r0, r13, #4
{
8f6311f0:	e59f309c 	ldr	r3, [pc, #156]	; 8f631294 <pm8950_get_pon_reason+0xbc>
	uint8_t val = 0;
8f6311f4:	e3a05000 	mov	r5, #0
	param.size   = 1;
8f6311f8:	e3a04001 	mov	r4, #1
	param.buffer = &val;
8f6311fc:	e28d6003 	add	r6, r13, #3
{
8f631200:	e5933000 	ldr	r3, [r3]
8f631204:	e58d3014 	str	r3, [r13, #20]
8f631208:	e3a03000 	mov	r3, #0
	cmd.offset   = REG_OFFSET(addr);
8f63120c:	e3a03009 	mov	r3, #9
	param.size   = 1;
8f631210:	e5cd4010 	strb	r4, [r13, #16]
	cmd.offset   = REG_OFFSET(addr);
8f631214:	e5cd3008 	strb	r3, [r13, #8]
	cmd.slave_id = SLAVE_ID(addr);
8f631218:	e3a03002 	mov	r3, #2
	uint8_t val = 0;
8f63121c:	e5cd5003 	strb	r5, [r13, #3]
	cmd.slave_id = SLAVE_ID(addr);
8f631220:	e5cd3006 	strb	r3, [r13, #6]
	cmd.priority = 0;
8f631224:	e5cd5005 	strb	r5, [r13, #5]
	param.buffer = &val;
8f631228:	e58d600c 	str	r6, [r13, #12]
	pmic_arb_read_cmd(&cmd, &param);
8f63122c:	ebff7f07 	bl	8f610e50 <pmic_arb_read_cmd>
	param.size   = 1;
8f631230:	e5cd4010 	strb	r4, [r13, #16]
	pmic_arb_read_cmd(&cmd, &param);
8f631234:	e28d100c 	add	r1, r13, #12
	return val;
8f631238:	e5dd4003 	ldrb	r4, [r13, #3]
	pmic_arb_read_cmd(&cmd, &param);
8f63123c:	e28d0004 	add	r0, r13, #4
	cmd.address  = PERIPH_ID(addr);
8f631240:	e3a03008 	mov	r3, #8
	param.buffer = &val;
8f631244:	e58d600c 	str	r6, [r13, #12]
	cmd.address  = PERIPH_ID(addr);
8f631248:	e5cd3007 	strb	r3, [r13, #7]
	cmd.offset   = REG_OFFSET(addr);
8f63124c:	e5cd3008 	strb	r3, [r13, #8]
	uint8_t pon_reason = 0;

	pon_reason = REG_READ(SMBCHGL_USB_ICL_STS_2|PMI8950_SLAVE_ID);
	/* check usbin/dcin status on pmi and set the corresponding bits for pon */
	pon_reason = (pon_reason & (USBIN_ACTIVE_PWR_SRC|DCIN_ACTIVE_PWR_SRC)) << 3 ;
8f631250:	e1a04184 	lsl	r4, r4, #3
	cmd.slave_id = SLAVE_ID(addr);
8f631254:	e5cd5006 	strb	r5, [r13, #6]
	pon_reason = (pon_reason & (USBIN_ACTIVE_PWR_SRC|DCIN_ACTIVE_PWR_SRC)) << 3 ;
8f631258:	e2044018 	and	r4, r4, #24
	cmd.priority = 0;
8f63125c:	e5cd5005 	strb	r5, [r13, #5]
	uint8_t val = 0;
8f631260:	e5cd5003 	strb	r5, [r13, #3]
	pmic_arb_read_cmd(&cmd, &param);
8f631264:	ebff7ef9 	bl	8f610e50 <pmic_arb_read_cmd>
	pon_reason |= REG_READ(PON_PON_REASON1);

	return pon_reason;
}
8f631268:	e59f3024 	ldr	r3, [pc, #36]	; 8f631294 <pm8950_get_pon_reason+0xbc>
	return val;
8f63126c:	e5dd0003 	ldrb	r0, [r13, #3]
}
8f631270:	e5932000 	ldr	r2, [r3]
8f631274:	e59d3014 	ldr	r3, [r13, #20]
8f631278:	e0332002 	eors	r2, r3, r2
8f63127c:	e3a03000 	mov	r3, #0
	return pon_reason;
8f631280:	e1840000 	orr	r0, r4, r0
}
8f631284:	1a000001 	bne	8f631290 <pm8950_get_pon_reason+0xb8>
8f631288:	e28dd018 	add	r13, r13, #24
8f63128c:	e8bd8070 	pop	{r4, r5, r6, r15}
8f631290:	eb00064a 	bl	8f632bc0 <__stack_chk_fail>
8f631294:	8f74221c 	.word	0x8f74221c

8f631298 <pmi632_get_pon_reason>:

uint8_t pmi632_get_pon_reason()
{
8f631298:	e92d4070 	push	{r4, r5, r6, r14}
8f63129c:	e24dd018 	sub	r13, r13, #24
	cmd.address  = PERIPH_ID(addr);
8f6312a0:	e3a03013 	mov	r3, #19
	pmic_arb_read_cmd(&cmd, &param);
8f6312a4:	e28d100c 	add	r1, r13, #12
	cmd.address  = PERIPH_ID(addr);
8f6312a8:	e5cd3007 	strb	r3, [r13, #7]
	pmic_arb_read_cmd(&cmd, &param);
8f6312ac:	e28d0004 	add	r0, r13, #4
{
8f6312b0:	e59f3098 	ldr	r3, [pc, #152]	; 8f631350 <pmi632_get_pon_reason+0xb8>
	uint8_t val = 0;
8f6312b4:	e3a04000 	mov	r4, #0
	param.buffer = &val;
8f6312b8:	e28d6003 	add	r6, r13, #3
	param.size   = 1;
8f6312bc:	e3a05001 	mov	r5, #1
{
8f6312c0:	e5933000 	ldr	r3, [r3]
8f6312c4:	e58d3014 	str	r3, [r13, #20]
8f6312c8:	e3a03000 	mov	r3, #0
	cmd.offset   = REG_OFFSET(addr);
8f6312cc:	e3a03010 	mov	r3, #16
	uint8_t val = 0;
8f6312d0:	e5cd4003 	strb	r4, [r13, #3]
	cmd.priority = 0;
8f6312d4:	e5cd4005 	strb	r4, [r13, #5]
	cmd.offset   = REG_OFFSET(addr);
8f6312d8:	e5cd3008 	strb	r3, [r13, #8]
	cmd.slave_id = SLAVE_ID(addr);
8f6312dc:	e3a03002 	mov	r3, #2
	param.buffer = &val;
8f6312e0:	e58d600c 	str	r6, [r13, #12]
	cmd.slave_id = SLAVE_ID(addr);
8f6312e4:	e5cd3006 	strb	r3, [r13, #6]
	param.size   = 1;
8f6312e8:	e5cd5010 	strb	r5, [r13, #16]
	pmic_arb_read_cmd(&cmd, &param);
8f6312ec:	ebff7ed7 	bl	8f610e50 <pmic_arb_read_cmd>
	return val;
8f6312f0:	e5dd3003 	ldrb	r3, [r13, #3]
	pmic_arb_read_cmd(&cmd, &param);
8f6312f4:	e28d100c 	add	r1, r13, #12
8f6312f8:	e28d0004 	add	r0, r13, #4
	cmd.address  = PERIPH_ID(addr);
8f6312fc:	e3a02008 	mov	r2, #8
	cmd.slave_id = SLAVE_ID(addr);
8f631300:	e5cd4006 	strb	r4, [r13, #6]
	cmd.priority = 0;
8f631304:	e5cd4005 	strb	r4, [r13, #5]
	uint8_t val = 0;
8f631308:	e5cd4003 	strb	r4, [r13, #3]
	uint8_t pon_reason = 0;

	pon_reason = REG_READ(SCHG_USB_INT_RT_STS|PMI8950_SLAVE_ID);
	/* Check USBIN status on PMI and set the corresponding bits for pon */
	pon_reason = (pon_reason & USBIN_PLUGIN_RT_STS);
8f63130c:	e2034010 	and	r4, r3, #16
	cmd.address  = PERIPH_ID(addr);
8f631310:	e5cd2007 	strb	r2, [r13, #7]
	cmd.offset   = REG_OFFSET(addr);
8f631314:	e5cd2008 	strb	r2, [r13, #8]
	param.buffer = &val;
8f631318:	e58d600c 	str	r6, [r13, #12]
	param.size   = 1;
8f63131c:	e5cd5010 	strb	r5, [r13, #16]
	pmic_arb_read_cmd(&cmd, &param);
8f631320:	ebff7eca 	bl	8f610e50 <pmic_arb_read_cmd>
	pon_reason |= REG_READ(PON_PON_REASON1);

	return pon_reason;
}
8f631324:	e59f3024 	ldr	r3, [pc, #36]	; 8f631350 <pmi632_get_pon_reason+0xb8>
	return val;
8f631328:	e5dd0003 	ldrb	r0, [r13, #3]
}
8f63132c:	e5932000 	ldr	r2, [r3]
8f631330:	e59d3014 	ldr	r3, [r13, #20]
8f631334:	e0332002 	eors	r2, r3, r2
8f631338:	e3a03000 	mov	r3, #0
	return pon_reason;
8f63133c:	e1840000 	orr	r0, r4, r0
}
8f631340:	1a000001 	bne	8f63134c <pmi632_get_pon_reason+0xb4>
8f631344:	e28dd018 	add	r13, r13, #24
8f631348:	e8bd8070 	pop	{r4, r5, r6, r15}
8f63134c:	eb00061b 	bl	8f632bc0 <__stack_chk_fail>
8f631350:	8f74221c 	.word	0x8f74221c

8f631354 <pm8x41_get_is_cold_boot>:
	}
	return 1;
}

uint8_t pm8x41_get_is_cold_boot()
{
8f631354:	e59f10e8 	ldr	r1, [pc, #232]	; 8f631444 <pm8x41_get_is_cold_boot+0xf0>
	uint8_t val = 0;
8f631358:	e3a03000 	mov	r3, #0
{
8f63135c:	e92d4070 	push	{r4, r5, r6, r14}
8f631360:	e24dd018 	sub	r13, r13, #24
8f631364:	e5911000 	ldr	r1, [r1]
8f631368:	e58d1014 	str	r1, [r13, #20]
8f63136c:	e3a01000 	mov	r1, #0
	pmic_arb_read_cmd(&cmd, &param);
8f631370:	e28d0004 	add	r0, r13, #4
8f631374:	e28d100c 	add	r1, r13, #12
	cmd.offset   = REG_OFFSET(addr);
8f631378:	e3a0200a 	mov	r2, #10
	uint8_t val = 0;
8f63137c:	e5cd3003 	strb	r3, [r13, #3]
	param.buffer = &val;
8f631380:	e28d5003 	add	r5, r13, #3
	cmd.slave_id = SLAVE_ID(addr);
8f631384:	e5cd3006 	strb	r3, [r13, #6]
	cmd.address  = PERIPH_ID(addr);
8f631388:	e3a06008 	mov	r6, #8
	cmd.priority = 0;
8f63138c:	e5cd3005 	strb	r3, [r13, #5]
	param.size   = 1;
8f631390:	e3a04001 	mov	r4, #1
	cmd.address  = PERIPH_ID(addr);
8f631394:	e5cd6007 	strb	r6, [r13, #7]
	cmd.offset   = REG_OFFSET(addr);
8f631398:	e5cd2008 	strb	r2, [r13, #8]
	param.buffer = &val;
8f63139c:	e58d500c 	str	r5, [r13, #12]
	param.size   = 1;
8f6313a0:	e5cd4010 	strb	r4, [r13, #16]
	pmic_arb_read_cmd(&cmd, &param);
8f6313a4:	ebff7ea9 	bl	8f610e50 <pmic_arb_read_cmd>
	return val;
8f6313a8:	e5dd3003 	ldrb	r3, [r13, #3]
	if (REG_READ(PON_WARMBOOT_STATUS1) || REG_READ(PON_WARMBOOT_STATUS2)) {
8f6313ac:	e3530000 	cmp	r3, #0
8f6313b0:	1a00000d 	bne	8f6313ec <pm8x41_get_is_cold_boot+0x98>
	pmic_arb_read_cmd(&cmd, &param);
8f6313b4:	e28d100c 	add	r1, r13, #12
8f6313b8:	e28d0004 	add	r0, r13, #4
	uint8_t val = 0;
8f6313bc:	e5cd3003 	strb	r3, [r13, #3]
	cmd.slave_id = SLAVE_ID(addr);
8f6313c0:	e5cd3006 	strb	r3, [r13, #6]
	cmd.priority = 0;
8f6313c4:	e5cd3005 	strb	r3, [r13, #5]
	cmd.offset   = REG_OFFSET(addr);
8f6313c8:	e3a0300b 	mov	r3, #11
	cmd.address  = PERIPH_ID(addr);
8f6313cc:	e5cd6007 	strb	r6, [r13, #7]
	cmd.offset   = REG_OFFSET(addr);
8f6313d0:	e5cd3008 	strb	r3, [r13, #8]
	param.buffer = &val;
8f6313d4:	e58d500c 	str	r5, [r13, #12]
	param.size   = 1;
8f6313d8:	e5cd4010 	strb	r4, [r13, #16]
	pmic_arb_read_cmd(&cmd, &param);
8f6313dc:	ebff7e9b 	bl	8f610e50 <pmic_arb_read_cmd>
	return val;
8f6313e0:	e5dd3003 	ldrb	r3, [r13, #3]
	if (REG_READ(PON_WARMBOOT_STATUS1) || REG_READ(PON_WARMBOOT_STATUS2)) {
8f6313e4:	e3530000 	cmp	r3, #0
8f6313e8:	0a00000d 	beq	8f631424 <pm8x41_get_is_cold_boot+0xd0>
		dprintf(INFO,"%s: Warm boot\n", __func__);
8f6313ec:	e30b10a4 	movw	r1, #45220	; 0xb0a4
8f6313f0:	e30b0084 	movw	r0, #45188	; 0xb084
8f6313f4:	e3481f70 	movt	r1, #36720	; 0x8f70
8f6313f8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6313fc:	eb00055c 	bl	8f632974 <_dprintf>
		return 0;
8f631400:	e3a00000 	mov	r0, #0
	}
	dprintf(INFO,"%s: cold boot\n", __func__);
	return 1;
}
8f631404:	e59f3038 	ldr	r3, [pc, #56]	; 8f631444 <pm8x41_get_is_cold_boot+0xf0>
8f631408:	e5932000 	ldr	r2, [r3]
8f63140c:	e59d3014 	ldr	r3, [r13, #20]
8f631410:	e0332002 	eors	r2, r3, r2
8f631414:	e3a03000 	mov	r3, #0
8f631418:	1a000008 	bne	8f631440 <pm8x41_get_is_cold_boot+0xec>
8f63141c:	e28dd018 	add	r13, r13, #24
8f631420:	e8bd8070 	pop	{r4, r5, r6, r15}
	dprintf(INFO,"%s: cold boot\n", __func__);
8f631424:	e30b10a4 	movw	r1, #45220	; 0xb0a4
8f631428:	e30b0094 	movw	r0, #45204	; 0xb094
8f63142c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f631430:	e3480f70 	movt	r0, #36720	; 0x8f70
8f631434:	eb00054e 	bl	8f632974 <_dprintf>
	return 1;
8f631438:	e1a00004 	mov	r0, r4
8f63143c:	eafffff0 	b	8f631404 <pm8x41_get_is_cold_boot+0xb0>
}
8f631440:	eb0005de 	bl	8f632bc0 <__stack_chk_fail>
8f631444:	8f74221c 	.word	0x8f74221c

8f631448 <pm8x41_clear_pmic_watchdog>:

	REG_WRITE(DIFF_CLK1_EN_CTL, reg);
}

void pm8x41_clear_pmic_watchdog(void)
{
8f631448:	e92d4010 	push	{r4, r14}
8f63144c:	e24dd018 	sub	r13, r13, #24
8f631450:	e59fe068 	ldr	r14, [pc, #104]	; 8f6314c0 <pm8x41_clear_pmic_watchdog+0x78>
	pmic_arb_write_cmd(&cmd, &param);
8f631454:	e28d100c 	add	r1, r13, #12
8f631458:	e28d0004 	add	r0, r13, #4
8f63145c:	e3a03000 	mov	r3, #0
{
8f631460:	e59ee000 	ldr	r14, [r14]
8f631464:	e58de014 	str	r14, [r13, #20]
8f631468:	e3a0e000 	mov	r14, #0
	param.buffer = &val;
8f63146c:	e28dc003 	add	r12, r13, #3
	cmd.address  = PERIPH_ID(addr);
8f631470:	e3a02008 	mov	r2, #8
8f631474:	e5cd3003 	strb	r3, [r13, #3]
8f631478:	e5cd2007 	strb	r2, [r13, #7]
	cmd.offset   = REG_OFFSET(addr);
8f63147c:	e3a02057 	mov	r2, #87	; 0x57
	cmd.slave_id = SLAVE_ID(addr);
8f631480:	e5cd3006 	strb	r3, [r13, #6]
	cmd.offset   = REG_OFFSET(addr);
8f631484:	e5cd2008 	strb	r2, [r13, #8]
	param.size   = 1;
8f631488:	e3a02001 	mov	r2, #1
	cmd.priority = 0;
8f63148c:	e5cd3005 	strb	r3, [r13, #5]
	param.size   = 1;
8f631490:	e5cd2010 	strb	r2, [r13, #16]
	param.buffer = &val;
8f631494:	e58dc00c 	str	r12, [r13, #12]
	pmic_arb_write_cmd(&cmd, &param);
8f631498:	ebff7e0c 	bl	8f610cd0 <pmic_arb_write_cmd>
	pm8x41_reg_write(PMIC_WD_RESET_S2_CTL2, 0x0);
}
8f63149c:	e59f301c 	ldr	r3, [pc, #28]	; 8f6314c0 <pm8x41_clear_pmic_watchdog+0x78>
8f6314a0:	e5932000 	ldr	r2, [r3]
8f6314a4:	e59d3014 	ldr	r3, [r13, #20]
8f6314a8:	e0332002 	eors	r2, r3, r2
8f6314ac:	e3a03000 	mov	r3, #0
8f6314b0:	1a000001 	bne	8f6314bc <pm8x41_clear_pmic_watchdog+0x74>
8f6314b4:	e28dd018 	add	r13, r13, #24
8f6314b8:	e8bd8010 	pop	{r4, r15}
8f6314bc:	eb0005bf 	bl	8f632bc0 <__stack_chk_fail>
8f6314c0:	8f74221c 	.word	0x8f74221c

8f6314c4 <pm8x41_vib_turn_on>:

	return batt_is_broken;
}

void pm8x41_vib_turn_on(void)
{
8f6314c4:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f6314c8:	e24dd018 	sub	r13, r13, #24
8f6314cc:	e59f30fc 	ldr	r3, [pc, #252]	; 8f6315d0 <pm8x41_vib_turn_on+0x10c>
	pmic_arb_read_cmd(&cmd, &param);
8f6314d0:	e28d100c 	add	r1, r13, #12
8f6314d4:	e28d0004 	add	r0, r13, #4
	cmd.slave_id = SLAVE_ID(addr);
8f6314d8:	e3a04001 	mov	r4, #1
{
8f6314dc:	e5933000 	ldr	r3, [r3]
8f6314e0:	e58d3014 	str	r3, [r13, #20]
8f6314e4:	e3a03000 	mov	r3, #0
	uint8_t val = 0;
8f6314e8:	e3a05000 	mov	r5, #0
	param.buffer = &val;
8f6314ec:	e28d6003 	add	r6, r13, #3
	cmd.address  = PERIPH_ID(addr);
8f6314f0:	e3e0703f 	mvn	r7, #63	; 0x3f
	cmd.offset   = REG_OFFSET(addr);
8f6314f4:	e3a08041 	mov	r8, #65	; 0x41
	uint8_t val = 0;
8f6314f8:	e5cd5003 	strb	r5, [r13, #3]
	cmd.offset   = REG_OFFSET(addr);
8f6314fc:	e5cd8008 	strb	r8, [r13, #8]
	cmd.address  = PERIPH_ID(addr);
8f631500:	e5cd7007 	strb	r7, [r13, #7]
	cmd.slave_id = SLAVE_ID(addr);
8f631504:	e5cd4006 	strb	r4, [r13, #6]
	cmd.priority = 0;
8f631508:	e5cd5005 	strb	r5, [r13, #5]
	param.size   = 1;
8f63150c:	e5cd4010 	strb	r4, [r13, #16]
	param.buffer = &val;
8f631510:	e58d600c 	str	r6, [r13, #12]
	pmic_arb_read_cmd(&cmd, &param);
8f631514:	ebff7e4d 	bl	8f610e50 <pmic_arb_read_cmd>
	return val;
8f631518:	e5dd3003 	ldrb	r3, [r13, #3]
	pmic_arb_write_cmd(&cmd, &param);
8f63151c:	e28d100c 	add	r1, r13, #12
8f631520:	e28d0004 	add	r0, r13, #4
	cmd.offset   = REG_OFFSET(addr);
8f631524:	e5cd8008 	strb	r8, [r13, #8]
	uint8_t val;

	val = pm8x41_reg_read(QPNP_VIB_VTG_CTL);
	val &= ~QPNP_VIB_VTG_SET_MASK;
8f631528:	e20330e0 	and	r3, r3, #224	; 0xe0
	cmd.address  = PERIPH_ID(addr);
8f63152c:	e5cd7007 	strb	r7, [r13, #7]
	val |= (QPNP_VIB_DEFAULT_VTG_LVL & QPNP_VIB_VTG_SET_MASK);
8f631530:	e3833016 	orr	r3, r3, #22
	cmd.slave_id = SLAVE_ID(addr);
8f631534:	e5cd4006 	strb	r4, [r13, #6]
8f631538:	e5cd3003 	strb	r3, [r13, #3]
	cmd.offset   = REG_OFFSET(addr);
8f63153c:	e3a08046 	mov	r8, #70	; 0x46
	cmd.priority = 0;
8f631540:	e5cd5005 	strb	r5, [r13, #5]
	param.buffer = &val;
8f631544:	e58d600c 	str	r6, [r13, #12]
	param.size   = 1;
8f631548:	e5cd4010 	strb	r4, [r13, #16]
	pmic_arb_write_cmd(&cmd, &param);
8f63154c:	ebff7ddf 	bl	8f610cd0 <pmic_arb_write_cmd>
	pmic_arb_read_cmd(&cmd, &param);
8f631550:	e28d100c 	add	r1, r13, #12
8f631554:	e28d0004 	add	r0, r13, #4
	uint8_t val = 0;
8f631558:	e5cd5003 	strb	r5, [r13, #3]
	cmd.address  = PERIPH_ID(addr);
8f63155c:	e5cd7007 	strb	r7, [r13, #7]
	cmd.slave_id = SLAVE_ID(addr);
8f631560:	e5cd4006 	strb	r4, [r13, #6]
	cmd.priority = 0;
8f631564:	e5cd5005 	strb	r5, [r13, #5]
	param.buffer = &val;
8f631568:	e58d600c 	str	r6, [r13, #12]
	param.size   = 1;
8f63156c:	e5cd4010 	strb	r4, [r13, #16]
	cmd.offset   = REG_OFFSET(addr);
8f631570:	e5cd8008 	strb	r8, [r13, #8]
	pmic_arb_read_cmd(&cmd, &param);
8f631574:	ebff7e35 	bl	8f610e50 <pmic_arb_read_cmd>
	return val;
8f631578:	e5dd3003 	ldrb	r3, [r13, #3]
	pmic_arb_write_cmd(&cmd, &param);
8f63157c:	e28d100c 	add	r1, r13, #12
8f631580:	e28d0004 	add	r0, r13, #4
	cmd.address  = PERIPH_ID(addr);
8f631584:	e5cd7007 	strb	r7, [r13, #7]
	cmd.offset   = REG_OFFSET(addr);
8f631588:	e5cd8008 	strb	r8, [r13, #8]
	pm8x41_reg_write(QPNP_VIB_VTG_CTL, val);

	val = pm8x41_reg_read(QPNP_VIB_EN_CTL);
	val |= QPNP_VIB_EN;
8f63158c:	e1e03c83 	mvn	r3, r3, lsl #25
	cmd.slave_id = SLAVE_ID(addr);
8f631590:	e5cd4006 	strb	r4, [r13, #6]
	val |= QPNP_VIB_EN;
8f631594:	e1e03ca3 	mvn	r3, r3, lsr #25
	cmd.priority = 0;
8f631598:	e5cd5005 	strb	r5, [r13, #5]
8f63159c:	e5cd3003 	strb	r3, [r13, #3]
	param.buffer = &val;
8f6315a0:	e58d600c 	str	r6, [r13, #12]
	param.size   = 1;
8f6315a4:	e5cd4010 	strb	r4, [r13, #16]
	pmic_arb_write_cmd(&cmd, &param);
8f6315a8:	ebff7dc8 	bl	8f610cd0 <pmic_arb_write_cmd>
	pm8x41_reg_write(QPNP_VIB_EN_CTL, val);
}
8f6315ac:	e59f301c 	ldr	r3, [pc, #28]	; 8f6315d0 <pm8x41_vib_turn_on+0x10c>
8f6315b0:	e5932000 	ldr	r2, [r3]
8f6315b4:	e59d3014 	ldr	r3, [r13, #20]
8f6315b8:	e0332002 	eors	r2, r3, r2
8f6315bc:	e3a03000 	mov	r3, #0
8f6315c0:	1a000001 	bne	8f6315cc <pm8x41_vib_turn_on+0x108>
8f6315c4:	e28dd018 	add	r13, r13, #24
8f6315c8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
8f6315cc:	eb00057b 	bl	8f632bc0 <__stack_chk_fail>
8f6315d0:	8f74221c 	.word	0x8f74221c

8f6315d4 <pm8x41_vib_turn_off>:

/* Turn off vibrator */
void pm8x41_vib_turn_off(void)
{
8f6315d4:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f6315d8:	e24dd018 	sub	r13, r13, #24
8f6315dc:	e59f3098 	ldr	r3, [pc, #152]	; 8f63167c <pm8x41_vib_turn_off+0xa8>
	pmic_arb_read_cmd(&cmd, &param);
8f6315e0:	e28d100c 	add	r1, r13, #12
8f6315e4:	e28d0004 	add	r0, r13, #4
	cmd.slave_id = SLAVE_ID(addr);
8f6315e8:	e3a04001 	mov	r4, #1
{
8f6315ec:	e5933000 	ldr	r3, [r3]
8f6315f0:	e58d3014 	str	r3, [r13, #20]
8f6315f4:	e3a03000 	mov	r3, #0
	uint8_t val = 0;
8f6315f8:	e3a05000 	mov	r5, #0
	param.buffer = &val;
8f6315fc:	e28d6003 	add	r6, r13, #3
	cmd.address  = PERIPH_ID(addr);
8f631600:	e3e0803f 	mvn	r8, #63	; 0x3f
	cmd.offset   = REG_OFFSET(addr);
8f631604:	e3a07046 	mov	r7, #70	; 0x46
	uint8_t val = 0;
8f631608:	e5cd5003 	strb	r5, [r13, #3]
	cmd.address  = PERIPH_ID(addr);
8f63160c:	e5cd8007 	strb	r8, [r13, #7]
	cmd.slave_id = SLAVE_ID(addr);
8f631610:	e5cd4006 	strb	r4, [r13, #6]
	cmd.priority = 0;
8f631614:	e5cd5005 	strb	r5, [r13, #5]
	param.size   = 1;
8f631618:	e5cd4010 	strb	r4, [r13, #16]
	param.buffer = &val;
8f63161c:	e58d600c 	str	r6, [r13, #12]
	cmd.offset   = REG_OFFSET(addr);
8f631620:	e5cd7008 	strb	r7, [r13, #8]
	pmic_arb_read_cmd(&cmd, &param);
8f631624:	ebff7e09 	bl	8f610e50 <pmic_arb_read_cmd>
	return val;
8f631628:	e5dd3003 	ldrb	r3, [r13, #3]
	pmic_arb_write_cmd(&cmd, &param);
8f63162c:	e28d100c 	add	r1, r13, #12
8f631630:	e28d0004 	add	r0, r13, #4
	cmd.address  = PERIPH_ID(addr);
8f631634:	e5cd8007 	strb	r8, [r13, #7]
	uint8_t val;

	val = pm8x41_reg_read(QPNP_VIB_EN_CTL);
	val &= ~QPNP_VIB_EN;
8f631638:	e203307f 	and	r3, r3, #127	; 0x7f
	cmd.offset   = REG_OFFSET(addr);
8f63163c:	e5cd7008 	strb	r7, [r13, #8]
8f631640:	e5cd3003 	strb	r3, [r13, #3]
	cmd.slave_id = SLAVE_ID(addr);
8f631644:	e5cd4006 	strb	r4, [r13, #6]
	cmd.priority = 0;
8f631648:	e5cd5005 	strb	r5, [r13, #5]
	param.buffer = &val;
8f63164c:	e58d600c 	str	r6, [r13, #12]
	param.size   = 1;
8f631650:	e5cd4010 	strb	r4, [r13, #16]
	pmic_arb_write_cmd(&cmd, &param);
8f631654:	ebff7d9d 	bl	8f610cd0 <pmic_arb_write_cmd>
	pm8x41_reg_write(QPNP_VIB_EN_CTL, val);
}
8f631658:	e59f301c 	ldr	r3, [pc, #28]	; 8f63167c <pm8x41_vib_turn_off+0xa8>
8f63165c:	e5932000 	ldr	r2, [r3]
8f631660:	e59d3014 	ldr	r3, [r13, #20]
8f631664:	e0332002 	eors	r2, r3, r2
8f631668:	e3a03000 	mov	r3, #0
8f63166c:	1a000001 	bne	8f631678 <pm8x41_vib_turn_off+0xa4>
8f631670:	e28dd018 	add	r13, r13, #24
8f631674:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
8f631678:	eb000550 	bl	8f632bc0 <__stack_chk_fail>
8f63167c:	8f74221c 	.word	0x8f74221c

8f631680 <adc_configure>:

/*
 * This function configures adc & requests for conversion
 */
static uint16_t adc_configure(struct adc_conf *adc)
{
8f631680:	e92d4030 	push	{r4, r5, r14}
8f631684:	e1a04000 	mov	r4, r0
	uint8_t mode;
	uint8_t adc_p;
	uint16_t result;

	/* Mode Selection */
	mode = (adc->mode << VADC_MODE_BIT_NORMAL);
8f631688:	e5d01004 	ldrb	r1, [r0, #4]
{
8f63168c:	e24dd00c 	sub	r13, r13, #12
	REG_WRITE((adc->base + VADC_MODE_CTRL), mode);
8f631690:	e5900000 	ldr	r0, [r0]
{
8f631694:	e59f311c 	ldr	r3, [pc, #284]	; 8f6317b8 <adc_configure+0x138>
	mode = (adc->mode << VADC_MODE_BIT_NORMAL);
8f631698:	e1a01181 	lsl	r1, r1, #3
	REG_WRITE((adc->base + VADC_MODE_CTRL), mode);
8f63169c:	e2800040 	add	r0, r0, #64	; 0x40
8f6316a0:	e20110f8 	and	r1, r1, #248	; 0xf8
{
8f6316a4:	e5933000 	ldr	r3, [r3]
8f6316a8:	e58d3004 	str	r3, [r13, #4]
8f6316ac:	e3a03000 	mov	r3, #0
	REG_WRITE((adc->base + VADC_MODE_CTRL), mode);
8f6316b0:	ebfffdc9 	bl	8f630ddc <pm8x41_reg_write>

	/* Select Channel */
	REG_WRITE((adc->base + VADC_CHAN_SEL), adc->chan);
8f6316b4:	e5940000 	ldr	r0, [r4]
8f6316b8:	e5d41006 	ldrb	r1, [r4, #6]
8f6316bc:	e2800048 	add	r0, r0, #72	; 0x48
8f6316c0:	ebfffdc5 	bl	8f630ddc <pm8x41_reg_write>

	/* ADC digital param setup */
	adc_p = (adc->adc_param << VADC_DECIM_RATIO_SEL);
8f6316c4:	e5d41008 	ldrb	r1, [r4, #8]
	REG_WRITE((adc->base + VADC_DIG_ADC_PARAM), adc_p);
8f6316c8:	e5940000 	ldr	r0, [r4]
	adc_p = (adc->adc_param << VADC_DECIM_RATIO_SEL);
8f6316cc:	e1a01101 	lsl	r1, r1, #2
	REG_WRITE((adc->base + VADC_DIG_ADC_PARAM), adc_p);
8f6316d0:	e2800050 	add	r0, r0, #80	; 0x50
8f6316d4:	e20110fc 	and	r1, r1, #252	; 0xfc
8f6316d8:	ebfffdbf 	bl	8f630ddc <pm8x41_reg_write>

	/* hardware settling time */
	REG_WRITE((adc->base + VADC_HW_SETTLE_TIME), adc->hw_set_time);
8f6316dc:	e5940000 	ldr	r0, [r4]
8f6316e0:	e5d41009 	ldrb	r1, [r4, #9]
8f6316e4:	e2800051 	add	r0, r0, #81	; 0x51
8f6316e8:	ebfffdbb 	bl	8f630ddc <pm8x41_reg_write>

	/* For normal mode set the fast avg */
	REG_WRITE((adc->base + VADC_FAST_AVG), adc->fast_avg);
8f6316ec:	e5940000 	ldr	r0, [r4]
8f6316f0:	e5d4100a 	ldrb	r1, [r4, #10]
8f6316f4:	e280005a 	add	r0, r0, #90	; 0x5a
8f6316f8:	ebfffdb7 	bl	8f630ddc <pm8x41_reg_write>
		REG_WRITE((adc->base + VADC_EN_CTL), VADC_CTL_EN_BIT);
8f6316fc:	e5940000 	ldr	r0, [r4]
8f631700:	e3a01080 	mov	r1, #128	; 0x80
8f631704:	e2800046 	add	r0, r0, #70	; 0x46
8f631708:	ebfffdb3 	bl	8f630ddc <pm8x41_reg_write>
	REG_WRITE((adc->base + VADC_CONV_REQ), VADC_CON_REQ_BIT);
8f63170c:	e5940000 	ldr	r0, [r4]
8f631710:	e3a01080 	mov	r1, #128	; 0x80
8f631714:	e2800052 	add	r0, r0, #82	; 0x52
8f631718:	ebfffdaf 	bl	8f630ddc <pm8x41_reg_write>
8f63171c:	ea000001 	b	8f631728 <adc_configure+0xa8>
		udelay(10);
8f631720:	e3a0000a 	mov	r0, #10
8f631724:	ebff758c 	bl	8f60ed5c <udelay>
		status = REG_READ(adc->base + VADC_STATUS);
8f631728:	e5940000 	ldr	r0, [r4]
8f63172c:	e2800008 	add	r0, r0, #8
8f631730:	ebfffd50 	bl	8f630c78 <pm8x41_reg_read>
		if (status == VADC_STATUS_EOC) {
8f631734:	e2000003 	and	r0, r0, #3
8f631738:	e3500001 	cmp	r0, #1
8f63173c:	1afffff7 	bne	8f631720 <adc_configure+0xa0>
			dprintf(SPEW, "ADC conversion is complete\n");
8f631740:	e30b00bc 	movw	r0, #45244	; 0xb0bc
8f631744:	e3480f70 	movt	r0, #36720	; 0x8f70
8f631748:	eb000489 	bl	8f632974 <_dprintf>
	val = REG_READ(adc->base + VADC_REG_DATA_MSB);
8f63174c:	e5940000 	ldr	r0, [r4]
8f631750:	e2800061 	add	r0, r0, #97	; 0x61
8f631754:	ebfffd47 	bl	8f630c78 <pm8x41_reg_read>
	val = REG_READ(adc->base + VADC_REG_DATA_LSB);
8f631758:	e5943000 	ldr	r3, [r4]
	val = REG_READ(adc->base + VADC_REG_DATA_MSB);
8f63175c:	e1a05000 	mov	r5, r0
	val = REG_READ(adc->base + VADC_REG_DATA_LSB);
8f631760:	e2830060 	add	r0, r3, #96	; 0x60
8f631764:	ebfffd43 	bl	8f630c78 <pm8x41_reg_read>
		REG_WRITE((adc->base + VADC_EN_CTL), (uint8_t) (~VADC_CTL_EN_BIT));
8f631768:	e5943000 	ldr	r3, [r4]
8f63176c:	e3a0107f 	mov	r1, #127	; 0x7f
	val = REG_READ(adc->base + VADC_REG_DATA_LSB);
8f631770:	e1a04000 	mov	r4, r0
		REG_WRITE((adc->base + VADC_EN_CTL), (uint8_t) (~VADC_CTL_EN_BIT));
8f631774:	e2830046 	add	r0, r3, #70	; 0x46
8f631778:	ebfffd97 	bl	8f630ddc <pm8x41_reg_write>
	*result = ((*result) << 8) | val;
8f63177c:	e1840405 	orr	r0, r4, r5, lsl #8

	/* Disable vadc */
	adc_enable(adc, false);

	return result;
}
8f631780:	e59f3030 	ldr	r3, [pc, #48]	; 8f6317b8 <adc_configure+0x138>
	return result;
8f631784:	e6ff0070 	uxth	r0, r0
8f631788:	e3500b2a 	cmp	r0, #43008	; 0xa800
8f63178c:	23a00b2a 	movcs	r0, #43008	; 0xa800
8f631790:	e3500a06 	cmp	r0, #24576	; 0x6000
8f631794:	33a00a06 	movcc	r0, #24576	; 0x6000
}
8f631798:	e5932000 	ldr	r2, [r3]
8f63179c:	e59d3004 	ldr	r3, [r13, #4]
8f6317a0:	e0332002 	eors	r2, r3, r2
8f6317a4:	e3a03000 	mov	r3, #0
8f6317a8:	1a000001 	bne	8f6317b4 <adc_configure+0x134>
8f6317ac:	e28dd00c 	add	r13, r13, #12
8f6317b0:	e8bd8030 	pop	{r4, r5, r15}
8f6317b4:	eb000501 	bl	8f632bc0 <__stack_chk_fail>
8f6317b8:	8f74221c 	.word	0x8f74221c

8f6317bc <pm8x41_adc_channel_read>:
 * This API takes channel number as input
 * & returns the calibrated voltage as output
 * The calibrated result is the voltage in uVs
 */
uint32_t pm8x41_adc_channel_read(uint16_t ch_num)
{
8f6317bc:	e59f11a4 	ldr	r1, [pc, #420]	; 8f631968 <pm8x41_adc_channel_read+0x1ac>
8f6317c0:	e3a03000 	mov	r3, #0
8f6317c4:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f6317c8:	e3045560 	movw	r5, #17760	; 0x4560
8f6317cc:	e24dd014 	sub	r13, r13, #20
8f6317d0:	e3485f72 	movt	r5, #36722	; 0x8f72
8f6317d4:	e5911000 	ldr	r1, [r1]
8f6317d8:	e58d100c 	str	r1, [r13, #12]
8f6317dc:	e3a01000 	mov	r1, #0
	for(i = 0; i < ARRAY_SIZE(adc_data) ; i++) {
8f6317e0:	e1a02005 	mov	r2, r5
		if (chan_data->chan == ch_num)
8f6317e4:	e1d210b6 	ldrh	r1, [r2, #6]
		chan_data = &adc_data[i];
8f6317e8:	e1a0c003 	mov	r12, r3
		if (chan_data->chan == ch_num)
8f6317ec:	e1510000 	cmp	r1, r0
8f6317f0:	0a000004 	beq	8f631808 <pm8x41_adc_channel_read+0x4c>
	for(i = 0; i < ARRAY_SIZE(adc_data) ; i++) {
8f6317f4:	e2833001 	add	r3, r3, #1
8f6317f8:	e282200c 	add	r2, r2, #12
8f6317fc:	e3530004 	cmp	r3, #4
8f631800:	1afffff7 	bne	8f6317e4 <pm8x41_adc_channel_read+0x28>
8f631804:	e3a03003 	mov	r3, #3
		chan_data = &adc_data[i];
8f631808:	e3a0000c 	mov	r0, #12
	if(adc->calib_type == CALIB_ABS) {
8f63180c:	e0040c90 	mul	r4, r0, r12
	if (!adc) {
		dprintf(CRITICAL, "Error: requested channel is not supported: %u\n", ch_num);
		return 0;
	}

	result = adc_configure(adc);
8f631810:	e0205390 	mla	r0, r0, r3, r5
8f631814:	ebffff99 	bl	8f631680 <adc_configure>
	if(adc->calib_type == CALIB_ABS) {
8f631818:	e0853004 	add	r3, r5, r4
8f63181c:	e5d3700b 	ldrb	r7, [r3, #11]
8f631820:	e3570000 	cmp	r7, #0
	result = adc_configure(adc);
8f631824:	e1a06000 	mov	r6, r0
	if(adc->calib_type == CALIB_ABS) {
8f631828:	0a000010 	beq	8f631870 <pm8x41_adc_channel_read+0xb4>
	} else if(adc->calib_type == CALIB_RATIO) {
8f63182c:	e3570001 	cmp	r7, #1
	uint32_t calib_result = 0;
8f631830:	13a04000 	movne	r4, #0
	} else if(adc->calib_type == CALIB_RATIO) {
8f631834:	0a00002d 	beq	8f6318f0 <pm8x41_adc_channel_read+0x134>

	calib_result = vadc_calibrate(result, adc);

	dprintf(SPEW, "Result: Raw %u\tCalibrated:%u\n", result, calib_result);
8f631838:	e1a02004 	mov	r2, r4
8f63183c:	e30b00d8 	movw	r0, #45272	; 0xb0d8
8f631840:	e1a01006 	mov	r1, r6
8f631844:	e3480f70 	movt	r0, #36720	; 0x8f70
8f631848:	eb000449 	bl	8f632974 <_dprintf>

	return calib_result;
}
8f63184c:	e59f3114 	ldr	r3, [pc, #276]	; 8f631968 <pm8x41_adc_channel_read+0x1ac>
8f631850:	e5932000 	ldr	r2, [r3]
8f631854:	e59d300c 	ldr	r3, [r13, #12]
8f631858:	e0332002 	eors	r2, r3, r2
8f63185c:	e3a03000 	mov	r3, #0
8f631860:	1a00003f 	bne	8f631964 <pm8x41_adc_channel_read+0x1a8>
8f631864:	e1a00004 	mov	r0, r4
8f631868:	e28dd014 	add	r13, r13, #20
8f63186c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
		calib.base = adc->base;
8f631870:	e7953004 	ldr	r3, [r5, r4]
		calib1 = adc_configure(&calib);
8f631874:	e1a0000d 	mov	r0, r13
		calib.adc_param = VADC_DECIM_RATIO_VAL;
8f631878:	e3a09001 	mov	r9, #1
		calib.mode = VADC_MODE_NORMAL;
8f63187c:	e5cd7004 	strb	r7, [r13, #4]
		calib.fast_avg = 0x0;
8f631880:	e5cd700a 	strb	r7, [r13, #10]
		calib.chan = VREF_625_CHAN_ID;
8f631884:	e3a08009 	mov	r8, #9
		calib.base = adc->base;
8f631888:	e58d3000 	str	r3, [r13]
		calib.chan = VREF_125_CHAN_ID;
8f63188c:	e3a0300a 	mov	r3, #10
		calib.adc_param = VADC_DECIM_RATIO_VAL;
8f631890:	e1cd90b8 	strh	r9, [r13, #8]
		calib.chan = VREF_125_CHAN_ID;
8f631894:	e1cd30b6 	strh	r3, [r13, #6]
		calib1 = adc_configure(&calib);
8f631898:	ebffff78 	bl	8f631680 <adc_configure>
		calib.base = adc->base;
8f63189c:	e7953004 	ldr	r3, [r5, r4]
		calib.adc_param = VADC_DECIM_RATIO_VAL;
8f6318a0:	e1cd90b8 	strh	r9, [r13, #8]
		calib.mode = VADC_MODE_NORMAL;
8f6318a4:	e5cd7004 	strb	r7, [r13, #4]
		calib.base = adc->base;
8f6318a8:	e58d3000 	str	r3, [r13]
		calib.chan = VREF_625_CHAN_ID;
8f6318ac:	e1cd80b6 	strh	r8, [r13, #6]
		calib.fast_avg = 0x0;
8f6318b0:	e5cd700a 	strb	r7, [r13, #10]
		calib1 = adc_configure(&calib);
8f6318b4:	e1a01000 	mov	r1, r0
		calib2 = adc_configure(&calib);
8f6318b8:	e1a0000d 	mov	r0, r13
		calib1 = adc_configure(&calib);
8f6318bc:	e1a04001 	mov	r4, r1
		calib2 = adc_configure(&calib);
8f6318c0:	ebffff6e 	bl	8f631680 <adc_configure>
8f6318c4:	e1a05000 	mov	r5, r0
		mul = VREF_625_MV / (calib1 - calib2);
8f6318c8:	e3080968 	movw	r0, #35176	; 0x8968
8f6318cc:	e0441005 	sub	r1, r4, r5
8f6318d0:	e3400009 	movt	r0, #9
8f6318d4:	fa002d5d 	blx	8f63ce50 <__divsi3>
		calib_result = (result - calib2) * mul;
8f6318d8:	e0465005 	sub	r5, r6, r5
		calib_result += VREF_625_MV;
8f6318dc:	e3084968 	movw	r4, #35176	; 0x8968
8f6318e0:	e7df4818 	bfi	r4, r8, #16, #16
8f6318e4:	e0244095 	mla	r4, r5, r0, r4
		calib_result *= OFFSET_GAIN_DNOM;
8f6318e8:	e0844914 	add	r4, r4, r4, lsl r9
		calib_result /= OFFSET_GAIN_NUME;
8f6318ec:	eaffffd1 	b	8f631838 <pm8x41_adc_channel_read+0x7c>
		calib.base = adc->base;
8f6318f0:	e7953004 	ldr	r3, [r5, r4]
		calib1 = adc_configure(&calib);
8f6318f4:	e1a0000d 	mov	r0, r13
		calib.mode = VADC_MODE_NORMAL;
8f6318f8:	e3a08000 	mov	r8, #0
		calib.adc_param = VADC_DECIM_RATIO_VAL;
8f6318fc:	e1cd70b8 	strh	r7, [r13, #8]
		calib.mode = VADC_MODE_NORMAL;
8f631900:	e5cd8004 	strb	r8, [r13, #4]
		calib.base = adc->base;
8f631904:	e58d3000 	str	r3, [r13]
		calib.chan = VDD_VADC_CHAN_ID;
8f631908:	e3a0300f 	mov	r3, #15
		calib.fast_avg = 0;
8f63190c:	e5cd800a 	strb	r8, [r13, #10]
		calib.chan = VDD_VADC_CHAN_ID;
8f631910:	e1cd30b6 	strh	r3, [r13, #6]
		calib1 = adc_configure(&calib);
8f631914:	ebffff59 	bl	8f631680 <adc_configure>
		calib.base = adc->base;
8f631918:	e7953004 	ldr	r3, [r5, r4]
		calib.adc_param = VADC_DECIM_RATIO_VAL;
8f63191c:	e1cd70b8 	strh	r7, [r13, #8]
		calib.mode = VADC_MODE_NORMAL;
8f631920:	e5cd8004 	strb	r8, [r13, #4]
		calib.base = adc->base;
8f631924:	e58d3000 	str	r3, [r13]
		calib.chan = GND_REF_CHAN_ID;
8f631928:	e3a0300e 	mov	r3, #14
		calib.fast_avg = 0;
8f63192c:	e5cd800a 	strb	r8, [r13, #10]
		calib.chan = GND_REF_CHAN_ID;
8f631930:	e1cd30b6 	strh	r3, [r13, #6]
		calib1 = adc_configure(&calib);
8f631934:	e1a01000 	mov	r1, r0
		calib2 = adc_configure(&calib);
8f631938:	e1a0000d 	mov	r0, r13
		calib1 = adc_configure(&calib);
8f63193c:	e1a04001 	mov	r4, r1
		calib2 = adc_configure(&calib);
8f631940:	ebffff4e 	bl	8f631680 <adc_configure>
8f631944:	e1a05000 	mov	r5, r0
		mul = VREF_18_V / (calib1 - calib2);
8f631948:	e3070740 	movw	r0, #30528	; 0x7740
8f63194c:	e0441005 	sub	r1, r4, r5
8f631950:	e340001b 	movt	r0, #27
8f631954:	fa002d3d 	blx	8f63ce50 <__divsi3>
		calib_result = (result - calib2) * mul;
8f631958:	e0465005 	sub	r5, r6, r5
8f63195c:	e0040095 	mul	r4, r5, r0
8f631960:	eaffffb4 	b	8f631838 <pm8x41_adc_channel_read+0x7c>
}
8f631964:	eb000495 	bl	8f632bc0 <__stack_chk_fail>
8f631968:	8f74221c 	.word	0x8f74221c

8f63196c <pm8x41_get_batt_voltage>:
/*
 * API: pm8x41_get_batt_voltage
 * Get calibrated battery voltage from VADC, in UV
 */
uint32_t pm8x41_get_batt_voltage()
{
8f63196c:	e59f3058 	ldr	r3, [pc, #88]	; 8f6319cc <pm8x41_get_batt_voltage+0x60>
	uint32_t voltage;

	voltage = pm8x41_adc_channel_read(VADC_BAT_VOL_CHAN_ID);
8f631970:	e3a00006 	mov	r0, #6
{
8f631974:	e92d4010 	push	{r4, r14}
8f631978:	e24dd008 	sub	r13, r13, #8
8f63197c:	e5933000 	ldr	r3, [r3]
8f631980:	e58d3004 	str	r3, [r13, #4]
8f631984:	e3a03000 	mov	r3, #0
	voltage = pm8x41_adc_channel_read(VADC_BAT_VOL_CHAN_ID);
8f631988:	ebffff8b 	bl	8f6317bc <pm8x41_adc_channel_read>

	if(!voltage)
8f63198c:	e2504000 	subs	r4, r0, #0
8f631990:	0a000008 	beq	8f6319b8 <pm8x41_get_batt_voltage+0x4c>
		dprintf(CRITICAL, "Error getting battery Voltage\n");
		return 0;
	}

	return voltage;
}
8f631994:	e59f3030 	ldr	r3, [pc, #48]	; 8f6319cc <pm8x41_get_batt_voltage+0x60>
8f631998:	e5932000 	ldr	r2, [r3]
8f63199c:	e59d3004 	ldr	r3, [r13, #4]
8f6319a0:	e0332002 	eors	r2, r3, r2
8f6319a4:	e3a03000 	mov	r3, #0
8f6319a8:	1a000006 	bne	8f6319c8 <pm8x41_get_batt_voltage+0x5c>
8f6319ac:	e1a00004 	mov	r0, r4
8f6319b0:	e28dd008 	add	r13, r13, #8
8f6319b4:	e8bd8010 	pop	{r4, r15}
		dprintf(CRITICAL, "Error getting battery Voltage\n");
8f6319b8:	e30b00f8 	movw	r0, #45304	; 0xb0f8
8f6319bc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6319c0:	eb0003eb 	bl	8f632974 <_dprintf>
		return 0;
8f6319c4:	eafffff2 	b	8f631994 <pm8x41_get_batt_voltage+0x28>
}
8f6319c8:	eb00047c 	bl	8f632bc0 <__stack_chk_fail>
8f6319cc:	8f74221c 	.word	0x8f74221c

8f6319d0 <pm_comm_read_byte>:
{
    SPMI_BUS_SUCCESS,
};

pm_err_flag_type pm_comm_read_byte(uint32 slave_id, uint32 addr, uint8* data, uint8 priority)
{
8f6319d0:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f6319d4:	e1a07003 	mov	r7, r3
8f6319d8:	e59f307c 	ldr	r3, [pc, #124]	; 8f631a5c <pm_comm_read_byte+0x8c>
8f6319dc:	e24dd00c 	sub	r13, r13, #12
8f6319e0:	e1a04001 	mov	r4, r1
8f6319e4:	e1a05000 	mov	r5, r0
8f6319e8:	e5933000 	ldr	r3, [r3]
8f6319ec:	e58d3004 	str	r3, [r13, #4]
8f6319f0:	e3a03000 	mov	r3, #0
8f6319f4:	e1a06002 	mov	r6, r2
    pm_err_flag_type     err = PM_ERR_FLAG__SUCCESS ;
    SpmiBus_ResultType   spmi_result = SPMI_BUS_SUCCESS;
    
    if(TRUE == spmi_initialized())
8f6319f8:	ebff7dc2 	bl	8f611108 <spmi_initialized>
8f6319fc:	e250c001 	subs	r12, r0, #1
8f631a00:	13a0c001 	movne	r12, #1
    {
        /* check for out-of-bounds index */
        if ( addr > PM_MAX_REGS)
8f631a04:	e3540801 	cmp	r4, #65536	; 0x10000
8f631a08:	238cc001 	orrcs	r12, r12, #1
8f631a0c:	e35c0000 	cmp	r12, #0
8f631a10:	0a000008 	beq	8f631a38 <pm_comm_read_byte+0x68>
        }
        else
        {
            spmi_result = spmi_reg_read(slave_id, addr, data, priority);

            if ( spmi_result != SPMI_BUS_SUCCESS ) { err = PM_ERR_FLAG__SPMI_OPT_ERR ; }
8f631a14:	e3a00009 	mov	r0, #9
    {
        err = PM_ERR_FLAG__SPMI_OPT_ERR ;
    }

    return err ;
}
8f631a18:	e59f303c 	ldr	r3, [pc, #60]	; 8f631a5c <pm_comm_read_byte+0x8c>
8f631a1c:	e5932000 	ldr	r2, [r3]
8f631a20:	e59d3004 	ldr	r3, [r13, #4]
8f631a24:	e0332002 	eors	r2, r3, r2
8f631a28:	e3a03000 	mov	r3, #0
8f631a2c:	1a000009 	bne	8f631a58 <pm_comm_read_byte+0x88>
8f631a30:	e28dd00c 	add	r13, r13, #12
8f631a34:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
            spmi_result = spmi_reg_read(slave_id, addr, data, priority);
8f631a38:	e6ff1074 	uxth	r1, r4
8f631a3c:	e1a03007 	mov	r3, r7
8f631a40:	e1a02006 	mov	r2, r6
8f631a44:	e1a00005 	mov	r0, r5
8f631a48:	ebfffcab 	bl	8f630cfc <spmi_reg_read>
            if ( spmi_result != SPMI_BUS_SUCCESS ) { err = PM_ERR_FLAG__SPMI_OPT_ERR ; }
8f631a4c:	e3500000 	cmp	r0, #0
8f631a50:	0afffff0 	beq	8f631a18 <pm_comm_read_byte+0x48>
8f631a54:	eaffffee 	b	8f631a14 <pm_comm_read_byte+0x44>
}
8f631a58:	eb000458 	bl	8f632bc0 <__stack_chk_fail>
8f631a5c:	8f74221c 	.word	0x8f74221c

8f631a60 <pm_comm_read_byte_mask>:

pm_err_flag_type pm_comm_read_byte_mask(uint32 slave_id, uint32 addr, uint8 mask, uint8* data, uint8 priority)
{
8f631a60:	e92d4030 	push	{r4, r5, r14}
8f631a64:	e1a05002 	mov	r5, r2
8f631a68:	e24dd00c 	sub	r13, r13, #12
8f631a6c:	e59f2054 	ldr	r2, [pc, #84]	; 8f631ac8 <pm_comm_read_byte_mask+0x68>
8f631a70:	e1a04003 	mov	r4, r3
    pm_err_flag_type     err = PM_ERR_FLAG__SUCCESS ;
   
    err = spmi_reg_read(slave_id, addr, data, priority);
8f631a74:	e6ff1071 	uxth	r1, r1
8f631a78:	e5dd3018 	ldrb	r3, [r13, #24]
{
8f631a7c:	e5922000 	ldr	r2, [r2]
8f631a80:	e58d2004 	str	r2, [r13, #4]
8f631a84:	e3a02000 	mov	r2, #0
    err = spmi_reg_read(slave_id, addr, data, priority);
8f631a88:	e1a02004 	mov	r2, r4
8f631a8c:	ebfffc9a 	bl	8f630cfc <spmi_reg_read>
        *data = *data & mask; 
    }

    
    return err ;
}
8f631a90:	e59f3030 	ldr	r3, [pc, #48]	; 8f631ac8 <pm_comm_read_byte_mask+0x68>
    if ( err != PM_ERR_FLAG__SUCCESS ) 
8f631a94:	e21000ff 	ands	r0, r0, #255	; 0xff
        *data = *data & mask; 
8f631a98:	05d42000 	ldrbeq	r2, [r4]
        err = PM_ERR_FLAG__SPMI_OPT_ERR ; 
8f631a9c:	13a00009 	movne	r0, #9
        *data = *data & mask; 
8f631aa0:	00022005 	andeq	r2, r2, r5
8f631aa4:	05c42000 	strbeq	r2, [r4]
}
8f631aa8:	e5932000 	ldr	r2, [r3]
8f631aac:	e59d3004 	ldr	r3, [r13, #4]
8f631ab0:	e0332002 	eors	r2, r3, r2
8f631ab4:	e3a03000 	mov	r3, #0
8f631ab8:	1a000001 	bne	8f631ac4 <pm_comm_read_byte_mask+0x64>
8f631abc:	e28dd00c 	add	r13, r13, #12
8f631ac0:	e8bd8030 	pop	{r4, r5, r15}
8f631ac4:	eb00043d 	bl	8f632bc0 <__stack_chk_fail>
8f631ac8:	8f74221c 	.word	0x8f74221c

8f631acc <pm_comm_write_byte_mask>:

    return err ;
}

pm_err_flag_type pm_comm_write_byte_mask(uint32 slave_id, uint32 addr, uint8 mask, uint8 value, uint8 priority)
{
8f631acc:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f631ad0:	e1a06003 	mov	r6, r3
8f631ad4:	e24dd008 	sub	r13, r13, #8
8f631ad8:	e59f30c0 	ldr	r3, [pc, #192]	; 8f631ba0 <pm_comm_write_byte_mask+0xd4>
8f631adc:	e1a04001 	mov	r4, r1
8f631ae0:	e1a05000 	mov	r5, r0
8f631ae4:	e5933000 	ldr	r3, [r3]
8f631ae8:	e58d3004 	str	r3, [r13, #4]
8f631aec:	e3a03000 	mov	r3, #0
8f631af0:	e5dd8020 	ldrb	r8, [r13, #32]
    pm_err_flag_type         err = PM_ERR_FLAG__SUCCESS ;
    SpmiBus_ResultType       spmi_result = SPMI_BUS_SUCCESS;
    uint8                    data = 0 ;
8f631af4:	e3a03000 	mov	r3, #0
{
8f631af8:	e1a07002 	mov	r7, r2
    uint8                    data = 0 ;
8f631afc:	e5cd3003 	strb	r3, [r13, #3]

    if(TRUE == spmi_initialized())
8f631b00:	ebff7d80 	bl	8f611108 <spmi_initialized>
8f631b04:	e250c001 	subs	r12, r0, #1
8f631b08:	13a0c001 	movne	r12, #1
    {
        /* check for out-of-bounds index */
        if ( addr > PM_MAX_REGS)
8f631b0c:	e3540801 	cmp	r4, #65536	; 0x10000
8f631b10:	238cc001 	orrcs	r12, r12, #1
8f631b14:	e35c0000 	cmp	r12, #0
8f631b18:	0a000008 	beq	8f631b40 <pm_comm_write_byte_mask+0x74>
                data &= (~mask) ; 
                data |= (value & mask) ;

                spmi_result = spmi_reg_write(slave_id, addr, &data, priority);

                if ( spmi_result != SPMI_BUS_SUCCESS ) { err = PM_ERR_FLAG__SPMI_OPT_ERR ; }
8f631b1c:	e3a00009 	mov	r0, #9
        err = PM_ERR_FLAG__SPMI_OPT_ERR ;
    }


    return err ;
}
8f631b20:	e59f3078 	ldr	r3, [pc, #120]	; 8f631ba0 <pm_comm_write_byte_mask+0xd4>
8f631b24:	e5932000 	ldr	r2, [r3]
8f631b28:	e59d3004 	ldr	r3, [r13, #4]
8f631b2c:	e0332002 	eors	r2, r3, r2
8f631b30:	e3a03000 	mov	r3, #0
8f631b34:	1a000018 	bne	8f631b9c <pm_comm_write_byte_mask+0xd0>
8f631b38:	e28dd008 	add	r13, r13, #8
8f631b3c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
            spmi_result = spmi_reg_read(slave_id, addr, &data, priority);
8f631b40:	e6ff4074 	uxth	r4, r4
8f631b44:	e28d2003 	add	r2, r13, #3
8f631b48:	e1a03008 	mov	r3, r8
8f631b4c:	e1a00005 	mov	r0, r5
8f631b50:	e1a01004 	mov	r1, r4
8f631b54:	ebfffc68 	bl	8f630cfc <spmi_reg_read>
            if ( spmi_result == SPMI_BUS_SUCCESS )
8f631b58:	e3500000 	cmp	r0, #0
8f631b5c:	0a000001 	beq	8f631b68 <pm_comm_write_byte_mask+0x9c>
    pm_err_flag_type         err = PM_ERR_FLAG__SUCCESS ;
8f631b60:	e3a00000 	mov	r0, #0
8f631b64:	eaffffed 	b	8f631b20 <pm_comm_write_byte_mask+0x54>
                data &= (~mask) ; 
8f631b68:	e5ddc003 	ldrb	r12, [r13, #3]
                data |= (value & mask) ;
8f631b6c:	e0066007 	and	r6, r6, r7
                spmi_result = spmi_reg_write(slave_id, addr, &data, priority);
8f631b70:	e28d2003 	add	r2, r13, #3
8f631b74:	e1a03008 	mov	r3, r8
                data &= (~mask) ; 
8f631b78:	e1cc7007 	bic	r7, r12, r7
                spmi_result = spmi_reg_write(slave_id, addr, &data, priority);
8f631b7c:	e1a01004 	mov	r1, r4
8f631b80:	e1a00005 	mov	r0, r5
                data |= (value & mask) ;
8f631b84:	e1876006 	orr	r6, r7, r6
8f631b88:	e5cd6003 	strb	r6, [r13, #3]
                spmi_result = spmi_reg_write(slave_id, addr, &data, priority);
8f631b8c:	ebfffc76 	bl	8f630d6c <spmi_reg_write>
                if ( spmi_result != SPMI_BUS_SUCCESS ) { err = PM_ERR_FLAG__SPMI_OPT_ERR ; }
8f631b90:	e3500000 	cmp	r0, #0
8f631b94:	0afffff1 	beq	8f631b60 <pm_comm_write_byte_mask+0x94>
8f631b98:	eaffffdf 	b	8f631b1c <pm_comm_write_byte_mask+0x50>
}
8f631b9c:	eb000407 	bl	8f632bc0 <__stack_chk_fail>
8f631ba0:	8f74221c 	.word	0x8f74221c

8f631ba4 <pm_fg_adc_usr_enable_bcl_monitoring>:
*          version of the PMIC.
*          PM_ERR_FLAG__SUCCESS               = SUCCESS.
*
*/
pm_err_flag_type pm_fg_adc_usr_enable_bcl_monitoring(uint32 pmic_device, boolean enable)
{
8f631ba4:	e59f307c 	ldr	r3, [pc, #124]	; 8f631c28 <pm_fg_adc_usr_enable_bcl_monitoring+0x84>
8f631ba8:	e92d4010 	push	{r4, r14}
8f631bac:	e24dd010 	sub	r13, r13, #16
8f631bb0:	e5933000 	ldr	r3, [r3]
8f631bb4:	e58d300c 	str	r3, [r13, #12]
8f631bb8:	e3a03000 	mov	r3, #0
8f631bbc:	e1a04001 	mov	r4, r1
  pm_err_flag_type err_flag = PM_ERR_FLAG__SUCCESS;
  pm_register_address_type  fg_adc_usr_bcl_monitoring = 0x00;
  uint8 mask = 0x80;

  pm_fg_data_type* fg_adc_usr_ptr = pm_fg_get_data(pmic_device);
8f631bc0:	eb000151 	bl	8f63210c <pm_fg_get_data>

  if (NULL == fg_adc_usr_ptr)
8f631bc4:	e3500000 	cmp	r0, #0
  {
    return PM_ERR_FLAG__FEATURE_NOT_SUPPORTED;
8f631bc8:	03a00017 	moveq	r0, #23
  if (NULL == fg_adc_usr_ptr)
8f631bcc:	0a00000c 	beq	8f631c04 <pm_fg_adc_usr_enable_bcl_monitoring+0x60>
  }
  else
  {
    fg_adc_usr_bcl_monitoring = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_en_ctl;
    err_flag = pm_comm_write_byte_mask(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_bcl_monitoring, mask, (pm_register_data_type)(enable << 7), 0);
8f631bd0:	e8900005 	ldm	r0, {r0, r2}
8f631bd4:	e1a03384 	lsl	r3, r4, #7
8f631bd8:	e3a0c000 	mov	r12, #0
8f631bdc:	e2033080 	and	r3, r3, #128	; 0x80
    fg_adc_usr_bcl_monitoring = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_en_ctl;
8f631be0:	e592200c 	ldr	r2, [r2, #12]
    err_flag = pm_comm_write_byte_mask(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_bcl_monitoring, mask, (pm_register_data_type)(enable << 7), 0);
8f631be4:	e5900000 	ldr	r0, [r0]
    fg_adc_usr_bcl_monitoring = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_en_ctl;
8f631be8:	e1d210b0 	ldrh	r1, [r2]
8f631bec:	e1d221ba 	ldrh	r2, [r2, #26]
    err_flag = pm_comm_write_byte_mask(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_bcl_monitoring, mask, (pm_register_data_type)(enable << 7), 0);
8f631bf0:	e58dc000 	str	r12, [r13]
    fg_adc_usr_bcl_monitoring = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_en_ctl;
8f631bf4:	e0811002 	add	r1, r1, r2
    err_flag = pm_comm_write_byte_mask(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_bcl_monitoring, mask, (pm_register_data_type)(enable << 7), 0);
8f631bf8:	e3a02080 	mov	r2, #128	; 0x80
8f631bfc:	e6ff1071 	uxth	r1, r1
8f631c00:	ebffffb1 	bl	8f631acc <pm_comm_write_byte_mask>
  }

  return err_flag;

}
8f631c04:	e59f301c 	ldr	r3, [pc, #28]	; 8f631c28 <pm_fg_adc_usr_enable_bcl_monitoring+0x84>
8f631c08:	e5932000 	ldr	r2, [r3]
8f631c0c:	e59d300c 	ldr	r3, [r13, #12]
8f631c10:	e0332002 	eors	r2, r3, r2
8f631c14:	e3a03000 	mov	r3, #0
8f631c18:	1a000001 	bne	8f631c24 <pm_fg_adc_usr_enable_bcl_monitoring+0x80>
8f631c1c:	e28dd010 	add	r13, r13, #16
8f631c20:	e8bd8010 	pop	{r4, r15}
8f631c24:	eb0003e5 	bl	8f632bc0 <__stack_chk_fail>
8f631c28:	8f74221c 	.word	0x8f74221c

8f631c2c <pm_fg_adc_usr_get_bcl_monitoring_sts>:
*          version of the PMIC.
*          PM_ERR_FLAG__SUCCESS               = SUCCESS.
*
*/
pm_err_flag_type pm_fg_adc_usr_get_bcl_monitoring_sts(uint32 pmic_device, boolean *enable)
{
8f631c2c:	e92d4030 	push	{r4, r5, r14}
8f631c30:	e24dd014 	sub	r13, r13, #20
8f631c34:	e59f307c 	ldr	r3, [pc, #124]	; 8f631cb8 <pm_fg_adc_usr_get_bcl_monitoring_sts+0x8c>
  pm_err_flag_type err_flag = PM_ERR_FLAG__SUCCESS;
  pm_register_address_type  fg_adc_usr_bcl_monitoring = 0x00;
  pm_register_data_type data = 0x00;
8f631c38:	e3a05000 	mov	r5, #0
{
8f631c3c:	e1a04001 	mov	r4, r1
8f631c40:	e5933000 	ldr	r3, [r3]
8f631c44:	e58d300c 	str	r3, [r13, #12]
8f631c48:	e3a03000 	mov	r3, #0
  pm_register_data_type data = 0x00;
8f631c4c:	e5cd500b 	strb	r5, [r13, #11]
  uint8 mask = 0x80;

  pm_fg_data_type* fg_adc_usr_ptr = pm_fg_get_data(pmic_device);
8f631c50:	eb00012d 	bl	8f63210c <pm_fg_get_data>

  if (NULL == fg_adc_usr_ptr)
8f631c54:	e3500000 	cmp	r0, #0
  {
    return PM_ERR_FLAG__FEATURE_NOT_SUPPORTED;
8f631c58:	03a00017 	moveq	r0, #23
  if (NULL == fg_adc_usr_ptr)
8f631c5c:	0a00000c 	beq	8f631c94 <pm_fg_adc_usr_get_bcl_monitoring_sts+0x68>
  }
  else
  {
    fg_adc_usr_bcl_monitoring = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_en_ctl;
    err_flag = pm_comm_read_byte_mask(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_bcl_monitoring, mask, &data, 0);
8f631c60:	e1c020d0 	ldrd	r2, [r0]
    fg_adc_usr_bcl_monitoring = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_en_ctl;
8f631c64:	e593300c 	ldr	r3, [r3, #12]
    err_flag = pm_comm_read_byte_mask(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_bcl_monitoring, mask, &data, 0);
8f631c68:	e5920000 	ldr	r0, [r2]
8f631c6c:	e3a02080 	mov	r2, #128	; 0x80
    fg_adc_usr_bcl_monitoring = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_en_ctl;
8f631c70:	e1d310b0 	ldrh	r1, [r3]
8f631c74:	e1d331ba 	ldrh	r3, [r3, #26]
    err_flag = pm_comm_read_byte_mask(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_bcl_monitoring, mask, &data, 0);
8f631c78:	e58d5000 	str	r5, [r13]
    fg_adc_usr_bcl_monitoring = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_en_ctl;
8f631c7c:	e0811003 	add	r1, r1, r3
    err_flag = pm_comm_read_byte_mask(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_bcl_monitoring, mask, &data, 0);
8f631c80:	e28d300b 	add	r3, r13, #11
8f631c84:	e6ff1071 	uxth	r1, r1
8f631c88:	ebffff74 	bl	8f631a60 <pm_comm_read_byte_mask>
    *enable = (boolean )data;
8f631c8c:	e5dd300b 	ldrb	r3, [r13, #11]
8f631c90:	e5843000 	str	r3, [r4]
  }

  return err_flag;

}
8f631c94:	e59f301c 	ldr	r3, [pc, #28]	; 8f631cb8 <pm_fg_adc_usr_get_bcl_monitoring_sts+0x8c>
8f631c98:	e5932000 	ldr	r2, [r3]
8f631c9c:	e59d300c 	ldr	r3, [r13, #12]
8f631ca0:	e0332002 	eors	r2, r3, r2
8f631ca4:	e3a03000 	mov	r3, #0
8f631ca8:	1a000001 	bne	8f631cb4 <pm_fg_adc_usr_get_bcl_monitoring_sts+0x88>
8f631cac:	e28dd014 	add	r13, r13, #20
8f631cb0:	e8bd8030 	pop	{r4, r5, r15}
8f631cb4:	eb0003c1 	bl	8f632bc0 <__stack_chk_fail>
8f631cb8:	8f74221c 	.word	0x8f74221c

8f631cbc <pm_fg_adc_usr_get_bcl_values>:
*          version of the PMIC.
*          PM_ERR_FLAG__SUCCESS               = SUCCESS.
*
*/
pm_err_flag_type pm_fg_adc_usr_get_bcl_values(uint32 pmic_device, boolean *enable)
{
8f631cbc:	e92d4030 	push	{r4, r5, r14}
8f631cc0:	e24dd014 	sub	r13, r13, #20
8f631cc4:	e59f307c 	ldr	r3, [pc, #124]	; 8f631d48 <pm_fg_adc_usr_get_bcl_values+0x8c>
  pm_err_flag_type err_flag = PM_ERR_FLAG__SUCCESS;
  pm_register_address_type  fg_adc_usr_bcl_values = 0x00;
  pm_register_data_type data = 0x00;
8f631cc8:	e3a05000 	mov	r5, #0
{
8f631ccc:	e1a04001 	mov	r4, r1
8f631cd0:	e5933000 	ldr	r3, [r3]
8f631cd4:	e58d300c 	str	r3, [r13, #12]
8f631cd8:	e3a03000 	mov	r3, #0
  pm_register_data_type data = 0x00;
8f631cdc:	e5cd500b 	strb	r5, [r13, #11]
  uint8 mask = 0x80;

  pm_fg_data_type* fg_adc_usr_ptr = pm_fg_get_data(pmic_device);
8f631ce0:	eb000109 	bl	8f63210c <pm_fg_get_data>

  if (NULL == fg_adc_usr_ptr)
8f631ce4:	e3500000 	cmp	r0, #0
  {
    return PM_ERR_FLAG__FEATURE_NOT_SUPPORTED;
8f631ce8:	03a00017 	moveq	r0, #23
  if (NULL == fg_adc_usr_ptr)
8f631cec:	0a00000c 	beq	8f631d24 <pm_fg_adc_usr_get_bcl_values+0x68>
  }
  else
  {
    fg_adc_usr_bcl_values = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_bcl_values;
    err_flag = pm_comm_read_byte_mask(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_bcl_values, mask, &data, 0);
8f631cf0:	e1c020d0 	ldrd	r2, [r0]
    fg_adc_usr_bcl_values = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_bcl_values;
8f631cf4:	e593300c 	ldr	r3, [r3, #12]
    err_flag = pm_comm_read_byte_mask(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_bcl_values, mask, &data, 0);
8f631cf8:	e5920000 	ldr	r0, [r2]
8f631cfc:	e3a02080 	mov	r2, #128	; 0x80
    fg_adc_usr_bcl_values = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_bcl_values;
8f631d00:	e1d310b0 	ldrh	r1, [r3]
8f631d04:	e1d332b0 	ldrh	r3, [r3, #32]
    err_flag = pm_comm_read_byte_mask(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_bcl_values, mask, &data, 0);
8f631d08:	e58d5000 	str	r5, [r13]
    fg_adc_usr_bcl_values = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_bcl_values;
8f631d0c:	e0811003 	add	r1, r1, r3
    err_flag = pm_comm_read_byte_mask(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_bcl_values, mask, &data, 0);
8f631d10:	e28d300b 	add	r3, r13, #11
8f631d14:	e6ff1071 	uxth	r1, r1
8f631d18:	ebffff50 	bl	8f631a60 <pm_comm_read_byte_mask>
    *enable = (boolean )data;
8f631d1c:	e5dd300b 	ldrb	r3, [r13, #11]
8f631d20:	e5843000 	str	r3, [r4]
  }

  return err_flag;

}
8f631d24:	e59f301c 	ldr	r3, [pc, #28]	; 8f631d48 <pm_fg_adc_usr_get_bcl_values+0x8c>
8f631d28:	e5932000 	ldr	r2, [r3]
8f631d2c:	e59d300c 	ldr	r3, [r13, #12]
8f631d30:	e0332002 	eors	r2, r3, r2
8f631d34:	e3a03000 	mov	r3, #0
8f631d38:	1a000001 	bne	8f631d44 <pm_fg_adc_usr_get_bcl_values+0x88>
8f631d3c:	e28dd014 	add	r13, r13, #20
8f631d40:	e8bd8030 	pop	{r4, r5, r15}
8f631d44:	eb00039d 	bl	8f632bc0 <__stack_chk_fail>
8f631d48:	8f74221c 	.word	0x8f74221c

8f631d4c <pm_fg_adc_usr_get_vbat>:
*          version of the PMIC.
*          PM_ERR_FLAG__SUCCESS               = SUCCESS.
*
*/
pm_err_flag_type pm_fg_adc_usr_get_vbat(uint32 pmic_device, uint32 *vbat_adc)
{
8f631d4c:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f631d50:	e24dd008 	sub	r13, r13, #8
8f631d54:	e59f30e4 	ldr	r3, [pc, #228]	; 8f631e40 <pm_fg_adc_usr_get_vbat+0xf4>
  pm_err_flag_type err_flag = PM_ERR_FLAG__SUCCESS;
  pm_register_address_type  fg_adc_usr_vbat = 0x00;
  pm_register_address_type  fg_adc_usr_vbat_cp = 0x00;
  pm_register_data_type data = 0x00;
8f631d58:	e3a05000 	mov	r5, #0
{
8f631d5c:	e1a06001 	mov	r6, r1
8f631d60:	e5933000 	ldr	r3, [r3]
8f631d64:	e58d3004 	str	r3, [r13, #4]
8f631d68:	e3a03000 	mov	r3, #0
  pm_register_data_type data = 0x00;
8f631d6c:	e5cd5002 	strb	r5, [r13, #2]
  pm_register_data_type data1 = 0x00;
8f631d70:	e5cd5003 	strb	r5, [r13, #3]

  //Compare data thrice in copy register and original register to make sure we have right data
  uint32  total_count = 3;
  uint32  count = 0;

  pm_fg_data_type* fg_adc_usr_ptr = pm_fg_get_data(pmic_device);
8f631d74:	eb0000e4 	bl	8f63210c <pm_fg_get_data>

  *vbat_adc = 0;
8f631d78:	e5865000 	str	r5, [r6]

  if (NULL == fg_adc_usr_ptr)
8f631d7c:	e2504000 	subs	r4, r0, #0
8f631d80:	0a00002b 	beq	8f631e34 <pm_fg_adc_usr_get_vbat+0xe8>
  {
    return PM_ERR_FLAG__FEATURE_NOT_SUPPORTED;
  }
  else
  {
    fg_adc_usr_vbat = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_vbat;
8f631d84:	e5943004 	ldr	r3, [r4, #4]
    fg_adc_usr_vbat_cp = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_vbat_cp;

    do {
      err_flag = pm_comm_read_byte(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_vbat, &data1, 0);
      err_flag = pm_comm_read_byte(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_vbat_cp, &data, 0);
8f631d88:	e3a08003 	mov	r8, #3
    fg_adc_usr_vbat = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_vbat;
8f631d8c:	e593300c 	ldr	r3, [r3, #12]
8f631d90:	e1d350b0 	ldrh	r5, [r3]
8f631d94:	e1d372b4 	ldrh	r7, [r3, #36]	; 0x24
    fg_adc_usr_vbat_cp = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_vbat_cp;
8f631d98:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
    fg_adc_usr_vbat = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_vbat;
8f631d9c:	e0857007 	add	r7, r5, r7
    fg_adc_usr_vbat_cp = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_vbat_cp;
8f631da0:	e0855003 	add	r5, r5, r3
      err_flag = pm_comm_read_byte(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_vbat, &data1, 0);
8f631da4:	e6ff7077 	uxth	r7, r7
      err_flag = pm_comm_read_byte(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_vbat_cp, &data, 0);
8f631da8:	e6ff5075 	uxth	r5, r5
      err_flag = pm_comm_read_byte(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_vbat, &data1, 0);
8f631dac:	e5941000 	ldr	r1, [r4]
8f631db0:	e28d2003 	add	r2, r13, #3
8f631db4:	e3a03000 	mov	r3, #0
8f631db8:	e5910000 	ldr	r0, [r1]
8f631dbc:	e1a01007 	mov	r1, r7
8f631dc0:	ebffff02 	bl	8f6319d0 <pm_comm_read_byte>
      err_flag = pm_comm_read_byte(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_vbat_cp, &data, 0);
8f631dc4:	e5941000 	ldr	r1, [r4]
8f631dc8:	e28d2002 	add	r2, r13, #2
8f631dcc:	e3a03000 	mov	r3, #0
8f631dd0:	e5910000 	ldr	r0, [r1]
8f631dd4:	e1a01005 	mov	r1, r5
8f631dd8:	ebfffefc 	bl	8f6319d0 <pm_comm_read_byte>

      if(data == data1)
8f631ddc:	e5dd2002 	ldrb	r2, [r13, #2]
8f631de0:	e5dd3003 	ldrb	r3, [r13, #3]
8f631de4:	e1530002 	cmp	r3, r2
8f631de8:	0a00000d 	beq	8f631e24 <pm_fg_adc_usr_get_vbat+0xd8>
      {
        break;
      }

      if((total_count - 1) == count)
8f631dec:	e3580001 	cmp	r8, #1
        err_flag = PM_ERR_FLAG__INVALID;
      }

      count++;

    }while ( count < total_count);
8f631df0:	12488001 	subne	r8, r8, #1
8f631df4:	1affffec 	bne	8f631dac <pm_fg_adc_usr_get_vbat+0x60>
8f631df8:	e3a03000 	mov	r3, #0
        err_flag = PM_ERR_FLAG__INVALID;
8f631dfc:	e3a0007d 	mov	r0, #125	; 0x7d
	temp_data = data;

	//Convert int8 to int32
    temp_data1 = temp_data;

    *vbat_adc = temp_data1 * RAW_VBAT_LSB;
8f631e00:	e5863000 	str	r3, [r6]
  }

  return err_flag;
}
8f631e04:	e59f3034 	ldr	r3, [pc, #52]	; 8f631e40 <pm_fg_adc_usr_get_vbat+0xf4>
8f631e08:	e5932000 	ldr	r2, [r3]
8f631e0c:	e59d3004 	ldr	r3, [r13, #4]
8f631e10:	e0332002 	eors	r2, r3, r2
8f631e14:	e3a03000 	mov	r3, #0
8f631e18:	1a000007 	bne	8f631e3c <pm_fg_adc_usr_get_vbat+0xf0>
8f631e1c:	e28dd008 	add	r13, r13, #8
8f631e20:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
    *vbat_adc = temp_data1 * RAW_VBAT_LSB;
8f631e24:	e6af3073 	sxtb	r3, r3
8f631e28:	e3a02027 	mov	r2, #39	; 0x27
8f631e2c:	e1630283 	smulbb	r3, r3, r2
8f631e30:	eafffff2 	b	8f631e00 <pm_fg_adc_usr_get_vbat+0xb4>
    return PM_ERR_FLAG__FEATURE_NOT_SUPPORTED;
8f631e34:	e3a00017 	mov	r0, #23
8f631e38:	eafffff1 	b	8f631e04 <pm_fg_adc_usr_get_vbat+0xb8>
}
8f631e3c:	eb00035f 	bl	8f632bc0 <__stack_chk_fail>
8f631e40:	8f74221c 	.word	0x8f74221c

8f631e44 <pm_fg_adc_usr_get_bcl_v_gain_batt>:
*          version of the PMIC.
*          PM_ERR_FLAG__SUCCESS               = SUCCESS.
*
*/
pm_err_flag_type pm_fg_adc_usr_get_bcl_v_gain_batt(uint32 pmic_device, int32 *v_gain_correction)
{
8f631e44:	e92d4030 	push	{r4, r5, r14}
8f631e48:	e24dd00c 	sub	r13, r13, #12
8f631e4c:	e59f3078 	ldr	r3, [pc, #120]	; 8f631ecc <pm_fg_adc_usr_get_bcl_v_gain_batt+0x88>
  pm_err_flag_type err_flag = PM_ERR_FLAG__SUCCESS;
  pm_register_address_type  fg_adc_usr_v_gain_batt = 0x00;
  pm_register_data_type data = 0x00;
8f631e50:	e3a05000 	mov	r5, #0
{
8f631e54:	e1a04001 	mov	r4, r1
8f631e58:	e5933000 	ldr	r3, [r3]
8f631e5c:	e58d3004 	str	r3, [r13, #4]
8f631e60:	e3a03000 	mov	r3, #0
  pm_register_data_type data = 0x00;
8f631e64:	e5cd5003 	strb	r5, [r13, #3]

  int8   temp_data = 0;
  int32  temp_data1 = 0;

  pm_fg_data_type* fg_adc_usr_ptr = pm_fg_get_data(pmic_device);
8f631e68:	eb0000a7 	bl	8f63210c <pm_fg_get_data>

  if (NULL == fg_adc_usr_ptr)
8f631e6c:	e3500000 	cmp	r0, #0
  {
    return PM_ERR_FLAG__FEATURE_NOT_SUPPORTED;
8f631e70:	03a00017 	moveq	r0, #23
  if (NULL == fg_adc_usr_ptr)
8f631e74:	0a00000b 	beq	8f631ea8 <pm_fg_adc_usr_get_bcl_v_gain_batt+0x64>
  }
  else
  {
    fg_adc_usr_v_gain_batt = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_bcl_v_gain_batt;
    err_flag = pm_comm_read_byte(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_v_gain_batt, &data, 0);
8f631e78:	e8900006 	ldm	r0, {r1, r2}
8f631e7c:	e1a03005 	mov	r3, r5
    fg_adc_usr_v_gain_batt = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_bcl_v_gain_batt;
8f631e80:	e592200c 	ldr	r2, [r2, #12]
    err_flag = pm_comm_read_byte(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_v_gain_batt, &data, 0);
8f631e84:	e5910000 	ldr	r0, [r1]
    fg_adc_usr_v_gain_batt = fg_adc_usr_ptr->fg_register->adc_usr_register->base_address + fg_adc_usr_ptr->fg_register->adc_usr_register->fg_adc_usr_bcl_v_gain_batt;
8f631e88:	e1d210b0 	ldrh	r1, [r2]
8f631e8c:	e1d223ba 	ldrh	r2, [r2, #58]	; 0x3a
8f631e90:	e0811002 	add	r1, r1, r2
    err_flag = pm_comm_read_byte(fg_adc_usr_ptr->comm_ptr->slave_id, fg_adc_usr_v_gain_batt, &data, 0);
8f631e94:	e28d2003 	add	r2, r13, #3
8f631e98:	e6ff1071 	uxth	r1, r1
8f631e9c:	ebfffecb 	bl	8f6319d0 <pm_comm_read_byte>

    //Convert uint8 to int8
	temp_data = data;

	//Convert int8 to int32
	temp_data1 = temp_data;
8f631ea0:	e1dd30d3 	ldrsb	r3, [r13, #3]
8f631ea4:	e5843000 	str	r3, [r4]
    *v_gain_correction = temp_data1;
  }

  return err_flag;

}
8f631ea8:	e59f301c 	ldr	r3, [pc, #28]	; 8f631ecc <pm_fg_adc_usr_get_bcl_v_gain_batt+0x88>
8f631eac:	e5932000 	ldr	r2, [r3]
8f631eb0:	e59d3004 	ldr	r3, [r13, #4]
8f631eb4:	e0332002 	eors	r2, r3, r2
8f631eb8:	e3a03000 	mov	r3, #0
8f631ebc:	1a000001 	bne	8f631ec8 <pm_fg_adc_usr_get_bcl_v_gain_batt+0x84>
8f631ec0:	e28dd00c 	add	r13, r13, #12
8f631ec4:	e8bd8030 	pop	{r4, r5, r15}
8f631ec8:	eb00033c 	bl	8f632bc0 <__stack_chk_fail>
8f631ecc:	8f74221c 	.word	0x8f74221c

8f631ed0 <pm_fg_adc_usr_get_calibrated_vbat>:

  return errFlag;
}

pm_err_flag_type pm_fg_adc_usr_get_calibrated_vbat(uint32 pmic_device, uint32 *calibrated_vbat)
{
8f631ed0:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f631ed4:	e24dd00c 	sub	r13, r13, #12
8f631ed8:	e59f20a0 	ldr	r2, [pc, #160]	; 8f631f80 <pm_fg_adc_usr_get_calibrated_vbat+0xb0>
8f631edc:	e1a04001 	mov	r4, r1
  pm_err_flag_type   errFlag = PM_ERR_FLAG__SUCCESS;

  uint32 raw_vbat = 0;
  static int32 gain = 0;
  
  errFlag = pm_fg_adc_usr_get_vbat(pmic_device, &raw_vbat);
8f631ee0:	e1a0100d 	mov	r1, r13
  uint32 raw_vbat = 0;
8f631ee4:	e3a03000 	mov	r3, #0
{
8f631ee8:	e5922000 	ldr	r2, [r2]
8f631eec:	e58d2004 	str	r2, [r13, #4]
8f631ef0:	e3a02000 	mov	r2, #0
8f631ef4:	e1a07000 	mov	r7, r0
  uint32 raw_vbat = 0;
8f631ef8:	e58d3000 	str	r3, [r13]
  errFlag = pm_fg_adc_usr_get_vbat(pmic_device, &raw_vbat);
8f631efc:	ebffff92 	bl	8f631d4c <pm_fg_adc_usr_get_vbat>
  
  if(!gain)
8f631f00:	e30251e0 	movw	r5, #8672	; 0x21e0
8f631f04:	e3485f74 	movt	r5, #36724	; 0x8f74
8f631f08:	e5952000 	ldr	r2, [r5]
8f631f0c:	e3520000 	cmp	r2, #0
  errFlag = pm_fg_adc_usr_get_vbat(pmic_device, &raw_vbat);
8f631f10:	e1a06000 	mov	r6, r0
  if(!gain)
8f631f14:	0a000011 	beq	8f631f60 <pm_fg_adc_usr_get_calibrated_vbat+0x90>
    errFlag |= pm_fg_adc_usr_get_bcl_v_gain_batt( pmic_device,  &gain );
  }

  /* Applying gain calibration to the raw value*/
  // Twos_complement(VBAT_registerval) *39 * (1+ Twos_Complement(V_GAIN_registerval) * (.32/128))
  *calibrated_vbat = (uint32)((((raw_vbat + 2) * (GAIN_LSB_DENOM + gain)))/GAIN_LSB_DENOM);
8f631f18:	e59d3000 	ldr	r3, [r13]
8f631f1c:	e2822e19 	add	r2, r2, #400	; 0x190
8f631f20:	e308151f 	movw	r1, #34079	; 0x851f
8f631f24:	e34511eb 	movt	r1, #20971	; 0x51eb
8f631f28:	e2833002 	add	r3, r3, #2
8f631f2c:	e0030392 	mul	r3, r2, r3
8f631f30:	e0832391 	umull	r2, r3, r1, r3
8f631f34:	e1a033a3 	lsr	r3, r3, #7
8f631f38:	e5843000 	str	r3, [r4]

  return errFlag;
}
8f631f3c:	e59f303c 	ldr	r3, [pc, #60]	; 8f631f80 <pm_fg_adc_usr_get_calibrated_vbat+0xb0>
8f631f40:	e5932000 	ldr	r2, [r3]
8f631f44:	e59d3004 	ldr	r3, [r13, #4]
8f631f48:	e0332002 	eors	r2, r3, r2
8f631f4c:	e3a03000 	mov	r3, #0
8f631f50:	1a000009 	bne	8f631f7c <pm_fg_adc_usr_get_calibrated_vbat+0xac>
8f631f54:	e1a00006 	mov	r0, r6
8f631f58:	e28dd00c 	add	r13, r13, #12
8f631f5c:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
    errFlag |= pm_fg_adc_usr_get_bcl_v_gain_batt( pmic_device,  &gain );
8f631f60:	e1a01005 	mov	r1, r5
8f631f64:	e1a00007 	mov	r0, r7
8f631f68:	ebffffb5 	bl	8f631e44 <pm_fg_adc_usr_get_bcl_v_gain_batt>
  *calibrated_vbat = (uint32)((((raw_vbat + 2) * (GAIN_LSB_DENOM + gain)))/GAIN_LSB_DENOM);
8f631f6c:	e5952000 	ldr	r2, [r5]
    errFlag |= pm_fg_adc_usr_get_bcl_v_gain_batt( pmic_device,  &gain );
8f631f70:	e1866000 	orr	r6, r6, r0
8f631f74:	e6ef6076 	uxtb	r6, r6
8f631f78:	eaffffe6 	b	8f631f18 <pm_fg_adc_usr_get_calibrated_vbat+0x48>
}
8f631f7c:	eb00030f 	bl	8f632bc0 <__stack_chk_fail>
8f631f80:	8f74221c 	.word	0x8f74221c

8f631f84 <pm_fg_usr_get_vbat>:

pm_err_flag_type pm_fg_usr_get_vbat(uint32 pmic_device, uint32 *calibrated_vbat)
{
8f631f84:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f631f88:	e24dd014 	sub	r13, r13, #20
8f631f8c:	e59f2100 	ldr	r2, [pc, #256]	; 8f632094 <pm_fg_usr_get_vbat+0x110>
8f631f90:	e1a06000 	mov	r6, r0
	uint16	wait_index = 0;
	boolean adc_reading_ready = FALSE;
8f631f94:	e3a03000 	mov	r3, #0
{
8f631f98:	e1a07001 	mov	r7, r1
8f631f9c:	e5922000 	ldr	r2, [r2]
8f631fa0:	e58d200c 	str	r2, [r13, #12]
8f631fa4:	e3a02000 	mov	r2, #0
	boolean adc_reading_ready = FALSE;
8f631fa8:	e58d3004 	str	r3, [r13, #4]
	boolean enable = FALSE;
8f631fac:	e58d3008 	str	r3, [r13, #8]

	pm_err_flag_type err_flag = PM_ERR_FLAG__SUCCESS;

	pm_fg_driver_init(pmic_device);
8f631fb0:	eb000038 	bl	8f632098 <pm_fg_driver_init>

	err_flag |= pm_fg_adc_usr_get_bcl_monitoring_sts(pmic_device, &enable);
8f631fb4:	e28d1008 	add	r1, r13, #8
8f631fb8:	e1a00006 	mov	r0, r6
8f631fbc:	ebffff1a 	bl	8f631c2c <pm_fg_adc_usr_get_bcl_monitoring_sts>
	if (err_flag != PM_ERR_FLAG__SUCCESS)  {
8f631fc0:	e2504000 	subs	r4, r0, #0
8f631fc4:	1a000018 	bne	8f63202c <pm_fg_usr_get_vbat+0xa8>
		return err_flag;
	} else {
		if (enable == FALSE) {
8f631fc8:	e59d3008 	ldr	r3, [r13, #8]
8f631fcc:	e3530000 	cmp	r3, #0
8f631fd0:	0a00001e 	beq	8f632050 <pm_fg_usr_get_vbat+0xcc>
				return err_flag;
		}
	}

	//Check Vbatt ADC level
	err_flag |= pm_fg_adc_usr_get_bcl_values(pmic_device, &adc_reading_ready); //Check if Vbatt ADC is ready
8f631fd4:	e28d1004 	add	r1, r13, #4
8f631fd8:	e1a00006 	mov	r0, r6
8f631fdc:	ebffff36 	bl	8f631cbc <pm_fg_adc_usr_get_bcl_values>
8f631fe0:	e3a05e7d 	mov	r5, #2000	; 0x7d0
8f631fe4:	e1a04000 	mov	r4, r0

	//Check if Vbatt ADC is Ready
	for (wait_index = 0; wait_index < PM_MAX_ADC_READY_DELAY; wait_index++) {
8f631fe8:	ea00000a 	b	8f632018 <pm_fg_usr_get_vbat+0x94>
		if(adc_reading_ready == FALSE) {
		udelay(PM_MIN_ADC_READY_DELAY);
8f631fec:	e3a00ffa 	mov	r0, #1000	; 0x3e8
	for (wait_index = 0; wait_index < PM_MAX_ADC_READY_DELAY; wait_index++) {
8f631ff0:	e2455001 	sub	r5, r5, #1
		udelay(PM_MIN_ADC_READY_DELAY);
8f631ff4:	ebff7358 	bl	8f60ed5c <udelay>
		err_flag |= pm_fg_adc_usr_get_bcl_values(pmic_device, &adc_reading_ready);
8f631ff8:	e28d1004 	add	r1, r13, #4
8f631ffc:	e1a00006 	mov	r0, r6
	for (wait_index = 0; wait_index < PM_MAX_ADC_READY_DELAY; wait_index++) {
8f632000:	e6ff5075 	uxth	r5, r5
		err_flag |= pm_fg_adc_usr_get_bcl_values(pmic_device, &adc_reading_ready);
8f632004:	ebffff2c 	bl	8f631cbc <pm_fg_adc_usr_get_bcl_values>
	for (wait_index = 0; wait_index < PM_MAX_ADC_READY_DELAY; wait_index++) {
8f632008:	e3550000 	cmp	r5, #0
		err_flag |= pm_fg_adc_usr_get_bcl_values(pmic_device, &adc_reading_ready);
8f63200c:	e1800004 	orr	r0, r0, r4
8f632010:	e6ef4070 	uxtb	r4, r0
	for (wait_index = 0; wait_index < PM_MAX_ADC_READY_DELAY; wait_index++) {
8f632014:	0a000013 	beq	8f632068 <pm_fg_usr_get_vbat+0xe4>
		if(adc_reading_ready == FALSE) {
8f632018:	e59d3004 	ldr	r3, [r13, #4]
8f63201c:	e3530000 	cmp	r3, #0
8f632020:	0afffff1 	beq	8f631fec <pm_fg_usr_get_vbat+0x68>
		} else {
			break;
		}
	}

	if ( err_flag != PM_ERR_FLAG__SUCCESS )  {
8f632024:	e3540000 	cmp	r4, #0
8f632028:	0a000013 	beq	8f63207c <pm_fg_usr_get_vbat+0xf8>
	if (adc_reading_ready) {
		err_flag |= pm_fg_adc_usr_get_calibrated_vbat(pmic_device, calibrated_vbat); //Read calibrated vbatt ADC
	}

	return err_flag;
}
8f63202c:	e59f3060 	ldr	r3, [pc, #96]	; 8f632094 <pm_fg_usr_get_vbat+0x110>
8f632030:	e5932000 	ldr	r2, [r3]
8f632034:	e59d300c 	ldr	r3, [r13, #12]
8f632038:	e0332002 	eors	r2, r3, r2
8f63203c:	e3a03000 	mov	r3, #0
8f632040:	1a000012 	bne	8f632090 <pm_fg_usr_get_vbat+0x10c>
8f632044:	e1a00004 	mov	r0, r4
8f632048:	e28dd014 	add	r13, r13, #20
8f63204c:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
			err_flag |= pm_fg_adc_usr_enable_bcl_monitoring(pmic_device, TRUE);
8f632050:	e3a01001 	mov	r1, #1
8f632054:	e1a00006 	mov	r0, r6
8f632058:	ebfffed1 	bl	8f631ba4 <pm_fg_adc_usr_enable_bcl_monitoring>
			if (err_flag != PM_ERR_FLAG__SUCCESS)
8f63205c:	e2504000 	subs	r4, r0, #0
8f632060:	0affffdb 	beq	8f631fd4 <pm_fg_usr_get_vbat+0x50>
8f632064:	eafffff0 	b	8f63202c <pm_fg_usr_get_vbat+0xa8>
	if ( err_flag != PM_ERR_FLAG__SUCCESS )  {
8f632068:	e3540000 	cmp	r4, #0
8f63206c:	1affffee 	bne	8f63202c <pm_fg_usr_get_vbat+0xa8>
	if (adc_reading_ready) {
8f632070:	e59d3004 	ldr	r3, [r13, #4]
8f632074:	e3530000 	cmp	r3, #0
8f632078:	0affffeb 	beq	8f63202c <pm_fg_usr_get_vbat+0xa8>
		err_flag |= pm_fg_adc_usr_get_calibrated_vbat(pmic_device, calibrated_vbat); //Read calibrated vbatt ADC
8f63207c:	e1a01007 	mov	r1, r7
8f632080:	e1a00006 	mov	r0, r6
8f632084:	ebffff91 	bl	8f631ed0 <pm_fg_adc_usr_get_calibrated_vbat>
8f632088:	e1a04000 	mov	r4, r0
8f63208c:	eaffffe6 	b	8f63202c <pm_fg_usr_get_vbat+0xa8>
}
8f632090:	eb0002ca 	bl	8f632bc0 <__stack_chk_fail>
8f632094:	8f74221c 	.word	0x8f74221c

8f632098 <pm_fg_driver_init>:

===========================================================================*/
/* Initialize FG driver and data structure */
void pm_fg_driver_init(uint32_t device_index)
{
	fg_data[device_index].comm_ptr = &comm[0];
8f632098:	e3a0300c 	mov	r3, #12
8f63209c:	e3041590 	movw	r1, #17808	; 0x4590
8f6320a0:	e0000093 	mul	r0, r3, r0
8f6320a4:	e3093400 	movw	r3, #37888	; 0x9400
8f6320a8:	e3483f75 	movt	r3, #36725	; 0x8f75
8f6320ac:	e3481f72 	movt	r1, #36722	; 0x8f72
{
8f6320b0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	fg_data[device_index].comm_ptr = &comm[0];
8f6320b4:	e083c000 	add	r12, r3, r0
{
8f6320b8:	e24dd00c 	sub	r13, r13, #12
	fg_data[device_index].fg_register = &fg_reg[0];
8f6320bc:	e30425ec 	movw	r2, #17900	; 0x45ec
	fg_data[device_index].comm_ptr = &comm[0];
8f6320c0:	e7831000 	str	r1, [r3, r0]
	fg_data[device_index].fg_register = &fg_reg[0];
8f6320c4:	e3482f72 	movt	r2, #36722	; 0x8f72
{
8f6320c8:	e59f3038 	ldr	r3, [pc, #56]	; 8f632108 <pm_fg_driver_init+0x70>
	fg_data[device_index].num_of_peripherals = 0x0;
8f6320cc:	e3a0e000 	mov	r14, #0
{
8f6320d0:	e5933000 	ldr	r3, [r3]
8f6320d4:	e58d3004 	str	r3, [r13, #4]
8f6320d8:	e3a03000 	mov	r3, #0
}
8f6320dc:	e59f3024 	ldr	r3, [pc, #36]	; 8f632108 <pm_fg_driver_init+0x70>
	fg_data[device_index].fg_register = &fg_reg[0];
8f6320e0:	e58c2004 	str	r2, [r12, #4]
	fg_data[device_index].num_of_peripherals = 0x0;
8f6320e4:	e5cce008 	strb	r14, [r12, #8]
}
8f6320e8:	e5932000 	ldr	r2, [r3]
8f6320ec:	e59d3004 	ldr	r3, [r13, #4]
8f6320f0:	e0332002 	eors	r2, r3, r2
8f6320f4:	e3a03000 	mov	r3, #0
8f6320f8:	1a000001 	bne	8f632104 <pm_fg_driver_init+0x6c>
8f6320fc:	e28dd00c 	add	r13, r13, #12
8f632100:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f632104:	eb0002ad 	bl	8f632bc0 <__stack_chk_fail>
8f632108:	8f74221c 	.word	0x8f74221c

8f63210c <pm_fg_get_data>:

pm_fg_data_type* pm_fg_get_data(uint32 pmic_index)
{
8f63210c:	e59f304c 	ldr	r3, [pc, #76]	; 8f632160 <pm_fg_get_data+0x54>
  if(pmic_index <PM_MAX_NUM_PMICS) 
8f632110:	e3500003 	cmp	r0, #3
{
8f632114:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f632118:	e24dd00c 	sub	r13, r13, #12
8f63211c:	e5933000 	ldr	r3, [r3]
8f632120:	e58d3004 	str	r3, [r13, #4]
8f632124:	e3a03000 	mov	r3, #0
  {
      return &fg_data[pmic_index];
8f632128:	93093400 	movwls	r3, #37888	; 0x9400
8f63212c:	93483f75 	movtls	r3, #36725	; 0x8f75
8f632130:	93a0200c 	movls	r2, #12
  }

  return NULL;
8f632134:	83a00000 	movhi	r0, #0
      return &fg_data[pmic_index];
8f632138:	90203092 	mlals	r0, r2, r0, r3
}
8f63213c:	e59f301c 	ldr	r3, [pc, #28]	; 8f632160 <pm_fg_get_data+0x54>
8f632140:	e5932000 	ldr	r2, [r3]
8f632144:	e59d3004 	ldr	r3, [r13, #4]
8f632148:	e0332002 	eors	r2, r3, r2
8f63214c:	e3a03000 	mov	r3, #0
8f632150:	1a000001 	bne	8f63215c <pm_fg_get_data+0x50>
8f632154:	e28dd00c 	add	r13, r13, #12
8f632158:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f63215c:	eb000297 	bl	8f632bc0 <__stack_chk_fail>
8f632160:	8f74221c 	.word	0x8f74221c

8f632164 <pm_vib_turn_on>:

#include <pm_vib.h>
#include <board.h>

void pm_vib_turn_on()
{
8f632164:	e59f306c 	ldr	r3, [pc, #108]	; 8f6321d8 <pm_vib_turn_on+0x74>
	if ((board_pmic_target(1) & PMIC_TYPE_MASK) == PMIC_IS_PMI632)
8f632168:	e3a00001 	mov	r0, #1
{
8f63216c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f632170:	e24dd00c 	sub	r13, r13, #12
8f632174:	e5933000 	ldr	r3, [r3]
8f632178:	e58d3004 	str	r3, [r13, #4]
8f63217c:	e3a03000 	mov	r3, #0
	if ((board_pmic_target(1) & PMIC_TYPE_MASK) == PMIC_IS_PMI632)
8f632180:	ebff7870 	bl	8f610348 <board_pmic_target>
		pm_vib_ldo_turn_on();
8f632184:	e59f304c 	ldr	r3, [pc, #76]	; 8f6321d8 <pm_vib_turn_on+0x74>
	if ((board_pmic_target(1) & PMIC_TYPE_MASK) == PMIC_IS_PMI632)
8f632188:	e6ef0070 	uxtb	r0, r0
8f63218c:	e3500025 	cmp	r0, #37	; 0x25
8f632190:	0a000007 	beq	8f6321b4 <pm_vib_turn_on+0x50>
	else
		pm_haptic_vib_turn_on();
8f632194:	e5932000 	ldr	r2, [r3]
8f632198:	e59d3004 	ldr	r3, [r13, #4]
8f63219c:	e0332002 	eors	r2, r3, r2
8f6321a0:	e3a03000 	mov	r3, #0
8f6321a4:	1a00000a 	bne	8f6321d4 <pm_vib_turn_on+0x70>
}
8f6321a8:	e28dd00c 	add	r13, r13, #12
8f6321ac:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		pm_haptic_vib_turn_on();
8f6321b0:	ea000027 	b	8f632254 <pm_haptic_vib_turn_on>
		pm_vib_ldo_turn_on();
8f6321b4:	e5932000 	ldr	r2, [r3]
8f6321b8:	e59d3004 	ldr	r3, [r13, #4]
8f6321bc:	e0332002 	eors	r2, r3, r2
8f6321c0:	e3a03000 	mov	r3, #0
8f6321c4:	1a000002 	bne	8f6321d4 <pm_vib_turn_on+0x70>
}
8f6321c8:	e28dd00c 	add	r13, r13, #12
8f6321cc:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		pm_vib_ldo_turn_on();
8f6321d0:	ea0000aa 	b	8f632480 <pm_vib_ldo_turn_on>
		pm_haptic_vib_turn_on();
8f6321d4:	eb000279 	bl	8f632bc0 <__stack_chk_fail>
8f6321d8:	8f74221c 	.word	0x8f74221c

8f6321dc <pm_vib_turn_off>:

void pm_vib_turn_off()
{
8f6321dc:	e59f306c 	ldr	r3, [pc, #108]	; 8f632250 <pm_vib_turn_off+0x74>
	if ((board_pmic_target(1) & PMIC_TYPE_MASK) == PMIC_IS_PMI632)
8f6321e0:	e3a00001 	mov	r0, #1
{
8f6321e4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6321e8:	e24dd00c 	sub	r13, r13, #12
8f6321ec:	e5933000 	ldr	r3, [r3]
8f6321f0:	e58d3004 	str	r3, [r13, #4]
8f6321f4:	e3a03000 	mov	r3, #0
	if ((board_pmic_target(1) & PMIC_TYPE_MASK) == PMIC_IS_PMI632)
8f6321f8:	ebff7852 	bl	8f610348 <board_pmic_target>
		pm_vib_ldo_turn_off();
8f6321fc:	e59f304c 	ldr	r3, [pc, #76]	; 8f632250 <pm_vib_turn_off+0x74>
	if ((board_pmic_target(1) & PMIC_TYPE_MASK) == PMIC_IS_PMI632)
8f632200:	e6ef0070 	uxtb	r0, r0
8f632204:	e3500025 	cmp	r0, #37	; 0x25
8f632208:	0a000007 	beq	8f63222c <pm_vib_turn_off+0x50>
	else
		pm_haptic_vib_turn_off();
8f63220c:	e5932000 	ldr	r2, [r3]
8f632210:	e59d3004 	ldr	r3, [r13, #4]
8f632214:	e0332002 	eors	r2, r3, r2
8f632218:	e3a03000 	mov	r3, #0
8f63221c:	1a00000a 	bne	8f63224c <pm_vib_turn_off+0x70>
}
8f632220:	e28dd00c 	add	r13, r13, #12
8f632224:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		pm_haptic_vib_turn_off();
8f632228:	ea00006f 	b	8f6323ec <pm_haptic_vib_turn_off>
		pm_vib_ldo_turn_off();
8f63222c:	e5932000 	ldr	r2, [r3]
8f632230:	e59d3004 	ldr	r3, [r13, #4]
8f632234:	e0332002 	eors	r2, r3, r2
8f632238:	e3a03000 	mov	r3, #0
8f63223c:	1a000002 	bne	8f63224c <pm_vib_turn_off+0x70>
}
8f632240:	e28dd00c 	add	r13, r13, #12
8f632244:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		pm_vib_ldo_turn_off();
8f632248:	ea0000e8 	b	8f6325f0 <pm_vib_ldo_turn_off>
		pm_haptic_vib_turn_off();
8f63224c:	eb00025b 	bl	8f632bc0 <__stack_chk_fail>
8f632250:	8f74221c 	.word	0x8f74221c

8f632254 <pm_haptic_vib_turn_on>:
#define QPNP_HAP_LRA_AUTO_DISABLE 0x00
#define QPNP_HAP_LRA_AUTO_MASK 0x70

/* Turn on vibrator */
void pm_haptic_vib_turn_on(void)
{
8f632254:	e92d4010 	push	{r4, r14}
8f632258:	e24dd008 	sub	r13, r13, #8
8f63225c:	e59f3184 	ldr	r3, [pc, #388]	; 8f6323e8 <pm_haptic_vib_turn_on+0x194>
	struct qpnp_hap vib_config = {0};
8f632260:	e3a04000 	mov	r4, #0
{
8f632264:	e5933000 	ldr	r3, [r3]
8f632268:	e58d3004 	str	r3, [r13, #4]
8f63226c:	e3a03000 	mov	r3, #0
	struct qpnp_hap vib_config = {0};
8f632270:	e1cd40b0 	strh	r4, [r13]
8f632274:	e5cd4002 	strb	r4, [r13, #2]

	if(!target_is_pmi_enabled())
8f632278:	ebffbe74 	bl	8f621c50 <target_is_pmi_enabled>
8f63227c:	e1500004 	cmp	r0, r4
8f632280:	0a00004f 	beq	8f6323c4 <pm_haptic_vib_turn_on+0x170>
		return;

	get_vibration_type(&vib_config);
8f632284:	e1a0000d 	mov	r0, r13
8f632288:	ebffbf1b 	bl	8f621efc <get_vibration_type>
	/* Configure the ACTUATOR TYPE register as ERM*/
	pmic_spmi_reg_mask_write(QPNP_HAP_ACT_TYPE_REG,
8f63228c:	e5dd2002 	ldrb	r2, [r13, #2]
8f632290:	e3a01001 	mov	r1, #1
8f632294:	e30c004c 	movw	r0, #49228	; 0xc04c
8f632298:	e0422001 	sub	r2, r2, r1
8f63229c:	e3400003 	movt	r0, #3
8f6322a0:	e16f2f12 	clz	r2, r2
8f6322a4:	e1a022a2 	lsr	r2, r2, #5
8f6322a8:	ebff7b66 	bl	8f611048 <pmic_spmi_reg_mask_write>
					QPNP_HAP_ACT_TYPE_MASK,
					VIB_ERM_TYPE == vib_config.vib_type ? QPNP_HAP_ERM
					: QPNP_HAP_LRA);

	/* Disable auto resonance for ERM */
	pmic_spmi_reg_mask_write(QPNP_HAP_LRA_AUTO_RES_REG,
8f6322ac:	e1a02004 	mov	r2, r4
8f6322b0:	e3a01070 	mov	r1, #112	; 0x70
8f6322b4:	e30c004f 	movw	r0, #49231	; 0xc04f
8f6322b8:	e3400003 	movt	r0, #3
8f6322bc:	ebff7b61 	bl	8f611048 <pmic_spmi_reg_mask_write>
					QPNP_HAP_LRA_AUTO_MASK,
					QPNP_HAP_LRA_AUTO_DISABLE);

	/* Configure the PLAY MODE register as direct*/
	pmic_spmi_reg_mask_write(QPNP_HAP_PLAY_MODE_REG,
8f6322c0:	e1a02004 	mov	r2, r4
8f6322c4:	e3a0103f 	mov	r1, #63	; 0x3f
8f6322c8:	e30c004e 	movw	r0, #49230	; 0xc04e
8f6322cc:	e3400003 	movt	r0, #3
8f6322d0:	ebff7b5c 	bl	8f611048 <pmic_spmi_reg_mask_write>
					QPNP_HAP_PLAY_MODE_MASK,
					QPNP_HAP_DIRECT);

	/* Configure the VMAX register */
	pmic_spmi_reg_mask_write(QPNP_HAP_VMAX_REG,
8f6322d4:	e3a02022 	mov	r2, #34	; 0x22
8f6322d8:	e3a0103f 	mov	r1, #63	; 0x3f
8f6322dc:	e30c0051 	movw	r0, #49233	; 0xc051
8f6322e0:	e3400003 	movt	r0, #3
8f6322e4:	ebff7b57 	bl	8f611048 <pmic_spmi_reg_mask_write>
					QPNP_HAP_VMAX_MASK, QPNP_HAP_VMAX);

	/* Sets current limit to 800mA*/
	pmic_spmi_reg_mask_write(QPNP_HAP_ILIM_REG,
8f6322e8:	e3a02001 	mov	r2, #1
8f6322ec:	e1a01002 	mov	r1, r2
8f6322f0:	e30c0052 	movw	r0, #49234	; 0xc052
8f6322f4:	e3400003 	movt	r0, #3
8f6322f8:	ebff7b52 	bl	8f611048 <pmic_spmi_reg_mask_write>
					QPNP_HAP_ILIM_MASK, QPNP_HAP_ILIM);

	/* Configure the short circuit debounce register as DEB_8CLK*/
	pmic_spmi_reg_mask_write(QPNP_HAP_SC_DEB_REG,
8f6322fc:	e3a02001 	mov	r2, #1
8f632300:	e3a01007 	mov	r1, #7
8f632304:	e30c0053 	movw	r0, #49235	; 0xc053
8f632308:	e3400003 	movt	r0, #3
8f63230c:	ebff7b4d 	bl	8f611048 <pmic_spmi_reg_mask_write>
					QPNP_HAP_SC_DEB_MASK, QPNP_HAP_SC_DEB_8CLK);

	/* Configure the INTERNAL_PWM register as 505KHZ and 13PF*/
	pmic_spmi_reg_mask_write(QPNP_HAP_INT_PWM_REG,
8f632310:	e3a02001 	mov	r2, #1
8f632314:	e3a01003 	mov	r1, #3
8f632318:	e30c0056 	movw	r0, #49238	; 0xc056
8f63231c:	e3400003 	movt	r0, #3
8f632320:	ebff7b48 	bl	8f611048 <pmic_spmi_reg_mask_write>
					QPNP_HAP_INT_PWM_MASK, QPNP_HAP_INT_PWM_505KHZ);
	pmic_spmi_reg_mask_write(QPNP_HAP_PWM_CAP_REG,
8f632324:	e3a02001 	mov	r2, #1
8f632328:	e3a01003 	mov	r1, #3
8f63232c:	e30c0058 	movw	r0, #49240	; 0xc058
8f632330:	e3400003 	movt	r0, #3
8f632334:	ebff7b43 	bl	8f611048 <pmic_spmi_reg_mask_write>
					QPNP_HAP_PWM_CAP_MASK, QPNP_HAP_PWM_CAP_13PF);

	/* Configure the WAVE SHAPE register as SQUARE*/
	pmic_spmi_reg_mask_write(QPNP_HAP_WAV_SHAPE_REG,
8f632338:	e3a02001 	mov	r2, #1
8f63233c:	e1a01002 	mov	r1, r2
8f632340:	e30c004d 	movw	r0, #49229	; 0xc04d
8f632344:	e3400003 	movt	r0, #3
8f632348:	ebff7b3e 	bl	8f611048 <pmic_spmi_reg_mask_write>
					QPNP_HAP_WAV_SHAPE_MASK, QPNP_HAP_WAV_SHAPE_SQUARE);

	/* Configure RATE_CFG1 and RATE_CFG2 registers for haptic rate. */
	pmic_spmi_reg_mask_write(QPNP_HAP_RATE_CFG1_REG,
8f63234c:	e5dd2000 	ldrb	r2, [r13]
8f632350:	e3a010ff 	mov	r1, #255	; 0xff
8f632354:	e30c0054 	movw	r0, #49236	; 0xc054
8f632358:	e3400003 	movt	r0, #3
8f63235c:	ebff7b39 	bl	8f611048 <pmic_spmi_reg_mask_write>
					QPNP_HAP_RATE_CFG1_MASK, vib_config.hap_rate_cfg1);
	pmic_spmi_reg_mask_write(QPNP_HAP_RATE_CFG2_REG,
8f632360:	e5dd2001 	ldrb	r2, [r13, #1]
8f632364:	e3a0100f 	mov	r1, #15
8f632368:	e30c0055 	movw	r0, #49237	; 0xc055
8f63236c:	e3400003 	movt	r0, #3
8f632370:	ebff7b34 	bl	8f611048 <pmic_spmi_reg_mask_write>
					QPNP_HAP_RATE_CFG2_MASK, vib_config.hap_rate_cfg2);

	/* Configure BRAKE register, PATTERN1 & PATTERN2 as VMAX. */
	pmic_spmi_reg_mask_write(QPNP_HAP_EN_CTL2_REG,
8f632374:	e3a02001 	mov	r2, #1
8f632378:	e1a01002 	mov	r1, r2
8f63237c:	e30c0048 	movw	r0, #49224	; 0xc048
8f632380:	e3400003 	movt	r0, #3
8f632384:	ebff7b2f 	bl	8f611048 <pmic_spmi_reg_mask_write>
					QPNP_HAP_EN_BRAKE_EN_MASK, QPNP_HAP_EN_BRAKING_EN);
	pmic_spmi_reg_mask_write(QPNP_HAP_BRAKE_REG,
8f632388:	e3a0200f 	mov	r2, #15
8f63238c:	e3a010ff 	mov	r1, #255	; 0xff
8f632390:	e30c005c 	movw	r0, #49244	; 0xc05c
8f632394:	e3400003 	movt	r0, #3
8f632398:	ebff7b2a 	bl	8f611048 <pmic_spmi_reg_mask_write>
					QPNP_HAP_BRAKE_VMAX_MASK, QPNP_HAP_BRAKE_VMAX);

	/* Enable control register */
	pmic_spmi_reg_mask_write(QPNP_HAP_EN_CTL_REG,
8f63239c:	e3a02080 	mov	r2, #128	; 0x80
8f6323a0:	e1a01002 	mov	r1, r2
8f6323a4:	e30c0046 	movw	r0, #49222	; 0xc046
8f6323a8:	e3400003 	movt	r0, #3
8f6323ac:	ebff7b25 	bl	8f611048 <pmic_spmi_reg_mask_write>
					QPNP_HAP_PLAY_MASK, QPNP_HAP_PLAY_EN);

	/* Enable play register */
	pmic_spmi_reg_mask_write(QPNP_HAP_PLAY_REG, QPNP_HAP_MASK, QPNP_HAP_EN);
8f6323b0:	e3a02080 	mov	r2, #128	; 0x80
8f6323b4:	e30c0070 	movw	r0, #49264	; 0xc070
8f6323b8:	e1a01002 	mov	r1, r2
8f6323bc:	e3400003 	movt	r0, #3
8f6323c0:	ebff7b20 	bl	8f611048 <pmic_spmi_reg_mask_write>
}
8f6323c4:	e59f301c 	ldr	r3, [pc, #28]	; 8f6323e8 <pm_haptic_vib_turn_on+0x194>
8f6323c8:	e5932000 	ldr	r2, [r3]
8f6323cc:	e59d3004 	ldr	r3, [r13, #4]
8f6323d0:	e0332002 	eors	r2, r3, r2
8f6323d4:	e3a03000 	mov	r3, #0
8f6323d8:	1a000001 	bne	8f6323e4 <pm_haptic_vib_turn_on+0x190>
8f6323dc:	e28dd008 	add	r13, r13, #8
8f6323e0:	e8bd8010 	pop	{r4, r15}
8f6323e4:	eb0001f5 	bl	8f632bc0 <__stack_chk_fail>
8f6323e8:	8f74221c 	.word	0x8f74221c

8f6323ec <pm_haptic_vib_turn_off>:

/* Turn off vibrator */
void pm_haptic_vib_turn_off(void)
{
8f6323ec:	e59f3088 	ldr	r3, [pc, #136]	; 8f63247c <pm_haptic_vib_turn_off+0x90>
8f6323f0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6323f4:	e24dd00c 	sub	r13, r13, #12
8f6323f8:	e5933000 	ldr	r3, [r3]
8f6323fc:	e58d3004 	str	r3, [r13, #4]
8f632400:	e3a03000 	mov	r3, #0
	if(!target_is_pmi_enabled())
8f632404:	ebffbe11 	bl	8f621c50 <target_is_pmi_enabled>
8f632408:	e3500000 	cmp	r0, #0
8f63240c:	1a000007 	bne	8f632430 <pm_haptic_vib_turn_off+0x44>
	pmic_spmi_reg_mask_write(QPNP_HAP_EN_CTL_REG,
					QPNP_HAP_PLAY_MASK, QPNP_HAP_PLAY_DIS);

	/* Disable play register */
	pmic_spmi_reg_mask_write(QPNP_HAP_PLAY_REG, QPNP_HAP_MASK, QPNP_HAP_DIS);
}
8f632410:	e59f3064 	ldr	r3, [pc, #100]	; 8f63247c <pm_haptic_vib_turn_off+0x90>
8f632414:	e5932000 	ldr	r2, [r3]
8f632418:	e59d3004 	ldr	r3, [r13, #4]
8f63241c:	e0332002 	eors	r2, r3, r2
8f632420:	e3a03000 	mov	r3, #0
8f632424:	1a000013 	bne	8f632478 <pm_haptic_vib_turn_off+0x8c>
8f632428:	e28dd00c 	add	r13, r13, #12
8f63242c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	pmic_spmi_reg_mask_write(QPNP_HAP_EN_CTL_REG,
8f632430:	e3a02000 	mov	r2, #0
8f632434:	e30c0046 	movw	r0, #49222	; 0xc046
8f632438:	e3a01080 	mov	r1, #128	; 0x80
8f63243c:	e3400003 	movt	r0, #3
8f632440:	ebff7b00 	bl	8f611048 <pmic_spmi_reg_mask_write>
	pmic_spmi_reg_mask_write(QPNP_HAP_PLAY_REG, QPNP_HAP_MASK, QPNP_HAP_DIS);
8f632444:	e59f3030 	ldr	r3, [pc, #48]	; 8f63247c <pm_haptic_vib_turn_off+0x90>
8f632448:	e5932000 	ldr	r2, [r3]
8f63244c:	e59d3004 	ldr	r3, [r13, #4]
8f632450:	e0332002 	eors	r2, r3, r2
8f632454:	e3a03000 	mov	r3, #0
8f632458:	1a000006 	bne	8f632478 <pm_haptic_vib_turn_off+0x8c>
8f63245c:	e30c0070 	movw	r0, #49264	; 0xc070
8f632460:	e3a02000 	mov	r2, #0
8f632464:	e3400003 	movt	r0, #3
8f632468:	e3a01080 	mov	r1, #128	; 0x80
}
8f63246c:	e28dd00c 	add	r13, r13, #12
8f632470:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	pmic_spmi_reg_mask_write(QPNP_HAP_PLAY_REG, QPNP_HAP_MASK, QPNP_HAP_DIS);
8f632474:	eaff7af3 	b	8f611048 <pmic_spmi_reg_mask_write>
}
8f632478:	eb0001d0 	bl	8f632bc0 <__stack_chk_fail>
8f63247c:	8f74221c 	.word	0x8f74221c

8f632480 <pm_vib_ldo_turn_on>:
#define VIB_LDO_NOMINAL_VOLTAGE_MV	3000
#define OVERDRIVE_TIME_US		30000

/* Turn on vibrator */
void pm_vib_ldo_turn_on(void)
{
8f632480:	e59f3164 	ldr	r3, [pc, #356]	; 8f6325ec <pm_vib_ldo_turn_on+0x16c>
8f632484:	e92d4030 	push	{r4, r5, r14}
8f632488:	e24dd00c 	sub	r13, r13, #12
8f63248c:	e5933000 	ldr	r3, [r3]
8f632490:	e58d3004 	str	r3, [r13, #4]
8f632494:	e3a03000 	mov	r3, #0
	uint8_t status;
	uint8_t vreg_timer_count = 0;

	if (!target_is_pmi_enabled())
8f632498:	ebffbdec 	bl	8f621c50 <target_is_pmi_enabled>
8f63249c:	e3500000 	cmp	r0, #0
8f6324a0:	1a000007 	bne	8f6324c4 <pm_vib_ldo_turn_on+0x44>
			pm_vib_ldo_turn_off();
			return;
		}
	}

}
8f6324a4:	e59f3140 	ldr	r3, [pc, #320]	; 8f6325ec <pm_vib_ldo_turn_on+0x16c>
8f6324a8:	e5932000 	ldr	r2, [r3]
8f6324ac:	e59d3004 	ldr	r3, [r13, #4]
8f6324b0:	e0332002 	eors	r2, r3, r2
8f6324b4:	e3a03000 	mov	r3, #0
8f6324b8:	1a00004a 	bne	8f6325e8 <pm_vib_ldo_turn_on+0x168>
8f6324bc:	e28dd00c 	add	r13, r13, #12
8f6324c0:	e8bd8030 	pop	{r4, r5, r15}
	pmic_spmi_reg_mask_write(QPNP_VIB_LDO_VSET_LB_REG,
8f6324c4:	e3a020ac 	mov	r2, #172	; 0xac
8f6324c8:	e3a010ff 	mov	r1, #255	; 0xff
8f6324cc:	e3050740 	movw	r0, #22336	; 0x5740
8f6324d0:	e3400003 	movt	r0, #3
8f6324d4:	ebff7adb 	bl	8f611048 <pmic_spmi_reg_mask_write>
	pmic_spmi_reg_mask_write(QPNP_VIB_LDO_VSET_UB_REG,
8f6324d8:	e3a0200d 	mov	r2, #13
8f6324dc:	e3a010ff 	mov	r1, #255	; 0xff
8f6324e0:	e3050741 	movw	r0, #22337	; 0x5741
8f6324e4:	e3400003 	movt	r0, #3
		status = pmic_spmi_reg_read(QPNP_VIB_LDO_STATUS1_REG);
8f6324e8:	e3055708 	movw	r5, #22280	; 0x5708
	pmic_spmi_reg_mask_write(QPNP_VIB_LDO_VSET_UB_REG,
8f6324ec:	ebff7ad5 	bl	8f611048 <pmic_spmi_reg_mask_write>
	pmic_spmi_reg_mask_write(QPNP_VIB_LDO_EN_CTL_REG,
8f6324f0:	e3a02080 	mov	r2, #128	; 0x80
8f6324f4:	e1a01002 	mov	r1, r2
8f6324f8:	e3050746 	movw	r0, #22342	; 0x5746
8f6324fc:	e3400003 	movt	r0, #3
		status = pmic_spmi_reg_read(QPNP_VIB_LDO_STATUS1_REG);
8f632500:	e3405003 	movt	r5, #3
	pmic_spmi_reg_mask_write(QPNP_VIB_LDO_EN_CTL_REG,
8f632504:	ebff7acf 	bl	8f611048 <pmic_spmi_reg_mask_write>
8f632508:	e3a0400b 	mov	r4, #11
8f63250c:	ea000001 	b	8f632518 <pm_vib_ldo_turn_on+0x98>
			udelay(VREG_READY_STEP_DELAY_US);
8f632510:	e3a00064 	mov	r0, #100	; 0x64
8f632514:	ebff7210 	bl	8f60ed5c <udelay>
		status = pmic_spmi_reg_read(QPNP_VIB_LDO_STATUS1_REG);
8f632518:	e1a00005 	mov	r0, r5
8f63251c:	ebff7aa8 	bl	8f610fc4 <pmic_spmi_reg_read>
		if ( status & VREG_READY ) {
8f632520:	e3100080 	tst	r0, #128	; 0x80
8f632524:	1a000015 	bne	8f632580 <pm_vib_ldo_turn_on+0x100>
		else if ( vreg_timer_count < (MAX_WAIT_FOR_VREG_READY_US /
8f632528:	e2443001 	sub	r3, r4, #1
8f63252c:	e21340ff 	ands	r4, r3, #255	; 0xff
8f632530:	1afffff6 	bne	8f632510 <pm_vib_ldo_turn_on+0x90>
			dprintf(CRITICAL, "LDO failed to start in 1 msec, "
8f632534:	e30b0118 	movw	r0, #45336	; 0xb118
8f632538:	e3480f70 	movt	r0, #36720	; 0x8f70
8f63253c:	eb00010c 	bl	8f632974 <_dprintf>

/* Turn off vibrator */
void pm_vib_ldo_turn_off(void)
{
	if (!target_is_pmi_enabled())
8f632540:	ebffbdc2 	bl	8f621c50 <target_is_pmi_enabled>
8f632544:	e3500000 	cmp	r0, #0
8f632548:	0affffd5 	beq	8f6324a4 <pm_vib_ldo_turn_on+0x24>
		return;

	/* Clear Register VIB_LDO_EN_CTL to disable vibrator */
	pmic_spmi_reg_mask_write(QPNP_VIB_LDO_EN_CTL_REG,
8f63254c:	e59f3098 	ldr	r3, [pc, #152]	; 8f6325ec <pm_vib_ldo_turn_on+0x16c>
8f632550:	e5932000 	ldr	r2, [r3]
8f632554:	e59d3004 	ldr	r3, [r13, #4]
8f632558:	e0332002 	eors	r2, r3, r2
8f63255c:	e3a03000 	mov	r3, #0
8f632560:	1a000020 	bne	8f6325e8 <pm_vib_ldo_turn_on+0x168>
8f632564:	e3050746 	movw	r0, #22342	; 0x5746
8f632568:	e3a02000 	mov	r2, #0
8f63256c:	e3400003 	movt	r0, #3
8f632570:	e3a01080 	mov	r1, #128	; 0x80
}
8f632574:	e28dd00c 	add	r13, r13, #12
8f632578:	e8bd4030 	pop	{r4, r5, r14}
	pmic_spmi_reg_mask_write(QPNP_VIB_LDO_EN_CTL_REG,
8f63257c:	eaff7ab1 	b	8f611048 <pmic_spmi_reg_mask_write>
	udelay(OVERDRIVE_TIME_US);
8f632580:	e3070530 	movw	r0, #30000	; 0x7530
		status = pmic_spmi_reg_read(QPNP_VIB_LDO_STATUS1_REG);
8f632584:	e3055708 	movw	r5, #22280	; 0x5708
	udelay(OVERDRIVE_TIME_US);
8f632588:	ebff71f3 	bl	8f60ed5c <udelay>
	pmic_spmi_reg_mask_write(QPNP_VIB_LDO_VSET_LB_REG,
8f63258c:	e3a020b8 	mov	r2, #184	; 0xb8
8f632590:	e3a010ff 	mov	r1, #255	; 0xff
8f632594:	e3050740 	movw	r0, #22336	; 0x5740
8f632598:	e3400003 	movt	r0, #3
		status = pmic_spmi_reg_read(QPNP_VIB_LDO_STATUS1_REG);
8f63259c:	e3405003 	movt	r5, #3
	pmic_spmi_reg_mask_write(QPNP_VIB_LDO_VSET_LB_REG,
8f6325a0:	ebff7aa8 	bl	8f611048 <pmic_spmi_reg_mask_write>
	pmic_spmi_reg_mask_write(QPNP_VIB_LDO_VSET_UB_REG,
8f6325a4:	e3a0200b 	mov	r2, #11
8f6325a8:	e3a010ff 	mov	r1, #255	; 0xff
8f6325ac:	e3050741 	movw	r0, #22337	; 0x5741
8f6325b0:	e3400003 	movt	r0, #3
8f6325b4:	e1a04002 	mov	r4, r2
8f6325b8:	ebff7aa2 	bl	8f611048 <pmic_spmi_reg_mask_write>
	vreg_timer_count = 0;
8f6325bc:	ea000001 	b	8f6325c8 <pm_vib_ldo_turn_on+0x148>
			udelay(VREG_READY_STEP_DELAY_US);
8f6325c0:	e3a00064 	mov	r0, #100	; 0x64
8f6325c4:	ebff71e4 	bl	8f60ed5c <udelay>
		status = pmic_spmi_reg_read(QPNP_VIB_LDO_STATUS1_REG);
8f6325c8:	e1a00005 	mov	r0, r5
8f6325cc:	ebff7a7c 	bl	8f610fc4 <pmic_spmi_reg_read>
		if ( status & VREG_READY ) {
8f6325d0:	e3100080 	tst	r0, #128	; 0x80
8f6325d4:	1affffb2 	bne	8f6324a4 <pm_vib_ldo_turn_on+0x24>
		else if ( vreg_timer_count < (MAX_WAIT_FOR_VREG_READY_US /
8f6325d8:	e2443001 	sub	r3, r4, #1
8f6325dc:	e21340ff 	ands	r4, r3, #255	; 0xff
8f6325e0:	1afffff6 	bne	8f6325c0 <pm_vib_ldo_turn_on+0x140>
8f6325e4:	eaffffd2 	b	8f632534 <pm_vib_ldo_turn_on+0xb4>
}
8f6325e8:	eb000174 	bl	8f632bc0 <__stack_chk_fail>
8f6325ec:	8f74221c 	.word	0x8f74221c

8f6325f0 <pm_vib_ldo_turn_off>:
{
8f6325f0:	e59f3070 	ldr	r3, [pc, #112]	; 8f632668 <pm_vib_ldo_turn_off+0x78>
8f6325f4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6325f8:	e24dd00c 	sub	r13, r13, #12
8f6325fc:	e5933000 	ldr	r3, [r3]
8f632600:	e58d3004 	str	r3, [r13, #4]
8f632604:	e3a03000 	mov	r3, #0
	if (!target_is_pmi_enabled())
8f632608:	ebffbd90 	bl	8f621c50 <target_is_pmi_enabled>
				QPNP_VIB_LDO_EN_CTL_MASK,
				QPNP_VIB_LDO_DIS);
}
8f63260c:	e59f3054 	ldr	r3, [pc, #84]	; 8f632668 <pm_vib_ldo_turn_off+0x78>
	if (!target_is_pmi_enabled())
8f632610:	e3500000 	cmp	r0, #0
8f632614:	1a000006 	bne	8f632634 <pm_vib_ldo_turn_off+0x44>
}
8f632618:	e5932000 	ldr	r2, [r3]
8f63261c:	e59d3004 	ldr	r3, [r13, #4]
8f632620:	e0332002 	eors	r2, r3, r2
8f632624:	e3a03000 	mov	r3, #0
8f632628:	1a00000d 	bne	8f632664 <pm_vib_ldo_turn_off+0x74>
8f63262c:	e28dd00c 	add	r13, r13, #12
8f632630:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	pmic_spmi_reg_mask_write(QPNP_VIB_LDO_EN_CTL_REG,
8f632634:	e5932000 	ldr	r2, [r3]
8f632638:	e59d3004 	ldr	r3, [r13, #4]
8f63263c:	e0332002 	eors	r2, r3, r2
8f632640:	e3a03000 	mov	r3, #0
8f632644:	1a000006 	bne	8f632664 <pm_vib_ldo_turn_off+0x74>
8f632648:	e3050746 	movw	r0, #22342	; 0x5746
8f63264c:	e3a02000 	mov	r2, #0
8f632650:	e3400003 	movt	r0, #3
8f632654:	e3a01080 	mov	r1, #128	; 0x80
}
8f632658:	e28dd00c 	add	r13, r13, #12
8f63265c:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	pmic_spmi_reg_mask_write(QPNP_VIB_LDO_EN_CTL_REG,
8f632660:	eaff7a78 	b	8f611048 <pmic_spmi_reg_mask_write>
}
8f632664:	eb000155 	bl	8f632bc0 <__stack_chk_fail>
8f632668:	8f74221c 	.word	0x8f74221c

8f63266c <vib_timer_func>:
}

#if !USE_VIB_THREAD
/* Function to turn off vibrator when the vib_timer is expired. */
static enum handler_return vib_timer_func(struct timer *v_timer, time_t t, void *arg)
{
8f63266c:	e92d4010 	push	{r4, r14}
	timer_cancel(&vib_timer);
	if(!vib_timeout){
8f632670:	e30445fc 	movw	r4, #17916	; 0x45fc
{
8f632674:	e59f3074 	ldr	r3, [pc, #116]	; 8f6326f0 <vib_timer_func+0x84>
	if(!vib_timeout){
8f632678:	e3484f72 	movt	r4, #36722	; 0x8f72
{
8f63267c:	e24dd008 	sub	r13, r13, #8
	timer_cancel(&vib_timer);
8f632680:	e30201e4 	movw	r0, #8676	; 0x21e4
8f632684:	e3480f74 	movt	r0, #36724	; 0x8f74
{
8f632688:	e5933000 	ldr	r3, [r3]
8f63268c:	e58d3004 	str	r3, [r13, #4]
8f632690:	e3a03000 	mov	r3, #0
	timer_cancel(&vib_timer);
8f632694:	ebffcab5 	bl	8f625170 <timer_cancel>
	if(!vib_timeout){
8f632698:	e5943000 	ldr	r3, [r4]
8f63269c:	e3530000 	cmp	r3, #0
8f6326a0:	0a000008 	beq	8f6326c8 <vib_timer_func+0x5c>
		vib_turn_off();
		vib_timeout = 1;
	}

	return INT_RESCHEDULE;
}
8f6326a4:	e59f3044 	ldr	r3, [pc, #68]	; 8f6326f0 <vib_timer_func+0x84>
8f6326a8:	e5932000 	ldr	r2, [r3]
8f6326ac:	e59d3004 	ldr	r3, [r13, #4]
8f6326b0:	e0332002 	eors	r2, r3, r2
8f6326b4:	e3a03000 	mov	r3, #0
8f6326b8:	1a00000b 	bne	8f6326ec <vib_timer_func+0x80>
8f6326bc:	e3a00001 	mov	r0, #1
8f6326c0:	e28dd008 	add	r13, r13, #8
8f6326c4:	e8bd8010 	pop	{r4, r15}
	uint32_t pmic = target_get_pmic();
8f6326c8:	ebff3a78 	bl	8f6010b0 <target_get_pmic>
	if (pmic == PMIC_IS_PM8916)
8f6326cc:	e350000b 	cmp	r0, #11
8f6326d0:	0a000003 	beq	8f6326e4 <vib_timer_func+0x78>
		pm_vib_turn_off();
8f6326d4:	ebfffec0 	bl	8f6321dc <pm_vib_turn_off>
		vib_timeout = 1;
8f6326d8:	e3a03001 	mov	r3, #1
8f6326dc:	e5843000 	str	r3, [r4]
8f6326e0:	eaffffef 	b	8f6326a4 <vib_timer_func+0x38>
		pm8x41_vib_turn_off();
8f6326e4:	ebfffbba 	bl	8f6315d4 <pm8x41_vib_turn_off>
8f6326e8:	eafffffa 	b	8f6326d8 <vib_timer_func+0x6c>
}
8f6326ec:	eb000133 	bl	8f632bc0 <__stack_chk_fail>
8f6326f0:	8f74221c 	.word	0x8f74221c

8f6326f4 <vib_turn_off>:
{
8f6326f4:	e59f3064 	ldr	r3, [pc, #100]	; 8f632760 <vib_turn_off+0x6c>
8f6326f8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6326fc:	e24dd00c 	sub	r13, r13, #12
8f632700:	e5933000 	ldr	r3, [r3]
8f632704:	e58d3004 	str	r3, [r13, #4]
8f632708:	e3a03000 	mov	r3, #0
	uint32_t pmic = target_get_pmic();
8f63270c:	ebff3a67 	bl	8f6010b0 <target_get_pmic>
		pm8x41_vib_turn_off();
8f632710:	e59f3048 	ldr	r3, [pc, #72]	; 8f632760 <vib_turn_off+0x6c>
	if (pmic == PMIC_IS_PM8916)
8f632714:	e350000b 	cmp	r0, #11
8f632718:	0a000007 	beq	8f63273c <vib_turn_off+0x48>
		pm_vib_turn_off();
8f63271c:	e5932000 	ldr	r2, [r3]
8f632720:	e59d3004 	ldr	r3, [r13, #4]
8f632724:	e0332002 	eors	r2, r3, r2
8f632728:	e3a03000 	mov	r3, #0
8f63272c:	1a00000a 	bne	8f63275c <vib_turn_off+0x68>
}
8f632730:	e28dd00c 	add	r13, r13, #12
8f632734:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		pm_vib_turn_off();
8f632738:	eafffea7 	b	8f6321dc <pm_vib_turn_off>
		pm8x41_vib_turn_off();
8f63273c:	e5932000 	ldr	r2, [r3]
8f632740:	e59d3004 	ldr	r3, [r13, #4]
8f632744:	e0332002 	eors	r2, r3, r2
8f632748:	e3a03000 	mov	r3, #0
8f63274c:	1a000002 	bne	8f63275c <vib_turn_off+0x68>
}
8f632750:	e28dd00c 	add	r13, r13, #12
8f632754:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
		pm8x41_vib_turn_off();
8f632758:	eafffb9d 	b	8f6315d4 <pm8x41_vib_turn_off>
		pm_vib_turn_off();
8f63275c:	eb000117 	bl	8f632bc0 <__stack_chk_fail>
8f632760:	8f74221c 	.word	0x8f74221c

8f632764 <vib_timed_turn_on>:
/*
 * Function to turn on vibrator.
 * vibrate_time - the time of phone vibrate.
 */
void vib_timed_turn_on(const uint32_t vibrate_time)
{
8f632764:	e92d4070 	push	{r4, r5, r6, r14}
#if USE_VIB_THREAD
	thread_t *thr;
#endif

	if(!vib_timeout){
8f632768:	e30445fc 	movw	r4, #17916	; 0x45fc
{
8f63276c:	e59f30b8 	ldr	r3, [pc, #184]	; 8f63282c <vib_timed_turn_on+0xc8>
	if(!vib_timeout){
8f632770:	e3484f72 	movt	r4, #36722	; 0x8f72
{
8f632774:	e24dd008 	sub	r13, r13, #8
8f632778:	e5933000 	ldr	r3, [r3]
8f63277c:	e58d3004 	str	r3, [r13, #4]
8f632780:	e3a03000 	mov	r3, #0
	if(!vib_timeout){
8f632784:	e5943000 	ldr	r3, [r4]
8f632788:	e3530000 	cmp	r3, #0
8f63278c:	0a00001a 	beq	8f6327fc <vib_timed_turn_on+0x98>
	uint32_t pmic = target_get_pmic();
8f632790:	e1a05000 	mov	r5, r0
8f632794:	ebff3a45 	bl	8f6010b0 <target_get_pmic>
	if (pmic == PMIC_IS_PM8916)
8f632798:	e350000b 	cmp	r0, #11
8f63279c:	0a000014 	beq	8f6327f4 <vib_timed_turn_on+0x90>
		pm_vib_turn_on();
8f6327a0:	ebfffe6f 	bl	8f632164 <pm_vib_turn_on>
		return;
	}
	vib_turn_on();
	vib_timeout = 0;
#if !USE_VIB_THREAD
	timer_initialize(&vib_timer);
8f6327a4:	e30201e4 	movw	r0, #8676	; 0x21e4
8f6327a8:	e3480f74 	movt	r0, #36724	; 0x8f74
	vib_timeout = 0;
8f6327ac:	e3a06000 	mov	r6, #0
8f6327b0:	e5846000 	str	r6, [r4]
	timer_initialize(&vib_timer);
8f6327b4:	ebffca3d 	bl	8f6250b0 <timer_initialize>
	timer_set_oneshot(&vib_timer, vibrate_time, vib_timer_func, NULL);
8f6327b8:	e59f306c 	ldr	r3, [pc, #108]	; 8f63282c <vib_timed_turn_on+0xc8>
8f6327bc:	e5932000 	ldr	r2, [r3]
8f6327c0:	e59d3004 	ldr	r3, [r13, #4]
8f6327c4:	e0332002 	eors	r2, r3, r2
8f6327c8:	e3a03000 	mov	r3, #0
8f6327cc:	1a000015 	bne	8f632828 <vib_timed_turn_on+0xc4>
8f6327d0:	e302266c 	movw	r2, #9836	; 0x266c
8f6327d4:	e30201e4 	movw	r0, #8676	; 0x21e4
8f6327d8:	e3482f63 	movt	r2, #36707	; 0x8f63
8f6327dc:	e3480f74 	movt	r0, #36724	; 0x8f74
8f6327e0:	e1a03006 	mov	r3, r6
8f6327e4:	e1a01005 	mov	r1, r5
		panic("failed to create vibrator thread\n");
	}
	thread_resume(thr);

#endif
}
8f6327e8:	e28dd008 	add	r13, r13, #8
8f6327ec:	e8bd4070 	pop	{r4, r5, r6, r14}
	timer_set_oneshot(&vib_timer, vibrate_time, vib_timer_func, NULL);
8f6327f0:	eaffca47 	b	8f625114 <timer_set_oneshot>
		pm8x41_vib_turn_on();
8f6327f4:	ebfffb32 	bl	8f6314c4 <pm8x41_vib_turn_on>
8f6327f8:	eaffffe9 	b	8f6327a4 <vib_timed_turn_on+0x40>
		dprintf(CRITICAL,"vibrator already turn on\n");
8f6327fc:	e59f3028 	ldr	r3, [pc, #40]	; 8f63282c <vib_timed_turn_on+0xc8>
8f632800:	e5932000 	ldr	r2, [r3]
8f632804:	e59d3004 	ldr	r3, [r13, #4]
8f632808:	e0332002 	eors	r2, r3, r2
8f63280c:	e3a03000 	mov	r3, #0
8f632810:	1a000004 	bne	8f632828 <vib_timed_turn_on+0xc4>
8f632814:	e30b0150 	movw	r0, #45392	; 0xb150
8f632818:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f63281c:	e28dd008 	add	r13, r13, #8
8f632820:	e8bd4070 	pop	{r4, r5, r6, r14}
		dprintf(CRITICAL,"vibrator already turn on\n");
8f632824:	ea000052 	b	8f632974 <_dprintf>
	timer_set_oneshot(&vib_timer, vibrate_time, vib_timer_func, NULL);
8f632828:	eb0000e4 	bl	8f632bc0 <__stack_chk_fail>
8f63282c:	8f74221c 	.word	0x8f74221c

8f632830 <turn_off_vib_early>:
		thread_sleep(CHECK_VIB_TIMER_FREQUENCY);
	}
}

void turn_off_vib_early(void)
{
8f632830:	e92d4010 	push	{r4, r14}
	if(vib_timeout) {
8f632834:	e30445fc 	movw	r4, #17916	; 0x45fc
{
8f632838:	e59f3064 	ldr	r3, [pc, #100]	; 8f6328a4 <turn_off_vib_early+0x74>
	if(vib_timeout) {
8f63283c:	e3484f72 	movt	r4, #36722	; 0x8f72
{
8f632840:	e24dd008 	sub	r13, r13, #8
8f632844:	e5933000 	ldr	r3, [r3]
8f632848:	e58d3004 	str	r3, [r13, #4]
8f63284c:	e3a03000 	mov	r3, #0
	if(vib_timeout) {
8f632850:	e5943000 	ldr	r3, [r4]
8f632854:	e3530000 	cmp	r3, #0
8f632858:	0a000007 	beq	8f63287c <turn_off_vib_early+0x4c>
		return;
	}
	vib_turn_off();
	vib_timeout = 1;
}
8f63285c:	e59f3040 	ldr	r3, [pc, #64]	; 8f6328a4 <turn_off_vib_early+0x74>
8f632860:	e5932000 	ldr	r2, [r3]
8f632864:	e59d3004 	ldr	r3, [r13, #4]
8f632868:	e0332002 	eors	r2, r3, r2
8f63286c:	e3a03000 	mov	r3, #0
8f632870:	1a00000a 	bne	8f6328a0 <turn_off_vib_early+0x70>
8f632874:	e28dd008 	add	r13, r13, #8
8f632878:	e8bd8010 	pop	{r4, r15}
	uint32_t pmic = target_get_pmic();
8f63287c:	ebff3a0b 	bl	8f6010b0 <target_get_pmic>
	if (pmic == PMIC_IS_PM8916)
8f632880:	e350000b 	cmp	r0, #11
8f632884:	0a000003 	beq	8f632898 <turn_off_vib_early+0x68>
		pm_vib_turn_off();
8f632888:	ebfffe53 	bl	8f6321dc <pm_vib_turn_off>
	vib_timeout = 1;
8f63288c:	e3a03001 	mov	r3, #1
8f632890:	e5843000 	str	r3, [r4]
8f632894:	eafffff0 	b	8f63285c <turn_off_vib_early+0x2c>
		pm8x41_vib_turn_off();
8f632898:	ebfffb4d 	bl	8f6315d4 <pm8x41_vib_turn_off>
8f63289c:	eafffffa 	b	8f63288c <turn_off_vib_early+0x5c>
}
8f6328a0:	eb0000c6 	bl	8f632bc0 <__stack_chk_fail>
8f6328a4:	8f74221c 	.word	0x8f74221c

8f6328a8 <halt>:
	while ((current_time_hires() - start) < usecs)
		;	
}

void halt(void)
{
8f6328a8:	e59f305c 	ldr	r3, [pc, #92]	; 8f63290c <halt+0x64>
	critical_section_count++;
8f6328ac:	e3012acc 	movw	r2, #6860	; 0x1acc
8f6328b0:	e3482f71 	movt	r2, #36721	; 0x8f71
8f6328b4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6328b8:	e24dd00c 	sub	r13, r13, #12
8f6328bc:	e5933000 	ldr	r3, [r3]
8f6328c0:	e58d3004 	str	r3, [r13, #4]
8f6328c4:	e3a03000 	mov	r3, #0
8f6328c8:	e5923000 	ldr	r3, [r2]
8f6328cc:	e2833001 	add	r3, r3, #1
8f6328d0:	e5823000 	str	r3, [r2]
	if (critical_section_count == 1)
8f6328d4:	e3530001 	cmp	r3, #1
8f6328d8:	0a000008 	beq	8f632900 <halt+0x58>
	enter_critical_section(); // disable ints
	platform_halt();
8f6328dc:	e59f3028 	ldr	r3, [pc, #40]	; 8f63290c <halt+0x64>
8f6328e0:	e5932000 	ldr	r2, [r3]
8f6328e4:	e59d3004 	ldr	r3, [r13, #4]
8f6328e8:	e0332002 	eors	r2, r3, r2
8f6328ec:	e3a03000 	mov	r3, #0
8f6328f0:	1a000004 	bne	8f632908 <halt+0x60>
}
8f6328f4:	e28dd00c 	add	r13, r13, #12
8f6328f8:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	platform_halt();
8f6328fc:	eaff3fb2 	b	8f6027cc <platform_halt>
		arch_disable_ints();
8f632900:	ebffb9c4 	bl	8f621018 <arch_disable_ints>
8f632904:	eafffff4 	b	8f6328dc <halt+0x34>
8f632908:	eb0000ac 	bl	8f632bc0 <__stack_chk_fail>
8f63290c:	8f74221c 	.word	0x8f74221c

8f632910 <_dputs>:

	halt();
}

int _dputs(const char *str)
{
8f632910:	e92d4010 	push	{r4, r14}
8f632914:	e1a04000 	mov	r4, r0
	while(*str != 0) {
8f632918:	e5d00000 	ldrb	r0, [r0]
{
8f63291c:	e24dd008 	sub	r13, r13, #8
8f632920:	e59f3048 	ldr	r3, [pc, #72]	; 8f632970 <_dputs+0x60>
	while(*str != 0) {
8f632924:	e3500000 	cmp	r0, #0
{
8f632928:	e5933000 	ldr	r3, [r3]
8f63292c:	e58d3004 	str	r3, [r13, #4]
8f632930:	e3a03000 	mov	r3, #0
	while(*str != 0) {
8f632934:	0a000003 	beq	8f632948 <_dputs+0x38>
		_dputc(*str++);
8f632938:	ebff3f81 	bl	8f602744 <_dputc>
	while(*str != 0) {
8f63293c:	e5f40001 	ldrb	r0, [r4, #1]!
8f632940:	e3500000 	cmp	r0, #0
8f632944:	1afffffb 	bne	8f632938 <_dputs+0x28>
	}

	return 0;
}
8f632948:	e59f3020 	ldr	r3, [pc, #32]	; 8f632970 <_dputs+0x60>
8f63294c:	e5932000 	ldr	r2, [r3]
8f632950:	e59d3004 	ldr	r3, [r13, #4]
8f632954:	e0332002 	eors	r2, r3, r2
8f632958:	e3a03000 	mov	r3, #0
8f63295c:	1a000002 	bne	8f63296c <_dputs+0x5c>
8f632960:	e3a00000 	mov	r0, #0
8f632964:	e28dd008 	add	r13, r13, #8
8f632968:	e8bd8010 	pop	{r4, r15}
8f63296c:	eb000093 	bl	8f632bc0 <__stack_chk_fail>
8f632970:	8f74221c 	.word	0x8f74221c

8f632974 <_dprintf>:

int _dprintf(const char *fmt, ...)
{
8f632974:	e92d000f 	push	{r0, r1, r2, r3}
8f632978:	e59f30bc 	ldr	r3, [pc, #188]	; 8f632a3c <_dprintf+0xc8>
8f63297c:	e92d4030 	push	{r4, r5, r14}
8f632980:	e24ddf47 	sub	r13, r13, #284	; 0x11c
8f632984:	e5933000 	ldr	r3, [r3]
8f632988:	e58d3114 	str	r3, [r13, #276]	; 0x114
8f63298c:	e3a03000 	mov	r3, #0
8f632990:	e59d5128 	ldr	r5, [r13, #296]	; 0x128
	char buf[256];
	char ts_buf[13];
	int err;

	snprintf(ts_buf, sizeof(ts_buf), "[%u] ",(unsigned int)current_time());
8f632994:	ebff70b6 	bl	8f60ec74 <current_time>
8f632998:	e30b216c 	movw	r2, #45420	; 0xb16c
8f63299c:	e3a0100d 	mov	r1, #13
8f6329a0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6329a4:	e1a03000 	mov	r3, r0
8f6329a8:	e28d0004 	add	r0, r13, #4
8f6329ac:	eb000563 	bl	8f633f40 <snprintf>
	while(*str != 0) {
8f6329b0:	e5dd0004 	ldrb	r0, [r13, #4]
8f6329b4:	e3500000 	cmp	r0, #0
8f6329b8:	0a000004 	beq	8f6329d0 <_dprintf+0x5c>
8f6329bc:	e28d4004 	add	r4, r13, #4
		_dputc(*str++);
8f6329c0:	ebff3f5f 	bl	8f602744 <_dputc>
	while(*str != 0) {
8f6329c4:	e5f40001 	ldrb	r0, [r4, #1]!
8f6329c8:	e3500000 	cmp	r0, #0
8f6329cc:	1afffffb 	bne	8f6329c0 <_dprintf+0x4c>
	dputs(ALWAYS, ts_buf);

	va_list ap;
	va_start(ap, fmt);
8f6329d0:	e28d3f4b 	add	r3, r13, #300	; 0x12c
	err = vsnprintf(buf, sizeof(buf), fmt, ap);
8f6329d4:	e1a02005 	mov	r2, r5
8f6329d8:	e28d0014 	add	r0, r13, #20
8f6329dc:	e3a01c01 	mov	r1, #256	; 0x100
	va_start(ap, fmt);
8f6329e0:	e58d3000 	str	r3, [r13]
	err = vsnprintf(buf, sizeof(buf), fmt, ap);
8f6329e4:	eb000399 	bl	8f633850 <vsnprintf>
8f6329e8:	e1a05000 	mov	r5, r0
	while(*str != 0) {
8f6329ec:	e5dd0014 	ldrb	r0, [r13, #20]
8f6329f0:	e3500000 	cmp	r0, #0
8f6329f4:	0a000004 	beq	8f632a0c <_dprintf+0x98>
8f6329f8:	e28d4014 	add	r4, r13, #20
		_dputc(*str++);
8f6329fc:	ebff3f50 	bl	8f602744 <_dputc>
	while(*str != 0) {
8f632a00:	e5f40001 	ldrb	r0, [r4, #1]!
8f632a04:	e3500000 	cmp	r0, #0
8f632a08:	1afffffb 	bne	8f6329fc <_dprintf+0x88>
	va_end(ap);

	dputs(ALWAYS, buf);

	return err;
}
8f632a0c:	e59f3028 	ldr	r3, [pc, #40]	; 8f632a3c <_dprintf+0xc8>
8f632a10:	e5932000 	ldr	r2, [r3]
8f632a14:	e59d3114 	ldr	r3, [r13, #276]	; 0x114
8f632a18:	e0332002 	eors	r2, r3, r2
8f632a1c:	e3a03000 	mov	r3, #0
8f632a20:	1a000004 	bne	8f632a38 <_dprintf+0xc4>
8f632a24:	e1a00005 	mov	r0, r5
8f632a28:	e28ddf47 	add	r13, r13, #284	; 0x11c
8f632a2c:	e8bd4030 	pop	{r4, r5, r14}
8f632a30:	e28dd010 	add	r13, r13, #16
8f632a34:	e12fff1e 	bx	r14
8f632a38:	eb000060 	bl	8f632bc0 <__stack_chk_fail>
8f632a3c:	8f74221c 	.word	0x8f74221c

8f632a40 <_dvprintf>:

int _dvprintf(const char *fmt, va_list ap)
{
8f632a40:	e92d4030 	push	{r4, r5, r14}
8f632a44:	e24ddf43 	sub	r13, r13, #268	; 0x10c
8f632a48:	e59fc068 	ldr	r12, [pc, #104]	; 8f632ab8 <_dvprintf+0x78>
8f632a4c:	e1a02000 	mov	r2, r0
8f632a50:	e1a03001 	mov	r3, r1
	char buf[256];
	int err;

	err = vsnprintf(buf, sizeof(buf), fmt, ap);
8f632a54:	e28d0004 	add	r0, r13, #4
8f632a58:	e3a01c01 	mov	r1, #256	; 0x100
{
8f632a5c:	e59cc000 	ldr	r12, [r12]
8f632a60:	e58dc104 	str	r12, [r13, #260]	; 0x104
8f632a64:	e3a0c000 	mov	r12, #0
	err = vsnprintf(buf, sizeof(buf), fmt, ap);
8f632a68:	eb000378 	bl	8f633850 <vsnprintf>
8f632a6c:	e1a05000 	mov	r5, r0
	while(*str != 0) {
8f632a70:	e5dd0004 	ldrb	r0, [r13, #4]
8f632a74:	e3500000 	cmp	r0, #0
8f632a78:	0a000004 	beq	8f632a90 <_dvprintf+0x50>
8f632a7c:	e28d4004 	add	r4, r13, #4
		_dputc(*str++);
8f632a80:	ebff3f2f 	bl	8f602744 <_dputc>
	while(*str != 0) {
8f632a84:	e5f40001 	ldrb	r0, [r4, #1]!
8f632a88:	e3500000 	cmp	r0, #0
8f632a8c:	1afffffb 	bne	8f632a80 <_dvprintf+0x40>

	dputs(ALWAYS, buf);

	return err;
}
8f632a90:	e59f3020 	ldr	r3, [pc, #32]	; 8f632ab8 <_dvprintf+0x78>
8f632a94:	e5932000 	ldr	r2, [r3]
8f632a98:	e59d3104 	ldr	r3, [r13, #260]	; 0x104
8f632a9c:	e0332002 	eors	r2, r3, r2
8f632aa0:	e3a03000 	mov	r3, #0
8f632aa4:	1a000002 	bne	8f632ab4 <_dvprintf+0x74>
8f632aa8:	e1a00005 	mov	r0, r5
8f632aac:	e28ddf43 	add	r13, r13, #268	; 0x10c
8f632ab0:	e8bd8030 	pop	{r4, r5, r15}
8f632ab4:	eb000041 	bl	8f632bc0 <__stack_chk_fail>
8f632ab8:	8f74221c 	.word	0x8f74221c

8f632abc <_panic>:
{
8f632abc:	e92d000e 	push	{r1, r2, r3}
8f632ac0:	e92d4870 	push	{r4, r5, r6, r11, r14}
8f632ac4:	e28db010 	add	r11, r13, #16
8f632ac8:	e24dd010 	sub	r13, r13, #16
8f632acc:	e59f30e8 	ldr	r3, [pc, #232]	; 8f632bbc <_panic+0x100>
	critical_section_count++;
8f632ad0:	e3014acc 	movw	r4, #6860	; 0x1acc
8f632ad4:	e3484f71 	movt	r4, #36721	; 0x8f71
8f632ad8:	e1a05000 	mov	r5, r0
	dprintf(ALWAYS, "panic (frame %p): \n", __GET_FRAME());
8f632adc:	e1a0100b 	mov	r1, r11
8f632ae0:	e30b0174 	movw	r0, #45428	; 0xb174
8f632ae4:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f632ae8:	e5933000 	ldr	r3, [r3]
8f632aec:	e50b3014 	str	r3, [r11, #-20]	; 0xffffffec
8f632af0:	e3a03000 	mov	r3, #0
8f632af4:	e59b6004 	ldr	r6, [r11, #4]
	dprintf(ALWAYS, "panic (frame %p): \n", __GET_FRAME());
8f632af8:	ebffff9d 	bl	8f632974 <_dprintf>
8f632afc:	e5943000 	ldr	r3, [r4]
	dump_frame(__GET_FRAME());
8f632b00:	e1a0000b 	mov	r0, r11
8f632b04:	e2833001 	add	r3, r3, #1
8f632b08:	e5843000 	str	r3, [r4]
	if (critical_section_count == 1)
8f632b0c:	e3530001 	cmp	r3, #1
8f632b10:	0a000022 	beq	8f632ba0 <_panic+0xe4>
	dump_fault_frame((struct arm_fault_frame *)frame);
8f632b14:	ebffb9c0 	bl	8f62121c <dump_fault_frame>
	critical_section_count--;
8f632b18:	e5943000 	ldr	r3, [r4]
8f632b1c:	e2433001 	sub	r3, r3, #1
8f632b20:	e5843000 	str	r3, [r4]
	if (critical_section_count == 0)
8f632b24:	e3530000 	cmp	r3, #0
8f632b28:	0a00001a 	beq	8f632b98 <_panic+0xdc>
	dprintf(ALWAYS, "panic (caller %p): ", caller);
8f632b2c:	e1a01005 	mov	r1, r5
8f632b30:	e30b0188 	movw	r0, #45448	; 0xb188
8f632b34:	e3480f70 	movt	r0, #36720	; 0x8f70
8f632b38:	ebffff8d 	bl	8f632974 <_dprintf>
	va_start(ap, fmt);
8f632b3c:	e28b1008 	add	r1, r11, #8
	_dvprintf(fmt, ap);
8f632b40:	e1a00006 	mov	r0, r6
	va_start(ap, fmt);
8f632b44:	e50b1018 	str	r1, [r11, #-24]	; 0xffffffe8
	_dvprintf(fmt, ap);
8f632b48:	ebffffbc 	bl	8f632a40 <_dvprintf>
	lk2nd_panic_hook();
8f632b4c:	ebffebf8 	bl	8f62db34 <lk2nd_panic_hook>
	mdelay(5000);
8f632b50:	e3010388 	movw	r0, #5000	; 0x1388
8f632b54:	ebff7068 	bl	8f60ecfc <mdelay>
	critical_section_count++;
8f632b58:	e5943000 	ldr	r3, [r4]
8f632b5c:	e2833001 	add	r3, r3, #1
8f632b60:	e5843000 	str	r3, [r4]
	if (critical_section_count == 1)
8f632b64:	e3530001 	cmp	r3, #1
8f632b68:	0a000010 	beq	8f632bb0 <_panic+0xf4>
	platform_halt();
8f632b6c:	ebff3f16 	bl	8f6027cc <platform_halt>
}
8f632b70:	e59f3044 	ldr	r3, [pc, #68]	; 8f632bbc <_panic+0x100>
8f632b74:	e5932000 	ldr	r2, [r3]
8f632b78:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
8f632b7c:	e0332002 	eors	r2, r3, r2
8f632b80:	e3a03000 	mov	r3, #0
8f632b84:	1a00000b 	bne	8f632bb8 <_panic+0xfc>
8f632b88:	e24bd010 	sub	r13, r11, #16
8f632b8c:	e8bd4870 	pop	{r4, r5, r6, r11, r14}
8f632b90:	e28dd00c 	add	r13, r13, #12
8f632b94:	e12fff1e 	bx	r14
		arch_enable_ints();
8f632b98:	ebffb91a 	bl	8f621008 <arch_enable_ints>
8f632b9c:	eaffffe2 	b	8f632b2c <_panic+0x70>
8f632ba0:	e50bb01c 	str	r11, [r11, #-28]	; 0xffffffe4
		arch_disable_ints();
8f632ba4:	ebffb91b 	bl	8f621018 <arch_disable_ints>
8f632ba8:	e51b001c 	ldr	r0, [r11, #-28]	; 0xffffffe4
8f632bac:	eaffffd8 	b	8f632b14 <_panic+0x58>
8f632bb0:	ebffb918 	bl	8f621018 <arch_disable_ints>
8f632bb4:	eaffffec 	b	8f632b6c <_panic+0xb0>
8f632bb8:	eb000000 	bl	8f632bc0 <__stack_chk_fail>
8f632bbc:	8f74221c 	.word	0x8f74221c

8f632bc0 <__stack_chk_fail>:
{
8f632bc0:	e59f3024 	ldr	r3, [pc, #36]	; 8f632bec <__stack_chk_fail+0x2c>
	panic("stack smashing detected.");
8f632bc4:	e30b119c 	movw	r1, #45468	; 0xb19c
{
8f632bc8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	panic("stack smashing detected.");
8f632bcc:	e3481f70 	movt	r1, #36720	; 0x8f70
{
8f632bd0:	e24dd00c 	sub	r13, r13, #12
8f632bd4:	e1a0000e 	mov	r0, r14
8f632bd8:	e5933000 	ldr	r3, [r3]
8f632bdc:	e58d3004 	str	r3, [r13, #4]
8f632be0:	e3a03000 	mov	r3, #0
	panic("stack smashing detected.");
8f632be4:	ebffffb4 	bl	8f632abc <_panic>
	for(;;);
8f632be8:	eafffffe 	b	8f632be8 <__stack_chk_fail+0x28>
8f632bec:	8f74221c 	.word	0x8f74221c

8f632bf0 <hexdump>:

void hexdump(const void *ptr, size_t len)
{
8f632bf0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f632bf4:	e24dd01c 	sub	r13, r13, #28
	addr_t address = (addr_t)ptr;
	size_t count;
	int i;

	for (count = 0 ; count < len; count += 16) {
8f632bf8:	e2513000 	subs	r3, r1, #0
8f632bfc:	e58d3008 	str	r3, [r13, #8]
{
8f632c00:	e59f30fc 	ldr	r3, [pc, #252]	; 8f632d04 <hexdump+0x114>
8f632c04:	e5933000 	ldr	r3, [r3]
8f632c08:	e58d3014 	str	r3, [r13, #20]
8f632c0c:	e3a03000 	mov	r3, #0
	for (count = 0 ; count < len; count += 16) {
8f632c10:	0a000032 	beq	8f632ce0 <hexdump+0xf0>
		printf("0x%08lx: ", address);
8f632c14:	e30bb1b8 	movw	r11, #45496	; 0xb1b8
		printf("%08x %08x %08x %08x |", *(const uint32_t *)address, *(const uint32_t *)(address + 4), *(const uint32_t *)(address + 8), *(const uint32_t *)(address + 12));
8f632c18:	e30ba1c4 	movw	r10, #45508	; 0xb1c4
		for (i=0; i < 16; i++) {
			char c = *(const char *)(address + i);
			if (isalpha(c)) {
				printf("%c", c);
			} else {
				printf(".");
8f632c1c:	e30960c4 	movw	r6, #37060	; 0x90c4
8f632c20:	e2804010 	add	r4, r0, #16
		printf("0x%08lx: ", address);
8f632c24:	e348bf70 	movt	r11, #36720	; 0x8f70
		printf("%08x %08x %08x %08x |", *(const uint32_t *)address, *(const uint32_t *)(address + 4), *(const uint32_t *)(address + 8), *(const uint32_t *)(address + 12));
8f632c28:	e348af70 	movt	r10, #36720	; 0x8f70
				printf(".");
8f632c2c:	e3486f70 	movt	r6, #36720	; 0x8f70
8f632c30:	e30f3ff0 	movw	r3, #65520	; 0xfff0
	addr_t address = (addr_t)ptr;
8f632c34:	e1a07000 	mov	r7, r0
8f632c38:	e34f3fff 	movt	r3, #65535	; 0xffff
8f632c3c:	e0433000 	sub	r3, r3, r0
8f632c40:	e58d300c 	str	r3, [r13, #12]
		printf("0x%08lx: ", address);
8f632c44:	e1a01007 	mov	r1, r7
8f632c48:	e1a0000b 	mov	r0, r11
8f632c4c:	eb0002e8 	bl	8f6337f4 <printf>
		printf("%08x %08x %08x %08x |", *(const uint32_t *)address, *(const uint32_t *)(address + 4), *(const uint32_t *)(address + 8), *(const uint32_t *)(address + 12));
8f632c50:	e514c004 	ldr	r12, [r4, #-4]
8f632c54:	e14420dc 	ldrd	r2, [r4, #-12]
8f632c58:	e1a0000a 	mov	r0, r10
8f632c5c:	e5141010 	ldr	r1, [r4, #-16]
				printf("%c", c);
8f632c60:	e30b51dc 	movw	r5, #45532	; 0xb1dc
		printf("%08x %08x %08x %08x |", *(const uint32_t *)address, *(const uint32_t *)(address + 4), *(const uint32_t *)(address + 8), *(const uint32_t *)(address + 12));
8f632c64:	e58dc000 	str	r12, [r13]
				printf("%c", c);
8f632c68:	e3485f70 	movt	r5, #36720	; 0x8f70
		printf("%08x %08x %08x %08x |", *(const uint32_t *)address, *(const uint32_t *)(address + 4), *(const uint32_t *)(address + 8), *(const uint32_t *)(address + 12));
8f632c6c:	eb0002e0 	bl	8f6337f4 <printf>
8f632c70:	e1a08007 	mov	r8, r7
8f632c74:	ea000005 	b	8f632c90 <hexdump+0xa0>
		for (i=0; i < 16; i++) {
8f632c78:	e2888001 	add	r8, r8, #1
				printf("%c", c);
8f632c7c:	e1a01009 	mov	r1, r9
8f632c80:	e1a00005 	mov	r0, r5
8f632c84:	eb0002da 	bl	8f6337f4 <printf>
		for (i=0; i < 16; i++) {
8f632c88:	e1540008 	cmp	r4, r8
8f632c8c:	0a000009 	beq	8f632cb8 <hexdump+0xc8>
			if (isalpha(c)) {
8f632c90:	e5d89000 	ldrb	r9, [r8]
8f632c94:	e1a00009 	mov	r0, r9
8f632c98:	eb000205 	bl	8f6334b4 <isalpha>
8f632c9c:	e3500000 	cmp	r0, #0
8f632ca0:	1afffff4 	bne	8f632c78 <hexdump+0x88>
		for (i=0; i < 16; i++) {
8f632ca4:	e2888001 	add	r8, r8, #1
				printf(".");
8f632ca8:	e1a00006 	mov	r0, r6
8f632cac:	eb0002d0 	bl	8f6337f4 <printf>
		for (i=0; i < 16; i++) {
8f632cb0:	e1540008 	cmp	r4, r8
8f632cb4:	1afffff5 	bne	8f632c90 <hexdump+0xa0>
			}
		}
		printf("|\n");
8f632cb8:	e30b01e0 	movw	r0, #45536	; 0xb1e0
8f632cbc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f632cc0:	eb0002cb 	bl	8f6337f4 <printf>
	for (count = 0 ; count < len; count += 16) {
8f632cc4:	e59d300c 	ldr	r3, [r13, #12]
8f632cc8:	e59d2008 	ldr	r2, [r13, #8]
8f632ccc:	e2844010 	add	r4, r4, #16
8f632cd0:	e0833004 	add	r3, r3, r4
		address += 16;
8f632cd4:	e2877010 	add	r7, r7, #16
	for (count = 0 ; count < len; count += 16) {
8f632cd8:	e1520003 	cmp	r2, r3
8f632cdc:	8affffd8 	bhi	8f632c44 <hexdump+0x54>
	}	
}
8f632ce0:	e59f301c 	ldr	r3, [pc, #28]	; 8f632d04 <hexdump+0x114>
8f632ce4:	e5932000 	ldr	r2, [r3]
8f632ce8:	e59d3014 	ldr	r3, [r13, #20]
8f632cec:	e0332002 	eors	r2, r3, r2
8f632cf0:	e3a03000 	mov	r3, #0
8f632cf4:	1a000001 	bne	8f632d00 <hexdump+0x110>
8f632cf8:	e28dd01c 	add	r13, r13, #28
8f632cfc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
8f632d00:	ebffffae 	bl	8f632bc0 <__stack_chk_fail>
8f632d04:	8f74221c 	.word	0x8f74221c

8f632d08 <heap_insert_free_chunk.isra.0>:

	struct free_heap_chunk *next_chunk;
	struct free_heap_chunk *last_chunk;

	// walk through the list, finding the node to insert before
	list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
8f632d08:	e3021200 	movw	r1, #8704	; 0x2200
8f632d0c:	e3481f74 	movt	r1, #36724	; 0x8f74
8f632d10:	e2812008 	add	r2, r1, #8
static struct free_heap_chunk *heap_insert_free_chunk(struct free_heap_chunk *chunk)
8f632d14:	e59fc134 	ldr	r12, [pc, #308]	; 8f632e50 <heap_insert_free_chunk.isra.0+0x148>
	list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
8f632d18:	e591300c 	ldr	r3, [r1, #12]
static struct free_heap_chunk *heap_insert_free_chunk(struct free_heap_chunk *chunk)
8f632d1c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
8f632d20:	e1530002 	cmp	r3, r2
static struct free_heap_chunk *heap_insert_free_chunk(struct free_heap_chunk *chunk)
8f632d24:	e24dd00c 	sub	r13, r13, #12
8f632d28:	e59cc000 	ldr	r12, [r12]
8f632d2c:	e58dc004 	str	r12, [r13, #4]
8f632d30:	e3a0c000 	mov	r12, #0
	list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
8f632d34:	0a000007 	beq	8f632d58 <heap_insert_free_chunk.isra.0+0x50>
		if (chunk < next_chunk) {
8f632d38:	e1530000 	cmp	r3, r0
8f632d3c:	9a000002 	bls	8f632d4c <heap_insert_free_chunk.isra.0+0x44>
8f632d40:	ea000034 	b	8f632e18 <heap_insert_free_chunk.isra.0+0x110>
8f632d44:	e1500003 	cmp	r0, r3
8f632d48:	3a000032 	bcc	8f632e18 <heap_insert_free_chunk.isra.0+0x110>
	list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
8f632d4c:	e5933004 	ldr	r3, [r3, #4]
8f632d50:	e1530002 	cmp	r3, r2
8f632d54:	1afffffa 	bne	8f632d44 <heap_insert_free_chunk.isra.0+0x3c>
	item->prev = list->prev;
8f632d58:	e591c008 	ldr	r12, [r1, #8]
	item->next = list;
8f632d5c:	e5802004 	str	r2, [r0, #4]
	item->prev = list->prev;
8f632d60:	e580c000 	str	r12, [r0]
	list->prev->next = item;
8f632d64:	e58c0004 	str	r0, [r12, #4]
	list->prev = item;
8f632d68:	e5810008 	str	r0, [r1, #8]
	if(item->prev != list)
8f632d6c:	e5901000 	ldr	r1, [r0]
	// walked off the end of the list, add it at the tail
	list_add_tail(&theheap.free_list, &chunk->node);

	// try to merge with the previous chunk
try_merge:
	last_chunk = list_prev_type(&theheap.free_list, &chunk->node, struct free_heap_chunk, node);
8f632d70:	e3510000 	cmp	r1, #0
8f632d74:	11510002 	cmpne	r1, r2
8f632d78:	0a000003 	beq	8f632d8c <heap_insert_free_chunk.isra.0+0x84>
	if (last_chunk) {
		if ((vaddr_t)last_chunk + last_chunk->len == (vaddr_t)chunk) {
8f632d7c:	e5912008 	ldr	r2, [r1, #8]
8f632d80:	e081c002 	add	r12, r1, r2
8f632d84:	e150000c 	cmp	r0, r12
8f632d88:	0a000017 	beq	8f632dec <heap_insert_free_chunk.isra.0+0xe4>
			chunk = last_chunk;
		}
	}

	// try to merge with the next chunk
	if (next_chunk) {
8f632d8c:	e3530000 	cmp	r3, #0
8f632d90:	0a000003 	beq	8f632da4 <heap_insert_free_chunk.isra.0+0x9c>
		if ((vaddr_t)chunk + chunk->len == (vaddr_t)next_chunk) {
8f632d94:	e5902008 	ldr	r2, [r0, #8]
8f632d98:	e0801002 	add	r1, r0, r2
8f632d9c:	e1530001 	cmp	r3, r1
8f632da0:	0a000007 	beq	8f632dc4 <heap_insert_free_chunk.isra.0+0xbc>
			list_delete(&next_chunk->node);
		}
	}

	return chunk;
}
8f632da4:	e59f30a4 	ldr	r3, [pc, #164]	; 8f632e50 <heap_insert_free_chunk.isra.0+0x148>
8f632da8:	e5932000 	ldr	r2, [r3]
8f632dac:	e59d3004 	ldr	r3, [r13, #4]
8f632db0:	e0332002 	eors	r2, r3, r2
8f632db4:	e3a03000 	mov	r3, #0
8f632db8:	1a000023 	bne	8f632e4c <heap_insert_free_chunk.isra.0+0x144>
8f632dbc:	e28dd00c 	add	r13, r13, #12
8f632dc0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	item->next->prev = item->prev;
8f632dc4:	e8935000 	ldm	r3, {r12, r14}
			chunk->len += next_chunk->len;
8f632dc8:	e5931008 	ldr	r1, [r3, #8]
8f632dcc:	e0812002 	add	r2, r1, r2
8f632dd0:	e5802008 	str	r2, [r0, #8]
8f632dd4:	e58ec000 	str	r12, [r14]
	item->prev = item->next = 0;
8f632dd8:	e3a02000 	mov	r2, #0
	item->prev->next = item->next;
8f632ddc:	e58ce004 	str	r14, [r12, #4]
	item->prev = item->next = 0;
8f632de0:	e5832004 	str	r2, [r3, #4]
8f632de4:	e5832000 	str	r2, [r3]
	return chunk;
8f632de8:	eaffffed 	b	8f632da4 <heap_insert_free_chunk.isra.0+0x9c>
			last_chunk->len += chunk->len;
8f632dec:	e590c008 	ldr	r12, [r0, #8]
8f632df0:	e08c2002 	add	r2, r12, r2
	item->next->prev = item->prev;
8f632df4:	e590c004 	ldr	r12, [r0, #4]
8f632df8:	e5812008 	str	r2, [r1, #8]
	item->prev = item->next = 0;
8f632dfc:	e3a02000 	mov	r2, #0
	item->next->prev = item->prev;
8f632e00:	e58c1000 	str	r1, [r12]
	item->prev->next = item->next;
8f632e04:	e581c004 	str	r12, [r1, #4]
	item->prev = item->next = 0;
8f632e08:	e5802004 	str	r2, [r0, #4]
8f632e0c:	e5802000 	str	r2, [r0]
8f632e10:	e1a00001 	mov	r0, r1
8f632e14:	eaffffdc 	b	8f632d8c <heap_insert_free_chunk.isra.0+0x84>
	item->prev = list->prev;
8f632e18:	e5931000 	ldr	r1, [r3]
8f632e1c:	e880000a 	stm	r0, {r1, r3}
	list->prev->next = item;
8f632e20:	e5810004 	str	r0, [r1, #4]
	list->prev = item;
8f632e24:	e5830000 	str	r0, [r3]
	if(item->prev != list)
8f632e28:	e5901000 	ldr	r1, [r0]
	last_chunk = list_prev_type(&theheap.free_list, &chunk->node, struct free_heap_chunk, node);
8f632e2c:	e1510002 	cmp	r1, r2
8f632e30:	13510000 	cmpne	r1, #0
8f632e34:	0affffd6 	beq	8f632d94 <heap_insert_free_chunk.isra.0+0x8c>
		if ((vaddr_t)last_chunk + last_chunk->len == (vaddr_t)chunk) {
8f632e38:	e5912008 	ldr	r2, [r1, #8]
8f632e3c:	e081c002 	add	r12, r1, r2
8f632e40:	e150000c 	cmp	r0, r12
8f632e44:	1affffd0 	bne	8f632d8c <heap_insert_free_chunk.isra.0+0x84>
8f632e48:	eaffffe7 	b	8f632dec <heap_insert_free_chunk.isra.0+0xe4>
}
8f632e4c:	ebffff5b 	bl	8f632bc0 <__stack_chk_fail>
8f632e50:	8f74221c 	.word	0x8f74221c

8f632e54 <heap_alloc>:
#endif
	
	LTRACEF("size %zd, align %d\n", size, alignment);

	// alignment must be power of 2
	if (alignment & (alignment - 1))
8f632e54:	e2413001 	sub	r3, r1, #1
{
8f632e58:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	if (alignment & (alignment - 1))
8f632e5c:	e0135001 	ands	r5, r3, r1
{
8f632e60:	e59f31fc 	ldr	r3, [pc, #508]	; 8f633064 <heap_alloc+0x210>
8f632e64:	e24dd00c 	sub	r13, r13, #12
		return NULL;
8f632e68:	13a04000 	movne	r4, #0
{
8f632e6c:	e5933000 	ldr	r3, [r3]
8f632e70:	e58d3004 	str	r3, [r13, #4]
8f632e74:	e3a03000 	mov	r3, #0
	if (alignment & (alignment - 1))
8f632e78:	1a000015 	bne	8f632ed4 <heap_alloc+0x80>

	if(size > (size + sizeof(struct alloc_struct_begin)))
8f632e7c:	e3700011 	cmn	r0, #17
8f632e80:	8a00005d 	bhi	8f632ffc <heap_alloc+0x1a8>
		return NULL;
	}
	size = ROUNDUP(size, sizeof(void *));

	// deal with nonzero alignments
	if (alignment > 0) {
8f632e84:	e3510000 	cmp	r1, #0
	size = ROUNDUP(size, sizeof(void *));
8f632e88:	e280000f 	add	r0, r0, #15
8f632e8c:	e3c04003 	bic	r4, r0, #3
8f632e90:	e1a06001 	mov	r6, r1
	if (alignment > 0) {
8f632e94:	1a000039 	bne	8f632f80 <heap_alloc+0x12c>
	critical_section_count++;
8f632e98:	e3015acc 	movw	r5, #6860	; 0x1acc
8f632e9c:	e3485f71 	movt	r5, #36721	; 0x8f71
8f632ea0:	e595c000 	ldr	r12, [r5]
8f632ea4:	e28c3001 	add	r3, r12, #1
8f632ea8:	e5853000 	str	r3, [r5]
	if (critical_section_count == 1)
8f632eac:	e3530001 	cmp	r3, #1
8f632eb0:	0a00003b 	beq	8f632fa4 <heap_alloc+0x150>
	enter_critical_section();

	// walk through the list
	ptr = NULL;
	struct free_heap_chunk *chunk;
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
8f632eb4:	e3021200 	movw	r1, #8704	; 0x2200
8f632eb8:	e3481f74 	movt	r1, #36724	; 0x8f74
8f632ebc:	e2810008 	add	r0, r1, #8
8f632ec0:	e591300c 	ldr	r3, [r1, #12]
8f632ec4:	e1530000 	cmp	r3, r0
8f632ec8:	1a00000d 	bne	8f632f04 <heap_alloc+0xb0>
	ptr = NULL;
8f632ecc:	e3a04000 	mov	r4, #0
	critical_section_count--;
8f632ed0:	e585c000 	str	r12, [r5]
//	heap_dump();

	exit_critical_section();

	return ptr;
}
8f632ed4:	e59f3188 	ldr	r3, [pc, #392]	; 8f633064 <heap_alloc+0x210>
8f632ed8:	e5932000 	ldr	r2, [r3]
8f632edc:	e59d3004 	ldr	r3, [r13, #4]
8f632ee0:	e0332002 	eors	r2, r3, r2
8f632ee4:	e3a03000 	mov	r3, #0
8f632ee8:	1a00005c 	bne	8f633060 <heap_alloc+0x20c>
8f632eec:	e1a00004 	mov	r0, r4
8f632ef0:	e28dd00c 	add	r13, r13, #12
8f632ef4:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
8f632ef8:	e5933004 	ldr	r3, [r3, #4]
8f632efc:	e1530000 	cmp	r3, r0
8f632f00:	0a000030 	beq	8f632fc8 <heap_alloc+0x174>
		if (chunk->len >= size) {
8f632f04:	e5932008 	ldr	r2, [r3, #8]
8f632f08:	e1520004 	cmp	r2, r4
8f632f0c:	3afffff9 	bcc	8f632ef8 <heap_alloc+0xa4>
	if(item->next != list)
8f632f10:	e593e004 	ldr	r14, [r3, #4]
8f632f14:	e15e0000 	cmp	r14, r0
8f632f18:	0a00003c 	beq	8f633010 <heap_alloc+0x1bc>
	item->next->prev = item->prev;
8f632f1c:	e5931000 	ldr	r1, [r3]
8f632f20:	e58e1000 	str	r1, [r14]
	item->prev->next = item->next;
8f632f24:	e581e004 	str	r14, [r1, #4]
			if (chunk->len > size + sizeof(struct free_heap_chunk)) {
8f632f28:	e284100c 	add	r1, r4, #12
8f632f2c:	e1520001 	cmp	r2, r1
	item->prev = item->next = 0;
8f632f30:	e3a01000 	mov	r1, #0
8f632f34:	e5831004 	str	r1, [r3, #4]
8f632f38:	e5831000 	str	r1, [r3]
8f632f3c:	8a000023 	bhi	8f632fd0 <heap_alloc+0x17c>
			if (alignment > 0) {
8f632f40:	e3560000 	cmp	r6, #0
			ptr = (void *)((addr_t)ptr + sizeof(struct alloc_struct_begin));
8f632f44:	e283400c 	add	r4, r3, #12
				ptr = (void *)ROUNDUP((addr_t)ptr, alignment);
8f632f48:	12461001 	subne	r1, r6, #1
8f632f4c:	12666000 	rsbne	r6, r6, #0
8f632f50:	10814004 	addne	r4, r1, r4
8f632f54:	10044006 	andne	r4, r4, r6
			as->ptr = (void *)chunk;
8f632f58:	e5043008 	str	r3, [r4, #-8]
			as->magic = HEAP_MAGIC;
8f632f5c:	e3043150 	movw	r3, #16720	; 0x4150
			as->size = size;
8f632f60:	e5042004 	str	r2, [r4, #-4]
			as->magic = HEAP_MAGIC;
8f632f64:	e3443845 	movt	r3, #18501	; 0x4845
8f632f68:	e504300c 	str	r3, [r4, #-12]
	if (critical_section_count == 0)
8f632f6c:	e35c0000 	cmp	r12, #0
	critical_section_count--;
8f632f70:	e585c000 	str	r12, [r5]
	if (critical_section_count == 0)
8f632f74:	1affffd6 	bne	8f632ed4 <heap_alloc+0x80>
		arch_enable_ints();
8f632f78:	ebffb822 	bl	8f621008 <arch_enable_ints>
8f632f7c:	eaffffd4 	b	8f632ed4 <heap_alloc+0x80>
		if (alignment < 16)
8f632f80:	e3510010 	cmp	r1, #16
8f632f84:	33a06010 	movcc	r6, #16
		if(size > (size + alignment))
8f632f88:	e0944006 	adds	r4, r4, r6
8f632f8c:	3affffc1 	bcc	8f632e98 <heap_alloc+0x44>
			dprintf(CRITICAL, "invalid input alignment\n");
8f632f90:	e30b01f8 	movw	r0, #45560	; 0xb1f8
8f632f94:	e3480f70 	movt	r0, #36720	; 0x8f70
8f632f98:	ebfffe75 	bl	8f632974 <_dprintf>
			return NULL;
8f632f9c:	e1a04005 	mov	r4, r5
8f632fa0:	eaffffcb 	b	8f632ed4 <heap_alloc+0x80>
		arch_disable_ints();
8f632fa4:	ebffb81b 	bl	8f621018 <arch_disable_ints>
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
8f632fa8:	e3021200 	movw	r1, #8704	; 0x2200
8f632fac:	e3481f74 	movt	r1, #36724	; 0x8f74
	critical_section_count--;
8f632fb0:	e595c000 	ldr	r12, [r5]
8f632fb4:	e2810008 	add	r0, r1, #8
8f632fb8:	e591300c 	ldr	r3, [r1, #12]
8f632fbc:	e24cc001 	sub	r12, r12, #1
8f632fc0:	e1530000 	cmp	r3, r0
8f632fc4:	1affffce 	bne	8f632f04 <heap_alloc+0xb0>
	ptr = NULL;
8f632fc8:	e3a04000 	mov	r4, #0
8f632fcc:	eaffffe6 	b	8f632f6c <heap_alloc+0x118>
	item->prev = list->prev;
8f632fd0:	e59e0000 	ldr	r0, [r14]
				struct free_heap_chunk *newchunk = heap_create_free_chunk((uint8_t *)ptr + size, chunk->len - size);
8f632fd4:	e0831004 	add	r1, r3, r4
8f632fd8:	e0422004 	sub	r2, r2, r4
	chunk->len = len;
8f632fdc:	e5812008 	str	r2, [r1, #8]
}
8f632fe0:	e1a02004 	mov	r2, r4
				chunk->len -= chunk->len - size;
8f632fe4:	e5834008 	str	r4, [r3, #8]
	item->prev = list->prev;
8f632fe8:	e7830004 	str	r0, [r3, r4]
	item->next = list;
8f632fec:	e581e004 	str	r14, [r1, #4]
	list->prev->next = item;
8f632ff0:	e5801004 	str	r1, [r0, #4]
	list->prev = item;
8f632ff4:	e58e1000 	str	r1, [r14]
}
8f632ff8:	eaffffd0 	b	8f632f40 <heap_alloc+0xec>
		dprintf(CRITICAL, "invalid input size\n");
8f632ffc:	e30b01e4 	movw	r0, #45540	; 0xb1e4
8f633000:	e3480f70 	movt	r0, #36720	; 0x8f70
8f633004:	ebfffe5a 	bl	8f632974 <_dprintf>
		return NULL;
8f633008:	e1a04005 	mov	r4, r5
8f63300c:	eaffffb0 	b	8f632ed4 <heap_alloc+0x80>
	item->next->prev = item->prev;
8f633010:	e593e000 	ldr	r14, [r3]
8f633014:	e581e008 	str	r14, [r1, #8]
	item->prev->next = item->next;
8f633018:	e58e0004 	str	r0, [r14, #4]
			if (chunk->len > size + sizeof(struct free_heap_chunk)) {
8f63301c:	e284e00c 	add	r14, r4, #12
8f633020:	e152000e 	cmp	r2, r14
	item->prev = item->next = 0;
8f633024:	e3a0e000 	mov	r14, #0
8f633028:	e583e004 	str	r14, [r3, #4]
8f63302c:	e583e000 	str	r14, [r3]
8f633030:	9affffc2 	bls	8f632f40 <heap_alloc+0xec>
				struct free_heap_chunk *newchunk = heap_create_free_chunk((uint8_t *)ptr + size, chunk->len - size);
8f633034:	e0427004 	sub	r7, r2, r4
	item->prev = list->prev;
8f633038:	e5912008 	ldr	r2, [r1, #8]
8f63303c:	e083e004 	add	r14, r3, r4
	chunk->len = len;
8f633040:	e58e7008 	str	r7, [r14, #8]
				chunk->len -= chunk->len - size;
8f633044:	e5834008 	str	r4, [r3, #8]
8f633048:	e7832004 	str	r2, [r3, r4]
	item->next = list;
8f63304c:	e58e0004 	str	r0, [r14, #4]
	list->prev->next = item;
8f633050:	e582e004 	str	r14, [r2, #4]
}
8f633054:	e1a02004 	mov	r2, r4
	list->prev = item;
8f633058:	e581e008 	str	r14, [r1, #8]
}
8f63305c:	eaffffb7 	b	8f632f40 <heap_alloc+0xec>
}
8f633060:	ebfffed6 	bl	8f632bc0 <__stack_chk_fail>
8f633064:	8f74221c 	.word	0x8f74221c

8f633068 <heap_free>:
	return(tmp_ptr);
}


void heap_free(void *ptr)
{
8f633068:	e92d4030 	push	{r4, r5, r14}
	if (ptr == 0)
8f63306c:	e2505000 	subs	r5, r0, #0
{
8f633070:	e59f309c 	ldr	r3, [pc, #156]	; 8f633114 <heap_free+0xac>
8f633074:	e24dd00c 	sub	r13, r13, #12
8f633078:	e5933000 	ldr	r3, [r3]
8f63307c:	e58d3004 	str	r3, [r13, #4]
8f633080:	e3a03000 	mov	r3, #0
	if (ptr == 0)
8f633084:	0a00000e 	beq	8f6330c4 <heap_free+0x5c>
	critical_section_count++;
8f633088:	e3014acc 	movw	r4, #6860	; 0x1acc
8f63308c:	e3484f71 	movt	r4, #36721	; 0x8f71
8f633090:	e5943000 	ldr	r3, [r4]
8f633094:	e2833001 	add	r3, r3, #1
8f633098:	e5843000 	str	r3, [r4]
	if (critical_section_count == 1)
8f63309c:	e3530001 	cmp	r3, #1
8f6330a0:	0a000018 	beq	8f633108 <heap_free+0xa0>
	chunk->len = len;
8f6330a4:	e9150009 	ldmdb	r5, {r0, r3}
8f6330a8:	e5803008 	str	r3, [r0, #8]

	LTRACEF("allocation was %zd bytes long at ptr %p\n", as->size, as->ptr);

	// looks good, create a free chunk and add it to the pool
	enter_critical_section();
	heap_insert_free_chunk(heap_create_free_chunk(as->ptr, as->size));
8f6330ac:	ebffff15 	bl	8f632d08 <heap_insert_free_chunk.isra.0>
	critical_section_count--;
8f6330b0:	e5943000 	ldr	r3, [r4]
8f6330b4:	e2433001 	sub	r3, r3, #1
8f6330b8:	e5843000 	str	r3, [r4]
	if (critical_section_count == 0)
8f6330bc:	e3530000 	cmp	r3, #0
8f6330c0:	0a000007 	beq	8f6330e4 <heap_free+0x7c>
	exit_critical_section();

//	heap_dump();
}
8f6330c4:	e59f3048 	ldr	r3, [pc, #72]	; 8f633114 <heap_free+0xac>
8f6330c8:	e5932000 	ldr	r2, [r3]
8f6330cc:	e59d3004 	ldr	r3, [r13, #4]
8f6330d0:	e0332002 	eors	r2, r3, r2
8f6330d4:	e3a03000 	mov	r3, #0
8f6330d8:	1a00000c 	bne	8f633110 <heap_free+0xa8>
8f6330dc:	e28dd00c 	add	r13, r13, #12
8f6330e0:	e8bd8030 	pop	{r4, r5, r15}
		arch_enable_ints();
8f6330e4:	e59f3028 	ldr	r3, [pc, #40]	; 8f633114 <heap_free+0xac>
8f6330e8:	e5932000 	ldr	r2, [r3]
8f6330ec:	e59d3004 	ldr	r3, [r13, #4]
8f6330f0:	e0332002 	eors	r2, r3, r2
8f6330f4:	e3a03000 	mov	r3, #0
8f6330f8:	1a000004 	bne	8f633110 <heap_free+0xa8>
8f6330fc:	e28dd00c 	add	r13, r13, #12
8f633100:	e8bd4030 	pop	{r4, r5, r14}
8f633104:	eaffb7bf 	b	8f621008 <arch_enable_ints>
		arch_disable_ints();
8f633108:	ebffb7c2 	bl	8f621018 <arch_disable_ints>
8f63310c:	eaffffe4 	b	8f6330a4 <heap_free+0x3c>
8f633110:	ebfffeaa 	bl	8f632bc0 <__stack_chk_fail>
8f633114:	8f74221c 	.word	0x8f74221c

8f633118 <heap_init>:

void heap_init(void)
{
8f633118:	e59fc068 	ldr	r12, [pc, #104]	; 8f633188 <heap_init+0x70>
	LTRACE_ENTRY;

	// set the heap range
	theheap.base = (void *)HEAP_START;
8f63311c:	e3023200 	movw	r3, #8704	; 0x2200
8f633120:	e3483f74 	movt	r3, #36724	; 0x8f74
8f633124:	e3090430 	movw	r0, #37936	; 0x9430
{
8f633128:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	theheap.base = (void *)HEAP_START;
8f63312c:	e3480f75 	movt	r0, #36725	; 0x8f75
{
8f633130:	e24dd00c 	sub	r13, r13, #12
	theheap.len = HEAP_LEN;
8f633134:	e3002000 	movw	r2, #0
8f633138:	e3492000 	movt	r2, #36864	; 0x9000
{
8f63313c:	e59cc000 	ldr	r12, [r12]
8f633140:	e58dc004 	str	r12, [r13, #4]
8f633144:	e3a0c000 	mov	r12, #0
	theheap.len = HEAP_LEN;
8f633148:	e0422000 	sub	r2, r2, r0
	list->prev = list->next = list;
8f63314c:	e2831008 	add	r1, r3, #8
8f633150:	e8830005 	stm	r3, {r0, r2}
8f633154:	e583100c 	str	r1, [r3, #12]
8f633158:	e5831008 	str	r1, [r3, #8]

	// initialize the free list
	list_initialize(&theheap.free_list);

	// create an initial free chunk
	heap_insert_free_chunk(heap_create_free_chunk(theheap.base, theheap.len));
8f63315c:	e59f3024 	ldr	r3, [pc, #36]	; 8f633188 <heap_init+0x70>
	chunk->len = len;
8f633160:	e5802008 	str	r2, [r0, #8]
	heap_insert_free_chunk(heap_create_free_chunk(theheap.base, theheap.len));
8f633164:	e5932000 	ldr	r2, [r3]
8f633168:	e59d3004 	ldr	r3, [r13, #4]
8f63316c:	e0332002 	eors	r2, r3, r2
8f633170:	e3a03000 	mov	r3, #0
8f633174:	1a000002 	bne	8f633184 <heap_init+0x6c>
	// dump heap info
//	heap_dump();

//	dprintf(INFO, "running heap tests\n");
//	heap_test();
}
8f633178:	e28dd00c 	add	r13, r13, #12
8f63317c:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	heap_insert_free_chunk(heap_create_free_chunk(theheap.base, theheap.len));
8f633180:	eafffee0 	b	8f632d08 <heap_insert_free_chunk.isra.0>
8f633184:	ebfffe8d 	bl	8f632bc0 <__stack_chk_fail>
8f633188:	8f74221c 	.word	0x8f74221c

8f63318c <atol>:
	return atoul(num);
#endif
}

long atol(const char *num)
{
8f63318c:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f633190:	e1a04000 	mov	r4, r0
	long value = 0;
	int neg = 0;

	if (num[0] == '0' && num[1] == 'x') {
8f633194:	e5d00000 	ldrb	r0, [r0]
{
8f633198:	e24dd00c 	sub	r13, r13, #12
8f63319c:	e59f3120 	ldr	r3, [pc, #288]	; 8f6332c4 <atol+0x138>
	if (num[0] == '0' && num[1] == 'x') {
8f6331a0:	e3500030 	cmp	r0, #48	; 0x30
{
8f6331a4:	e5933000 	ldr	r3, [r3]
8f6331a8:	e58d3004 	str	r3, [r13, #4]
8f6331ac:	e3a03000 	mov	r3, #0
	if (num[0] == '0' && num[1] == 'x') {
8f6331b0:	0a000022 	beq	8f633240 <atol+0xb4>
		num += 2;
		while (*num && isxdigit(*num))
			value = value * 16 + hexval(*num++);
	} else {
		// decimal
		if (num[0] == '-') {
8f6331b4:	e350002d 	cmp	r0, #45	; 0x2d
8f6331b8:	0a000019 	beq	8f633224 <atol+0x98>
			neg = 1;
			num++;
		}
		while (*num && isdigit(*num))
8f6331bc:	e3500000 	cmp	r0, #0
8f6331c0:	0a00001c 	beq	8f633238 <atol+0xac>
	int neg = 0;
8f6331c4:	e3a07000 	mov	r7, #0
8f6331c8:	e3a05000 	mov	r5, #0
			value = value * 10 + *num++  - '0';
8f6331cc:	e3a0600a 	mov	r6, #10
8f6331d0:	ea000005 	b	8f6331ec <atol+0x60>
8f6331d4:	e4d43001 	ldrb	r3, [r4], #1
8f6331d8:	e2433030 	sub	r3, r3, #48	; 0x30
		while (*num && isdigit(*num))
8f6331dc:	e5d40000 	ldrb	r0, [r4]
			value = value * 10 + *num++  - '0';
8f6331e0:	e0253596 	mla	r5, r6, r5, r3
		while (*num && isdigit(*num))
8f6331e4:	e3500000 	cmp	r0, #0
8f6331e8:	0a000002 	beq	8f6331f8 <atol+0x6c>
8f6331ec:	eb00009c 	bl	8f633464 <isdigit>
8f6331f0:	e3500000 	cmp	r0, #0
8f6331f4:	1afffff6 	bne	8f6331d4 <atol+0x48>
	}

	if (neg)
8f6331f8:	e3570000 	cmp	r7, #0
		value = -value;
8f6331fc:	12655000 	rsbne	r5, r5, #0

	return value;
}
8f633200:	e59f30bc 	ldr	r3, [pc, #188]	; 8f6332c4 <atol+0x138>
8f633204:	e5932000 	ldr	r2, [r3]
8f633208:	e59d3004 	ldr	r3, [r13, #4]
8f63320c:	e0332002 	eors	r2, r3, r2
8f633210:	e3a03000 	mov	r3, #0
8f633214:	1a000029 	bne	8f6332c0 <atol+0x134>
8f633218:	e1a00005 	mov	r0, r5
8f63321c:	e28dd00c 	add	r13, r13, #12
8f633220:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		while (*num && isdigit(*num))
8f633224:	e5d40001 	ldrb	r0, [r4, #1]
			num++;
8f633228:	e2844001 	add	r4, r4, #1
		while (*num && isdigit(*num))
8f63322c:	e3500000 	cmp	r0, #0
			neg = 1;
8f633230:	13a07001 	movne	r7, #1
		while (*num && isdigit(*num))
8f633234:	1affffe3 	bne	8f6331c8 <atol+0x3c>
	long value = 0;
8f633238:	e1a05000 	mov	r5, r0
	return value;
8f63323c:	eaffffef 	b	8f633200 <atol+0x74>
	if (num[0] == '0' && num[1] == 'x') {
8f633240:	e5d43001 	ldrb	r3, [r4, #1]
8f633244:	e3530078 	cmp	r3, #120	; 0x78
8f633248:	1affffdd 	bne	8f6331c4 <atol+0x38>
		while (*num && isxdigit(*num))
8f63324c:	e5d40002 	ldrb	r0, [r4, #2]
		num += 2;
8f633250:	e2844002 	add	r4, r4, #2
		while (*num && isxdigit(*num))
8f633254:	e3500000 	cmp	r0, #0
	long value = 0;
8f633258:	13a05000 	movne	r5, #0
		while (*num && isxdigit(*num))
8f63325c:	1a000013 	bne	8f6332b0 <atol+0x124>
8f633260:	eafffff4 	b	8f633238 <atol+0xac>
			value = value * 16 + hexval(*num++);
8f633264:	e4d43001 	ldrb	r3, [r4], #1
8f633268:	e1a05205 	lsl	r5, r5, #4
	if (c >= '0' && c <= '9')
8f63326c:	e2432030 	sub	r2, r3, #48	; 0x30
8f633270:	e6ef1072 	uxtb	r1, r2
8f633274:	e3510009 	cmp	r1, #9
			value = value * 16 + hexval(*num++);
8f633278:	90855002 	addls	r5, r5, r2
	if (c >= '0' && c <= '9')
8f63327c:	9a000008 	bls	8f6332a4 <atol+0x118>
	else if (c >= 'a' && c <= 'f')
8f633280:	e2432061 	sub	r2, r3, #97	; 0x61
8f633284:	e3520005 	cmp	r2, #5
		return c - 'a' + 10;
8f633288:	92433057 	subls	r3, r3, #87	; 0x57
			value = value * 16 + hexval(*num++);
8f63328c:	90855003 	addls	r5, r5, r3
	else if (c >= 'a' && c <= 'f')
8f633290:	9a000003 	bls	8f6332a4 <atol+0x118>
	else if (c >= 'A' && c <= 'F')
8f633294:	e2432041 	sub	r2, r3, #65	; 0x41
8f633298:	e3520005 	cmp	r2, #5
		return c - 'A' + 10;
8f63329c:	92433037 	subls	r3, r3, #55	; 0x37
			value = value * 16 + hexval(*num++);
8f6332a0:	90855003 	addls	r5, r5, r3
		while (*num && isxdigit(*num))
8f6332a4:	e5d40000 	ldrb	r0, [r4]
8f6332a8:	e3500000 	cmp	r0, #0
8f6332ac:	0affffd3 	beq	8f633200 <atol+0x74>
8f6332b0:	eb000094 	bl	8f633508 <isxdigit>
8f6332b4:	e3500000 	cmp	r0, #0
8f6332b8:	1affffe9 	bne	8f633264 <atol+0xd8>
8f6332bc:	eaffffcf 	b	8f633200 <atol+0x74>
}
8f6332c0:	ebfffe3e 	bl	8f632bc0 <__stack_chk_fail>
8f6332c4:	8f74221c 	.word	0x8f74221c

8f6332c8 <atoi>:
{
8f6332c8:	e59f3038 	ldr	r3, [pc, #56]	; 8f633308 <atoi+0x40>
8f6332cc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6332d0:	e24dd00c 	sub	r13, r13, #12
8f6332d4:	e5933000 	ldr	r3, [r3]
8f6332d8:	e58d3004 	str	r3, [r13, #4]
8f6332dc:	e3a03000 	mov	r3, #0
	return atol(num);
8f6332e0:	e59f3020 	ldr	r3, [pc, #32]	; 8f633308 <atoi+0x40>
8f6332e4:	e5932000 	ldr	r2, [r3]
8f6332e8:	e59d3004 	ldr	r3, [r13, #4]
8f6332ec:	e0332002 	eors	r2, r3, r2
8f6332f0:	e3a03000 	mov	r3, #0
8f6332f4:	1a000002 	bne	8f633304 <atoi+0x3c>
}
8f6332f8:	e28dd00c 	add	r13, r13, #12
8f6332fc:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return atol(num);
8f633300:	eaffffa1 	b	8f63318c <atol>
8f633304:	ebfffe2d 	bl	8f632bc0 <__stack_chk_fail>
8f633308:	8f74221c 	.word	0x8f74221c

8f63330c <atoul>:

unsigned long atoul(const char *num)
{
8f63330c:	e92d4070 	push	{r4, r5, r6, r14}
8f633310:	e1a04000 	mov	r4, r0
	unsigned long value = 0;
	if (num[0] == '0' && num[1] == 'x') {
8f633314:	e5d00000 	ldrb	r0, [r0]
{
8f633318:	e24dd008 	sub	r13, r13, #8
8f63331c:	e59f30f8 	ldr	r3, [pc, #248]	; 8f63341c <atoul+0x110>
	if (num[0] == '0' && num[1] == 'x') {
8f633320:	e3500030 	cmp	r0, #48	; 0x30
{
8f633324:	e5933000 	ldr	r3, [r3]
8f633328:	e58d3004 	str	r3, [r13, #4]
8f63332c:	e3a03000 	mov	r3, #0
	if (num[0] == '0' && num[1] == 'x') {
8f633330:	0a000016 	beq	8f633390 <atoul+0x84>
		num += 2;
		while (*num && isxdigit(*num))
			value = value * 16 + hexval(*num++);
	} else {
		// decimal
		while (*num && isdigit(*num))
8f633334:	e3500000 	cmp	r0, #0
8f633338:	0a000034 	beq	8f633410 <atoul+0x104>
	unsigned long value = 0;
8f63333c:	e3a05000 	mov	r5, #0
			value = value * 10 + *num++  - '0';
8f633340:	e3a0600a 	mov	r6, #10
8f633344:	ea000005 	b	8f633360 <atoul+0x54>
8f633348:	e4d43001 	ldrb	r3, [r4], #1
8f63334c:	e2433030 	sub	r3, r3, #48	; 0x30
		while (*num && isdigit(*num))
8f633350:	e5d40000 	ldrb	r0, [r4]
			value = value * 10 + *num++  - '0';
8f633354:	e0253596 	mla	r5, r6, r5, r3
		while (*num && isdigit(*num))
8f633358:	e3500000 	cmp	r0, #0
8f63335c:	0a000002 	beq	8f63336c <atoul+0x60>
8f633360:	eb00003f 	bl	8f633464 <isdigit>
8f633364:	e3500000 	cmp	r0, #0
8f633368:	1afffff6 	bne	8f633348 <atoul+0x3c>
	}

	return value;
}
8f63336c:	e59f30a8 	ldr	r3, [pc, #168]	; 8f63341c <atoul+0x110>
8f633370:	e5932000 	ldr	r2, [r3]
8f633374:	e59d3004 	ldr	r3, [r13, #4]
8f633378:	e0332002 	eors	r2, r3, r2
8f63337c:	e3a03000 	mov	r3, #0
8f633380:	1a000024 	bne	8f633418 <atoul+0x10c>
8f633384:	e1a00005 	mov	r0, r5
8f633388:	e28dd008 	add	r13, r13, #8
8f63338c:	e8bd8070 	pop	{r4, r5, r6, r15}
	if (num[0] == '0' && num[1] == 'x') {
8f633390:	e5d43001 	ldrb	r3, [r4, #1]
8f633394:	e3530078 	cmp	r3, #120	; 0x78
8f633398:	1affffe7 	bne	8f63333c <atoul+0x30>
		while (*num && isxdigit(*num))
8f63339c:	e5d40002 	ldrb	r0, [r4, #2]
		num += 2;
8f6333a0:	e2844002 	add	r4, r4, #2
		while (*num && isxdigit(*num))
8f6333a4:	e3500000 	cmp	r0, #0
	unsigned long value = 0;
8f6333a8:	13a05000 	movne	r5, #0
		while (*num && isxdigit(*num))
8f6333ac:	1a000013 	bne	8f633400 <atoul+0xf4>
8f6333b0:	ea000016 	b	8f633410 <atoul+0x104>
			value = value * 16 + hexval(*num++);
8f6333b4:	e4d43001 	ldrb	r3, [r4], #1
8f6333b8:	e1a05205 	lsl	r5, r5, #4
	if (c >= '0' && c <= '9')
8f6333bc:	e2432030 	sub	r2, r3, #48	; 0x30
8f6333c0:	e6ef1072 	uxtb	r1, r2
8f6333c4:	e3510009 	cmp	r1, #9
			value = value * 16 + hexval(*num++);
8f6333c8:	90855002 	addls	r5, r5, r2
	if (c >= '0' && c <= '9')
8f6333cc:	9a000008 	bls	8f6333f4 <atoul+0xe8>
	else if (c >= 'a' && c <= 'f')
8f6333d0:	e2432061 	sub	r2, r3, #97	; 0x61
8f6333d4:	e3520005 	cmp	r2, #5
		return c - 'a' + 10;
8f6333d8:	92433057 	subls	r3, r3, #87	; 0x57
			value = value * 16 + hexval(*num++);
8f6333dc:	90855003 	addls	r5, r5, r3
	else if (c >= 'a' && c <= 'f')
8f6333e0:	9a000003 	bls	8f6333f4 <atoul+0xe8>
	else if (c >= 'A' && c <= 'F')
8f6333e4:	e2432041 	sub	r2, r3, #65	; 0x41
8f6333e8:	e3520005 	cmp	r2, #5
		return c - 'A' + 10;
8f6333ec:	92433037 	subls	r3, r3, #55	; 0x37
			value = value * 16 + hexval(*num++);
8f6333f0:	90855003 	addls	r5, r5, r3
		while (*num && isxdigit(*num))
8f6333f4:	e5d40000 	ldrb	r0, [r4]
8f6333f8:	e3500000 	cmp	r0, #0
8f6333fc:	0affffda 	beq	8f63336c <atoul+0x60>
8f633400:	eb000040 	bl	8f633508 <isxdigit>
8f633404:	e3500000 	cmp	r0, #0
8f633408:	1affffe9 	bne	8f6333b4 <atoul+0xa8>
8f63340c:	eaffffd6 	b	8f63336c <atoul+0x60>
8f633410:	e1a05000 	mov	r5, r0
8f633414:	eaffffd4 	b	8f63336c <atoul+0x60>
}
8f633418:	ebfffde8 	bl	8f632bc0 <__stack_chk_fail>
8f63341c:	8f74221c 	.word	0x8f74221c

8f633420 <atoui>:
{
8f633420:	e59f3038 	ldr	r3, [pc, #56]	; 8f633460 <atoui+0x40>
8f633424:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f633428:	e24dd00c 	sub	r13, r13, #12
8f63342c:	e5933000 	ldr	r3, [r3]
8f633430:	e58d3004 	str	r3, [r13, #4]
8f633434:	e3a03000 	mov	r3, #0
	return atoul(num);
8f633438:	e59f3020 	ldr	r3, [pc, #32]	; 8f633460 <atoui+0x40>
8f63343c:	e5932000 	ldr	r2, [r3]
8f633440:	e59d3004 	ldr	r3, [r13, #4]
8f633444:	e0332002 	eors	r2, r3, r2
8f633448:	e3a03000 	mov	r3, #0
8f63344c:	1a000002 	bne	8f63345c <atoui+0x3c>
}
8f633450:	e28dd00c 	add	r13, r13, #12
8f633454:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return atoul(num);
8f633458:	eaffffab 	b	8f63330c <atoul>
8f63345c:	ebfffdd7 	bl	8f632bc0 <__stack_chk_fail>
8f633460:	8f74221c 	.word	0x8f74221c

8f633464 <isdigit>:
{
	return ((c >= 'A') && (c <= 'Z'));
}

int isdigit(int c)
{
8f633464:	e59f3044 	ldr	r3, [pc, #68]	; 8f6334b0 <isdigit+0x4c>
	return ((c >= '0') && (c <= '9'));
8f633468:	e2400030 	sub	r0, r0, #48	; 0x30
{
8f63346c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f633470:	e24dd00c 	sub	r13, r13, #12
	return ((c >= '0') && (c <= '9'));
8f633474:	e3500009 	cmp	r0, #9
{
8f633478:	e5933000 	ldr	r3, [r3]
8f63347c:	e58d3004 	str	r3, [r13, #4]
8f633480:	e3a03000 	mov	r3, #0
}
8f633484:	e59f3024 	ldr	r3, [pc, #36]	; 8f6334b0 <isdigit+0x4c>
	return ((c >= '0') && (c <= '9'));
8f633488:	83a00000 	movhi	r0, #0
8f63348c:	93a00001 	movls	r0, #1
}
8f633490:	e5932000 	ldr	r2, [r3]
8f633494:	e59d3004 	ldr	r3, [r13, #4]
8f633498:	e0332002 	eors	r2, r3, r2
8f63349c:	e3a03000 	mov	r3, #0
8f6334a0:	1a000001 	bne	8f6334ac <isdigit+0x48>
8f6334a4:	e28dd00c 	add	r13, r13, #12
8f6334a8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6334ac:	ebfffdc3 	bl	8f632bc0 <__stack_chk_fail>
8f6334b0:	8f74221c 	.word	0x8f74221c

8f6334b4 <isalpha>:

int isalpha(int c)
{
8f6334b4:	e59f3048 	ldr	r3, [pc, #72]	; 8f633504 <isalpha+0x50>
	return isupper(c) || islower(c);
8f6334b8:	e3c00020 	bic	r0, r0, #32
8f6334bc:	e2400041 	sub	r0, r0, #65	; 0x41
{
8f6334c0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6334c4:	e24dd00c 	sub	r13, r13, #12
	return isupper(c) || islower(c);
8f6334c8:	e3500019 	cmp	r0, #25
{
8f6334cc:	e5933000 	ldr	r3, [r3]
8f6334d0:	e58d3004 	str	r3, [r13, #4]
8f6334d4:	e3a03000 	mov	r3, #0
}
8f6334d8:	e59f3024 	ldr	r3, [pc, #36]	; 8f633504 <isalpha+0x50>
	return isupper(c) || islower(c);
8f6334dc:	83a00000 	movhi	r0, #0
8f6334e0:	93a00001 	movls	r0, #1
}
8f6334e4:	e5932000 	ldr	r2, [r3]
8f6334e8:	e59d3004 	ldr	r3, [r13, #4]
8f6334ec:	e0332002 	eors	r2, r3, r2
8f6334f0:	e3a03000 	mov	r3, #0
8f6334f4:	1a000001 	bne	8f633500 <isalpha+0x4c>
8f6334f8:	e28dd00c 	add	r13, r13, #12
8f6334fc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f633500:	ebfffdae 	bl	8f632bc0 <__stack_chk_fail>
8f633504:	8f74221c 	.word	0x8f74221c

8f633508 <isxdigit>:
{
	return isalpha(c) || isdigit(c);
}

int isxdigit(int c)
{
8f633508:	e59f3058 	ldr	r3, [pc, #88]	; 8f633568 <isxdigit+0x60>
8f63350c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f633510:	e24dd00c 	sub	r13, r13, #12
8f633514:	e5933000 	ldr	r3, [r3]
8f633518:	e58d3004 	str	r3, [r13, #4]
8f63351c:	e3a03000 	mov	r3, #0
	return ((c >= '0') && (c <= '9'));
8f633520:	e2403030 	sub	r3, r0, #48	; 0x30
	return isdigit(c) || ((c >= 'a') && (c <= 'f')) || ((c >= 'A') && (c <= 'F'));
8f633524:	e3530009 	cmp	r3, #9
8f633528:	93a00001 	movls	r0, #1
8f63352c:	9a000004 	bls	8f633544 <isxdigit+0x3c>
8f633530:	e3c00020 	bic	r0, r0, #32
8f633534:	e2400041 	sub	r0, r0, #65	; 0x41
8f633538:	e3500005 	cmp	r0, #5
8f63353c:	83a00000 	movhi	r0, #0
8f633540:	93a00001 	movls	r0, #1
}
8f633544:	e59f301c 	ldr	r3, [pc, #28]	; 8f633568 <isxdigit+0x60>
8f633548:	e5932000 	ldr	r2, [r3]
8f63354c:	e59d3004 	ldr	r3, [r13, #4]
8f633550:	e0332002 	eors	r2, r3, r2
8f633554:	e3a03000 	mov	r3, #0
8f633558:	1a000001 	bne	8f633564 <isxdigit+0x5c>
8f63355c:	e28dd00c 	add	r13, r13, #12
8f633560:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f633564:	ebfffd95 	bl	8f632bc0 <__stack_chk_fail>
8f633568:	8f74221c 	.word	0x8f74221c

8f63356c <lcm>:
/* Function to calculate gcd of two positive numbers. */
unsigned gcd(unsigned m, unsigned n)
{
	unsigned x;

	if (m < n)
8f63356c:	e1500001 	cmp	r0, r1
	return m;
}

/* Function to calculate lcm of two positive numbers. */
unsigned lcm(unsigned m, unsigned n)
{
8f633570:	e59f2078 	ldr	r2, [pc, #120]	; 8f6335f0 <lcm+0x84>
8f633574:	e92d4030 	push	{r4, r5, r14}
	if (m < n)
8f633578:	21a03001 	movcs	r3, r1
8f63357c:	31a03000 	movcc	r3, r0
8f633580:	21a04000 	movcs	r4, r0
8f633584:	31a04001 	movcc	r4, r1
	while (n != 0)
8f633588:	e3530000 	cmp	r3, #0
{
8f63358c:	e24dd00c 	sub	r13, r13, #12
	unsigned lcm;

	lcm = (m * n) / gcd(m, n);
8f633590:	e0050091 	mul	r5, r1, r0
{
8f633594:	e5922000 	ldr	r2, [r2]
8f633598:	e58d2004 	str	r2, [r13, #4]
8f63359c:	e3a02000 	mov	r2, #0
	while (n != 0)
8f6335a0:	0a000006 	beq	8f6335c0 <lcm+0x54>
8f6335a4:	e1a00004 	mov	r0, r4
8f6335a8:	e1a01003 	mov	r1, r3
		x = m % n;
8f6335ac:	e1a04001 	mov	r4, r1
8f6335b0:	fa00261f 	blx	8f63ce34 <__aeabi_uidivmod>
	while (n != 0)
8f6335b4:	e1a00004 	mov	r0, r4
8f6335b8:	e3510000 	cmp	r1, #0
8f6335bc:	1afffffa 	bne	8f6335ac <lcm+0x40>
	lcm = (m * n) / gcd(m, n);
8f6335c0:	e1a01004 	mov	r1, r4
8f6335c4:	e1a00005 	mov	r0, r5
8f6335c8:	fa002582 	blx	8f63cbd8 <__udivsi3>

	return lcm;
}
8f6335cc:	e59f301c 	ldr	r3, [pc, #28]	; 8f6335f0 <lcm+0x84>
8f6335d0:	e5932000 	ldr	r2, [r3]
8f6335d4:	e59d3004 	ldr	r3, [r13, #4]
8f6335d8:	e0332002 	eors	r2, r3, r2
8f6335dc:	e3a03000 	mov	r3, #0
8f6335e0:	1a000001 	bne	8f6335ec <lcm+0x80>
8f6335e4:	e28dd00c 	add	r13, r13, #12
8f6335e8:	e8bd8030 	pop	{r4, r5, r15}
8f6335ec:	ebfffd73 	bl	8f632bc0 <__stack_chk_fail>
8f6335f0:	8f74221c 	.word	0x8f74221c

8f6335f4 <itoa>:
{
	int sum = num;
	int i = 0;
	int digit;

	if (len == 0)
8f6335f4:	e3520000 	cmp	r2, #0
{
8f6335f8:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f6335fc:	e1a05003 	mov	r5, r3
8f633600:	e59f30a0 	ldr	r3, [pc, #160]	; 8f6336a8 <itoa+0xb4>
8f633604:	e24dd008 	sub	r13, r13, #8
8f633608:	11a06001 	movne	r6, r1
		else
			str[i++] = 'A' + digit - 0xA;

		sum /= base;

	}while (sum && (i < (len - 1)));
8f63360c:	12424001 	subne	r4, r2, #1
{
8f633610:	e5933000 	ldr	r3, [r3]
8f633614:	e58d3004 	str	r3, [r13, #4]
8f633618:	e3a03000 	mov	r3, #0
	if (len == 0)
8f63361c:	11a08006 	movne	r8, r6
8f633620:	13a07001 	movne	r7, #1
8f633624:	1a000004 	bne	8f63363c <itoa+0x48>
8f633628:	ea00001b 	b	8f63369c <itoa+0xa8>
	}while (sum && (i < (len - 1)));
8f63362c:	e1540003 	cmp	r4, r3
8f633630:	e2877001 	add	r7, r7, #1
8f633634:	e2888001 	add	r8, r8, #1
8f633638:	da000016 	ble	8f633698 <itoa+0xa4>
		digit = sum % base;
8f63363c:	e1a01005 	mov	r1, r5
8f633640:	fa0026a7 	blx	8f63d0e4 <__aeabi_idivmod>
		if (digit < 0xA)
8f633644:	e3510009 	cmp	r1, #9
			str[i++] = '0' + digit;
8f633648:	d2811030 	addle	r1, r1, #48	; 0x30
			str[i++] = 'A' + digit - 0xA;
8f63364c:	c2811037 	addgt	r1, r1, #55	; 0x37
			str[i++] = '0' + digit;
8f633650:	d1a03007 	movle	r3, r7
			str[i++] = 'A' + digit - 0xA;
8f633654:	c1a03007 	movgt	r3, r7
	}while (sum && (i < (len - 1)));
8f633658:	e3500000 	cmp	r0, #0
			str[i++] = 'A' + digit - 0xA;
8f63365c:	e5c81000 	strb	r1, [r8]
	}while (sum && (i < (len - 1)));
8f633660:	1afffff1 	bne	8f63362c <itoa+0x38>

	if (i == (len - 1) && sum)
		return -1;

	str[i] = '\0';
8f633664:	e3a04000 	mov	r4, #0
	strrev(str);
8f633668:	e1a00006 	mov	r0, r6
	str[i] = '\0';
8f63366c:	e7c64003 	strb	r4, [r6, r3]
	strrev(str);
8f633670:	eb0004c0 	bl	8f634978 <strrev>

	return 0;
8f633674:	e1a00004 	mov	r0, r4
}
8f633678:	e59f3028 	ldr	r3, [pc, #40]	; 8f6336a8 <itoa+0xb4>
8f63367c:	e5932000 	ldr	r2, [r3]
8f633680:	e59d3004 	ldr	r3, [r13, #4]
8f633684:	e0332002 	eors	r2, r3, r2
8f633688:	e3a03000 	mov	r3, #0
8f63368c:	1a000004 	bne	8f6336a4 <itoa+0xb0>
8f633690:	e28dd008 	add	r13, r13, #8
8f633694:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
	if (i == (len - 1) && sum)
8f633698:	1afffff1 	bne	8f633664 <itoa+0x70>
		return -1;
8f63369c:	e3e00000 	mvn	r0, #0
8f6336a0:	eafffff4 	b	8f633678 <itoa+0x84>
}
8f6336a4:	ebfffd45 	bl	8f632bc0 <__stack_chk_fail>
8f6336a8:	8f74221c 	.word	0x8f74221c

8f6336ac <longlong_to_string.constprop.0>:
#define SHOWSIGNFLAG 0x00000080
#define SIGNEDFLAG   0x00000100
#define LEFTFORMATFLAG 0x00000200
#define LEADZEROFLAG 0x00000400

static char *longlong_to_string(char *buf, unsigned long long n, int len, uint flag)
8f6336ac:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f6336b0:	e24dd00c 	sub	r13, r13, #12
8f6336b4:	e1a04003 	mov	r4, r3
8f6336b8:	e59f3130 	ldr	r3, [pc, #304]	; 8f6337f0 <longlong_to_string.constprop.0+0x144>
8f6336bc:	e59da030 	ldr	r10, [r13, #48]	; 0x30
8f6336c0:	e1a07000 	mov	r7, r0
8f6336c4:	e5933000 	ldr	r3, [r3]
8f6336c8:	e58d3004 	str	r3, [r13, #4]
8f6336cc:	e3a03000 	mov	r3, #0
8f6336d0:	e1a00002 	mov	r0, r2
{
	int pos = len;
	int negative = 0;

	if((flag & SIGNEDFLAG) && (long long)n < 0) {
8f6336d4:	e31a0c01 	tst	r10, #256	; 0x100
8f6336d8:	0a000001 	beq	8f6336e4 <longlong_to_string.constprop.0+0x38>
8f6336dc:	e3540000 	cmp	r4, #0
8f6336e0:	ba000034 	blt	8f6337b8 <longlong_to_string.constprop.0+0x10c>
	}

	buf[--pos] = 0;
	
	/* only do the math if the number is >= 10 */
	while(n >= 10) {
8f6336e4:	e350000a 	cmp	r0, #10
	buf[--pos] = 0;
8f6336e8:	e3a09000 	mov	r9, #0
	while(n >= 10) {
8f6336ec:	e2d43000 	sbcs	r3, r4, #0
	buf[--pos] = 0;
8f6336f0:	e5c7901f 	strb	r9, [r7, #31]
	while(n >= 10) {
8f6336f4:	3a000025 	bcc	8f633790 <longlong_to_string.constprop.0+0xe4>
8f6336f8:	e287601f 	add	r6, r7, #31
8f6336fc:	e1e08007 	mvn	r8, r7
		int digit = n % 10;
8f633700:	e1a01004 	mov	r1, r4
8f633704:	e3a0200a 	mov	r2, #10
8f633708:	e3a03000 	mov	r3, #0
8f63370c:	e1a0b000 	mov	r11, r0
8f633710:	fa0026a3 	blx	8f63d1a4 <__aeabi_uldivmod>

		n /= 10;
8f633714:	e3a03000 	mov	r3, #0
8f633718:	e1a01004 	mov	r1, r4
8f63371c:	e1a0000b 	mov	r0, r11
		int digit = n % 10;
8f633720:	e1a05002 	mov	r5, r2
		n /= 10;
8f633724:	e3a0200a 	mov	r2, #10
8f633728:	fa00269d 	blx	8f63d1a4 <__aeabi_uldivmod>
	while(n >= 10) {
8f63372c:	e35b0064 	cmp	r11, #100	; 0x64
8f633730:	e2d43000 	sbcs	r3, r4, #0

		buf[--pos] = digit + '0';
8f633734:	e2855030 	add	r5, r5, #48	; 0x30
8f633738:	e0883006 	add	r3, r8, r6
8f63373c:	e5665001 	strb	r5, [r6, #-1]!
		n /= 10;
8f633740:	e1a04001 	mov	r4, r1
	while(n >= 10) {
8f633744:	2affffed 	bcs	8f633700 <longlong_to_string.constprop.0+0x54>
	}
	buf[--pos] = n + '0';
8f633748:	e2802030 	add	r2, r0, #48	; 0x30
	
	if(negative)
8f63374c:	e3590000 	cmp	r9, #0
	buf[--pos] = n + '0';
8f633750:	e2430001 	sub	r0, r3, #1
8f633754:	e7c72000 	strb	r2, [r7, r0]
8f633758:	e0870000 	add	r0, r7, r0
	if(negative)
8f63375c:	0a00000f 	beq	8f6337a0 <longlong_to_string.constprop.0+0xf4>
		buf[--pos] = '-';
8f633760:	e2433002 	sub	r3, r3, #2
8f633764:	e3a0202d 	mov	r2, #45	; 0x2d
8f633768:	e0870003 	add	r0, r7, r3
8f63376c:	e7c72003 	strb	r2, [r7, r3]
	else if((flag & SHOWSIGNFLAG))
		buf[--pos] = '+';

	return &buf[pos];
}
8f633770:	e59f3078 	ldr	r3, [pc, #120]	; 8f6337f0 <longlong_to_string.constprop.0+0x144>
8f633774:	e5932000 	ldr	r2, [r3]
8f633778:	e59d3004 	ldr	r3, [r13, #4]
8f63377c:	e0332002 	eors	r2, r3, r2
8f633780:	e3a03000 	mov	r3, #0
8f633784:	1a000018 	bne	8f6337ec <longlong_to_string.constprop.0+0x140>
8f633788:	e28dd00c 	add	r13, r13, #12
8f63378c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	buf[--pos] = n + '0';
8f633790:	e2802030 	add	r2, r0, #48	; 0x30
8f633794:	e287001e 	add	r0, r7, #30
	buf[--pos] = 0;
8f633798:	e3a0301f 	mov	r3, #31
	buf[--pos] = n + '0';
8f63379c:	e5c7201e 	strb	r2, [r7, #30]
	else if((flag & SHOWSIGNFLAG))
8f6337a0:	e31a0080 	tst	r10, #128	; 0x80
		buf[--pos] = '+';
8f6337a4:	12433002 	subne	r3, r3, #2
8f6337a8:	13a0202b 	movne	r2, #43	; 0x2b
8f6337ac:	10870003 	addne	r0, r7, r3
8f6337b0:	17c72003 	strbne	r2, [r7, r3]
	return &buf[pos];
8f6337b4:	eaffffed 	b	8f633770 <longlong_to_string.constprop.0+0xc4>
		n = -n;
8f6337b8:	e2723000 	rsbs	r3, r2, #0
8f6337bc:	e2e44000 	rsc	r4, r4, #0
	while(n >= 10) {
8f6337c0:	e353000a 	cmp	r3, #10
8f6337c4:	e2d42000 	sbcs	r2, r4, #0
		n = -n;
8f6337c8:	e1a00003 	mov	r0, r3
	buf[--pos] = 0;
8f6337cc:	e3a02000 	mov	r2, #0
8f6337d0:	e5c7201f 	strb	r2, [r7, #31]
		negative = 1;
8f6337d4:	23a09001 	movcs	r9, #1
8f6337d8:	2affffc6 	bcs	8f6336f8 <longlong_to_string.constprop.0+0x4c>
	buf[--pos] = n + '0';
8f6337dc:	e2832030 	add	r2, r3, #48	; 0x30
	buf[--pos] = 0;
8f6337e0:	e3a0301f 	mov	r3, #31
	buf[--pos] = n + '0';
8f6337e4:	e5c7201e 	strb	r2, [r7, #30]
	if(negative)
8f6337e8:	eaffffdc 	b	8f633760 <longlong_to_string.constprop.0+0xb4>
}
8f6337ec:	ebfffcf3 	bl	8f632bc0 <__stack_chk_fail>
8f6337f0:	8f74221c 	.word	0x8f74221c

8f6337f4 <printf>:
{
8f6337f4:	e92d000f 	push	{r0, r1, r2, r3}
8f6337f8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6337fc:	e24dd00c 	sub	r13, r13, #12
8f633800:	e59f3044 	ldr	r3, [pc, #68]	; 8f63384c <printf+0x58>
	va_start(ap, fmt);
8f633804:	e28d1014 	add	r1, r13, #20
	err = _dvprintf(fmt, ap);
8f633808:	e59d0010 	ldr	r0, [r13, #16]
{
8f63380c:	e5933000 	ldr	r3, [r3]
8f633810:	e58d3004 	str	r3, [r13, #4]
8f633814:	e3a03000 	mov	r3, #0
	va_start(ap, fmt);
8f633818:	e58d1000 	str	r1, [r13]
	err = _dvprintf(fmt, ap);
8f63381c:	ebfffc87 	bl	8f632a40 <_dvprintf>
}
8f633820:	e59f3024 	ldr	r3, [pc, #36]	; 8f63384c <printf+0x58>
8f633824:	e5932000 	ldr	r2, [r3]
8f633828:	e59d3004 	ldr	r3, [r13, #4]
8f63382c:	e0332002 	eors	r2, r3, r2
8f633830:	e3a03000 	mov	r3, #0
8f633834:	1a000003 	bne	8f633848 <printf+0x54>
8f633838:	e28dd00c 	add	r13, r13, #12
8f63383c:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
8f633840:	e28dd010 	add	r13, r13, #16
8f633844:	e12fff1e 	bx	r14
8f633848:	ebfffcdc 	bl	8f632bc0 <__stack_chk_fail>
8f63384c:	8f74221c 	.word	0x8f74221c

8f633850 <vsnprintf>:
{
	return vsnprintf(str, INT_MAX, fmt, ap);
}

int vsnprintf(char *str, size_t len, const char *fmt, va_list ap)
{
8f633850:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f633854:	e1a08001 	mov	r8, r1
#define OUTPUT_CHAR(c) do { (*str++ = c); chars_written++; if (chars_written + 1 == len) goto done; } while(0)
#define OUTPUT_CHAR_NOLENCHECK(c) do { (*str++ = c); chars_written++; } while(0)

	for(;;) {	
		/* handle regular chars that aren't format related */
		while((c = *fmt++) != 0) {
8f633858:	e5d2c000 	ldrb	r12, [r2]
{
8f63385c:	e24dd03c 	sub	r13, r13, #60	; 0x3c
8f633860:	e59f16d4 	ldr	r1, [pc, #1748]	; 8f633f3c <vsnprintf+0x6ec>
8f633864:	e1a05000 	mov	r5, r0
		while((c = *fmt++) != 0) {
8f633868:	e35c0000 	cmp	r12, #0
{
8f63386c:	e5911000 	ldr	r1, [r1]
8f633870:	e58d1034 	str	r1, [r13, #52]	; 0x34
8f633874:	e3a01000 	mov	r1, #0
		while((c = *fmt++) != 0) {
8f633878:	01a0000c 	moveq	r0, r12
8f63387c:	0a000010 	beq	8f6338c4 <vsnprintf+0x74>
8f633880:	e2826001 	add	r6, r2, #1
	size_t chars_written = 0;
8f633884:	e3a04000 	mov	r4, #0
8f633888:	e1a09003 	mov	r9, r3
		table = hextable;
8f63388c:	e30b322c 	movw	r3, #45612	; 0xb22c
8f633890:	e3483f70 	movt	r3, #36720	; 0x8f70
8f633894:	e58d300c 	str	r3, [r13, #12]
			if(c == '%')
8f633898:	e35c0025 	cmp	r12, #37	; 0x25
8f63389c:	0a000012 	beq	8f6338ec <vsnprintf+0x9c>
				break; /* we saw a '%', break and start parsing format */
			OUTPUT_CHAR(c);
8f6338a0:	e2843002 	add	r3, r4, #2
8f6338a4:	e4c5c001 	strb	r12, [r5], #1
8f6338a8:	e1530008 	cmp	r3, r8
8f6338ac:	e2844001 	add	r4, r4, #1
8f6338b0:	0a000002 	beq	8f6338c0 <vsnprintf+0x70>
		while((c = *fmt++) != 0) {
8f6338b4:	e4d6c001 	ldrb	r12, [r6], #1
8f6338b8:	e35c0000 	cmp	r12, #0
8f6338bc:	1afffff5 	bne	8f633898 <vsnprintf+0x48>
	chars_written--; /* don't count the null */

#undef OUTPUT_CHAR
#undef OUTPUT_CHAR_NOLENCHECK

	return chars_written;
8f6338c0:	e1a00004 	mov	r0, r4
	OUTPUT_CHAR_NOLENCHECK('\0');
8f6338c4:	e3a03000 	mov	r3, #0
8f6338c8:	e5c53000 	strb	r3, [r5]
}
8f6338cc:	e59f3668 	ldr	r3, [pc, #1640]	; 8f633f3c <vsnprintf+0x6ec>
8f6338d0:	e5932000 	ldr	r2, [r3]
8f6338d4:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f6338d8:	e0332002 	eors	r2, r3, r2
8f6338dc:	e3a03000 	mov	r3, #0
8f6338e0:	1a000194 	bne	8f633f38 <vsnprintf+0x6e8>
8f6338e4:	e28dd03c 	add	r13, r13, #60	; 0x3c
8f6338e8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		c = *fmt++;
8f6338ec:	e4d63001 	ldrb	r3, [r6], #1
		if(c == 0)
8f6338f0:	e3530000 	cmp	r3, #0
8f6338f4:	0afffff1 	beq	8f6338c0 <vsnprintf+0x70>
8f6338f8:	e3a07000 	mov	r7, #0
				format_num *= 10;
8f6338fc:	e3a0100a 	mov	r1, #10
		if(c == 0)
8f633900:	e1a0b007 	mov	r11, r7
		switch(c) {
8f633904:	e2432023 	sub	r2, r3, #35	; 0x23
8f633908:	e3520057 	cmp	r2, #87	; 0x57
8f63390c:	979ff102 	ldrls	r15, [r15, r2, lsl #2]
8f633910:	ea0000f6 	b	8f633cf0 <vsnprintf+0x4a0>
8f633914:	8f633de4 	.word	0x8f633de4
8f633918:	8f633cf0 	.word	0x8f633cf0
8f63391c:	8f633df8 	.word	0x8f633df8
8f633920:	8f633cf0 	.word	0x8f633cf0
8f633924:	8f633cf0 	.word	0x8f633cf0
8f633928:	8f633cf0 	.word	0x8f633cf0
8f63392c:	8f633cf0 	.word	0x8f633cf0
8f633930:	8f633cf0 	.word	0x8f633cf0
8f633934:	8f633e14 	.word	0x8f633e14
8f633938:	8f633cf0 	.word	0x8f633cf0
8f63393c:	8f633e28 	.word	0x8f633e28
8f633940:	8f633a80 	.word	0x8f633a80
8f633944:	8f633cf0 	.word	0x8f633cf0
8f633948:	8f633d20 	.word	0x8f633d20
8f63394c:	8f633d20 	.word	0x8f633d20
8f633950:	8f633d20 	.word	0x8f633d20
8f633954:	8f633d20 	.word	0x8f633d20
8f633958:	8f633d20 	.word	0x8f633d20
8f63395c:	8f633d20 	.word	0x8f633d20
8f633960:	8f633d20 	.word	0x8f633d20
8f633964:	8f633d20 	.word	0x8f633d20
8f633968:	8f633d20 	.word	0x8f633d20
8f63396c:	8f633d20 	.word	0x8f633d20
8f633970:	8f633cf0 	.word	0x8f633cf0
8f633974:	8f633cf0 	.word	0x8f633cf0
8f633978:	8f633cf0 	.word	0x8f633cf0
8f63397c:	8f633cf0 	.word	0x8f633cf0
8f633980:	8f633cf0 	.word	0x8f633cf0
8f633984:	8f633cf0 	.word	0x8f633cf0
8f633988:	8f633cf0 	.word	0x8f633cf0
8f63398c:	8f633cf0 	.word	0x8f633cf0
8f633990:	8f633cf0 	.word	0x8f633cf0
8f633994:	8f633cf0 	.word	0x8f633cf0
8f633998:	8f633a90 	.word	0x8f633a90
8f63399c:	8f633cf0 	.word	0x8f633cf0
8f6339a0:	8f633cf0 	.word	0x8f633cf0
8f6339a4:	8f633cf0 	.word	0x8f633cf0
8f6339a8:	8f633cf0 	.word	0x8f633cf0
8f6339ac:	8f633cf0 	.word	0x8f633cf0
8f6339b0:	8f633cf0 	.word	0x8f633cf0
8f6339b4:	8f633cf0 	.word	0x8f633cf0
8f6339b8:	8f633cf0 	.word	0x8f633cf0
8f6339bc:	8f633cf0 	.word	0x8f633cf0
8f6339c0:	8f633cf0 	.word	0x8f633cf0
8f6339c4:	8f633cf0 	.word	0x8f633cf0
8f6339c8:	8f633cf0 	.word	0x8f633cf0
8f6339cc:	8f633cf0 	.word	0x8f633cf0
8f6339d0:	8f633cf0 	.word	0x8f633cf0
8f6339d4:	8f633cf0 	.word	0x8f633cf0
8f6339d8:	8f633cf0 	.word	0x8f633cf0
8f6339dc:	8f633ca0 	.word	0x8f633ca0
8f6339e0:	8f633cf0 	.word	0x8f633cf0
8f6339e4:	8f633cf0 	.word	0x8f633cf0
8f6339e8:	8f633e3c 	.word	0x8f633e3c
8f6339ec:	8f633cf0 	.word	0x8f633cf0
8f6339f0:	8f633cf0 	.word	0x8f633cf0
8f6339f4:	8f633cf0 	.word	0x8f633cf0
8f6339f8:	8f633cf0 	.word	0x8f633cf0
8f6339fc:	8f633cf0 	.word	0x8f633cf0
8f633a00:	8f633cf0 	.word	0x8f633cf0
8f633a04:	8f633cf0 	.word	0x8f633cf0
8f633a08:	8f633cf0 	.word	0x8f633cf0
8f633a0c:	8f633cf0 	.word	0x8f633cf0
8f633a10:	8f633cf0 	.word	0x8f633cf0
8f633a14:	8f633dc4 	.word	0x8f633dc4
8f633a18:	8f633a94 	.word	0x8f633a94
8f633a1c:	8f633cf0 	.word	0x8f633cf0
8f633a20:	8f633cf0 	.word	0x8f633cf0
8f633a24:	8f633cf0 	.word	0x8f633cf0
8f633a28:	8f633a74 	.word	0x8f633a74
8f633a2c:	8f633a94 	.word	0x8f633a94
8f633a30:	8f633cf0 	.word	0x8f633cf0
8f633a34:	8f633cf0 	.word	0x8f633cf0
8f633a38:	8f633e44 	.word	0x8f633e44
8f633a3c:	8f633cf0 	.word	0x8f633cf0
8f633a40:	8f633da8 	.word	0x8f633da8
8f633a44:	8f633cf0 	.word	0x8f633cf0
8f633a48:	8f633b4c 	.word	0x8f633b4c
8f633a4c:	8f633cf0 	.word	0x8f633cf0
8f633a50:	8f633cf0 	.word	0x8f633cf0
8f633a54:	8f633d84 	.word	0x8f633d84
8f633a58:	8f633cf0 	.word	0x8f633cf0
8f633a5c:	8f633ca4 	.word	0x8f633ca4
8f633a60:	8f633cf0 	.word	0x8f633cf0
8f633a64:	8f633cf0 	.word	0x8f633cf0
8f633a68:	8f633b50 	.word	0x8f633b50
8f633a6c:	8f633cf0 	.word	0x8f633cf0
8f633a70:	8f633e60 	.word	0x8f633e60
				if(flags & HALFFLAG)
8f633a74:	e31b0004 	tst	r11, #4
					flags |= HALFHALFFLAG;
8f633a78:	138bb008 	orrne	r11, r11, #8
				flags |= HALFFLAG;
8f633a7c:	e38bb004 	orr	r11, r11, #4
		c = *fmt++;
8f633a80:	e4d63001 	ldrb	r3, [r6], #1
		if(c == 0)
8f633a84:	e3530000 	cmp	r3, #0
8f633a88:	1affff9d 	bne	8f633904 <vsnprintf+0xb4>
done:
8f633a8c:	eaffff8b 	b	8f6338c0 <vsnprintf+0x70>
				flags |= LONGFLAG;
8f633a90:	e38bb001 	orr	r11, r11, #1
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
8f633a94:	e31b0002 	tst	r11, #2
8f633a98:	0a0000b2 	beq	8f633d68 <vsnprintf+0x518>
8f633a9c:	e2899007 	add	r9, r9, #7
8f633aa0:	e3c99007 	bic	r9, r9, #7
8f633aa4:	e5993004 	ldr	r3, [r9, #4]
8f633aa8:	e4992008 	ldr	r2, [r9], #8
				flags |= SIGNEDFLAG;
8f633aac:	e38bbc01 	orr	r11, r11, #256	; 0x100
				s = longlong_to_string(num_buffer, n, sizeof(num_buffer), flags);
8f633ab0:	e28d0014 	add	r0, r13, #20
8f633ab4:	e58db000 	str	r11, [r13]
8f633ab8:	ebfffefb 	bl	8f6336ac <longlong_to_string.constprop.0>
		if (flags & LEFTFORMATFLAG) {
8f633abc:	e31b0c02 	tst	r11, #512	; 0x200
				s = longlong_to_string(num_buffer, n, sizeof(num_buffer), flags);
8f633ac0:	e1a0a000 	mov	r10, r0
		if (flags & LEFTFORMATFLAG) {
8f633ac4:	1a00004c 	bne	8f633bfc <vsnprintf+0x3ac>
			size_t string_len = strlen(s);
8f633ac8:	e1a0000a 	mov	r0, r10
8f633acc:	eb00034d 	bl	8f634808 <strlen>
			char outchar = (flags & LEADZEROFLAG) ? '0' : ' ';
8f633ad0:	e31b0b01 	tst	r11, #1024	; 0x400
8f633ad4:	13a01030 	movne	r1, #48	; 0x30
8f633ad8:	03a01020 	moveq	r1, #32
			for (; format_num > string_len; format_num--)
8f633adc:	e1570000 	cmp	r7, r0
8f633ae0:	9a00000f 	bls	8f633b24 <vsnprintf+0x2d4>
				OUTPUT_CHAR(outchar);
8f633ae4:	e2843002 	add	r3, r4, #2
8f633ae8:	e2844001 	add	r4, r4, #1
8f633aec:	e1580003 	cmp	r8, r3
8f633af0:	e1a03005 	mov	r3, r5
8f633af4:	e4c31001 	strb	r1, [r3], #1
8f633af8:	0a000065 	beq	8f633c94 <vsnprintf+0x444>
8f633afc:	e0470000 	sub	r0, r7, r0
8f633b00:	e0855000 	add	r5, r5, r0
8f633b04:	ea000004 	b	8f633b1c <vsnprintf+0x2cc>
8f633b08:	e2842002 	add	r2, r4, #2
8f633b0c:	e4c31001 	strb	r1, [r3], #1
8f633b10:	e1580002 	cmp	r8, r2
8f633b14:	e2844001 	add	r4, r4, #1
8f633b18:	0a00005d 	beq	8f633c94 <vsnprintf+0x444>
			for (; format_num > string_len; format_num--)
8f633b1c:	e1530005 	cmp	r3, r5
8f633b20:	1afffff8 	bne	8f633b08 <vsnprintf+0x2b8>
8f633b24:	e24aa001 	sub	r10, r10, #1
			while(*s != 0)
8f633b28:	e5fa3001 	ldrb	r3, [r10, #1]!
8f633b2c:	e3530000 	cmp	r3, #0
8f633b30:	0affff5f 	beq	8f6338b4 <vsnprintf+0x64>
				OUTPUT_CHAR(*s++);
8f633b34:	e4c53001 	strb	r3, [r5], #1
8f633b38:	e2843002 	add	r3, r4, #2
8f633b3c:	e1580003 	cmp	r8, r3
8f633b40:	e2844001 	add	r4, r4, #1
8f633b44:	1afffff7 	bne	8f633b28 <vsnprintf+0x2d8>
8f633b48:	eaffff5c 	b	8f6338c0 <vsnprintf+0x70>
				flags |= LONGFLAG | ALTFLAG;
8f633b4c:	e38bb021 	orr	r11, r11, #33	; 0x21
				n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
8f633b50:	e21b2002 	ands	r2, r11, #2
8f633b54:	0a00005d 	beq	8f633cd0 <vsnprintf+0x480>
8f633b58:	e2899007 	add	r9, r9, #7
8f633b5c:	e3c99007 	bic	r9, r9, #7
8f633b60:	e5992004 	ldr	r2, [r9, #4]
8f633b64:	e4993008 	ldr	r3, [r9], #8
		table = hextable;
8f633b68:	e59d100c 	ldr	r1, [r13, #12]
8f633b6c:	e21be040 	ands	r14, r11, #64	; 0x40
8f633b70:	e30bc21c 	movw	r12, #45596	; 0xb21c
8f633b74:	e348cf70 	movt	r12, #36720	; 0x8f70
	buf[--pos] = 0;
8f633b78:	e3a00000 	mov	r0, #0
8f633b7c:	e5cd0033 	strb	r0, [r13, #51]	; 0x33
		table = hextable;
8f633b80:	11a0c001 	movne	r12, r1
	buf[--pos] = 0;
8f633b84:	e28d1032 	add	r1, r13, #50	; 0x32
		unsigned int digit = u % 16;
8f633b88:	e203000f 	and	r0, r3, #15
	} while(u != 0);
8f633b8c:	e3530010 	cmp	r3, #16
8f633b90:	e1a0a002 	mov	r10, r2
8f633b94:	e2daa000 	sbcs	r10, r10, #0
		buf[--pos] = table[digit];
8f633b98:	e7dc0000 	ldrb	r0, [r12, r0]
		u /= 16;
8f633b9c:	e1a03223 	lsr	r3, r3, #4
8f633ba0:	e1833e02 	orr	r3, r3, r2, lsl #28
		buf[--pos] = table[digit];
8f633ba4:	e1a0a001 	mov	r10, r1
		u /= 16;
8f633ba8:	e1a02222 	lsr	r2, r2, #4
		buf[--pos] = table[digit];
8f633bac:	e4410001 	strb	r0, [r1], #-1
	} while(u != 0);
8f633bb0:	2afffff4 	bcs	8f633b88 <vsnprintf+0x338>
				if(flags & ALTFLAG) {
8f633bb4:	e31b0020 	tst	r11, #32
8f633bb8:	0a00000d 	beq	8f633bf4 <vsnprintf+0x3a4>
					OUTPUT_CHAR('0');
8f633bbc:	e2843002 	add	r3, r4, #2
8f633bc0:	e3a02030 	mov	r2, #48	; 0x30
8f633bc4:	e1530008 	cmp	r3, r8
8f633bc8:	e5c52000 	strb	r2, [r5]
8f633bcc:	0a0000d4 	beq	8f633f24 <vsnprintf+0x6d4>
					OUTPUT_CHAR((flags & CAPSFLAG) ? 'X': 'x');
8f633bd0:	e35e0000 	cmp	r14, #0
8f633bd4:	e2844003 	add	r4, r4, #3
8f633bd8:	e2855002 	add	r5, r5, #2
8f633bdc:	13a02058 	movne	r2, #88	; 0x58
8f633be0:	03a02078 	moveq	r2, #120	; 0x78
8f633be4:	e1540008 	cmp	r4, r8
8f633be8:	e5452001 	strb	r2, [r5, #-1]
8f633bec:	0a0000cf 	beq	8f633f30 <vsnprintf+0x6e0>
8f633bf0:	e1a04003 	mov	r4, r3
		if (flags & LEFTFORMATFLAG) {
8f633bf4:	e31b0c02 	tst	r11, #512	; 0x200
8f633bf8:	0affffb2 	beq	8f633ac8 <vsnprintf+0x278>
			while(*s != 0) {
8f633bfc:	e5da2000 	ldrb	r2, [r10]
8f633c00:	e3520000 	cmp	r2, #0
8f633c04:	0a00000f 	beq	8f633c48 <vsnprintf+0x3f8>
				OUTPUT_CHAR(*s++);
8f633c08:	e2843002 	add	r3, r4, #2
8f633c0c:	e4c52001 	strb	r2, [r5], #1
8f633c10:	e1530008 	cmp	r3, r8
8f633c14:	e2844001 	add	r4, r4, #1
8f633c18:	0affff28 	beq	8f6338c0 <vsnprintf+0x70>
8f633c1c:	e26a1001 	rsb	r1, r10, #1
8f633c20:	ea000004 	b	8f633c38 <vsnprintf+0x3e8>
8f633c24:	e2842002 	add	r2, r4, #2
8f633c28:	e4c53001 	strb	r3, [r5], #1
8f633c2c:	e1580002 	cmp	r8, r2
8f633c30:	e2844001 	add	r4, r4, #1
8f633c34:	0affff21 	beq	8f6338c0 <vsnprintf+0x70>
				count++;
8f633c38:	e081200a 	add	r2, r1, r10
			while(*s != 0) {
8f633c3c:	e5fa3001 	ldrb	r3, [r10, #1]!
8f633c40:	e3530000 	cmp	r3, #0
8f633c44:	1afffff6 	bne	8f633c24 <vsnprintf+0x3d4>
			for (; format_num > count; format_num--)
8f633c48:	e1570002 	cmp	r7, r2
8f633c4c:	9affff18 	bls	8f6338b4 <vsnprintf+0x64>
				OUTPUT_CHAR(' ');
8f633c50:	e2843002 	add	r3, r4, #2
8f633c54:	e3a01020 	mov	r1, #32
8f633c58:	e1580003 	cmp	r8, r3
8f633c5c:	e1a03005 	mov	r3, r5
8f633c60:	e2844001 	add	r4, r4, #1
8f633c64:	e4c31001 	strb	r1, [r3], #1
8f633c68:	0a000009 	beq	8f633c94 <vsnprintf+0x444>
8f633c6c:	e0472002 	sub	r2, r7, r2
8f633c70:	e0855002 	add	r5, r5, r2
			for (; format_num > count; format_num--)
8f633c74:	e1530005 	cmp	r3, r5
8f633c78:	0affff0d 	beq	8f6338b4 <vsnprintf+0x64>
				OUTPUT_CHAR(' ');
8f633c7c:	e3a02020 	mov	r2, #32
8f633c80:	e4c32001 	strb	r2, [r3], #1
8f633c84:	e2842002 	add	r2, r4, #2
8f633c88:	e2844001 	add	r4, r4, #1
8f633c8c:	e1580002 	cmp	r8, r2
8f633c90:	1afffff7 	bne	8f633c74 <vsnprintf+0x424>
	return chars_written;
8f633c94:	e1a00004 	mov	r0, r4
				OUTPUT_CHAR(outchar);
8f633c98:	e1a05003 	mov	r5, r3
8f633c9c:	eaffff08 	b	8f6338c4 <vsnprintf+0x74>
				flags |= LONGFLAG;
8f633ca0:	e38bb001 	orr	r11, r11, #1
				n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
8f633ca4:	e21b3002 	ands	r3, r11, #2
8f633ca8:	0a000025 	beq	8f633d44 <vsnprintf+0x4f4>
8f633cac:	e2899007 	add	r9, r9, #7
8f633cb0:	e3c99007 	bic	r9, r9, #7
8f633cb4:	e5993004 	ldr	r3, [r9, #4]
8f633cb8:	e4992008 	ldr	r2, [r9], #8
				s = longlong_to_string(num_buffer, n, sizeof(num_buffer), flags);
8f633cbc:	e28d0014 	add	r0, r13, #20
8f633cc0:	e58db000 	str	r11, [r13]
8f633cc4:	ebfffe78 	bl	8f6336ac <longlong_to_string.constprop.0>
8f633cc8:	e1a0a000 	mov	r10, r0
				goto _output_string;
8f633ccc:	eaffffc8 	b	8f633bf4 <vsnprintf+0x3a4>
				    (flags & LONGFLAG) ? va_arg(ap, unsigned long) : 
8f633cd0:	e21b3001 	ands	r3, r11, #1
8f633cd4:	1a000028 	bne	8f633d7c <vsnprintf+0x52c>
8f633cd8:	e21b2008 	ands	r2, r11, #8
8f633cdc:	0a000076 	beq	8f633ebc <vsnprintf+0x66c>
8f633ce0:	e1a02003 	mov	r2, r3
					(flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
8f633ce4:	e4993004 	ldr	r3, [r9], #4
				    (flags & LONGFLAG) ? va_arg(ap, unsigned long) : 
8f633ce8:	e6ef3073 	uxtb	r3, r3
8f633cec:	eaffff9d 	b	8f633b68 <vsnprintf+0x318>
				OUTPUT_CHAR('%');
8f633cf0:	e2840002 	add	r0, r4, #2
8f633cf4:	e3a02025 	mov	r2, #37	; 0x25
8f633cf8:	e1500008 	cmp	r0, r8
8f633cfc:	e5c52000 	strb	r2, [r5]
8f633d00:	0a000087 	beq	8f633f24 <vsnprintf+0x6d4>
				OUTPUT_CHAR(c);
8f633d04:	e2844003 	add	r4, r4, #3
8f633d08:	e5c53001 	strb	r3, [r5, #1]
8f633d0c:	e1540008 	cmp	r4, r8
8f633d10:	e2855002 	add	r5, r5, #2
8f633d14:	0afffeea 	beq	8f6338c4 <vsnprintf+0x74>
8f633d18:	e1a04000 	mov	r4, r0
8f633d1c:	eafffee4 	b	8f6338b4 <vsnprintf+0x64>
				if (c == '0' && format_num == 0)
8f633d20:	e3530030 	cmp	r3, #48	; 0x30
8f633d24:	03570000 	cmpeq	r7, #0
				format_num += c - '0';
8f633d28:	e0273791 	mla	r7, r1, r7, r3
		c = *fmt++;
8f633d2c:	e4d63001 	ldrb	r3, [r6], #1
					flags |= LEADZEROFLAG;
8f633d30:	038bbb01 	orreq	r11, r11, #1024	; 0x400
		if(c == 0)
8f633d34:	e3530000 	cmp	r3, #0
				format_num += c - '0';
8f633d38:	e2477030 	sub	r7, r7, #48	; 0x30
		if(c == 0)
8f633d3c:	1afffef0 	bne	8f633904 <vsnprintf+0xb4>
8f633d40:	eafffede 	b	8f6338c0 <vsnprintf+0x70>
					(flags & LONGFLAG) ? va_arg(ap, unsigned long) : 
8f633d44:	e21b2001 	ands	r2, r11, #1
8f633d48:	1a000049 	bne	8f633e74 <vsnprintf+0x624>
8f633d4c:	e21b3008 	ands	r3, r11, #8
8f633d50:	1a000060 	bne	8f633ed8 <vsnprintf+0x688>
8f633d54:	e21b2004 	ands	r2, r11, #4
8f633d58:	0a00006c 	beq	8f633f10 <vsnprintf+0x6c0>
					(flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
8f633d5c:	e4992004 	ldr	r2, [r9], #4
					(flags & LONGFLAG) ? va_arg(ap, unsigned long) : 
8f633d60:	e6ff2072 	uxth	r2, r2
8f633d64:	eaffffd4 	b	8f633cbc <vsnprintf+0x46c>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
8f633d68:	e31b0001 	tst	r11, #1
8f633d6c:	0a000042 	beq	8f633e7c <vsnprintf+0x62c>
8f633d70:	e4992004 	ldr	r2, [r9], #4
8f633d74:	e1a03fc2 	asr	r3, r2, #31
8f633d78:	eaffff4b 	b	8f633aac <vsnprintf+0x25c>
				    (flags & LONGFLAG) ? va_arg(ap, unsigned long) : 
8f633d7c:	e4993004 	ldr	r3, [r9], #4
8f633d80:	eaffff78 	b	8f633b68 <vsnprintf+0x318>
				s = va_arg(ap, const char *);
8f633d84:	e499a004 	ldr	r10, [r9], #4
				if(s == 0)
8f633d88:	e35a0000 	cmp	r10, #0
8f633d8c:	1affff98 	bne	8f633bf4 <vsnprintf+0x3a4>
		if (flags & LEFTFORMATFLAG) {
8f633d90:	e31b0c02 	tst	r11, #512	; 0x200
					s = "<null>";
8f633d94:	e30ba214 	movw	r10, #45588	; 0xb214
8f633d98:	e348af70 	movt	r10, #36720	; 0x8f70
		if (flags & LEFTFORMATFLAG) {
8f633d9c:	0affff49 	beq	8f633ac8 <vsnprintf+0x278>
			while(*s != 0) {
8f633da0:	e3a0203c 	mov	r2, #60	; 0x3c
8f633da4:	eaffff97 	b	8f633c08 <vsnprintf+0x3b8>
				if(flags & LONGLONGFLAG)
8f633da8:	e31b0002 	tst	r11, #2
				ptr = va_arg(ap, void *);
8f633dac:	e4993004 	ldr	r3, [r9], #4
				if(flags & LONGLONGFLAG)
8f633db0:	0a000037 	beq	8f633e94 <vsnprintf+0x644>
					*(long long *)ptr = chars_written;
8f633db4:	e3a02000 	mov	r2, #0
8f633db8:	e5834000 	str	r4, [r3]
8f633dbc:	e5832004 	str	r2, [r3, #4]
8f633dc0:	eafffebb 	b	8f6338b4 <vsnprintf+0x64>
				uc = va_arg(ap, unsigned int);
8f633dc4:	e5993000 	ldr	r3, [r9]
8f633dc8:	e4c53001 	strb	r3, [r5], #1
				OUTPUT_CHAR(uc);
8f633dcc:	e2843002 	add	r3, r4, #2
8f633dd0:	e1530008 	cmp	r3, r8
8f633dd4:	e2844001 	add	r4, r4, #1
8f633dd8:	0afffeb8 	beq	8f6338c0 <vsnprintf+0x70>
				uc = va_arg(ap, unsigned int);
8f633ddc:	e2899004 	add	r9, r9, #4
8f633de0:	eafffeb3 	b	8f6338b4 <vsnprintf+0x64>
		c = *fmt++;
8f633de4:	e4d63001 	ldrb	r3, [r6], #1
				flags |= ALTFLAG;
8f633de8:	e38bb020 	orr	r11, r11, #32
		if(c == 0)
8f633dec:	e3530000 	cmp	r3, #0
8f633df0:	1afffec3 	bne	8f633904 <vsnprintf+0xb4>
8f633df4:	eafffeb1 	b	8f6338c0 <vsnprintf+0x70>
				OUTPUT_CHAR('%');
8f633df8:	e2843002 	add	r3, r4, #2
8f633dfc:	e2844001 	add	r4, r4, #1
8f633e00:	e1530008 	cmp	r3, r8
8f633e04:	e3a03025 	mov	r3, #37	; 0x25
8f633e08:	e4c53001 	strb	r3, [r5], #1
8f633e0c:	1afffea8 	bne	8f6338b4 <vsnprintf+0x64>
8f633e10:	eafffeaa 	b	8f6338c0 <vsnprintf+0x70>
		c = *fmt++;
8f633e14:	e4d63001 	ldrb	r3, [r6], #1
				flags |= SHOWSIGNFLAG;
8f633e18:	e38bb080 	orr	r11, r11, #128	; 0x80
		if(c == 0)
8f633e1c:	e3530000 	cmp	r3, #0
8f633e20:	1afffeb7 	bne	8f633904 <vsnprintf+0xb4>
8f633e24:	eafffea5 	b	8f6338c0 <vsnprintf+0x70>
		c = *fmt++;
8f633e28:	e4d63001 	ldrb	r3, [r6], #1
				flags |= LEFTFORMATFLAG;
8f633e2c:	e38bbc02 	orr	r11, r11, #512	; 0x200
		if(c == 0)
8f633e30:	e3530000 	cmp	r3, #0
8f633e34:	1afffeb2 	bne	8f633904 <vsnprintf+0xb4>
8f633e38:	eafffea0 	b	8f6338c0 <vsnprintf+0x70>
				flags |= CAPSFLAG;
8f633e3c:	e38bb040 	orr	r11, r11, #64	; 0x40
8f633e40:	eaffff42 	b	8f633b50 <vsnprintf+0x300>
		c = *fmt++;
8f633e44:	e4d63001 	ldrb	r3, [r6], #1
				if(flags & LONGFLAG)
8f633e48:	e31b0001 	tst	r11, #1
					flags |= LONGLONGFLAG;
8f633e4c:	138bb002 	orrne	r11, r11, #2
		if(c == 0)
8f633e50:	e3530000 	cmp	r3, #0
				flags |= LONGFLAG;
8f633e54:	e38bb001 	orr	r11, r11, #1
		if(c == 0)
8f633e58:	1afffea9 	bne	8f633904 <vsnprintf+0xb4>
8f633e5c:	eafffe97 	b	8f6338c0 <vsnprintf+0x70>
		c = *fmt++;
8f633e60:	e4d63001 	ldrb	r3, [r6], #1
				flags |= SIZETFLAG;
8f633e64:	e38bb010 	orr	r11, r11, #16
		if(c == 0)
8f633e68:	e3530000 	cmp	r3, #0
8f633e6c:	1afffea4 	bne	8f633904 <vsnprintf+0xb4>
8f633e70:	eafffe92 	b	8f6338c0 <vsnprintf+0x70>
					(flags & LONGFLAG) ? va_arg(ap, unsigned long) : 
8f633e74:	e4992004 	ldr	r2, [r9], #4
8f633e78:	eaffff8f 	b	8f633cbc <vsnprintf+0x46c>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
8f633e7c:	e31b0008 	tst	r11, #8
8f633e80:	0a000018 	beq	8f633ee8 <vsnprintf+0x698>
					(flags & HALFHALFFLAG) ? (signed char)va_arg(ap, int) :
8f633e84:	e4993004 	ldr	r3, [r9], #4
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
8f633e88:	e6af2073 	sxtb	r2, r3
8f633e8c:	e7a033d3 	sbfx	r3, r3, #7, #1
8f633e90:	eaffff05 	b	8f633aac <vsnprintf+0x25c>
				else if(flags & LONGFLAG)
8f633e94:	e31b0001 	tst	r11, #1
8f633e98:	1a000005 	bne	8f633eb4 <vsnprintf+0x664>
				else if(flags & HALFHALFFLAG)
8f633e9c:	e31b0008 	tst	r11, #8
					*(signed char *)ptr = chars_written;
8f633ea0:	15c34000 	strbne	r4, [r3]
				else if(flags & HALFHALFFLAG)
8f633ea4:	1afffe82 	bne	8f6338b4 <vsnprintf+0x64>
				else if(flags & HALFFLAG)
8f633ea8:	e31b0004 	tst	r11, #4
					*(short *)ptr = chars_written;
8f633eac:	11c340b0 	strhne	r4, [r3]
				else if(flags & HALFFLAG)
8f633eb0:	1afffe7f 	bne	8f6338b4 <vsnprintf+0x64>
					*(int *)ptr = chars_written;
8f633eb4:	e5834000 	str	r4, [r3]
8f633eb8:	eafffe7d 	b	8f6338b4 <vsnprintf+0x64>
				    (flags & LONGFLAG) ? va_arg(ap, unsigned long) : 
8f633ebc:	e21b3004 	ands	r3, r11, #4
8f633ec0:	1a00000f 	bne	8f633f04 <vsnprintf+0x6b4>
8f633ec4:	e21b2010 	ands	r2, r11, #16
8f633ec8:	0affffab 	beq	8f633d7c <vsnprintf+0x52c>
8f633ecc:	e1a02003 	mov	r2, r3
8f633ed0:	e4993004 	ldr	r3, [r9], #4
8f633ed4:	eaffff23 	b	8f633b68 <vsnprintf+0x318>
					(flags & LONGFLAG) ? va_arg(ap, unsigned long) : 
8f633ed8:	e1a03002 	mov	r3, r2
					(flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
8f633edc:	e4992004 	ldr	r2, [r9], #4
					(flags & LONGFLAG) ? va_arg(ap, unsigned long) : 
8f633ee0:	e6ef2072 	uxtb	r2, r2
8f633ee4:	eaffff74 	b	8f633cbc <vsnprintf+0x46c>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
8f633ee8:	e31b0004 	tst	r11, #4
					(flags & HALFFLAG) ? (short)va_arg(ap, int) :
8f633eec:	14993004 	ldrne	r3, [r9], #4
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
8f633ef0:	04992004 	ldreq	r2, [r9], #4
8f633ef4:	16bf2073 	sxthne	r2, r3
8f633ef8:	17a037d3 	sbfxne	r3, r3, #15, #1
8f633efc:	01a03fc2 	asreq	r3, r2, #31
8f633f00:	eafffee9 	b	8f633aac <vsnprintf+0x25c>
					(flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
8f633f04:	e4993004 	ldr	r3, [r9], #4
				    (flags & LONGFLAG) ? va_arg(ap, unsigned long) : 
8f633f08:	e6ff3073 	uxth	r3, r3
8f633f0c:	eaffff15 	b	8f633b68 <vsnprintf+0x318>
					(flags & LONGFLAG) ? va_arg(ap, unsigned long) : 
8f633f10:	e21b3010 	ands	r3, r11, #16
8f633f14:	0affffd6 	beq	8f633e74 <vsnprintf+0x624>
8f633f18:	e1a03002 	mov	r3, r2
8f633f1c:	e4992004 	ldr	r2, [r9], #4
8f633f20:	eaffff65 	b	8f633cbc <vsnprintf+0x46c>
				OUTPUT_CHAR('%');
8f633f24:	e2855001 	add	r5, r5, #1
8f633f28:	e2840001 	add	r0, r4, #1
8f633f2c:	eafffe64 	b	8f6338c4 <vsnprintf+0x74>
	return chars_written;
8f633f30:	e1a00003 	mov	r0, r3
8f633f34:	eafffe62 	b	8f6338c4 <vsnprintf+0x74>
}
8f633f38:	ebfffb20 	bl	8f632bc0 <__stack_chk_fail>
8f633f3c:	8f74221c 	.word	0x8f74221c

8f633f40 <snprintf>:
{
8f633f40:	e92d000c 	push	{r2, r3}
8f633f44:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f633f48:	e24dd00c 	sub	r13, r13, #12
8f633f4c:	e59fc044 	ldr	r12, [pc, #68]	; 8f633f98 <snprintf+0x58>
	va_start(ap, fmt);
8f633f50:	e28d3014 	add	r3, r13, #20
	err = vsnprintf(str, len, fmt, ap);
8f633f54:	e59d2010 	ldr	r2, [r13, #16]
{
8f633f58:	e59cc000 	ldr	r12, [r12]
8f633f5c:	e58dc004 	str	r12, [r13, #4]
8f633f60:	e3a0c000 	mov	r12, #0
	va_start(ap, fmt);
8f633f64:	e58d3000 	str	r3, [r13]
	err = vsnprintf(str, len, fmt, ap);
8f633f68:	ebfffe38 	bl	8f633850 <vsnprintf>
}
8f633f6c:	e59f3024 	ldr	r3, [pc, #36]	; 8f633f98 <snprintf+0x58>
8f633f70:	e5932000 	ldr	r2, [r3]
8f633f74:	e59d3004 	ldr	r3, [r13, #4]
8f633f78:	e0332002 	eors	r2, r3, r2
8f633f7c:	e3a03000 	mov	r3, #0
8f633f80:	1a000003 	bne	8f633f94 <snprintf+0x54>
8f633f84:	e28dd00c 	add	r13, r13, #12
8f633f88:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
8f633f8c:	e28dd008 	add	r13, r13, #8
8f633f90:	e12fff1e 	bx	r14
8f633f94:	ebfffb09 	bl	8f632bc0 <__stack_chk_fail>
8f633f98:	8f74221c 	.word	0x8f74221c

8f633f9c <sprintf>:
{
8f633f9c:	e92d000e 	push	{r1, r2, r3}
	return vsnprintf(str, INT_MAX, fmt, ap);
8f633fa0:	e3e01102 	mvn	r1, #-2147483648	; 0x80000000
{
8f633fa4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f633fa8:	e24dd008 	sub	r13, r13, #8
8f633fac:	e59fc044 	ldr	r12, [pc, #68]	; 8f633ff8 <sprintf+0x5c>
	va_start(ap, fmt);
8f633fb0:	e28d3010 	add	r3, r13, #16
	return vsnprintf(str, INT_MAX, fmt, ap);
8f633fb4:	e59d200c 	ldr	r2, [r13, #12]
{
8f633fb8:	e59cc000 	ldr	r12, [r12]
8f633fbc:	e58dc004 	str	r12, [r13, #4]
8f633fc0:	e3a0c000 	mov	r12, #0
	va_start(ap, fmt);
8f633fc4:	e58d3000 	str	r3, [r13]
	return vsnprintf(str, INT_MAX, fmt, ap);
8f633fc8:	ebfffe20 	bl	8f633850 <vsnprintf>
}
8f633fcc:	e59f3024 	ldr	r3, [pc, #36]	; 8f633ff8 <sprintf+0x5c>
8f633fd0:	e5932000 	ldr	r2, [r3]
8f633fd4:	e59d3004 	ldr	r3, [r13, #4]
8f633fd8:	e0332002 	eors	r2, r3, r2
8f633fdc:	e3a03000 	mov	r3, #0
8f633fe0:	1a000003 	bne	8f633ff4 <sprintf+0x58>
8f633fe4:	e28dd008 	add	r13, r13, #8
8f633fe8:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
8f633fec:	e28dd00c 	add	r13, r13, #12
8f633ff0:	e12fff1e 	bx	r14
8f633ff4:	ebfffaf1 	bl	8f632bc0 <__stack_chk_fail>
8f633ff8:	8f74221c 	.word	0x8f74221c

8f633ffc <malloc>:
#include <string.h>
#include <lib/heap.h>
#include <arch/ops.h>

void *malloc(size_t size)
{
8f633ffc:	e59f303c 	ldr	r3, [pc, #60]	; 8f634040 <malloc+0x44>
8f634000:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f634004:	e24dd00c 	sub	r13, r13, #12
8f634008:	e5933000 	ldr	r3, [r3]
8f63400c:	e58d3004 	str	r3, [r13, #4]
8f634010:	e3a03000 	mov	r3, #0
	return heap_alloc(size, 0);
8f634014:	e59f3024 	ldr	r3, [pc, #36]	; 8f634040 <malloc+0x44>
8f634018:	e5932000 	ldr	r2, [r3]
8f63401c:	e59d3004 	ldr	r3, [r13, #4]
8f634020:	e0332002 	eors	r2, r3, r2
8f634024:	e3a03000 	mov	r3, #0
8f634028:	1a000003 	bne	8f63403c <malloc+0x40>
8f63402c:	e3a01000 	mov	r1, #0
}
8f634030:	e28dd00c 	add	r13, r13, #12
8f634034:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return heap_alloc(size, 0);
8f634038:	eafffb85 	b	8f632e54 <heap_alloc>
8f63403c:	ebfffadf 	bl	8f632bc0 <__stack_chk_fail>
8f634040:	8f74221c 	.word	0x8f74221c

8f634044 <memalign>:

void *memalign(size_t boundary, size_t size)
{
8f634044:	e92d4010 	push	{r4, r14}
8f634048:	e1a04001 	mov	r4, r1
8f63404c:	e59f304c 	ldr	r3, [pc, #76]	; 8f6340a0 <memalign+0x5c>
8f634050:	e24dd008 	sub	r13, r13, #8
8f634054:	e1a01000 	mov	r1, r0
	void *ptr;
	ptr = heap_alloc(size, boundary);
8f634058:	e1a00004 	mov	r0, r4
{
8f63405c:	e5933000 	ldr	r3, [r3]
8f634060:	e58d3004 	str	r3, [r13, #4]
8f634064:	e3a03000 	mov	r3, #0
	ptr = heap_alloc(size, boundary);
8f634068:	ebfffb79 	bl	8f632e54 <heap_alloc>
	/* Clean the cache before giving the memory */
	arch_clean_invalidate_cache_range((addr_t) ptr, size);
8f63406c:	e1a01004 	mov	r1, r4
	ptr = heap_alloc(size, boundary);
8f634070:	e1a04000 	mov	r4, r0
	arch_clean_invalidate_cache_range((addr_t) ptr, size);
8f634074:	ebffb3c9 	bl	8f620fa0 <arch_clean_invalidate_cache_range>
	return ptr;
}
8f634078:	e59f3020 	ldr	r3, [pc, #32]	; 8f6340a0 <memalign+0x5c>
8f63407c:	e5932000 	ldr	r2, [r3]
8f634080:	e59d3004 	ldr	r3, [r13, #4]
8f634084:	e0332002 	eors	r2, r3, r2
8f634088:	e3a03000 	mov	r3, #0
8f63408c:	1a000002 	bne	8f63409c <memalign+0x58>
8f634090:	e1a00004 	mov	r0, r4
8f634094:	e28dd008 	add	r13, r13, #8
8f634098:	e8bd8010 	pop	{r4, r15}
8f63409c:	ebfffac7 	bl	8f632bc0 <__stack_chk_fail>
8f6340a0:	8f74221c 	.word	0x8f74221c

8f6340a4 <calloc>:

void *calloc(size_t count, size_t size)
{
8f6340a4:	e92d4030 	push	{r4, r5, r14}
8f6340a8:	e24dd00c 	sub	r13, r13, #12
	void *ptr;
	size_t realsize = count * size;
8f6340ac:	e0050091 	mul	r5, r1, r0
{
8f6340b0:	e59f3050 	ldr	r3, [pc, #80]	; 8f634108 <calloc+0x64>

	ptr = heap_alloc(realsize, 0);
8f6340b4:	e3a01000 	mov	r1, #0
{
8f6340b8:	e5933000 	ldr	r3, [r3]
8f6340bc:	e58d3004 	str	r3, [r13, #4]
8f6340c0:	e3a03000 	mov	r3, #0
	ptr = heap_alloc(realsize, 0);
8f6340c4:	e1a00005 	mov	r0, r5
8f6340c8:	ebfffb61 	bl	8f632e54 <heap_alloc>
	if (!ptr)
8f6340cc:	e2504000 	subs	r4, r0, #0
8f6340d0:	0a000002 	beq	8f6340e0 <calloc+0x3c>
		return NULL;

	memset(ptr, 0, realsize);
8f6340d4:	e1a02005 	mov	r2, r5
8f6340d8:	e3a01000 	mov	r1, #0
8f6340dc:	eb000078 	bl	8f6342c4 <memset>
	return ptr;
}
8f6340e0:	e59f3020 	ldr	r3, [pc, #32]	; 8f634108 <calloc+0x64>
8f6340e4:	e5932000 	ldr	r2, [r3]
8f6340e8:	e59d3004 	ldr	r3, [r13, #4]
8f6340ec:	e0332002 	eors	r2, r3, r2
8f6340f0:	e3a03000 	mov	r3, #0
8f6340f4:	1a000002 	bne	8f634104 <calloc+0x60>
8f6340f8:	e1a00004 	mov	r0, r4
8f6340fc:	e28dd00c 	add	r13, r13, #12
8f634100:	e8bd8030 	pop	{r4, r5, r15}
8f634104:	ebfffaad 	bl	8f632bc0 <__stack_chk_fail>
8f634108:	8f74221c 	.word	0x8f74221c

8f63410c <free>:

void free(void *ptr)
{
8f63410c:	e59f3038 	ldr	r3, [pc, #56]	; 8f63414c <free+0x40>
8f634110:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f634114:	e24dd00c 	sub	r13, r13, #12
8f634118:	e5933000 	ldr	r3, [r3]
8f63411c:	e58d3004 	str	r3, [r13, #4]
8f634120:	e3a03000 	mov	r3, #0
	return heap_free(ptr);
8f634124:	e59f3020 	ldr	r3, [pc, #32]	; 8f63414c <free+0x40>
8f634128:	e5932000 	ldr	r2, [r3]
8f63412c:	e59d3004 	ldr	r3, [r13, #4]
8f634130:	e0332002 	eors	r2, r3, r2
8f634134:	e3a03000 	mov	r3, #0
8f634138:	1a000002 	bne	8f634148 <free+0x3c>
}
8f63413c:	e28dd00c 	add	r13, r13, #12
8f634140:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return heap_free(ptr);
8f634144:	eafffbc7 	b	8f633068 <heap_free>
8f634148:	ebfffa9c 	bl	8f632bc0 <__stack_chk_fail>
8f63414c:	8f74221c 	.word	0x8f74221c

8f634150 <rand>:

static int randseed = 12345;

int rand(void)
{
	return (randseed = randseed * 12345 + 17);
8f634150:	e3043600 	movw	r3, #17920	; 0x4600
8f634154:	e3483f72 	movt	r3, #36722	; 0x8f72
8f634158:	e3032039 	movw	r2, #12345	; 0x3039
{
8f63415c:	e59f1044 	ldr	r1, [pc, #68]	; 8f6341a8 <rand+0x58>
	return (randseed = randseed * 12345 + 17);
8f634160:	e5930000 	ldr	r0, [r3]
{
8f634164:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f634168:	e24dd00c 	sub	r13, r13, #12
	return (randseed = randseed * 12345 + 17);
8f63416c:	e0000092 	mul	r0, r2, r0
{
8f634170:	e5911000 	ldr	r1, [r1]
8f634174:	e58d1004 	str	r1, [r13, #4]
8f634178:	e3a01000 	mov	r1, #0
	return (randseed = randseed * 12345 + 17);
8f63417c:	e2800011 	add	r0, r0, #17
8f634180:	e5830000 	str	r0, [r3]
}
8f634184:	e59f301c 	ldr	r3, [pc, #28]	; 8f6341a8 <rand+0x58>
8f634188:	e5932000 	ldr	r2, [r3]
8f63418c:	e59d3004 	ldr	r3, [r13, #4]
8f634190:	e0332002 	eors	r2, r3, r2
8f634194:	e3a03000 	mov	r3, #0
8f634198:	1a000001 	bne	8f6341a4 <rand+0x54>
8f63419c:	e28dd00c 	add	r13, r13, #12
8f6341a0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6341a4:	ebfffa85 	bl	8f632bc0 <__stack_chk_fail>
8f6341a8:	8f74221c 	.word	0x8f74221c

8f6341ac <bcopy>:
.align 2

/* void bcopy(const void *src, void *dest, size_t n); */
FUNCTION(bcopy)
	// swap args for bcopy
	mov	r12, r0
8f6341ac:	e1a0c000 	mov	r12, r0
	mov	r0, r1
8f6341b0:	e1a00001 	mov	r0, r1
	mov r1, r12
8f6341b4:	e1a0100c 	mov	r1, r12

8f6341b8 <memcpy>:

/* void *memcpy(void *dest, const void *src, size_t n); */
FUNCTION(memmove)
FUNCTION(memcpy)
	// check for zero length copy or the same pointer
	cmp		r2, #0
8f6341b8:	e3520000 	cmp	r2, #0
	cmpne	r1, r0
8f6341bc:	11510000 	cmpne	r1, r0
	bxeq	lr
8f6341c0:	012fff1e 	bxeq	r14

	// save a few registers for use and the return code (input dst)
	stmfd	sp!, {r0, r4, r5, lr}
8f6341c4:	e92d4031 	push	{r0, r4, r5, r14}

	// check for forwards overlap (src > dst, distance < len)
	subs	r3, r0, r1
8f6341c8:	e0503001 	subs	r3, r0, r1
	cmpgt	r2, r3
8f6341cc:	c1520003 	cmpgt	r2, r3
	bgt		.L_forwardoverlap
8f6341d0:	ca000030 	bgt	8f634298 <memcpy+0xe0>

	// check for a short copy len.
	// 20 bytes is enough so that if a 16 byte alignment needs to happen there is at least a 
	//   wordwise copy worth of work to be done.
	cmp		r2, #(16+4)
8f6341d4:	e3520014 	cmp	r2, #20
	blt		.L_bytewise
8f6341d8:	ba00001a 	blt	8f634248 <memcpy+0x90>

	// see if they are similarly aligned on 4 byte boundaries
	eor		r3, r0, r1
8f6341dc:	e0203001 	eor	r3, r0, r1
	tst		r3, #3
8f6341e0:	e3130003 	tst	r3, #3
	bne		.L_bytewise		// dissimilarly aligned, nothing we can do (for now)
8f6341e4:	1a000017 	bne	8f634248 <memcpy+0x90>

	// check for 16 byte alignment on dst.
	// this will also catch src being not 4 byte aligned, since it is similarly 4 byte 
	//   aligned with dst at this point.
	tst		r0, #15
8f6341e8:	e310000f 	tst	r0, #15
	bne		.L_not16bytealigned
8f6341ec:	1a00001a 	bne	8f63425c <memcpy+0xa4>

	// check to see if we have at least 32 bytes of data to copy.
	// if not, just revert to wordwise copy
	cmp		r2, #32
8f6341f0:	e3520020 	cmp	r2, #32
	blt		.L_wordwise
8f6341f4:	ba00000c 	blt	8f63422c <memcpy+0x74>
.L_bigcopy:
	// copy 32 bytes at a time. src & dst need to be at least 4 byte aligned, 
	// and we need at least 32 bytes remaining to copy

	// save r6-r7 for use in the big copy
	stmfd	sp!, {r6-r7}
8f6341f8:	e92d00c0 	push	{r6, r7}

	sub		r2, r2, #32		// subtract an extra 32 to the len so we can avoid an extra compare
8f6341fc:	e2422020 	sub	r2, r2, #32

.L_bigcopy_loop:
	ldmia	r1!, {r4, r5, r6, r7}
8f634200:	e8b100f0 	ldm	r1!, {r4, r5, r6, r7}
	stmia	r0!, {r4, r5, r6, r7}
8f634204:	e8a000f0 	stmia	r0!, {r4, r5, r6, r7}
	ldmia	r1!, {r4, r5, r6, r7}
8f634208:	e8b100f0 	ldm	r1!, {r4, r5, r6, r7}
	subs	r2, r2, #32
8f63420c:	e2522020 	subs	r2, r2, #32
	stmia	r0!, {r4, r5, r6, r7}
8f634210:	e8a000f0 	stmia	r0!, {r4, r5, r6, r7}
	bge		.L_bigcopy_loop
8f634214:	aafffff9 	bge	8f634200 <memcpy+0x48>

	// restore r6-r7
	ldmfd	sp!, {r6-r7}
8f634218:	e8bd00c0 	pop	{r6, r7}

	// see if we are done
	adds	r2, r2, #32
8f63421c:	e2922020 	adds	r2, r2, #32
	beq		.L_done
8f634220:	0a00000c 	beq	8f634258 <memcpy+0xa0>

	// less then 4 bytes left?
	cmp		r2, #4
8f634224:	e3520004 	cmp	r2, #4
	blt		.L_bytewise
8f634228:	ba000006 	blt	8f634248 <memcpy+0x90>

.L_wordwise:
	// copy 4 bytes at a time.
	// src & dst are guaranteed to be word aligned, and at least 4 bytes are left to copy.
	subs	r2, r2, #4
8f63422c:	e2522004 	subs	r2, r2, #4

.L_wordwise_loop:
	ldr		r3, [r1], #4
8f634230:	e4913004 	ldr	r3, [r1], #4
	subs	r2, r2, #4
8f634234:	e2522004 	subs	r2, r2, #4
	str		r3, [r0], #4
8f634238:	e4803004 	str	r3, [r0], #4
	bge		.L_wordwise_loop
8f63423c:	aafffffb 	bge	8f634230 <memcpy+0x78>

	// correct the remaining len and test for completion
	adds	r2, r2, #4	
8f634240:	e2922004 	adds	r2, r2, #4
	beq		.L_done
8f634244:	0a000003 	beq	8f634258 <memcpy+0xa0>

.L_bytewise:
	// simple bytewise copy
	ldrb	r3, [r1], #1
8f634248:	e4d13001 	ldrb	r3, [r1], #1
	subs	r2, r2, #1
8f63424c:	e2522001 	subs	r2, r2, #1
	strb	r3, [r0], #1
8f634250:	e4c03001 	strb	r3, [r0], #1
	bgt		.L_bytewise
8f634254:	cafffffb 	bgt	8f634248 <memcpy+0x90>

.L_done:
	// load dst for return and restore r4,r5
#if ARM_ARCH_LEVEL >= 5
	ldmfd	sp!, {r0, r4, r5, pc}
8f634258:	e8bd8031 	pop	{r0, r4, r5, r15}
.L_not16bytealigned:
	// dst is not 16 byte aligned, so we will copy up to 15 bytes to get it aligned.
	// src is guaranteed to be similarly word aligned with dst.

	// set the condition flags based on the alignment.
	lsl		r12, r0, #28
8f63425c:	e1a0ce00 	lsl	r12, r0, #28
	rsb		r12, r12, #0
8f634260:	e26cc000 	rsb	r12, r12, #0
	msr		CPSR_f, r12				// move into NZCV fields in CPSR
8f634264:	e128f00c 	msr	CPSR_f, r12

	// move as many bytes as necessary to get the dst aligned
	ldrvsb	r3, [r1], #1			// V set
8f634268:	64d13001 	ldrbvs	r3, [r1], #1
	ldrcsh	r4, [r1], #2			// C set
8f63426c:	20d140b2 	ldrhcs	r4, [r1], #2
	ldreq	r5, [r1], #4			// Z set
8f634270:	04915004 	ldreq	r5, [r1], #4

	strvsb	r3, [r0], #1
8f634274:	64c03001 	strbvs	r3, [r0], #1
	strcsh	r4, [r0], #2
8f634278:	20c040b2 	strhcs	r4, [r0], #2
	streq	r5, [r0], #4
8f63427c:	04805004 	streq	r5, [r0], #4

	ldmmiia	r1!, {r3-r4}			// N set
8f634280:	48b10018 	ldmmi	r1!, {r3, r4}
	stmmiia	r0!, {r3-r4}
8f634284:	48a00018 	stmiami	r0!, {r3, r4}

	// fix the remaining len
	sub		r2, r2, r12, lsr #28
8f634288:	e0422e2c 	sub	r2, r2, r12, lsr #28

	// test to see what we should do now
	cmp		r2, #32
8f63428c:	e3520020 	cmp	r2, #32
	bge		.L_bigcopy
8f634290:	aaffffd8 	bge	8f6341f8 <memcpy+0x40>
	b		.L_wordwise
8f634294:	eaffffe4 	b	8f63422c <memcpy+0x74>
	
	// src and dest overlap 'forwards' or dst > src
.L_forwardoverlap:

	// do a bytewise reverse copy for now
	add		r1, r1, r2
8f634298:	e0811002 	add	r1, r1, r2
	add		r0, r0, r2
8f63429c:	e0800002 	add	r0, r0, r2
	sub		r1, r1, #1
8f6342a0:	e2411001 	sub	r1, r1, #1
	sub		r0, r0, #1
8f6342a4:	e2400001 	sub	r0, r0, #1

.L_bytewisereverse:
	// simple bytewise reverse copy
	ldrb	r3, [r1], #-1
8f6342a8:	e4513001 	ldrb	r3, [r1], #-1
	subs	r2, r2, #1
8f6342ac:	e2522001 	subs	r2, r2, #1
	strb	r3, [r0], #-1
8f6342b0:	e4403001 	strb	r3, [r0], #-1
	bgt		.L_bytewisereverse
8f6342b4:	cafffffb 	bgt	8f6342a8 <memcpy+0xf0>

	b		.L_done
8f6342b8:	eaffffe6 	b	8f634258 <memcpy+0xa0>

8f6342bc <bzero>:
.text
.align 2

/* void bzero(void *s, size_t n); */
FUNCTION(bzero)
	mov		r2, r1
8f6342bc:	e1a02001 	mov	r2, r1
	mov		r1, #0
8f6342c0:	e3a01000 	mov	r1, #0

8f6342c4 <memset>:

/* void *memset(void *s, int c, size_t n); */
FUNCTION(memset)
	// check for zero length
	cmp		r2, #0
8f6342c4:	e3520000 	cmp	r2, #0
	bxeq	lr
8f6342c8:	012fff1e 	bxeq	r14

	// save the original pointer
	mov		r12, r0
8f6342cc:	e1a0c000 	mov	r12, r0

	// short memsets aren't worth optimizing
	cmp		r2, #(32 + 16)
8f6342d0:	e3520030 	cmp	r2, #48	; 0x30
	blt		.L_bytewise
8f6342d4:	ba000010 	blt	8f63431c <memset+0x58>

	// fill a 32 bit register with the 8 bit value
	and		r1, r1, #0xff
8f6342d8:	e20110ff 	and	r1, r1, #255	; 0xff
	orr		r1, r1, r1, lsl #8
8f6342dc:	e1811401 	orr	r1, r1, r1, lsl #8
	orr		r1, r1, r1, lsl #16
8f6342e0:	e1811801 	orr	r1, r1, r1, lsl #16

	// check for 16 byte alignment
	tst		r0, #15
8f6342e4:	e310000f 	tst	r0, #15
	bne		.L_not16bytealigned
8f6342e8:	1a000010 	bne	8f634330 <memset+0x6c>

.L_bigset:
	// dump some registers to make space for our values
	stmfd	sp!, { r4-r5 }
8f6342ec:	e92d0030 	push	{r4, r5}
	
	// fill a bunch of registers with the set value
	mov		r3, r1
8f6342f0:	e1a03001 	mov	r3, r1
	mov		r4, r1
8f6342f4:	e1a04001 	mov	r4, r1
	mov		r5, r1
8f6342f8:	e1a05001 	mov	r5, r1

	// prepare the count register so we can avoid an extra compare
	sub 	r2, r2, #32
8f6342fc:	e2422020 	sub	r2, r2, #32

	// 32 bytes at a time
.L_bigset_loop:
	stmia	r0!, { r1, r3, r4, r5 }
8f634300:	e8a0003a 	stmia	r0!, {r1, r3, r4, r5}
	subs	r2, r2, #32
8f634304:	e2522020 	subs	r2, r2, #32
	stmia	r0!, { r1, r3, r4, r5 }
8f634308:	e8a0003a 	stmia	r0!, {r1, r3, r4, r5}
	bge		.L_bigset_loop
8f63430c:	aafffffb 	bge	8f634300 <memset+0x3c>

	// restore our dumped registers
	ldmfd	sp!, { r4-r5 }
8f634310:	e8bd0030 	pop	{r4, r5}

	// see if we're done
	adds	r2, r2, #32
8f634314:	e2922020 	adds	r2, r2, #32
	beq		.L_done
8f634318:	0a000002 	beq	8f634328 <memset+0x64>

.L_bytewise:
	// bytewise memset
	subs	r2, r2, #1
8f63431c:	e2522001 	subs	r2, r2, #1
	strb	r1, [r0], #1
8f634320:	e4c01001 	strb	r1, [r0], #1
	bgt		.L_bytewise
8f634324:	cafffffc 	bgt	8f63431c <memset+0x58>

.L_done:
	// restore the base pointer as return value
	mov		r0, r12
8f634328:	e1a0000c 	mov	r0, r12
	bx		lr
8f63432c:	e12fff1e 	bx	r14

.L_not16bytealigned:
	// dst is not 16 byte aligned, so we will set up to 15 bytes to get it aligned.

	// set the condition flags based on the alignment.
	lsl     r3, r0, #28
8f634330:	e1a03e00 	lsl	r3, r0, #28
	rsb     r3, r3, #0
8f634334:	e2633000 	rsb	r3, r3, #0
	msr     CPSR_f, r3             // move into NZCV fields in CPSR
8f634338:	e128f003 	msr	CPSR_f, r3

	// move as many bytes as necessary to get the dst aligned
	strvsb  r1, [r0], #1			// V set
8f63433c:	64c01001 	strbvs	r1, [r0], #1
	strcsh  r1, [r0], #2			// C set
8f634340:	20c010b2 	strhcs	r1, [r0], #2
	streq   r1, [r0], #4			// Z set
8f634344:	04801004 	streq	r1, [r0], #4
	strmi   r1, [r0], #4			// N set
8f634348:	44801004 	strmi	r1, [r0], #4
	strmi   r1, [r0], #4			// N set
8f63434c:	44801004 	strmi	r1, [r0], #4

	// fix the remaining len
	sub     r2, r2, r3, lsr #28
8f634350:	e0422e23 	sub	r2, r2, r3, lsr #28

	// do the large memset
	b       .L_bigset
8f634354:	eaffffe4 	b	8f6342ec <memset+0x28>

8f634358 <memchr>:
#include <string.h>
#include <sys/types.h>

void *
memchr(void const *buf, int c, size_t len)
{
8f634358:	e59f3074 	ldr	r3, [pc, #116]	; 8f6343d4 <memchr+0x7c>
	size_t i;
	unsigned char const *b= buf;
	unsigned char        x= (c&0xff);

	for(i= 0; i< len; i++) {
8f63435c:	e3520000 	cmp	r2, #0
{
8f634360:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f634364:	e24dd00c 	sub	r13, r13, #12
8f634368:	e5933000 	ldr	r3, [r3]
8f63436c:	e58d3004 	str	r3, [r13, #4]
8f634370:	e3a03000 	mov	r3, #0
	for(i= 0; i< len; i++) {
8f634374:	0a000013 	beq	8f6343c8 <memchr+0x70>
8f634378:	e6ef1071 	uxtb	r1, r1
8f63437c:	e080c002 	add	r12, r0, r2
8f634380:	e1a03000 	mov	r3, r0
8f634384:	ea000001 	b	8f634390 <memchr+0x38>
8f634388:	e153000c 	cmp	r3, r12
8f63438c:	0a00000b 	beq	8f6343c0 <memchr+0x68>
		if(b[i]== x) {
8f634390:	e1a00003 	mov	r0, r3
8f634394:	e4d32001 	ldrb	r2, [r3], #1
8f634398:	e1520001 	cmp	r2, r1
8f63439c:	1afffff9 	bne	8f634388 <memchr+0x30>
			return (void*)(b+i);
		}
	}

	return NULL;
}
8f6343a0:	e59f302c 	ldr	r3, [pc, #44]	; 8f6343d4 <memchr+0x7c>
8f6343a4:	e5932000 	ldr	r2, [r3]
8f6343a8:	e59d3004 	ldr	r3, [r13, #4]
8f6343ac:	e0332002 	eors	r2, r3, r2
8f6343b0:	e3a03000 	mov	r3, #0
8f6343b4:	1a000005 	bne	8f6343d0 <memchr+0x78>
8f6343b8:	e28dd00c 	add	r13, r13, #12
8f6343bc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	return NULL;
8f6343c0:	e3a00000 	mov	r0, #0
8f6343c4:	eafffff5 	b	8f6343a0 <memchr+0x48>
8f6343c8:	e1a00002 	mov	r0, r2
8f6343cc:	eafffff3 	b	8f6343a0 <memchr+0x48>
}
8f6343d0:	ebfff9fa 	bl	8f632bc0 <__stack_chk_fail>
8f6343d4:	8f74221c 	.word	0x8f74221c

8f6343d8 <memcmp>:
#include <string.h>
#include <sys/types.h>

int
memcmp(const void *cs, const void *ct, size_t count)
{
8f6343d8:	e59f3078 	ldr	r3, [pc, #120]	; 8f634458 <memcmp+0x80>
	const unsigned char *su1, *su2;
	signed char res = 0;

	for(su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
8f6343dc:	e3520000 	cmp	r2, #0
{
8f6343e0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6343e4:	e24dd00c 	sub	r13, r13, #12
8f6343e8:	e5933000 	ldr	r3, [r3]
8f6343ec:	e58d3004 	str	r3, [r13, #4]
8f6343f0:	e3a03000 	mov	r3, #0
	for(su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
8f6343f4:	0a000014 	beq	8f63444c <memcmp+0x74>
8f6343f8:	e2422001 	sub	r2, r2, #1
8f6343fc:	e2403001 	sub	r3, r0, #1
8f634400:	e2411001 	sub	r1, r1, #1
8f634404:	e0802002 	add	r2, r0, r2
8f634408:	ea000001 	b	8f634414 <memcmp+0x3c>
8f63440c:	e1530002 	cmp	r3, r2
8f634410:	0a000005 	beq	8f63442c <memcmp+0x54>
		if((res = *su1 - *su2) != 0)
8f634414:	e5f30001 	ldrb	r0, [r3, #1]!
8f634418:	e5f1c001 	ldrb	r12, [r1, #1]!
8f63441c:	e040000c 	sub	r0, r0, r12
8f634420:	e6af0070 	sxtb	r0, r0
8f634424:	e3500000 	cmp	r0, #0
8f634428:	0afffff7 	beq	8f63440c <memcmp+0x34>
			break;
	return res;
}
8f63442c:	e59f3024 	ldr	r3, [pc, #36]	; 8f634458 <memcmp+0x80>
8f634430:	e5932000 	ldr	r2, [r3]
8f634434:	e59d3004 	ldr	r3, [r13, #4]
8f634438:	e0332002 	eors	r2, r3, r2
8f63443c:	e3a03000 	mov	r3, #0
8f634440:	1a000003 	bne	8f634454 <memcmp+0x7c>
8f634444:	e28dd00c 	add	r13, r13, #12
8f634448:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	for(su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
8f63444c:	e1a00002 	mov	r0, r2
	return res;
8f634450:	eafffff5 	b	8f63442c <memcmp+0x54>
}
8f634454:	ebfff9d9 	bl	8f632bc0 <__stack_chk_fail>
8f634458:	8f74221c 	.word	0x8f74221c

8f63445c <memscpy>:

#include <string.h>

size_t memscpy(void *dest, size_t dst_size, const void *src, size_t src_size)
{
	size_t copy_size = dst_size < src_size ? dst_size : src_size;
8f63445c:	e1530001 	cmp	r3, r1
{
8f634460:	e92d4010 	push	{r4, r14}
	size_t copy_size = dst_size < src_size ? dst_size : src_size;
8f634464:	31a04003 	movcc	r4, r3
8f634468:	21a04001 	movcs	r4, r1
{
8f63446c:	e59f3040 	ldr	r3, [pc, #64]	; 8f6344b4 <memscpy+0x58>
8f634470:	e24dd008 	sub	r13, r13, #8
	memcpy(dest, src, copy_size);
8f634474:	e1a01002 	mov	r1, r2
8f634478:	e1a02004 	mov	r2, r4
{
8f63447c:	e5933000 	ldr	r3, [r3]
8f634480:	e58d3004 	str	r3, [r13, #4]
8f634484:	e3a03000 	mov	r3, #0
	memcpy(dest, src, copy_size);
8f634488:	ebffff4a 	bl	8f6341b8 <memcpy>
	return copy_size;
}
8f63448c:	e59f3020 	ldr	r3, [pc, #32]	; 8f6344b4 <memscpy+0x58>
8f634490:	e5932000 	ldr	r2, [r3]
8f634494:	e59d3004 	ldr	r3, [r13, #4]
8f634498:	e0332002 	eors	r2, r3, r2
8f63449c:	e3a03000 	mov	r3, #0
8f6344a0:	1a000002 	bne	8f6344b0 <memscpy+0x54>
8f6344a4:	e1a00004 	mov	r0, r4
8f6344a8:	e28dd008 	add	r13, r13, #8
8f6344ac:	e8bd8010 	pop	{r4, r15}
8f6344b0:	ebfff9c2 	bl	8f632bc0 <__stack_chk_fail>
8f6344b4:	8f74221c 	.word	0x8f74221c

8f6344b8 <strchr>:
#include <string.h>
#include <sys/types.h>

char *
strchr(const char *s, int c)
{
8f6344b8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	for(; *s != (char) c; ++s)
8f6344bc:	e6ef1071 	uxtb	r1, r1
8f6344c0:	e5d03000 	ldrb	r3, [r0]
{
8f6344c4:	e24dd00c 	sub	r13, r13, #12
8f6344c8:	e59f2050 	ldr	r2, [pc, #80]	; 8f634520 <strchr+0x68>
	for(; *s != (char) c; ++s)
8f6344cc:	e1530001 	cmp	r3, r1
{
8f6344d0:	e5922000 	ldr	r2, [r2]
8f6344d4:	e58d2004 	str	r2, [r13, #4]
8f6344d8:	e3a02000 	mov	r2, #0
	for(; *s != (char) c; ++s)
8f6344dc:	1a000003 	bne	8f6344f0 <strchr+0x38>
8f6344e0:	ea000005 	b	8f6344fc <strchr+0x44>
8f6344e4:	e5f03001 	ldrb	r3, [r0, #1]!
8f6344e8:	e1530001 	cmp	r3, r1
8f6344ec:	0a000002 	beq	8f6344fc <strchr+0x44>
		if (*s == '\0')
8f6344f0:	e3530000 	cmp	r3, #0
8f6344f4:	1afffffa 	bne	8f6344e4 <strchr+0x2c>
			return NULL;
8f6344f8:	e1a00003 	mov	r0, r3
	return (char *) s;
}
8f6344fc:	e59f301c 	ldr	r3, [pc, #28]	; 8f634520 <strchr+0x68>
8f634500:	e5932000 	ldr	r2, [r3]
8f634504:	e59d3004 	ldr	r3, [r13, #4]
8f634508:	e0332002 	eors	r2, r3, r2
8f63450c:	e3a03000 	mov	r3, #0
8f634510:	1a000001 	bne	8f63451c <strchr+0x64>
8f634514:	e28dd00c 	add	r13, r13, #12
8f634518:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f63451c:	ebfff9a7 	bl	8f632bc0 <__stack_chk_fail>
8f634520:	8f74221c 	.word	0x8f74221c

8f634524 <strcmp>:
#include <string.h>
#include <sys/types.h>

int
strcmp(char const *cs, char const *ct)
{
8f634524:	e59f3064 	ldr	r3, [pc, #100]	; 8f634590 <strcmp+0x6c>
8f634528:	e2402001 	sub	r2, r0, #1
8f63452c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f634530:	e24dd00c 	sub	r13, r13, #12
8f634534:	e5933000 	ldr	r3, [r3]
8f634538:	e58d3004 	str	r3, [r13, #4]
8f63453c:	e3a03000 	mov	r3, #0
8f634540:	ea000001 	b	8f63454c <strcmp+0x28>
	signed char __res;

	while(1) {
		if((__res = *cs - *ct++) != 0 || !*cs++)
8f634544:	e3530000 	cmp	r3, #0
8f634548:	0a00000d 	beq	8f634584 <strcmp+0x60>
8f63454c:	e5f23001 	ldrb	r3, [r2, #1]!
8f634550:	e4d10001 	ldrb	r0, [r1], #1
8f634554:	e0430000 	sub	r0, r3, r0
8f634558:	e6af0070 	sxtb	r0, r0
8f63455c:	e3500000 	cmp	r0, #0
8f634560:	0afffff7 	beq	8f634544 <strcmp+0x20>
			break;
	}

	return __res;
}
8f634564:	e59f3024 	ldr	r3, [pc, #36]	; 8f634590 <strcmp+0x6c>
8f634568:	e5932000 	ldr	r2, [r3]
8f63456c:	e59d3004 	ldr	r3, [r13, #4]
8f634570:	e0332002 	eors	r2, r3, r2
8f634574:	e3a03000 	mov	r3, #0
8f634578:	1a000003 	bne	8f63458c <strcmp+0x68>
8f63457c:	e28dd00c 	add	r13, r13, #12
8f634580:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f634584:	e1a00003 	mov	r0, r3
	return __res;
8f634588:	eafffff5 	b	8f634564 <strcmp+0x40>
}
8f63458c:	ebfff98b 	bl	8f632bc0 <__stack_chk_fail>
8f634590:	8f74221c 	.word	0x8f74221c

8f634594 <strcpy>:
#include <string.h>
#include <sys/types.h>

char *
strcpy(char *dest, char const *src)
{
8f634594:	e59f3048 	ldr	r3, [pc, #72]	; 8f6345e4 <strcpy+0x50>
8f634598:	e2402001 	sub	r2, r0, #1
8f63459c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6345a0:	e24dd00c 	sub	r13, r13, #12
8f6345a4:	e5933000 	ldr	r3, [r3]
8f6345a8:	e58d3004 	str	r3, [r13, #4]
8f6345ac:	e3a03000 	mov	r3, #0
	char *tmp = dest;

	while((*dest++ = *src++) != '\0')
8f6345b0:	e4d13001 	ldrb	r3, [r1], #1
8f6345b4:	e3530000 	cmp	r3, #0
8f6345b8:	e5e23001 	strb	r3, [r2, #1]!
8f6345bc:	1afffffb 	bne	8f6345b0 <strcpy+0x1c>
		;
	return tmp;
}
8f6345c0:	e59f301c 	ldr	r3, [pc, #28]	; 8f6345e4 <strcpy+0x50>
8f6345c4:	e5932000 	ldr	r2, [r3]
8f6345c8:	e59d3004 	ldr	r3, [r13, #4]
8f6345cc:	e0332002 	eors	r2, r3, r2
8f6345d0:	e3a03000 	mov	r3, #0
8f6345d4:	1a000001 	bne	8f6345e0 <strcpy+0x4c>
8f6345d8:	e28dd00c 	add	r13, r13, #12
8f6345dc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6345e0:	ebfff976 	bl	8f632bc0 <__stack_chk_fail>
8f6345e4:	8f74221c 	.word	0x8f74221c

8f6345e8 <strdup>:
#include <stdlib.h>
#include <string.h>

char *
strdup(const char *str)
{
8f6345e8:	e59f3060 	ldr	r3, [pc, #96]	; 8f634650 <strdup+0x68>
8f6345ec:	e92d4070 	push	{r4, r5, r6, r14}
8f6345f0:	e24dd008 	sub	r13, r13, #8
8f6345f4:	e5933000 	ldr	r3, [r3]
8f6345f8:	e58d3004 	str	r3, [r13, #4]
8f6345fc:	e3a03000 	mov	r3, #0
8f634600:	e1a06000 	mov	r6, r0
	size_t len;
	char *copy;
	
	len = strlen(str) + 1;
8f634604:	eb00007f 	bl	8f634808 <strlen>
8f634608:	e2805001 	add	r5, r0, #1
	copy = malloc(len);
8f63460c:	e1a00005 	mov	r0, r5
8f634610:	ebfffe79 	bl	8f633ffc <malloc>
	if (copy == NULL)
8f634614:	e2504000 	subs	r4, r0, #0
8f634618:	0a000002 	beq	8f634628 <strdup+0x40>
		return NULL;
	memcpy(copy, str, len);
8f63461c:	e1a02005 	mov	r2, r5
8f634620:	e1a01006 	mov	r1, r6
8f634624:	ebfffee3 	bl	8f6341b8 <memcpy>
	return copy;
}
8f634628:	e59f3020 	ldr	r3, [pc, #32]	; 8f634650 <strdup+0x68>
8f63462c:	e5932000 	ldr	r2, [r3]
8f634630:	e59d3004 	ldr	r3, [r13, #4]
8f634634:	e0332002 	eors	r2, r3, r2
8f634638:	e3a03000 	mov	r3, #0
8f63463c:	1a000002 	bne	8f63464c <strdup+0x64>
8f634640:	e1a00004 	mov	r0, r4
8f634644:	e28dd008 	add	r13, r13, #8
8f634648:	e8bd8070 	pop	{r4, r5, r6, r15}
8f63464c:	ebfff95b 	bl	8f632bc0 <__stack_chk_fail>
8f634650:	8f74221c 	.word	0x8f74221c

8f634654 <strlcat>:
#include <string.h>
#include <sys/types.h>

size_t
strlcat(char *dst, char const *src, size_t s)
{
8f634654:	e59f30d0 	ldr	r3, [pc, #208]	; 8f63472c <strlcat+0xd8>
8f634658:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f63465c:	e1a07001 	mov	r7, r1
8f634660:	e24dd00c 	sub	r13, r13, #12
	size_t i;
	size_t j= strnlen(dst, s);
8f634664:	e1a01002 	mov	r1, r2
{
8f634668:	e1a04002 	mov	r4, r2
8f63466c:	e5933000 	ldr	r3, [r3]
8f634670:	e58d3004 	str	r3, [r13, #4]
8f634674:	e3a03000 	mov	r3, #0
8f634678:	e1a06000 	mov	r6, r0
	size_t j= strnlen(dst, s);
8f63467c:	eb00009d 	bl	8f6348f8 <strnlen>

	if(!s) {
8f634680:	e3540000 	cmp	r4, #0
	size_t j= strnlen(dst, s);
8f634684:	e1a05000 	mov	r5, r0
	if(!s) {
8f634688:	0a00001f 	beq	8f63470c <strlcat+0xb8>
		return j+strlen(src);
	}

	dst+= j;

	for(i= 0; ((i< s-j) && src[i]); i++) {
8f63468c:	e0542000 	subs	r2, r4, r0
	dst+= j;
8f634690:	e0866000 	add	r6, r6, r0
	for(i= 0; ((i< s-j) && src[i]); i++) {
8f634694:	01a04002 	moveq	r4, r2
8f634698:	01a00007 	moveq	r0, r7
8f63469c:	0a00000d 	beq	8f6346d8 <strlcat+0x84>
8f6346a0:	e246e001 	sub	r14, r6, #1
8f6346a4:	e1a03007 	mov	r3, r7
8f6346a8:	e3a04000 	mov	r4, #0
8f6346ac:	ea000003 	b	8f6346c0 <strlcat+0x6c>
8f6346b0:	e2844001 	add	r4, r4, #1
		dst[i]= src[i];
8f6346b4:	e5eec001 	strb	r12, [r14, #1]!
	for(i= 0; ((i< s-j) && src[i]); i++) {
8f6346b8:	e1540002 	cmp	r4, r2
8f6346bc:	0a000016 	beq	8f63471c <strlcat+0xc8>
8f6346c0:	e5d3c000 	ldrb	r12, [r3]
8f6346c4:	e1a00003 	mov	r0, r3
8f6346c8:	e2833001 	add	r3, r3, #1
8f6346cc:	e35c0000 	cmp	r12, #0
8f6346d0:	1afffff6 	bne	8f6346b0 <strlcat+0x5c>
	}

	dst[i]= 0;
8f6346d4:	e0866004 	add	r6, r6, r4
8f6346d8:	e3a03000 	mov	r3, #0
8f6346dc:	e5c63000 	strb	r3, [r6]

	return j + i + strlen(src+i);
8f6346e0:	eb000048 	bl	8f634808 <strlen>
8f6346e4:	e0800004 	add	r0, r0, r4
8f6346e8:	e0800005 	add	r0, r0, r5
}
8f6346ec:	e59f3038 	ldr	r3, [pc, #56]	; 8f63472c <strlcat+0xd8>
8f6346f0:	e5932000 	ldr	r2, [r3]
8f6346f4:	e59d3004 	ldr	r3, [r13, #4]
8f6346f8:	e0332002 	eors	r2, r3, r2
8f6346fc:	e3a03000 	mov	r3, #0
8f634700:	1a000008 	bne	8f634728 <strlcat+0xd4>
8f634704:	e28dd00c 	add	r13, r13, #12
8f634708:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		return j+strlen(src);
8f63470c:	e1a00007 	mov	r0, r7
8f634710:	eb00003c 	bl	8f634808 <strlen>
8f634714:	e0800005 	add	r0, r0, r5
8f634718:	eafffff3 	b	8f6346ec <strlcat+0x98>
	dst[i]= 0;
8f63471c:	e0866004 	add	r6, r6, r4
	return j + i + strlen(src+i);
8f634720:	e0870004 	add	r0, r7, r4
8f634724:	eaffffeb 	b	8f6346d8 <strlcat+0x84>
}
8f634728:	ebfff924 	bl	8f632bc0 <__stack_chk_fail>
8f63472c:	8f74221c 	.word	0x8f74221c

8f634730 <strlcpy>:
#include <string.h>
#include <sys/types.h>

size_t
strlcpy(char *dst, char const *src, size_t s)
{
8f634730:	e59f30cc 	ldr	r3, [pc, #204]	; 8f634804 <strlcpy+0xd4>
	size_t i= 0;

	if(!s) {
8f634734:	e3520000 	cmp	r2, #0
{
8f634738:	e92d4030 	push	{r4, r5, r14}
8f63473c:	e24dd00c 	sub	r13, r13, #12
8f634740:	e5933000 	ldr	r3, [r3]
8f634744:	e58d3004 	str	r3, [r13, #4]
8f634748:	e3a03000 	mov	r3, #0
	if(!s) {
8f63474c:	0a00001e 	beq	8f6347cc <strlcpy+0x9c>
		return strlen(src);
	}

	for(i= 0; ((i< s-1) && src[i]); i++) {
8f634750:	e252e001 	subs	r14, r2, #1
8f634754:	e1a05000 	mov	r5, r0
8f634758:	01a0400e 	moveq	r4, r14
8f63475c:	01a00001 	moveq	r0, r1
8f634760:	0a00000d 	beq	8f63479c <strlcpy+0x6c>
8f634764:	e245c001 	sub	r12, r5, #1
8f634768:	e1a03001 	mov	r3, r1
8f63476c:	e3a04000 	mov	r4, #0
8f634770:	ea000003 	b	8f634784 <strlcpy+0x54>
8f634774:	e2844001 	add	r4, r4, #1
		dst[i]= src[i];
8f634778:	e5ec2001 	strb	r2, [r12, #1]!
	for(i= 0; ((i< s-1) && src[i]); i++) {
8f63477c:	e154000e 	cmp	r4, r14
8f634780:	0a00001b 	beq	8f6347f4 <strlcpy+0xc4>
8f634784:	e5d32000 	ldrb	r2, [r3]
8f634788:	e1a00003 	mov	r0, r3
8f63478c:	e2833001 	add	r3, r3, #1
8f634790:	e3520000 	cmp	r2, #0
8f634794:	1afffff6 	bne	8f634774 <strlcpy+0x44>
	}

	dst[i]= 0;
8f634798:	e0855004 	add	r5, r5, r4
8f63479c:	e3a03000 	mov	r3, #0
8f6347a0:	e5c53000 	strb	r3, [r5]

	return i + strlen(src+i);
8f6347a4:	eb000017 	bl	8f634808 <strlen>
}
8f6347a8:	e59f3054 	ldr	r3, [pc, #84]	; 8f634804 <strlcpy+0xd4>
8f6347ac:	e5932000 	ldr	r2, [r3]
8f6347b0:	e59d3004 	ldr	r3, [r13, #4]
8f6347b4:	e0332002 	eors	r2, r3, r2
8f6347b8:	e3a03000 	mov	r3, #0
	return i + strlen(src+i);
8f6347bc:	e0800004 	add	r0, r0, r4
}
8f6347c0:	1a00000e 	bne	8f634800 <strlcpy+0xd0>
8f6347c4:	e28dd00c 	add	r13, r13, #12
8f6347c8:	e8bd8030 	pop	{r4, r5, r15}
		return strlen(src);
8f6347cc:	e59f3030 	ldr	r3, [pc, #48]	; 8f634804 <strlcpy+0xd4>
8f6347d0:	e5932000 	ldr	r2, [r3]
8f6347d4:	e59d3004 	ldr	r3, [r13, #4]
8f6347d8:	e0332002 	eors	r2, r3, r2
8f6347dc:	e3a03000 	mov	r3, #0
8f6347e0:	1a000006 	bne	8f634800 <strlcpy+0xd0>
8f6347e4:	e1a00001 	mov	r0, r1
}
8f6347e8:	e28dd00c 	add	r13, r13, #12
8f6347ec:	e8bd4030 	pop	{r4, r5, r14}
		return strlen(src);
8f6347f0:	ea000004 	b	8f634808 <strlen>
	dst[i]= 0;
8f6347f4:	e0855004 	add	r5, r5, r4
	return i + strlen(src+i);
8f6347f8:	e0810004 	add	r0, r1, r4
8f6347fc:	eaffffe6 	b	8f63479c <strlcpy+0x6c>
}
8f634800:	ebfff8ee 	bl	8f632bc0 <__stack_chk_fail>
8f634804:	8f74221c 	.word	0x8f74221c

8f634808 <strlen>:
#include <string.h>
#include <sys/types.h>

size_t
strlen(char const *s)
{
8f634808:	e59f3058 	ldr	r3, [pc, #88]	; 8f634868 <strlen+0x60>
8f63480c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f634810:	e24dd00c 	sub	r13, r13, #12
8f634814:	e5933000 	ldr	r3, [r3]
8f634818:	e58d3004 	str	r3, [r13, #4]
8f63481c:	e3a03000 	mov	r3, #0
8f634820:	e1a03000 	mov	r3, r0
	size_t i;

	i= 0;
	while(s[i]) {
8f634824:	e5d00000 	ldrb	r0, [r0]
8f634828:	e3500000 	cmp	r0, #0
8f63482c:	0a000004 	beq	8f634844 <strlen+0x3c>
8f634830:	e2631001 	rsb	r1, r3, #1
		i+= 1;
8f634834:	e0810003 	add	r0, r1, r3
	while(s[i]) {
8f634838:	e5f32001 	ldrb	r2, [r3, #1]!
8f63483c:	e3520000 	cmp	r2, #0
8f634840:	1afffffb 	bne	8f634834 <strlen+0x2c>
	}

	return i;
}
8f634844:	e59f301c 	ldr	r3, [pc, #28]	; 8f634868 <strlen+0x60>
8f634848:	e5932000 	ldr	r2, [r3]
8f63484c:	e59d3004 	ldr	r3, [r13, #4]
8f634850:	e0332002 	eors	r2, r3, r2
8f634854:	e3a03000 	mov	r3, #0
8f634858:	1a000001 	bne	8f634864 <strlen+0x5c>
8f63485c:	e28dd00c 	add	r13, r13, #12
8f634860:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f634864:	ebfff8d5 	bl	8f632bc0 <__stack_chk_fail>
8f634868:	8f74221c 	.word	0x8f74221c

8f63486c <strncmp>:
#include <string.h>
#include <sys/types.h>

int
strncmp(char const *cs, char const *ct, size_t count)
{
8f63486c:	e59f3080 	ldr	r3, [pc, #128]	; 8f6348f4 <strncmp+0x88>
	signed char __res = 0;

	while(count > 0) {
8f634870:	e3520000 	cmp	r2, #0
{
8f634874:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f634878:	e24dd00c 	sub	r13, r13, #12
8f63487c:	e5933000 	ldr	r3, [r3]
8f634880:	e58d3004 	str	r3, [r13, #4]
8f634884:	e3a03000 	mov	r3, #0
	while(count > 0) {
8f634888:	0a000016 	beq	8f6348e8 <strncmp+0x7c>
8f63488c:	e240c001 	sub	r12, r0, #1
8f634890:	e0812002 	add	r2, r1, r2
8f634894:	ea000003 	b	8f6348a8 <strncmp+0x3c>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
8f634898:	e3530000 	cmp	r3, #0
8f63489c:	0a00000f 	beq	8f6348e0 <strncmp+0x74>
	while(count > 0) {
8f6348a0:	e1520001 	cmp	r2, r1
8f6348a4:	0a000005 	beq	8f6348c0 <strncmp+0x54>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
8f6348a8:	e5fc3001 	ldrb	r3, [r12, #1]!
8f6348ac:	e4d10001 	ldrb	r0, [r1], #1
8f6348b0:	e0430000 	sub	r0, r3, r0
8f6348b4:	e6af0070 	sxtb	r0, r0
8f6348b8:	e3500000 	cmp	r0, #0
8f6348bc:	0afffff5 	beq	8f634898 <strncmp+0x2c>
			break;
		count--;
	}

	return __res;
}
8f6348c0:	e59f302c 	ldr	r3, [pc, #44]	; 8f6348f4 <strncmp+0x88>
8f6348c4:	e5932000 	ldr	r2, [r3]
8f6348c8:	e59d3004 	ldr	r3, [r13, #4]
8f6348cc:	e0332002 	eors	r2, r3, r2
8f6348d0:	e3a03000 	mov	r3, #0
8f6348d4:	1a000005 	bne	8f6348f0 <strncmp+0x84>
8f6348d8:	e28dd00c 	add	r13, r13, #12
8f6348dc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6348e0:	e1a00003 	mov	r0, r3
	return __res;
8f6348e4:	eafffff5 	b	8f6348c0 <strncmp+0x54>
	while(count > 0) {
8f6348e8:	e1a00002 	mov	r0, r2
8f6348ec:	eafffff3 	b	8f6348c0 <strncmp+0x54>
}
8f6348f0:	ebfff8b2 	bl	8f632bc0 <__stack_chk_fail>
8f6348f4:	8f74221c 	.word	0x8f74221c

8f6348f8 <strnlen>:
#include <string.h>
#include <sys/types.h>

size_t
strnlen(char const *s, size_t count)
{
8f6348f8:	e59f3074 	ldr	r3, [pc, #116]	; 8f634974 <strnlen+0x7c>
	const char *sc;

	for(sc = s; count-- && *sc != '\0'; ++sc)
8f6348fc:	e251c000 	subs	r12, r1, #0
{
8f634900:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f634904:	e24dd00c 	sub	r13, r13, #12
8f634908:	e5933000 	ldr	r3, [r3]
8f63490c:	e58d3004 	str	r3, [r13, #4]
8f634910:	e3a03000 	mov	r3, #0
	for(sc = s; count-- && *sc != '\0'; ++sc)
8f634914:	01a0000c 	moveq	r0, r12
8f634918:	0a00000a 	beq	8f634948 <strnlen+0x50>
8f63491c:	e080c00c 	add	r12, r0, r12
8f634920:	e1a03000 	mov	r3, r0
8f634924:	ea000001 	b	8f634930 <strnlen+0x38>
8f634928:	e153000c 	cmp	r3, r12
8f63492c:	0a00000d 	beq	8f634968 <strnlen+0x70>
8f634930:	e1a02003 	mov	r2, r3
8f634934:	e2833001 	add	r3, r3, #1
8f634938:	e5d21000 	ldrb	r1, [r2]
8f63493c:	e3510000 	cmp	r1, #0
8f634940:	1afffff8 	bne	8f634928 <strnlen+0x30>
		;
	return sc - s;
8f634944:	e0420000 	sub	r0, r2, r0
}
8f634948:	e59f3024 	ldr	r3, [pc, #36]	; 8f634974 <strnlen+0x7c>
8f63494c:	e5932000 	ldr	r2, [r3]
8f634950:	e59d3004 	ldr	r3, [r13, #4]
8f634954:	e0332002 	eors	r2, r3, r2
8f634958:	e3a03000 	mov	r3, #0
8f63495c:	1a000003 	bne	8f634970 <strnlen+0x78>
8f634960:	e28dd00c 	add	r13, r13, #12
8f634964:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	return sc - s;
8f634968:	e0430000 	sub	r0, r3, r0
8f63496c:	eafffff5 	b	8f634948 <strnlen+0x50>
}
8f634970:	ebfff892 	bl	8f632bc0 <__stack_chk_fail>
8f634974:	8f74221c 	.word	0x8f74221c

8f634978 <strrev>:
#include <string.h>
#include <sys/types.h>

void
strrev(unsigned char *str)
{
8f634978:	e59f3084 	ldr	r3, [pc, #132]	; 8f634a04 <strrev+0x8c>
8f63497c:	e92d4070 	push	{r4, r5, r6, r14}
8f634980:	e24dd008 	sub	r13, r13, #8
8f634984:	e5933000 	ldr	r3, [r3]
8f634988:	e58d3004 	str	r3, [r13, #4]
8f63498c:	e3a03000 	mov	r3, #0
8f634990:	e1a04000 	mov	r4, r0
	int i;
	int j;
	unsigned char a;
	unsigned len = strlen((const char *)str);
8f634994:	ebffff9b 	bl	8f634808 <strlen>

	for (i = 0, j = len - 1; i < j; i++, j--)
8f634998:	e2403001 	sub	r3, r0, #1
8f63499c:	e3530000 	cmp	r3, #0
8f6349a0:	da00000e 	ble	8f6349e0 <strrev+0x68>
8f6349a4:	e2441001 	sub	r1, r4, #1
8f6349a8:	e084c000 	add	r12, r4, r0
8f6349ac:	e3e06001 	mvn	r6, #1
	{
		a = str[i];
8f6349b0:	e1a02001 	mov	r2, r1
8f6349b4:	e5f1e001 	ldrb	r14, [r1, #1]!
	for (i = 0, j = len - 1; i < j; i++, j--)
8f6349b8:	e2822002 	add	r2, r2, #2
		str[i] = str[j];
8f6349bc:	e57c5001 	ldrb	r5, [r12, #-1]!
	for (i = 0, j = len - 1; i < j; i++, j--)
8f6349c0:	e0463001 	sub	r3, r6, r1
8f6349c4:	e0422004 	sub	r2, r2, r4
8f6349c8:	e0833004 	add	r3, r3, r4
8f6349cc:	e0833000 	add	r3, r3, r0
		str[i] = str[j];
8f6349d0:	e5c15000 	strb	r5, [r1]
	for (i = 0, j = len - 1; i < j; i++, j--)
8f6349d4:	e1520003 	cmp	r2, r3
		str[j] = a;
8f6349d8:	e5cce000 	strb	r14, [r12]
	for (i = 0, j = len - 1; i < j; i++, j--)
8f6349dc:	bafffff3 	blt	8f6349b0 <strrev+0x38>
	}
}
8f6349e0:	e59f301c 	ldr	r3, [pc, #28]	; 8f634a04 <strrev+0x8c>
8f6349e4:	e5932000 	ldr	r2, [r3]
8f6349e8:	e59d3004 	ldr	r3, [r13, #4]
8f6349ec:	e0332002 	eors	r2, r3, r2
8f6349f0:	e3a03000 	mov	r3, #0
8f6349f4:	1a000001 	bne	8f634a00 <strrev+0x88>
8f6349f8:	e28dd008 	add	r13, r13, #8
8f6349fc:	e8bd8070 	pop	{r4, r5, r6, r15}
8f634a00:	ebfff86e 	bl	8f632bc0 <__stack_chk_fail>
8f634a04:	8f74221c 	.word	0x8f74221c

8f634a08 <strstr>:
#include <string.h>
#include <sys/types.h>

char *
strstr(char const *s1, char const *s2)
{
8f634a08:	e59f3098 	ldr	r3, [pc, #152]	; 8f634aa8 <strstr+0xa0>
8f634a0c:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f634a10:	e1a04000 	mov	r4, r0
8f634a14:	e24dd00c 	sub	r13, r13, #12
	return strstrl(s1, s2, strlen(s2));
8f634a18:	e1a00001 	mov	r0, r1
{
8f634a1c:	e5933000 	ldr	r3, [r3]
8f634a20:	e58d3004 	str	r3, [r13, #4]
8f634a24:	e3a03000 	mov	r3, #0
8f634a28:	e1a06001 	mov	r6, r1
	return strstrl(s1, s2, strlen(s2));
8f634a2c:	ebffff75 	bl	8f634808 <strlen>
char *
strstrl(char const *s1, char const *s2, size_t l2)
{
	int l1;

	if (!l2)
8f634a30:	e2505000 	subs	r5, r0, #0
8f634a34:	0a00000f 	beq	8f634a78 <strstr+0x70>
		return (char *)s1;
	l1 = strlen(s1);
8f634a38:	e1a00004 	mov	r0, r4
8f634a3c:	ebffff71 	bl	8f634808 <strlen>
	while(l1 >= l2) {
8f634a40:	e1550000 	cmp	r5, r0
8f634a44:	8a000014 	bhi	8f634a9c <strstr+0x94>
8f634a48:	e0847000 	add	r7, r4, r0
8f634a4c:	ea000003 	b	8f634a60 <strstr+0x58>
		l1--;
		if (!memcmp(s1,s2,l2))
			return (char *)s1;
		s1++;
8f634a50:	e2844001 	add	r4, r4, #1
	while(l1 >= l2) {
8f634a54:	e0473004 	sub	r3, r7, r4
8f634a58:	e1550003 	cmp	r5, r3
8f634a5c:	8a00000e 	bhi	8f634a9c <strstr+0x94>
		if (!memcmp(s1,s2,l2))
8f634a60:	e1a02005 	mov	r2, r5
8f634a64:	e1a01006 	mov	r1, r6
8f634a68:	e1a00004 	mov	r0, r4
8f634a6c:	ebfffe59 	bl	8f6343d8 <memcmp>
8f634a70:	e3500000 	cmp	r0, #0
8f634a74:	1afffff5 	bne	8f634a50 <strstr+0x48>
}
8f634a78:	e59f3028 	ldr	r3, [pc, #40]	; 8f634aa8 <strstr+0xa0>
8f634a7c:	e5932000 	ldr	r2, [r3]
8f634a80:	e59d3004 	ldr	r3, [r13, #4]
8f634a84:	e0332002 	eors	r2, r3, r2
8f634a88:	e3a03000 	mov	r3, #0
8f634a8c:	1a000004 	bne	8f634aa4 <strstr+0x9c>
8f634a90:	e1a00004 	mov	r0, r4
8f634a94:	e28dd00c 	add	r13, r13, #12
8f634a98:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
	}
	return NULL;
8f634a9c:	e3a04000 	mov	r4, #0
	return strstrl(s1, s2, strlen(s2));
8f634aa0:	eafffff4 	b	8f634a78 <strstr+0x70>
}
8f634aa4:	ebfff845 	bl	8f632bc0 <__stack_chk_fail>
8f634aa8:	8f74221c 	.word	0x8f74221c

8f634aac <strstrl>:
{
8f634aac:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	if (!l2)
8f634ab0:	e2525000 	subs	r5, r2, #0
{
8f634ab4:	e59f3084 	ldr	r3, [pc, #132]	; 8f634b40 <strstrl+0x94>
8f634ab8:	e24dd00c 	sub	r13, r13, #12
8f634abc:	e1a04000 	mov	r4, r0
8f634ac0:	e5933000 	ldr	r3, [r3]
8f634ac4:	e58d3004 	str	r3, [r13, #4]
8f634ac8:	e3a03000 	mov	r3, #0
	if (!l2)
8f634acc:	0a00000f 	beq	8f634b10 <strstrl+0x64>
8f634ad0:	e1a07001 	mov	r7, r1
	l1 = strlen(s1);
8f634ad4:	ebffff4b 	bl	8f634808 <strlen>
	while(l1 >= l2) {
8f634ad8:	e1550000 	cmp	r5, r0
8f634adc:	8a000014 	bhi	8f634b34 <strstrl+0x88>
8f634ae0:	e0846000 	add	r6, r4, r0
8f634ae4:	ea000003 	b	8f634af8 <strstrl+0x4c>
		s1++;
8f634ae8:	e2844001 	add	r4, r4, #1
	while(l1 >= l2) {
8f634aec:	e0463004 	sub	r3, r6, r4
8f634af0:	e1550003 	cmp	r5, r3
8f634af4:	8a00000e 	bhi	8f634b34 <strstrl+0x88>
		if (!memcmp(s1,s2,l2))
8f634af8:	e1a02005 	mov	r2, r5
8f634afc:	e1a01007 	mov	r1, r7
8f634b00:	e1a00004 	mov	r0, r4
8f634b04:	ebfffe33 	bl	8f6343d8 <memcmp>
8f634b08:	e3500000 	cmp	r0, #0
8f634b0c:	1afffff5 	bne	8f634ae8 <strstrl+0x3c>
}
8f634b10:	e59f3028 	ldr	r3, [pc, #40]	; 8f634b40 <strstrl+0x94>
8f634b14:	e5932000 	ldr	r2, [r3]
8f634b18:	e59d3004 	ldr	r3, [r13, #4]
8f634b1c:	e0332002 	eors	r2, r3, r2
8f634b20:	e3a03000 	mov	r3, #0
8f634b24:	1a000004 	bne	8f634b3c <strstrl+0x90>
8f634b28:	e1a00004 	mov	r0, r4
8f634b2c:	e28dd00c 	add	r13, r13, #12
8f634b30:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
	return NULL;
8f634b34:	e3a04000 	mov	r4, #0
8f634b38:	eafffff4 	b	8f634b10 <strstrl+0x64>
}
8f634b3c:	ebfff81f 	bl	8f632bc0 <__stack_chk_fail>
8f634b40:	8f74221c 	.word	0x8f74221c

8f634b44 <strtok_r>:
	return strtok_r(s, delim, &last);
}

char *
strtok_r(char *s, const char *delim, char **last)
{
8f634b44:	e59f30bc 	ldr	r3, [pc, #188]	; 8f634c08 <strtok_r+0xc4>
	char *spanp;
	int c, sc;
	char *tok;


	if (s == NULL && (s = *last) == NULL)
8f634b48:	e3500000 	cmp	r0, #0
{
8f634b4c:	e92d4010 	push	{r4, r14}
8f634b50:	e24dd008 	sub	r13, r13, #8
8f634b54:	e5933000 	ldr	r3, [r3]
8f634b58:	e58d3004 	str	r3, [r13, #4]
8f634b5c:	e3a03000 	mov	r3, #0
	if (s == NULL && (s = *last) == NULL)
8f634b60:	0a000023 	beq	8f634bf4 <strtok_r+0xb0>

	/*
	 * Skip (span) leading delimiters (s += strspn(s, delim), sort of).
	 */
cont:
	c = *s++;
8f634b64:	e1a04000 	mov	r4, r0
	for (spanp = (char *)delim; (sc = *spanp++) != 0;) {
8f634b68:	e1a0c001 	mov	r12, r1
	c = *s++;
8f634b6c:	e4d4e001 	ldrb	r14, [r4], #1
	for (spanp = (char *)delim; (sc = *spanp++) != 0;) {
8f634b70:	ea000001 	b	8f634b7c <strtok_r+0x38>
		if (c == sc)
8f634b74:	e15e0003 	cmp	r14, r3
8f634b78:	0a00001b 	beq	8f634bec <strtok_r+0xa8>
	for (spanp = (char *)delim; (sc = *spanp++) != 0;) {
8f634b7c:	e4dc3001 	ldrb	r3, [r12], #1
8f634b80:	e3530000 	cmp	r3, #0
8f634b84:	1afffffa 	bne	8f634b74 <strtok_r+0x30>
			goto cont;
	}

	if (c == 0) {		/* no non-delimiter characters */
8f634b88:	e35e0000 	cmp	r14, #0
		*last = NULL;
8f634b8c:	0582e000 	streq	r14, [r2]
		return (NULL);
8f634b90:	01a0000e 	moveq	r0, r14
	if (c == 0) {		/* no non-delimiter characters */
8f634b94:	0a00000c 	beq	8f634bcc <strtok_r+0x88>
	/*
	 * Scan token (scan for delimiters: s += strcspn(s, delim), sort of).
	 * Note that delim must have one NUL; we stop if we see that, too.
	 */
	for (;;) {
		c = *s++;
8f634b98:	e4d4e001 	ldrb	r14, [r4], #1
		spanp = (char *)delim;
8f634b9c:	e1a0c001 	mov	r12, r1
8f634ba0:	ea000001 	b	8f634bac <strtok_r+0x68>
				else
					s[-1] = 0;
				*last = s;
				return (tok);
			}
		} while (sc != 0);
8f634ba4:	e3530000 	cmp	r3, #0
8f634ba8:	0afffffa 	beq	8f634b98 <strtok_r+0x54>
			if ((sc = *spanp++) == c) {
8f634bac:	e4dc3001 	ldrb	r3, [r12], #1
8f634bb0:	e15e0003 	cmp	r14, r3
8f634bb4:	1afffffa 	bne	8f634ba4 <strtok_r+0x60>
				if (c == 0)
8f634bb8:	e35e0000 	cmp	r14, #0
					s[-1] = 0;
8f634bbc:	13a03000 	movne	r3, #0
					s = NULL;
8f634bc0:	01a0400e 	moveq	r4, r14
					s[-1] = 0;
8f634bc4:	15443001 	strbne	r3, [r4, #-1]
				*last = s;
8f634bc8:	e5824000 	str	r4, [r2]
	}
	/* NOTREACHED */
}
8f634bcc:	e59f3034 	ldr	r3, [pc, #52]	; 8f634c08 <strtok_r+0xc4>
8f634bd0:	e5932000 	ldr	r2, [r3]
8f634bd4:	e59d3004 	ldr	r3, [r13, #4]
8f634bd8:	e0332002 	eors	r2, r3, r2
8f634bdc:	e3a03000 	mov	r3, #0
8f634be0:	1a000007 	bne	8f634c04 <strtok_r+0xc0>
8f634be4:	e28dd008 	add	r13, r13, #8
8f634be8:	e8bd8010 	pop	{r4, r15}
8f634bec:	e1a00004 	mov	r0, r4
8f634bf0:	eaffffdb 	b	8f634b64 <strtok_r+0x20>
	if (s == NULL && (s = *last) == NULL)
8f634bf4:	e5920000 	ldr	r0, [r2]
8f634bf8:	e3500000 	cmp	r0, #0
8f634bfc:	1affffd8 	bne	8f634b64 <strtok_r+0x20>
8f634c00:	eafffff1 	b	8f634bcc <strtok_r+0x88>
}
8f634c04:	ebfff7ed 	bl	8f632bc0 <__stack_chk_fail>
8f634c08:	8f74221c 	.word	0x8f74221c

8f634c0c <fdt_check_header>:

#include "libfdt_internal.h"

int fdt_check_header(const void *fdt)
{
	if (fdt_magic(fdt) == FDT_MAGIC) {
8f634c0c:	e5902000 	ldr	r2, [r0]
8f634c10:	e30f1eed 	movw	r1, #65261	; 0xfeed
{
8f634c14:	e59f30ec 	ldr	r3, [pc, #236]	; 8f634d08 <fdt_check_header+0xfc>
	if (fdt_magic(fdt) == FDT_MAGIC) {
8f634c18:	e34d100d 	movt	r1, #53261	; 0xd00d
{
8f634c1c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f634c20:	e24dd00c 	sub	r13, r13, #12
8f634c24:	e5933000 	ldr	r3, [r3]
8f634c28:	e58d3004 	str	r3, [r13, #4]
8f634c2c:	e3a03000 	mov	r3, #0
8f634c30:	e7e7e452 	ubfx	r14, r2, #8, #8
8f634c34:	e1a03c22 	lsr	r3, r2, #24
8f634c38:	e7e7c852 	ubfx	r12, r2, #16, #8
8f634c3c:	e1833c02 	orr	r3, r3, r2, lsl #24
8f634c40:	e183380e 	orr	r3, r3, r14, lsl #16
8f634c44:	e183340c 	orr	r3, r3, r12, lsl #8
	if (fdt_magic(fdt) == FDT_MAGIC) {
8f634c48:	e1530001 	cmp	r3, r1
8f634c4c:	0a000014 	beq	8f634ca4 <fdt_check_header+0x98>
		/* Complete tree */
		if (fdt_version(fdt) < FDT_FIRST_SUPPORTED_VERSION)
			return -FDT_ERR_BADVERSION;
		if (fdt_last_comp_version(fdt) > FDT_LAST_SUPPORTED_VERSION)
			return -FDT_ERR_BADVERSION;
	} else if (fdt_magic(fdt) == FDT_SW_MAGIC) {
8f634c50:	e3002112 	movw	r2, #274	; 0x112
8f634c54:	e3422ff2 	movt	r2, #12274	; 0x2ff2
8f634c58:	e1530002 	cmp	r3, r2
8f634c5c:	1a000024 	bne	8f634cf4 <fdt_check_header+0xe8>
		/* Unfinished sequential-write blob */
		if (fdt_size_dt_struct(fdt) == 0)
8f634c60:	e5902024 	ldr	r2, [r0, #36]	; 0x24
8f634c64:	e7e70452 	ubfx	r0, r2, #8, #8
8f634c68:	e7e71852 	ubfx	r1, r2, #16, #8
8f634c6c:	e1a03c22 	lsr	r3, r2, #24
8f634c70:	e1833c02 	orr	r3, r3, r2, lsl #24
8f634c74:	e1833800 	orr	r3, r3, r0, lsl #16
			return -FDT_ERR_BADSTATE;
8f634c78:	e1933401 	orrs	r3, r3, r1, lsl #8
8f634c7c:	13a00000 	movne	r0, #0
8f634c80:	03e00006 	mvneq	r0, #6
	} else {
		return -FDT_ERR_BADMAGIC;
	}
	return 0;
}
8f634c84:	e59f307c 	ldr	r3, [pc, #124]	; 8f634d08 <fdt_check_header+0xfc>
8f634c88:	e5932000 	ldr	r2, [r3]
8f634c8c:	e59d3004 	ldr	r3, [r13, #4]
8f634c90:	e0332002 	eors	r2, r3, r2
8f634c94:	e3a03000 	mov	r3, #0
8f634c98:	1a000019 	bne	8f634d04 <fdt_check_header+0xf8>
8f634c9c:	e28dd00c 	add	r13, r13, #12
8f634ca0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		if (fdt_version(fdt) < FDT_FIRST_SUPPORTED_VERSION)
8f634ca4:	e5902014 	ldr	r2, [r0, #20]
8f634ca8:	e7e7c452 	ubfx	r12, r2, #8, #8
8f634cac:	e7e71852 	ubfx	r1, r2, #16, #8
8f634cb0:	e1a03c22 	lsr	r3, r2, #24
8f634cb4:	e1833c02 	orr	r3, r3, r2, lsl #24
8f634cb8:	e183380c 	orr	r3, r3, r12, lsl #16
8f634cbc:	e1833401 	orr	r3, r3, r1, lsl #8
8f634cc0:	e353000f 	cmp	r3, #15
8f634cc4:	9a00000c 	bls	8f634cfc <fdt_check_header+0xf0>
		if (fdt_last_comp_version(fdt) > FDT_LAST_SUPPORTED_VERSION)
8f634cc8:	e5902018 	ldr	r2, [r0, #24]
8f634ccc:	e7e70452 	ubfx	r0, r2, #8, #8
8f634cd0:	e7e71852 	ubfx	r1, r2, #16, #8
8f634cd4:	e1a03c22 	lsr	r3, r2, #24
8f634cd8:	e1833c02 	orr	r3, r3, r2, lsl #24
8f634cdc:	e1833800 	orr	r3, r3, r0, lsl #16
8f634ce0:	e1833401 	orr	r3, r3, r1, lsl #8
			return -FDT_ERR_BADVERSION;
8f634ce4:	e3530012 	cmp	r3, #18
8f634ce8:	33a00000 	movcc	r0, #0
8f634cec:	23e00009 	mvncs	r0, #9
8f634cf0:	eaffffe3 	b	8f634c84 <fdt_check_header+0x78>
		return -FDT_ERR_BADMAGIC;
8f634cf4:	e3e00008 	mvn	r0, #8
8f634cf8:	eaffffe1 	b	8f634c84 <fdt_check_header+0x78>
			return -FDT_ERR_BADVERSION;
8f634cfc:	e3e00009 	mvn	r0, #9
8f634d00:	eaffffdf 	b	8f634c84 <fdt_check_header+0x78>
}
8f634d04:	ebfff7ad 	bl	8f632bc0 <__stack_chk_fail>
8f634d08:	8f74221c 	.word	0x8f74221c

8f634d0c <fdt_offset_ptr>:

const void *fdt_offset_ptr(const void *fdt, int offset, unsigned int len)
{
	const char *p;

	if (fdt_version(fdt) >= 0x11)
8f634d0c:	e590c014 	ldr	r12, [r0, #20]
{
8f634d10:	e59f30b8 	ldr	r3, [pc, #184]	; 8f634dd0 <fdt_offset_ptr+0xc4>
8f634d14:	e92d4030 	push	{r4, r5, r14}
8f634d18:	e24dd00c 	sub	r13, r13, #12
8f634d1c:	e7e7e45c 	ubfx	r14, r12, #8, #8
8f634d20:	e5933000 	ldr	r3, [r3]
8f634d24:	e58d3004 	str	r3, [r13, #4]
8f634d28:	e3a03000 	mov	r3, #0
8f634d2c:	e1a03c2c 	lsr	r3, r12, #24
8f634d30:	e1833c0c 	orr	r3, r3, r12, lsl #24
8f634d34:	e7e7c85c 	ubfx	r12, r12, #16, #8
8f634d38:	e183380e 	orr	r3, r3, r14, lsl #16
8f634d3c:	e183340c 	orr	r3, r3, r12, lsl #8
	if (fdt_version(fdt) >= 0x11)
8f634d40:	e3530010 	cmp	r3, #16
8f634d44:	9a00000b 	bls	8f634d78 <fdt_offset_ptr+0x6c>
		if (((int)(offset + len) < offset)
8f634d48:	e081e002 	add	r14, r1, r2
8f634d4c:	e15e0001 	cmp	r14, r1
8f634d50:	ba00001b 	blt	8f634dc4 <fdt_offset_ptr+0xb8>
		    || ((offset + len) > fdt_size_dt_struct(fdt)))
8f634d54:	e590c024 	ldr	r12, [r0, #36]	; 0x24
8f634d58:	e7e7545c 	ubfx	r5, r12, #8, #8
8f634d5c:	e7e7485c 	ubfx	r4, r12, #16, #8
8f634d60:	e1a03c2c 	lsr	r3, r12, #24
8f634d64:	e1833c0c 	orr	r3, r3, r12, lsl #24
8f634d68:	e1833805 	orr	r3, r3, r5, lsl #16
8f634d6c:	e1833404 	orr	r3, r3, r4, lsl #8
8f634d70:	e15e0003 	cmp	r14, r3
8f634d74:	8a000012 	bhi	8f634dc4 <fdt_offset_ptr+0xb8>
const char *_fdt_find_string(const char *strtab, int tabsize, const char *s);
int _fdt_node_end_offset(void *fdt, int nodeoffset);

static inline const void *_fdt_offset_ptr(const void *fdt, int offset)
{
	return (const char *)fdt + fdt_off_dt_struct(fdt) + offset;
8f634d78:	e590c008 	ldr	r12, [r0, #8]
8f634d7c:	e7e7e45c 	ubfx	r14, r12, #8, #8
8f634d80:	e1a03c2c 	lsr	r3, r12, #24
8f634d84:	e1833c0c 	orr	r3, r3, r12, lsl #24
8f634d88:	e7e7c85c 	ubfx	r12, r12, #16, #8
8f634d8c:	e183380e 	orr	r3, r3, r14, lsl #16
8f634d90:	e183340c 	orr	r3, r3, r12, lsl #8
8f634d94:	e0831001 	add	r1, r3, r1
8f634d98:	e0800001 	add	r0, r0, r1
			return NULL;

	p = _fdt_offset_ptr(fdt, offset);

	if (p + len < p)
		return NULL;
8f634d9c:	e1700002 	cmn	r0, r2
8f634da0:	23a00000 	movcs	r0, #0
	return p;
}
8f634da4:	e59f3024 	ldr	r3, [pc, #36]	; 8f634dd0 <fdt_offset_ptr+0xc4>
8f634da8:	e5932000 	ldr	r2, [r3]
8f634dac:	e59d3004 	ldr	r3, [r13, #4]
8f634db0:	e0332002 	eors	r2, r3, r2
8f634db4:	e3a03000 	mov	r3, #0
8f634db8:	1a000003 	bne	8f634dcc <fdt_offset_ptr+0xc0>
8f634dbc:	e28dd00c 	add	r13, r13, #12
8f634dc0:	e8bd8030 	pop	{r4, r5, r15}
		return NULL;
8f634dc4:	e3a00000 	mov	r0, #0
8f634dc8:	eafffff5 	b	8f634da4 <fdt_offset_ptr+0x98>
}
8f634dcc:	ebfff77b 	bl	8f632bc0 <__stack_chk_fail>
8f634dd0:	8f74221c 	.word	0x8f74221c

8f634dd4 <fdt_next_tag>:

uint32_t fdt_next_tag(const void *fdt, int startoffset, int *nextoffset)
{
8f634dd4:	e59f31c0 	ldr	r3, [pc, #448]	; 8f634f9c <fdt_next_tag+0x1c8>
8f634dd8:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f634ddc:	e24dd008 	sub	r13, r13, #8
8f634de0:	e5933000 	ldr	r3, [r3]
8f634de4:	e58d3004 	str	r3, [r13, #4]
8f634de8:	e3a03000 	mov	r3, #0
8f634dec:	e1a07002 	mov	r7, r2
	const uint32_t *tagp, *lenp;
	uint32_t tag;
	int offset = startoffset;
	const char *p;

	*nextoffset = -FDT_ERR_TRUNCATED;
8f634df0:	e3e03007 	mvn	r3, #7
8f634df4:	e5823000 	str	r3, [r2]
	tagp = fdt_offset_ptr(fdt, offset, FDT_TAGSIZE);
8f634df8:	e3a02004 	mov	r2, #4
{
8f634dfc:	e1a05000 	mov	r5, r0
8f634e00:	e1a08001 	mov	r8, r1
	tagp = fdt_offset_ptr(fdt, offset, FDT_TAGSIZE);
8f634e04:	ebffffc0 	bl	8f634d0c <fdt_offset_ptr>
	if (!tagp)
8f634e08:	e3500000 	cmp	r0, #0
8f634e0c:	0a00003d 	beq	8f634f08 <fdt_next_tag+0x134>
		return FDT_END; /* premature end */
	tag = fdt32_to_cpu(*tagp);
8f634e10:	e5903000 	ldr	r3, [r0]
	offset += FDT_TAGSIZE;
8f634e14:	e2881004 	add	r1, r8, #4
8f634e18:	e7e72453 	ubfx	r2, r3, #8, #8
8f634e1c:	e1a04001 	mov	r4, r1
8f634e20:	e1a06c23 	lsr	r6, r3, #24
8f634e24:	e1866c03 	orr	r6, r6, r3, lsl #24
8f634e28:	e7e73853 	ubfx	r3, r3, #16, #8
8f634e2c:	e1866802 	orr	r6, r6, r2, lsl #16

	*nextoffset = -FDT_ERR_BADSTRUCTURE;
8f634e30:	e3e0200a 	mvn	r2, #10
8f634e34:	e1866403 	orr	r6, r6, r3, lsl #8
8f634e38:	e5872000 	str	r2, [r7]
	switch (tag) {
8f634e3c:	e2463001 	sub	r3, r6, #1
8f634e40:	e3530008 	cmp	r3, #8
8f634e44:	979ff103 	ldrls	r15, [r15, r3, lsl #2]
8f634e48:	ea00002e 	b	8f634f08 <fdt_next_tag+0x134>
8f634e4c:	8f634e70 	.word	0x8f634e70
8f634e50:	8f634f30 	.word	0x8f634f30
8f634e54:	8f634f58 	.word	0x8f634f58
8f634e58:	8f634f30 	.word	0x8f634f30
8f634e5c:	8f634f08 	.word	0x8f634f08
8f634e60:	8f634f08 	.word	0x8f634f08
8f634e64:	8f634f08 	.word	0x8f634f08
8f634e68:	8f634f08 	.word	0x8f634f08
8f634e6c:	8f634f30 	.word	0x8f634f30
	if (fdt_version(fdt) >= 0x11)
8f634e70:	e5953014 	ldr	r3, [r5, #20]
8f634e74:	e7e7c453 	ubfx	r12, r3, #8, #8
8f634e78:	e7e72853 	ubfx	r2, r3, #16, #8
8f634e7c:	e1a00c23 	lsr	r0, r3, #24
8f634e80:	e1800c03 	orr	r0, r0, r3, lsl #24
8f634e84:	e180080c 	orr	r0, r0, r12, lsl #16
8f634e88:	e1800402 	orr	r0, r0, r2, lsl #8
8f634e8c:	ea000003 	b	8f634ea0 <fdt_next_tag+0xcc>
	case FDT_BEGIN_NODE:
		/* skip name */
		do {
			p = fdt_offset_ptr(fdt, offset++, 1);
		} while (p && (*p != '\0'));
8f634e90:	e7d53003 	ldrb	r3, [r5, r3]
8f634e94:	e2811001 	add	r1, r1, #1
8f634e98:	e3530000 	cmp	r3, #0
8f634e9c:	0a00003b 	beq	8f634f90 <fdt_next_tag+0x1bc>
	if (fdt_version(fdt) >= 0x11)
8f634ea0:	e3500010 	cmp	r0, #16
			p = fdt_offset_ptr(fdt, offset++, 1);
8f634ea4:	e2844001 	add	r4, r4, #1
	if (fdt_version(fdt) >= 0x11)
8f634ea8:	9a00000a 	bls	8f634ed8 <fdt_next_tag+0x104>
		if (((int)(offset + len) < offset)
8f634eac:	e1510004 	cmp	r1, r4
8f634eb0:	ca000014 	bgt	8f634f08 <fdt_next_tag+0x134>
		    || ((offset + len) > fdt_size_dt_struct(fdt)))
8f634eb4:	e5952024 	ldr	r2, [r5, #36]	; 0x24
8f634eb8:	e7e7e452 	ubfx	r14, r2, #8, #8
8f634ebc:	e7e7c852 	ubfx	r12, r2, #16, #8
8f634ec0:	e1a03c22 	lsr	r3, r2, #24
8f634ec4:	e1833c02 	orr	r3, r3, r2, lsl #24
8f634ec8:	e183380e 	orr	r3, r3, r14, lsl #16
8f634ecc:	e183340c 	orr	r3, r3, r12, lsl #8
8f634ed0:	e1540003 	cmp	r4, r3
8f634ed4:	8a00000b 	bhi	8f634f08 <fdt_next_tag+0x134>
8f634ed8:	e5952008 	ldr	r2, [r5, #8]
8f634edc:	e7e7c452 	ubfx	r12, r2, #8, #8
8f634ee0:	e1a03c22 	lsr	r3, r2, #24
8f634ee4:	e1833c02 	orr	r3, r3, r2, lsl #24
8f634ee8:	e7e72852 	ubfx	r2, r2, #16, #8
8f634eec:	e183380c 	orr	r3, r3, r12, lsl #16
8f634ef0:	e1833402 	orr	r3, r3, r2, lsl #8
8f634ef4:	e0833001 	add	r3, r3, r1
8f634ef8:	e0852003 	add	r2, r5, r3
		} while (p && (*p != '\0'));
8f634efc:	e3520000 	cmp	r2, #0
8f634f00:	13720001 	cmnne	r2, #1
8f634f04:	3affffe1 	bcc	8f634e90 <fdt_next_tag+0xbc>
	switch (tag) {
8f634f08:	e3a06009 	mov	r6, #9
	if (!fdt_offset_ptr(fdt, startoffset, offset - startoffset))
		return FDT_END; /* premature end */

	*nextoffset = FDT_TAGALIGN(offset);
	return tag;
}
8f634f0c:	e59f3088 	ldr	r3, [pc, #136]	; 8f634f9c <fdt_next_tag+0x1c8>
8f634f10:	e5932000 	ldr	r2, [r3]
8f634f14:	e59d3004 	ldr	r3, [r13, #4]
8f634f18:	e0332002 	eors	r2, r3, r2
8f634f1c:	e3a03000 	mov	r3, #0
8f634f20:	1a00001c 	bne	8f634f98 <fdt_next_tag+0x1c4>
8f634f24:	e1a00006 	mov	r0, r6
8f634f28:	e28dd008 	add	r13, r13, #8
8f634f2c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
	switch (tag) {
8f634f30:	e3a02004 	mov	r2, #4
	if (!fdt_offset_ptr(fdt, startoffset, offset - startoffset))
8f634f34:	e1a01008 	mov	r1, r8
8f634f38:	e1a00005 	mov	r0, r5
8f634f3c:	ebffff72 	bl	8f634d0c <fdt_offset_ptr>
8f634f40:	e3500000 	cmp	r0, #0
8f634f44:	0affffef 	beq	8f634f08 <fdt_next_tag+0x134>
	*nextoffset = FDT_TAGALIGN(offset);
8f634f48:	e2844003 	add	r4, r4, #3
8f634f4c:	e3c44003 	bic	r4, r4, #3
8f634f50:	e5874000 	str	r4, [r7]
	return tag;
8f634f54:	eaffffec 	b	8f634f0c <fdt_next_tag+0x138>
		lenp = fdt_offset_ptr(fdt, offset, sizeof(*lenp));
8f634f58:	e3a02004 	mov	r2, #4
8f634f5c:	e1a00005 	mov	r0, r5
8f634f60:	ebffff69 	bl	8f634d0c <fdt_offset_ptr>
		if (!lenp)
8f634f64:	e3500000 	cmp	r0, #0
8f634f68:	0affffe6 	beq	8f634f08 <fdt_next_tag+0x134>
			+ fdt32_to_cpu(*lenp);
8f634f6c:	e5902000 	ldr	r2, [r0]
		offset += sizeof(struct fdt_property) - FDT_TAGSIZE
8f634f70:	e288400c 	add	r4, r8, #12
8f634f74:	e7e70452 	ubfx	r0, r2, #8, #8
8f634f78:	e7e71852 	ubfx	r1, r2, #16, #8
8f634f7c:	e1a03c22 	lsr	r3, r2, #24
8f634f80:	e1833c02 	orr	r3, r3, r2, lsl #24
8f634f84:	e1833800 	orr	r3, r3, r0, lsl #16
8f634f88:	e1833401 	orr	r3, r3, r1, lsl #8
8f634f8c:	e0834004 	add	r4, r3, r4
	if (!fdt_offset_ptr(fdt, startoffset, offset - startoffset))
8f634f90:	e0442008 	sub	r2, r4, r8
		break;
8f634f94:	eaffffe6 	b	8f634f34 <fdt_next_tag+0x160>
}
8f634f98:	ebfff708 	bl	8f632bc0 <__stack_chk_fail>
8f634f9c:	8f74221c 	.word	0x8f74221c

8f634fa0 <_fdt_check_node_offset>:

int _fdt_check_node_offset(const void *fdt, int offset)
{
8f634fa0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	if ((offset < 0) || (offset % FDT_TAGSIZE)
8f634fa4:	e2513000 	subs	r3, r1, #0
{
8f634fa8:	e24dd014 	sub	r13, r13, #20
8f634fac:	e59f2058 	ldr	r2, [pc, #88]	; 8f63500c <_fdt_check_node_offset+0x6c>
8f634fb0:	e58d1004 	str	r1, [r13, #4]
8f634fb4:	e5922000 	ldr	r2, [r2]
8f634fb8:	e58d200c 	str	r2, [r13, #12]
8f634fbc:	e3a02000 	mov	r2, #0
	if ((offset < 0) || (offset % FDT_TAGSIZE)
8f634fc0:	ba00000e 	blt	8f635000 <_fdt_check_node_offset+0x60>
8f634fc4:	e3130003 	tst	r3, #3
8f634fc8:	1a00000c 	bne	8f635000 <_fdt_check_node_offset+0x60>
	    || (fdt_next_tag(fdt, offset, &offset) != FDT_BEGIN_NODE))
8f634fcc:	e28d2004 	add	r2, r13, #4
8f634fd0:	ebffff7f 	bl	8f634dd4 <fdt_next_tag>
8f634fd4:	e3500001 	cmp	r0, #1
8f634fd8:	1a000008 	bne	8f635000 <_fdt_check_node_offset+0x60>
		return -FDT_ERR_BADOFFSET;

	return offset;
8f634fdc:	e59d0004 	ldr	r0, [r13, #4]
}
8f634fe0:	e59f3024 	ldr	r3, [pc, #36]	; 8f63500c <_fdt_check_node_offset+0x6c>
8f634fe4:	e5932000 	ldr	r2, [r3]
8f634fe8:	e59d300c 	ldr	r3, [r13, #12]
8f634fec:	e0332002 	eors	r2, r3, r2
8f634ff0:	e3a03000 	mov	r3, #0
8f634ff4:	1a000003 	bne	8f635008 <_fdt_check_node_offset+0x68>
8f634ff8:	e28dd014 	add	r13, r13, #20
8f634ffc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		return -FDT_ERR_BADOFFSET;
8f635000:	e3e00003 	mvn	r0, #3
8f635004:	eafffff5 	b	8f634fe0 <_fdt_check_node_offset+0x40>
}
8f635008:	ebfff6ec 	bl	8f632bc0 <__stack_chk_fail>
8f63500c:	8f74221c 	.word	0x8f74221c

8f635010 <_fdt_check_prop_offset>:

int _fdt_check_prop_offset(const void *fdt, int offset)
{
8f635010:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	if ((offset < 0) || (offset % FDT_TAGSIZE)
8f635014:	e2513000 	subs	r3, r1, #0
{
8f635018:	e24dd014 	sub	r13, r13, #20
8f63501c:	e59f2058 	ldr	r2, [pc, #88]	; 8f63507c <_fdt_check_prop_offset+0x6c>
8f635020:	e58d1004 	str	r1, [r13, #4]
8f635024:	e5922000 	ldr	r2, [r2]
8f635028:	e58d200c 	str	r2, [r13, #12]
8f63502c:	e3a02000 	mov	r2, #0
	if ((offset < 0) || (offset % FDT_TAGSIZE)
8f635030:	ba00000e 	blt	8f635070 <_fdt_check_prop_offset+0x60>
8f635034:	e3130003 	tst	r3, #3
8f635038:	1a00000c 	bne	8f635070 <_fdt_check_prop_offset+0x60>
	    || (fdt_next_tag(fdt, offset, &offset) != FDT_PROP))
8f63503c:	e28d2004 	add	r2, r13, #4
8f635040:	ebffff63 	bl	8f634dd4 <fdt_next_tag>
8f635044:	e3500003 	cmp	r0, #3
8f635048:	1a000008 	bne	8f635070 <_fdt_check_prop_offset+0x60>
		return -FDT_ERR_BADOFFSET;

	return offset;
8f63504c:	e59d0004 	ldr	r0, [r13, #4]
}
8f635050:	e59f3024 	ldr	r3, [pc, #36]	; 8f63507c <_fdt_check_prop_offset+0x6c>
8f635054:	e5932000 	ldr	r2, [r3]
8f635058:	e59d300c 	ldr	r3, [r13, #12]
8f63505c:	e0332002 	eors	r2, r3, r2
8f635060:	e3a03000 	mov	r3, #0
8f635064:	1a000003 	bne	8f635078 <_fdt_check_prop_offset+0x68>
8f635068:	e28dd014 	add	r13, r13, #20
8f63506c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		return -FDT_ERR_BADOFFSET;
8f635070:	e3e00003 	mvn	r0, #3
8f635074:	eafffff5 	b	8f635050 <_fdt_check_prop_offset+0x40>
}
8f635078:	ebfff6d0 	bl	8f632bc0 <__stack_chk_fail>
8f63507c:	8f74221c 	.word	0x8f74221c

8f635080 <fdt_next_node>:

int fdt_next_node(const void *fdt, int offset, int *depth)
{
8f635080:	e92d4070 	push	{r4, r5, r6, r14}
	int nextoffset = 0;
	uint32_t tag;

	if (offset >= 0)
8f635084:	e2513000 	subs	r3, r1, #0
{
8f635088:	e24dd010 	sub	r13, r13, #16
8f63508c:	e1a05002 	mov	r5, r2
8f635090:	e59f2100 	ldr	r2, [pc, #256]	; 8f635198 <fdt_next_node+0x118>
	int nextoffset = 0;
8f635094:	e3a04000 	mov	r4, #0
{
8f635098:	e1a06000 	mov	r6, r0
8f63509c:	e5922000 	ldr	r2, [r2]
8f6350a0:	e58d200c 	str	r2, [r13, #12]
8f6350a4:	e3a02000 	mov	r2, #0
	int nextoffset = 0;
8f6350a8:	e58d4004 	str	r4, [r13, #4]
	if (offset >= 0)
8f6350ac:	aa000028 	bge	8f635154 <fdt_next_node+0xd4>
		if ((nextoffset = _fdt_check_node_offset(fdt, offset)) < 0)
			return nextoffset;

	do {
		offset = nextoffset;
		tag = fdt_next_tag(fdt, offset, &nextoffset);
8f6350b0:	e28d2004 	add	r2, r13, #4
8f6350b4:	e1a01004 	mov	r1, r4
8f6350b8:	e1a00006 	mov	r0, r6
8f6350bc:	ebffff44 	bl	8f634dd4 <fdt_next_tag>

		switch (tag) {
8f6350c0:	e3500002 	cmp	r0, #2
8f6350c4:	0a000005 	beq	8f6350e0 <fdt_next_node+0x60>
8f6350c8:	e3500009 	cmp	r0, #9
8f6350cc:	0a000019 	beq	8f635138 <fdt_next_node+0xb8>
8f6350d0:	e3500001 	cmp	r0, #1
8f6350d4:	0a00000a 	beq	8f635104 <fdt_next_node+0x84>
		offset = nextoffset;
8f6350d8:	e59d4004 	ldr	r4, [r13, #4]
8f6350dc:	eafffff3 	b	8f6350b0 <fdt_next_node+0x30>
			if (depth)
				(*depth)++;
			break;

		case FDT_END_NODE:
			if (depth && ((--(*depth)) < 0))
8f6350e0:	e3550000 	cmp	r5, #0
8f6350e4:	0afffffb 	beq	8f6350d8 <fdt_next_node+0x58>
8f6350e8:	e5953000 	ldr	r3, [r5]
8f6350ec:	e2433001 	sub	r3, r3, #1
8f6350f0:	e5853000 	str	r3, [r5]
8f6350f4:	e3530000 	cmp	r3, #0
8f6350f8:	aafffff6 	bge	8f6350d8 <fdt_next_node+0x58>
				return nextoffset;
8f6350fc:	e59d4004 	ldr	r4, [r13, #4]
8f635100:	ea000003 	b	8f635114 <fdt_next_node+0x94>
			if (depth)
8f635104:	e3550000 	cmp	r5, #0
				(*depth)++;
8f635108:	15953000 	ldrne	r3, [r5]
8f63510c:	12833001 	addne	r3, r3, #1
8f635110:	15853000 	strne	r3, [r5]
				return nextoffset;
		}
	} while (tag != FDT_BEGIN_NODE);

	return offset;
}
8f635114:	e59f307c 	ldr	r3, [pc, #124]	; 8f635198 <fdt_next_node+0x118>
8f635118:	e5932000 	ldr	r2, [r3]
8f63511c:	e59d300c 	ldr	r3, [r13, #12]
8f635120:	e0332002 	eors	r2, r3, r2
8f635124:	e3a03000 	mov	r3, #0
8f635128:	1a000019 	bne	8f635194 <fdt_next_node+0x114>
8f63512c:	e1a00004 	mov	r0, r4
8f635130:	e28dd010 	add	r13, r13, #16
8f635134:	e8bd8070 	pop	{r4, r5, r6, r15}
			if ((nextoffset >= 0)
8f635138:	e59d4004 	ldr	r4, [r13, #4]
8f63513c:	e3540000 	cmp	r4, #0
8f635140:	aa000011 	bge	8f63518c <fdt_next_node+0x10c>
				return -FDT_ERR_NOTFOUND;
8f635144:	e3550000 	cmp	r5, #0
8f635148:	03740008 	cmneq	r4, #8
8f63514c:	03e04000 	mvneq	r4, #0
8f635150:	eaffffef 	b	8f635114 <fdt_next_node+0x94>
	if ((offset < 0) || (offset % FDT_TAGSIZE)
8f635154:	e3130003 	tst	r3, #3
8f635158:	e58d3008 	str	r3, [r13, #8]
8f63515c:	1a000008 	bne	8f635184 <fdt_next_node+0x104>
	    || (fdt_next_tag(fdt, offset, &offset) != FDT_BEGIN_NODE))
8f635160:	e28d2008 	add	r2, r13, #8
8f635164:	ebffff1a 	bl	8f634dd4 <fdt_next_tag>
8f635168:	e3500001 	cmp	r0, #1
8f63516c:	1a000004 	bne	8f635184 <fdt_next_node+0x104>
	return offset;
8f635170:	e59d4008 	ldr	r4, [r13, #8]
		if ((nextoffset = _fdt_check_node_offset(fdt, offset)) < 0)
8f635174:	e3540000 	cmp	r4, #0
8f635178:	e58d4004 	str	r4, [r13, #4]
8f63517c:	aaffffcb 	bge	8f6350b0 <fdt_next_node+0x30>
8f635180:	eaffffe3 	b	8f635114 <fdt_next_node+0x94>
		return -FDT_ERR_BADOFFSET;
8f635184:	e3e04003 	mvn	r4, #3
8f635188:	eaffffe1 	b	8f635114 <fdt_next_node+0x94>
				return -FDT_ERR_NOTFOUND;
8f63518c:	e3e04000 	mvn	r4, #0
8f635190:	eaffffdf 	b	8f635114 <fdt_next_node+0x94>
}
8f635194:	ebfff689 	bl	8f632bc0 <__stack_chk_fail>
8f635198:	8f74221c 	.word	0x8f74221c

8f63519c <_fdt_find_string>:

const char *_fdt_find_string(const char *strtab, int tabsize, const char *s)
{
8f63519c:	e59f308c 	ldr	r3, [pc, #140]	; 8f635230 <_fdt_find_string+0x94>
8f6351a0:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f6351a4:	e1a04000 	mov	r4, r0
8f6351a8:	e24dd00c 	sub	r13, r13, #12
	int len = strlen(s) + 1;
8f6351ac:	e1a00002 	mov	r0, r2
{
8f6351b0:	e1a05001 	mov	r5, r1
8f6351b4:	e5933000 	ldr	r3, [r3]
8f6351b8:	e58d3004 	str	r3, [r13, #4]
8f6351bc:	e3a03000 	mov	r3, #0
8f6351c0:	e1a06002 	mov	r6, r2
	int len = strlen(s) + 1;
8f6351c4:	ebfffd8f 	bl	8f634808 <strlen>
8f6351c8:	e2807001 	add	r7, r0, #1
	const char *last = strtab + tabsize - len;
8f6351cc:	e0455007 	sub	r5, r5, r7
	const char *p;

	for (p = strtab; p <= last; p++)
8f6351d0:	e0945005 	adds	r5, r4, r5
8f6351d4:	3a000003 	bcc	8f6351e8 <_fdt_find_string+0x4c>
8f6351d8:	ea00000a 	b	8f635208 <_fdt_find_string+0x6c>
8f6351dc:	e2844001 	add	r4, r4, #1
8f6351e0:	e1550004 	cmp	r5, r4
8f6351e4:	3a000007 	bcc	8f635208 <_fdt_find_string+0x6c>
		if (memcmp(p, s, len) == 0)
8f6351e8:	e1a02007 	mov	r2, r7
8f6351ec:	e1a01006 	mov	r1, r6
8f6351f0:	e1a00004 	mov	r0, r4
8f6351f4:	ebfffc77 	bl	8f6343d8 <memcmp>
8f6351f8:	e3500000 	cmp	r0, #0
8f6351fc:	1afffff6 	bne	8f6351dc <_fdt_find_string+0x40>
8f635200:	e1a00004 	mov	r0, r4
8f635204:	ea000000 	b	8f63520c <_fdt_find_string+0x70>
			return p;
	return NULL;
8f635208:	e3a00000 	mov	r0, #0
}
8f63520c:	e59f301c 	ldr	r3, [pc, #28]	; 8f635230 <_fdt_find_string+0x94>
8f635210:	e5932000 	ldr	r2, [r3]
8f635214:	e59d3004 	ldr	r3, [r13, #4]
8f635218:	e0332002 	eors	r2, r3, r2
8f63521c:	e3a03000 	mov	r3, #0
8f635220:	1a000001 	bne	8f63522c <_fdt_find_string+0x90>
8f635224:	e28dd00c 	add	r13, r13, #12
8f635228:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
8f63522c:	ebfff663 	bl	8f632bc0 <__stack_chk_fail>
8f635230:	8f74221c 	.word	0x8f74221c

8f635234 <fdt_move>:

int fdt_move(const void *fdt, void *buf, int bufsize)
{
8f635234:	e59f3088 	ldr	r3, [pc, #136]	; 8f6352c4 <fdt_move+0x90>
8f635238:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f63523c:	e24dd00c 	sub	r13, r13, #12
8f635240:	e5933000 	ldr	r3, [r3]
8f635244:	e58d3004 	str	r3, [r13, #4]
8f635248:	e3a03000 	mov	r3, #0
8f63524c:	e1a07000 	mov	r7, r0
8f635250:	e1a06001 	mov	r6, r1
8f635254:	e1a05002 	mov	r5, r2
	FDT_CHECK_HEADER(fdt);
8f635258:	ebfffe6b 	bl	8f634c0c <fdt_check_header>
8f63525c:	e2504000 	subs	r4, r0, #0
8f635260:	1a00000b 	bne	8f635294 <fdt_move+0x60>

	if (fdt_totalsize(fdt) > (uint32_t)bufsize)
8f635264:	e597c004 	ldr	r12, [r7, #4]
8f635268:	e7e7145c 	ubfx	r1, r12, #8, #8
8f63526c:	e7e7285c 	ubfx	r2, r12, #16, #8
8f635270:	e1a03c2c 	lsr	r3, r12, #24
8f635274:	e1833c0c 	orr	r3, r3, r12, lsl #24
8f635278:	e1833801 	orr	r3, r3, r1, lsl #16
8f63527c:	e1832402 	orr	r2, r3, r2, lsl #8
8f635280:	e1550002 	cmp	r5, r2
8f635284:	3a00000b 	bcc	8f6352b8 <fdt_move+0x84>
		return -FDT_ERR_NOSPACE;

	memmove(buf, fdt, fdt_totalsize(fdt));
8f635288:	e1a01007 	mov	r1, r7
8f63528c:	e1a00006 	mov	r0, r6
8f635290:	ebfffbc8 	bl	8f6341b8 <memcpy>
	return 0;
}
8f635294:	e59f3028 	ldr	r3, [pc, #40]	; 8f6352c4 <fdt_move+0x90>
8f635298:	e5932000 	ldr	r2, [r3]
8f63529c:	e59d3004 	ldr	r3, [r13, #4]
8f6352a0:	e0332002 	eors	r2, r3, r2
8f6352a4:	e3a03000 	mov	r3, #0
8f6352a8:	1a000004 	bne	8f6352c0 <fdt_move+0x8c>
8f6352ac:	e1a00004 	mov	r0, r4
8f6352b0:	e28dd00c 	add	r13, r13, #12
8f6352b4:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		return -FDT_ERR_NOSPACE;
8f6352b8:	e3e04002 	mvn	r4, #2
8f6352bc:	eafffff4 	b	8f635294 <fdt_move+0x60>
}
8f6352c0:	ebfff63e 	bl	8f632bc0 <__stack_chk_fail>
8f6352c4:	8f74221c 	.word	0x8f74221c

8f6352c8 <fdt_subnode_offset_namelen.part.0>:
	} while (tag == FDT_NOP);

	return -FDT_ERR_NOTFOUND;
}

int fdt_subnode_offset_namelen(const void *fdt, int offset,
8f6352c8:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
{
	int depth;

	FDT_CHECK_HEADER(fdt);

	for (depth = 0;
8f6352cc:	e2514000 	subs	r4, r1, #0
int fdt_subnode_offset_namelen(const void *fdt, int offset,
8f6352d0:	e24dd00c 	sub	r13, r13, #12
8f6352d4:	e1a06003 	mov	r6, r3
8f6352d8:	e59f30d4 	ldr	r3, [pc, #212]	; 8f6353b4 <fdt_subnode_offset_namelen.part.0+0xec>
	for (depth = 0;
8f6352dc:	e3a01000 	mov	r1, #0
int fdt_subnode_offset_namelen(const void *fdt, int offset,
8f6352e0:	e5933000 	ldr	r3, [r3]
8f6352e4:	e58d3004 	str	r3, [r13, #4]
8f6352e8:	e3a03000 	mov	r3, #0
	for (depth = 0;
8f6352ec:	e58d1000 	str	r1, [r13]
8f6352f0:	ba000022 	blt	8f635380 <fdt_subnode_offset_namelen.part.0+0xb8>
	const char *p = fdt_offset_ptr(fdt, offset + FDT_TAGSIZE, len+1);
8f6352f4:	e2868001 	add	r8, r6, #1
8f6352f8:	e1a05000 	mov	r5, r0
8f6352fc:	e1a07002 	mov	r7, r2
	     (offset >= 0) && (depth >= 0);
	     offset = fdt_next_node(fdt, offset, &depth))
8f635300:	e1a01004 	mov	r1, r4
8f635304:	e1a0200d 	mov	r2, r13
8f635308:	e1a00005 	mov	r0, r5
8f63530c:	ebffff5b 	bl	8f635080 <fdt_next_node>
	     (offset >= 0) && (depth >= 0);
8f635310:	e59dc000 	ldr	r12, [r13]
	for (depth = 0;
8f635314:	e35c0000 	cmp	r12, #0
8f635318:	a3500000 	cmpge	r0, #0
	     offset = fdt_next_node(fdt, offset, &depth))
8f63531c:	e1a04000 	mov	r4, r0
	for (depth = 0;
8f635320:	ba00001f 	blt	8f6353a4 <fdt_subnode_offset_namelen.part.0+0xdc>
		if ((depth == 1)
8f635324:	e35c0001 	cmp	r12, #1
8f635328:	1afffff4 	bne	8f635300 <fdt_subnode_offset_namelen.part.0+0x38>
	const char *p = fdt_offset_ptr(fdt, offset + FDT_TAGSIZE, len+1);
8f63532c:	e2841004 	add	r1, r4, #4
8f635330:	e1a02008 	mov	r2, r8
8f635334:	e1a00005 	mov	r0, r5
8f635338:	ebfffe73 	bl	8f634d0c <fdt_offset_ptr>
	if (! p)
8f63533c:	e2509000 	subs	r9, r0, #0
8f635340:	0affffee 	beq	8f635300 <fdt_subnode_offset_namelen.part.0+0x38>
	if (memcmp(p, s, len) != 0)
8f635344:	e1a02006 	mov	r2, r6
8f635348:	e1a01007 	mov	r1, r7
8f63534c:	ebfffc21 	bl	8f6343d8 <memcmp>
8f635350:	e3500000 	cmp	r0, #0
8f635354:	1affffe9 	bne	8f635300 <fdt_subnode_offset_namelen.part.0+0x38>
	if (p[len] == '\0')
8f635358:	e7d99006 	ldrb	r9, [r9, r6]
8f63535c:	e3590000 	cmp	r9, #0
8f635360:	0a000006 	beq	8f635380 <fdt_subnode_offset_namelen.part.0+0xb8>
	else if (!memchr(s, '@', len) && (p[len] == '@'))
8f635364:	e1a02006 	mov	r2, r6
8f635368:	e3a01040 	mov	r1, #64	; 0x40
8f63536c:	e1a00007 	mov	r0, r7
8f635370:	ebfffbf8 	bl	8f634358 <memchr>
8f635374:	e3590040 	cmp	r9, #64	; 0x40
8f635378:	03500000 	cmpeq	r0, #0
8f63537c:	1affffdf 	bne	8f635300 <fdt_subnode_offset_namelen.part.0+0x38>
			return offset;

	if (depth < 0)
		return -FDT_ERR_NOTFOUND;
	return offset; /* error */
}
8f635380:	e59f302c 	ldr	r3, [pc, #44]	; 8f6353b4 <fdt_subnode_offset_namelen.part.0+0xec>
8f635384:	e5932000 	ldr	r2, [r3]
8f635388:	e59d3004 	ldr	r3, [r13, #4]
8f63538c:	e0332002 	eors	r2, r3, r2
8f635390:	e3a03000 	mov	r3, #0
8f635394:	1a000005 	bne	8f6353b0 <fdt_subnode_offset_namelen.part.0+0xe8>
8f635398:	e1a00004 	mov	r0, r4
8f63539c:	e28dd00c 	add	r13, r13, #12
8f6353a0:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
		return -FDT_ERR_NOTFOUND;
8f6353a4:	e35c0000 	cmp	r12, #0
8f6353a8:	b3e04000 	mvnlt	r4, #0
8f6353ac:	eafffff3 	b	8f635380 <fdt_subnode_offset_namelen.part.0+0xb8>
}
8f6353b0:	ebfff602 	bl	8f632bc0 <__stack_chk_fail>
8f6353b4:	8f74221c 	.word	0x8f74221c

8f6353b8 <fdt_num_mem_rsv>:

static inline const struct fdt_reserve_entry *_fdt_mem_rsv(const void *fdt, int n)
{
	const struct fdt_reserve_entry *rsv_table =
		(const struct fdt_reserve_entry *)
		((const char *)fdt + fdt_off_mem_rsvmap(fdt));
8f6353b8:	e5902010 	ldr	r2, [r0, #16]
{
8f6353bc:	e59f30a4 	ldr	r3, [pc, #164]	; 8f635468 <fdt_num_mem_rsv+0xb0>
8f6353c0:	e92d4030 	push	{r4, r5, r14}
8f6353c4:	e24dd00c 	sub	r13, r13, #12
8f6353c8:	e5933000 	ldr	r3, [r3]
8f6353cc:	e58d3004 	str	r3, [r13, #4]
8f6353d0:	e3a03000 	mov	r3, #0
8f6353d4:	e7e71452 	ubfx	r1, r2, #8, #8
8f6353d8:	e1a03c22 	lsr	r3, r2, #24
8f6353dc:	e7e7e852 	ubfx	r14, r2, #16, #8
8f6353e0:	e1833c02 	orr	r3, r3, r2, lsl #24
	int i = 0;
8f6353e4:	e3a04000 	mov	r4, #0
8f6353e8:	e1833801 	orr	r3, r3, r1, lsl #16
8f6353ec:	e183340e 	orr	r3, r3, r14, lsl #8
8f6353f0:	e080e003 	add	r14, r0, r3
	while (fdt64_to_cpu(_fdt_mem_rsv(fdt, i)->size) != 0)
8f6353f4:	ea000000 	b	8f6353fc <fdt_num_mem_rsv+0x44>
		i++;
8f6353f8:	e2844001 	add	r4, r4, #1
	while (fdt64_to_cpu(_fdt_mem_rsv(fdt, i)->size) != 0)
8f6353fc:	e59ec008 	ldr	r12, [r14, #8]
8f635400:	e28ee010 	add	r14, r14, #16
8f635404:	e51e1004 	ldr	r1, [r14, #-4]
}
#define cpu_to_fdt32(x) fdt32_to_cpu(x)

static inline uint64_t fdt64_to_cpu(uint64_t x)
{
	return (EXTRACT_BYTE(0) << 56) | (EXTRACT_BYTE(1) << 48) | (EXTRACT_BYTE(2) << 40) | (EXTRACT_BYTE(3) << 32)
8f635408:	e7e7345c 	ubfx	r3, r12, #8, #8
8f63540c:	e7e7585c 	ubfx	r5, r12, #16, #8
		| (EXTRACT_BYTE(4) << 24) | (EXTRACT_BYTE(5) << 16) | (EXTRACT_BYTE(6) << 8) | EXTRACT_BYTE(7);
8f635410:	e7e70451 	ubfx	r0, r1, #8, #8
8f635414:	e1a02c01 	lsl	r2, r1, #24
	return (EXTRACT_BYTE(0) << 56) | (EXTRACT_BYTE(1) << 48) | (EXTRACT_BYTE(2) << 40) | (EXTRACT_BYTE(3) << 32)
8f635418:	e1a03803 	lsl	r3, r3, #16
		| (EXTRACT_BYTE(4) << 24) | (EXTRACT_BYTE(5) << 16) | (EXTRACT_BYTE(6) << 8) | EXTRACT_BYTE(7);
8f63541c:	e1822c21 	orr	r2, r2, r1, lsr #24
8f635420:	e1833c0c 	orr	r3, r3, r12, lsl #24
8f635424:	e7e71851 	ubfx	r1, r1, #16, #8
8f635428:	e1833405 	orr	r3, r3, r5, lsl #8
8f63542c:	e1822800 	orr	r2, r2, r0, lsl #16
8f635430:	e1833c2c 	orr	r3, r3, r12, lsr #24
8f635434:	e1822401 	orr	r2, r2, r1, lsl #8
8f635438:	e1923003 	orrs	r3, r2, r3
8f63543c:	1affffed 	bne	8f6353f8 <fdt_num_mem_rsv+0x40>
}
8f635440:	e59f3020 	ldr	r3, [pc, #32]	; 8f635468 <fdt_num_mem_rsv+0xb0>
8f635444:	e5932000 	ldr	r2, [r3]
8f635448:	e59d3004 	ldr	r3, [r13, #4]
8f63544c:	e0332002 	eors	r2, r3, r2
8f635450:	e3a03000 	mov	r3, #0
8f635454:	1a000002 	bne	8f635464 <fdt_num_mem_rsv+0xac>
8f635458:	e1a00004 	mov	r0, r4
8f63545c:	e28dd00c 	add	r13, r13, #12
8f635460:	e8bd8030 	pop	{r4, r5, r15}
8f635464:	ebfff5d5 	bl	8f632bc0 <__stack_chk_fail>
8f635468:	8f74221c 	.word	0x8f74221c

8f63546c <fdt_subnode_offset>:

int fdt_subnode_offset(const void *fdt, int parentoffset,
		       const char *name)
{
8f63546c:	e59f308c 	ldr	r3, [pc, #140]	; 8f635500 <fdt_subnode_offset+0x94>
8f635470:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f635474:	e1a04000 	mov	r4, r0
8f635478:	e24dd00c 	sub	r13, r13, #12
	return fdt_subnode_offset_namelen(fdt, parentoffset, name, strlen(name));
8f63547c:	e1a00002 	mov	r0, r2
{
8f635480:	e5933000 	ldr	r3, [r3]
8f635484:	e58d3004 	str	r3, [r13, #4]
8f635488:	e3a03000 	mov	r3, #0
8f63548c:	e1a05002 	mov	r5, r2
8f635490:	e1a06001 	mov	r6, r1
	return fdt_subnode_offset_namelen(fdt, parentoffset, name, strlen(name));
8f635494:	ebfffcdb 	bl	8f634808 <strlen>
8f635498:	e1a07000 	mov	r7, r0
	FDT_CHECK_HEADER(fdt);
8f63549c:	e1a00004 	mov	r0, r4
8f6354a0:	ebfffdd9 	bl	8f634c0c <fdt_check_header>
}
8f6354a4:	e59f3054 	ldr	r3, [pc, #84]	; 8f635500 <fdt_subnode_offset+0x94>
	FDT_CHECK_HEADER(fdt);
8f6354a8:	e3500000 	cmp	r0, #0
8f6354ac:	1a00000b 	bne	8f6354e0 <fdt_subnode_offset+0x74>
8f6354b0:	e5932000 	ldr	r2, [r3]
8f6354b4:	e59d3004 	ldr	r3, [r13, #4]
8f6354b8:	e0332002 	eors	r2, r3, r2
8f6354bc:	e3a03000 	mov	r3, #0
8f6354c0:	1a00000d 	bne	8f6354fc <fdt_subnode_offset+0x90>
8f6354c4:	e1a03007 	mov	r3, r7
8f6354c8:	e1a02005 	mov	r2, r5
8f6354cc:	e1a01006 	mov	r1, r6
8f6354d0:	e1a00004 	mov	r0, r4
}
8f6354d4:	e28dd00c 	add	r13, r13, #12
8f6354d8:	e8bd40f0 	pop	{r4, r5, r6, r7, r14}
8f6354dc:	eaffff79 	b	8f6352c8 <fdt_subnode_offset_namelen.part.0>
8f6354e0:	e5932000 	ldr	r2, [r3]
8f6354e4:	e59d3004 	ldr	r3, [r13, #4]
8f6354e8:	e0332002 	eors	r2, r3, r2
8f6354ec:	e3a03000 	mov	r3, #0
8f6354f0:	1a000001 	bne	8f6354fc <fdt_subnode_offset+0x90>
8f6354f4:	e28dd00c 	add	r13, r13, #12
8f6354f8:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
8f6354fc:	ebfff5af 	bl	8f632bc0 <__stack_chk_fail>
8f635500:	8f74221c 	.word	0x8f74221c

8f635504 <fdt_get_property_by_offset>:
}

const struct fdt_property *fdt_get_property_by_offset(const void *fdt,
						      int offset,
						      int *lenp)
{
8f635504:	e59f30ac 	ldr	r3, [pc, #172]	; 8f6355b8 <fdt_get_property_by_offset+0xb4>
8f635508:	e92d4070 	push	{r4, r5, r6, r14}
8f63550c:	e24dd008 	sub	r13, r13, #8
8f635510:	e5933000 	ldr	r3, [r3]
8f635514:	e58d3004 	str	r3, [r13, #4]
8f635518:	e3a03000 	mov	r3, #0
8f63551c:	e1a04000 	mov	r4, r0
8f635520:	e1a05001 	mov	r5, r1
8f635524:	e1a06002 	mov	r6, r2
	int err;
	const struct fdt_property *prop;

	if ((err = _fdt_check_prop_offset(fdt, offset)) < 0) {
8f635528:	ebfffeb8 	bl	8f635010 <_fdt_check_prop_offset>
8f63552c:	e2503000 	subs	r3, r0, #0
8f635530:	ba00001a 	blt	8f6355a0 <fdt_get_property_by_offset+0x9c>
	return (const char *)fdt + fdt_off_dt_struct(fdt) + offset;
8f635534:	e5940008 	ldr	r0, [r4, #8]
		return NULL;
	}

	prop = _fdt_offset_ptr(fdt, offset);

	if (lenp)
8f635538:	e3560000 	cmp	r6, #0
	return (EXTRACT_BYTE(0) << 24) | (EXTRACT_BYTE(1) << 16) | (EXTRACT_BYTE(2) << 8) | EXTRACT_BYTE(3);
8f63553c:	e7e71450 	ubfx	r1, r0, #8, #8
8f635540:	e1a03c20 	lsr	r3, r0, #24
8f635544:	e1833c00 	orr	r3, r3, r0, lsl #24
8f635548:	e7e70850 	ubfx	r0, r0, #16, #8
8f63554c:	e1833801 	orr	r3, r3, r1, lsl #16
8f635550:	e1833400 	orr	r3, r3, r0, lsl #8
8f635554:	e0831005 	add	r1, r3, r5
8f635558:	e0840001 	add	r0, r4, r1
8f63555c:	0a000007 	beq	8f635580 <fdt_get_property_by_offset+0x7c>
		*lenp = fdt32_to_cpu(prop->len);
8f635560:	e5902004 	ldr	r2, [r0, #4]
8f635564:	e7e7c452 	ubfx	r12, r2, #8, #8
8f635568:	e7e71852 	ubfx	r1, r2, #16, #8
8f63556c:	e1a03c22 	lsr	r3, r2, #24
8f635570:	e1833c02 	orr	r3, r3, r2, lsl #24
8f635574:	e183380c 	orr	r3, r3, r12, lsl #16
8f635578:	e1833401 	orr	r3, r3, r1, lsl #8
8f63557c:	e5863000 	str	r3, [r6]

	return prop;
}
8f635580:	e59f3030 	ldr	r3, [pc, #48]	; 8f6355b8 <fdt_get_property_by_offset+0xb4>
8f635584:	e5932000 	ldr	r2, [r3]
8f635588:	e59d3004 	ldr	r3, [r13, #4]
8f63558c:	e0332002 	eors	r2, r3, r2
8f635590:	e3a03000 	mov	r3, #0
8f635594:	1a000006 	bne	8f6355b4 <fdt_get_property_by_offset+0xb0>
8f635598:	e28dd008 	add	r13, r13, #8
8f63559c:	e8bd8070 	pop	{r4, r5, r6, r15}
		if (lenp)
8f6355a0:	e3560000 	cmp	r6, #0
		return NULL;
8f6355a4:	01a00006 	moveq	r0, r6
8f6355a8:	13a00000 	movne	r0, #0
			*lenp = err;
8f6355ac:	15863000 	strne	r3, [r6]
8f6355b0:	eafffff2 	b	8f635580 <fdt_get_property_by_offset+0x7c>
}
8f6355b4:	ebfff581 	bl	8f632bc0 <__stack_chk_fail>
8f6355b8:	8f74221c 	.word	0x8f74221c

8f6355bc <fdt_get_property_namelen>:

const struct fdt_property *fdt_get_property_namelen(const void *fdt,
						    int offset,
						    const char *name,
						    int namelen, int *lenp)
{
8f6355bc:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
8f6355c0:	e1a07003 	mov	r7, r3
8f6355c4:	e24dd008 	sub	r13, r13, #8
8f6355c8:	e59f3180 	ldr	r3, [pc, #384]	; 8f635750 <fdt_get_property_namelen+0x194>
8f6355cc:	e1a06000 	mov	r6, r0
8f6355d0:	e1a09002 	mov	r9, r2
8f6355d4:	e59d8028 	ldr	r8, [r13, #40]	; 0x28
8f6355d8:	e5933000 	ldr	r3, [r3]
8f6355dc:	e58d3004 	str	r3, [r13, #4]
8f6355e0:	e3a03000 	mov	r3, #0
	if ((offset = _fdt_check_node_offset(fdt, nodeoffset)) < 0)
8f6355e4:	ebfffe6d 	bl	8f634fa0 <_fdt_check_node_offset>
8f6355e8:	e2505000 	subs	r5, r0, #0
8f6355ec:	ba00000b 	blt	8f635620 <fdt_get_property_namelen+0x64>
		tag = fdt_next_tag(fdt, offset, &nextoffset);
8f6355f0:	e1a0200d 	mov	r2, r13
8f6355f4:	e1a01005 	mov	r1, r5
8f6355f8:	e1a00006 	mov	r0, r6
8f6355fc:	ebfffdf4 	bl	8f634dd4 <fdt_next_tag>
		switch (tag) {
8f635600:	e3500003 	cmp	r0, #3
8f635604:	0a000005 	beq	8f635620 <fdt_get_property_namelen+0x64>
8f635608:	e3500009 	cmp	r0, #9
8f63560c:	0a000035 	beq	8f6356e8 <fdt_get_property_namelen+0x12c>
	} while (tag == FDT_NOP);
8f635610:	e3500004 	cmp	r0, #4
		offset = nextoffset;
8f635614:	e59d5000 	ldr	r5, [r13]
	} while (tag == FDT_NOP);
8f635618:	0afffff4 	beq	8f6355f0 <fdt_get_property_namelen+0x34>
	return -FDT_ERR_NOTFOUND;
8f63561c:	e3e05000 	mvn	r5, #0
	for (offset = fdt_first_property_offset(fdt, offset);
8f635620:	e3550000 	cmp	r5, #0
8f635624:	ba00002a 	blt	8f6356d4 <fdt_get_property_namelen+0x118>
	     (offset >= 0);
	     (offset = fdt_next_property_offset(fdt, offset))) {
		const struct fdt_property *prop;

		if (!(prop = fdt_get_property_by_offset(fdt, offset, lenp))) {
8f635628:	e1a02008 	mov	r2, r8
8f63562c:	e1a01005 	mov	r1, r5
8f635630:	e1a00006 	mov	r0, r6
8f635634:	ebffffb2 	bl	8f635504 <fdt_get_property_by_offset>
8f635638:	e250a000 	subs	r10, r0, #0
8f63563c:	0a00003c 	beq	8f635734 <fdt_get_property_namelen+0x178>
			offset = -FDT_ERR_INTERNAL;
			break;
		}
		if (_fdt_string_eq(fdt, fdt32_to_cpu(prop->nameoff),
8f635640:	e59a1008 	ldr	r1, [r10, #8]
	return (const char *)fdt + fdt_off_dt_strings(fdt) + stroffset;
8f635644:	e596200c 	ldr	r2, [r6, #12]
8f635648:	e7e7c451 	ubfx	r12, r1, #8, #8
8f63564c:	e7e70452 	ubfx	r0, r2, #8, #8
8f635650:	e1a04c21 	lsr	r4, r1, #24
8f635654:	e1a03c22 	lsr	r3, r2, #24
8f635658:	e1844c01 	orr	r4, r4, r1, lsl #24
8f63565c:	e1833c02 	orr	r3, r3, r2, lsl #24
8f635660:	e7e71851 	ubfx	r1, r1, #16, #8
8f635664:	e7e72852 	ubfx	r2, r2, #16, #8
8f635668:	e184480c 	orr	r4, r4, r12, lsl #16
8f63566c:	e1833800 	orr	r3, r3, r0, lsl #16
8f635670:	e1844401 	orr	r4, r4, r1, lsl #8
8f635674:	e1833402 	orr	r3, r3, r2, lsl #8
8f635678:	e0844003 	add	r4, r4, r3
8f63567c:	e0864004 	add	r4, r6, r4
	return (strlen(p) == (size_t)len) && (memcmp(p, s, len) == 0);
8f635680:	e1a00004 	mov	r0, r4
8f635684:	ebfffc5f 	bl	8f634808 <strlen>
8f635688:	e1500007 	cmp	r0, r7
8f63568c:	0a000019 	beq	8f6356f8 <fdt_get_property_namelen+0x13c>
	if ((offset = _fdt_check_prop_offset(fdt, offset)) < 0)
8f635690:	e1a01005 	mov	r1, r5
8f635694:	e1a00006 	mov	r0, r6
8f635698:	ebfffe5c 	bl	8f635010 <_fdt_check_prop_offset>
8f63569c:	e2505000 	subs	r5, r0, #0
8f6356a0:	ba00000b 	blt	8f6356d4 <fdt_get_property_namelen+0x118>
		tag = fdt_next_tag(fdt, offset, &nextoffset);
8f6356a4:	e1a0200d 	mov	r2, r13
8f6356a8:	e1a01005 	mov	r1, r5
8f6356ac:	e1a00006 	mov	r0, r6
8f6356b0:	ebfffdc7 	bl	8f634dd4 <fdt_next_tag>
		switch (tag) {
8f6356b4:	e3500003 	cmp	r0, #3
8f6356b8:	0affffd8 	beq	8f635620 <fdt_get_property_namelen+0x64>
8f6356bc:	e3500009 	cmp	r0, #9
8f6356c0:	0a000008 	beq	8f6356e8 <fdt_get_property_namelen+0x12c>
	} while (tag == FDT_NOP);
8f6356c4:	e3500004 	cmp	r0, #4
		offset = nextoffset;
8f6356c8:	e59d5000 	ldr	r5, [r13]
	} while (tag == FDT_NOP);
8f6356cc:	0afffff4 	beq	8f6356a4 <fdt_get_property_namelen+0xe8>
	return -FDT_ERR_NOTFOUND;
8f6356d0:	e3e05000 	mvn	r5, #0
				   name, namelen))
			return prop;
	}

	if (lenp)
8f6356d4:	e3580000 	cmp	r8, #0
		*lenp = offset;
8f6356d8:	15885000 	strne	r5, [r8]
	return NULL;
8f6356dc:	13a0a000 	movne	r10, #0
8f6356e0:	01a0a008 	moveq	r10, r8
8f6356e4:	ea000009 	b	8f635710 <fdt_get_property_namelen+0x154>
			if (nextoffset >= 0)
8f6356e8:	e59d5000 	ldr	r5, [r13]
				return -FDT_ERR_BADSTRUCTURE;
8f6356ec:	e3550000 	cmp	r5, #0
8f6356f0:	a3e0500a 	mvnge	r5, #10
8f6356f4:	eaffffc9 	b	8f635620 <fdt_get_property_namelen+0x64>
	return (strlen(p) == (size_t)len) && (memcmp(p, s, len) == 0);
8f6356f8:	e1a02007 	mov	r2, r7
8f6356fc:	e1a01009 	mov	r1, r9
8f635700:	e1a00004 	mov	r0, r4
8f635704:	ebfffb33 	bl	8f6343d8 <memcmp>
8f635708:	e3500000 	cmp	r0, #0
8f63570c:	1affffdf 	bne	8f635690 <fdt_get_property_namelen+0xd4>
}
8f635710:	e59f3038 	ldr	r3, [pc, #56]	; 8f635750 <fdt_get_property_namelen+0x194>
8f635714:	e5932000 	ldr	r2, [r3]
8f635718:	e59d3004 	ldr	r3, [r13, #4]
8f63571c:	e0332002 	eors	r2, r3, r2
8f635720:	e3a03000 	mov	r3, #0
8f635724:	1a000008 	bne	8f63574c <fdt_get_property_namelen+0x190>
8f635728:	e1a0000a 	mov	r0, r10
8f63572c:	e28dd008 	add	r13, r13, #8
8f635730:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
	if (lenp)
8f635734:	e3580000 	cmp	r8, #0
			offset = -FDT_ERR_INTERNAL;
8f635738:	e3e0500c 	mvn	r5, #12
		*lenp = offset;
8f63573c:	15885000 	strne	r5, [r8]
	return NULL;
8f635740:	13a0a000 	movne	r10, #0
8f635744:	01a0a008 	moveq	r10, r8
8f635748:	eafffff0 	b	8f635710 <fdt_get_property_namelen+0x154>
}
8f63574c:	ebfff51b 	bl	8f632bc0 <__stack_chk_fail>
8f635750:	8f74221c 	.word	0x8f74221c

8f635754 <fdt_path_offset>:
{
8f635754:	e59f3160 	ldr	r3, [pc, #352]	; 8f6358bc <fdt_path_offset+0x168>
8f635758:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f63575c:	e1a07000 	mov	r7, r0
8f635760:	e24dd010 	sub	r13, r13, #16
	const char *end = path + strlen(path);
8f635764:	e1a00001 	mov	r0, r1
{
8f635768:	e5933000 	ldr	r3, [r3]
8f63576c:	e58d300c 	str	r3, [r13, #12]
8f635770:	e3a03000 	mov	r3, #0
8f635774:	e1a04001 	mov	r4, r1
	const char *end = path + strlen(path);
8f635778:	ebfffc22 	bl	8f634808 <strlen>
8f63577c:	e1a08000 	mov	r8, r0
	FDT_CHECK_HEADER(fdt);
8f635780:	e1a00007 	mov	r0, r7
8f635784:	ebfffd20 	bl	8f634c0c <fdt_check_header>
8f635788:	e2505000 	subs	r5, r0, #0
8f63578c:	1a00003e 	bne	8f63588c <fdt_path_offset+0x138>
	if (*path != '/') {
8f635790:	e5d43000 	ldrb	r3, [r4]
	const char *end = path + strlen(path);
8f635794:	e0848008 	add	r8, r4, r8
	if (*path != '/') {
8f635798:	e353002f 	cmp	r3, #47	; 0x2f
8f63579c:	0a000019 	beq	8f635808 <fdt_path_offset+0xb4>
		const char *q = strchr(path, '/');
8f6357a0:	e3a0102f 	mov	r1, #47	; 0x2f
8f6357a4:	e1a00004 	mov	r0, r4
8f6357a8:	ebfffb42 	bl	8f6344b8 <strchr>
const char *fdt_get_alias_namelen(const void *fdt,
				  const char *name, int namelen)
{
	int aliasoffset;

	aliasoffset = fdt_path_offset(fdt, "/aliases");
8f6357ac:	e30b123c 	movw	r1, #45628	; 0xb23c
8f6357b0:	e3481f70 	movt	r1, #36720	; 0x8f70
			q = end;
8f6357b4:	e3500000 	cmp	r0, #0
8f6357b8:	11a06000 	movne	r6, r0
	aliasoffset = fdt_path_offset(fdt, "/aliases");
8f6357bc:	e1a00007 	mov	r0, r7
			q = end;
8f6357c0:	01a06008 	moveq	r6, r8
	aliasoffset = fdt_path_offset(fdt, "/aliases");
8f6357c4:	ebffffe2 	bl	8f635754 <fdt_path_offset>
		p = fdt_get_alias_namelen(fdt, p, q - p);
8f6357c8:	e0463004 	sub	r3, r6, r4
	if (aliasoffset < 0)
8f6357cc:	e2501000 	subs	r1, r0, #0
8f6357d0:	ba000036 	blt	8f6358b0 <fdt_path_offset+0x15c>
	prop = fdt_get_property_namelen(fdt, nodeoffset, name, namelen, lenp);
8f6357d4:	e1a02004 	mov	r2, r4
8f6357d8:	e1a00007 	mov	r0, r7
8f6357dc:	e58d5000 	str	r5, [r13]
8f6357e0:	ebffff75 	bl	8f6355bc <fdt_get_property_namelen>
	if (! prop)
8f6357e4:	e3500000 	cmp	r0, #0
8f6357e8:	0a000030 	beq	8f6358b0 <fdt_path_offset+0x15c>
		if (!p)
8f6357ec:	e290100c 	adds	r1, r0, #12
8f6357f0:	0a00002e 	beq	8f6358b0 <fdt_path_offset+0x15c>
		offset = fdt_path_offset(fdt, p);
8f6357f4:	e1a00007 	mov	r0, r7
	while (*p) {
8f6357f8:	e1a04006 	mov	r4, r6
		offset = fdt_path_offset(fdt, p);
8f6357fc:	ebffffd4 	bl	8f635754 <fdt_path_offset>
	while (*p) {
8f635800:	e5d63000 	ldrb	r3, [r6]
		offset = fdt_path_offset(fdt, p);
8f635804:	e1a05000 	mov	r5, r0
	while (*p) {
8f635808:	e3530000 	cmp	r3, #0
8f63580c:	0a00001e 	beq	8f63588c <fdt_path_offset+0x138>
		while (*p == '/')
8f635810:	e353002f 	cmp	r3, #47	; 0x2f
8f635814:	1a000004 	bne	8f63582c <fdt_path_offset+0xd8>
8f635818:	e5f43001 	ldrb	r3, [r4, #1]!
8f63581c:	e353002f 	cmp	r3, #47	; 0x2f
8f635820:	0afffffc 	beq	8f635818 <fdt_path_offset+0xc4>
		if (! *p)
8f635824:	e3530000 	cmp	r3, #0
8f635828:	0a000017 	beq	8f63588c <fdt_path_offset+0x138>
		q = strchr(p, '/');
8f63582c:	e3a0102f 	mov	r1, #47	; 0x2f
8f635830:	e1a00004 	mov	r0, r4
8f635834:	ebfffb1f 	bl	8f6344b8 <strchr>
8f635838:	e1a03000 	mov	r3, r0
			q = end;
8f63583c:	e3530000 	cmp	r3, #0
	FDT_CHECK_HEADER(fdt);
8f635840:	e1a00007 	mov	r0, r7
			q = end;
8f635844:	11a06003 	movne	r6, r3
8f635848:	01a06008 	moveq	r6, r8
	FDT_CHECK_HEADER(fdt);
8f63584c:	ebfffcee 	bl	8f634c0c <fdt_check_header>
8f635850:	e3500000 	cmp	r0, #0
8f635854:	11a05000 	movne	r5, r0
8f635858:	1a000005 	bne	8f635874 <fdt_path_offset+0x120>
8f63585c:	e1a01005 	mov	r1, r5
8f635860:	e0463004 	sub	r3, r6, r4
8f635864:	e1a02004 	mov	r2, r4
8f635868:	e1a00007 	mov	r0, r7
8f63586c:	ebfffe95 	bl	8f6352c8 <fdt_subnode_offset_namelen.part.0>
8f635870:	e1a05000 	mov	r5, r0
		if (offset < 0)
8f635874:	e3550000 	cmp	r5, #0
8f635878:	ba000003 	blt	8f63588c <fdt_path_offset+0x138>
	while (*p) {
8f63587c:	e5d63000 	ldrb	r3, [r6]
8f635880:	e1a04006 	mov	r4, r6
8f635884:	e3530000 	cmp	r3, #0
8f635888:	1affffe0 	bne	8f635810 <fdt_path_offset+0xbc>
}
8f63588c:	e59f3028 	ldr	r3, [pc, #40]	; 8f6358bc <fdt_path_offset+0x168>
8f635890:	e5932000 	ldr	r2, [r3]
8f635894:	e59d300c 	ldr	r3, [r13, #12]
8f635898:	e0332002 	eors	r2, r3, r2
8f63589c:	e3a03000 	mov	r3, #0
8f6358a0:	1a000004 	bne	8f6358b8 <fdt_path_offset+0x164>
8f6358a4:	e1a00005 	mov	r0, r5
8f6358a8:	e28dd010 	add	r13, r13, #16
8f6358ac:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
			return -FDT_ERR_BADPATH;
8f6358b0:	e3e05004 	mvn	r5, #4
8f6358b4:	eafffff4 	b	8f63588c <fdt_path_offset+0x138>
}
8f6358b8:	ebfff4c0 	bl	8f632bc0 <__stack_chk_fail>
8f6358bc:	8f74221c 	.word	0x8f74221c

8f6358c0 <fdt_get_property>:
{
8f6358c0:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f6358c4:	e1a05003 	mov	r5, r3
8f6358c8:	e59f305c 	ldr	r3, [pc, #92]	; 8f63592c <fdt_get_property+0x6c>
8f6358cc:	e24dd014 	sub	r13, r13, #20
8f6358d0:	e1a06000 	mov	r6, r0
					strlen(name), lenp);
8f6358d4:	e1a00002 	mov	r0, r2
{
8f6358d8:	e5933000 	ldr	r3, [r3]
8f6358dc:	e58d300c 	str	r3, [r13, #12]
8f6358e0:	e3a03000 	mov	r3, #0
8f6358e4:	e1a04002 	mov	r4, r2
8f6358e8:	e1a07001 	mov	r7, r1
					strlen(name), lenp);
8f6358ec:	ebfffbc5 	bl	8f634808 <strlen>
	return fdt_get_property_namelen(fdt, nodeoffset, name,
8f6358f0:	e1a02004 	mov	r2, r4
8f6358f4:	e1a01007 	mov	r1, r7
8f6358f8:	e58d5000 	str	r5, [r13]
					strlen(name), lenp);
8f6358fc:	e1a03000 	mov	r3, r0
	return fdt_get_property_namelen(fdt, nodeoffset, name,
8f635900:	e1a00006 	mov	r0, r6
8f635904:	ebffff2c 	bl	8f6355bc <fdt_get_property_namelen>
}
8f635908:	e59f301c 	ldr	r3, [pc, #28]	; 8f63592c <fdt_get_property+0x6c>
8f63590c:	e5932000 	ldr	r2, [r3]
8f635910:	e59d300c 	ldr	r3, [r13, #12]
8f635914:	e0332002 	eors	r2, r3, r2
8f635918:	e3a03000 	mov	r3, #0
8f63591c:	1a000001 	bne	8f635928 <fdt_get_property+0x68>
8f635920:	e28dd014 	add	r13, r13, #20
8f635924:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
8f635928:	ebfff4a4 	bl	8f632bc0 <__stack_chk_fail>
8f63592c:	8f74221c 	.word	0x8f74221c

8f635930 <fdt_getprop>:
{
8f635930:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f635934:	e1a05003 	mov	r5, r3
8f635938:	e59f3064 	ldr	r3, [pc, #100]	; 8f6359a4 <fdt_getprop+0x74>
8f63593c:	e24dd014 	sub	r13, r13, #20
8f635940:	e1a06000 	mov	r6, r0
	return fdt_getprop_namelen(fdt, nodeoffset, name, strlen(name), lenp);
8f635944:	e1a00002 	mov	r0, r2
{
8f635948:	e5933000 	ldr	r3, [r3]
8f63594c:	e58d300c 	str	r3, [r13, #12]
8f635950:	e3a03000 	mov	r3, #0
8f635954:	e1a04002 	mov	r4, r2
8f635958:	e1a07001 	mov	r7, r1
	return fdt_getprop_namelen(fdt, nodeoffset, name, strlen(name), lenp);
8f63595c:	ebfffba9 	bl	8f634808 <strlen>
	prop = fdt_get_property_namelen(fdt, nodeoffset, name, namelen, lenp);
8f635960:	e1a02004 	mov	r2, r4
8f635964:	e1a01007 	mov	r1, r7
8f635968:	e58d5000 	str	r5, [r13]
	return fdt_getprop_namelen(fdt, nodeoffset, name, strlen(name), lenp);
8f63596c:	e1a03000 	mov	r3, r0
	prop = fdt_get_property_namelen(fdt, nodeoffset, name, namelen, lenp);
8f635970:	e1a00006 	mov	r0, r6
8f635974:	ebffff10 	bl	8f6355bc <fdt_get_property_namelen>
}
8f635978:	e59f3024 	ldr	r3, [pc, #36]	; 8f6359a4 <fdt_getprop+0x74>
	if (! prop)
8f63597c:	e3500000 	cmp	r0, #0
	return prop->data;
8f635980:	1280000c 	addne	r0, r0, #12
}
8f635984:	e5932000 	ldr	r2, [r3]
8f635988:	e59d300c 	ldr	r3, [r13, #12]
8f63598c:	e0332002 	eors	r2, r3, r2
8f635990:	e3a03000 	mov	r3, #0
8f635994:	1a000001 	bne	8f6359a0 <fdt_getprop+0x70>
8f635998:	e28dd014 	add	r13, r13, #20
8f63599c:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
8f6359a0:	ebfff486 	bl	8f632bc0 <__stack_chk_fail>
8f6359a4:	8f74221c 	.word	0x8f74221c

8f6359a8 <fdt_node_check_compatible>:
	return 0;
}

int fdt_node_check_compatible(const void *fdt, int nodeoffset,
			      const char *compatible)
{
8f6359a8:	e59f30f4 	ldr	r3, [pc, #244]	; 8f635aa4 <fdt_node_check_compatible+0xfc>
8f6359ac:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f6359b0:	e1a04000 	mov	r4, r0
8f6359b4:	e24dd010 	sub	r13, r13, #16
	return fdt_getprop_namelen(fdt, nodeoffset, name, strlen(name), lenp);
8f6359b8:	e30a0714 	movw	r0, #42772	; 0xa714
8f6359bc:	e3480f70 	movt	r0, #36720	; 0x8f70
{
8f6359c0:	e5933000 	ldr	r3, [r3]
8f6359c4:	e58d300c 	str	r3, [r13, #12]
8f6359c8:	e3a03000 	mov	r3, #0
8f6359cc:	e1a06001 	mov	r6, r1
8f6359d0:	e1a05002 	mov	r5, r2
	return fdt_getprop_namelen(fdt, nodeoffset, name, strlen(name), lenp);
8f6359d4:	ebfffb8b 	bl	8f634808 <strlen>
	prop = fdt_get_property_namelen(fdt, nodeoffset, name, namelen, lenp);
8f6359d8:	e28d2008 	add	r2, r13, #8
8f6359dc:	e1a01006 	mov	r1, r6
8f6359e0:	e58d2000 	str	r2, [r13]
8f6359e4:	e30a2714 	movw	r2, #42772	; 0xa714
8f6359e8:	e3482f70 	movt	r2, #36720	; 0x8f70
	return fdt_getprop_namelen(fdt, nodeoffset, name, strlen(name), lenp);
8f6359ec:	e1a03000 	mov	r3, r0
	prop = fdt_get_property_namelen(fdt, nodeoffset, name, namelen, lenp);
8f6359f0:	e1a00004 	mov	r0, r4
8f6359f4:	ebfffef0 	bl	8f6355bc <fdt_get_property_namelen>
	if (! prop)
8f6359f8:	e3500000 	cmp	r0, #0
8f6359fc:	0a000025 	beq	8f635a98 <fdt_node_check_compatible+0xf0>
	const void *prop;
	int len;

	prop = fdt_getprop(fdt, nodeoffset, "compatible", &len);
	if (!prop)
8f635a00:	e290400c 	adds	r4, r0, #12
8f635a04:	0a000023 	beq	8f635a98 <fdt_node_check_compatible+0xf0>
	int len = strlen(str);
8f635a08:	e1a00005 	mov	r0, r5
		return len;
	if (_fdt_stringlist_contains(prop, len, compatible))
8f635a0c:	e59d8008 	ldr	r8, [r13, #8]
	int len = strlen(str);
8f635a10:	ebfffb7c 	bl	8f634808 <strlen>
	while (listlen >= len) {
8f635a14:	e1580000 	cmp	r8, r0
	int len = strlen(str);
8f635a18:	e1a06000 	mov	r6, r0
	while (listlen >= len) {
8f635a1c:	ba00001b 	blt	8f635a90 <fdt_node_check_compatible+0xe8>
		if (memcmp(str, strlist, len+1) == 0)
8f635a20:	e2807001 	add	r7, r0, #1
8f635a24:	ea00000b 	b	8f635a58 <fdt_node_check_compatible+0xb0>
		p = memchr(strlist, '\0', listlen);
8f635a28:	e1a02008 	mov	r2, r8
8f635a2c:	e3a01000 	mov	r1, #0
8f635a30:	e1a00004 	mov	r0, r4
8f635a34:	ebfffa47 	bl	8f634358 <memchr>
		if (!p)
8f635a38:	e3500000 	cmp	r0, #0
8f635a3c:	0a000013 	beq	8f635a90 <fdt_node_check_compatible+0xe8>
		listlen -= (p-strlist) + 1;
8f635a40:	e0403004 	sub	r3, r0, r4
		strlist = p + 1;
8f635a44:	e2804001 	add	r4, r0, #1
		listlen -= (p-strlist) + 1;
8f635a48:	e1e03003 	mvn	r3, r3
8f635a4c:	e0888003 	add	r8, r8, r3
	while (listlen >= len) {
8f635a50:	e1560008 	cmp	r6, r8
8f635a54:	ca00000d 	bgt	8f635a90 <fdt_node_check_compatible+0xe8>
		if (memcmp(str, strlist, len+1) == 0)
8f635a58:	e1a02007 	mov	r2, r7
8f635a5c:	e1a01004 	mov	r1, r4
8f635a60:	e1a00005 	mov	r0, r5
8f635a64:	ebfffa5b 	bl	8f6343d8 <memcmp>
8f635a68:	e3500000 	cmp	r0, #0
8f635a6c:	1affffed 	bne	8f635a28 <fdt_node_check_compatible+0x80>
		return 0;
	else
		return 1;
}
8f635a70:	e59f302c 	ldr	r3, [pc, #44]	; 8f635aa4 <fdt_node_check_compatible+0xfc>
8f635a74:	e5932000 	ldr	r2, [r3]
8f635a78:	e59d300c 	ldr	r3, [r13, #12]
8f635a7c:	e0332002 	eors	r2, r3, r2
8f635a80:	e3a03000 	mov	r3, #0
8f635a84:	1a000005 	bne	8f635aa0 <fdt_node_check_compatible+0xf8>
8f635a88:	e28dd010 	add	r13, r13, #16
8f635a8c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
		return 1;
8f635a90:	e3a00001 	mov	r0, #1
8f635a94:	eafffff5 	b	8f635a70 <fdt_node_check_compatible+0xc8>
		return len;
8f635a98:	e59d0008 	ldr	r0, [r13, #8]
8f635a9c:	eafffff3 	b	8f635a70 <fdt_node_check_compatible+0xc8>
}
8f635aa0:	ebfff446 	bl	8f632bc0 <__stack_chk_fail>
8f635aa4:	8f74221c 	.word	0x8f74221c

8f635aa8 <fdt_node_offset_by_compatible>:

int fdt_node_offset_by_compatible(const void *fdt, int startoffset,
				  const char *compatible)
{
8f635aa8:	e59f30a8 	ldr	r3, [pc, #168]	; 8f635b58 <fdt_node_offset_by_compatible+0xb0>
8f635aac:	e92d4070 	push	{r4, r5, r6, r14}
8f635ab0:	e24dd008 	sub	r13, r13, #8
8f635ab4:	e5933000 	ldr	r3, [r3]
8f635ab8:	e58d3004 	str	r3, [r13, #4]
8f635abc:	e3a03000 	mov	r3, #0
8f635ac0:	e1a05000 	mov	r5, r0
8f635ac4:	e1a04001 	mov	r4, r1
8f635ac8:	e1a06002 	mov	r6, r2
	int offset, err;

	FDT_CHECK_HEADER(fdt);
8f635acc:	ebfffc4e 	bl	8f634c0c <fdt_check_header>
8f635ad0:	e3500000 	cmp	r0, #0
8f635ad4:	0a000007 	beq	8f635af8 <fdt_node_offset_by_compatible+0x50>
		else if (err == 0)
			return offset;
	}

	return offset; /* error from fdt_next_node() */
}
8f635ad8:	e59f3078 	ldr	r3, [pc, #120]	; 8f635b58 <fdt_node_offset_by_compatible+0xb0>
8f635adc:	e5932000 	ldr	r2, [r3]
8f635ae0:	e59d3004 	ldr	r3, [r13, #4]
8f635ae4:	e0332002 	eors	r2, r3, r2
8f635ae8:	e3a03000 	mov	r3, #0
8f635aec:	1a000018 	bne	8f635b54 <fdt_node_offset_by_compatible+0xac>
8f635af0:	e28dd008 	add	r13, r13, #8
8f635af4:	e8bd8070 	pop	{r4, r5, r6, r15}
	for (offset = fdt_next_node(fdt, startoffset, NULL);
8f635af8:	e1a02000 	mov	r2, r0
8f635afc:	e1a01004 	mov	r1, r4
8f635b00:	e1a00005 	mov	r0, r5
8f635b04:	ebfffd5d 	bl	8f635080 <fdt_next_node>
8f635b08:	e2504000 	subs	r4, r0, #0
8f635b0c:	aa000006 	bge	8f635b2c <fdt_node_offset_by_compatible+0x84>
8f635b10:	ea00000d 	b	8f635b4c <fdt_node_offset_by_compatible+0xa4>
	     offset = fdt_next_node(fdt, offset, NULL)) {
8f635b14:	e1a01004 	mov	r1, r4
8f635b18:	e3a02000 	mov	r2, #0
8f635b1c:	e1a00005 	mov	r0, r5
8f635b20:	ebfffd56 	bl	8f635080 <fdt_next_node>
	for (offset = fdt_next_node(fdt, startoffset, NULL);
8f635b24:	e2504000 	subs	r4, r0, #0
8f635b28:	ba000007 	blt	8f635b4c <fdt_node_offset_by_compatible+0xa4>
		err = fdt_node_check_compatible(fdt, offset, compatible);
8f635b2c:	e1a02006 	mov	r2, r6
8f635b30:	e1a01004 	mov	r1, r4
8f635b34:	e1a00005 	mov	r0, r5
8f635b38:	ebffff9a 	bl	8f6359a8 <fdt_node_check_compatible>
		if ((err < 0) && (err != -FDT_ERR_NOTFOUND))
8f635b3c:	e3700001 	cmn	r0, #1
8f635b40:	baffffe4 	blt	8f635ad8 <fdt_node_offset_by_compatible+0x30>
		else if (err == 0)
8f635b44:	e3500000 	cmp	r0, #0
8f635b48:	1afffff1 	bne	8f635b14 <fdt_node_offset_by_compatible+0x6c>
8f635b4c:	e1a00004 	mov	r0, r4
8f635b50:	eaffffe0 	b	8f635ad8 <fdt_node_offset_by_compatible+0x30>
}
8f635b54:	ebfff419 	bl	8f632bc0 <__stack_chk_fail>
8f635b58:	8f74221c 	.word	0x8f74221c

8f635b5c <_fdt_blocks_misordered>:
#include "libfdt_internal.h"

static int _fdt_blocks_misordered(const void *fdt,
			      int mem_rsv_size, int struct_size)
{
	return (fdt_off_mem_rsvmap(fdt) < FDT_ALIGN(sizeof(struct fdt_header), 8))
8f635b5c:	e590c010 	ldr	r12, [r0, #16]
{
8f635b60:	e59f30f4 	ldr	r3, [pc, #244]	; 8f635c5c <_fdt_blocks_misordered+0x100>
8f635b64:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f635b68:	e24dd00c 	sub	r13, r13, #12
8f635b6c:	e7e7e45c 	ubfx	r14, r12, #8, #8
8f635b70:	e5933000 	ldr	r3, [r3]
8f635b74:	e58d3004 	str	r3, [r13, #4]
8f635b78:	e3a03000 	mov	r3, #0
8f635b7c:	e1a03c2c 	lsr	r3, r12, #24
8f635b80:	e1833c0c 	orr	r3, r3, r12, lsl #24
8f635b84:	e7e7c85c 	ubfx	r12, r12, #16, #8
8f635b88:	e183380e 	orr	r3, r3, r14, lsl #16
8f635b8c:	e183340c 	orr	r3, r3, r12, lsl #8
		|| (fdt_off_dt_struct(fdt) <
		    (fdt_off_mem_rsvmap(fdt) + mem_rsv_size))
		|| (fdt_off_dt_strings(fdt) <
		    (fdt_off_dt_struct(fdt) + struct_size))
		|| (fdt_totalsize(fdt) <
8f635b90:	e3530027 	cmp	r3, #39	; 0x27
8f635b94:	9a000009 	bls	8f635bc0 <_fdt_blocks_misordered+0x64>
		|| (fdt_off_dt_struct(fdt) <
8f635b98:	e590c008 	ldr	r12, [r0, #8]
		    (fdt_off_mem_rsvmap(fdt) + mem_rsv_size))
8f635b9c:	e0811003 	add	r1, r1, r3
8f635ba0:	e7e7e45c 	ubfx	r14, r12, #8, #8
8f635ba4:	e1a03c2c 	lsr	r3, r12, #24
8f635ba8:	e1833c0c 	orr	r3, r3, r12, lsl #24
8f635bac:	e7e7c85c 	ubfx	r12, r12, #16, #8
8f635bb0:	e183380e 	orr	r3, r3, r14, lsl #16
8f635bb4:	e183340c 	orr	r3, r3, r12, lsl #8
		|| (fdt_off_dt_struct(fdt) <
8f635bb8:	e1510003 	cmp	r1, r3
8f635bbc:	9a000008 	bls	8f635be4 <_fdt_blocks_misordered+0x88>
		|| (fdt_totalsize(fdt) <
8f635bc0:	e3a00001 	mov	r0, #1
		    (fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt)));
}
8f635bc4:	e59f3090 	ldr	r3, [pc, #144]	; 8f635c5c <_fdt_blocks_misordered+0x100>
8f635bc8:	e5932000 	ldr	r2, [r3]
8f635bcc:	e59d3004 	ldr	r3, [r13, #4]
8f635bd0:	e0332002 	eors	r2, r3, r2
8f635bd4:	e3a03000 	mov	r3, #0
8f635bd8:	1a00001e 	bne	8f635c58 <_fdt_blocks_misordered+0xfc>
8f635bdc:	e28dd00c 	add	r13, r13, #12
8f635be0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
		    (fdt_off_dt_struct(fdt) + struct_size))
8f635be4:	e0822003 	add	r2, r2, r3
		|| (fdt_off_dt_strings(fdt) <
8f635be8:	e590300c 	ldr	r3, [r0, #12]
8f635bec:	e7e7e453 	ubfx	r14, r3, #8, #8
8f635bf0:	e7e7c853 	ubfx	r12, r3, #16, #8
8f635bf4:	e1a01c23 	lsr	r1, r3, #24
8f635bf8:	e1811c03 	orr	r1, r1, r3, lsl #24
8f635bfc:	e181180e 	orr	r1, r1, r14, lsl #16
8f635c00:	e181140c 	orr	r1, r1, r12, lsl #8
8f635c04:	e1520001 	cmp	r2, r1
8f635c08:	8affffec 	bhi	8f635bc0 <_fdt_blocks_misordered+0x64>
		    (fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt)));
8f635c0c:	e5903020 	ldr	r3, [r0, #32]
		|| (fdt_totalsize(fdt) <
8f635c10:	e5902004 	ldr	r2, [r0, #4]
8f635c14:	e7e7e453 	ubfx	r14, r3, #8, #8
8f635c18:	e7e7c853 	ubfx	r12, r3, #16, #8
8f635c1c:	e1a00c23 	lsr	r0, r3, #24
8f635c20:	e1800c03 	orr	r0, r0, r3, lsl #24
8f635c24:	e1a03c22 	lsr	r3, r2, #24
8f635c28:	e180080e 	orr	r0, r0, r14, lsl #16
8f635c2c:	e1833c02 	orr	r3, r3, r2, lsl #24
8f635c30:	e180040c 	orr	r0, r0, r12, lsl #8
		    (fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt)));
8f635c34:	e0800001 	add	r0, r0, r1
8f635c38:	e7e71452 	ubfx	r1, r2, #8, #8
8f635c3c:	e7e72852 	ubfx	r2, r2, #16, #8
8f635c40:	e1833801 	orr	r3, r3, r1, lsl #16
8f635c44:	e1833402 	orr	r3, r3, r2, lsl #8
		|| (fdt_totalsize(fdt) <
8f635c48:	e1500003 	cmp	r0, r3
8f635c4c:	93a00000 	movls	r0, #0
8f635c50:	83a00001 	movhi	r0, #1
8f635c54:	eaffffda 	b	8f635bc4 <_fdt_blocks_misordered+0x68>
}
8f635c58:	ebfff3d8 	bl	8f632bc0 <__stack_chk_fail>
8f635c5c:	8f74221c 	.word	0x8f74221c

8f635c60 <_fdt_packblocks>:
				  endoffset - nodeoffset, 0);
}

static void _fdt_packblocks(const char *old, char *new,
			    int mem_rsv_size, int struct_size)
{
8f635c60:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f635c64:	e1a06003 	mov	r6, r3
8f635c68:	e59f3130 	ldr	r3, [pc, #304]	; 8f635da0 <_fdt_packblocks+0x140>
8f635c6c:	e24dd008 	sub	r13, r13, #8
8f635c70:	e1a05000 	mov	r5, r0
8f635c74:	e1a04001 	mov	r4, r1
8f635c78:	e5933000 	ldr	r3, [r3]
8f635c7c:	e58d3004 	str	r3, [r13, #4]
8f635c80:	e3a03000 	mov	r3, #0

	mem_rsv_off = FDT_ALIGN(sizeof(struct fdt_header), 8);
	struct_off = mem_rsv_off + mem_rsv_size;
	strings_off = struct_off + struct_size;

	memmove(new + mem_rsv_off, old + fdt_off_mem_rsvmap(old), mem_rsv_size);
8f635c84:	e5903010 	ldr	r3, [r0, #16]
8f635c88:	e2810028 	add	r0, r1, #40	; 0x28
	struct_off = mem_rsv_off + mem_rsv_size;
8f635c8c:	e2828028 	add	r8, r2, #40	; 0x28
8f635c90:	e7e7e453 	ubfx	r14, r3, #8, #8
8f635c94:	e7e7c853 	ubfx	r12, r3, #16, #8
8f635c98:	e1a01c23 	lsr	r1, r3, #24
	strings_off = struct_off + struct_size;
8f635c9c:	e0867008 	add	r7, r6, r8
8f635ca0:	e1811c03 	orr	r1, r1, r3, lsl #24
8f635ca4:	e181180e 	orr	r1, r1, r14, lsl #16
8f635ca8:	e181140c 	orr	r1, r1, r12, lsl #8
	memmove(new + mem_rsv_off, old + fdt_off_mem_rsvmap(old), mem_rsv_size);
8f635cac:	e0851001 	add	r1, r5, r1
8f635cb0:	ebfff940 	bl	8f6341b8 <memcpy>
	fdt_set_off_mem_rsvmap(new, mem_rsv_off);

	memmove(new + struct_off, old + fdt_off_dt_struct(old), struct_size);
8f635cb4:	e5953008 	ldr	r3, [r5, #8]
8f635cb8:	e1a02006 	mov	r2, r6
8f635cbc:	e0840008 	add	r0, r4, r8
8f635cc0:	e7e7e453 	ubfx	r14, r3, #8, #8
8f635cc4:	e7e7c853 	ubfx	r12, r3, #16, #8
8f635cc8:	e1a01c23 	lsr	r1, r3, #24
8f635ccc:	e6bf8f38 	rev	r8, r8
8f635cd0:	e1811c03 	orr	r1, r1, r3, lsl #24
__fdt_set_hdr(off_mem_rsvmap);
8f635cd4:	e3a0330a 	mov	r3, #671088640	; 0x28000000
8f635cd8:	e181180e 	orr	r1, r1, r14, lsl #16
8f635cdc:	e5843010 	str	r3, [r4, #16]
8f635ce0:	e181140c 	orr	r1, r1, r12, lsl #8
8f635ce4:	e0851001 	add	r1, r5, r1
8f635ce8:	ebfff932 	bl	8f6341b8 <memcpy>
	fdt_set_off_dt_struct(new, struct_off);
	fdt_set_size_dt_struct(new, struct_size);

	memmove(new + strings_off, old + fdt_off_dt_strings(old),
8f635cec:	e595200c 	ldr	r2, [r5, #12]
8f635cf0:	e7e71456 	ubfx	r1, r6, #8, #8
8f635cf4:	e1a03c26 	lsr	r3, r6, #24
8f635cf8:	e1833c06 	orr	r3, r3, r6, lsl #24
8f635cfc:	e7e76856 	ubfx	r6, r6, #16, #8
8f635d00:	e1833801 	orr	r3, r3, r1, lsl #16
8f635d04:	e5950020 	ldr	r0, [r5, #32]
8f635d08:	e1836406 	orr	r6, r3, r6, lsl #8
8f635d0c:	e1a01c22 	lsr	r1, r2, #24
8f635d10:	e7e73452 	ubfx	r3, r2, #8, #8
8f635d14:	e1811c02 	orr	r1, r1, r2, lsl #24
8f635d18:	e7e72852 	ubfx	r2, r2, #16, #8
__fdt_set_hdr(off_dt_struct);
8f635d1c:	e5848008 	str	r8, [r4, #8]
8f635d20:	e1811803 	orr	r1, r1, r3, lsl #16
8f635d24:	e7e73450 	ubfx	r3, r0, #8, #8
8f635d28:	e1811402 	orr	r1, r1, r2, lsl #8
8f635d2c:	e1a02c20 	lsr	r2, r0, #24
8f635d30:	e1822c00 	orr	r2, r2, r0, lsl #24
8f635d34:	e7e70850 	ubfx	r0, r0, #16, #8
8f635d38:	e1822803 	orr	r2, r2, r3, lsl #16
8f635d3c:	e0851001 	add	r1, r5, r1
8f635d40:	e1822400 	orr	r2, r2, r0, lsl #8
__fdt_set_hdr(size_dt_struct);
8f635d44:	e5846024 	str	r6, [r4, #36]	; 0x24
8f635d48:	e0840007 	add	r0, r4, r7
8f635d4c:	e6bf7f37 	rev	r7, r7
8f635d50:	ebfff918 	bl	8f6341b8 <memcpy>
		fdt_size_dt_strings(old));
	fdt_set_off_dt_strings(new, strings_off);
	fdt_set_size_dt_strings(new, fdt_size_dt_strings(old));
8f635d54:	e5952020 	ldr	r2, [r5, #32]
__fdt_set_hdr(off_dt_strings);
8f635d58:	e584700c 	str	r7, [r4, #12]
8f635d5c:	e7e70452 	ubfx	r0, r2, #8, #8
8f635d60:	e7e71852 	ubfx	r1, r2, #16, #8
8f635d64:	e1a03c22 	lsr	r3, r2, #24
8f635d68:	e1833c02 	orr	r3, r3, r2, lsl #24
8f635d6c:	e1833800 	orr	r3, r3, r0, lsl #16
8f635d70:	e1833401 	orr	r3, r3, r1, lsl #8
8f635d74:	e6bf3f33 	rev	r3, r3
__fdt_set_hdr(size_dt_strings);
8f635d78:	e5843020 	str	r3, [r4, #32]
}
8f635d7c:	e59f301c 	ldr	r3, [pc, #28]	; 8f635da0 <_fdt_packblocks+0x140>
8f635d80:	e5932000 	ldr	r2, [r3]
8f635d84:	e59d3004 	ldr	r3, [r13, #4]
8f635d88:	e0332002 	eors	r2, r3, r2
8f635d8c:	e3a03000 	mov	r3, #0
8f635d90:	1a000001 	bne	8f635d9c <_fdt_packblocks+0x13c>
8f635d94:	e28dd008 	add	r13, r13, #8
8f635d98:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
8f635d9c:	ebfff387 	bl	8f632bc0 <__stack_chk_fail>
8f635da0:	8f74221c 	.word	0x8f74221c

8f635da4 <_fdt_rw_check_header.part.0>:
static int _fdt_rw_check_header(void *fdt)
8f635da4:	e59f30a4 	ldr	r3, [pc, #164]	; 8f635e50 <_fdt_rw_check_header.part.0+0xac>
8f635da8:	e92d4030 	push	{r4, r5, r14}
8f635dac:	e24dd00c 	sub	r13, r13, #12
8f635db0:	e5933000 	ldr	r3, [r3]
8f635db4:	e58d3004 	str	r3, [r13, #4]
8f635db8:	e3a03000 	mov	r3, #0
	if (fdt_version(fdt) < 17)
8f635dbc:	e5903014 	ldr	r3, [r0, #20]
8f635dc0:	e7e71453 	ubfx	r1, r3, #8, #8
8f635dc4:	e7e72853 	ubfx	r2, r3, #16, #8
8f635dc8:	e1a04c23 	lsr	r4, r3, #24
8f635dcc:	e1844c03 	orr	r4, r4, r3, lsl #24
8f635dd0:	e1844801 	orr	r4, r4, r1, lsl #16
8f635dd4:	e1844402 	orr	r4, r4, r2, lsl #8
8f635dd8:	e3540010 	cmp	r4, #16
8f635ddc:	9a000016 	bls	8f635e3c <_fdt_rw_check_header.part.0+0x98>
				   fdt_size_dt_struct(fdt)))
8f635de0:	e5903024 	ldr	r3, [r0, #36]	; 0x24
8f635de4:	e1a05000 	mov	r5, r0
8f635de8:	e7e71453 	ubfx	r1, r3, #8, #8
8f635dec:	e1a02c23 	lsr	r2, r3, #24
8f635df0:	e1822c03 	orr	r2, r2, r3, lsl #24
8f635df4:	e7e73853 	ubfx	r3, r3, #16, #8
8f635df8:	e1822801 	orr	r2, r2, r1, lsl #16
	if (_fdt_blocks_misordered(fdt, sizeof(struct fdt_reserve_entry),
8f635dfc:	e3a01010 	mov	r1, #16
8f635e00:	e1822403 	orr	r2, r2, r3, lsl #8
8f635e04:	ebffff54 	bl	8f635b5c <_fdt_blocks_misordered>
8f635e08:	e3500000 	cmp	r0, #0
8f635e0c:	1a00000c 	bne	8f635e44 <_fdt_rw_check_header.part.0+0xa0>
	if (fdt_version(fdt) > 17)
8f635e10:	e3540011 	cmp	r4, #17
__fdt_set_hdr(version);
8f635e14:	13a03411 	movne	r3, #285212672	; 0x11000000
8f635e18:	15853014 	strne	r3, [r5, #20]
}
8f635e1c:	e59f302c 	ldr	r3, [pc, #44]	; 8f635e50 <_fdt_rw_check_header.part.0+0xac>
8f635e20:	e5932000 	ldr	r2, [r3]
8f635e24:	e59d3004 	ldr	r3, [r13, #4]
8f635e28:	e0332002 	eors	r2, r3, r2
8f635e2c:	e3a03000 	mov	r3, #0
8f635e30:	1a000005 	bne	8f635e4c <_fdt_rw_check_header.part.0+0xa8>
8f635e34:	e28dd00c 	add	r13, r13, #12
8f635e38:	e8bd8030 	pop	{r4, r5, r15}
		return -FDT_ERR_BADVERSION;
8f635e3c:	e3e00009 	mvn	r0, #9
8f635e40:	eafffff5 	b	8f635e1c <_fdt_rw_check_header.part.0+0x78>
		return -FDT_ERR_BADLAYOUT;
8f635e44:	e3e0000b 	mvn	r0, #11
8f635e48:	eafffff3 	b	8f635e1c <_fdt_rw_check_header.part.0+0x78>
}
8f635e4c:	ebfff35b 	bl	8f632bc0 <__stack_chk_fail>
8f635e50:	8f74221c 	.word	0x8f74221c

8f635e54 <_fdt_splice>:
{
8f635e54:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f635e58:	e1a04001 	mov	r4, r1
	return fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
8f635e5c:	e590e00c 	ldr	r14, [r0, #12]
{
8f635e60:	e24dd00c 	sub	r13, r13, #12
8f635e64:	e59f10dc 	ldr	r1, [pc, #220]	; 8f635f48 <_fdt_splice+0xf4>
8f635e68:	e7e7545e 	ubfx	r5, r14, #8, #8
8f635e6c:	e1a0cc2e 	lsr	r12, r14, #24
8f635e70:	e5911000 	ldr	r1, [r1]
8f635e74:	e58d1004 	str	r1, [r13, #4]
8f635e78:	e3a01000 	mov	r1, #0
	return fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
8f635e7c:	e5901020 	ldr	r1, [r0, #32]
8f635e80:	e18ccc0e 	orr	r12, r12, r14, lsl #24
8f635e84:	e7e7e85e 	ubfx	r14, r14, #16, #8
8f635e88:	e18cc805 	orr	r12, r12, r5, lsl #16
8f635e8c:	e7e75451 	ubfx	r5, r1, #8, #8
8f635e90:	e18cc40e 	orr	r12, r12, r14, lsl #8
8f635e94:	e1a0ec21 	lsr	r14, r1, #24
8f635e98:	e18eec01 	orr	r14, r14, r1, lsl #24
8f635e9c:	e7e71851 	ubfx	r1, r1, #16, #8
8f635ea0:	e18ee805 	orr	r14, r14, r5, lsl #16
8f635ea4:	e18ee401 	orr	r14, r14, r1, lsl #8
	if (((p + oldlen) < p) || ((p + oldlen) > end))
8f635ea8:	e0841002 	add	r1, r4, r2
8f635eac:	e1510004 	cmp	r1, r4
	return fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
8f635eb0:	e08cc00e 	add	r12, r12, r14
	char *end = (char *)fdt + _fdt_data_size(fdt);
8f635eb4:	e080c00c 	add	r12, r0, r12
	if (((p + oldlen) < p) || ((p + oldlen) > end))
8f635eb8:	23a05000 	movcs	r5, #0
8f635ebc:	33a05001 	movcc	r5, #1
8f635ec0:	e151000c 	cmp	r1, r12
8f635ec4:	83855001 	orrhi	r5, r5, #1
8f635ec8:	e3550000 	cmp	r5, #0
8f635ecc:	1a000018 	bne	8f635f34 <_fdt_splice+0xe0>
	if ((end - oldlen + newlen) > ((char *)fdt + fdt_totalsize(fdt)))
8f635ed0:	e5906004 	ldr	r6, [r0, #4]
8f635ed4:	e0437002 	sub	r7, r3, r2
8f635ed8:	e08c7007 	add	r7, r12, r7
8f635edc:	e7e79456 	ubfx	r9, r6, #8, #8
8f635ee0:	e7e78856 	ubfx	r8, r6, #16, #8
8f635ee4:	e1a0ec26 	lsr	r14, r6, #24
8f635ee8:	e18eec06 	orr	r14, r14, r6, lsl #24
8f635eec:	e18ee809 	orr	r14, r14, r9, lsl #16
8f635ef0:	e18ee408 	orr	r14, r14, r8, lsl #8
8f635ef4:	e080e00e 	add	r14, r0, r14
8f635ef8:	e157000e 	cmp	r7, r14
8f635efc:	8a00000e 	bhi	8f635f3c <_fdt_splice+0xe8>
	memmove(p + newlen, p + oldlen, end - p - oldlen);
8f635f00:	e04cc004 	sub	r12, r12, r4
8f635f04:	e0840003 	add	r0, r4, r3
8f635f08:	e04c2002 	sub	r2, r12, r2
8f635f0c:	ebfff8a9 	bl	8f6341b8 <memcpy>
	return 0;
8f635f10:	e1a00005 	mov	r0, r5
}
8f635f14:	e59f302c 	ldr	r3, [pc, #44]	; 8f635f48 <_fdt_splice+0xf4>
8f635f18:	e5932000 	ldr	r2, [r3]
8f635f1c:	e59d3004 	ldr	r3, [r13, #4]
8f635f20:	e0332002 	eors	r2, r3, r2
8f635f24:	e3a03000 	mov	r3, #0
8f635f28:	1a000005 	bne	8f635f44 <_fdt_splice+0xf0>
8f635f2c:	e28dd00c 	add	r13, r13, #12
8f635f30:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
		return -FDT_ERR_BADOFFSET;
8f635f34:	e3e00003 	mvn	r0, #3
8f635f38:	eafffff5 	b	8f635f14 <_fdt_splice+0xc0>
		return -FDT_ERR_NOSPACE;
8f635f3c:	e3e00002 	mvn	r0, #2
8f635f40:	eafffff3 	b	8f635f14 <_fdt_splice+0xc0>
}
8f635f44:	ebfff31d 	bl	8f632bc0 <__stack_chk_fail>
8f635f48:	8f74221c 	.word	0x8f74221c

8f635f4c <_fdt_splice_struct>:
{
8f635f4c:	e59fc0a0 	ldr	r12, [pc, #160]	; 8f635ff4 <_fdt_splice_struct+0xa8>
8f635f50:	e92d4070 	push	{r4, r5, r6, r14}
8f635f54:	e24dd008 	sub	r13, r13, #8
8f635f58:	e59cc000 	ldr	r12, [r12]
8f635f5c:	e58dc004 	str	r12, [r13, #4]
8f635f60:	e3a0c000 	mov	r12, #0
8f635f64:	e1a04000 	mov	r4, r0
8f635f68:	e1a05002 	mov	r5, r2
8f635f6c:	e1a06003 	mov	r6, r3
	if ((err = _fdt_splice(fdt, p, oldlen, newlen)))
8f635f70:	ebffffb7 	bl	8f635e54 <_fdt_splice>
8f635f74:	e3500000 	cmp	r0, #0
8f635f78:	1a000014 	bne	8f635fd0 <_fdt_splice_struct+0x84>
	fdt_set_size_dt_struct(fdt, fdt_size_dt_struct(fdt) + delta);
8f635f7c:	e594e024 	ldr	r14, [r4, #36]	; 0x24
	int delta = newlen - oldlen;
8f635f80:	e0461005 	sub	r1, r6, r5
	fdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);
8f635f84:	e594c00c 	ldr	r12, [r4, #12]
8f635f88:	e7e7345e 	ubfx	r3, r14, #8, #8
8f635f8c:	e1a02c2e 	lsr	r2, r14, #24
8f635f90:	e1822c0e 	orr	r2, r2, r14, lsl #24
8f635f94:	e7e7e85e 	ubfx	r14, r14, #16, #8
8f635f98:	e1822803 	orr	r2, r2, r3, lsl #16
8f635f9c:	e1a03c2c 	lsr	r3, r12, #24
8f635fa0:	e182240e 	orr	r2, r2, r14, lsl #8
8f635fa4:	e1833c0c 	orr	r3, r3, r12, lsl #24
	fdt_set_size_dt_struct(fdt, fdt_size_dt_struct(fdt) + delta);
8f635fa8:	e0822001 	add	r2, r2, r1
8f635fac:	e6bf2f32 	rev	r2, r2
__fdt_set_hdr(size_dt_struct);
8f635fb0:	e5842024 	str	r2, [r4, #36]	; 0x24
8f635fb4:	e7e7245c 	ubfx	r2, r12, #8, #8
8f635fb8:	e7e7c85c 	ubfx	r12, r12, #16, #8
8f635fbc:	e1833802 	orr	r3, r3, r2, lsl #16
8f635fc0:	e183340c 	orr	r3, r3, r12, lsl #8
	fdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);
8f635fc4:	e0833001 	add	r3, r3, r1
8f635fc8:	e6bf3f33 	rev	r3, r3
__fdt_set_hdr(off_dt_strings);
8f635fcc:	e584300c 	str	r3, [r4, #12]
}
8f635fd0:	e59f301c 	ldr	r3, [pc, #28]	; 8f635ff4 <_fdt_splice_struct+0xa8>
8f635fd4:	e5932000 	ldr	r2, [r3]
8f635fd8:	e59d3004 	ldr	r3, [r13, #4]
8f635fdc:	e0332002 	eors	r2, r3, r2
8f635fe0:	e3a03000 	mov	r3, #0
8f635fe4:	1a000001 	bne	8f635ff0 <_fdt_splice_struct+0xa4>
8f635fe8:	e28dd008 	add	r13, r13, #8
8f635fec:	e8bd8070 	pop	{r4, r5, r6, r15}
8f635ff0:	ebfff2f2 	bl	8f632bc0 <__stack_chk_fail>
8f635ff4:	8f74221c 	.word	0x8f74221c

8f635ff8 <_fdt_add_property>:
{
8f635ff8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f635ffc:	e1a07003 	mov	r7, r3
8f636000:	e24dd014 	sub	r13, r13, #20
8f636004:	e59f31e8 	ldr	r3, [pc, #488]	; 8f6361f4 <_fdt_add_property+0x1fc>
8f636008:	e1a05000 	mov	r5, r0
8f63600c:	e1a08002 	mov	r8, r2
8f636010:	e59d9038 	ldr	r9, [r13, #56]	; 0x38
8f636014:	e5933000 	ldr	r3, [r3]
8f636018:	e58d300c 	str	r3, [r13, #12]
8f63601c:	e3a03000 	mov	r3, #0
	if ((nextoffset = _fdt_check_node_offset(fdt, nodeoffset)) < 0)
8f636020:	ebfffbde 	bl	8f634fa0 <_fdt_check_node_offset>
8f636024:	e2504000 	subs	r4, r0, #0
8f636028:	ba00003d 	blt	8f636124 <_fdt_add_property+0x12c>
	char *strtab = (char *)fdt + fdt_off_dt_strings(fdt);
8f63602c:	e595300c 	ldr	r3, [r5, #12]
	int len = strlen(s) + 1;
8f636030:	e1a00008 	mov	r0, r8
8f636034:	e7e71453 	ubfx	r1, r3, #8, #8
8f636038:	e7e72853 	ubfx	r2, r3, #16, #8
8f63603c:	e1a06c23 	lsr	r6, r3, #24
8f636040:	e1866c03 	orr	r6, r6, r3, lsl #24
8f636044:	e1866801 	orr	r6, r6, r1, lsl #16
8f636048:	e1866402 	orr	r6, r6, r2, lsl #8
8f63604c:	ebfff9ed 	bl	8f634808 <strlen>
	p = _fdt_find_string(strtab, fdt_size_dt_strings(fdt), s);
8f636050:	e5951020 	ldr	r1, [r5, #32]
	char *strtab = (char *)fdt + fdt_off_dt_strings(fdt);
8f636054:	e0856006 	add	r6, r5, r6
	p = _fdt_find_string(strtab, fdt_size_dt_strings(fdt), s);
8f636058:	e1a02008 	mov	r2, r8
8f63605c:	e7e7e451 	ubfx	r14, r1, #8, #8
8f636060:	e7e7c851 	ubfx	r12, r1, #16, #8
8f636064:	e1a03c21 	lsr	r3, r1, #24
8f636068:	e1833c01 	orr	r3, r3, r1, lsl #24
8f63606c:	e183180e 	orr	r1, r3, r14, lsl #16
8f636070:	e181140c 	orr	r1, r1, r12, lsl #8
	int len = strlen(s) + 1;
8f636074:	e1a0b000 	mov	r11, r0
	p = _fdt_find_string(strtab, fdt_size_dt_strings(fdt), s);
8f636078:	e1a00006 	mov	r0, r6
8f63607c:	ebfffc46 	bl	8f63519c <_fdt_find_string>
	if (p)
8f636080:	e2502000 	subs	r2, r0, #0
		return (p - strtab);
8f636084:	1042a006 	subne	r10, r2, r6
	if (p)
8f636088:	0a00002e 	beq	8f636148 <_fdt_add_property+0x150>
	if (namestroff < 0)
8f63608c:	e35a0000 	cmp	r10, #0
8f636090:	b1a0400a 	movlt	r4, r10
8f636094:	ba000022 	blt	8f636124 <_fdt_add_property+0x12c>
8f636098:	e5952008 	ldr	r2, [r5, #8]
	proplen = sizeof(**prop) + FDT_TAGALIGN(len);
8f63609c:	e2873003 	add	r3, r7, #3
8f6360a0:	e3c33003 	bic	r3, r3, #3
8f6360a4:	e7e70452 	ubfx	r0, r2, #8, #8
	err = _fdt_splice_struct(fdt, *prop, 0, proplen);
8f6360a8:	e283300c 	add	r3, r3, #12
8f6360ac:	e1a01c22 	lsr	r1, r2, #24
8f6360b0:	e1811c02 	orr	r1, r1, r2, lsl #24
8f6360b4:	e7e72852 	ubfx	r2, r2, #16, #8
8f6360b8:	e1811800 	orr	r1, r1, r0, lsl #16
8f6360bc:	e1a00005 	mov	r0, r5
8f6360c0:	e1811402 	orr	r1, r1, r2, lsl #8
8f6360c4:	e3a02000 	mov	r2, #0
8f6360c8:	e0811004 	add	r1, r1, r4
8f6360cc:	e0851001 	add	r1, r5, r1
	*prop = _fdt_offset_ptr_w(fdt, nextoffset);
8f6360d0:	e5891000 	str	r1, [r9]
	err = _fdt_splice_struct(fdt, *prop, 0, proplen);
8f6360d4:	ebffff9c 	bl	8f635f4c <_fdt_splice_struct>
	if (err)
8f6360d8:	e2504000 	subs	r4, r0, #0
8f6360dc:	1a000010 	bne	8f636124 <_fdt_add_property+0x12c>
	(*prop)->tag = cpu_to_fdt32(FDT_PROP);
8f6360e0:	e5991000 	ldr	r1, [r9]
8f6360e4:	e7e7245a 	ubfx	r2, r10, #8, #8
8f6360e8:	e3a03403 	mov	r3, #50331648	; 0x3000000
8f6360ec:	e5813000 	str	r3, [r1]
8f6360f0:	e1a03c2a 	lsr	r3, r10, #24
8f6360f4:	e1833c0a 	orr	r3, r3, r10, lsl #24
8f6360f8:	e7e7a85a 	ubfx	r10, r10, #16, #8
8f6360fc:	e1833802 	orr	r3, r3, r2, lsl #16
8f636100:	e7e72457 	ubfx	r2, r7, #8, #8
8f636104:	e183a40a 	orr	r10, r3, r10, lsl #8
8f636108:	e1a03c27 	lsr	r3, r7, #24
8f63610c:	e1833c07 	orr	r3, r3, r7, lsl #24
8f636110:	e7e77857 	ubfx	r7, r7, #16, #8
8f636114:	e1833802 	orr	r3, r3, r2, lsl #16
	(*prop)->nameoff = cpu_to_fdt32(namestroff);
8f636118:	e581a008 	str	r10, [r1, #8]
8f63611c:	e1837407 	orr	r7, r3, r7, lsl #8
	(*prop)->len = cpu_to_fdt32(len);
8f636120:	e5817004 	str	r7, [r1, #4]
}
8f636124:	e59f30c8 	ldr	r3, [pc, #200]	; 8f6361f4 <_fdt_add_property+0x1fc>
8f636128:	e5932000 	ldr	r2, [r3]
8f63612c:	e59d300c 	ldr	r3, [r13, #12]
8f636130:	e0332002 	eors	r2, r3, r2
8f636134:	e3a03000 	mov	r3, #0
8f636138:	1a00002c 	bne	8f6361f0 <_fdt_add_property+0x1f8>
8f63613c:	e1a00004 	mov	r0, r4
8f636140:	e28dd014 	add	r13, r13, #20
8f636144:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	new = strtab + fdt_size_dt_strings(fdt);
8f636148:	e595c020 	ldr	r12, [r5, #32]
	int len = strlen(s) + 1;
8f63614c:	e28b3001 	add	r3, r11, #1
		+ fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
8f636150:	e595100c 	ldr	r1, [r5, #12]
	if ((err = _fdt_splice(fdt, p, 0, newlen)))
8f636154:	e1a00005 	mov	r0, r5
8f636158:	e7e7b45c 	ubfx	r11, r12, #8, #8
8f63615c:	e58d3004 	str	r3, [r13, #4]
8f636160:	e1a0ec2c 	lsr	r14, r12, #24
8f636164:	e7e7a451 	ubfx	r10, r1, #8, #8
8f636168:	e18eec0c 	orr	r14, r14, r12, lsl #24
8f63616c:	e7e7c85c 	ubfx	r12, r12, #16, #8
8f636170:	e18eb80b 	orr	r11, r14, r11, lsl #16
8f636174:	e18bb40c 	orr	r11, r11, r12, lsl #8
8f636178:	e1a0cc21 	lsr	r12, r1, #24
8f63617c:	e18ccc01 	orr	r12, r12, r1, lsl #24
8f636180:	e7e71851 	ubfx	r1, r1, #16, #8
8f636184:	e18ca80a 	orr	r10, r12, r10, lsl #16
8f636188:	e18a1401 	orr	r1, r10, r1, lsl #8
		+ fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
8f63618c:	e081100b 	add	r1, r1, r11
	if ((err = _fdt_splice(fdt, p, 0, newlen)))
8f636190:	e0851001 	add	r1, r5, r1
8f636194:	ebffff2e 	bl	8f635e54 <_fdt_splice>
8f636198:	e250a000 	subs	r10, r0, #0
8f63619c:	1affffba 	bne	8f63608c <_fdt_add_property+0x94>
	fdt_set_size_dt_strings(fdt, fdt_size_dt_strings(fdt) + newlen);
8f6361a0:	e595c020 	ldr	r12, [r5, #32]
	memcpy(new, s, len);
8f6361a4:	e086000b 	add	r0, r6, r11
8f6361a8:	e1a0a00b 	mov	r10, r11
8f6361ac:	e59d3004 	ldr	r3, [r13, #4]
8f6361b0:	e7e7645c 	ubfx	r6, r12, #8, #8
8f6361b4:	e7e7e85c 	ubfx	r14, r12, #16, #8
8f6361b8:	e1a0bc2c 	lsr	r11, r12, #24
8f6361bc:	e1a01008 	mov	r1, r8
8f6361c0:	e18bbc0c 	orr	r11, r11, r12, lsl #24
8f6361c4:	e1a02003 	mov	r2, r3
8f6361c8:	e18bb806 	orr	r11, r11, r6, lsl #16
8f6361cc:	e18bb40e 	orr	r11, r11, r14, lsl #8
	fdt_set_size_dt_strings(fdt, fdt_size_dt_strings(fdt) + newlen);
8f6361d0:	e08bb003 	add	r11, r11, r3
8f6361d4:	e6bfbf3b 	rev	r11, r11
__fdt_set_hdr(size_dt_strings);
8f6361d8:	e585b020 	str	r11, [r5, #32]
	memcpy(new, s, len);
8f6361dc:	ebfff7f5 	bl	8f6341b8 <memcpy>
	if (namestroff < 0)
8f6361e0:	e35a0000 	cmp	r10, #0
8f6361e4:	b1a0400a 	movlt	r4, r10
8f6361e8:	aaffffaa 	bge	8f636098 <_fdt_add_property+0xa0>
8f6361ec:	eaffffcc 	b	8f636124 <_fdt_add_property+0x12c>
}
8f6361f0:	ebfff272 	bl	8f632bc0 <__stack_chk_fail>
8f6361f4:	8f74221c 	.word	0x8f74221c

8f6361f8 <fdt_setprop>:
{
8f6361f8:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f6361fc:	e1a08003 	mov	r8, r3
8f636200:	e24dd01c 	sub	r13, r13, #28
8f636204:	e59f3120 	ldr	r3, [pc, #288]	; 8f63632c <fdt_setprop+0x134>
8f636208:	e1a05000 	mov	r5, r0
8f63620c:	e1a06001 	mov	r6, r1
8f636210:	e59d9038 	ldr	r9, [r13, #56]	; 0x38
8f636214:	e5933000 	ldr	r3, [r3]
8f636218:	e58d3014 	str	r3, [r13, #20]
8f63621c:	e3a03000 	mov	r3, #0
8f636220:	e1a07002 	mov	r7, r2
	FDT_CHECK_HEADER(fdt);
8f636224:	ebfffa78 	bl	8f634c0c <fdt_check_header>
8f636228:	e2504000 	subs	r4, r0, #0
8f63622c:	1a000021 	bne	8f6362b8 <fdt_setprop+0xc0>
8f636230:	e1a00005 	mov	r0, r5
8f636234:	ebfffeda 	bl	8f635da4 <_fdt_rw_check_header.part.0>
	FDT_RW_CHECK_HEADER(fdt);
8f636238:	e2504000 	subs	r4, r0, #0
8f63623c:	1a00001d 	bne	8f6362b8 <fdt_setprop+0xc0>
		fdt_get_property(fdt, nodeoffset, name, lenp);
8f636240:	e28d3010 	add	r3, r13, #16
8f636244:	e1a02007 	mov	r2, r7
8f636248:	e1a01006 	mov	r1, r6
8f63624c:	e1a00005 	mov	r0, r5
8f636250:	ebfffd9a 	bl	8f6358c0 <fdt_get_property>
	if (! (*prop))
8f636254:	e3500000 	cmp	r0, #0
	*prop = fdt_get_property_w(fdt, nodeoffset, name, &oldlen);
8f636258:	e58d000c 	str	r0, [r13, #12]
	if (! (*prop))
8f63625c:	0a00001e 	beq	8f6362dc <fdt_setprop+0xe4>
	if ((err = _fdt_splice_struct(fdt, (*prop)->data, FDT_TAGALIGN(oldlen),
8f636260:	e59d2010 	ldr	r2, [r13, #16]
				      FDT_TAGALIGN(len))))
8f636264:	e2893003 	add	r3, r9, #3
	if ((err = _fdt_splice_struct(fdt, (*prop)->data, FDT_TAGALIGN(oldlen),
8f636268:	e280100c 	add	r1, r0, #12
8f63626c:	e3c33003 	bic	r3, r3, #3
8f636270:	e2822003 	add	r2, r2, #3
8f636274:	e1a00005 	mov	r0, r5
8f636278:	e3c22003 	bic	r2, r2, #3
8f63627c:	ebffff32 	bl	8f635f4c <_fdt_splice_struct>
8f636280:	e3500000 	cmp	r0, #0
8f636284:	1a000022 	bne	8f636314 <fdt_setprop+0x11c>
8f636288:	e7e72459 	ubfx	r2, r9, #8, #8
8f63628c:	e1a03c29 	lsr	r3, r9, #24
	(*prop)->len = cpu_to_fdt32(len);
8f636290:	e59d000c 	ldr	r0, [r13, #12]
8f636294:	e1833c09 	orr	r3, r3, r9, lsl #24
8f636298:	e1833802 	orr	r3, r3, r2, lsl #16
8f63629c:	e7e72859 	ubfx	r2, r9, #16, #8
8f6362a0:	e1833402 	orr	r3, r3, r2, lsl #8
8f6362a4:	e5803004 	str	r3, [r0, #4]
	memcpy(prop->data, val, len);
8f6362a8:	e280000c 	add	r0, r0, #12
8f6362ac:	e1a02009 	mov	r2, r9
8f6362b0:	e1a01008 	mov	r1, r8
8f6362b4:	ebfff7bf 	bl	8f6341b8 <memcpy>
}
8f6362b8:	e59f306c 	ldr	r3, [pc, #108]	; 8f63632c <fdt_setprop+0x134>
8f6362bc:	e5932000 	ldr	r2, [r3]
8f6362c0:	e59d3014 	ldr	r3, [r13, #20]
8f6362c4:	e0332002 	eors	r2, r3, r2
8f6362c8:	e3a03000 	mov	r3, #0
8f6362cc:	1a000015 	bne	8f636328 <fdt_setprop+0x130>
8f6362d0:	e1a00004 	mov	r0, r4
8f6362d4:	e28dd01c 	add	r13, r13, #28
8f6362d8:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
		return oldlen;
8f6362dc:	e59d0010 	ldr	r0, [r13, #16]
	if (err == -FDT_ERR_NOTFOUND)
8f6362e0:	e3700001 	cmn	r0, #1
8f6362e4:	1a000006 	bne	8f636304 <fdt_setprop+0x10c>
		err = _fdt_add_property(fdt, nodeoffset, name, len, &prop);
8f6362e8:	e28d300c 	add	r3, r13, #12
8f6362ec:	e1a02007 	mov	r2, r7
8f6362f0:	e58d3000 	str	r3, [r13]
8f6362f4:	e1a01006 	mov	r1, r6
8f6362f8:	e1a00005 	mov	r0, r5
8f6362fc:	e1a03009 	mov	r3, r9
8f636300:	ebffff3c 	bl	8f635ff8 <_fdt_add_property>
	if (err)
8f636304:	e3500000 	cmp	r0, #0
8f636308:	0a000004 	beq	8f636320 <fdt_setprop+0x128>
	if (err == -FDT_ERR_NOTFOUND)
8f63630c:	e1a04000 	mov	r4, r0
8f636310:	eaffffe8 	b	8f6362b8 <fdt_setprop+0xc0>
8f636314:	e3700001 	cmn	r0, #1
8f636318:	0afffff2 	beq	8f6362e8 <fdt_setprop+0xf0>
8f63631c:	eafffffa 	b	8f63630c <fdt_setprop+0x114>
	memcpy(prop->data, val, len);
8f636320:	e59d000c 	ldr	r0, [r13, #12]
8f636324:	eaffffdf 	b	8f6362a8 <fdt_setprop+0xb0>
}
8f636328:	ebfff224 	bl	8f632bc0 <__stack_chk_fail>
8f63632c:	8f74221c 	.word	0x8f74221c

8f636330 <fdt_appendprop>:
{
8f636330:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f636334:	e1a08003 	mov	r8, r3
8f636338:	e24dd01c 	sub	r13, r13, #28
8f63633c:	e59f3120 	ldr	r3, [pc, #288]	; 8f636464 <fdt_appendprop+0x134>
8f636340:	e1a05000 	mov	r5, r0
8f636344:	e1a06001 	mov	r6, r1
8f636348:	e59d9038 	ldr	r9, [r13, #56]	; 0x38
8f63634c:	e5933000 	ldr	r3, [r3]
8f636350:	e58d3014 	str	r3, [r13, #20]
8f636354:	e3a03000 	mov	r3, #0
8f636358:	e1a07002 	mov	r7, r2
	FDT_CHECK_HEADER(fdt);
8f63635c:	ebfffa2a 	bl	8f634c0c <fdt_check_header>
8f636360:	e2504000 	subs	r4, r0, #0
8f636364:	1a000016 	bne	8f6363c4 <fdt_appendprop+0x94>
8f636368:	e1a00005 	mov	r0, r5
8f63636c:	ebfffe8c 	bl	8f635da4 <_fdt_rw_check_header.part.0>
	FDT_RW_CHECK_HEADER(fdt);
8f636370:	e2504000 	subs	r4, r0, #0
8f636374:	1a000012 	bne	8f6363c4 <fdt_appendprop+0x94>
8f636378:	e28d3010 	add	r3, r13, #16
8f63637c:	e1a02007 	mov	r2, r7
8f636380:	e1a01006 	mov	r1, r6
8f636384:	e1a00005 	mov	r0, r5
8f636388:	ebfffd4c 	bl	8f6358c0 <fdt_get_property>
	if (prop) {
8f63638c:	e3500000 	cmp	r0, #0
	prop = fdt_get_property_w(fdt, nodeoffset, name, &oldlen);
8f636390:	e58d000c 	str	r0, [r13, #12]
	if (prop) {
8f636394:	0a000022 	beq	8f636424 <fdt_appendprop+0xf4>
		newlen = len + oldlen;
8f636398:	e59d2010 	ldr	r2, [r13, #16]
		err = _fdt_splice_struct(fdt, prop->data,
8f63639c:	e280100c 	add	r1, r0, #12
8f6363a0:	e1a00005 	mov	r0, r5
		newlen = len + oldlen;
8f6363a4:	e0825009 	add	r5, r2, r9
					 FDT_TAGALIGN(oldlen),
8f6363a8:	e2822003 	add	r2, r2, #3
					 FDT_TAGALIGN(newlen));
8f6363ac:	e2853003 	add	r3, r5, #3
		err = _fdt_splice_struct(fdt, prop->data,
8f6363b0:	e3c22003 	bic	r2, r2, #3
8f6363b4:	e3c33003 	bic	r3, r3, #3
8f6363b8:	ebfffee3 	bl	8f635f4c <_fdt_splice_struct>
		if (err)
8f6363bc:	e2504000 	subs	r4, r0, #0
8f6363c0:	0a000008 	beq	8f6363e8 <fdt_appendprop+0xb8>
}
8f6363c4:	e59f3098 	ldr	r3, [pc, #152]	; 8f636464 <fdt_appendprop+0x134>
8f6363c8:	e5932000 	ldr	r2, [r3]
8f6363cc:	e59d3014 	ldr	r3, [r13, #20]
8f6363d0:	e0332002 	eors	r2, r3, r2
8f6363d4:	e3a03000 	mov	r3, #0
8f6363d8:	1a000020 	bne	8f636460 <fdt_appendprop+0x130>
8f6363dc:	e1a00004 	mov	r0, r4
8f6363e0:	e28dd01c 	add	r13, r13, #28
8f6363e4:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
8f6363e8:	e7e7c455 	ubfx	r12, r5, #8, #8
8f6363ec:	e1a03c25 	lsr	r3, r5, #24
		prop->len = cpu_to_fdt32(newlen);
8f6363f0:	e59d000c 	ldr	r0, [r13, #12]
8f6363f4:	e1833c05 	orr	r3, r3, r5, lsl #24
8f6363f8:	e7e75855 	ubfx	r5, r5, #16, #8
8f6363fc:	e183380c 	orr	r3, r3, r12, lsl #16
		memcpy(prop->data + oldlen, val, len);
8f636400:	e280000c 	add	r0, r0, #12
8f636404:	e1a02009 	mov	r2, r9
8f636408:	e1835405 	orr	r5, r3, r5, lsl #8
8f63640c:	e59d3010 	ldr	r3, [r13, #16]
		prop->len = cpu_to_fdt32(newlen);
8f636410:	e5005008 	str	r5, [r0, #-8]
		memcpy(prop->data + oldlen, val, len);
8f636414:	e1a01008 	mov	r1, r8
8f636418:	e0800003 	add	r0, r0, r3
8f63641c:	ebfff765 	bl	8f6341b8 <memcpy>
8f636420:	eaffffe7 	b	8f6363c4 <fdt_appendprop+0x94>
		err = _fdt_add_property(fdt, nodeoffset, name, len, &prop);
8f636424:	e28d300c 	add	r3, r13, #12
8f636428:	e1a02007 	mov	r2, r7
8f63642c:	e58d3000 	str	r3, [r13]
8f636430:	e1a01006 	mov	r1, r6
8f636434:	e1a00005 	mov	r0, r5
8f636438:	e1a03009 	mov	r3, r9
8f63643c:	ebfffeed 	bl	8f635ff8 <_fdt_add_property>
		if (err)
8f636440:	e2504000 	subs	r4, r0, #0
8f636444:	1affffde 	bne	8f6363c4 <fdt_appendprop+0x94>
		memcpy(prop->data, val, len);
8f636448:	e59d000c 	ldr	r0, [r13, #12]
8f63644c:	e1a02009 	mov	r2, r9
8f636450:	e1a01008 	mov	r1, r8
8f636454:	e280000c 	add	r0, r0, #12
8f636458:	ebfff756 	bl	8f6341b8 <memcpy>
8f63645c:	eaffffd8 	b	8f6363c4 <fdt_appendprop+0x94>
}
8f636460:	ebfff1d6 	bl	8f632bc0 <__stack_chk_fail>
8f636464:	8f74221c 	.word	0x8f74221c

8f636468 <fdt_appendprop_str>:
{
8f636468:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
8f63646c:	e1a08003 	mov	r8, r3
8f636470:	e24dd01c 	sub	r13, r13, #28
8f636474:	e59f312c 	ldr	r3, [pc, #300]	; 8f6365a8 <fdt_appendprop_str+0x140>
8f636478:	e1a05000 	mov	r5, r0
8f63647c:	e1a06001 	mov	r6, r1
8f636480:	e59d9038 	ldr	r9, [r13, #56]	; 0x38
8f636484:	e5933000 	ldr	r3, [r3]
8f636488:	e58d3014 	str	r3, [r13, #20]
8f63648c:	e3a03000 	mov	r3, #0
8f636490:	e1a07002 	mov	r7, r2
	FDT_CHECK_HEADER(fdt);
8f636494:	ebfff9dc 	bl	8f634c0c <fdt_check_header>
8f636498:	e2504000 	subs	r4, r0, #0
8f63649c:	1a000016 	bne	8f6364fc <fdt_appendprop_str+0x94>
8f6364a0:	e1a00005 	mov	r0, r5
8f6364a4:	ebfffe3e 	bl	8f635da4 <_fdt_rw_check_header.part.0>
	FDT_RW_CHECK_HEADER(fdt);
8f6364a8:	e2504000 	subs	r4, r0, #0
8f6364ac:	1a000012 	bne	8f6364fc <fdt_appendprop_str+0x94>
8f6364b0:	e28d3010 	add	r3, r13, #16
8f6364b4:	e1a02007 	mov	r2, r7
8f6364b8:	e1a01006 	mov	r1, r6
8f6364bc:	e1a00005 	mov	r0, r5
8f6364c0:	ebfffcfe 	bl	8f6358c0 <fdt_get_property>
	if (prop) {
8f6364c4:	e3500000 	cmp	r0, #0
	prop = fdt_get_property_w(fdt, nodeoffset, name, &oldlen);
8f6364c8:	e58d000c 	str	r0, [r13, #12]
	if (prop) {
8f6364cc:	0a000025 	beq	8f636568 <fdt_appendprop_str+0x100>
		newlen = len + oldlen;
8f6364d0:	e59d2010 	ldr	r2, [r13, #16]
		err = _fdt_splice_struct(fdt, prop->data,
8f6364d4:	e280100c 	add	r1, r0, #12
8f6364d8:	e1a00005 	mov	r0, r5
		newlen = len + oldlen;
8f6364dc:	e0825009 	add	r5, r2, r9
					 FDT_TAGALIGN(oldlen),
8f6364e0:	e2822003 	add	r2, r2, #3
					 FDT_TAGALIGN(newlen));
8f6364e4:	e2853003 	add	r3, r5, #3
		err = _fdt_splice_struct(fdt, prop->data,
8f6364e8:	e3c22003 	bic	r2, r2, #3
8f6364ec:	e3c33003 	bic	r3, r3, #3
8f6364f0:	ebfffe95 	bl	8f635f4c <_fdt_splice_struct>
		if (err)
8f6364f4:	e2504000 	subs	r4, r0, #0
8f6364f8:	0a000008 	beq	8f636520 <fdt_appendprop_str+0xb8>
}
8f6364fc:	e59f30a4 	ldr	r3, [pc, #164]	; 8f6365a8 <fdt_appendprop_str+0x140>
8f636500:	e5932000 	ldr	r2, [r3]
8f636504:	e59d3014 	ldr	r3, [r13, #20]
8f636508:	e0332002 	eors	r2, r3, r2
8f63650c:	e3a03000 	mov	r3, #0
8f636510:	1a000023 	bne	8f6365a4 <fdt_appendprop_str+0x13c>
8f636514:	e1a00004 	mov	r0, r4
8f636518:	e28dd01c 	add	r13, r13, #28
8f63651c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
8f636520:	e7e7e455 	ubfx	r14, r5, #8, #8
8f636524:	e1a03c25 	lsr	r3, r5, #24
		prop->len = cpu_to_fdt32(newlen);
8f636528:	e59dc00c 	ldr	r12, [r13, #12]
8f63652c:	e1833c05 	orr	r3, r3, r5, lsl #24
		prop->data[oldlen-1] = 0x20;
8f636530:	e59d0010 	ldr	r0, [r13, #16]
8f636534:	e7e75855 	ubfx	r5, r5, #16, #8
8f636538:	e183380e 	orr	r3, r3, r14, lsl #16
		memcpy(prop->data + oldlen, val, len);
8f63653c:	e1a02009 	mov	r2, r9
8f636540:	e1835405 	orr	r5, r3, r5, lsl #8
		prop->data[oldlen-1] = 0x20;
8f636544:	e08c3000 	add	r3, r12, r0
		prop->len = cpu_to_fdt32(newlen);
8f636548:	e58c5004 	str	r5, [r12, #4]
		memcpy(prop->data + oldlen, val, len);
8f63654c:	e28cc00c 	add	r12, r12, #12
8f636550:	e08c0000 	add	r0, r12, r0
8f636554:	e1a01008 	mov	r1, r8
		prop->data[oldlen-1] = 0x20;
8f636558:	e3a0c020 	mov	r12, #32
8f63655c:	e5c3c00b 	strb	r12, [r3, #11]
		memcpy(prop->data + oldlen, val, len);
8f636560:	ebfff714 	bl	8f6341b8 <memcpy>
8f636564:	eaffffe4 	b	8f6364fc <fdt_appendprop_str+0x94>
		err = _fdt_add_property(fdt, nodeoffset, name, len, &prop);
8f636568:	e28d300c 	add	r3, r13, #12
8f63656c:	e1a02007 	mov	r2, r7
8f636570:	e58d3000 	str	r3, [r13]
8f636574:	e1a01006 	mov	r1, r6
8f636578:	e1a00005 	mov	r0, r5
8f63657c:	e1a03009 	mov	r3, r9
8f636580:	ebfffe9c 	bl	8f635ff8 <_fdt_add_property>
		if (err)
8f636584:	e2504000 	subs	r4, r0, #0
8f636588:	1affffdb 	bne	8f6364fc <fdt_appendprop_str+0x94>
		memcpy(prop->data, val, len);
8f63658c:	e59d000c 	ldr	r0, [r13, #12]
8f636590:	e1a02009 	mov	r2, r9
8f636594:	e1a01008 	mov	r1, r8
8f636598:	e280000c 	add	r0, r0, #12
8f63659c:	ebfff705 	bl	8f6341b8 <memcpy>
8f6365a0:	eaffffd5 	b	8f6364fc <fdt_appendprop_str+0x94>
}
8f6365a4:	ebfff185 	bl	8f632bc0 <__stack_chk_fail>
8f6365a8:	8f74221c 	.word	0x8f74221c

8f6365ac <fdt_open_into>:
	uint32_t newsize;
	const char *fdtstart = fdt;
	const char *fdtend = NULL;
	char *tmp;

	if (fdtstart + fdt_totalsize(fdt) < fdtstart) {
8f6365ac:	e590c004 	ldr	r12, [r0, #4]
{
8f6365b0:	e59f32a4 	ldr	r3, [pc, #676]	; 8f63685c <fdt_open_into+0x2b0>
8f6365b4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f6365b8:	e24dd00c 	sub	r13, r13, #12
8f6365bc:	e5933000 	ldr	r3, [r3]
8f6365c0:	e58d3004 	str	r3, [r13, #4]
8f6365c4:	e3a03000 	mov	r3, #0
8f6365c8:	e1a06001 	mov	r6, r1
8f6365cc:	e1a03c2c 	lsr	r3, r12, #24
8f6365d0:	e7e7145c 	ubfx	r1, r12, #8, #8
8f6365d4:	e1833c0c 	orr	r3, r3, r12, lsl #24
8f6365d8:	e1a07002 	mov	r7, r2
8f6365dc:	e7e7285c 	ubfx	r2, r12, #16, #8
8f6365e0:	e1833801 	orr	r3, r3, r1, lsl #16
8f6365e4:	e1833402 	orr	r3, r3, r2, lsl #8
	if (fdtstart + fdt_totalsize(fdt) < fdtstart) {
8f6365e8:	e0905003 	adds	r5, r0, r3
8f6365ec:	2a000097 	bcs	8f636850 <fdt_open_into+0x2a4>
		return err;
	}
	fdtend = fdtstart + fdt_totalsize(fdt);
	FDT_CHECK_HEADER(fdt);
8f6365f0:	e1a04000 	mov	r4, r0
8f6365f4:	ebfff984 	bl	8f634c0c <fdt_check_header>
8f6365f8:	e2508000 	subs	r8, r0, #0
8f6365fc:	0a000008 	beq	8f636624 <fdt_open_into+0x78>
	fdt_set_version(buf, 17);
	fdt_set_last_comp_version(buf, 16);
	fdt_set_boot_cpuid_phys(buf, fdt_boot_cpuid_phys(fdt));

	return 0;
}
8f636600:	e59f3254 	ldr	r3, [pc, #596]	; 8f63685c <fdt_open_into+0x2b0>
8f636604:	e5932000 	ldr	r2, [r3]
8f636608:	e59d3004 	ldr	r3, [r13, #4]
8f63660c:	e0332002 	eors	r2, r3, r2
8f636610:	e3a03000 	mov	r3, #0
8f636614:	1a00008f 	bne	8f636858 <fdt_open_into+0x2ac>
8f636618:	e1a00008 	mov	r0, r8
8f63661c:	e28dd00c 	add	r13, r13, #12
8f636620:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	if ((fdt_num_mem_rsv(fdt) + 1) >
8f636624:	e1a00004 	mov	r0, r4
8f636628:	ebfffb62 	bl	8f6353b8 <fdt_num_mem_rsv>
8f63662c:	e2800001 	add	r0, r0, #1
8f636630:	e370021f 	cmn	r0, #-268435455	; 0xf0000001
8f636634:	ca000085 	bgt	8f636850 <fdt_open_into+0x2a4>
	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
8f636638:	e1a00004 	mov	r0, r4
8f63663c:	ebfffb5d 	bl	8f6353b8 <fdt_num_mem_rsv>
	if (fdt_version(fdt) >= 17) {
8f636640:	e5942014 	ldr	r2, [r4, #20]
8f636644:	e7e71852 	ubfx	r1, r2, #16, #8
8f636648:	e1a03c22 	lsr	r3, r2, #24
8f63664c:	e1833c02 	orr	r3, r3, r2, lsl #24
	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
8f636650:	e1a09000 	mov	r9, r0
8f636654:	e7e70452 	ubfx	r0, r2, #8, #8
8f636658:	e1833800 	orr	r3, r3, r0, lsl #16
8f63665c:	e1833401 	orr	r3, r3, r1, lsl #8
	if (fdt_version(fdt) >= 17) {
8f636660:	e3530010 	cmp	r3, #16
8f636664:	9a00004e 	bls	8f6367a4 <fdt_open_into+0x1f8>
		struct_size = fdt_size_dt_struct(fdt);
8f636668:	e5942024 	ldr	r2, [r4, #36]	; 0x24
8f63666c:	e7e71452 	ubfx	r1, r2, #8, #8
8f636670:	e7e73852 	ubfx	r3, r2, #16, #8
8f636674:	e1a0ac22 	lsr	r10, r2, #24
8f636678:	e18aac02 	orr	r10, r10, r2, lsl #24
8f63667c:	e18aa801 	orr	r10, r10, r1, lsl #16
8f636680:	e18aa403 	orr	r10, r10, r3, lsl #8
8f636684:	e58da000 	str	r10, [r13]
			if (struct_size < 0)
8f636688:	e35a0000 	cmp	r10, #0
8f63668c:	ba000050 	blt	8f6367d4 <fdt_open_into+0x228>
	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
8f636690:	e2899001 	add	r9, r9, #1
	if (!_fdt_blocks_misordered(fdt, mem_rsv_size, struct_size)) {
8f636694:	e1a0200a 	mov	r2, r10
8f636698:	e1a00004 	mov	r0, r4
	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
8f63669c:	e1a0b209 	lsl	r11, r9, #4
	if (!_fdt_blocks_misordered(fdt, mem_rsv_size, struct_size)) {
8f6366a0:	e1a0100b 	mov	r1, r11
8f6366a4:	ebfffd2c 	bl	8f635b5c <_fdt_blocks_misordered>
8f6366a8:	e3500000 	cmp	r0, #0
8f6366ac:	0a00004f 	beq	8f6367f0 <fdt_open_into+0x244>
                + (uint64_t)struct_size + (uint64_t)fdt_size_dt_strings(fdt)) > UINT_MAX) {
8f6366b0:	e5941020 	ldr	r1, [r4, #32]
8f6366b4:	e3a03000 	mov	r3, #0
	if (((uint64_t)FDT_ALIGN(sizeof(struct fdt_header), 8) + (uint64_t)mem_rsv_size \
8f6366b8:	e3e02000 	mvn	r2, #0
8f6366bc:	e7e7c451 	ubfx	r12, r1, #8, #8
8f6366c0:	e7e70851 	ubfx	r0, r1, #16, #8
8f6366c4:	e1a09c21 	lsr	r9, r1, #24
8f6366c8:	e1899c01 	orr	r9, r9, r1, lsl #24
8f6366cc:	e189980c 	orr	r9, r9, r12, lsl #16
8f6366d0:	e1899400 	orr	r9, r9, r0, lsl #8
                + (uint64_t)struct_size + (uint64_t)fdt_size_dt_strings(fdt)) > UINT_MAX) {
8f6366d4:	e2999028 	adds	r9, r9, #40	; 0x28
8f6366d8:	e2a31000 	adc	r1, r3, #0
8f6366dc:	e099900b 	adds	r9, r9, r11
8f6366e0:	e2a11000 	adc	r1, r1, #0
8f6366e4:	e099900a 	adds	r9, r9, r10
8f6366e8:	e0a11fca 	adc	r1, r1, r10, asr #31
	if (((uint64_t)FDT_ALIGN(sizeof(struct fdt_header), 8) + (uint64_t)mem_rsv_size \
8f6366ec:	e1520009 	cmp	r2, r9
8f6366f0:	e0d33001 	sbcs	r3, r3, r1
8f6366f4:	3a000055 	bcc	8f636850 <fdt_open_into+0x2a4>
	if (bufsize < (int) newsize)
8f6366f8:	e1590007 	cmp	r9, r7
8f6366fc:	ca000039 	bgt	8f6367e8 <fdt_open_into+0x23c>
	if (((tmp + newsize) < tmp) || ((buf + bufsize) < buf)) {
8f636700:	e0963009 	adds	r3, r6, r9
8f636704:	2a000051 	bcs	8f636850 <fdt_open_into+0x2a4>
8f636708:	e0962007 	adds	r2, r6, r7
8f63670c:	2a00004f 	bcs	8f636850 <fdt_open_into+0x2a4>
	if (((tmp + newsize) > fdtstart) && (tmp < fdtend)) {
8f636710:	e1530004 	cmp	r3, r4
8f636714:	81550006 	cmphi	r5, r6
8f636718:	91a05006 	movls	r5, r6
8f63671c:	8a00002e 	bhi	8f6367dc <fdt_open_into+0x230>
	_fdt_packblocks(fdt, tmp, mem_rsv_size, struct_size);
8f636720:	e1a0300a 	mov	r3, r10
8f636724:	e1a0200b 	mov	r2, r11
8f636728:	e1a01005 	mov	r1, r5
8f63672c:	e1a00004 	mov	r0, r4
8f636730:	ebfffd4a 	bl	8f635c60 <_fdt_packblocks>
	memmove(buf, tmp, newsize);
8f636734:	e1a02009 	mov	r2, r9
8f636738:	e1a01005 	mov	r1, r5
8f63673c:	e1a00006 	mov	r0, r6
8f636740:	ebfff69c 	bl	8f6341b8 <memcpy>
	fdt_set_boot_cpuid_phys(buf, fdt_boot_cpuid_phys(fdt));
8f636744:	e594101c 	ldr	r1, [r4, #28]
__fdt_set_hdr(magic);
8f636748:	e3a03edd 	mov	r3, #3536	; 0xdd0
8f63674c:	e34e3dfe 	movt	r3, #60926	; 0xedfe
8f636750:	e7e70451 	ubfx	r0, r1, #8, #8
8f636754:	e5863000 	str	r3, [r6]
8f636758:	e1a03c21 	lsr	r3, r1, #24
8f63675c:	e1a02c27 	lsr	r2, r7, #24
8f636760:	e1833c01 	orr	r3, r3, r1, lsl #24
8f636764:	e7e71851 	ubfx	r1, r1, #16, #8
8f636768:	e1833800 	orr	r3, r3, r0, lsl #16
8f63676c:	e1822c07 	orr	r2, r2, r7, lsl #24
8f636770:	e1833401 	orr	r3, r3, r1, lsl #8
8f636774:	e6bf3f33 	rev	r3, r3
__fdt_set_hdr(boot_cpuid_phys);
8f636778:	e586301c 	str	r3, [r6, #28]
8f63677c:	e7e73457 	ubfx	r3, r7, #8, #8
8f636780:	e7e77857 	ubfx	r7, r7, #16, #8
8f636784:	e1823803 	orr	r3, r2, r3, lsl #16
__fdt_set_hdr(version);
8f636788:	e3a02411 	mov	r2, #285212672	; 0x11000000
8f63678c:	e1837407 	orr	r7, r3, r7, lsl #8
8f636790:	e5862014 	str	r2, [r6, #20]
__fdt_set_hdr(last_comp_version);
8f636794:	e3a03201 	mov	r3, #268435456	; 0x10000000
__fdt_set_hdr(totalsize);
8f636798:	e5867004 	str	r7, [r6, #4]
__fdt_set_hdr(last_comp_version);
8f63679c:	e5863018 	str	r3, [r6, #24]
	return 0;
8f6367a0:	eaffff96 	b	8f636600 <fdt_open_into+0x54>
		while (fdt_next_tag(fdt, struct_size, &struct_size) != FDT_END)
8f6367a4:	e1a01008 	mov	r1, r8
		struct_size = 0;
8f6367a8:	e58d8000 	str	r8, [r13]
		while (fdt_next_tag(fdt, struct_size, &struct_size) != FDT_END)
8f6367ac:	ea000000 	b	8f6367b4 <fdt_open_into+0x208>
8f6367b0:	e59d1000 	ldr	r1, [r13]
8f6367b4:	e1a0200d 	mov	r2, r13
8f6367b8:	e1a00004 	mov	r0, r4
8f6367bc:	ebfff984 	bl	8f634dd4 <fdt_next_tag>
8f6367c0:	e3500009 	cmp	r0, #9
8f6367c4:	1afffff9 	bne	8f6367b0 <fdt_open_into+0x204>
		if (struct_size < 0)
8f6367c8:	e59da000 	ldr	r10, [r13]
8f6367cc:	e35a0000 	cmp	r10, #0
8f6367d0:	aaffffae 	bge	8f636690 <fdt_open_into+0xe4>
8f6367d4:	e1a0800a 	mov	r8, r10
8f6367d8:	eaffff88 	b	8f636600 <fdt_open_into+0x54>
		if ((tmp + newsize) > ((char *)buf + bufsize))
8f6367dc:	e0853009 	add	r3, r5, r9
8f6367e0:	e1520003 	cmp	r2, r3
8f6367e4:	2affffcd 	bcs	8f636720 <fdt_open_into+0x174>
		return -FDT_ERR_NOSPACE;
8f6367e8:	e3e08002 	mvn	r8, #2
8f6367ec:	eaffff83 	b	8f636600 <fdt_open_into+0x54>
		err = fdt_move(fdt, buf, bufsize);
8f6367f0:	e1a02007 	mov	r2, r7
8f6367f4:	e1a01006 	mov	r1, r6
8f6367f8:	e1a00004 	mov	r0, r4
8f6367fc:	ebfffa8c 	bl	8f635234 <fdt_move>
		if (err)
8f636800:	e2508000 	subs	r8, r0, #0
8f636804:	1affff7d 	bne	8f636600 <fdt_open_into+0x54>
		fdt_set_size_dt_struct(buf, struct_size);
8f636808:	e59d3000 	ldr	r3, [r13]
__fdt_set_hdr(version);
8f63680c:	e3a02411 	mov	r2, #285212672	; 0x11000000
8f636810:	e5862014 	str	r2, [r6, #20]
8f636814:	e7e71453 	ubfx	r1, r3, #8, #8
8f636818:	e1a02c23 	lsr	r2, r3, #24
8f63681c:	e1822c03 	orr	r2, r2, r3, lsl #24
8f636820:	e7e73853 	ubfx	r3, r3, #16, #8
8f636824:	e1822801 	orr	r2, r2, r1, lsl #16
8f636828:	e1822403 	orr	r2, r2, r3, lsl #8
8f63682c:	e1a03c27 	lsr	r3, r7, #24
__fdt_set_hdr(size_dt_struct);
8f636830:	e5862024 	str	r2, [r6, #36]	; 0x24
8f636834:	e7e72457 	ubfx	r2, r7, #8, #8
8f636838:	e1833c07 	orr	r3, r3, r7, lsl #24
8f63683c:	e7e77857 	ubfx	r7, r7, #16, #8
8f636840:	e1833802 	orr	r3, r3, r2, lsl #16
8f636844:	e1837407 	orr	r7, r3, r7, lsl #8
__fdt_set_hdr(totalsize);
8f636848:	e5867004 	str	r7, [r6, #4]
		return 0;
8f63684c:	eaffff6b 	b	8f636600 <fdt_open_into+0x54>
		return err;
8f636850:	e3e08000 	mvn	r8, #0
8f636854:	eaffff69 	b	8f636600 <fdt_open_into+0x54>
}
8f636858:	ebfff0d8 	bl	8f632bc0 <__stack_chk_fail>
8f63685c:	8f74221c 	.word	0x8f74221c

8f636860 <fdt_pack>:

int fdt_pack(void *fdt)
{
8f636860:	e59f30d4 	ldr	r3, [pc, #212]	; 8f63693c <fdt_pack+0xdc>
8f636864:	e92d4030 	push	{r4, r5, r14}
8f636868:	e24dd00c 	sub	r13, r13, #12
8f63686c:	e5933000 	ldr	r3, [r3]
8f636870:	e58d3004 	str	r3, [r13, #4]
8f636874:	e3a03000 	mov	r3, #0
8f636878:	e1a05000 	mov	r5, r0
	FDT_CHECK_HEADER(fdt);
8f63687c:	ebfff8e2 	bl	8f634c0c <fdt_check_header>
8f636880:	e2504000 	subs	r4, r0, #0
8f636884:	1a000022 	bne	8f636914 <fdt_pack+0xb4>
8f636888:	e1a00005 	mov	r0, r5
8f63688c:	ebfffd44 	bl	8f635da4 <_fdt_rw_check_header.part.0>
	int mem_rsv_size;

	FDT_RW_CHECK_HEADER(fdt);
8f636890:	e2504000 	subs	r4, r0, #0
8f636894:	1a00001e 	bne	8f636914 <fdt_pack+0xb4>

	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
8f636898:	e1a00005 	mov	r0, r5
8f63689c:	ebfffac5 	bl	8f6353b8 <fdt_num_mem_rsv>
		* sizeof(struct fdt_reserve_entry);
	_fdt_packblocks(fdt, fdt, mem_rsv_size, fdt_size_dt_struct(fdt));
8f6368a0:	e5951024 	ldr	r1, [r5, #36]	; 0x24
8f6368a4:	e1a03c21 	lsr	r3, r1, #24
8f6368a8:	e1833c01 	orr	r3, r3, r1, lsl #24
	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
8f6368ac:	e2802001 	add	r2, r0, #1
8f6368b0:	e7e70451 	ubfx	r0, r1, #8, #8
8f6368b4:	e7e71851 	ubfx	r1, r1, #16, #8
8f6368b8:	e1833800 	orr	r3, r3, r0, lsl #16
	_fdt_packblocks(fdt, fdt, mem_rsv_size, fdt_size_dt_struct(fdt));
8f6368bc:	e1a02202 	lsl	r2, r2, #4
8f6368c0:	e1833401 	orr	r3, r3, r1, lsl #8
8f6368c4:	e1a00005 	mov	r0, r5
8f6368c8:	e1a01005 	mov	r1, r5
8f6368cc:	ebfffce3 	bl	8f635c60 <_fdt_packblocks>
	return fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
8f6368d0:	e595200c 	ldr	r2, [r5, #12]
8f6368d4:	e5951020 	ldr	r1, [r5, #32]
8f6368d8:	e7e70452 	ubfx	r0, r2, #8, #8
8f6368dc:	e1a03c22 	lsr	r3, r2, #24
8f6368e0:	e1833c02 	orr	r3, r3, r2, lsl #24
8f6368e4:	e7e72852 	ubfx	r2, r2, #16, #8
8f6368e8:	e1833800 	orr	r3, r3, r0, lsl #16
8f6368ec:	e7e70451 	ubfx	r0, r1, #8, #8
8f6368f0:	e1833402 	orr	r3, r3, r2, lsl #8
8f6368f4:	e1a02c21 	lsr	r2, r1, #24
8f6368f8:	e1822c01 	orr	r2, r2, r1, lsl #24
8f6368fc:	e7e71851 	ubfx	r1, r1, #16, #8
8f636900:	e1822800 	orr	r2, r2, r0, lsl #16
8f636904:	e1822401 	orr	r2, r2, r1, lsl #8
8f636908:	e0833002 	add	r3, r3, r2
8f63690c:	e6bf3f33 	rev	r3, r3
8f636910:	e5853004 	str	r3, [r5, #4]
	fdt_set_totalsize(fdt, _fdt_data_size(fdt));

	return 0;
}
8f636914:	e59f3020 	ldr	r3, [pc, #32]	; 8f63693c <fdt_pack+0xdc>
8f636918:	e5932000 	ldr	r2, [r3]
8f63691c:	e59d3004 	ldr	r3, [r13, #4]
8f636920:	e0332002 	eors	r2, r3, r2
8f636924:	e3a03000 	mov	r3, #0
8f636928:	1a000002 	bne	8f636938 <fdt_pack+0xd8>
8f63692c:	e1a00004 	mov	r0, r4
8f636930:	e28dd00c 	add	r13, r13, #12
8f636934:	e8bd8030 	pop	{r4, r5, r15}
8f636938:	ebfff0a0 	bl	8f632bc0 <__stack_chk_fail>
8f63693c:	8f74221c 	.word	0x8f74221c

8f636940 <ptable_find>:
			ptn->flags, ptype[(unsigned short) ptn->type], pperm[(unsigned short) ptn->perm]);
	}
}

struct ptentry *ptable_find(struct ptable *ptable, const char *name)
{
8f636940:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f636944:	e24dd00c 	sub	r13, r13, #12
	struct ptentry *ptn;
	int i;

	for (i = 0; i < ptable->count; ++i) {
8f636948:	e5907400 	ldr	r7, [r0, #1024]	; 0x400
{
8f63694c:	e59f3074 	ldr	r3, [pc, #116]	; 8f6369c8 <ptable_find+0x88>
	for (i = 0; i < ptable->count; ++i) {
8f636950:	e3570000 	cmp	r7, #0
{
8f636954:	e5933000 	ldr	r3, [r3]
8f636958:	e58d3004 	str	r3, [r13, #4]
8f63695c:	e3a03000 	mov	r3, #0
	for (i = 0; i < ptable->count; ++i) {
8f636960:	da000015 	ble	8f6369bc <ptable_find+0x7c>
8f636964:	e1a04000 	mov	r4, r0
8f636968:	e1a06001 	mov	r6, r1
8f63696c:	e3a05000 	mov	r5, #0
8f636970:	ea000003 	b	8f636984 <ptable_find+0x44>
8f636974:	e2855001 	add	r5, r5, #1
8f636978:	e2844020 	add	r4, r4, #32
8f63697c:	e1570005 	cmp	r7, r5
8f636980:	0a00000d 	beq	8f6369bc <ptable_find+0x7c>
		ptn = &ptable->parts[i];
		if (!strcmp(ptn->name, name))
8f636984:	e1a01006 	mov	r1, r6
8f636988:	e1a00004 	mov	r0, r4
8f63698c:	ebfff6e4 	bl	8f634524 <strcmp>
8f636990:	e3500000 	cmp	r0, #0
8f636994:	1afffff6 	bne	8f636974 <ptable_find+0x34>
			return ptn;
	}

	return NULL;
}
8f636998:	e59f3028 	ldr	r3, [pc, #40]	; 8f6369c8 <ptable_find+0x88>
8f63699c:	e5932000 	ldr	r2, [r3]
8f6369a0:	e59d3004 	ldr	r3, [r13, #4]
8f6369a4:	e0332002 	eors	r2, r3, r2
8f6369a8:	e3a03000 	mov	r3, #0
8f6369ac:	1a000004 	bne	8f6369c4 <ptable_find+0x84>
8f6369b0:	e1a00004 	mov	r0, r4
8f6369b4:	e28dd00c 	add	r13, r13, #12
8f6369b8:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
	return NULL;
8f6369bc:	e3a04000 	mov	r4, #0
8f6369c0:	eafffff4 	b	8f636998 <ptable_find+0x58>
}
8f6369c4:	ebfff07d 	bl	8f632bc0 <__stack_chk_fail>
8f6369c8:	8f74221c 	.word	0x8f74221c

8f6369cc <bio_default_write_block>:
{
	panic("%s no reasonable default operation\n", __PRETTY_FUNCTION__);
}

static ssize_t bio_default_write_block(struct bdev *dev, const void *buf, bnum_t block, uint count)
{
8f6369cc:	e59f3050 	ldr	r3, [pc, #80]	; 8f636a24 <bio_default_write_block+0x58>
8f6369d0:	e1a0000e 	mov	r0, r14
8f6369d4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	panic("%s no reasonable default operation\n", __PRETTY_FUNCTION__);
8f6369d8:	e30b22a8 	movw	r2, #45736	; 0xb2a8
{
8f6369dc:	e24dd00c 	sub	r13, r13, #12
	panic("%s no reasonable default operation\n", __PRETTY_FUNCTION__);
8f6369e0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6369e4:	e30b1248 	movw	r1, #45640	; 0xb248
8f6369e8:	e3481f70 	movt	r1, #36720	; 0x8f70
{
8f6369ec:	e5933000 	ldr	r3, [r3]
8f6369f0:	e58d3004 	str	r3, [r13, #4]
8f6369f4:	e3a03000 	mov	r3, #0
	panic("%s no reasonable default operation\n", __PRETTY_FUNCTION__);
8f6369f8:	ebfff02f 	bl	8f632abc <_panic>
}
8f6369fc:	e59f3020 	ldr	r3, [pc, #32]	; 8f636a24 <bio_default_write_block+0x58>
8f636a00:	e5932000 	ldr	r2, [r3]
8f636a04:	e59d3004 	ldr	r3, [r13, #4]
8f636a08:	e0332002 	eors	r2, r3, r2
8f636a0c:	e3a03000 	mov	r3, #0
8f636a10:	1a000002 	bne	8f636a20 <bio_default_write_block+0x54>
8f636a14:	e3a00000 	mov	r0, #0
8f636a18:	e28dd00c 	add	r13, r13, #12
8f636a1c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f636a20:	ebfff066 	bl	8f632bc0 <__stack_chk_fail>
8f636a24:	8f74221c 	.word	0x8f74221c

8f636a28 <bio_default_read_block>:
{
8f636a28:	e59f3050 	ldr	r3, [pc, #80]	; 8f636a80 <bio_default_read_block+0x58>
8f636a2c:	e1a0000e 	mov	r0, r14
8f636a30:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	panic("%s no reasonable default operation\n", __PRETTY_FUNCTION__);
8f636a34:	e30b2290 	movw	r2, #45712	; 0xb290
{
8f636a38:	e24dd00c 	sub	r13, r13, #12
	panic("%s no reasonable default operation\n", __PRETTY_FUNCTION__);
8f636a3c:	e3482f70 	movt	r2, #36720	; 0x8f70
8f636a40:	e30b1248 	movw	r1, #45640	; 0xb248
8f636a44:	e3481f70 	movt	r1, #36720	; 0x8f70
{
8f636a48:	e5933000 	ldr	r3, [r3]
8f636a4c:	e58d3004 	str	r3, [r13, #4]
8f636a50:	e3a03000 	mov	r3, #0
	panic("%s no reasonable default operation\n", __PRETTY_FUNCTION__);
8f636a54:	ebfff018 	bl	8f632abc <_panic>
}
8f636a58:	e59f3020 	ldr	r3, [pc, #32]	; 8f636a80 <bio_default_read_block+0x58>
8f636a5c:	e5932000 	ldr	r2, [r3]
8f636a60:	e59d3004 	ldr	r3, [r13, #4]
8f636a64:	e0332002 	eors	r2, r3, r2
8f636a68:	e3a03000 	mov	r3, #0
8f636a6c:	1a000002 	bne	8f636a7c <bio_default_read_block+0x54>
8f636a70:	e3a00000 	mov	r0, #0
8f636a74:	e28dd00c 	add	r13, r13, #12
8f636a78:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f636a7c:	ebfff04f 	bl	8f632bc0 <__stack_chk_fail>
8f636a80:	8f74221c 	.word	0x8f74221c

8f636a84 <bdev_dec_ref.part.0>:
static void bdev_inc_ref(bdev_t *dev)
{
	atomic_add(&dev->ref, 1);
}

static void bdev_dec_ref(bdev_t *dev)
8f636a84:	e59f3084 	ldr	r3, [pc, #132]	; 8f636b10 <bdev_dec_ref.part.0+0x8c>
	int oldval = atomic_add(&dev->ref, -1);
	if (oldval == 1) {
		// last ref, remove it
		DEBUG_ASSERT(!list_in_list(&dev->node));

		TRACEF("last ref, removing (%s)\n", dev->name);
8f636a88:	e3a020ee 	mov	r2, #238	; 0xee
static void bdev_dec_ref(bdev_t *dev)
8f636a8c:	e92d4010 	push	{r4, r14}
		TRACEF("last ref, removing (%s)\n", dev->name);
8f636a90:	e30b12c0 	movw	r1, #45760	; 0xb2c0
static void bdev_dec_ref(bdev_t *dev)
8f636a94:	e24dd008 	sub	r13, r13, #8
8f636a98:	e1a04000 	mov	r4, r0
		TRACEF("last ref, removing (%s)\n", dev->name);
8f636a9c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f636aa0:	e30b026c 	movw	r0, #45676	; 0xb26c
8f636aa4:	e3480f70 	movt	r0, #36720	; 0x8f70
static void bdev_dec_ref(bdev_t *dev)
8f636aa8:	e5933000 	ldr	r3, [r3]
8f636aac:	e58d3004 	str	r3, [r13, #4]
8f636ab0:	e3a03000 	mov	r3, #0
		TRACEF("last ref, removing (%s)\n", dev->name);
8f636ab4:	ebfff34e 	bl	8f6337f4 <printf>
8f636ab8:	e594100c 	ldr	r1, [r4, #12]
8f636abc:	e30b0274 	movw	r0, #45684	; 0xb274
8f636ac0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f636ac4:	ebfff34a 	bl	8f6337f4 <printf>

		// call the close hook if it exists
		if (dev->close)
8f636ac8:	e5943044 	ldr	r3, [r4, #68]	; 0x44
8f636acc:	e3530000 	cmp	r3, #0
8f636ad0:	0a000001 	beq	8f636adc <bdev_dec_ref.part.0+0x58>
			dev->close(dev);
8f636ad4:	e1a00004 	mov	r0, r4
8f636ad8:	e12fff33 	blx	r3

		free(dev->name);
8f636adc:	e594000c 	ldr	r0, [r4, #12]
8f636ae0:	ebfff589 	bl	8f63410c <free>
		free(dev);
8f636ae4:	e59f3024 	ldr	r3, [pc, #36]	; 8f636b10 <bdev_dec_ref.part.0+0x8c>
8f636ae8:	e5932000 	ldr	r2, [r3]
8f636aec:	e59d3004 	ldr	r3, [r13, #4]
8f636af0:	e0332002 	eors	r2, r3, r2
8f636af4:	e3a03000 	mov	r3, #0
8f636af8:	1a000003 	bne	8f636b0c <bdev_dec_ref.part.0+0x88>
8f636afc:	e1a00004 	mov	r0, r4
	}
}
8f636b00:	e28dd008 	add	r13, r13, #8
8f636b04:	e8bd4010 	pop	{r4, r14}
		free(dev);
8f636b08:	eafff57f 	b	8f63410c <free>
8f636b0c:	ebfff02b 	bl	8f632bc0 <__stack_chk_fail>
8f636b10:	8f74221c 	.word	0x8f74221c

8f636b14 <bio_default_erase>:
{
8f636b14:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f636b18:	e1a05003 	mov	r5, r3
8f636b1c:	e24dd014 	sub	r13, r13, #20
8f636b20:	e59f30dc 	ldr	r3, [pc, #220]	; 8f636c04 <bio_default_erase+0xf0>
	zero_buf = calloc(1, ERASE_BUF_SIZE);
8f636b24:	e3a01a01 	mov	r1, #4096	; 0x1000
{
8f636b28:	e1a07000 	mov	r7, r0
	zero_buf = calloc(1, ERASE_BUF_SIZE);
8f636b2c:	e3a00001 	mov	r0, #1
{
8f636b30:	e59d9038 	ldr	r9, [r13, #56]	; 0x38
8f636b34:	e5933000 	ldr	r3, [r3]
8f636b38:	e58d300c 	str	r3, [r13, #12]
8f636b3c:	e3a03000 	mov	r3, #0
8f636b40:	e1a04002 	mov	r4, r2
	zero_buf = calloc(1, ERASE_BUF_SIZE);
8f636b44:	ebfff556 	bl	8f6340a4 <calloc>
	size_t remaining = len;
8f636b48:	e1a06009 	mov	r6, r9
	zero_buf = calloc(1, ERASE_BUF_SIZE);
8f636b4c:	e1a0a000 	mov	r10, r0
	while (remaining > 0) {
8f636b50:	ea000012 	b	8f636ba0 <bio_default_erase+0x8c>
		return -1;
	if (offset >= dev->size)
		return 0;
	if (len == 0)
		return 0;
	if (offset + len > dev->size)
8f636b54:	e090c004 	adds	r12, r0, r4
		len = dev->size - offset;

	return dev->write(dev, buf, offset, len);
8f636b58:	e597b034 	ldr	r11, [r7, #52]	; 0x34
	if (offset + len > dev->size)
8f636b5c:	e2a51000 	adc	r1, r5, #0
8f636b60:	e153000c 	cmp	r3, r12
8f636b64:	e0d22001 	sbcs	r2, r2, r1
	return dev->write(dev, buf, offset, len);
8f636b68:	e1a02004 	mov	r2, r4
		len = dev->size - offset;
8f636b6c:	b0430004 	sublt	r0, r3, r4
	return dev->write(dev, buf, offset, len);
8f636b70:	e1a0100a 	mov	r1, r10
8f636b74:	e58d0000 	str	r0, [r13]
8f636b78:	e1a03005 	mov	r3, r5
8f636b7c:	e1a00007 	mov	r0, r7
8f636b80:	e12fff3b 	blx	r11
		if (written < 0)
8f636b84:	e250c000 	subs	r12, r0, #0
8f636b88:	ba000011 	blt	8f636bd4 <bio_default_erase+0xc0>
		pos += written;
8f636b8c:	e09c4004 	adds	r4, r12, r4
		remaining -= written;
8f636b90:	e046600c 	sub	r6, r6, r12
		pos += written;
8f636b94:	e0a55fcc 	adc	r5, r5, r12, asr #31
		if (written < towrite)
8f636b98:	e158000c 	cmp	r8, r12
8f636b9c:	ca00000c 	bgt	8f636bd4 <bio_default_erase+0xc0>
	while (remaining > 0) {
8f636ba0:	e3560000 	cmp	r6, #0
8f636ba4:	0a000013 	beq	8f636bf8 <bio_default_erase+0xe4>
		ssize_t towrite = MIN(remaining, ERASE_BUF_SIZE);
8f636ba8:	e3560a01 	cmp	r6, #4096	; 0x1000
8f636bac:	31a00006 	movcc	r0, r6
8f636bb0:	23a00a01 	movcs	r0, #4096	; 0x1000
	if (offset < 0)
8f636bb4:	e3550000 	cmp	r5, #0
		ssize_t towrite = MIN(remaining, ERASE_BUF_SIZE);
8f636bb8:	e1a08000 	mov	r8, r0
	if (offset < 0)
8f636bbc:	ba000004 	blt	8f636bd4 <bio_default_erase+0xc0>
	if (offset >= dev->size)
8f636bc0:	e5973010 	ldr	r3, [r7, #16]
8f636bc4:	e5972014 	ldr	r2, [r7, #20]
8f636bc8:	e1540003 	cmp	r4, r3
8f636bcc:	e0d51002 	sbcs	r1, r5, r2
8f636bd0:	baffffdf 	blt	8f636b54 <bio_default_erase+0x40>
			return pos;
8f636bd4:	e1a00004 	mov	r0, r4
}
8f636bd8:	e59f3024 	ldr	r3, [pc, #36]	; 8f636c04 <bio_default_erase+0xf0>
8f636bdc:	e5932000 	ldr	r2, [r3]
8f636be0:	e59d300c 	ldr	r3, [r13, #12]
8f636be4:	e0332002 	eors	r2, r3, r2
8f636be8:	e3a03000 	mov	r3, #0
8f636bec:	1a000003 	bne	8f636c00 <bio_default_erase+0xec>
8f636bf0:	e28dd014 	add	r13, r13, #20
8f636bf4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	return len;
8f636bf8:	e1a00009 	mov	r0, r9
8f636bfc:	eafffff5 	b	8f636bd8 <bio_default_erase+0xc4>
}
8f636c00:	ebffefee 	bl	8f632bc0 <__stack_chk_fail>
8f636c04:	8f74221c 	.word	0x8f74221c

8f636c08 <bio_default_read>:
{
8f636c08:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f636c0c:	e28db020 	add	r11, r13, #32
8f636c10:	e24dd014 	sub	r13, r13, #20
	STACKBUF_DMA_ALIGN(temp, dev->block_size); // temporary buffer for partial block transfers
8f636c14:	e5906018 	ldr	r6, [r0, #24]
{
8f636c18:	e1a08003 	mov	r8, r3
8f636c1c:	e1a09002 	mov	r9, r2
8f636c20:	e59f21e4 	ldr	r2, [pc, #484]	; 8f636e0c <bio_default_read+0x204>
	STACKBUF_DMA_ALIGN(temp, dev->block_size); // temporary buffer for partial block transfers
8f636c24:	e286307f 	add	r3, r6, #127	; 0x7f
{
8f636c28:	e50b1030 	str	r1, [r11, #-48]	; 0xffffffd0
	STACKBUF_DMA_ALIGN(temp, dev->block_size); // temporary buffer for partial block transfers
8f636c2c:	e3c33007 	bic	r3, r3, #7
{
8f636c30:	e5922000 	ldr	r2, [r2]
8f636c34:	e50b2028 	str	r2, [r11, #-40]	; 0xffffffd8
8f636c38:	e3a02000 	mov	r2, #0
	STACKBUF_DMA_ALIGN(temp, dev->block_size); // temporary buffer for partial block transfers
8f636c3c:	e04dd003 	sub	r13, r13, r3
{
8f636c40:	e1a04000 	mov	r4, r0
	STACKBUF_DMA_ALIGN(temp, dev->block_size); // temporary buffer for partial block transfers
8f636c44:	e28d303f 	add	r3, r13, #63	; 0x3f
8f636c48:	e1a02006 	mov	r2, r6
8f636c4c:	e3c3303f 	bic	r3, r3, #63	; 0x3f
8f636c50:	e1a00009 	mov	r0, r9
8f636c54:	e50b3034 	str	r3, [r11, #-52]	; 0xffffffcc
	block = offset / dev->block_size;
8f636c58:	e1a01008 	mov	r1, r8
8f636c5c:	e3a03000 	mov	r3, #0
{
8f636c60:	e59b7004 	ldr	r7, [r11, #4]
8f636c64:	fa001926 	blx	8f63d104 <__aeabi_ldivmod>
	if ((offset % dev->block_size) != 0) {
8f636c68:	e1933002 	orrs	r3, r3, r2
	block = offset / dev->block_size;
8f636c6c:	e1a0a000 	mov	r10, r0
	ssize_t bytes_read = 0;
8f636c70:	03a05000 	moveq	r5, #0
	if ((offset % dev->block_size) != 0) {
8f636c74:	1a00000c 	bne	8f636cac <bio_default_read+0xa4>
	if (len >= dev->block_size) {
8f636c78:	e1570006 	cmp	r7, r6
8f636c7c:	2a00002e 	bcs	8f636d3c <bio_default_read+0x134>
	if (len > 0) {
8f636c80:	e3570000 	cmp	r7, #0
8f636c84:	1a000049 	bne	8f636db0 <bio_default_read+0x1a8>
}
8f636c88:	e59f317c 	ldr	r3, [pc, #380]	; 8f636e0c <bio_default_read+0x204>
8f636c8c:	e5932000 	ldr	r2, [r3]
8f636c90:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f636c94:	e0332002 	eors	r2, r3, r2
8f636c98:	e3a03000 	mov	r3, #0
8f636c9c:	1a000059 	bne	8f636e08 <bio_default_read+0x200>
8f636ca0:	e1a00005 	mov	r0, r5
8f636ca4:	e24bd020 	sub	r13, r11, #32
8f636ca8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	if (block > dev->block_count)
8f636cac:	e594301c 	ldr	r3, [r4, #28]
8f636cb0:	e15a0003 	cmp	r10, r3
	if (block + count > dev->block_count)
8f636cb4:	828aa001 	addhi	r10, r10, #1
	if (block > dev->block_count)
8f636cb8:	8a000010 	bhi	8f636d00 <bio_default_read+0xf8>
	if (block + count > dev->block_count)
8f636cbc:	e280a001 	add	r10, r0, #1
	return dev->read_block(dev, buf, block, count);
8f636cc0:	e5945030 	ldr	r5, [r4, #48]	; 0x30
	if (block + count > dev->block_count)
8f636cc4:	e153000a 	cmp	r3, r10
	return dev->read_block(dev, buf, block, count);
8f636cc8:	e1a02000 	mov	r2, r0
		count = dev->block_count - block;
8f636ccc:	30433000 	subcc	r3, r3, r0
	return dev->read_block(dev, buf, block, count);
8f636cd0:	e51b1034 	ldr	r1, [r11, #-52]	; 0xffffffcc
8f636cd4:	23a03001 	movcs	r3, #1
8f636cd8:	e1a00004 	mov	r0, r4
8f636cdc:	e12fff35 	blx	r5
		if (err < 0)
8f636ce0:	e2505000 	subs	r5, r0, #0
8f636ce4:	baffffe7 	blt	8f636c88 <bio_default_read+0x80>
		size_t block_offset = offset % dev->block_size;
8f636ce8:	e5946018 	ldr	r6, [r4, #24]
8f636cec:	e1a00009 	mov	r0, r9
8f636cf0:	e1a01008 	mov	r1, r8
8f636cf4:	e3a03000 	mov	r3, #0
8f636cf8:	e1a02006 	mov	r2, r6
8f636cfc:	fa001900 	blx	8f63d104 <__aeabi_ldivmod>
		memcpy(buf, temp + block_offset, tocopy);
8f636d00:	e51b3034 	ldr	r3, [r11, #-52]	; 0xffffffcc
		size_t tocopy = MIN(dev->block_size - block_offset, len);
8f636d04:	e0465002 	sub	r5, r6, r2
8f636d08:	e1550007 	cmp	r5, r7
		memcpy(buf, temp + block_offset, tocopy);
8f636d0c:	e0831002 	add	r1, r3, r2
8f636d10:	e51b3030 	ldr	r3, [r11, #-48]	; 0xffffffd0
		size_t tocopy = MIN(dev->block_size - block_offset, len);
8f636d14:	21a05007 	movcs	r5, r7
		len -= tocopy;
8f636d18:	e0477005 	sub	r7, r7, r5
		memcpy(buf, temp + block_offset, tocopy);
8f636d1c:	e1a02005 	mov	r2, r5
8f636d20:	e1a00003 	mov	r0, r3
		buf += tocopy;
8f636d24:	e0833005 	add	r3, r3, r5
8f636d28:	e50b3030 	str	r3, [r11, #-48]	; 0xffffffd0
		memcpy(buf, temp + block_offset, tocopy);
8f636d2c:	ebfff521 	bl	8f6341b8 <memcpy>
	if (len >= dev->block_size) {
8f636d30:	e5946018 	ldr	r6, [r4, #24]
8f636d34:	e1570006 	cmp	r7, r6
8f636d38:	3affffd0 	bcc	8f636c80 <bio_default_read+0x78>
		size_t block_count = len / dev->block_size;
8f636d3c:	e1a01006 	mov	r1, r6
8f636d40:	e1a00007 	mov	r0, r7
8f636d44:	fa0017a3 	blx	8f63cbd8 <__udivsi3>
	if (block > dev->block_count)
8f636d48:	e594301c 	ldr	r3, [r4, #28]
8f636d4c:	e15a0003 	cmp	r10, r3
	if (block + count > dev->block_count)
8f636d50:	808aa000 	addhi	r10, r10, r0
		size_t block_count = len / dev->block_size;
8f636d54:	e1a08000 	mov	r8, r0
	if (block > dev->block_count)
8f636d58:	8a00000c 	bhi	8f636d90 <bio_default_read+0x188>
	if (block + count > dev->block_count)
8f636d5c:	e08a9000 	add	r9, r10, r0
	return dev->read_block(dev, buf, block, count);
8f636d60:	e5946030 	ldr	r6, [r4, #48]	; 0x30
	if (block + count > dev->block_count)
8f636d64:	e1530009 	cmp	r3, r9
	return dev->read_block(dev, buf, block, count);
8f636d68:	e51b1030 	ldr	r1, [r11, #-48]	; 0xffffffd0
		count = dev->block_count - block;
8f636d6c:	3043300a 	subcc	r3, r3, r10
	return dev->read_block(dev, buf, block, count);
8f636d70:	e1a0200a 	mov	r2, r10
8f636d74:	21a03000 	movcs	r3, r0
8f636d78:	e1a00004 	mov	r0, r4
8f636d7c:	e12fff36 	blx	r6
		if (err < 0)
8f636d80:	e3500000 	cmp	r0, #0
8f636d84:	ba00001d 	blt	8f636e00 <bio_default_read+0x1f8>
		size_t bytes = block_count * dev->block_size;
8f636d88:	e5946018 	ldr	r6, [r4, #24]
	if (block + count > dev->block_count)
8f636d8c:	e1a0a009 	mov	r10, r9
		size_t bytes = block_count * dev->block_size;
8f636d90:	e0060896 	mul	r6, r6, r8
		buf += bytes;
8f636d94:	e51b3030 	ldr	r3, [r11, #-48]	; 0xffffffd0
		len -= bytes;
8f636d98:	e0477006 	sub	r7, r7, r6
		buf += bytes;
8f636d9c:	e0833006 	add	r3, r3, r6
	if (len > 0) {
8f636da0:	e3570000 	cmp	r7, #0
		bytes_read += bytes;
8f636da4:	e0855006 	add	r5, r5, r6
		buf += bytes;
8f636da8:	e50b3030 	str	r3, [r11, #-48]	; 0xffffffd0
	if (len > 0) {
8f636dac:	0affffb5 	beq	8f636c88 <bio_default_read+0x80>
	if (block > dev->block_count)
8f636db0:	e594301c 	ldr	r3, [r4, #28]
8f636db4:	e15a0003 	cmp	r10, r3
8f636db8:	8a00000a 	bhi	8f636de8 <bio_default_read+0x1e0>
	if (block + count > dev->block_count)
8f636dbc:	e28a2001 	add	r2, r10, #1
	return dev->read_block(dev, buf, block, count);
8f636dc0:	e5946030 	ldr	r6, [r4, #48]	; 0x30
	if (block + count > dev->block_count)
8f636dc4:	e1530002 	cmp	r3, r2
	return dev->read_block(dev, buf, block, count);
8f636dc8:	e51b1034 	ldr	r1, [r11, #-52]	; 0xffffffcc
		count = dev->block_count - block;
8f636dcc:	3043300a 	subcc	r3, r3, r10
	return dev->read_block(dev, buf, block, count);
8f636dd0:	e1a0200a 	mov	r2, r10
8f636dd4:	23a03001 	movcs	r3, #1
8f636dd8:	e1a00004 	mov	r0, r4
8f636ddc:	e12fff36 	blx	r6
		if (err < 0)
8f636de0:	e3500000 	cmp	r0, #0
8f636de4:	ba000005 	blt	8f636e00 <bio_default_read+0x1f8>
		memcpy(buf, temp, len);
8f636de8:	e51b1034 	ldr	r1, [r11, #-52]	; 0xffffffcc
8f636dec:	e1a02007 	mov	r2, r7
8f636df0:	e51b0030 	ldr	r0, [r11, #-48]	; 0xffffffd0
		bytes_read += len;
8f636df4:	e0855007 	add	r5, r5, r7
		memcpy(buf, temp, len);
8f636df8:	ebfff4ee 	bl	8f6341b8 <memcpy>
		bytes_read += len;
8f636dfc:	eaffffa1 	b	8f636c88 <bio_default_read+0x80>
8f636e00:	e1a05000 	mov	r5, r0
	return (err >= 0) ? bytes_read : err;
8f636e04:	eaffff9f 	b	8f636c88 <bio_default_read+0x80>
}
8f636e08:	ebffef6c 	bl	8f632bc0 <__stack_chk_fail>
8f636e0c:	8f74221c 	.word	0x8f74221c

8f636e10 <bio_default_write>:
{
8f636e10:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f636e14:	e28db020 	add	r11, r13, #32
8f636e18:	e24dd01c 	sub	r13, r13, #28
	STACKBUF_DMA_ALIGN(temp, dev->block_size); // temporary buffer for partial block transfers
8f636e1c:	e5905018 	ldr	r5, [r0, #24]
{
8f636e20:	e1a0c003 	mov	r12, r3
8f636e24:	e50b3038 	str	r3, [r11, #-56]	; 0xffffffc8
8f636e28:	e1a08002 	mov	r8, r2
	STACKBUF_DMA_ALIGN(temp, dev->block_size); // temporary buffer for partial block transfers
8f636e2c:	e285307f 	add	r3, r5, #127	; 0x7f
{
8f636e30:	e59f224c 	ldr	r2, [pc, #588]	; 8f637084 <bio_default_write+0x274>
	STACKBUF_DMA_ALIGN(temp, dev->block_size); // temporary buffer for partial block transfers
8f636e34:	e3c33007 	bic	r3, r3, #7
{
8f636e38:	e50b1030 	str	r1, [r11, #-48]	; 0xffffffd0
	STACKBUF_DMA_ALIGN(temp, dev->block_size); // temporary buffer for partial block transfers
8f636e3c:	e04dd003 	sub	r13, r13, r3
{
8f636e40:	e5922000 	ldr	r2, [r2]
8f636e44:	e50b2028 	str	r2, [r11, #-40]	; 0xffffffd8
8f636e48:	e3a02000 	mov	r2, #0
	STACKBUF_DMA_ALIGN(temp, dev->block_size); // temporary buffer for partial block transfers
8f636e4c:	e28d303f 	add	r3, r13, #63	; 0x3f
{
8f636e50:	e1a04000 	mov	r4, r0
	STACKBUF_DMA_ALIGN(temp, dev->block_size); // temporary buffer for partial block transfers
8f636e54:	e3c3303f 	bic	r3, r3, #63	; 0x3f
8f636e58:	e1a02005 	mov	r2, r5
8f636e5c:	e50b3034 	str	r3, [r11, #-52]	; 0xffffffcc
	block = offset / dev->block_size;
8f636e60:	e1a00008 	mov	r0, r8
8f636e64:	e3a03000 	mov	r3, #0
8f636e68:	e1a0100c 	mov	r1, r12
8f636e6c:	fa0018a4 	blx	8f63d104 <__aeabi_ldivmod>
{
8f636e70:	e59b7004 	ldr	r7, [r11, #4]
	if ((offset % dev->block_size) != 0) {
8f636e74:	e1933002 	orrs	r3, r3, r2
8f636e78:	01a09000 	moveq	r9, r0
	ssize_t bytes_written = 0;
8f636e7c:	03a0a000 	moveq	r10, #0
	if ((offset % dev->block_size) != 0) {
8f636e80:	1a00002e 	bne	8f636f40 <bio_default_write+0x130>
	if (len >= dev->block_size) {
8f636e84:	e1570005 	cmp	r7, r5
8f636e88:	2a00005e 	bcs	8f637008 <bio_default_write+0x1f8>
	if (len > 0) {
8f636e8c:	e3570000 	cmp	r7, #0
8f636e90:	1a000008 	bne	8f636eb8 <bio_default_write+0xa8>
}
8f636e94:	e59f31e8 	ldr	r3, [pc, #488]	; 8f637084 <bio_default_write+0x274>
8f636e98:	e5932000 	ldr	r2, [r3]
8f636e9c:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f636ea0:	e0332002 	eors	r2, r3, r2
8f636ea4:	e3a03000 	mov	r3, #0
8f636ea8:	1a000074 	bne	8f637080 <bio_default_write+0x270>
8f636eac:	e1a0000a 	mov	r0, r10
8f636eb0:	e24bd020 	sub	r13, r11, #32
8f636eb4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
	if (block > dev->block_count)
8f636eb8:	e594301c 	ldr	r3, [r4, #28]
8f636ebc:	e1590003 	cmp	r9, r3
8f636ec0:	8a00000a 	bhi	8f636ef0 <bio_default_write+0xe0>
	if (block + count > dev->block_count)
8f636ec4:	e2892001 	add	r2, r9, #1
	return dev->read_block(dev, buf, block, count);
8f636ec8:	e5945030 	ldr	r5, [r4, #48]	; 0x30
	if (block + count > dev->block_count)
8f636ecc:	e1530002 	cmp	r3, r2
	return dev->read_block(dev, buf, block, count);
8f636ed0:	e51b1034 	ldr	r1, [r11, #-52]	; 0xffffffcc
		count = dev->block_count - block;
8f636ed4:	30433009 	subcc	r3, r3, r9
	return dev->read_block(dev, buf, block, count);
8f636ed8:	e1a02009 	mov	r2, r9
8f636edc:	23a03001 	movcs	r3, #1
8f636ee0:	e1a00004 	mov	r0, r4
8f636ee4:	e12fff35 	blx	r5
		if (err < 0)
8f636ee8:	e3500000 	cmp	r0, #0
8f636eec:	ba000061 	blt	8f637078 <bio_default_write+0x268>
		memcpy(temp, buf, len);
8f636ef0:	e51b1030 	ldr	r1, [r11, #-48]	; 0xffffffd0
8f636ef4:	e1a02007 	mov	r2, r7
8f636ef8:	e51b0034 	ldr	r0, [r11, #-52]	; 0xffffffcc
8f636efc:	ebfff4ad 	bl	8f6341b8 <memcpy>
	LTRACEF("dev '%s', buf %p, block %d, count %u\n", dev->name, buf, block, count);

	DEBUG_ASSERT(dev->ref > 0);

	/* range check */
	if (block > dev->block_count)
8f636f00:	e594301c 	ldr	r3, [r4, #28]
8f636f04:	e1590003 	cmp	r9, r3
8f636f08:	8a00000a 	bhi	8f636f38 <bio_default_write+0x128>
		return 0;
	if (count == 0)
		return 0;
	if (block + count > dev->block_count)
8f636f0c:	e2892001 	add	r2, r9, #1
		count = dev->block_count - block;

	return dev->write_block(dev, buf, block, count);
8f636f10:	e51b1034 	ldr	r1, [r11, #-52]	; 0xffffffcc
	if (block + count > dev->block_count)
8f636f14:	e1520003 	cmp	r2, r3
	return dev->write_block(dev, buf, block, count);
8f636f18:	e5945038 	ldr	r5, [r4, #56]	; 0x38
		count = dev->block_count - block;
8f636f1c:	80433009 	subhi	r3, r3, r9
	return dev->write_block(dev, buf, block, count);
8f636f20:	e1a02009 	mov	r2, r9
8f636f24:	93a03001 	movls	r3, #1
8f636f28:	e1a00004 	mov	r0, r4
8f636f2c:	e12fff35 	blx	r5
		if (err < 0)
8f636f30:	e3500000 	cmp	r0, #0
8f636f34:	ba00004f 	blt	8f637078 <bio_default_write+0x268>
		bytes_written += len;
8f636f38:	e08aa007 	add	r10, r10, r7
8f636f3c:	eaffffd4 	b	8f636e94 <bio_default_write+0x84>
	if (block > dev->block_count)
8f636f40:	e594301c 	ldr	r3, [r4, #28]
	if (block + count > dev->block_count)
8f636f44:	e2809001 	add	r9, r0, #1
8f636f48:	e1a06000 	mov	r6, r0
	if (block > dev->block_count)
8f636f4c:	e1500003 	cmp	r0, r3
8f636f50:	8a00000f 	bhi	8f636f94 <bio_default_write+0x184>
	if (block + count > dev->block_count)
8f636f54:	e1530009 	cmp	r3, r9
	return dev->read_block(dev, buf, block, count);
8f636f58:	e1a02000 	mov	r2, r0
		count = dev->block_count - block;
8f636f5c:	30433000 	subcc	r3, r3, r0
	return dev->read_block(dev, buf, block, count);
8f636f60:	e5945030 	ldr	r5, [r4, #48]	; 0x30
8f636f64:	23a03001 	movcs	r3, #1
8f636f68:	e51b1034 	ldr	r1, [r11, #-52]	; 0xffffffcc
8f636f6c:	e1a00004 	mov	r0, r4
8f636f70:	e12fff35 	blx	r5
		if (err < 0)
8f636f74:	e250a000 	subs	r10, r0, #0
8f636f78:	baffffc5 	blt	8f636e94 <bio_default_write+0x84>
		size_t block_offset = offset % dev->block_size;
8f636f7c:	e5945018 	ldr	r5, [r4, #24]
8f636f80:	e1a00008 	mov	r0, r8
8f636f84:	e51b1038 	ldr	r1, [r11, #-56]	; 0xffffffc8
8f636f88:	e3a03000 	mov	r3, #0
8f636f8c:	e1a02005 	mov	r2, r5
8f636f90:	fa00185b 	blx	8f63d104 <__aeabi_ldivmod>
		size_t tocopy = MIN(dev->block_size - block_offset, len);
8f636f94:	e0455002 	sub	r5, r5, r2
		memcpy(temp + block_offset, buf, tocopy);
8f636f98:	e51b3034 	ldr	r3, [r11, #-52]	; 0xffffffcc
		size_t tocopy = MIN(dev->block_size - block_offset, len);
8f636f9c:	e1550007 	cmp	r5, r7
		memcpy(temp + block_offset, buf, tocopy);
8f636fa0:	e51b1030 	ldr	r1, [r11, #-48]	; 0xffffffd0
8f636fa4:	e0830002 	add	r0, r3, r2
		size_t tocopy = MIN(dev->block_size - block_offset, len);
8f636fa8:	21a05007 	movcs	r5, r7
		memcpy(temp + block_offset, buf, tocopy);
8f636fac:	e1a02005 	mov	r2, r5
8f636fb0:	ebfff480 	bl	8f6341b8 <memcpy>
	if (block > dev->block_count)
8f636fb4:	e594301c 	ldr	r3, [r4, #28]
8f636fb8:	e1560003 	cmp	r6, r3
8f636fbc:	8a000009 	bhi	8f636fe8 <bio_default_write+0x1d8>
	if (block + count > dev->block_count)
8f636fc0:	e1590003 	cmp	r9, r3
	return dev->write_block(dev, buf, block, count);
8f636fc4:	e1a02006 	mov	r2, r6
		count = dev->block_count - block;
8f636fc8:	80433006 	subhi	r3, r3, r6
	return dev->write_block(dev, buf, block, count);
8f636fcc:	e51b1034 	ldr	r1, [r11, #-52]	; 0xffffffcc
8f636fd0:	93a03001 	movls	r3, #1
8f636fd4:	e5946038 	ldr	r6, [r4, #56]	; 0x38
8f636fd8:	e1a00004 	mov	r0, r4
8f636fdc:	e12fff36 	blx	r6
		if (err < 0)
8f636fe0:	e250a000 	subs	r10, r0, #0
8f636fe4:	baffffaa 	blt	8f636e94 <bio_default_write+0x84>
		buf += tocopy;
8f636fe8:	e51b3030 	ldr	r3, [r11, #-48]	; 0xffffffd0
		len -= tocopy;
8f636fec:	e0477005 	sub	r7, r7, r5
		bytes_written += tocopy;
8f636ff0:	e1a0a005 	mov	r10, r5
		buf += tocopy;
8f636ff4:	e0833005 	add	r3, r3, r5
	if (len >= dev->block_size) {
8f636ff8:	e5945018 	ldr	r5, [r4, #24]
		buf += tocopy;
8f636ffc:	e50b3030 	str	r3, [r11, #-48]	; 0xffffffd0
	if (len >= dev->block_size) {
8f637000:	e1570005 	cmp	r7, r5
8f637004:	3affffa0 	bcc	8f636e8c <bio_default_write+0x7c>
		size_t block_count = len / dev->block_size;
8f637008:	e1a01005 	mov	r1, r5
8f63700c:	e1a00007 	mov	r0, r7
8f637010:	fa0016f0 	blx	8f63cbd8 <__udivsi3>
	if (block > dev->block_count)
8f637014:	e594301c 	ldr	r3, [r4, #28]
8f637018:	e1590003 	cmp	r9, r3
	if (block + count > dev->block_count)
8f63701c:	80899000 	addhi	r9, r9, r0
		size_t block_count = len / dev->block_size;
8f637020:	e1a06000 	mov	r6, r0
	if (block > dev->block_count)
8f637024:	8a00000c 	bhi	8f63705c <bio_default_write+0x24c>
	if (block + count > dev->block_count)
8f637028:	e0898000 	add	r8, r9, r0
	return dev->write_block(dev, buf, block, count);
8f63702c:	e5945038 	ldr	r5, [r4, #56]	; 0x38
	if (block + count > dev->block_count)
8f637030:	e1530008 	cmp	r3, r8
	return dev->write_block(dev, buf, block, count);
8f637034:	e51b1030 	ldr	r1, [r11, #-48]	; 0xffffffd0
		count = dev->block_count - block;
8f637038:	30433009 	subcc	r3, r3, r9
	return dev->write_block(dev, buf, block, count);
8f63703c:	e1a02009 	mov	r2, r9
8f637040:	21a03000 	movcs	r3, r0
8f637044:	e1a00004 	mov	r0, r4
8f637048:	e12fff35 	blx	r5
		if (err < 0)
8f63704c:	e3500000 	cmp	r0, #0
8f637050:	ba000008 	blt	8f637078 <bio_default_write+0x268>
		size_t bytes = block_count * dev->block_size;
8f637054:	e5945018 	ldr	r5, [r4, #24]
	if (block + count > dev->block_count)
8f637058:	e1a09008 	mov	r9, r8
		size_t bytes = block_count * dev->block_size;
8f63705c:	e0050695 	mul	r5, r5, r6
		buf += bytes;
8f637060:	e51b3030 	ldr	r3, [r11, #-48]	; 0xffffffd0
		len -= bytes;
8f637064:	e0477005 	sub	r7, r7, r5
		buf += bytes;
8f637068:	e0833005 	add	r3, r3, r5
		bytes_written += bytes;
8f63706c:	e08aa005 	add	r10, r10, r5
		buf += bytes;
8f637070:	e50b3030 	str	r3, [r11, #-48]	; 0xffffffd0
		block += block_count;
8f637074:	eaffff84 	b	8f636e8c <bio_default_write+0x7c>
8f637078:	e1a0a000 	mov	r10, r0
	return (err >= 0) ? bytes_written : err;
8f63707c:	eaffff84 	b	8f636e94 <bio_default_write+0x84>
}
8f637080:	ebffeece 	bl	8f632bc0 <__stack_chk_fail>
8f637084:	8f74221c 	.word	0x8f74221c

8f637088 <bio_open>:
{
8f637088:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	mutex_acquire(&bdevs->lock);
8f63708c:	e3027210 	movw	r7, #8720	; 0x2210
{
8f637090:	e59f30a0 	ldr	r3, [pc, #160]	; 8f637138 <bio_open+0xb0>
	mutex_acquire(&bdevs->lock);
8f637094:	e3487f74 	movt	r7, #36724	; 0x8f74
{
8f637098:	e24dd00c 	sub	r13, r13, #12
8f63709c:	e1a05000 	mov	r5, r0
8f6370a0:	e5933000 	ldr	r3, [r3]
8f6370a4:	e58d3004 	str	r3, [r13, #4]
8f6370a8:	e3a03000 	mov	r3, #0
	mutex_acquire(&bdevs->lock);
8f6370ac:	e5973000 	ldr	r3, [r7]
8f6370b0:	e2830008 	add	r0, r3, #8
8f6370b4:	ebffafc4 	bl	8f622fcc <mutex_acquire>
	list_for_every_entry(&bdevs->list, entry, bdev_t, node) {
8f6370b8:	e5976000 	ldr	r6, [r7]
8f6370bc:	e5964004 	ldr	r4, [r6, #4]
8f6370c0:	e1560004 	cmp	r6, r4
8f6370c4:	1a000003 	bne	8f6370d8 <bio_open+0x50>
8f6370c8:	ea00000d 	b	8f637104 <bio_open+0x7c>
8f6370cc:	e5944004 	ldr	r4, [r4, #4]
8f6370d0:	e1560004 	cmp	r6, r4
8f6370d4:	0a00000a 	beq	8f637104 <bio_open+0x7c>
		if (!strcmp(entry->name, name)) {
8f6370d8:	e594000c 	ldr	r0, [r4, #12]
8f6370dc:	e1a01005 	mov	r1, r5
8f6370e0:	ebfff50f 	bl	8f634524 <strcmp>
8f6370e4:	e3500000 	cmp	r0, #0
8f6370e8:	1afffff7 	bne	8f6370cc <bio_open+0x44>
	atomic_add(&dev->ref, 1);
8f6370ec:	e2840008 	add	r0, r4, #8
8f6370f0:	e3a01001 	mov	r1, #1
8f6370f4:	ebffa7d1 	bl	8f621040 <atomic_add>
}
8f6370f8:	e1a05004 	mov	r5, r4
8f6370fc:	e5974000 	ldr	r4, [r7]
8f637100:	ea000000 	b	8f637108 <bio_open+0x80>
	bdev_t *bdev = NULL;
8f637104:	e3a05000 	mov	r5, #0
	mutex_release(&bdevs->lock);
8f637108:	e2840008 	add	r0, r4, #8
8f63710c:	ebffaffc 	bl	8f623104 <mutex_release>
}
8f637110:	e59f3020 	ldr	r3, [pc, #32]	; 8f637138 <bio_open+0xb0>
8f637114:	e5932000 	ldr	r2, [r3]
8f637118:	e59d3004 	ldr	r3, [r13, #4]
8f63711c:	e0332002 	eors	r2, r3, r2
8f637120:	e3a03000 	mov	r3, #0
8f637124:	1a000002 	bne	8f637134 <bio_open+0xac>
8f637128:	e1a00005 	mov	r0, r5
8f63712c:	e28dd00c 	add	r13, r13, #12
8f637130:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
8f637134:	ebffeea1 	bl	8f632bc0 <__stack_chk_fail>
8f637138:	8f74221c 	.word	0x8f74221c

8f63713c <bio_close>:
{
8f63713c:	e59f3070 	ldr	r3, [pc, #112]	; 8f6371b4 <bio_close+0x78>
	int oldval = atomic_add(&dev->ref, -1);
8f637140:	e3e01000 	mvn	r1, #0
{
8f637144:	e92d4010 	push	{r4, r14}
8f637148:	e1a04000 	mov	r4, r0
8f63714c:	e24dd008 	sub	r13, r13, #8
	int oldval = atomic_add(&dev->ref, -1);
8f637150:	e2800008 	add	r0, r0, #8
{
8f637154:	e5933000 	ldr	r3, [r3]
8f637158:	e58d3004 	str	r3, [r13, #4]
8f63715c:	e3a03000 	mov	r3, #0
	int oldval = atomic_add(&dev->ref, -1);
8f637160:	ebffa7b6 	bl	8f621040 <atomic_add>
	if (oldval == 1) {
8f637164:	e59f3048 	ldr	r3, [pc, #72]	; 8f6371b4 <bio_close+0x78>
8f637168:	e3500001 	cmp	r0, #1
8f63716c:	0a000006 	beq	8f63718c <bio_close+0x50>
}
8f637170:	e5932000 	ldr	r2, [r3]
8f637174:	e59d3004 	ldr	r3, [r13, #4]
8f637178:	e0332002 	eors	r2, r3, r2
8f63717c:	e3a03000 	mov	r3, #0
8f637180:	1a00000a 	bne	8f6371b0 <bio_close+0x74>
8f637184:	e28dd008 	add	r13, r13, #8
8f637188:	e8bd8010 	pop	{r4, r15}
8f63718c:	e5932000 	ldr	r2, [r3]
8f637190:	e59d3004 	ldr	r3, [r13, #4]
8f637194:	e0332002 	eors	r2, r3, r2
8f637198:	e3a03000 	mov	r3, #0
8f63719c:	1a000003 	bne	8f6371b0 <bio_close+0x74>
8f6371a0:	e1a00004 	mov	r0, r4
8f6371a4:	e28dd008 	add	r13, r13, #8
8f6371a8:	e8bd4010 	pop	{r4, r14}
8f6371ac:	eafffe34 	b	8f636a84 <bdev_dec_ref.part.0>
8f6371b0:	ebffee82 	bl	8f632bc0 <__stack_chk_fail>
8f6371b4:	8f74221c 	.word	0x8f74221c

8f6371b8 <bio_read>:
{
8f6371b8:	e92d4070 	push	{r4, r5, r6, r14}
	if (offset < 0)
8f6371bc:	e3530000 	cmp	r3, #0
{
8f6371c0:	e24dd008 	sub	r13, r13, #8
8f6371c4:	e59fc0ac 	ldr	r12, [pc, #172]	; 8f637278 <bio_read+0xc0>
8f6371c8:	e59de018 	ldr	r14, [r13, #24]
8f6371cc:	e59cc000 	ldr	r12, [r12]
8f6371d0:	e58dc004 	str	r12, [r13, #4]
8f6371d4:	e3a0c000 	mov	r12, #0
	if (offset < 0)
8f6371d8:	ba000023 	blt	8f63726c <bio_read+0xb4>
	if (offset >= dev->size)
8f6371dc:	e5904010 	ldr	r4, [r0, #16]
8f6371e0:	e5905014 	ldr	r5, [r0, #20]
8f6371e4:	e1520004 	cmp	r2, r4
8f6371e8:	e0d3c005 	sbcs	r12, r3, r5
8f6371ec:	a3a0c001 	movge	r12, #1
8f6371f0:	b3a0c000 	movlt	r12, #0
	if (len == 0)
8f6371f4:	e35e0000 	cmp	r14, #0
8f6371f8:	038cc001 	orreq	r12, r12, #1
8f6371fc:	e35c0000 	cmp	r12, #0
		return 0;
8f637200:	13a00000 	movne	r0, #0
	if (len == 0)
8f637204:	0a000007 	beq	8f637228 <bio_read+0x70>
}
8f637208:	e59f3068 	ldr	r3, [pc, #104]	; 8f637278 <bio_read+0xc0>
8f63720c:	e5932000 	ldr	r2, [r3]
8f637210:	e59d3004 	ldr	r3, [r13, #4]
8f637214:	e0332002 	eors	r2, r3, r2
8f637218:	e3a03000 	mov	r3, #0
8f63721c:	1a000014 	bne	8f637274 <bio_read+0xbc>
8f637220:	e28dd008 	add	r13, r13, #8
8f637224:	e8bd8070 	pop	{r4, r5, r6, r15}
	if (offset + len > dev->size)
8f637228:	e09e6002 	adds	r6, r14, r2
8f63722c:	e2a3c000 	adc	r12, r3, #0
8f637230:	e1540006 	cmp	r4, r6
8f637234:	e0d5c00c 	sbcs	r12, r5, r12
	return dev->read(dev, buf, offset, len);
8f637238:	e59fc038 	ldr	r12, [pc, #56]	; 8f637278 <bio_read+0xc0>
		len = dev->size - offset;
8f63723c:	b044e002 	sublt	r14, r4, r2
	return dev->read(dev, buf, offset, len);
8f637240:	e59c4000 	ldr	r4, [r12]
8f637244:	e59dc004 	ldr	r12, [r13, #4]
8f637248:	e03c4004 	eors	r4, r12, r4
8f63724c:	e3a0c000 	mov	r12, #0
8f637250:	1a000007 	bne	8f637274 <bio_read+0xbc>
8f637254:	e58de018 	str	r14, [r13, #24]
8f637258:	e590e02c 	ldr	r14, [r0, #44]	; 0x2c
8f63725c:	e1a0c00e 	mov	r12, r14
}
8f637260:	e28dd008 	add	r13, r13, #8
8f637264:	e8bd4070 	pop	{r4, r5, r6, r14}
	return dev->read(dev, buf, offset, len);
8f637268:	e12fff1c 	bx	r12
		return -1;
8f63726c:	e3e00000 	mvn	r0, #0
8f637270:	eaffffe4 	b	8f637208 <bio_read+0x50>
}
8f637274:	ebffee51 	bl	8f632bc0 <__stack_chk_fail>
8f637278:	8f74221c 	.word	0x8f74221c

8f63727c <bio_read_block>:
{
8f63727c:	e92d4010 	push	{r4, r14}
8f637280:	e24dd008 	sub	r13, r13, #8
	if (block > dev->block_count)
8f637284:	e590e01c 	ldr	r14, [r0, #28]
{
8f637288:	e59fc084 	ldr	r12, [pc, #132]	; 8f637314 <bio_read_block+0x98>
	if (block > dev->block_count)
8f63728c:	e15e0002 	cmp	r14, r2
{
8f637290:	e59cc000 	ldr	r12, [r12]
8f637294:	e58dc004 	str	r12, [r13, #4]
8f637298:	e3a0c000 	mov	r12, #0
	if (block > dev->block_count)
8f63729c:	23a0c000 	movcs	r12, #0
8f6372a0:	33a0c001 	movcc	r12, #1
	if (count == 0)
8f6372a4:	e3530000 	cmp	r3, #0
8f6372a8:	038cc001 	orreq	r12, r12, #1
8f6372ac:	e35c0000 	cmp	r12, #0
8f6372b0:	0a000008 	beq	8f6372d8 <bio_read_block+0x5c>
}
8f6372b4:	e59f3058 	ldr	r3, [pc, #88]	; 8f637314 <bio_read_block+0x98>
8f6372b8:	e5932000 	ldr	r2, [r3]
8f6372bc:	e59d3004 	ldr	r3, [r13, #4]
8f6372c0:	e0332002 	eors	r2, r3, r2
8f6372c4:	e3a03000 	mov	r3, #0
8f6372c8:	1a000010 	bne	8f637310 <bio_read_block+0x94>
8f6372cc:	e3a00000 	mov	r0, #0
8f6372d0:	e28dd008 	add	r13, r13, #8
8f6372d4:	e8bd8010 	pop	{r4, r15}
	if (block + count > dev->block_count)
8f6372d8:	e082c003 	add	r12, r2, r3
8f6372dc:	e15e000c 	cmp	r14, r12
	return dev->read_block(dev, buf, block, count);
8f6372e0:	e59fc02c 	ldr	r12, [pc, #44]	; 8f637314 <bio_read_block+0x98>
		count = dev->block_count - block;
8f6372e4:	304e3002 	subcc	r3, r14, r2
	return dev->read_block(dev, buf, block, count);
8f6372e8:	e59ce000 	ldr	r14, [r12]
8f6372ec:	e59dc004 	ldr	r12, [r13, #4]
8f6372f0:	e03ce00e 	eors	r14, r12, r14
8f6372f4:	e3a0c000 	mov	r12, #0
8f6372f8:	1a000004 	bne	8f637310 <bio_read_block+0x94>
8f6372fc:	e590e030 	ldr	r14, [r0, #48]	; 0x30
8f637300:	e1a0c00e 	mov	r12, r14
}
8f637304:	e28dd008 	add	r13, r13, #8
8f637308:	e8bd4010 	pop	{r4, r14}
	return dev->read_block(dev, buf, block, count);
8f63730c:	e12fff1c 	bx	r12
}
8f637310:	ebffee2a 	bl	8f632bc0 <__stack_chk_fail>
8f637314:	8f74221c 	.word	0x8f74221c

8f637318 <bio_write>:
{
8f637318:	e92d4070 	push	{r4, r5, r6, r14}
	if (offset < 0)
8f63731c:	e3530000 	cmp	r3, #0
{
8f637320:	e24dd008 	sub	r13, r13, #8
8f637324:	e59fc0ac 	ldr	r12, [pc, #172]	; 8f6373d8 <bio_write+0xc0>
8f637328:	e59de018 	ldr	r14, [r13, #24]
8f63732c:	e59cc000 	ldr	r12, [r12]
8f637330:	e58dc004 	str	r12, [r13, #4]
8f637334:	e3a0c000 	mov	r12, #0
	if (offset < 0)
8f637338:	ba000023 	blt	8f6373cc <bio_write+0xb4>
	if (offset >= dev->size)
8f63733c:	e5904010 	ldr	r4, [r0, #16]
8f637340:	e5905014 	ldr	r5, [r0, #20]
8f637344:	e1520004 	cmp	r2, r4
8f637348:	e0d3c005 	sbcs	r12, r3, r5
8f63734c:	a3a0c001 	movge	r12, #1
8f637350:	b3a0c000 	movlt	r12, #0
	if (len == 0)
8f637354:	e35e0000 	cmp	r14, #0
8f637358:	038cc001 	orreq	r12, r12, #1
8f63735c:	e35c0000 	cmp	r12, #0
		return 0;
8f637360:	13a00000 	movne	r0, #0
	if (len == 0)
8f637364:	0a000007 	beq	8f637388 <bio_write+0x70>
}
8f637368:	e59f3068 	ldr	r3, [pc, #104]	; 8f6373d8 <bio_write+0xc0>
8f63736c:	e5932000 	ldr	r2, [r3]
8f637370:	e59d3004 	ldr	r3, [r13, #4]
8f637374:	e0332002 	eors	r2, r3, r2
8f637378:	e3a03000 	mov	r3, #0
8f63737c:	1a000014 	bne	8f6373d4 <bio_write+0xbc>
8f637380:	e28dd008 	add	r13, r13, #8
8f637384:	e8bd8070 	pop	{r4, r5, r6, r15}
	if (offset + len > dev->size)
8f637388:	e09e6002 	adds	r6, r14, r2
8f63738c:	e2a3c000 	adc	r12, r3, #0
8f637390:	e1540006 	cmp	r4, r6
8f637394:	e0d5c00c 	sbcs	r12, r5, r12
	return dev->write(dev, buf, offset, len);
8f637398:	e59fc038 	ldr	r12, [pc, #56]	; 8f6373d8 <bio_write+0xc0>
		len = dev->size - offset;
8f63739c:	b044e002 	sublt	r14, r4, r2
	return dev->write(dev, buf, offset, len);
8f6373a0:	e59c4000 	ldr	r4, [r12]
8f6373a4:	e59dc004 	ldr	r12, [r13, #4]
8f6373a8:	e03c4004 	eors	r4, r12, r4
8f6373ac:	e3a0c000 	mov	r12, #0
8f6373b0:	1a000007 	bne	8f6373d4 <bio_write+0xbc>
8f6373b4:	e58de018 	str	r14, [r13, #24]
8f6373b8:	e590e034 	ldr	r14, [r0, #52]	; 0x34
8f6373bc:	e1a0c00e 	mov	r12, r14
}
8f6373c0:	e28dd008 	add	r13, r13, #8
8f6373c4:	e8bd4070 	pop	{r4, r5, r6, r14}
	return dev->write(dev, buf, offset, len);
8f6373c8:	e12fff1c 	bx	r12
		return -1;
8f6373cc:	e3e00000 	mvn	r0, #0
8f6373d0:	eaffffe4 	b	8f637368 <bio_write+0x50>
}
8f6373d4:	ebffedf9 	bl	8f632bc0 <__stack_chk_fail>
8f6373d8:	8f74221c 	.word	0x8f74221c

8f6373dc <bio_write_block>:
{
8f6373dc:	e92d4010 	push	{r4, r14}
8f6373e0:	e24dd008 	sub	r13, r13, #8
	if (block > dev->block_count)
8f6373e4:	e590e01c 	ldr	r14, [r0, #28]
{
8f6373e8:	e59fc084 	ldr	r12, [pc, #132]	; 8f637474 <bio_write_block+0x98>
	if (block > dev->block_count)
8f6373ec:	e15e0002 	cmp	r14, r2
{
8f6373f0:	e59cc000 	ldr	r12, [r12]
8f6373f4:	e58dc004 	str	r12, [r13, #4]
8f6373f8:	e3a0c000 	mov	r12, #0
	if (block > dev->block_count)
8f6373fc:	23a0c000 	movcs	r12, #0
8f637400:	33a0c001 	movcc	r12, #1
	if (count == 0)
8f637404:	e3530000 	cmp	r3, #0
8f637408:	038cc001 	orreq	r12, r12, #1
8f63740c:	e35c0000 	cmp	r12, #0
8f637410:	0a000008 	beq	8f637438 <bio_write_block+0x5c>
}
8f637414:	e59f3058 	ldr	r3, [pc, #88]	; 8f637474 <bio_write_block+0x98>
8f637418:	e5932000 	ldr	r2, [r3]
8f63741c:	e59d3004 	ldr	r3, [r13, #4]
8f637420:	e0332002 	eors	r2, r3, r2
8f637424:	e3a03000 	mov	r3, #0
8f637428:	1a000010 	bne	8f637470 <bio_write_block+0x94>
8f63742c:	e3a00000 	mov	r0, #0
8f637430:	e28dd008 	add	r13, r13, #8
8f637434:	e8bd8010 	pop	{r4, r15}
	if (block + count > dev->block_count)
8f637438:	e082c003 	add	r12, r2, r3
8f63743c:	e15e000c 	cmp	r14, r12
	return dev->write_block(dev, buf, block, count);
8f637440:	e59fc02c 	ldr	r12, [pc, #44]	; 8f637474 <bio_write_block+0x98>
		count = dev->block_count - block;
8f637444:	304e3002 	subcc	r3, r14, r2
	return dev->write_block(dev, buf, block, count);
8f637448:	e59ce000 	ldr	r14, [r12]
8f63744c:	e59dc004 	ldr	r12, [r13, #4]
8f637450:	e03ce00e 	eors	r14, r12, r14
8f637454:	e3a0c000 	mov	r12, #0
8f637458:	1a000004 	bne	8f637470 <bio_write_block+0x94>
8f63745c:	e590e038 	ldr	r14, [r0, #56]	; 0x38
8f637460:	e1a0c00e 	mov	r12, r14
}
8f637464:	e28dd008 	add	r13, r13, #8
8f637468:	e8bd4010 	pop	{r4, r14}
	return dev->write_block(dev, buf, block, count);
8f63746c:	e12fff1c 	bx	r12
}
8f637470:	ebffedd2 	bl	8f632bc0 <__stack_chk_fail>
8f637474:	8f74221c 	.word	0x8f74221c

8f637478 <bio_erase>:

ssize_t bio_erase(bdev_t *dev, off_t offset, size_t len)
{
8f637478:	e92d4030 	push	{r4, r5, r14}
	LTRACEF("dev '%s', offset %lld, len %zd\n", dev->name, offset, len);

	DEBUG_ASSERT(dev->ref > 0);

	/* range check */
	if (offset < 0)
8f63747c:	e3530000 	cmp	r3, #0
{
8f637480:	e24dd00c 	sub	r13, r13, #12
8f637484:	e59f10a8 	ldr	r1, [pc, #168]	; 8f637534 <bio_erase+0xbc>
8f637488:	e59dc018 	ldr	r12, [r13, #24]
8f63748c:	e5911000 	ldr	r1, [r1]
8f637490:	e58d1004 	str	r1, [r13, #4]
8f637494:	e3a01000 	mov	r1, #0
	if (offset < 0)
8f637498:	ba000022 	blt	8f637528 <bio_erase+0xb0>
		return -1;
	if (offset >= dev->size)
8f63749c:	e590e010 	ldr	r14, [r0, #16]
8f6374a0:	e5904014 	ldr	r4, [r0, #20]
8f6374a4:	e152000e 	cmp	r2, r14
8f6374a8:	e0d31004 	sbcs	r1, r3, r4
8f6374ac:	a3a01001 	movge	r1, #1
8f6374b0:	b3a01000 	movlt	r1, #0
		return 0;
	if (len == 0)
8f6374b4:	e35c0000 	cmp	r12, #0
8f6374b8:	03811001 	orreq	r1, r1, #1
8f6374bc:	e3510000 	cmp	r1, #0
		return 0;
8f6374c0:	13a00000 	movne	r0, #0
	if (len == 0)
8f6374c4:	0a000007 	beq	8f6374e8 <bio_erase+0x70>
	if (offset + len > dev->size)
		len = dev->size - offset;

	return dev->erase(dev, offset, len);
}
8f6374c8:	e59f3064 	ldr	r3, [pc, #100]	; 8f637534 <bio_erase+0xbc>
8f6374cc:	e5932000 	ldr	r2, [r3]
8f6374d0:	e59d3004 	ldr	r3, [r13, #4]
8f6374d4:	e0332002 	eors	r2, r3, r2
8f6374d8:	e3a03000 	mov	r3, #0
8f6374dc:	1a000013 	bne	8f637530 <bio_erase+0xb8>
8f6374e0:	e28dd00c 	add	r13, r13, #12
8f6374e4:	e8bd8030 	pop	{r4, r5, r15}
	if (offset + len > dev->size)
8f6374e8:	e09c5002 	adds	r5, r12, r2
8f6374ec:	e2a31000 	adc	r1, r3, #0
8f6374f0:	e15e0005 	cmp	r14, r5
8f6374f4:	e0d41001 	sbcs	r1, r4, r1
	return dev->erase(dev, offset, len);
8f6374f8:	e59f1034 	ldr	r1, [pc, #52]	; 8f637534 <bio_erase+0xbc>
		len = dev->size - offset;
8f6374fc:	b04ec002 	sublt	r12, r14, r2
	return dev->erase(dev, offset, len);
8f637500:	e591e000 	ldr	r14, [r1]
8f637504:	e59d1004 	ldr	r1, [r13, #4]
8f637508:	e031e00e 	eors	r14, r1, r14
8f63750c:	e3a01000 	mov	r1, #0
8f637510:	1a000006 	bne	8f637530 <bio_erase+0xb8>
8f637514:	e590103c 	ldr	r1, [r0, #60]	; 0x3c
8f637518:	e58dc018 	str	r12, [r13, #24]
}
8f63751c:	e28dd00c 	add	r13, r13, #12
8f637520:	e8bd4030 	pop	{r4, r5, r14}
	return dev->erase(dev, offset, len);
8f637524:	e12fff11 	bx	r1
		return -1;
8f637528:	e3e00000 	mvn	r0, #0
8f63752c:	eaffffe5 	b	8f6374c8 <bio_erase+0x50>
}
8f637530:	ebffeda2 	bl	8f632bc0 <__stack_chk_fail>
8f637534:	8f74221c 	.word	0x8f74221c

8f637538 <bio_initialize_bdev>:
		return dev->ioctl(dev, request, argp);
	}
}

void bio_initialize_bdev(bdev_t *dev, const char *name, size_t block_size, bnum_t block_count)
{
8f637538:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f63753c:	e1a07003 	mov	r7, r3
8f637540:	e59f30ac 	ldr	r3, [pc, #172]	; 8f6375f4 <bio_initialize_bdev+0xbc>
8f637544:	e1a04000 	mov	r4, r0
8f637548:	e24dd00c 	sub	r13, r13, #12
	item->prev = item->next = 0;
8f63754c:	e3a06000 	mov	r6, #0
8f637550:	e5933000 	ldr	r3, [r3]
8f637554:	e58d3004 	str	r3, [r13, #4]
8f637558:	e3a03000 	mov	r3, #0
	DEBUG_ASSERT(dev);
	DEBUG_ASSERT(name);
	DEBUG_ASSERT(block_size == 512); // XXX can only deal with 512 for now

	list_clear_node(&dev->node);
	dev->name = strdup(name);
8f63755c:	e1a00001 	mov	r0, r1
8f637560:	e5846004 	str	r6, [r4, #4]
{
8f637564:	e1a05002 	mov	r5, r2
8f637568:	e5846000 	str	r6, [r4]
	dev->name = strdup(name);
8f63756c:	ebfff41d 	bl	8f6345e8 <strdup>
	dev->block_size = block_size;
8f637570:	e5845018 	str	r5, [r4, #24]
	dev->block_count = block_count;
	dev->size = (off_t)block_count * block_size;
8f637574:	e0825597 	umull	r5, r2, r7, r5
	dev->label = NULL;
	dev->is_gpt = false;
	dev->is_subdev = false;

	/* set up the default hooks, the sub driver should override the block operations at least */
	dev->read = bio_default_read;
8f637578:	e3063c08 	movw	r3, #27656	; 0x6c08
8f63757c:	e3483f63 	movt	r3, #36707	; 0x8f63
8f637580:	e584302c 	str	r3, [r4, #44]	; 0x2c
	dev->read_block = bio_default_read_block;
	dev->write = bio_default_write;
	dev->write_block = bio_default_write_block;
	dev->erase = bio_default_erase;
8f637584:	e3063b14 	movw	r3, #27412	; 0x6b14
8f637588:	e3483f63 	movt	r3, #36707	; 0x8f63
	dev->write = bio_default_write;
8f63758c:	e3061e10 	movw	r1, #28176	; 0x6e10
	dev->block_count = block_count;
8f637590:	e584701c 	str	r7, [r4, #28]
	dev->write = bio_default_write;
8f637594:	e3481f63 	movt	r1, #36707	; 0x8f63
	dev->ref = 0;
8f637598:	e5846008 	str	r6, [r4, #8]
	dev->size = (off_t)block_count * block_size;
8f63759c:	e5842014 	str	r2, [r4, #20]
	dev->write_block = bio_default_write_block;
8f6375a0:	e30629cc 	movw	r2, #27084	; 0x69cc
8f6375a4:	e3482f63 	movt	r2, #36707	; 0x8f63
	dev->erase = bio_default_erase;
8f6375a8:	e1c423f8 	strd	r2, [r4, #56]	; 0x38
	dev->close = NULL;
}
8f6375ac:	e59f3040 	ldr	r3, [pc, #64]	; 8f6375f4 <bio_initialize_bdev+0xbc>
	dev->label = NULL;
8f6375b0:	e5846020 	str	r6, [r4, #32]
	dev->is_gpt = false;
8f6375b4:	e5846024 	str	r6, [r4, #36]	; 0x24
	dev->is_subdev = false;
8f6375b8:	e5846028 	str	r6, [r4, #40]	; 0x28
	dev->close = NULL;
8f6375bc:	e5846044 	str	r6, [r4, #68]	; 0x44
	dev->size = (off_t)block_count * block_size;
8f6375c0:	e5845010 	str	r5, [r4, #16]
	dev->name = strdup(name);
8f6375c4:	e584000c 	str	r0, [r4, #12]
	dev->read_block = bio_default_read_block;
8f6375c8:	e3060a28 	movw	r0, #27176	; 0x6a28
8f6375cc:	e3480f63 	movt	r0, #36707	; 0x8f63
	dev->write = bio_default_write;
8f6375d0:	e1c403f0 	strd	r0, [r4, #48]	; 0x30
}
8f6375d4:	e5932000 	ldr	r2, [r3]
8f6375d8:	e59d3004 	ldr	r3, [r13, #4]
8f6375dc:	e0332002 	eors	r2, r3, r2
8f6375e0:	e3a03000 	mov	r3, #0
8f6375e4:	1a000001 	bne	8f6375f0 <bio_initialize_bdev+0xb8>
8f6375e8:	e28dd00c 	add	r13, r13, #12
8f6375ec:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
8f6375f0:	ebffed72 	bl	8f632bc0 <__stack_chk_fail>
8f6375f4:	8f74221c 	.word	0x8f74221c

8f6375f8 <bio_register_device>:

void bio_register_device(bdev_t *dev)
{
8f6375f8:	e92d4030 	push	{r4, r5, r14}

	LTRACEF(" '%s'\n", dev->name);

	bdev_inc_ref(dev);

	mutex_acquire(&bdevs->lock);
8f6375fc:	e3025210 	movw	r5, #8720	; 0x2210
{
8f637600:	e59f306c 	ldr	r3, [pc, #108]	; 8f637674 <bio_register_device+0x7c>
	mutex_acquire(&bdevs->lock);
8f637604:	e3485f74 	movt	r5, #36724	; 0x8f74
{
8f637608:	e24dd00c 	sub	r13, r13, #12
8f63760c:	e1a04000 	mov	r4, r0
	atomic_add(&dev->ref, 1);
8f637610:	e3a01001 	mov	r1, #1
8f637614:	e2800008 	add	r0, r0, #8
{
8f637618:	e5933000 	ldr	r3, [r3]
8f63761c:	e58d3004 	str	r3, [r13, #4]
8f637620:	e3a03000 	mov	r3, #0
	atomic_add(&dev->ref, 1);
8f637624:	ebffa685 	bl	8f621040 <atomic_add>
	mutex_acquire(&bdevs->lock);
8f637628:	e5950000 	ldr	r0, [r5]
8f63762c:	e2800008 	add	r0, r0, #8
8f637630:	ebffae65 	bl	8f622fcc <mutex_acquire>
	list_add_head(&bdevs->list, &dev->node);
8f637634:	e5950000 	ldr	r0, [r5]
	item->next = list->next;
8f637638:	e5903004 	ldr	r3, [r0, #4]
8f63763c:	e8840009 	stm	r4, {r0, r3}
	list->next->prev = item;
8f637640:	e5834000 	str	r4, [r3]
	mutex_release(&bdevs->lock);
8f637644:	e59f3028 	ldr	r3, [pc, #40]	; 8f637674 <bio_register_device+0x7c>
	list->next = item;
8f637648:	e5804004 	str	r4, [r0, #4]
8f63764c:	e5932000 	ldr	r2, [r3]
8f637650:	e59d3004 	ldr	r3, [r13, #4]
8f637654:	e0332002 	eors	r2, r3, r2
8f637658:	e3a03000 	mov	r3, #0
8f63765c:	1a000003 	bne	8f637670 <bio_register_device+0x78>
8f637660:	e2800008 	add	r0, r0, #8
}
8f637664:	e28dd00c 	add	r13, r13, #12
8f637668:	e8bd4030 	pop	{r4, r5, r14}
	mutex_release(&bdevs->lock);
8f63766c:	eaffaea4 	b	8f623104 <mutex_release>
8f637670:	ebffed52 	bl	8f632bc0 <__stack_chk_fail>
8f637674:	8f74221c 	.word	0x8f74221c

8f637678 <bio_unregister_device>:

void bio_unregister_device(bdev_t *dev)
{
8f637678:	e92d4030 	push	{r4, r5, r14}
	DEBUG_ASSERT(dev);

	LTRACEF(" '%s'\n", dev->name);

	// remove it from the list
	mutex_acquire(&bdevs->lock);
8f63767c:	e3025210 	movw	r5, #8720	; 0x2210
{
8f637680:	e59f30a8 	ldr	r3, [pc, #168]	; 8f637730 <bio_unregister_device+0xb8>
	mutex_acquire(&bdevs->lock);
8f637684:	e3485f74 	movt	r5, #36724	; 0x8f74
{
8f637688:	e24dd00c 	sub	r13, r13, #12
8f63768c:	e1a04000 	mov	r4, r0
8f637690:	e5933000 	ldr	r3, [r3]
8f637694:	e58d3004 	str	r3, [r13, #4]
8f637698:	e3a03000 	mov	r3, #0
	mutex_acquire(&bdevs->lock);
8f63769c:	e5953000 	ldr	r3, [r5]
8f6376a0:	e2830008 	add	r0, r3, #8
8f6376a4:	ebffae48 	bl	8f622fcc <mutex_acquire>
	item->next->prev = item->prev;
8f6376a8:	e5941004 	ldr	r1, [r4, #4]
8f6376ac:	e5942000 	ldr	r2, [r4]
	item->prev = item->next = 0;
8f6376b0:	e3a03000 	mov	r3, #0
	list_delete(&dev->node);
	mutex_release(&bdevs->lock);
8f6376b4:	e5950000 	ldr	r0, [r5]
8f6376b8:	e1a05004 	mov	r5, r4
	item->next->prev = item->prev;
8f6376bc:	e5812000 	str	r2, [r1]
8f6376c0:	e2800008 	add	r0, r0, #8
	item->prev->next = item->next;
8f6376c4:	e5821004 	str	r1, [r2, #4]
	item->prev = item->next = 0;
8f6376c8:	e5843004 	str	r3, [r4, #4]
8f6376cc:	e4853008 	str	r3, [r5], #8
8f6376d0:	ebffae8b 	bl	8f623104 <mutex_release>
	int oldval = atomic_add(&dev->ref, -1);
8f6376d4:	e3e01000 	mvn	r1, #0
8f6376d8:	e1a00005 	mov	r0, r5
8f6376dc:	ebffa657 	bl	8f621040 <atomic_add>
	if (oldval == 1) {
8f6376e0:	e59f3048 	ldr	r3, [pc, #72]	; 8f637730 <bio_unregister_device+0xb8>
8f6376e4:	e3500001 	cmp	r0, #1
8f6376e8:	0a000006 	beq	8f637708 <bio_unregister_device+0x90>

	bdev_dec_ref(dev); // remove the ref the list used to have
}
8f6376ec:	e5932000 	ldr	r2, [r3]
8f6376f0:	e59d3004 	ldr	r3, [r13, #4]
8f6376f4:	e0332002 	eors	r2, r3, r2
8f6376f8:	e3a03000 	mov	r3, #0
8f6376fc:	1a00000a 	bne	8f63772c <bio_unregister_device+0xb4>
8f637700:	e28dd00c 	add	r13, r13, #12
8f637704:	e8bd8030 	pop	{r4, r5, r15}
8f637708:	e5932000 	ldr	r2, [r3]
8f63770c:	e59d3004 	ldr	r3, [r13, #4]
8f637710:	e0332002 	eors	r2, r3, r2
8f637714:	e3a03000 	mov	r3, #0
8f637718:	1a000003 	bne	8f63772c <bio_unregister_device+0xb4>
8f63771c:	e1a00004 	mov	r0, r4
8f637720:	e28dd00c 	add	r13, r13, #12
8f637724:	e8bd4030 	pop	{r4, r5, r14}
8f637728:	eafffcd5 	b	8f636a84 <bdev_dec_ref.part.0>
8f63772c:	ebffed23 	bl	8f632bc0 <__stack_chk_fail>
8f637730:	8f74221c 	.word	0x8f74221c

8f637734 <bio_init>:
	}
	mutex_release(&bdevs->lock);
}

void bio_init(void)
{
8f637734:	e59f3058 	ldr	r3, [pc, #88]	; 8f637794 <bio_init+0x60>
	bdevs = malloc(sizeof(*bdevs));
8f637738:	e3a00024 	mov	r0, #36	; 0x24
{
8f63773c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f637740:	e24dd00c 	sub	r13, r13, #12
8f637744:	e5933000 	ldr	r3, [r3]
8f637748:	e58d3004 	str	r3, [r13, #4]
8f63774c:	e3a03000 	mov	r3, #0
	bdevs = malloc(sizeof(*bdevs));
8f637750:	ebfff229 	bl	8f633ffc <malloc>
8f637754:	e3023210 	movw	r3, #8720	; 0x2210
8f637758:	e3483f74 	movt	r3, #36724	; 0x8f74
8f63775c:	e5830000 	str	r0, [r3]

	list_initialize(&bdevs->list);
	mutex_init(&bdevs->lock);
8f637760:	e59f302c 	ldr	r3, [pc, #44]	; 8f637794 <bio_init+0x60>
	list->prev = list->next = list;
8f637764:	e5800004 	str	r0, [r0, #4]
8f637768:	e5800000 	str	r0, [r0]
8f63776c:	e5932000 	ldr	r2, [r3]
8f637770:	e59d3004 	ldr	r3, [r13, #4]
8f637774:	e0332002 	eors	r2, r3, r2
8f637778:	e3a03000 	mov	r3, #0
8f63777c:	1a000003 	bne	8f637790 <bio_init+0x5c>
8f637780:	e2800008 	add	r0, r0, #8
}
8f637784:	e28dd00c 	add	r13, r13, #12
8f637788:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	mutex_init(&bdevs->lock);
8f63778c:	eaffadf7 	b	8f622f70 <mutex_init>
8f637790:	ebffed0a 	bl	8f632bc0 <__stack_chk_fail>
8f637794:	8f74221c 	.word	0x8f74221c

8f637798 <subdev_close>:

	return bio_erase(subdev->parent, offset + subdev->offset * subdev->dev.block_size, len);
}

static void subdev_close(struct bdev *_dev)
{
8f637798:	e59f3048 	ldr	r3, [pc, #72]	; 8f6377e8 <subdev_close+0x50>
8f63779c:	e92d4010 	push	{r4, r14}
8f6377a0:	e1a04000 	mov	r4, r0
8f6377a4:	e24dd008 	sub	r13, r13, #8
	subdev_t *subdev = (subdev_t *)_dev;

	bio_close(subdev->parent);
8f6377a8:	e5900048 	ldr	r0, [r0, #72]	; 0x48
{
8f6377ac:	e5933000 	ldr	r3, [r3]
8f6377b0:	e58d3004 	str	r3, [r13, #4]
8f6377b4:	e3a03000 	mov	r3, #0
	bio_close(subdev->parent);
8f6377b8:	ebfffe5f 	bl	8f63713c <bio_close>
	subdev->parent = NULL;
8f6377bc:	e3a03000 	mov	r3, #0
8f6377c0:	e5843048 	str	r3, [r4, #72]	; 0x48
}
8f6377c4:	e59f301c 	ldr	r3, [pc, #28]	; 8f6377e8 <subdev_close+0x50>
8f6377c8:	e5932000 	ldr	r2, [r3]
8f6377cc:	e59d3004 	ldr	r3, [r13, #4]
8f6377d0:	e0332002 	eors	r2, r3, r2
8f6377d4:	e3a03000 	mov	r3, #0
8f6377d8:	1a000001 	bne	8f6377e4 <subdev_close+0x4c>
8f6377dc:	e28dd008 	add	r13, r13, #8
8f6377e0:	e8bd8010 	pop	{r4, r15}
8f6377e4:	ebffecf5 	bl	8f632bc0 <__stack_chk_fail>
8f6377e8:	8f74221c 	.word	0x8f74221c

8f6377ec <subdev_erase>:
{
8f6377ec:	e59fc060 	ldr	r12, [pc, #96]	; 8f637854 <subdev_erase+0x68>
8f6377f0:	e92d4010 	push	{r4, r14}
8f6377f4:	e24dd008 	sub	r13, r13, #8
8f6377f8:	e59cc000 	ldr	r12, [r12]
8f6377fc:	e58dc004 	str	r12, [r13, #4]
8f637800:	e3a0c000 	mov	r12, #0
	return bio_erase(subdev->parent, offset + subdev->offset * subdev->dev.block_size, len);
8f637804:	e59fc048 	ldr	r12, [pc, #72]	; 8f637854 <subdev_erase+0x68>
{
8f637808:	e59d1010 	ldr	r1, [r13, #16]
	return bio_erase(subdev->parent, offset + subdev->offset * subdev->dev.block_size, len);
8f63780c:	e59ce000 	ldr	r14, [r12]
8f637810:	e59dc004 	ldr	r12, [r13, #4]
8f637814:	e03ce00e 	eors	r14, r12, r14
8f637818:	e3a0c000 	mov	r12, #0
8f63781c:	1a00000b 	bne	8f637850 <subdev_erase+0x64>
8f637820:	e58d1010 	str	r1, [r13, #16]
8f637824:	e590e018 	ldr	r14, [r0, #24]
8f637828:	e5901050 	ldr	r1, [r0, #80]	; 0x50
8f63782c:	e5904054 	ldr	r4, [r0, #84]	; 0x54
8f637830:	e5900048 	ldr	r0, [r0, #72]	; 0x48
8f637834:	e08c1e91 	umull	r1, r12, r1, r14
8f637838:	e0912002 	adds	r2, r1, r2
8f63783c:	e02cc49e 	mla	r12, r14, r4, r12
8f637840:	e0ac3003 	adc	r3, r12, r3
}
8f637844:	e28dd008 	add	r13, r13, #8
8f637848:	e8bd4010 	pop	{r4, r14}
	return bio_erase(subdev->parent, offset + subdev->offset * subdev->dev.block_size, len);
8f63784c:	eaffff09 	b	8f637478 <bio_erase>
8f637850:	ebffecda 	bl	8f632bc0 <__stack_chk_fail>
8f637854:	8f74221c 	.word	0x8f74221c

8f637858 <subdev_write_block>:
{
8f637858:	e59fc044 	ldr	r12, [pc, #68]	; 8f6378a4 <subdev_write_block+0x4c>
8f63785c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f637860:	e24dd00c 	sub	r13, r13, #12
8f637864:	e59cc000 	ldr	r12, [r12]
8f637868:	e58dc004 	str	r12, [r13, #4]
8f63786c:	e3a0c000 	mov	r12, #0
	return bio_write_block(subdev->parent, buf, block + subdev->offset, count);
8f637870:	e59fc02c 	ldr	r12, [pc, #44]	; 8f6378a4 <subdev_write_block+0x4c>
8f637874:	e59ce000 	ldr	r14, [r12]
8f637878:	e59dc004 	ldr	r12, [r13, #4]
8f63787c:	e03ce00e 	eors	r14, r12, r14
8f637880:	e3a0c000 	mov	r12, #0
8f637884:	1a000005 	bne	8f6378a0 <subdev_write_block+0x48>
8f637888:	e590c050 	ldr	r12, [r0, #80]	; 0x50
8f63788c:	e5900048 	ldr	r0, [r0, #72]	; 0x48
8f637890:	e082200c 	add	r2, r2, r12
}
8f637894:	e28dd00c 	add	r13, r13, #12
8f637898:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return bio_write_block(subdev->parent, buf, block + subdev->offset, count);
8f63789c:	eafffece 	b	8f6373dc <bio_write_block>
8f6378a0:	ebffecc6 	bl	8f632bc0 <__stack_chk_fail>
8f6378a4:	8f74221c 	.word	0x8f74221c

8f6378a8 <subdev_write>:
{
8f6378a8:	e92d4030 	push	{r4, r5, r14}
8f6378ac:	e24dd00c 	sub	r13, r13, #12
8f6378b0:	e59fe058 	ldr	r14, [pc, #88]	; 8f637910 <subdev_write+0x68>
8f6378b4:	e59dc018 	ldr	r12, [r13, #24]
8f6378b8:	e59ee000 	ldr	r14, [r14]
8f6378bc:	e58de004 	str	r14, [r13, #4]
8f6378c0:	e3a0e000 	mov	r14, #0
	return bio_write(subdev->parent, buf, offset + subdev->offset * subdev->dev.block_size, len);
8f6378c4:	e59fe044 	ldr	r14, [pc, #68]	; 8f637910 <subdev_write+0x68>
8f6378c8:	e59e4000 	ldr	r4, [r14]
8f6378cc:	e59de004 	ldr	r14, [r13, #4]
8f6378d0:	e03e4004 	eors	r4, r14, r4
8f6378d4:	e3a0e000 	mov	r14, #0
8f6378d8:	1a00000b 	bne	8f63790c <subdev_write+0x64>
8f6378dc:	e58dc018 	str	r12, [r13, #24]
8f6378e0:	e5904018 	ldr	r4, [r0, #24]
8f6378e4:	e590c050 	ldr	r12, [r0, #80]	; 0x50
8f6378e8:	e5905054 	ldr	r5, [r0, #84]	; 0x54
8f6378ec:	e5900048 	ldr	r0, [r0, #72]	; 0x48
8f6378f0:	e08ec49c 	umull	r12, r14, r12, r4
8f6378f4:	e09c2002 	adds	r2, r12, r2
8f6378f8:	e02ee594 	mla	r14, r4, r5, r14
8f6378fc:	e0ae3003 	adc	r3, r14, r3
}
8f637900:	e28dd00c 	add	r13, r13, #12
8f637904:	e8bd4030 	pop	{r4, r5, r14}
	return bio_write(subdev->parent, buf, offset + subdev->offset * subdev->dev.block_size, len);
8f637908:	eafffe82 	b	8f637318 <bio_write>
8f63790c:	ebffecab 	bl	8f632bc0 <__stack_chk_fail>
8f637910:	8f74221c 	.word	0x8f74221c

8f637914 <subdev_read_block>:
{
8f637914:	e59fc044 	ldr	r12, [pc, #68]	; 8f637960 <subdev_read_block+0x4c>
8f637918:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f63791c:	e24dd00c 	sub	r13, r13, #12
8f637920:	e59cc000 	ldr	r12, [r12]
8f637924:	e58dc004 	str	r12, [r13, #4]
8f637928:	e3a0c000 	mov	r12, #0
	return bio_read_block(subdev->parent, buf, (off_t)block + subdev->offset, count);
8f63792c:	e59fc02c 	ldr	r12, [pc, #44]	; 8f637960 <subdev_read_block+0x4c>
8f637930:	e59ce000 	ldr	r14, [r12]
8f637934:	e59dc004 	ldr	r12, [r13, #4]
8f637938:	e03ce00e 	eors	r14, r12, r14
8f63793c:	e3a0c000 	mov	r12, #0
8f637940:	1a000005 	bne	8f63795c <subdev_read_block+0x48>
8f637944:	e590c050 	ldr	r12, [r0, #80]	; 0x50
8f637948:	e5900048 	ldr	r0, [r0, #72]	; 0x48
8f63794c:	e082200c 	add	r2, r2, r12
}
8f637950:	e28dd00c 	add	r13, r13, #12
8f637954:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return bio_read_block(subdev->parent, buf, (off_t)block + subdev->offset, count);
8f637958:	eafffe47 	b	8f63727c <bio_read_block>
8f63795c:	ebffec97 	bl	8f632bc0 <__stack_chk_fail>
8f637960:	8f74221c 	.word	0x8f74221c

8f637964 <subdev_read>:
{
8f637964:	e92d4030 	push	{r4, r5, r14}
8f637968:	e24dd00c 	sub	r13, r13, #12
8f63796c:	e59fe058 	ldr	r14, [pc, #88]	; 8f6379cc <subdev_read+0x68>
8f637970:	e59dc018 	ldr	r12, [r13, #24]
8f637974:	e59ee000 	ldr	r14, [r14]
8f637978:	e58de004 	str	r14, [r13, #4]
8f63797c:	e3a0e000 	mov	r14, #0
	return bio_read(subdev->parent, buf, (off_t)offset + (off_t)subdev->offset * (off_t)subdev->dev.block_size, len);
8f637980:	e59fe044 	ldr	r14, [pc, #68]	; 8f6379cc <subdev_read+0x68>
8f637984:	e59e4000 	ldr	r4, [r14]
8f637988:	e59de004 	ldr	r14, [r13, #4]
8f63798c:	e03e4004 	eors	r4, r14, r4
8f637990:	e3a0e000 	mov	r14, #0
8f637994:	1a00000b 	bne	8f6379c8 <subdev_read+0x64>
8f637998:	e58dc018 	str	r12, [r13, #24]
8f63799c:	e5904018 	ldr	r4, [r0, #24]
8f6379a0:	e590c050 	ldr	r12, [r0, #80]	; 0x50
8f6379a4:	e5905054 	ldr	r5, [r0, #84]	; 0x54
8f6379a8:	e5900048 	ldr	r0, [r0, #72]	; 0x48
8f6379ac:	e08ec49c 	umull	r12, r14, r12, r4
8f6379b0:	e09c2002 	adds	r2, r12, r2
8f6379b4:	e02ee594 	mla	r14, r4, r5, r14
8f6379b8:	e0ae3003 	adc	r3, r14, r3
}
8f6379bc:	e28dd00c 	add	r13, r13, #12
8f6379c0:	e8bd4030 	pop	{r4, r5, r14}
	return bio_read(subdev->parent, buf, (off_t)offset + (off_t)subdev->offset * (off_t)subdev->dev.block_size, len);
8f6379c4:	eafffdfb 	b	8f6371b8 <bio_read>
8f6379c8:	ebffec7c 	bl	8f632bc0 <__stack_chk_fail>
8f6379cc:	8f74221c 	.word	0x8f74221c

8f6379d0 <bio_publish_subdevice>:

status_t bio_publish_subdevice(const char *parent_dev, const char *subdev, bnum_t startblock, size_t len)
{
8f6379d0:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f6379d4:	e1a07003 	mov	r7, r3
8f6379d8:	e59f30d4 	ldr	r3, [pc, #212]	; 8f637ab4 <bio_publish_subdevice+0xe4>
8f6379dc:	e24dd008 	sub	r13, r13, #8
8f6379e0:	e1a08001 	mov	r8, r1
8f6379e4:	e1a06002 	mov	r6, r2
8f6379e8:	e5933000 	ldr	r3, [r3]
8f6379ec:	e58d3004 	str	r3, [r13, #4]
8f6379f0:	e3a03000 	mov	r3, #0
	LTRACEF("parent %s, sub %s, startblock %u, len %zd\n", parent_dev, subdev, startblock, len);

	bdev_t *parent = bio_open(parent_dev);
8f6379f4:	ebfffda3 	bl	8f637088 <bio_open>
	if (!parent)
8f6379f8:	e2505000 	subs	r5, r0, #0
8f6379fc:	0a000029 	beq	8f637aa8 <bio_publish_subdevice+0xd8>
		return -1;

	/* make sure we're able to do this */
	if (startblock + len > parent->block_count)
8f637a00:	e595201c 	ldr	r2, [r5, #28]
8f637a04:	e0863007 	add	r3, r6, r7
8f637a08:	e1530002 	cmp	r3, r2
8f637a0c:	8a000025 	bhi	8f637aa8 <bio_publish_subdevice+0xd8>
		return -1;

	subdev_t *sub = malloc(sizeof(subdev_t));
8f637a10:	e3a00058 	mov	r0, #88	; 0x58
8f637a14:	ebfff178 	bl	8f633ffc <malloc>
	bio_initialize_bdev(&sub->dev, subdev, parent->block_size, len);
8f637a18:	e1a03007 	mov	r3, r7
8f637a1c:	e5952018 	ldr	r2, [r5, #24]
8f637a20:	e1a01008 	mov	r1, r8

	sub->parent = parent;
	sub->offset = startblock;
8f637a24:	e3a07000 	mov	r7, #0
	subdev_t *sub = malloc(sizeof(subdev_t));
8f637a28:	e1a04000 	mov	r4, r0
	bio_initialize_bdev(&sub->dev, subdev, parent->block_size, len);
8f637a2c:	ebfffec1 	bl	8f637538 <bio_initialize_bdev>
	sub->dev.write = &subdev_write;
	sub->dev.write_block = &subdev_write_block;
	sub->dev.erase = &subdev_erase;
	sub->dev.close = &subdev_close;

	bio_register_device(&sub->dev);
8f637a30:	e1a00004 	mov	r0, r4
	sub->dev.read = &subdev_read;
8f637a34:	e3072964 	movw	r2, #31076	; 0x7964
	sub->dev.read_block = &subdev_read_block;
8f637a38:	e3073914 	movw	r3, #30996	; 0x7914
	sub->dev.read = &subdev_read;
8f637a3c:	e3482f63 	movt	r2, #36707	; 0x8f63
	sub->dev.read_block = &subdev_read_block;
8f637a40:	e3483f63 	movt	r3, #36707	; 0x8f63
	sub->parent = parent;
8f637a44:	e5845048 	str	r5, [r4, #72]	; 0x48
	sub->dev.read_block = &subdev_read_block;
8f637a48:	e1c422fc 	strd	r2, [r4, #44]	; 0x2c
	sub->dev.write = &subdev_write;
8f637a4c:	e30728a8 	movw	r2, #30888	; 0x78a8
	sub->dev.write_block = &subdev_write_block;
8f637a50:	e3073858 	movw	r3, #30808	; 0x7858
	sub->dev.write = &subdev_write;
8f637a54:	e3482f63 	movt	r2, #36707	; 0x8f63
	sub->dev.write_block = &subdev_write_block;
8f637a58:	e3483f63 	movt	r3, #36707	; 0x8f63
	sub->offset = startblock;
8f637a5c:	e5846050 	str	r6, [r4, #80]	; 0x50
	sub->dev.write_block = &subdev_write_block;
8f637a60:	e1c423f4 	strd	r2, [r4, #52]	; 0x34
	sub->dev.erase = &subdev_erase;
8f637a64:	e30727ec 	movw	r2, #30700	; 0x77ec
	sub->dev.close = &subdev_close;
8f637a68:	e3073798 	movw	r3, #30616	; 0x7798
	sub->dev.erase = &subdev_erase;
8f637a6c:	e3482f63 	movt	r2, #36707	; 0x8f63
	sub->dev.close = &subdev_close;
8f637a70:	e3483f63 	movt	r3, #36707	; 0x8f63
	sub->offset = startblock;
8f637a74:	e5847054 	str	r7, [r4, #84]	; 0x54
	sub->dev.erase = &subdev_erase;
8f637a78:	e584203c 	str	r2, [r4, #60]	; 0x3c
	sub->dev.close = &subdev_close;
8f637a7c:	e5843044 	str	r3, [r4, #68]	; 0x44
	bio_register_device(&sub->dev);
8f637a80:	ebfffedc 	bl	8f6375f8 <bio_register_device>

	return 0;
8f637a84:	e1a00007 	mov	r0, r7
}
8f637a88:	e59f3024 	ldr	r3, [pc, #36]	; 8f637ab4 <bio_publish_subdevice+0xe4>
8f637a8c:	e5932000 	ldr	r2, [r3]
8f637a90:	e59d3004 	ldr	r3, [r13, #4]
8f637a94:	e0332002 	eors	r2, r3, r2
8f637a98:	e3a03000 	mov	r3, #0
8f637a9c:	1a000003 	bne	8f637ab0 <bio_publish_subdevice+0xe0>
8f637aa0:	e28dd008 	add	r13, r13, #8
8f637aa4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
		return -1;
8f637aa8:	e3e00000 	mvn	r0, #0
8f637aac:	eafffff5 	b	8f637a88 <bio_publish_subdevice+0xb8>
}
8f637ab0:	ebffec42 	bl	8f632bc0 <__stack_chk_fail>
8f637ab4:	8f74221c 	.word	0x8f74221c

8f637ab8 <find_mount>:
    }
    return NULL;
}

static struct fs_mount *find_mount(const char *path, const char **trimmed_path)
{
8f637ab8:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, r10, r14}
	struct fs_mount *mount;
	size_t pathlen = strlen(path);

	list_for_every_entry(&mounts, mount, struct fs_mount, node) {
8f637abc:	e304760c 	movw	r7, #17932	; 0x460c
{
8f637ac0:	e59f30a4 	ldr	r3, [pc, #164]	; 8f637b6c <find_mount+0xb4>
	list_for_every_entry(&mounts, mount, struct fs_mount, node) {
8f637ac4:	e3487f72 	movt	r7, #36722	; 0x8f72
{
8f637ac8:	e24dd008 	sub	r13, r13, #8
8f637acc:	e1a09000 	mov	r9, r0
8f637ad0:	e5933000 	ldr	r3, [r3]
8f637ad4:	e58d3004 	str	r3, [r13, #4]
8f637ad8:	e3a03000 	mov	r3, #0
8f637adc:	e1a0a001 	mov	r10, r1
	size_t pathlen = strlen(path);
8f637ae0:	ebfff348 	bl	8f634808 <strlen>
	list_for_every_entry(&mounts, mount, struct fs_mount, node) {
8f637ae4:	e5975004 	ldr	r5, [r7, #4]
8f637ae8:	e1550007 	cmp	r5, r7
8f637aec:	0a00000f 	beq	8f637b30 <find_mount+0x78>
8f637af0:	e1a08000 	mov	r8, r0
		size_t mountpathlen = strlen(mount->path);
8f637af4:	e5956008 	ldr	r6, [r5, #8]
8f637af8:	e1a00006 	mov	r0, r6
8f637afc:	ebfff341 	bl	8f634808 <strlen>
		if (pathlen < mountpathlen)
8f637b00:	e1580000 	cmp	r8, r0
		size_t mountpathlen = strlen(mount->path);
8f637b04:	e1a04000 	mov	r4, r0
		if (pathlen < mountpathlen)
8f637b08:	3a000005 	bcc	8f637b24 <find_mount+0x6c>
			continue;

		LTRACEF("comparing %s with %s\n", path, mount->path);

		if (memcmp(path, mount->path, mountpathlen) == 0) {
8f637b0c:	e1a02000 	mov	r2, r0
8f637b10:	e1a01006 	mov	r1, r6
8f637b14:	e1a00009 	mov	r0, r9
8f637b18:	ebfff22e 	bl	8f6343d8 <memcmp>
8f637b1c:	e3500000 	cmp	r0, #0
8f637b20:	0a00000c 	beq	8f637b58 <find_mount+0xa0>
	list_for_every_entry(&mounts, mount, struct fs_mount, node) {
8f637b24:	e5955004 	ldr	r5, [r5, #4]
8f637b28:	e1550007 	cmp	r5, r7
8f637b2c:	1afffff0 	bne	8f637af4 <find_mount+0x3c>

			return mount;
		}
	}

	return NULL;
8f637b30:	e3a05000 	mov	r5, #0
}
8f637b34:	e59f3030 	ldr	r3, [pc, #48]	; 8f637b6c <find_mount+0xb4>
8f637b38:	e5932000 	ldr	r2, [r3]
8f637b3c:	e59d3004 	ldr	r3, [r13, #4]
8f637b40:	e0332002 	eors	r2, r3, r2
8f637b44:	e3a03000 	mov	r3, #0
8f637b48:	1a000006 	bne	8f637b68 <find_mount+0xb0>
8f637b4c:	e1a00005 	mov	r0, r5
8f637b50:	e28dd008 	add	r13, r13, #8
8f637b54:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, r15}
			if (trimmed_path)
8f637b58:	e35a0000 	cmp	r10, #0
				*trimmed_path = &path[mountpathlen];
8f637b5c:	10894004 	addne	r4, r9, r4
8f637b60:	158a4000 	strne	r4, [r10]
8f637b64:	eafffff2 	b	8f637b34 <find_mount+0x7c>
}
8f637b68:	ebffec14 	bl	8f632bc0 <__stack_chk_fail>
8f637b6c:	8f74221c 	.word	0x8f74221c

8f637b70 <put_mount.part.0>:
	return ERR_NOT_FOUND;

    return mount(path, device, fs->api);
}

static void put_mount(struct fs_mount *mount)
8f637b70:	e92d4010 	push	{r4, r14}
8f637b74:	e1a04000 	mov	r4, r0
	item->next->prev = item->prev;
8f637b78:	e5901004 	ldr	r1, [r0, #4]
8f637b7c:	e24dd008 	sub	r13, r13, #8
8f637b80:	e5902000 	ldr	r2, [r0]
{
	if (!(--mount->refs)) {
		list_delete(&mount->node);
        mount->api->unmount(mount->cookie);
8f637b84:	e5900018 	ldr	r0, [r0, #24]
static void put_mount(struct fs_mount *mount)
8f637b88:	e59f3064 	ldr	r3, [pc, #100]	; 8f637bf4 <put_mount.part.0+0x84>
8f637b8c:	e5933000 	ldr	r3, [r3]
8f637b90:	e58d3004 	str	r3, [r13, #4]
8f637b94:	e3a03000 	mov	r3, #0
8f637b98:	e5812000 	str	r2, [r1]
	item->prev = item->next = 0;
8f637b9c:	e3a03000 	mov	r3, #0
	item->prev->next = item->next;
8f637ba0:	e5821004 	str	r1, [r2, #4]
        mount->api->unmount(mount->cookie);
8f637ba4:	e5902004 	ldr	r2, [r0, #4]
	item->prev = item->next = 0;
8f637ba8:	e5843004 	str	r3, [r4, #4]
8f637bac:	e5843000 	str	r3, [r4]
8f637bb0:	e5940010 	ldr	r0, [r4, #16]
8f637bb4:	e12fff32 	blx	r2
		free(mount->path);
8f637bb8:	e5940008 	ldr	r0, [r4, #8]
8f637bbc:	ebfff152 	bl	8f63410c <free>
		bio_close(mount->dev);
8f637bc0:	e594000c 	ldr	r0, [r4, #12]
8f637bc4:	ebfffd5c 	bl	8f63713c <bio_close>
		free(mount);
8f637bc8:	e59f3024 	ldr	r3, [pc, #36]	; 8f637bf4 <put_mount.part.0+0x84>
8f637bcc:	e5932000 	ldr	r2, [r3]
8f637bd0:	e59d3004 	ldr	r3, [r13, #4]
8f637bd4:	e0332002 	eors	r2, r3, r2
8f637bd8:	e3a03000 	mov	r3, #0
8f637bdc:	1a000003 	bne	8f637bf0 <put_mount.part.0+0x80>
8f637be0:	e1a00004 	mov	r0, r4
	}
}
8f637be4:	e28dd008 	add	r13, r13, #8
8f637be8:	e8bd4010 	pop	{r4, r14}
		free(mount);
8f637bec:	eafff146 	b	8f63410c <free>
8f637bf0:	ebffebf2 	bl	8f632bc0 <__stack_chk_fail>
8f637bf4:	8f74221c 	.word	0x8f74221c

8f637bf8 <fs_init>:
void fs_init(void) {
8f637bf8:	e59f3038 	ldr	r3, [pc, #56]	; 8f637c38 <fs_init+0x40>
8f637bfc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f637c00:	e24dd00c 	sub	r13, r13, #12
8f637c04:	e5933000 	ldr	r3, [r3]
8f637c08:	e58d3004 	str	r3, [r13, #4]
8f637c0c:	e3a03000 	mov	r3, #0
	ext2_init();
8f637c10:	e59f3020 	ldr	r3, [pc, #32]	; 8f637c38 <fs_init+0x40>
8f637c14:	e5932000 	ldr	r2, [r3]
8f637c18:	e59d3004 	ldr	r3, [r13, #4]
8f637c1c:	e0332002 	eors	r2, r3, r2
8f637c20:	e3a03000 	mov	r3, #0
8f637c24:	1a000002 	bne	8f637c34 <fs_init+0x3c>
}
8f637c28:	e28dd00c 	add	r13, r13, #12
8f637c2c:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	ext2_init();
8f637c30:	ea000edb 	b	8f63b7a4 <ext2_init>
8f637c34:	ebffebe1 	bl	8f632bc0 <__stack_chk_fail>
8f637c38:	8f74221c 	.word	0x8f74221c

8f637c3c <fs_register_type>:
{
8f637c3c:	e59f307c 	ldr	r3, [pc, #124]	; 8f637cc0 <fs_register_type+0x84>
8f637c40:	e92d4030 	push	{r4, r5, r14}
8f637c44:	e1a05000 	mov	r5, r0
8f637c48:	e24dd00c 	sub	r13, r13, #12
    fs = malloc(sizeof(struct fs));
8f637c4c:	e3a00010 	mov	r0, #16
{
8f637c50:	e5933000 	ldr	r3, [r3]
8f637c54:	e58d3004 	str	r3, [r13, #4]
8f637c58:	e3a03000 	mov	r3, #0
8f637c5c:	e1a04001 	mov	r4, r1
    fs = malloc(sizeof(struct fs));
8f637c60:	ebfff0e5 	bl	8f633ffc <malloc>
    if (!fs)
8f637c64:	e2503000 	subs	r3, r0, #0
8f637c68:	0a000011 	beq	8f637cb4 <fs_register_type+0x78>
	item->next = list->next;
8f637c6c:	e3042604 	movw	r2, #17924	; 0x4604
8f637c70:	e3482f72 	movt	r2, #36722	; 0x8f72
    return NO_ERROR;
8f637c74:	e3a00000 	mov	r0, #0
    fs->name = name;
8f637c78:	e5835008 	str	r5, [r3, #8]
8f637c7c:	e5921004 	ldr	r1, [r2, #4]
    fs->api = api;
8f637c80:	e583400c 	str	r4, [r3, #12]
	item->prev = list;
8f637c84:	e5832000 	str	r2, [r3]
	item->next = list->next;
8f637c88:	e5831004 	str	r1, [r3, #4]
	list->next->prev = item;
8f637c8c:	e5813000 	str	r3, [r1]
	list->next = item;
8f637c90:	e5823004 	str	r3, [r2, #4]
}
8f637c94:	e59f3024 	ldr	r3, [pc, #36]	; 8f637cc0 <fs_register_type+0x84>
8f637c98:	e5932000 	ldr	r2, [r3]
8f637c9c:	e59d3004 	ldr	r3, [r13, #4]
8f637ca0:	e0332002 	eors	r2, r3, r2
8f637ca4:	e3a03000 	mov	r3, #0
8f637ca8:	1a000003 	bne	8f637cbc <fs_register_type+0x80>
8f637cac:	e28dd00c 	add	r13, r13, #12
8f637cb0:	e8bd8030 	pop	{r4, r5, r15}
        return ERR_NO_MEMORY;
8f637cb4:	e3e00004 	mvn	r0, #4
8f637cb8:	eafffff5 	b	8f637c94 <fs_register_type+0x58>
}
8f637cbc:	ebffebbf 	bl	8f632bc0 <__stack_chk_fail>
8f637cc0:	8f74221c 	.word	0x8f74221c

8f637cc4 <fs_close_file>:

    return handle->mount->api->write(handle->cookie, buf, offset, len);
}

status_t fs_close_file(filehandle *handle)
{
8f637cc4:	e59f307c 	ldr	r3, [pc, #124]	; 8f637d48 <fs_close_file+0x84>
8f637cc8:	e92d4010 	push	{r4, r14}
8f637ccc:	e24dd008 	sub	r13, r13, #8
8f637cd0:	e5933000 	ldr	r3, [r3]
8f637cd4:	e58d3004 	str	r3, [r13, #4]
8f637cd8:	e3a03000 	mov	r3, #0
8f637cdc:	e1a04000 	mov	r4, r0
    status_t err = handle->mount->api->close(handle->cookie);
8f637ce0:	e8900009 	ldm	r0, {r0, r3}
8f637ce4:	e5933018 	ldr	r3, [r3, #24]
8f637ce8:	e593301c 	ldr	r3, [r3, #28]
8f637cec:	e12fff33 	blx	r3
    if (err < 0)
8f637cf0:	e3500000 	cmp	r0, #0
8f637cf4:	ba000008 	blt	8f637d1c <fs_close_file+0x58>
        return err;

    put_mount(handle->mount);
8f637cf8:	e5940004 	ldr	r0, [r4, #4]
	if (!(--mount->refs)) {
8f637cfc:	e5903014 	ldr	r3, [r0, #20]
8f637d00:	e2433001 	sub	r3, r3, #1
8f637d04:	e5803014 	str	r3, [r0, #20]
8f637d08:	e3530000 	cmp	r3, #0
8f637d0c:	0a00000a 	beq	8f637d3c <fs_close_file+0x78>
    free(handle);
8f637d10:	e1a00004 	mov	r0, r4
8f637d14:	ebfff0fc 	bl	8f63410c <free>
8f637d18:	e3a00000 	mov	r0, #0
    return 0;
}
8f637d1c:	e59f3024 	ldr	r3, [pc, #36]	; 8f637d48 <fs_close_file+0x84>
8f637d20:	e5932000 	ldr	r2, [r3]
8f637d24:	e59d3004 	ldr	r3, [r13, #4]
8f637d28:	e0332002 	eors	r2, r3, r2
8f637d2c:	e3a03000 	mov	r3, #0
8f637d30:	1a000003 	bne	8f637d44 <fs_close_file+0x80>
8f637d34:	e28dd008 	add	r13, r13, #8
8f637d38:	e8bd8010 	pop	{r4, r15}
8f637d3c:	ebffff8b 	bl	8f637b70 <put_mount.part.0>
8f637d40:	eafffff2 	b	8f637d10 <fs_close_file+0x4c>
8f637d44:	ebffeb9d 	bl	8f632bc0 <__stack_chk_fail>
8f637d48:	8f74221c 	.word	0x8f74221c

8f637d4c <fs_read_dir>:

    return 0;
}

status_t fs_read_dir(dirhandle *handle, struct dirent *ent)
{
8f637d4c:	e59f3074 	ldr	r3, [pc, #116]	; 8f637dc8 <fs_read_dir+0x7c>
8f637d50:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f637d54:	e24dd00c 	sub	r13, r13, #12
8f637d58:	e5933000 	ldr	r3, [r3]
8f637d5c:	e58d3004 	str	r3, [r13, #4]
8f637d60:	e3a03000 	mov	r3, #0
    if (!handle->mount->api->readdir)
8f637d64:	e5903004 	ldr	r3, [r0, #4]
8f637d68:	e5933018 	ldr	r3, [r3, #24]
8f637d6c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
8f637d70:	e3530000 	cmp	r3, #0
8f637d74:	0a000009 	beq	8f637da0 <fs_read_dir+0x54>
		return ERR_NOT_SUPPORTED;

    return handle->mount->api->readdir(handle->cookie, ent);
8f637d78:	e59f2048 	ldr	r2, [pc, #72]	; 8f637dc8 <fs_read_dir+0x7c>
8f637d7c:	e592c000 	ldr	r12, [r2]
8f637d80:	e59d2004 	ldr	r2, [r13, #4]
8f637d84:	e032c00c 	eors	r12, r2, r12
8f637d88:	e3a02000 	mov	r2, #0
8f637d8c:	1a00000c 	bne	8f637dc4 <fs_read_dir+0x78>
8f637d90:	e5900000 	ldr	r0, [r0]
}
8f637d94:	e28dd00c 	add	r13, r13, #12
8f637d98:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
    return handle->mount->api->readdir(handle->cookie, ent);
8f637d9c:	e12fff13 	bx	r3
}
8f637da0:	e59f3020 	ldr	r3, [pc, #32]	; 8f637dc8 <fs_read_dir+0x7c>
8f637da4:	e5932000 	ldr	r2, [r3]
8f637da8:	e59d3004 	ldr	r3, [r13, #4]
8f637dac:	e0332002 	eors	r2, r3, r2
8f637db0:	e3a03000 	mov	r3, #0
8f637db4:	1a000002 	bne	8f637dc4 <fs_read_dir+0x78>
8f637db8:	e3e00017 	mvn	r0, #23
8f637dbc:	e28dd00c 	add	r13, r13, #12
8f637dc0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f637dc4:	ebffeb7d 	bl	8f632bc0 <__stack_chk_fail>
8f637dc8:	8f74221c 	.word	0x8f74221c

8f637dcc <fs_close_dir>:

status_t fs_close_dir(dirhandle *handle)
{
8f637dcc:	e59f3090 	ldr	r3, [pc, #144]	; 8f637e64 <fs_close_dir+0x98>
8f637dd0:	e92d4010 	push	{r4, r14}
8f637dd4:	e24dd008 	sub	r13, r13, #8
8f637dd8:	e5933000 	ldr	r3, [r3]
8f637ddc:	e58d3004 	str	r3, [r13, #4]
8f637de0:	e3a03000 	mov	r3, #0
    if (!handle->mount->api->closedir)
8f637de4:	e5903004 	ldr	r3, [r0, #4]
8f637de8:	e5933018 	ldr	r3, [r3, #24]
8f637dec:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
8f637df0:	e3530000 	cmp	r3, #0
8f637df4:	0a000017 	beq	8f637e58 <fs_close_dir+0x8c>
        return ERR_NOT_SUPPORTED;

    status_t err = handle->mount->api->closedir(handle->cookie);
8f637df8:	e1a04000 	mov	r4, r0
8f637dfc:	e5900000 	ldr	r0, [r0]
8f637e00:	e12fff33 	blx	r3
	if (err < 0)
8f637e04:	e3500000 	cmp	r0, #0
8f637e08:	ba000008 	blt	8f637e30 <fs_close_dir+0x64>
		return err;

    put_mount(handle->mount);
8f637e0c:	e5940004 	ldr	r0, [r4, #4]
	if (!(--mount->refs)) {
8f637e10:	e5903014 	ldr	r3, [r0, #20]
8f637e14:	e2433001 	sub	r3, r3, #1
8f637e18:	e5803014 	str	r3, [r0, #20]
8f637e1c:	e3530000 	cmp	r3, #0
8f637e20:	0a00000a 	beq	8f637e50 <fs_close_dir+0x84>
    free(handle);
8f637e24:	e1a00004 	mov	r0, r4
8f637e28:	ebfff0b7 	bl	8f63410c <free>
	return 0;
8f637e2c:	e3a00000 	mov	r0, #0
}
8f637e30:	e59f302c 	ldr	r3, [pc, #44]	; 8f637e64 <fs_close_dir+0x98>
8f637e34:	e5932000 	ldr	r2, [r3]
8f637e38:	e59d3004 	ldr	r3, [r13, #4]
8f637e3c:	e0332002 	eors	r2, r3, r2
8f637e40:	e3a03000 	mov	r3, #0
8f637e44:	1a000005 	bne	8f637e60 <fs_close_dir+0x94>
8f637e48:	e28dd008 	add	r13, r13, #8
8f637e4c:	e8bd8010 	pop	{r4, r15}
8f637e50:	ebffff46 	bl	8f637b70 <put_mount.part.0>
8f637e54:	eafffff2 	b	8f637e24 <fs_close_dir+0x58>
        return ERR_NOT_SUPPORTED;
8f637e58:	e3e00017 	mvn	r0, #23
8f637e5c:	eafffff3 	b	8f637e30 <fs_close_dir+0x64>
}
8f637e60:	ebffeb56 	bl	8f632bc0 <__stack_chk_fail>
8f637e64:	8f74221c 	.word	0x8f74221c

8f637e68 <fs_normalize_path>:

    return read_bytes;
}

void fs_normalize_path(char *path)
{
8f637e68:	e59f322c 	ldr	r3, [pc, #556]	; 8f63809c <fs_normalize_path+0x234>
8f637e6c:	e1a01000 	mov	r1, r0
	outpos = 0;
	done = false;

	/* remove duplicate path seperators, flatten empty fields (only composed of .), backtrack fields with .., remove trailing slashes */
	while (!done) {
		c = path[pos];
8f637e70:	e5d02000 	ldrb	r2, [r0]
{
8f637e74:	e92d4030 	push	{r4, r5, r14}
	pos = 0;
8f637e78:	e3a0e000 	mov	r14, #0
{
8f637e7c:	e24dd00c 	sub	r13, r13, #12
	outpos = 0;
8f637e80:	e1a0c00e 	mov	r12, r14
{
8f637e84:	e5933000 	ldr	r3, [r3]
8f637e88:	e58d3004 	str	r3, [r13, #4]
8f637e8c:	e3a03000 	mov	r3, #0
					if (c == 0)
						done = true;
				} else {
					// a field prefixed with ..
					// emit the .. and move directly to the IN_FIELD state
					path[outpos++] = '.';
8f637e90:	e3a0402e 	mov	r4, #46	; 0x2e
8f637e94:	e3e03000 	mvn	r3, #0
				path[outpos++] = '/';
8f637e98:	e3a0502f 	mov	r5, #47	; 0x2f
		switch (state) {
8f637e9c:	e3530007 	cmp	r3, #7
8f637ea0:	979ff103 	ldrls	r15, [r15, r3, lsl #2]
8f637ea4:	ea00005a 	b	8f638014 <fs_normalize_path+0x1ac>
8f637ea8:	8f637fb4 	.word	0x8f637fb4
8f637eac:	8f637f8c 	.word	0x8f637f8c
8f637eb0:	8f637f70 	.word	0x8f637f70
8f637eb4:	8f637f1c 	.word	0x8f637f1c
8f637eb8:	8f637f08 	.word	0x8f637f08
8f637ebc:	8f637edc 	.word	0x8f637edc
8f637ec0:	8f637ec8 	.word	0x8f637ec8
8f637ec4:	8f637fc8 	.word	0x8f637fc8
				pos++; // consume the dot
8f637ec8:	e28ee001 	add	r14, r14, #1
		c = path[pos];
8f637ecc:	e1a01000 	mov	r1, r0
8f637ed0:	e3a03007 	mov	r3, #7
8f637ed4:	e7f1200e 	ldrb	r2, [r1, r14]!
8f637ed8:	eaffffef 	b	8f637e9c <fs_normalize_path+0x34>
				if (c == '.') {
8f637edc:	e352002e 	cmp	r2, #46	; 0x2e
8f637ee0:	0a000055 	beq	8f63803c <fs_normalize_path+0x1d4>
				} else if (c == '/') {
8f637ee4:	e352002f 	cmp	r2, #47	; 0x2f
8f637ee8:	0a000057 	beq	8f63804c <fs_normalize_path+0x1e4>
				} else if (c == 0) {
8f637eec:	e3520000 	cmp	r2, #0
8f637ef0:	0a00000d 	beq	8f637f2c <fs_normalize_path+0xc4>
					path[outpos++] = '.';
8f637ef4:	e7c0400c 	strb	r4, [r0, r12]
8f637ef8:	e28cc001 	add	r12, r12, #1
		c = path[pos];
8f637efc:	e5d12000 	ldrb	r2, [r1]
8f637f00:	e3a03001 	mov	r3, #1
8f637f04:	eaffffe4 	b	8f637e9c <fs_normalize_path+0x34>
				pos++; // consume the dot
8f637f08:	e28ee001 	add	r14, r14, #1
		c = path[pos];
8f637f0c:	e1a01000 	mov	r1, r0
8f637f10:	e3a03005 	mov	r3, #5
8f637f14:	e7f1200e 	ldrb	r2, [r1, r14]!
8f637f18:	eaffffdf 	b	8f637e9c <fs_normalize_path+0x34>
				if (c == '/') {
8f637f1c:	e352002f 	cmp	r2, #47	; 0x2f
8f637f20:	0a000041 	beq	8f63802c <fs_normalize_path+0x1c4>
				} else if (c == 0) {
8f637f24:	e3520000 	cmp	r2, #0
8f637f28:	1a000045 	bne	8f638044 <fs_normalize_path+0x1dc>
				break;
		}
	}

	/* dont end with trailing slashes */
	if (outpos > 0 && path[outpos - 1] == '/')
8f637f2c:	e35c0000 	cmp	r12, #0
		outpos--;

	path[outpos++] = 0;
8f637f30:	d1a0300c 	movle	r3, r12
	if (outpos > 0 && path[outpos - 1] == '/')
8f637f34:	da000003 	ble	8f637f48 <fs_normalize_path+0xe0>
8f637f38:	e24c3001 	sub	r3, r12, #1
8f637f3c:	e7d02003 	ldrb	r2, [r0, r3]
8f637f40:	e352002f 	cmp	r2, #47	; 0x2f
8f637f44:	11a0300c 	movne	r3, r12
	path[outpos++] = 0;
8f637f48:	e3a02000 	mov	r2, #0
8f637f4c:	e7c02003 	strb	r2, [r0, r3]
}
8f637f50:	e59f3144 	ldr	r3, [pc, #324]	; 8f63809c <fs_normalize_path+0x234>
8f637f54:	e5932000 	ldr	r2, [r3]
8f637f58:	e59d3004 	ldr	r3, [r13, #4]
8f637f5c:	e0332002 	eors	r2, r3, r2
8f637f60:	e3a03000 	mov	r3, #0
8f637f64:	1a000047 	bne	8f638088 <fs_normalize_path+0x220>
8f637f68:	e28dd00c 	add	r13, r13, #12
8f637f6c:	e8bd8030 	pop	{r4, r5, r15}
				pos++;
8f637f70:	e28ee001 	add	r14, r14, #1
		c = path[pos];
8f637f74:	e1a01000 	mov	r1, r0
				path[outpos++] = '/';
8f637f78:	e7c0500c 	strb	r5, [r0, r12]
	while (!done) {
8f637f7c:	e3a03003 	mov	r3, #3
		c = path[pos];
8f637f80:	e7f1200e 	ldrb	r2, [r1, r14]!
				path[outpos++] = '/';
8f637f84:	e28cc001 	add	r12, r12, #1
8f637f88:	eaffffc3 	b	8f637e9c <fs_normalize_path+0x34>
				if (c == '/') {
8f637f8c:	e352002f 	cmp	r2, #47	; 0x2f
8f637f90:	0a000021 	beq	8f63801c <fs_normalize_path+0x1b4>
				} else if (c == 0) {
8f637f94:	e3520000 	cmp	r2, #0
8f637f98:	0affffe3 	beq	8f637f2c <fs_normalize_path+0xc4>
					pos++;
8f637f9c:	e28ee001 	add	r14, r14, #1
		c = path[pos];
8f637fa0:	e1a01000 	mov	r1, r0
					path[outpos++] = c;
8f637fa4:	e7c0200c 	strb	r2, [r0, r12]
8f637fa8:	e28cc001 	add	r12, r12, #1
		c = path[pos];
8f637fac:	e7f1200e 	ldrb	r2, [r1, r14]!
8f637fb0:	eaffffb9 	b	8f637e9c <fs_normalize_path+0x34>
				if (c == '.') {
8f637fb4:	e352002e 	cmp	r2, #46	; 0x2e
8f637fb8:	0a000019 	beq	8f638024 <fs_normalize_path+0x1bc>
				} else if (c == 0) {
8f637fbc:	e3520000 	cmp	r2, #0
8f637fc0:	0affffd9 	beq	8f637f2c <fs_normalize_path+0xc4>
8f637fc4:	eaffffcd 	b	8f637f00 <fs_normalize_path+0x98>
				if (c == '/' || c == 0) {
8f637fc8:	e3520000 	cmp	r2, #0
8f637fcc:	1352002f 	cmpne	r2, #47	; 0x2f
8f637fd0:	1a000008 	bne	8f637ff8 <fs_normalize_path+0x190>
					if (outpos > 0) {
8f637fd4:	e35c0000 	cmp	r12, #0
8f637fd8:	ca000020 	bgt	8f638060 <fs_normalize_path+0x1f8>
	while (!done) {
8f637fdc:	e3520000 	cmp	r2, #0
					pos++;
8f637fe0:	e28ee001 	add	r14, r14, #1
	while (!done) {
8f637fe4:	0affffd0 	beq	8f637f2c <fs_normalize_path+0xc4>
		c = path[pos];
8f637fe8:	e1a01000 	mov	r1, r0
8f637fec:	e3a03003 	mov	r3, #3
8f637ff0:	e7f1200e 	ldrb	r2, [r1, r14]!
8f637ff4:	eaffffa8 	b	8f637e9c <fs_normalize_path+0x34>
					path[outpos++] = '.';
8f637ff8:	e28c2001 	add	r2, r12, #1
8f637ffc:	e7c0400c 	strb	r4, [r0, r12]
					path[outpos++] = '.';
8f638000:	e3a03001 	mov	r3, #1
8f638004:	e28cc002 	add	r12, r12, #2
8f638008:	e7c04002 	strb	r4, [r0, r2]
		c = path[pos];
8f63800c:	e5d12000 	ldrb	r2, [r1]
8f638010:	eaffffa1 	b	8f637e9c <fs_normalize_path+0x34>
				if (c == '/') {
8f638014:	e352002f 	cmp	r2, #47	; 0x2f
8f638018:	1a00001b 	bne	8f63808c <fs_normalize_path+0x224>
8f63801c:	e3a03002 	mov	r3, #2
8f638020:	eaffff9d 	b	8f637e9c <fs_normalize_path+0x34>
8f638024:	e3a03004 	mov	r3, #4
8f638028:	eaffff9b 	b	8f637e9c <fs_normalize_path+0x34>
					pos++;
8f63802c:	e28ee001 	add	r14, r14, #1
		c = path[pos];
8f638030:	e1a01000 	mov	r1, r0
8f638034:	e7f1200e 	ldrb	r2, [r1, r14]!
8f638038:	eaffff97 	b	8f637e9c <fs_normalize_path+0x34>
8f63803c:	e3a03006 	mov	r3, #6
8f638040:	eaffff95 	b	8f637e9c <fs_normalize_path+0x34>
8f638044:	e3a03000 	mov	r3, #0
8f638048:	eaffff93 	b	8f637e9c <fs_normalize_path+0x34>
					pos++;
8f63804c:	e28ee001 	add	r14, r14, #1
		c = path[pos];
8f638050:	e1a01000 	mov	r1, r0
8f638054:	e3a03003 	mov	r3, #3
8f638058:	e7f1200e 	ldrb	r2, [r1, r14]!
8f63805c:	eaffff8e 	b	8f637e9c <fs_normalize_path+0x34>
						while (outpos > 0) {
8f638060:	e25cc001 	subs	r12, r12, #1
8f638064:	0affffdc 	beq	8f637fdc <fs_normalize_path+0x174>
8f638068:	e080300c 	add	r3, r0, r12
8f63806c:	ea000001 	b	8f638078 <fs_normalize_path+0x210>
8f638070:	e25cc001 	subs	r12, r12, #1
8f638074:	0affffd8 	beq	8f637fdc <fs_normalize_path+0x174>
							if (path[outpos - 1] == '/') {
8f638078:	e5731001 	ldrb	r1, [r3, #-1]!
8f63807c:	e351002f 	cmp	r1, #47	; 0x2f
8f638080:	1afffffa 	bne	8f638070 <fs_normalize_path+0x208>
8f638084:	eaffffd4 	b	8f637fdc <fs_normalize_path+0x174>
}
8f638088:	ebffeacc 	bl	8f632bc0 <__stack_chk_fail>
				} else if (c == '.') {
8f63808c:	e352002e 	cmp	r2, #46	; 0x2e
8f638090:	13a03000 	movne	r3, #0
8f638094:	03a03004 	moveq	r3, #4
8f638098:	eaffff7f 	b	8f637e9c <fs_normalize_path+0x34>
8f63809c:	8f74221c 	.word	0x8f74221c

8f6380a0 <mount>:
{
8f6380a0:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f6380a4:	e24ddf83 	sub	r13, r13, #524	; 0x20c
8f6380a8:	e59f3108 	ldr	r3, [pc, #264]	; 8f6381b8 <mount+0x118>
8f6380ac:	e1a05001 	mov	r5, r1
8f6380b0:	e1a06002 	mov	r6, r2
	strlcpy(temppath, path, sizeof(temppath));
8f6380b4:	e1a01000 	mov	r1, r0
8f6380b8:	e3a02c02 	mov	r2, #512	; 0x200
8f6380bc:	e28d0004 	add	r0, r13, #4
{
8f6380c0:	e5933000 	ldr	r3, [r3]
8f6380c4:	e58d3204 	str	r3, [r13, #516]	; 0x204
8f6380c8:	e3a03000 	mov	r3, #0
	strlcpy(temppath, path, sizeof(temppath));
8f6380cc:	ebfff197 	bl	8f634730 <strlcpy>
	fs_normalize_path(temppath);
8f6380d0:	e28d0004 	add	r0, r13, #4
8f6380d4:	ebffff63 	bl	8f637e68 <fs_normalize_path>
	if(temppath[0] != '/')
8f6380d8:	e5dd3004 	ldrb	r3, [r13, #4]
8f6380dc:	e353002f 	cmp	r3, #47	; 0x2f
8f6380e0:	1a00002f 	bne	8f6381a4 <mount+0x104>
	if (find_mount(temppath, NULL))
8f6380e4:	e28d0004 	add	r0, r13, #4
8f6380e8:	e3a01000 	mov	r1, #0
8f6380ec:	ebfffe71 	bl	8f637ab8 <find_mount>
8f6380f0:	e2504000 	subs	r4, r0, #0
8f6380f4:	1a000028 	bne	8f63819c <mount+0xfc>
	bdev_t *dev = bio_open(device);
8f6380f8:	e1a00005 	mov	r0, r5
8f6380fc:	ebfffbe1 	bl	8f637088 <bio_open>
	if (!dev)
8f638100:	e2507000 	subs	r7, r0, #0
8f638104:	0a000028 	beq	8f6381ac <mount+0x10c>
    status_t err = api->mount(dev, &cookie);
8f638108:	e5963000 	ldr	r3, [r6]
8f63810c:	e1a0100d 	mov	r1, r13
8f638110:	e12fff33 	blx	r3
	if (err < 0) {
8f638114:	e2505000 	subs	r5, r0, #0
8f638118:	ba00001c 	blt	8f638190 <mount+0xf0>
	struct fs_mount *mount = malloc(sizeof(struct fs_mount));
8f63811c:	e3a0001c 	mov	r0, #28
	return 0;
8f638120:	e1a05004 	mov	r5, r4
	struct fs_mount *mount = malloc(sizeof(struct fs_mount));
8f638124:	ebffefb4 	bl	8f633ffc <malloc>
8f638128:	e1a04000 	mov	r4, r0
	mount->path = strdup(temppath);
8f63812c:	e28d0004 	add	r0, r13, #4
8f638130:	ebfff12c 	bl	8f6345e8 <strdup>
	mount->cookie = cookie;
8f638134:	e59d2000 	ldr	r2, [r13]
	item->next = list->next;
8f638138:	e304360c 	movw	r3, #17932	; 0x460c
8f63813c:	e3483f72 	movt	r3, #36722	; 0x8f72
	mount->refs = 1;
8f638140:	e3a01001 	mov	r1, #1
	mount->dev = dev;
8f638144:	e584700c 	str	r7, [r4, #12]
	mount->cookie = cookie;
8f638148:	e5842010 	str	r2, [r4, #16]
8f63814c:	e5932004 	ldr	r2, [r3, #4]
    mount->api = api;
8f638150:	e5846018 	str	r6, [r4, #24]
	mount->refs = 1;
8f638154:	e5841014 	str	r1, [r4, #20]
	item->prev = list;
8f638158:	e5843000 	str	r3, [r4]
	item->next = list->next;
8f63815c:	e5842004 	str	r2, [r4, #4]
	mount->path = strdup(temppath);
8f638160:	e5840008 	str	r0, [r4, #8]
	list->next->prev = item;
8f638164:	e5824000 	str	r4, [r2]
	list->next = item;
8f638168:	e5834004 	str	r4, [r3, #4]
}
8f63816c:	e59f3044 	ldr	r3, [pc, #68]	; 8f6381b8 <mount+0x118>
8f638170:	e5932000 	ldr	r2, [r3]
8f638174:	e59d3204 	ldr	r3, [r13, #516]	; 0x204
8f638178:	e0332002 	eors	r2, r3, r2
8f63817c:	e3a03000 	mov	r3, #0
8f638180:	1a00000b 	bne	8f6381b4 <mount+0x114>
8f638184:	e1a00005 	mov	r0, r5
8f638188:	e28ddf83 	add	r13, r13, #524	; 0x20c
8f63818c:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		bio_close(dev);
8f638190:	e1a00007 	mov	r0, r7
8f638194:	ebfffbe8 	bl	8f63713c <bio_close>
		return err;
8f638198:	eafffff3 	b	8f63816c <mount+0xcc>
		return ERR_ALREADY_MOUNTED;
8f63819c:	e3e05012 	mvn	r5, #18
8f6381a0:	eafffff1 	b	8f63816c <mount+0xcc>
		return ERR_BAD_PATH;
8f6381a4:	e3e05011 	mvn	r5, #17
8f6381a8:	eaffffef 	b	8f63816c <mount+0xcc>
		return ERR_NOT_FOUND;
8f6381ac:	e3e05001 	mvn	r5, #1
8f6381b0:	eaffffed 	b	8f63816c <mount+0xcc>
}
8f6381b4:	ebffea81 	bl	8f632bc0 <__stack_chk_fail>
8f6381b8:	8f74221c 	.word	0x8f74221c

8f6381bc <fs_mount>:
{
8f6381bc:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
    list_for_every_entry(&fses, fs, struct fs, node) {
8f6381c0:	e3045604 	movw	r5, #17924	; 0x4604
8f6381c4:	e3485f72 	movt	r5, #36722	; 0x8f72
{
8f6381c8:	e59f30a0 	ldr	r3, [pc, #160]	; 8f638270 <fs_mount+0xb4>
8f6381cc:	e24dd008 	sub	r13, r13, #8
    list_for_every_entry(&fses, fs, struct fs, node) {
8f6381d0:	e5954004 	ldr	r4, [r5, #4]
{
8f6381d4:	e5933000 	ldr	r3, [r3]
8f6381d8:	e58d3004 	str	r3, [r13, #4]
8f6381dc:	e3a03000 	mov	r3, #0
    list_for_every_entry(&fses, fs, struct fs, node) {
8f6381e0:	e1540005 	cmp	r4, r5
8f6381e4:	0a000017 	beq	8f638248 <fs_mount+0x8c>
8f6381e8:	e1a07000 	mov	r7, r0
8f6381ec:	e1a06001 	mov	r6, r1
8f6381f0:	e1a08002 	mov	r8, r2
8f6381f4:	ea000002 	b	8f638204 <fs_mount+0x48>
8f6381f8:	e5944004 	ldr	r4, [r4, #4]
8f6381fc:	e1540005 	cmp	r4, r5
8f638200:	0a000010 	beq	8f638248 <fs_mount+0x8c>
        if (!strcmp(name, fs->name))
8f638204:	e5941008 	ldr	r1, [r4, #8]
8f638208:	e1a00006 	mov	r0, r6
8f63820c:	ebfff0c4 	bl	8f634524 <strcmp>
8f638210:	e3500000 	cmp	r0, #0
8f638214:	1afffff7 	bne	8f6381f8 <fs_mount+0x3c>
    return mount(path, device, fs->api);
8f638218:	e59f3050 	ldr	r3, [pc, #80]	; 8f638270 <fs_mount+0xb4>
8f63821c:	e5932000 	ldr	r2, [r3]
8f638220:	e59d3004 	ldr	r3, [r13, #4]
8f638224:	e0332002 	eors	r2, r3, r2
8f638228:	e3a03000 	mov	r3, #0
8f63822c:	1a00000e 	bne	8f63826c <fs_mount+0xb0>
8f638230:	e594200c 	ldr	r2, [r4, #12]
8f638234:	e1a01008 	mov	r1, r8
8f638238:	e1a00007 	mov	r0, r7
}
8f63823c:	e28dd008 	add	r13, r13, #8
8f638240:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, r14}
    return mount(path, device, fs->api);
8f638244:	eaffff95 	b	8f6380a0 <mount>
}
8f638248:	e59f3020 	ldr	r3, [pc, #32]	; 8f638270 <fs_mount+0xb4>
8f63824c:	e5932000 	ldr	r2, [r3]
8f638250:	e59d3004 	ldr	r3, [r13, #4]
8f638254:	e0332002 	eors	r2, r3, r2
8f638258:	e3a03000 	mov	r3, #0
8f63825c:	1a000002 	bne	8f63826c <fs_mount+0xb0>
8f638260:	e3e00001 	mvn	r0, #1
8f638264:	e28dd008 	add	r13, r13, #8
8f638268:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
8f63826c:	ebffea53 	bl	8f632bc0 <__stack_chk_fail>
8f638270:	8f74221c 	.word	0x8f74221c

8f638274 <fs_unmount>:
{
8f638274:	e59f308c 	ldr	r3, [pc, #140]	; 8f638308 <fs_unmount+0x94>
8f638278:	e1a01000 	mov	r1, r0
8f63827c:	e92d4010 	push	{r4, r14}
8f638280:	e24ddf82 	sub	r13, r13, #520	; 0x208
	strlcpy(temppath, path, sizeof(temppath));
8f638284:	e3a02c02 	mov	r2, #512	; 0x200
8f638288:	e28d0004 	add	r0, r13, #4
{
8f63828c:	e5933000 	ldr	r3, [r3]
8f638290:	e58d3204 	str	r3, [r13, #516]	; 0x204
8f638294:	e3a03000 	mov	r3, #0
	strlcpy(temppath, path, sizeof(temppath));
8f638298:	ebfff124 	bl	8f634730 <strlcpy>
	fs_normalize_path(temppath);
8f63829c:	e28d0004 	add	r0, r13, #4
8f6382a0:	ebfffef0 	bl	8f637e68 <fs_normalize_path>
	struct fs_mount *mount = find_mount(temppath, NULL);
8f6382a4:	e28d0004 	add	r0, r13, #4
8f6382a8:	e3a01000 	mov	r1, #0
8f6382ac:	ebfffe01 	bl	8f637ab8 <find_mount>
	if (!mount)
8f6382b0:	e2503000 	subs	r3, r0, #0
8f6382b4:	0a000010 	beq	8f6382fc <fs_unmount+0x88>
	if (!(--mount->refs)) {
8f6382b8:	e5934014 	ldr	r4, [r3, #20]
8f6382bc:	e2444001 	sub	r4, r4, #1
8f6382c0:	e5834014 	str	r4, [r3, #20]
8f6382c4:	e3540000 	cmp	r4, #0
	return 0;
8f6382c8:	13a04000 	movne	r4, #0
	if (!(--mount->refs)) {
8f6382cc:	0a000008 	beq	8f6382f4 <fs_unmount+0x80>
}
8f6382d0:	e59f3030 	ldr	r3, [pc, #48]	; 8f638308 <fs_unmount+0x94>
8f6382d4:	e5932000 	ldr	r2, [r3]
8f6382d8:	e59d3204 	ldr	r3, [r13, #516]	; 0x204
8f6382dc:	e0332002 	eors	r2, r3, r2
8f6382e0:	e3a03000 	mov	r3, #0
8f6382e4:	1a000006 	bne	8f638304 <fs_unmount+0x90>
8f6382e8:	e1a00004 	mov	r0, r4
8f6382ec:	e28ddf82 	add	r13, r13, #520	; 0x208
8f6382f0:	e8bd8010 	pop	{r4, r15}
8f6382f4:	ebfffe1d 	bl	8f637b70 <put_mount.part.0>
8f6382f8:	eafffff4 	b	8f6382d0 <fs_unmount+0x5c>
		return ERR_NOT_FOUND;
8f6382fc:	e3e04001 	mvn	r4, #1
8f638300:	eafffff2 	b	8f6382d0 <fs_unmount+0x5c>
}
8f638304:	ebffea2d 	bl	8f632bc0 <__stack_chk_fail>
8f638308:	8f74221c 	.word	0x8f74221c

8f63830c <fs_open_file>:
{
8f63830c:	e1a03000 	mov	r3, r0
	strlcpy(temppath, path, sizeof(temppath));
8f638310:	e3a02c02 	mov	r2, #512	; 0x200
{
8f638314:	e92d4030 	push	{r4, r5, r14}
8f638318:	e1a05001 	mov	r5, r1
8f63831c:	e24ddf85 	sub	r13, r13, #532	; 0x214
	strlcpy(temppath, path, sizeof(temppath));
8f638320:	e1a01003 	mov	r1, r3
{
8f638324:	e59f30a0 	ldr	r3, [pc, #160]	; 8f6383cc <fs_open_file+0xc0>
	strlcpy(temppath, path, sizeof(temppath));
8f638328:	e28d000c 	add	r0, r13, #12
{
8f63832c:	e5933000 	ldr	r3, [r3]
8f638330:	e58d320c 	str	r3, [r13, #524]	; 0x20c
8f638334:	e3a03000 	mov	r3, #0
	strlcpy(temppath, path, sizeof(temppath));
8f638338:	ebfff0fc 	bl	8f634730 <strlcpy>
	fs_normalize_path(temppath);
8f63833c:	e28d000c 	add	r0, r13, #12
8f638340:	ebfffec8 	bl	8f637e68 <fs_normalize_path>
	struct fs_mount *mount = find_mount(temppath, &newpath);
8f638344:	e28d1004 	add	r1, r13, #4
8f638348:	e28d000c 	add	r0, r13, #12
8f63834c:	ebfffdd9 	bl	8f637ab8 <find_mount>
	if (!mount)
8f638350:	e2504000 	subs	r4, r0, #0
8f638354:	0a000019 	beq	8f6383c0 <fs_open_file+0xb4>
    status_t err = mount->api->open(mount->cookie, newpath, &cookie);
8f638358:	e5943018 	ldr	r3, [r4, #24]
8f63835c:	e28d2008 	add	r2, r13, #8
8f638360:	e59d1004 	ldr	r1, [r13, #4]
8f638364:	e5940010 	ldr	r0, [r4, #16]
8f638368:	e5933008 	ldr	r3, [r3, #8]
8f63836c:	e12fff33 	blx	r3
	if (err < 0)
8f638370:	e3500000 	cmp	r0, #0
8f638374:	ba000009 	blt	8f6383a0 <fs_open_file+0x94>
    filehandle *f = malloc(sizeof(*f));
8f638378:	e3a00008 	mov	r0, #8
8f63837c:	ebffef1e 	bl	8f633ffc <malloc>
	f->cookie = cookie;
8f638380:	e59d1008 	ldr	r1, [r13, #8]
	mount->refs++;
8f638384:	e5942014 	ldr	r2, [r4, #20]
8f638388:	e2822001 	add	r2, r2, #1
    filehandle *f = malloc(sizeof(*f));
8f63838c:	e1a03000 	mov	r3, r0
	f->cookie = cookie;
8f638390:	e8800012 	stm	r0, {r1, r4}
	return 0;
8f638394:	e3a00000 	mov	r0, #0
	mount->refs++;
8f638398:	e5842014 	str	r2, [r4, #20]
    *handle = f;
8f63839c:	e5853000 	str	r3, [r5]
}
8f6383a0:	e59f3024 	ldr	r3, [pc, #36]	; 8f6383cc <fs_open_file+0xc0>
8f6383a4:	e5932000 	ldr	r2, [r3]
8f6383a8:	e59d320c 	ldr	r3, [r13, #524]	; 0x20c
8f6383ac:	e0332002 	eors	r2, r3, r2
8f6383b0:	e3a03000 	mov	r3, #0
8f6383b4:	1a000003 	bne	8f6383c8 <fs_open_file+0xbc>
8f6383b8:	e28ddf85 	add	r13, r13, #532	; 0x214
8f6383bc:	e8bd8030 	pop	{r4, r5, r15}
		return ERR_NOT_FOUND;
8f6383c0:	e3e00001 	mvn	r0, #1
8f6383c4:	eafffff5 	b	8f6383a0 <fs_open_file+0x94>
}
8f6383c8:	ebffe9fc 	bl	8f632bc0 <__stack_chk_fail>
8f6383cc:	8f74221c 	.word	0x8f74221c

8f6383d0 <fs_load_file>:
{
8f6383d0:	e92d4070 	push	{r4, r5, r6, r14}
8f6383d4:	e24dd028 	sub	r13, r13, #40	; 0x28
8f6383d8:	e59f30ac 	ldr	r3, [pc, #172]	; 8f63848c <fs_load_file+0xbc>
8f6383dc:	e1a06001 	mov	r6, r1
    status_t err = fs_open_file(path, &handle);
8f6383e0:	e28d100c 	add	r1, r13, #12
{
8f6383e4:	e1a05002 	mov	r5, r2
8f6383e8:	e5933000 	ldr	r3, [r3]
8f6383ec:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f6383f0:	e3a03000 	mov	r3, #0
    status_t err = fs_open_file(path, &handle);
8f6383f4:	ebffffc4 	bl	8f63830c <fs_open_file>
	if (err < 0)
8f6383f8:	e2504000 	subs	r4, r0, #0
8f6383fc:	ba000018 	blt	8f638464 <fs_load_file+0x94>
    fs_stat_file(handle, &stat);
8f638400:	e59d300c 	ldr	r3, [r13, #12]
    return handle->mount->api->stat(handle->cookie, stat);
8f638404:	e28d1010 	add	r1, r13, #16
8f638408:	e8930005 	ldm	r3, {r0, r2}
8f63840c:	e5923018 	ldr	r3, [r2, #24]
8f638410:	e5933010 	ldr	r3, [r3, #16]
8f638414:	e12fff33 	blx	r3
    ssize_t read_bytes = fs_read_file(handle, ptr, 0, MIN(maxlen, stat.size));
8f638418:	e59d300c 	ldr	r3, [r13, #12]
8f63841c:	e3a0c000 	mov	r12, #0
    return handle->mount->api->read(handle->cookie, buf, offset, len);
8f638420:	e5932004 	ldr	r2, [r3, #4]
8f638424:	e5930000 	ldr	r0, [r3]
    ssize_t read_bytes = fs_read_file(handle, ptr, 0, MIN(maxlen, stat.size));
8f638428:	e59d3018 	ldr	r3, [r13, #24]
    return handle->mount->api->read(handle->cookie, buf, offset, len);
8f63842c:	e5921018 	ldr	r1, [r2, #24]
    ssize_t read_bytes = fs_read_file(handle, ptr, 0, MIN(maxlen, stat.size));
8f638430:	e59d201c 	ldr	r2, [r13, #28]
8f638434:	e1550003 	cmp	r5, r3
8f638438:	e0dc2002 	sbcs	r2, r12, r2
    return handle->mount->api->read(handle->cookie, buf, offset, len);
8f63843c:	e3a02000 	mov	r2, #0
    ssize_t read_bytes = fs_read_file(handle, ptr, 0, MIN(maxlen, stat.size));
8f638440:	b1a03005 	movlt	r3, r5
8f638444:	e58d3000 	str	r3, [r13]
    return handle->mount->api->read(handle->cookie, buf, offset, len);
8f638448:	e3a03000 	mov	r3, #0
8f63844c:	e5914014 	ldr	r4, [r1, #20]
8f638450:	e1a01006 	mov	r1, r6
8f638454:	e12fff34 	blx	r4
8f638458:	e1a04000 	mov	r4, r0
    fs_close_file(handle);
8f63845c:	e59d000c 	ldr	r0, [r13, #12]
8f638460:	ebfffe17 	bl	8f637cc4 <fs_close_file>
}
8f638464:	e59f3020 	ldr	r3, [pc, #32]	; 8f63848c <fs_load_file+0xbc>
8f638468:	e5932000 	ldr	r2, [r3]
8f63846c:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f638470:	e0332002 	eors	r2, r3, r2
8f638474:	e3a03000 	mov	r3, #0
8f638478:	1a000002 	bne	8f638488 <fs_load_file+0xb8>
8f63847c:	e1a00004 	mov	r0, r4
8f638480:	e28dd028 	add	r13, r13, #40	; 0x28
8f638484:	e8bd8070 	pop	{r4, r5, r6, r15}
8f638488:	ebffe9cc 	bl	8f632bc0 <__stack_chk_fail>
8f63848c:	8f74221c 	.word	0x8f74221c

8f638490 <fs_open_dir>:
{
8f638490:	e1a03000 	mov	r3, r0
    strlcpy(temppath, path, sizeof(temppath));
8f638494:	e3a02c01 	mov	r2, #256	; 0x100
{
8f638498:	e92d4070 	push	{r4, r5, r6, r14}
8f63849c:	e1a06001 	mov	r6, r1
8f6384a0:	e24dde11 	sub	r13, r13, #272	; 0x110
    strlcpy(temppath, path, sizeof(temppath));
8f6384a4:	e1a01003 	mov	r1, r3
{
8f6384a8:	e59f30ec 	ldr	r3, [pc, #236]	; 8f63859c <fs_open_dir+0x10c>
    strlcpy(temppath, path, sizeof(temppath));
8f6384ac:	e28d000c 	add	r0, r13, #12
{
8f6384b0:	e5933000 	ldr	r3, [r3]
8f6384b4:	e58d310c 	str	r3, [r13, #268]	; 0x10c
8f6384b8:	e3a03000 	mov	r3, #0
    strlcpy(temppath, path, sizeof(temppath));
8f6384bc:	ebfff09b 	bl	8f634730 <strlcpy>
    fs_normalize_path(temppath);
8f6384c0:	e28d000c 	add	r0, r13, #12
8f6384c4:	ebfffe67 	bl	8f637e68 <fs_normalize_path>
    struct fs_mount *mount = find_mount(temppath, &newpath);
8f6384c8:	e28d1004 	add	r1, r13, #4
8f6384cc:	e28d000c 	add	r0, r13, #12
8f6384d0:	ebfffd78 	bl	8f637ab8 <find_mount>
    if (!mount)
8f6384d4:	e2504000 	subs	r4, r0, #0
8f6384d8:	0a000023 	beq	8f63856c <fs_open_dir+0xdc>
    if (!mount->api->opendir) {
8f6384dc:	e5943018 	ldr	r3, [r4, #24]
8f6384e0:	e5933024 	ldr	r3, [r3, #36]	; 0x24
8f6384e4:	e3530000 	cmp	r3, #0
8f6384e8:	0a000021 	beq	8f638574 <fs_open_dir+0xe4>
    status_t err = mount->api->opendir(mount->cookie, newpath, &cookie);
8f6384ec:	e59d1004 	ldr	r1, [r13, #4]
8f6384f0:	e28d2008 	add	r2, r13, #8
8f6384f4:	e5940010 	ldr	r0, [r4, #16]
8f6384f8:	e12fff33 	blx	r3
    if (err < 0) {
8f6384fc:	e2505000 	subs	r5, r0, #0
8f638500:	ba000011 	blt	8f63854c <fs_open_dir+0xbc>
    dirhandle *d = malloc(sizeof(*d));
8f638504:	e3a00008 	mov	r0, #8
    return 0;
8f638508:	e3a05000 	mov	r5, #0
    dirhandle *d = malloc(sizeof(*d));
8f63850c:	ebffeeba 	bl	8f633ffc <malloc>
    d->cookie = cookie;
8f638510:	e59d3008 	ldr	r3, [r13, #8]
8f638514:	e8800018 	stm	r0, {r3, r4}
    mount->refs++;
8f638518:	e5943014 	ldr	r3, [r4, #20]
8f63851c:	e2833001 	add	r3, r3, #1
8f638520:	e5843014 	str	r3, [r4, #20]
    *handle = d;
8f638524:	e5860000 	str	r0, [r6]
}
8f638528:	e59f306c 	ldr	r3, [pc, #108]	; 8f63859c <fs_open_dir+0x10c>
8f63852c:	e5932000 	ldr	r2, [r3]
8f638530:	e59d310c 	ldr	r3, [r13, #268]	; 0x10c
8f638534:	e0332002 	eors	r2, r3, r2
8f638538:	e3a03000 	mov	r3, #0
8f63853c:	1a000015 	bne	8f638598 <fs_open_dir+0x108>
8f638540:	e1a00005 	mov	r0, r5
8f638544:	e28dde11 	add	r13, r13, #272	; 0x110
8f638548:	e8bd8070 	pop	{r4, r5, r6, r15}
	if (!(--mount->refs)) {
8f63854c:	e5943014 	ldr	r3, [r4, #20]
8f638550:	e2433001 	sub	r3, r3, #1
8f638554:	e5843014 	str	r3, [r4, #20]
8f638558:	e3530000 	cmp	r3, #0
8f63855c:	1afffff1 	bne	8f638528 <fs_open_dir+0x98>
8f638560:	e1a00004 	mov	r0, r4
8f638564:	ebfffd81 	bl	8f637b70 <put_mount.part.0>
8f638568:	eaffffee 	b	8f638528 <fs_open_dir+0x98>
        return ERR_NOT_FOUND;
8f63856c:	e3e05001 	mvn	r5, #1
8f638570:	eaffffec 	b	8f638528 <fs_open_dir+0x98>
	if (!(--mount->refs)) {
8f638574:	e5943014 	ldr	r3, [r4, #20]
8f638578:	e2433001 	sub	r3, r3, #1
8f63857c:	e5843014 	str	r3, [r4, #20]
8f638580:	e3530000 	cmp	r3, #0
        return ERR_NOT_SUPPORTED;
8f638584:	13e05017 	mvnne	r5, #23
	if (!(--mount->refs)) {
8f638588:	1affffe6 	bne	8f638528 <fs_open_dir+0x98>
8f63858c:	ebfffd77 	bl	8f637b70 <put_mount.part.0>
        return ERR_NOT_SUPPORTED;
8f638590:	e3e05017 	mvn	r5, #23
8f638594:	eaffffe3 	b	8f638528 <fs_open_dir+0x98>
}
8f638598:	ebffe988 	bl	8f632bc0 <__stack_chk_fail>
8f63859c:	8f74221c 	.word	0x8f74221c

8f6385a0 <partition_parse_gpt_header.part.0>:
/*
 * Parse the gpt header and get the required header fields
 * Return 0 on valid signature
 */
static unsigned int
partition_parse_gpt_header(unsigned char *buffer, struct gpt_header* header)
8f6385a0:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6385a4:	e24dd00c 	sub	r13, r13, #12
	/* Check GPT Signature */
	if (((uint32_t *) buffer)[0] != GPT_SIGNATURE_2 ||
	    ((uint32_t *) buffer)[1] != GPT_SIGNATURE_1)
		return 1;

	header->header_size = GET_LWORD_FROM_BYTE(&buffer[HEADER_SIZE_OFFSET]);
8f6385a8:	e590300c 	ldr	r3, [r0, #12]
partition_parse_gpt_header(unsigned char *buffer, struct gpt_header* header)
8f6385ac:	e59f204c 	ldr	r2, [pc, #76]	; 8f638600 <partition_parse_gpt_header.part.0+0x60>
8f6385b0:	e5922000 	ldr	r2, [r2]
8f6385b4:	e58d2004 	str	r2, [r13, #4]
8f6385b8:	e3a02000 	mov	r2, #0
	header->header_size = GET_LWORD_FROM_BYTE(&buffer[HEADER_SIZE_OFFSET]);
8f6385bc:	e581300c 	str	r3, [r1, #12]
	header->first_usable_lba =
	    GET_LLWORD_FROM_BYTE(&buffer[FIRST_USABLE_LBA_OFFSET]);
8f6385c0:	e1c022d8 	ldrd	r2, [r0, #40]	; 0x28
	header->first_usable_lba =
8f6385c4:	e1c120f0 	strd	r2, [r1]
	header->max_partition_count =
	    GET_LWORD_FROM_BYTE(&buffer[PARTITION_COUNT_OFFSET]);
8f6385c8:	e5903050 	ldr	r3, [r0, #80]	; 0x50
	header->max_partition_count =
8f6385cc:	e5813010 	str	r3, [r1, #16]
	header->partition_entry_size =
	    GET_LWORD_FROM_BYTE(&buffer[PENTRY_SIZE_OFFSET]);
8f6385d0:	e5903054 	ldr	r3, [r0, #84]	; 0x54
	header->partition_entry_size =
8f6385d4:	e5813008 	str	r3, [r1, #8]

	return 0;
}
8f6385d8:	e59f3020 	ldr	r3, [pc, #32]	; 8f638600 <partition_parse_gpt_header.part.0+0x60>
8f6385dc:	e5932000 	ldr	r2, [r3]
8f6385e0:	e59d3004 	ldr	r3, [r13, #4]
8f6385e4:	e0332002 	eors	r2, r3, r2
8f6385e8:	e3a03000 	mov	r3, #0
8f6385ec:	1a000002 	bne	8f6385fc <partition_parse_gpt_header.part.0+0x5c>
8f6385f0:	e3a00000 	mov	r0, #0
8f6385f4:	e28dd00c 	add	r13, r13, #12
8f6385f8:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f6385fc:	ebffe96f 	bl	8f632bc0 <__stack_chk_fail>
8f638600:	8f74221c 	.word	0x8f74221c

8f638604 <partition_unpublish>:
err:
	return (err < 0) ? err : count;
}

int partition_unpublish(const char *device)
{
8f638604:	e59f308c 	ldr	r3, [pc, #140]	; 8f638698 <partition_unpublish+0x94>
8f638608:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f63860c:	e24ddf82 	sub	r13, r13, #520	; 0x208
	int i;
	int count;
	bdev_t *dev;
	char devname[512];	

	count = 0;
8f638610:	e3a06000 	mov	r6, #0
	for (i=0; i < 16; i++) {
		sprintf(devname, "%sp%d", device, i);
8f638614:	e30b82d0 	movw	r8, #45776	; 0xb2d0
{
8f638618:	e5933000 	ldr	r3, [r3]
8f63861c:	e58d3204 	str	r3, [r13, #516]	; 0x204
8f638620:	e3a03000 	mov	r3, #0
		sprintf(devname, "%sp%d", device, i);
8f638624:	e3488f70 	movt	r8, #36720	; 0x8f70
{
8f638628:	e1a07000 	mov	r7, r0
	for (i=0; i < 16; i++) {
8f63862c:	e1a05006 	mov	r5, r6
		sprintf(devname, "%sp%d", device, i);
8f638630:	e1a03005 	mov	r3, r5
8f638634:	e1a02007 	mov	r2, r7
8f638638:	e1a01008 	mov	r1, r8
8f63863c:	e28d0004 	add	r0, r13, #4
8f638640:	ebffee55 	bl	8f633f9c <sprintf>

		dev = bio_open(devname);
8f638644:	e28d0004 	add	r0, r13, #4
8f638648:	ebfffa8e 	bl	8f637088 <bio_open>
		if (!dev)
8f63864c:	e2504000 	subs	r4, r0, #0
8f638650:	0a000003 	beq	8f638664 <partition_unpublish+0x60>
			continue;

		bio_unregister_device(dev);
8f638654:	ebfffc07 	bl	8f637678 <bio_unregister_device>
		bio_close(dev);
8f638658:	e1a00004 	mov	r0, r4
8f63865c:	ebfffab6 	bl	8f63713c <bio_close>
		count++;
8f638660:	e2866001 	add	r6, r6, #1
	for (i=0; i < 16; i++) {
8f638664:	e2855001 	add	r5, r5, #1
8f638668:	e3550010 	cmp	r5, #16
8f63866c:	1affffef 	bne	8f638630 <partition_unpublish+0x2c>
	}

	return count;
}
8f638670:	e59f3020 	ldr	r3, [pc, #32]	; 8f638698 <partition_unpublish+0x94>
8f638674:	e5932000 	ldr	r2, [r3]
8f638678:	e59d3204 	ldr	r3, [r13, #516]	; 0x204
8f63867c:	e0332002 	eors	r2, r3, r2
8f638680:	e3a03000 	mov	r3, #0
8f638684:	1a000002 	bne	8f638694 <partition_unpublish+0x90>
8f638688:	e1a00006 	mov	r0, r6
8f63868c:	e28ddf82 	add	r13, r13, #520	; 0x208
8f638690:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
8f638694:	ebffe949 	bl	8f632bc0 <__stack_chk_fail>
8f638698:	8f74221c 	.word	0x8f74221c

8f63869c <partition_publish>:
{
8f63869c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f6386a0:	e28db020 	add	r11, r13, #32
8f6386a4:	e24ddf6f 	sub	r13, r13, #444	; 0x1bc
8f6386a8:	e1a09003 	mov	r9, r3
8f6386ac:	e59f3644 	ldr	r3, [pc, #1604]	; 8f638cf8 <partition_publish+0x65c>
8f6386b0:	e1a07000 	mov	r7, r0
8f6386b4:	e1a08002 	mov	r8, r2
8f6386b8:	e5933000 	ldr	r3, [r3]
8f6386bc:	e50b3028 	str	r3, [r11, #-40]	; 0xffffffd8
8f6386c0:	e3a03000 	mov	r3, #0
	partition_unpublish(device);
8f6386c4:	ebffffce 	bl	8f638604 <partition_unpublish>
	bdev_t *dev = bio_open(device);
8f6386c8:	e1a00007 	mov	r0, r7
8f6386cc:	ebfffa6d 	bl	8f637088 <bio_open>
	if (!dev) {
8f6386d0:	e2505000 	subs	r5, r0, #0
8f6386d4:	0a00014b 	beq	8f638c08 <partition_publish+0x56c>
	STACKBUF_DMA_ALIGN(buf, dev->block_size);
8f6386d8:	e5953018 	ldr	r3, [r5, #24]
		err = bio_read(dev, buf, offset, 512);
8f6386dc:	e1a02008 	mov	r2, r8
	STACKBUF_DMA_ALIGN(buf, dev->block_size);
8f6386e0:	e283307f 	add	r3, r3, #127	; 0x7f
8f6386e4:	e3c33007 	bic	r3, r3, #7
8f6386e8:	e04dd003 	sub	r13, r13, r3
8f6386ec:	e28d3047 	add	r3, r13, #71	; 0x47
8f6386f0:	e3c3a03f 	bic	r10, r3, #63	; 0x3f
		err = bio_read(dev, buf, offset, 512);
8f6386f4:	e3a03c02 	mov	r3, #512	; 0x200
8f6386f8:	e58d3000 	str	r3, [r13]
8f6386fc:	e1a03009 	mov	r3, r9
8f638700:	e1a0100a 	mov	r1, r10
8f638704:	ebfffaab 	bl	8f6371b8 <bio_read>
		if (err < 0)
8f638708:	e2504000 	subs	r4, r0, #0
8f63870c:	ba000069 	blt	8f6388b8 <partition_publish+0x21c>
		if (buf[510] != 0x55 || buf[511] != 0xaa)
8f638710:	e5da31fe 	ldrb	r3, [r10, #510]	; 0x1fe
8f638714:	e3530055 	cmp	r3, #85	; 0x55
8f638718:	0a00000d 	beq	8f638754 <partition_publish+0xb8>
	int count = 0;
8f63871c:	e3a06000 	mov	r6, #0
	bio_close(dev);
8f638720:	e3540000 	cmp	r4, #0
8f638724:	e1a00005 	mov	r0, r5
8f638728:	b1a06004 	movlt	r6, r4
8f63872c:	ebfffa82 	bl	8f63713c <bio_close>
}
8f638730:	e59f35c0 	ldr	r3, [pc, #1472]	; 8f638cf8 <partition_publish+0x65c>
8f638734:	e5932000 	ldr	r2, [r3]
8f638738:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f63873c:	e0332002 	eors	r2, r3, r2
8f638740:	e3a03000 	mov	r3, #0
8f638744:	1a000167 	bne	8f638ce8 <partition_publish+0x64c>
8f638748:	e1a00006 	mov	r0, r6
8f63874c:	e24bd020 	sub	r13, r11, #32
8f638750:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
		if (buf[510] != 0x55 || buf[511] != 0xaa)
8f638754:	e5da31ff 	ldrb	r3, [r10, #511]	; 0x1ff
8f638758:	e35300aa 	cmp	r3, #170	; 0xaa
8f63875c:	1affffee 	bne	8f63871c <partition_publish+0x80>
		memcpy(part, buf + 446, sizeof(part));
8f638760:	e28a1f6f 	add	r1, r10, #444	; 0x1bc
8f638764:	e3a02040 	mov	r2, #64	; 0x40
8f638768:	e2811002 	add	r1, r1, #2
8f63876c:	e24b0f62 	sub	r0, r11, #392	; 0x188
8f638770:	ebffee90 	bl	8f6341b8 <memcpy>
		dprintf(INFO, "mbr partition table dump:\n");
8f638774:	e24b6f62 	sub	r6, r11, #392	; 0x188
8f638778:	e30b0304 	movw	r0, #45828	; 0xb304
8f63877c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f638780:	e50b61a8 	str	r6, [r11, #-424]	; 0xfffffe58
8f638784:	ebffe87a 	bl	8f632974 <_dprintf>
			dprintf(INFO, "\t%i: status 0x%hhx, type 0x%hhx, start 0x%x, len 0x%x\n", i, part[i].status, part[i].type, part[i].lba_start, part[i].lba_length);
8f638788:	e30b2320 	movw	r2, #45856	; 0xb320
8f63878c:	e3482f70 	movt	r2, #36720	; 0x8f70
		dprintf(INFO, "mbr partition table dump:\n");
8f638790:	e1a03006 	mov	r3, r6
		for (i=0; i < 4; i++) {
8f638794:	e50b41ac 	str	r4, [r11, #-428]	; 0xfffffe54
8f638798:	e50b51b0 	str	r5, [r11, #-432]	; 0xfffffe50
8f63879c:	e3a06000 	mov	r6, #0
8f6387a0:	e1a04003 	mov	r4, r3
8f6387a4:	e1a05002 	mov	r5, r2
			dprintf(INFO, "\t%i: status 0x%hhx, type 0x%hhx, start 0x%x, len 0x%x\n", i, part[i].status, part[i].type, part[i].lba_start, part[i].lba_length);
8f6387a8:	e24b3024 	sub	r3, r11, #36	; 0x24
8f6387ac:	e1a00005 	mov	r0, r5
8f6387b0:	e0832206 	add	r2, r3, r6, lsl #4
8f6387b4:	e5d43004 	ldrb	r3, [r4, #4]
8f6387b8:	e5121158 	ldr	r1, [r2, #-344]	; 0xfffffea8
8f6387bc:	e58d1004 	str	r1, [r13, #4]
8f6387c0:	e1a01006 	mov	r1, r6
8f6387c4:	e512215c 	ldr	r2, [r2, #-348]	; 0xfffffea4
		for (i=0; i < 4; i++) {
8f6387c8:	e2866001 	add	r6, r6, #1
			dprintf(INFO, "\t%i: status 0x%hhx, type 0x%hhx, start 0x%x, len 0x%x\n", i, part[i].status, part[i].type, part[i].lba_start, part[i].lba_length);
8f6387cc:	e58d2000 	str	r2, [r13]
8f6387d0:	e4d42010 	ldrb	r2, [r4], #16
8f6387d4:	ebffe866 	bl	8f632974 <_dprintf>
		for (i=0; i < 4; i++) {
8f6387d8:	e3560004 	cmp	r6, #4
8f6387dc:	1afffff1 	bne	8f6387a8 <partition_publish+0x10c>
		for (i=0; i < 4; i++) {
8f6387e0:	e51b41ac 	ldr	r4, [r11, #-428]	; 0xfffffe54
				sprintf(subdevice, "%sp%d", device, i); 
8f6387e4:	e30b12d0 	movw	r1, #45776	; 0xb2d0
	int count = 0;
8f6387e8:	e50b91b8 	str	r9, [r11, #-440]	; 0xfffffe48
				sprintf(subdevice, "%sp%d", device, i); 
8f6387ec:	e3481f70 	movt	r1, #36720	; 0x8f70
	int count = 0;
8f6387f0:	e1a09007 	mov	r9, r7
8f6387f4:	e51b71a8 	ldr	r7, [r11, #-424]	; 0xfffffe58
		for (i=0; i < 4; i++) {
8f6387f8:	e3a03000 	mov	r3, #0
					dprintf(INFO, "error publishing subdevice '%s'\n", subdevice);
8f6387fc:	e30b2364 	movw	r2, #45924	; 0xb364
	int count = 0;
8f638800:	e50b81b4 	str	r8, [r11, #-436]	; 0xfffffe4c
					dprintf(INFO, "error publishing subdevice '%s'\n", subdevice);
8f638804:	e3482f70 	movt	r2, #36720	; 0x8f70
	int count = 0;
8f638808:	e1a06003 	mov	r6, r3
					dprintf(INFO, "error publishing subdevice '%s'\n", subdevice);
8f63880c:	e50b21ac 	str	r2, [r11, #-428]	; 0xfffffe54
	int count = 0;
8f638810:	e1a08003 	mov	r8, r3
8f638814:	e1a02004 	mov	r2, r4
8f638818:	e1a04001 	mov	r4, r1
		for (i=0; i < 4; i++) {
8f63881c:	e51b51b0 	ldr	r5, [r11, #-432]	; 0xfffffe50
	int count = 0;
8f638820:	e50ba1b0 	str	r10, [r11, #-432]	; 0xfffffe50
	if (part->type == 0)
8f638824:	e5d71004 	ldrb	r1, [r7, #4]
8f638828:	e3510000 	cmp	r1, #0
8f63882c:	0a00001b 	beq	8f6388a0 <partition_publish+0x204>
	if (part->status != 0x80 && part->status != 0x00)
8f638830:	e5d73000 	ldrb	r3, [r7]
8f638834:	e313007f 	tst	r3, #127	; 0x7f
8f638838:	1a000018 	bne	8f6388a0 <partition_publish+0x204>
	if (part->lba_start >= dev->block_count)
8f63883c:	e24b3024 	sub	r3, r11, #36	; 0x24
8f638840:	e595001c 	ldr	r0, [r5, #28]
8f638844:	e083a208 	add	r10, r3, r8, lsl #4
8f638848:	e51a315c 	ldr	r3, [r10, #-348]	; 0xfffffea4
8f63884c:	e1530000 	cmp	r3, r0
8f638850:	2a000012 	bcs	8f6388a0 <partition_publish+0x204>
	if ((part->lba_start + part->lba_length) > dev->block_count)
8f638854:	e51ac158 	ldr	r12, [r10, #-344]	; 0xfffffea8
8f638858:	e083300c 	add	r3, r3, r12
8f63885c:	e1500003 	cmp	r0, r3
8f638860:	3a00000e 	bcc	8f6388a0 <partition_publish+0x204>
				if(part[i].type==0xee) {
8f638864:	e35100ee 	cmp	r1, #238	; 0xee
8f638868:	0a00001a 	beq	8f6388d8 <partition_publish+0x23c>
				sprintf(subdevice, "%sp%d", device, i); 
8f63886c:	e1a03008 	mov	r3, r8
8f638870:	e1a02009 	mov	r2, r9
8f638874:	e1a01004 	mov	r1, r4
8f638878:	e24b00a8 	sub	r0, r11, #168	; 0xa8
8f63887c:	ebffedc6 	bl	8f633f9c <sprintf>
				err = bio_publish_subdevice(device, subdevice, part[i].lba_start, part[i].lba_length);
8f638880:	e51a215c 	ldr	r2, [r10, #-348]	; 0xfffffea4
8f638884:	e51a3158 	ldr	r3, [r10, #-344]	; 0xfffffea8
8f638888:	e24b10a8 	sub	r1, r11, #168	; 0xa8
8f63888c:	e1a00009 	mov	r0, r9
8f638890:	ebfffc4e 	bl	8f6379d0 <bio_publish_subdevice>
				if (err < 0) {
8f638894:	e2502000 	subs	r2, r0, #0
				count++;
8f638898:	a2866001 	addge	r6, r6, #1
				if (err < 0) {
8f63889c:	ba000007 	blt	8f6388c0 <partition_publish+0x224>
		for (i=0; i < 4; i++) {
8f6388a0:	e2888001 	add	r8, r8, #1
8f6388a4:	e2877010 	add	r7, r7, #16
8f6388a8:	e3580004 	cmp	r8, #4
8f6388ac:	1affffdc 	bne	8f638824 <partition_publish+0x188>
8f6388b0:	e1a04002 	mov	r4, r2
8f6388b4:	eaffff99 	b	8f638720 <partition_publish+0x84>
			goto err;
8f6388b8:	e1a06004 	mov	r6, r4
8f6388bc:	eaffff9b 	b	8f638730 <partition_publish+0x94>
					dprintf(INFO, "error publishing subdevice '%s'\n", subdevice);
8f6388c0:	e51b01ac 	ldr	r0, [r11, #-428]	; 0xfffffe54
8f6388c4:	e24b10a8 	sub	r1, r11, #168	; 0xa8
8f6388c8:	e50b21a8 	str	r2, [r11, #-424]	; 0xfffffe58
8f6388cc:	ebffe828 	bl	8f632974 <_dprintf>
					continue;
8f6388d0:	e51b21a8 	ldr	r2, [r11, #-424]	; 0xfffffe58
8f6388d4:	eafffff1 	b	8f6388a0 <partition_publish+0x204>
		dprintf(INFO, "found GPT\n");
8f6388d8:	e30b0358 	movw	r0, #45912	; 0xb358
8f6388dc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f6388e0:	e51ba1b0 	ldr	r10, [r11, #-432]	; 0xfffffe50
8f6388e4:	e1a07009 	mov	r7, r9
8f6388e8:	e51b81b4 	ldr	r8, [r11, #-436]	; 0xfffffe4c
8f6388ec:	e51b91b8 	ldr	r9, [r11, #-440]	; 0xfffffe48
8f6388f0:	ebffe81f 	bl	8f632974 <_dprintf>
		err = bio_read(dev, buf, offset + dev->block_size, dev->block_size);
8f6388f4:	e5953018 	ldr	r3, [r5, #24]
8f6388f8:	e1a0100a 	mov	r1, r10
8f6388fc:	e1a00005 	mov	r0, r5
8f638900:	e0932008 	adds	r2, r3, r8
8f638904:	e58d3000 	str	r3, [r13]
8f638908:	e2a93000 	adc	r3, r9, #0
8f63890c:	ebfffa29 	bl	8f6371b8 <bio_read>
		if (err < 0)
8f638910:	e2504000 	subs	r4, r0, #0
8f638914:	baffffe7 	blt	8f6388b8 <partition_publish+0x21c>
	if (((uint32_t *) buffer)[0] != GPT_SIGNATURE_2 ||
8f638918:	e59a2000 	ldr	r2, [r10]
8f63891c:	e3043645 	movw	r3, #17989	; 0x4645
8f638920:	e3423049 	movt	r3, #8265	; 0x2049
8f638924:	e1520003 	cmp	r2, r3
8f638928:	1a0000c4 	bne	8f638c40 <partition_publish+0x5a4>
8f63892c:	e59a2004 	ldr	r2, [r10, #4]
8f638930:	e3043150 	movw	r3, #16720	; 0x4150
8f638934:	e3453452 	movt	r3, #21586	; 0x5452
8f638938:	e1520003 	cmp	r2, r3
8f63893c:	1a0000bf 	bne	8f638c40 <partition_publish+0x5a4>
8f638940:	e24b1f69 	sub	r1, r11, #420	; 0x1a4
8f638944:	e1a0000a 	mov	r0, r10
8f638948:	ebffff14 	bl	8f6385a0 <partition_parse_gpt_header.part.0>
		if (err) {
8f63894c:	e3500000 	cmp	r0, #0
8f638950:	1a0000ba 	bne	8f638c40 <partition_publish+0x5a4>
		uint64_t partition_0 = GET_LLWORD_FROM_BYTE(&buf[PARTITION_ENTRIES_OFFSET]);
8f638954:	e59a1048 	ldr	r1, [r10, #72]	; 0x48
		uint32_t part_entry_cnt = dev->block_size / ENTRY_SIZE;
8f638958:	e5953018 	ldr	r3, [r5, #24]
		for (i = 0; i < (ROUNDUP(gpthdr.max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f63895c:	e51b2194 	ldr	r2, [r11, #-404]	; 0xfffffe6c
		uint64_t partition_0 = GET_LLWORD_FROM_BYTE(&buf[PARTITION_ENTRIES_OFFSET]);
8f638960:	e50b11c0 	str	r1, [r11, #-448]	; 0xfffffe40
		for (i = 0; i < (ROUNDUP(gpthdr.max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f638964:	e2422001 	sub	r2, r2, #1
		uint32_t part_entry_cnt = dev->block_size / ENTRY_SIZE;
8f638968:	e1a013a3 	lsr	r1, r3, #7
		for (i = 0; i < (ROUNDUP(gpthdr.max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f63896c:	e2610000 	rsb	r0, r1, #0
8f638970:	e0822001 	add	r2, r2, r1
8f638974:	e0022000 	and	r2, r2, r0
		uint32_t part_entry_cnt = dev->block_size / ENTRY_SIZE;
8f638978:	e50b11a8 	str	r1, [r11, #-424]	; 0xfffffe58
		for (i = 0; i < (ROUNDUP(gpthdr.max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f63897c:	e1520001 	cmp	r2, r1
		uint64_t partition_0 = GET_LLWORD_FROM_BYTE(&buf[PARTITION_ENTRIES_OFFSET]);
8f638980:	e59a204c 	ldr	r2, [r10, #76]	; 0x4c
		for (i = 0; i < (ROUNDUP(gpthdr.max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f638984:	e50b01d0 	str	r0, [r11, #-464]	; 0xfffffe30
		uint64_t partition_0 = GET_LLWORD_FROM_BYTE(&buf[PARTITION_ENTRIES_OFFSET]);
8f638988:	e50b21c4 	str	r2, [r11, #-452]	; 0xfffffe3c
		for (i = 0; i < (ROUNDUP(gpthdr.max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f63898c:	3a0000d6 	bcc	8f638cec <partition_publish+0x650>
8f638990:	e1a0c003 	mov	r12, r3
				sprintf(subdevice, "%sp%d", device, count+1);
8f638994:	e30b22d0 	movw	r2, #45776	; 0xb2d0
		for (i = 0; i < (ROUNDUP(gpthdr.max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f638998:	e50b51b8 	str	r5, [r11, #-440]	; 0xfffffe48
				sprintf(subdevice, "%sp%d", device, count+1);
8f63899c:	e3482f70 	movt	r2, #36720	; 0x8f70
		for (i = 0; i < (ROUNDUP(gpthdr.max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f6389a0:	e50b81c8 	str	r8, [r11, #-456]	; 0xfffffe38
				sprintf(subdevice, "%sp%d", device, count+1);
8f6389a4:	e50b21ac 	str	r2, [r11, #-428]	; 0xfffffe54
				if (strcmp(name, "system") == 0 || strcmp(name, "system_a") ||
8f6389a8:	e3012280 	movw	r2, #4736	; 0x1280
		for (i = 0; i < (ROUNDUP(gpthdr.max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f6389ac:	e50b91cc 	str	r9, [r11, #-460]	; 0xfffffe34
				if (strcmp(name, "system") == 0 || strcmp(name, "system_a") ||
8f6389b0:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6389b4:	e50b21b0 	str	r2, [r11, #-432]	; 0xfffffe50
8f6389b8:	e30a2b20 	movw	r2, #43808	; 0xab20
8f6389bc:	e3482f70 	movt	r2, #36720	; 0x8f70
8f6389c0:	e50b21bc 	str	r2, [r11, #-444]	; 0xfffffe44
		for (i = 0; i < (ROUNDUP(gpthdr.max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f6389c4:	e3a02000 	mov	r2, #0
8f6389c8:	e50b21b4 	str	r2, [r11, #-436]	; 0xfffffe4c
			err = bio_read(dev, buf, offset + (partition_0 * dev->block_size) + (i * dev->block_size),
8f6389cc:	e51b31b4 	ldr	r3, [r11, #-436]	; 0xfffffe4c
8f6389d0:	e1a0100a 	mov	r1, r10
8f6389d4:	e58dc000 	str	r12, [r13]
8f6389d8:	e51b01b8 	ldr	r0, [r11, #-440]	; 0xfffffe48
8f6389dc:	e00e039c 	mul	r14, r12, r3
8f6389e0:	e51b31c0 	ldr	r3, [r11, #-448]	; 0xfffffe40
8f6389e4:	e083239c 	umull	r2, r3, r12, r3
8f6389e8:	e092200e 	adds	r2, r2, r14
8f6389ec:	e51be1c4 	ldr	r14, [r11, #-452]	; 0xfffffe3c
8f6389f0:	e0233e9c 	mla	r3, r12, r14, r3
8f6389f4:	e51bc1c8 	ldr	r12, [r11, #-456]	; 0xfffffe38
8f6389f8:	e2a33000 	adc	r3, r3, #0
8f6389fc:	e092200c 	adds	r2, r2, r12
8f638a00:	e51bc1cc 	ldr	r12, [r11, #-460]	; 0xfffffe34
8f638a04:	e0ac3003 	adc	r3, r12, r3
8f638a08:	ebfff9ea 	bl	8f6371b8 <bio_read>
			if (err < 0) {
8f638a0c:	e2504000 	subs	r4, r0, #0
8f638a10:	ba0000a9 	blt	8f638cbc <partition_publish+0x620>
			for (j = 0; j < part_entry_cnt; j++) {
8f638a14:	e51b31a8 	ldr	r3, [r11, #-424]	; 0xfffffe58
8f638a18:	e3530000 	cmp	r3, #0
8f638a1c:	0a0000ab 	beq	8f638cd0 <partition_publish+0x634>
8f638a20:	e3a08000 	mov	r8, #0
			       &buf[(j * gpthdr.partition_entry_size)],
8f638a24:	e51b119c 	ldr	r1, [r11, #-412]	; 0xfffffe64
				memcpy(&type_guid,
8f638a28:	e3a02010 	mov	r2, #16
8f638a2c:	e24b0f52 	sub	r0, r11, #328	; 0x148
8f638a30:	e021a891 	mla	r1, r1, r8, r10
8f638a34:	ebffeddf 	bl	8f6341b8 <memcpy>
				if (type_guid[0]==0 && type_guid[1]==0) {
8f638a38:	e55b2148 	ldrb	r2, [r11, #-328]	; 0xfffffeb8
8f638a3c:	e55b3147 	ldrb	r3, [r11, #-327]	; 0xfffffeb9
8f638a40:	e1923003 	orrs	r3, r2, r3
8f638a44:	0a000074 	beq	8f638c1c <partition_publish+0x580>
				first_lba = GET_LLWORD_FROM_BYTE(&buf[(j * gpthdr.partition_entry_size) + FIRST_LBA_OFFSET]);
8f638a48:	e51b319c 	ldr	r3, [r11, #-412]	; 0xfffffe64
				memset(&UTF16_name, 0x00, MAX_GPT_NAME_SIZE);
8f638a4c:	e3a02048 	mov	r2, #72	; 0x48
8f638a50:	e3a01000 	mov	r1, #0
8f638a54:	e24b00f0 	sub	r0, r11, #240	; 0xf0
				first_lba = GET_LLWORD_FROM_BYTE(&buf[(j * gpthdr.partition_entry_size) + FIRST_LBA_OFFSET]);
8f638a58:	e023a893 	mla	r3, r3, r8, r10
				last_lba = GET_LLWORD_FROM_BYTE(&buf[(j * gpthdr.partition_entry_size) + LAST_LBA_OFFSET]);
8f638a5c:	e5d3402a 	ldrb	r4, [r3, #42]	; 0x2a
8f638a60:	e5d3e029 	ldrb	r14, [r3, #41]	; 0x29
				first_lba = GET_LLWORD_FROM_BYTE(&buf[(j * gpthdr.partition_entry_size) + FIRST_LBA_OFFSET]);
8f638a64:	e5d3c022 	ldrb	r12, [r3, #34]	; 0x22
				last_lba = GET_LLWORD_FROM_BYTE(&buf[(j * gpthdr.partition_entry_size) + LAST_LBA_OFFSET]);
8f638a68:	e1a04804 	lsl	r4, r4, #16
				first_lba = GET_LLWORD_FROM_BYTE(&buf[(j * gpthdr.partition_entry_size) + FIRST_LBA_OFFSET]);
8f638a6c:	e5d35021 	ldrb	r5, [r3, #33]	; 0x21
				last_lba = GET_LLWORD_FROM_BYTE(&buf[(j * gpthdr.partition_entry_size) + LAST_LBA_OFFSET]);
8f638a70:	e184e40e 	orr	r14, r4, r14, lsl #8
8f638a74:	e5d34028 	ldrb	r4, [r3, #40]	; 0x28
				first_lba = GET_LLWORD_FROM_BYTE(&buf[(j * gpthdr.partition_entry_size) + FIRST_LBA_OFFSET]);
8f638a78:	e1a0c80c 	lsl	r12, r12, #16
				last_lba = GET_LLWORD_FROM_BYTE(&buf[(j * gpthdr.partition_entry_size) + LAST_LBA_OFFSET]);
8f638a7c:	e18e4004 	orr	r4, r14, r4
8f638a80:	e5d3e02b 	ldrb	r14, [r3, #43]	; 0x2b
				first_lba = GET_LLWORD_FROM_BYTE(&buf[(j * gpthdr.partition_entry_size) + FIRST_LBA_OFFSET]);
8f638a84:	e18cc405 	orr	r12, r12, r5, lsl #8
8f638a88:	e5d35020 	ldrb	r5, [r3, #32]
8f638a8c:	e5d33023 	ldrb	r3, [r3, #35]	; 0x23
				last_lba = GET_LLWORD_FROM_BYTE(&buf[(j * gpthdr.partition_entry_size) + LAST_LBA_OFFSET]);
8f638a90:	e1844c0e 	orr	r4, r4, r14, lsl #24
				first_lba = GET_LLWORD_FROM_BYTE(&buf[(j * gpthdr.partition_entry_size) + FIRST_LBA_OFFSET]);
8f638a94:	e18c5005 	orr	r5, r12, r5
				size = last_lba - first_lba + 1;
8f638a98:	e2944001 	adds	r4, r4, #1
				first_lba = GET_LLWORD_FROM_BYTE(&buf[(j * gpthdr.partition_entry_size) + FIRST_LBA_OFFSET]);
8f638a9c:	e1855c03 	orr	r5, r5, r3, lsl #24
				size = last_lba - first_lba + 1;
8f638aa0:	e0544005 	subs	r4, r4, r5
				memset(&UTF16_name, 0x00, MAX_GPT_NAME_SIZE);
8f638aa4:	ebffee06 	bl	8f6342c4 <memset>
				memcpy(UTF16_name, &buf[(j * gpthdr.partition_entry_size) +
8f638aa8:	e51b119c 	ldr	r1, [r11, #-412]	; 0xfffffe64
8f638aac:	e3a02048 	mov	r2, #72	; 0x48
8f638ab0:	e24b00f0 	sub	r0, r11, #240	; 0xf0
8f638ab4:	e021a891 	mla	r1, r1, r8, r10
8f638ab8:	e2811038 	add	r1, r1, #56	; 0x38
8f638abc:	ebffedbd 	bl	8f6341b8 <memcpy>
				for (n = 0; n < MAX_GPT_NAME_SIZE / 2; n++) {
8f638ac0:	e24b3f4e 	sub	r3, r11, #312	; 0x138
8f638ac4:	e2432001 	sub	r2, r3, #1
				memcpy(UTF16_name, &buf[(j * gpthdr.partition_entry_size) +
8f638ac8:	e3a03001 	mov	r3, #1
					name[n] = UTF16_name[n * 2];
8f638acc:	e24b10f0 	sub	r1, r11, #240	; 0xf0
8f638ad0:	e0811083 	add	r1, r1, r3, lsl #1
				for (n = 0; n < MAX_GPT_NAME_SIZE / 2; n++) {
8f638ad4:	e2833001 	add	r3, r3, #1
8f638ad8:	e3530025 	cmp	r3, #37	; 0x25
					name[n] = UTF16_name[n * 2];
8f638adc:	e5511002 	ldrb	r1, [r1, #-2]
8f638ae0:	e5e21001 	strb	r1, [r2, #1]!
				for (n = 0; n < MAX_GPT_NAME_SIZE / 2; n++) {
8f638ae4:	1afffff8 	bne	8f638acc <partition_publish+0x430>
				sprintf(subdevice, "%sp%d", device, count+1);
8f638ae8:	e2869001 	add	r9, r6, #1
8f638aec:	e51b11ac 	ldr	r1, [r11, #-428]	; 0xfffffe54
8f638af0:	e1a02007 	mov	r2, r7
8f638af4:	e24b00a8 	sub	r0, r11, #168	; 0xa8
8f638af8:	e1a03009 	mov	r3, r9
8f638afc:	ebffed26 	bl	8f633f9c <sprintf>
				err = bio_publish_subdevice(device, subdevice, first_lba, size);
8f638b00:	e1a03004 	mov	r3, r4
8f638b04:	e24b10a8 	sub	r1, r11, #168	; 0xa8
8f638b08:	e1a02005 	mov	r2, r5
8f638b0c:	e1a00007 	mov	r0, r7
8f638b10:	ebfffbae 	bl	8f6379d0 <bio_publish_subdevice>
				if (err < 0) {
8f638b14:	e2504000 	subs	r4, r0, #0
8f638b18:	ba000035 	blt	8f638bf4 <partition_publish+0x558>
				bdev_t *partdev = bio_open(subdevice);
8f638b1c:	e24b00a8 	sub	r0, r11, #168	; 0xa8
8f638b20:	ebfff958 	bl	8f637088 <bio_open>
8f638b24:	e1a05000 	mov	r5, r0
				partdev->label = strdup((char*)name);
8f638b28:	e24b0f4e 	sub	r0, r11, #312	; 0x138
8f638b2c:	ebffeead 	bl	8f6345e8 <strdup>
				partdev->is_gpt = true;
8f638b30:	e3a03001 	mov	r3, #1
				if (strcmp(name, "system") == 0 || strcmp(name, "system_a") ||
8f638b34:	e51b11b0 	ldr	r1, [r11, #-432]	; 0xfffffe50
				partdev->is_gpt = true;
8f638b38:	e5853024 	str	r3, [r5, #36]	; 0x24
				partdev->label = strdup((char*)name);
8f638b3c:	e5850020 	str	r0, [r5, #32]
				if (strcmp(name, "system") == 0 || strcmp(name, "system_a") ||
8f638b40:	e24b0f4e 	sub	r0, r11, #312	; 0x138
8f638b44:	ebffee76 	bl	8f634524 <strcmp>
8f638b48:	e3500000 	cmp	r0, #0
8f638b4c:	0a000010 	beq	8f638b94 <partition_publish+0x4f8>
8f638b50:	e51b11bc 	ldr	r1, [r11, #-444]	; 0xfffffe44
8f638b54:	e24b0f4e 	sub	r0, r11, #312	; 0x138
8f638b58:	ebffee71 	bl	8f634524 <strcmp>
8f638b5c:	e3500000 	cmp	r0, #0
8f638b60:	1a00000b 	bne	8f638b94 <partition_publish+0x4f8>
				    strcmp(name, "system_b") || strcmp(name, "userdata") == 0)
8f638b64:	e24b0f4e 	sub	r0, r11, #312	; 0x138
8f638b68:	e30a1b2c 	movw	r1, #43820	; 0xab2c
8f638b6c:	e3481f70 	movt	r1, #36720	; 0x8f70
8f638b70:	ebffee6b 	bl	8f634524 <strcmp>
				if (strcmp(name, "system") == 0 || strcmp(name, "system_a") ||
8f638b74:	e3500000 	cmp	r0, #0
8f638b78:	1a000005 	bne	8f638b94 <partition_publish+0x4f8>
				    strcmp(name, "system_b") || strcmp(name, "userdata") == 0)
8f638b7c:	e24b0f4e 	sub	r0, r11, #312	; 0x138
8f638b80:	e3011288 	movw	r1, #4744	; 0x1288
8f638b84:	e3481f70 	movt	r1, #36720	; 0x8f70
8f638b88:	ebffee65 	bl	8f634524 <strcmp>
8f638b8c:	e3500000 	cmp	r0, #0
8f638b90:	1a000003 	bne	8f638ba4 <partition_publish+0x508>
					partition_publish(subdevice, 0);
8f638b94:	e24b00a8 	sub	r0, r11, #168	; 0xa8
8f638b98:	e3a02000 	mov	r2, #0
8f638b9c:	e3a03000 	mov	r3, #0
8f638ba0:	ebfffebd 	bl	8f63869c <partition_publish>
				count++;
8f638ba4:	e1a06009 	mov	r6, r9
			for (j = 0; j < part_entry_cnt; j++) {
8f638ba8:	e51b31a8 	ldr	r3, [r11, #-424]	; 0xfffffe58
8f638bac:	e2888001 	add	r8, r8, #1
8f638bb0:	e1530008 	cmp	r3, r8
8f638bb4:	1affff9a 	bne	8f638a24 <partition_publish+0x388>
		for (i = 0; i < (ROUNDUP(gpthdr.max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
8f638bb8:	e51b0194 	ldr	r0, [r11, #-404]	; 0xfffffe6c
8f638bbc:	e2400001 	sub	r0, r0, #1
8f638bc0:	e0800003 	add	r0, r0, r3
8f638bc4:	e51b31d0 	ldr	r3, [r11, #-464]	; 0xfffffe30
8f638bc8:	e0000003 	and	r0, r0, r3
8f638bcc:	e51b31b4 	ldr	r3, [r11, #-436]	; 0xfffffe4c
8f638bd0:	e51b11a8 	ldr	r1, [r11, #-424]	; 0xfffffe58
8f638bd4:	e2835001 	add	r5, r3, #1
8f638bd8:	e50b51b4 	str	r5, [r11, #-436]	; 0xfffffe4c
8f638bdc:	fa000ffd 	blx	8f63cbd8 <__udivsi3>
8f638be0:	e1500005 	cmp	r0, r5
8f638be4:	9a000039 	bls	8f638cd0 <partition_publish+0x634>
			err = bio_read(dev, buf, offset + (partition_0 * dev->block_size) + (i * dev->block_size),
8f638be8:	e51b31b8 	ldr	r3, [r11, #-440]	; 0xfffffe48
8f638bec:	e593c018 	ldr	r12, [r3, #24]
8f638bf0:	eaffff75 	b	8f6389cc <partition_publish+0x330>
					dprintf(INFO, "error publishing subdevice '%s'\n", name);
8f638bf4:	e24b1f4e 	sub	r1, r11, #312	; 0x138
8f638bf8:	e30b0364 	movw	r0, #45924	; 0xb364
8f638bfc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f638c00:	ebffe75b 	bl	8f632974 <_dprintf>
					continue;
8f638c04:	eaffffe7 	b	8f638ba8 <partition_publish+0x50c>
		printf("partition_publish: unable to open device\n");
8f638c08:	e30b02d8 	movw	r0, #45784	; 0xb2d8
8f638c0c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f638c10:	ebffeaf7 	bl	8f6337f4 <printf>
		return -1;
8f638c14:	e3e06000 	mvn	r6, #0
8f638c18:	eafffec4 	b	8f638730 <partition_publish+0x94>
					i = ROUNDUP(gpthdr.max_partition_count, part_entry_cnt);
8f638c1c:	e51b3194 	ldr	r3, [r11, #-404]	; 0xfffffe6c
8f638c20:	e51b21a8 	ldr	r2, [r11, #-424]	; 0xfffffe58
8f638c24:	e2433001 	sub	r3, r3, #1
8f638c28:	e0833002 	add	r3, r3, r2
8f638c2c:	e51b21d0 	ldr	r2, [r11, #-464]	; 0xfffffe30
8f638c30:	e0033002 	and	r3, r3, r2
8f638c34:	e50b31b4 	str	r3, [r11, #-436]	; 0xfffffe4c
					break;
8f638c38:	e1a00003 	mov	r0, r3
8f638c3c:	eaffffe2 	b	8f638bcc <partition_publish+0x530>
			uint64_t backup_header_lba = dev->block_count - 1;
8f638c40:	e595301c 	ldr	r3, [r5, #28]
			err = bio_read(dev, buf, (backup_header_lba * dev->block_size), dev->block_size);
8f638c44:	e1a0100a 	mov	r1, r10
8f638c48:	e5952018 	ldr	r2, [r5, #24]
8f638c4c:	e1a00005 	mov	r0, r5
			uint64_t backup_header_lba = dev->block_count - 1;
8f638c50:	e2433001 	sub	r3, r3, #1
			err = bio_read(dev, buf, (backup_header_lba * dev->block_size), dev->block_size);
8f638c54:	e58d2000 	str	r2, [r13]
8f638c58:	e0832293 	umull	r2, r3, r3, r2
8f638c5c:	ebfff955 	bl	8f6371b8 <bio_read>
			if (err < 0) {
8f638c60:	e2504000 	subs	r4, r0, #0
8f638c64:	ba00001b 	blt	8f638cd8 <partition_publish+0x63c>
	if (((uint32_t *) buffer)[0] != GPT_SIGNATURE_2 ||
8f638c68:	e59a2000 	ldr	r2, [r10]
8f638c6c:	e3043645 	movw	r3, #17989	; 0x4645
8f638c70:	e3423049 	movt	r3, #8265	; 0x2049
8f638c74:	e1520003 	cmp	r2, r3
8f638c78:	1a000009 	bne	8f638ca4 <partition_publish+0x608>
8f638c7c:	e59a2004 	ldr	r2, [r10, #4]
8f638c80:	e3043150 	movw	r3, #16720	; 0x4150
8f638c84:	e3453452 	movt	r3, #21586	; 0x5452
8f638c88:	e1520003 	cmp	r2, r3
8f638c8c:	1a000004 	bne	8f638ca4 <partition_publish+0x608>
8f638c90:	e24b1f69 	sub	r1, r11, #420	; 0x1a4
8f638c94:	e1a0000a 	mov	r0, r10
8f638c98:	ebfffe40 	bl	8f6385a0 <partition_parse_gpt_header.part.0>
			if (err) {
8f638c9c:	e3500000 	cmp	r0, #0
8f638ca0:	0affff2b 	beq	8f638954 <partition_publish+0x2b8>
				dprintf(CRITICAL, "GPT: Primary and backup signatures invalid\n");
8f638ca4:	e30101a4 	movw	r0, #4516	; 0x11a4
8f638ca8:	e3480f70 	movt	r0, #36720	; 0x8f70
8f638cac:	ebffe730 	bl	8f632974 <_dprintf>
	bio_close(dev);
8f638cb0:	e1a00005 	mov	r0, r5
8f638cb4:	ebfff920 	bl	8f63713c <bio_close>
	return (err < 0) ? err : count;
8f638cb8:	eafffe9c 	b	8f638730 <partition_publish+0x94>
				dprintf(CRITICAL,
8f638cbc:	e30b0388 	movw	r0, #45960	; 0xb388
8f638cc0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f638cc4:	e51b51b8 	ldr	r5, [r11, #-440]	; 0xfffffe48
8f638cc8:	ebffe729 	bl	8f632974 <_dprintf>
				break;
8f638ccc:	eafffe93 	b	8f638720 <partition_publish+0x84>
8f638cd0:	e51b51b8 	ldr	r5, [r11, #-440]	; 0xfffffe48
8f638cd4:	eafffe91 	b	8f638720 <partition_publish+0x84>
				dprintf(CRITICAL, "GPT: Could not read backup gpt from mmc\n");
8f638cd8:	e3010178 	movw	r0, #4472	; 0x1178
8f638cdc:	e3480f70 	movt	r0, #36720	; 0x8f70
8f638ce0:	ebffe723 	bl	8f632974 <_dprintf>
				break;
8f638ce4:	eafffe8d 	b	8f638720 <partition_publish+0x84>
}
8f638ce8:	ebffe7b4 	bl	8f632bc0 <__stack_chk_fail>
	bio_close(dev);
8f638cec:	e1a00005 	mov	r0, r5
8f638cf0:	ebfff911 	bl	8f63713c <bio_close>
	return (err < 0) ? err : count;
8f638cf4:	eafffe8d 	b	8f638730 <partition_publish+0x94>
8f638cf8:	8f74221c 	.word	0x8f74221c

8f638cfc <zcalloc>:

voidpf ZLIB_INTERNAL zcalloc (opaque, items, size)
    voidpf opaque;
    unsigned items;
    unsigned size;
{
8f638cfc:	e59f303c 	ldr	r3, [pc, #60]	; 8f638d40 <zcalloc+0x44>
8f638d00:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f638d04:	e24dd00c 	sub	r13, r13, #12
8f638d08:	e5933000 	ldr	r3, [r3]
8f638d0c:	e58d3004 	str	r3, [r13, #4]
8f638d10:	e3a03000 	mov	r3, #0
    if (opaque) items += size - size; /* make compiler happy */
    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
8f638d14:	e59f3024 	ldr	r3, [pc, #36]	; 8f638d40 <zcalloc+0x44>
8f638d18:	e5930000 	ldr	r0, [r3]
8f638d1c:	e59d3004 	ldr	r3, [r13, #4]
8f638d20:	e0330000 	eors	r0, r3, r0
8f638d24:	e3a03000 	mov	r3, #0
8f638d28:	1a000003 	bne	8f638d3c <zcalloc+0x40>
8f638d2c:	e0000192 	mul	r0, r2, r1
                              (voidpf)calloc(items, size);
}
8f638d30:	e28dd00c 	add	r13, r13, #12
8f638d34:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
8f638d38:	eaffecaf 	b	8f633ffc <malloc>
8f638d3c:	ebffe79f 	bl	8f632bc0 <__stack_chk_fail>
8f638d40:	8f74221c 	.word	0x8f74221c

8f638d44 <zcfree>:

void ZLIB_INTERNAL zcfree (opaque, ptr)
    voidpf opaque;
    voidpf ptr;
{
8f638d44:	e59f303c 	ldr	r3, [pc, #60]	; 8f638d88 <zcfree+0x44>
8f638d48:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f638d4c:	e24dd00c 	sub	r13, r13, #12
8f638d50:	e5933000 	ldr	r3, [r3]
8f638d54:	e58d3004 	str	r3, [r13, #4]
8f638d58:	e3a03000 	mov	r3, #0
    free(ptr);
8f638d5c:	e59f3024 	ldr	r3, [pc, #36]	; 8f638d88 <zcfree+0x44>
8f638d60:	e5932000 	ldr	r2, [r3]
8f638d64:	e59d3004 	ldr	r3, [r13, #4]
8f638d68:	e0332002 	eors	r2, r3, r2
8f638d6c:	e3a03000 	mov	r3, #0
8f638d70:	1a000003 	bne	8f638d84 <zcfree+0x40>
8f638d74:	e1a00001 	mov	r0, r1
    if (opaque) return; /* make compiler happy */
}
8f638d78:	e28dd00c 	add	r13, r13, #12
8f638d7c:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
    free(ptr);
8f638d80:	eaffece1 	b	8f63410c <free>
8f638d84:	ebffe78d 	bl	8f632bc0 <__stack_chk_fail>
8f638d88:	8f74221c 	.word	0x8f74221c

8f638d8c <adler32>:
{
    unsigned long sum2;
    unsigned n;

    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
8f638d8c:	e1a0c820 	lsr	r12, r0, #16
    adler &= 0xffff;
8f638d90:	e6ff3070 	uxth	r3, r0

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
8f638d94:	e3520001 	cmp	r2, #1
{
8f638d98:	e59f0350 	ldr	r0, [pc, #848]	; 8f6390f0 <adler32+0x364>
8f638d9c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f638da0:	e24dd00c 	sub	r13, r13, #12
8f638da4:	e5900000 	ldr	r0, [r0]
8f638da8:	e58d0004 	str	r0, [r13, #4]
8f638dac:	e3a00000 	mov	r0, #0
    if (len == 1) {
8f638db0:	0a00006c 	beq	8f638f68 <adler32+0x1dc>
            sum2 -= BASE;
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
8f638db4:	e3510000 	cmp	r1, #0
        return 1L;
8f638db8:	03a00001 	moveq	r0, #1
    if (buf == Z_NULL)
8f638dbc:	0a00004d 	beq	8f638ef8 <adler32+0x16c>

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
8f638dc0:	e352000f 	cmp	r2, #15
8f638dc4:	9a000053 	bls	8f638f18 <adler32+0x18c>
        MOD28(sum2);            /* only added so many BASE's */
        return adler | (sum2 << 16);
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
8f638dc8:	e30185af 	movw	r8, #5551	; 0x15af
8f638dcc:	e1520008 	cmp	r2, r8
8f638dd0:	9a000072 	bls	8f638fa0 <adler32+0x214>
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
        MOD(adler);
8f638dd4:	e3085071 	movw	r5, #32881	; 0x8071
8f638dd8:	e281ed57 	add	r14, r1, #5568	; 0x15c0
8f638ddc:	e3485007 	movt	r5, #32775	; 0x8007
            buf += 16;
8f638de0:	e30175b0 	movw	r7, #5552	; 0x15b0
        MOD(adler);
8f638de4:	e30f6ff1 	movw	r6, #65521	; 0xfff1
        len -= NMAX;
8f638de8:	e1a04002 	mov	r4, r2
8f638dec:	e2422d56 	sub	r2, r2, #5504	; 0x1580
8f638df0:	e2422030 	sub	r2, r2, #48	; 0x30
        n = NMAX / 16;          /* NMAX is divisible by 16 */
8f638df4:	e2810010 	add	r0, r1, #16
            DO16(buf);          /* 16 sums unrolled */
8f638df8:	e5509010 	ldrb	r9, [r0, #-16]
        } while (--n);
8f638dfc:	e2800010 	add	r0, r0, #16
            DO16(buf);          /* 16 sums unrolled */
8f638e00:	e550a01f 	ldrb	r10, [r0, #-31]	; 0xffffffe1
8f638e04:	e550b01e 	ldrb	r11, [r0, #-30]	; 0xffffffe2
8f638e08:	e0893003 	add	r3, r9, r3
8f638e0c:	e08aa003 	add	r10, r10, r3
8f638e10:	e083300a 	add	r3, r3, r10
8f638e14:	e08ba00a 	add	r10, r11, r10
8f638e18:	e550b01d 	ldrb	r11, [r0, #-29]	; 0xffffffe3
8f638e1c:	e083300a 	add	r3, r3, r10
8f638e20:	e08bb00a 	add	r11, r11, r10
8f638e24:	e550a01c 	ldrb	r10, [r0, #-28]	; 0xffffffe4
8f638e28:	e083300b 	add	r3, r3, r11
8f638e2c:	e08ab00b 	add	r11, r10, r11
8f638e30:	e550a01b 	ldrb	r10, [r0, #-27]	; 0xffffffe5
8f638e34:	e083300b 	add	r3, r3, r11
8f638e38:	e08aa00b 	add	r10, r10, r11
8f638e3c:	e550b01a 	ldrb	r11, [r0, #-26]	; 0xffffffe6
8f638e40:	e083300a 	add	r3, r3, r10
8f638e44:	e08ba00a 	add	r10, r11, r10
8f638e48:	e550b019 	ldrb	r11, [r0, #-25]	; 0xffffffe7
8f638e4c:	e083300a 	add	r3, r3, r10
8f638e50:	e08bb00a 	add	r11, r11, r10
8f638e54:	e550a018 	ldrb	r10, [r0, #-24]	; 0xffffffe8
8f638e58:	e083300b 	add	r3, r3, r11
8f638e5c:	e08ab00b 	add	r11, r10, r11
8f638e60:	e550a017 	ldrb	r10, [r0, #-23]	; 0xffffffe9
8f638e64:	e083300b 	add	r3, r3, r11
8f638e68:	e08aa00b 	add	r10, r10, r11
8f638e6c:	e550b016 	ldrb	r11, [r0, #-22]	; 0xffffffea
8f638e70:	e083300a 	add	r3, r3, r10
8f638e74:	e08ba00a 	add	r10, r11, r10
8f638e78:	e550b015 	ldrb	r11, [r0, #-21]	; 0xffffffeb
8f638e7c:	e083300a 	add	r3, r3, r10
8f638e80:	e08bb00a 	add	r11, r11, r10
8f638e84:	e550a014 	ldrb	r10, [r0, #-20]	; 0xffffffec
8f638e88:	e083300b 	add	r3, r3, r11
8f638e8c:	e08ab00b 	add	r11, r10, r11
8f638e90:	e550a013 	ldrb	r10, [r0, #-19]	; 0xffffffed
8f638e94:	e083900b 	add	r9, r3, r11
8f638e98:	e5503012 	ldrb	r3, [r0, #-18]	; 0xffffffee
8f638e9c:	e08aa00b 	add	r10, r10, r11
8f638ea0:	e083300a 	add	r3, r3, r10
8f638ea4:	e089900a 	add	r9, r9, r10
8f638ea8:	e550a011 	ldrb	r10, [r0, #-17]	; 0xffffffef
8f638eac:	e0899003 	add	r9, r9, r3
        } while (--n);
8f638eb0:	e15e0000 	cmp	r14, r0
            DO16(buf);          /* 16 sums unrolled */
8f638eb4:	e08a3003 	add	r3, r10, r3
8f638eb8:	e0899003 	add	r9, r9, r3
8f638ebc:	e08cc009 	add	r12, r12, r9
        } while (--n);
8f638ec0:	1affffcc 	bne	8f638df8 <adler32+0x6c>
        MOD(adler);
8f638ec4:	e0809395 	umull	r9, r0, r5, r3
    while (len >= NMAX) {
8f638ec8:	e1520008 	cmp	r2, r8
            buf += 16;
8f638ecc:	e0811007 	add	r1, r1, r7
    while (len >= NMAX) {
8f638ed0:	e08ee007 	add	r14, r14, r7
        MOD(adler);
8f638ed4:	e1a007a0 	lsr	r0, r0, #15
8f638ed8:	e0633096 	mls	r3, r6, r0, r3
        MOD(sum2);
8f638edc:	e0809c95 	umull	r9, r0, r5, r12
8f638ee0:	e1a007a0 	lsr	r0, r0, #15
8f638ee4:	e06cc096 	mls	r12, r6, r0, r12
    while (len >= NMAX) {
8f638ee8:	8affffbe 	bhi	8f638de8 <adler32+0x5c>
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
8f638eec:	e3520000 	cmp	r2, #0
8f638ef0:	1a000028 	bne	8f638f98 <adler32+0x20c>
        MOD(adler);
        MOD(sum2);
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
8f638ef4:	e183080c 	orr	r0, r3, r12, lsl #16
}
8f638ef8:	e59f31f0 	ldr	r3, [pc, #496]	; 8f6390f0 <adler32+0x364>
8f638efc:	e5932000 	ldr	r2, [r3]
8f638f00:	e59d3004 	ldr	r3, [r13, #4]
8f638f04:	e0332002 	eors	r2, r3, r2
8f638f08:	e3a03000 	mov	r3, #0
8f638f0c:	1a000076 	bne	8f6390ec <adler32+0x360>
8f638f10:	e28dd00c 	add	r13, r13, #12
8f638f14:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
        while (len--) {
8f638f18:	e3520000 	cmp	r2, #0
8f638f1c:	0a000005 	beq	8f638f38 <adler32+0x1ac>
8f638f20:	e0812002 	add	r2, r1, r2
            adler += *buf++;
8f638f24:	e4d10001 	ldrb	r0, [r1], #1
        while (len--) {
8f638f28:	e1510002 	cmp	r1, r2
            adler += *buf++;
8f638f2c:	e0833000 	add	r3, r3, r0
            sum2 += adler;
8f638f30:	e08cc003 	add	r12, r12, r3
        while (len--) {
8f638f34:	1afffffa 	bne	8f638f24 <adler32+0x198>
        if (adler >= BASE)
8f638f38:	e30f2ff0 	movw	r2, #65520	; 0xfff0
8f638f3c:	e1530002 	cmp	r3, r2
        MOD28(sum2);            /* only added so many BASE's */
8f638f40:	e3082071 	movw	r2, #32881	; 0x8071
8f638f44:	e3482007 	movt	r2, #32775	; 0x8007
8f638f48:	e30f1ff1 	movw	r1, #65521	; 0xfff1
            adler -= BASE;
8f638f4c:	82433cff 	subhi	r3, r3, #65280	; 0xff00
        MOD28(sum2);            /* only added so many BASE's */
8f638f50:	e0820c92 	umull	r0, r2, r2, r12
            adler -= BASE;
8f638f54:	824330f1 	subhi	r3, r3, #241	; 0xf1
        MOD28(sum2);            /* only added so many BASE's */
8f638f58:	e1a027a2 	lsr	r2, r2, #15
8f638f5c:	e06cc291 	mls	r12, r1, r2, r12
        return adler | (sum2 << 16);
8f638f60:	e183080c 	orr	r0, r3, r12, lsl #16
8f638f64:	eaffffe3 	b	8f638ef8 <adler32+0x16c>
        adler += buf[0];
8f638f68:	e5d11000 	ldrb	r1, [r1]
        if (adler >= BASE)
8f638f6c:	e30f2ff0 	movw	r2, #65520	; 0xfff0
        adler += buf[0];
8f638f70:	e0813003 	add	r3, r1, r3
        if (adler >= BASE)
8f638f74:	e1530002 	cmp	r3, r2
        if (sum2 >= BASE)
8f638f78:	e30f2ff0 	movw	r2, #65520	; 0xfff0
            adler -= BASE;
8f638f7c:	82433cff 	subhi	r3, r3, #65280	; 0xff00
8f638f80:	824330f1 	subhi	r3, r3, #241	; 0xf1
        sum2 += adler;
8f638f84:	e083c00c 	add	r12, r3, r12
        if (sum2 >= BASE)
8f638f88:	e15c0002 	cmp	r12, r2
            sum2 -= BASE;
8f638f8c:	824cccff 	subhi	r12, r12, #65280	; 0xff00
8f638f90:	824cc0f1 	subhi	r12, r12, #241	; 0xf1
8f638f94:	eaffffd6 	b	8f638ef4 <adler32+0x168>
        while (len >= 16) {
8f638f98:	e352000f 	cmp	r2, #15
8f638f9c:	9a00004f 	bls	8f6390e0 <adler32+0x354>
8f638fa0:	e2426010 	sub	r6, r2, #16
8f638fa4:	e2815020 	add	r5, r1, #32
8f638fa8:	e3c6400f 	bic	r4, r6, #15
8f638fac:	e281e010 	add	r14, r1, #16
8f638fb0:	e1a06226 	lsr	r6, r6, #4
8f638fb4:	e0855004 	add	r5, r5, r4
            DO16(buf);
8f638fb8:	e55e0010 	ldrb	r0, [r14, #-16]
        while (len >= 16) {
8f638fbc:	e28ee010 	add	r14, r14, #16
            DO16(buf);
8f638fc0:	e55e801f 	ldrb	r8, [r14, #-31]	; 0xffffffe1
8f638fc4:	e55e701e 	ldrb	r7, [r14, #-30]	; 0xffffffe2
8f638fc8:	e0803003 	add	r3, r0, r3
8f638fcc:	e0888003 	add	r8, r8, r3
8f638fd0:	e0833008 	add	r3, r3, r8
8f638fd4:	e0878008 	add	r8, r7, r8
8f638fd8:	e55e701d 	ldrb	r7, [r14, #-29]	; 0xffffffe3
8f638fdc:	e0830008 	add	r0, r3, r8
8f638fe0:	e55e301c 	ldrb	r3, [r14, #-28]	; 0xffffffe4
8f638fe4:	e0877008 	add	r7, r7, r8
8f638fe8:	e0800007 	add	r0, r0, r7
8f638fec:	e0837007 	add	r7, r3, r7
8f638ff0:	e55e301b 	ldrb	r3, [r14, #-27]	; 0xffffffe5
8f638ff4:	e0800007 	add	r0, r0, r7
8f638ff8:	e0833007 	add	r3, r3, r7
8f638ffc:	e55e701a 	ldrb	r7, [r14, #-26]	; 0xffffffe6
8f639000:	e0800003 	add	r0, r0, r3
8f639004:	e0877003 	add	r7, r7, r3
8f639008:	e55e3019 	ldrb	r3, [r14, #-25]	; 0xffffffe7
8f63900c:	e0800007 	add	r0, r0, r7
8f639010:	e0837007 	add	r7, r3, r7
8f639014:	e55e3018 	ldrb	r3, [r14, #-24]	; 0xffffffe8
8f639018:	e0800007 	add	r0, r0, r7
8f63901c:	e0833007 	add	r3, r3, r7
8f639020:	e55e7017 	ldrb	r7, [r14, #-23]	; 0xffffffe9
8f639024:	e0800003 	add	r0, r0, r3
8f639028:	e0877003 	add	r7, r7, r3
8f63902c:	e55e3016 	ldrb	r3, [r14, #-22]	; 0xffffffea
8f639030:	e0800007 	add	r0, r0, r7
8f639034:	e0837007 	add	r7, r3, r7
8f639038:	e55e3015 	ldrb	r3, [r14, #-21]	; 0xffffffeb
8f63903c:	e0800007 	add	r0, r0, r7
8f639040:	e0833007 	add	r3, r3, r7
8f639044:	e55e7014 	ldrb	r7, [r14, #-20]	; 0xffffffec
8f639048:	e0800003 	add	r0, r0, r3
8f63904c:	e0877003 	add	r7, r7, r3
8f639050:	e55e3013 	ldrb	r3, [r14, #-19]	; 0xffffffed
8f639054:	e0800007 	add	r0, r0, r7
8f639058:	e0837007 	add	r7, r3, r7
8f63905c:	e55e3012 	ldrb	r3, [r14, #-18]	; 0xffffffee
8f639060:	e0800007 	add	r0, r0, r7
8f639064:	e0833007 	add	r3, r3, r7
8f639068:	e55e7011 	ldrb	r7, [r14, #-17]	; 0xffffffef
8f63906c:	e0800003 	add	r0, r0, r3
        while (len >= 16) {
8f639070:	e155000e 	cmp	r5, r14
            DO16(buf);
8f639074:	e0873003 	add	r3, r7, r3
8f639078:	e0800003 	add	r0, r0, r3
8f63907c:	e08cc000 	add	r12, r12, r0
        while (len >= 16) {
8f639080:	1affffcc 	bne	8f638fb8 <adler32+0x22c>
            buf += 16;
8f639084:	e2866001 	add	r6, r6, #1
        while (len--) {
8f639088:	e312000f 	tst	r2, #15
8f63908c:	e2422011 	sub	r2, r2, #17
            buf += 16;
8f639090:	e0811206 	add	r1, r1, r6, lsl #4
        while (len--) {
8f639094:	e0422004 	sub	r2, r2, r4
8f639098:	0a000006 	beq	8f6390b8 <adler32+0x32c>
8f63909c:	e2822001 	add	r2, r2, #1
8f6390a0:	e0812002 	add	r2, r1, r2
            adler += *buf++;
8f6390a4:	e4d10001 	ldrb	r0, [r1], #1
        while (len--) {
8f6390a8:	e1510002 	cmp	r1, r2
            adler += *buf++;
8f6390ac:	e0833000 	add	r3, r3, r0
            sum2 += adler;
8f6390b0:	e08cc003 	add	r12, r12, r3
        while (len--) {
8f6390b4:	1afffffa 	bne	8f6390a4 <adler32+0x318>
        MOD(adler);
8f6390b8:	e3082071 	movw	r2, #32881	; 0x8071
8f6390bc:	e3482007 	movt	r2, #32775	; 0x8007
8f6390c0:	e30f0ff1 	movw	r0, #65521	; 0xfff1
8f6390c4:	e081e392 	umull	r14, r1, r2, r3
        MOD(sum2);
8f6390c8:	e082ec92 	umull	r14, r2, r2, r12
        MOD(adler);
8f6390cc:	e1a017a1 	lsr	r1, r1, #15
8f6390d0:	e0633190 	mls	r3, r0, r1, r3
        MOD(sum2);
8f6390d4:	e1a027a2 	lsr	r2, r2, #15
8f6390d8:	e06cc290 	mls	r12, r0, r2, r12
8f6390dc:	eaffff84 	b	8f638ef4 <adler32+0x168>
        while (len--) {
8f6390e0:	e2442d56 	sub	r2, r4, #5504	; 0x1580
8f6390e4:	e2422031 	sub	r2, r2, #49	; 0x31
8f6390e8:	eaffffeb 	b	8f63909c <adler32+0x310>
}
8f6390ec:	ebffe6b3 	bl	8f632bc0 <__stack_chk_fail>
8f6390f0:	8f74221c 	.word	0x8f74221c

8f6390f4 <inflate_table>:
unsigned short FAR *lens;
unsigned codes;
code FAR * FAR *table;
unsigned FAR *bits;
unsigned short FAR *work;
{
8f6390f4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f6390f8:	e24dd084 	sub	r13, r13, #132	; 0x84
8f6390fc:	e28de03c 	add	r14, r13, #60	; 0x3c
8f639100:	e59dc0a8 	ldr	r12, [r13, #168]	; 0xa8
8f639104:	e58d3020 	str	r3, [r13, #32]
8f639108:	e59f353c 	ldr	r3, [pc, #1340]	; 8f63964c <inflate_table+0x558>
8f63910c:	e59db0ac 	ldr	r11, [r13, #172]	; 0xac
8f639110:	e58dc01c 	str	r12, [r13, #28]
8f639114:	e28dc05a 	add	r12, r13, #90	; 0x5a
8f639118:	e58d100c 	str	r1, [r13, #12]
8f63911c:	e5933000 	ldr	r3, [r3]
8f639120:	e58d307c 	str	r3, [r13, #124]	; 0x7c
8f639124:	e3a03000 	mov	r3, #0
       at length counts to determine sub-table sizes when building the
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
8f639128:	e28d303a 	add	r3, r13, #58	; 0x3a
        count[len] = 0;
8f63912c:	e3a01000 	mov	r1, #0
8f639130:	e1e310b2 	strh	r1, [r3, #2]!
    for (len = 0; len <= MAXBITS; len++)
8f639134:	e15c0003 	cmp	r12, r3
8f639138:	1afffffc 	bne	8f639130 <inflate_table+0x3c>
    for (sym = 0; sym < codes; sym++)
8f63913c:	e3520000 	cmp	r2, #0
8f639140:	159d400c 	ldrne	r4, [r13, #12]
8f639144:	10845082 	addne	r5, r4, r2, lsl #1
8f639148:	0a000007 	beq	8f63916c <inflate_table+0x78>
        count[lens[sym]]++;
8f63914c:	e0d430b2 	ldrh	r3, [r4], #2
8f639150:	e28d1080 	add	r1, r13, #128	; 0x80
    for (sym = 0; sym < codes; sym++)
8f639154:	e1550004 	cmp	r5, r4
        count[lens[sym]]++;
8f639158:	e0813083 	add	r3, r1, r3, lsl #1
8f63915c:	e15314b4 	ldrh	r1, [r3, #-68]	; 0xffffffbc
8f639160:	e2811001 	add	r1, r1, #1
8f639164:	e14314b4 	strh	r1, [r3, #-68]	; 0xffffffbc
    for (sym = 0; sym < codes; sym++)
8f639168:	1afffff7 	bne	8f63914c <inflate_table+0x58>

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
    for (max = MAXBITS; max >= 1; max--)
8f63916c:	e28d305c 	add	r3, r13, #92	; 0x5c
8f639170:	e3a0400f 	mov	r4, #15
        if (count[max] != 0) break;
8f639174:	e17310b2 	ldrh	r1, [r3, #-2]!
8f639178:	e3510000 	cmp	r1, #0
8f63917c:	1a000016 	bne	8f6391dc <inflate_table+0xe8>
    for (max = MAXBITS; max >= 1; max--)
8f639180:	e2544001 	subs	r4, r4, #1
8f639184:	1afffffa 	bne	8f639174 <inflate_table+0x80>
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
        here.op = (unsigned char)64;    /* invalid code marker */
        here.bits = (unsigned char)1;
        here.val = (unsigned short)0;
        *(*table)++ = here;             /* make a table to force an error */
8f639188:	e59d0020 	ldr	r0, [r13, #32]
8f63918c:	e3a02d05 	mov	r2, #320	; 0x140
8f639190:	e5903000 	ldr	r3, [r0]
        *(*table)++ = here;
8f639194:	e2831008 	add	r1, r3, #8
        *(*table)++ = here;             /* make a table to force an error */
8f639198:	e1c340b2 	strh	r4, [r3, #2]
8f63919c:	e1c320b0 	strh	r2, [r3]
        *(*table)++ = here;
8f6391a0:	e5801000 	str	r1, [r0]
        *bits = 1;
        return 0;     /* no symbols, but wait for decoding to report error */
8f6391a4:	e1a00004 	mov	r0, r4
        *(*table)++ = here;
8f6391a8:	e1c320b4 	strh	r2, [r3, #4]
        *bits = 1;
8f6391ac:	e3a01001 	mov	r1, #1
        *(*table)++ = here;
8f6391b0:	e1c340b6 	strh	r4, [r3, #6]
        *bits = 1;
8f6391b4:	e59d301c 	ldr	r3, [r13, #28]
8f6391b8:	e5831000 	str	r1, [r3]

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
}
8f6391bc:	e59f3488 	ldr	r3, [pc, #1160]	; 8f63964c <inflate_table+0x558>
8f6391c0:	e5932000 	ldr	r2, [r3]
8f6391c4:	e59d307c 	ldr	r3, [r13, #124]	; 0x7c
8f6391c8:	e0332002 	eors	r2, r3, r2
8f6391cc:	e3a03000 	mov	r3, #0
8f6391d0:	1a00011c 	bne	8f639648 <inflate_table+0x554>
8f6391d4:	e28dd084 	add	r13, r13, #132	; 0x84
8f6391d8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
    for (min = 1; min < max; min++)
8f6391dc:	e3540001 	cmp	r4, #1
8f6391e0:	01a05004 	moveq	r5, r4
8f6391e4:	0a000008 	beq	8f63920c <inflate_table+0x118>
8f6391e8:	e28d303c 	add	r3, r13, #60	; 0x3c
8f6391ec:	e3a05001 	mov	r5, #1
8f6391f0:	ea000002 	b	8f639200 <inflate_table+0x10c>
8f6391f4:	e2855001 	add	r5, r5, #1
8f6391f8:	e1550004 	cmp	r5, r4
8f6391fc:	0a000002 	beq	8f63920c <inflate_table+0x118>
        if (count[min] != 0) break;
8f639200:	e1f310b2 	ldrh	r1, [r3, #2]!
8f639204:	e3510000 	cmp	r1, #0
8f639208:	0afffff9 	beq	8f6391f4 <inflate_table+0x100>
    left = 1;
8f63920c:	e3a03001 	mov	r3, #1
        left -= count[len];
8f639210:	e1fe10b2 	ldrh	r1, [r14, #2]!
        if (left < 0) return -1;        /* over-subscribed */
8f639214:	e0713083 	rsbs	r3, r1, r3, lsl #1
8f639218:	4a00003b 	bmi	8f63930c <inflate_table+0x218>
    for (len = 1; len <= MAXBITS; len++) {
8f63921c:	e15e000c 	cmp	r14, r12
8f639220:	1afffffa 	bne	8f639210 <inflate_table+0x11c>
    if (left > 0 && (type == CODES || max != 1))
8f639224:	e3530000 	cmp	r3, #0
8f639228:	0a000005 	beq	8f639244 <inflate_table+0x150>
8f63922c:	e2543001 	subs	r3, r4, #1
8f639230:	13a03001 	movne	r3, #1
8f639234:	e3500000 	cmp	r0, #0
8f639238:	03833001 	orreq	r3, r3, #1
8f63923c:	e3530000 	cmp	r3, #0
8f639240:	1a000031 	bne	8f63930c <inflate_table+0x218>
    root = *bits;
8f639244:	e59d301c 	ldr	r3, [r13, #28]
8f639248:	e28d103e 	add	r1, r13, #62	; 0x3e
8f63924c:	e28de060 	add	r14, r13, #96	; 0x60
8f639250:	e5936000 	ldr	r6, [r3]
    offs[1] = 0;
8f639254:	e3a03000 	mov	r3, #0
8f639258:	e1cd35be 	strh	r3, [r13, #94]	; 0x5e
        offs[len + 1] = offs[len] + count[len];
8f63925c:	e0d170b2 	ldrh	r7, [r1], #2
8f639260:	e0873003 	add	r3, r7, r3
    for (len = 1; len < MAXBITS; len++)
8f639264:	e151000c 	cmp	r1, r12
        offs[len + 1] = offs[len] + count[len];
8f639268:	e6ff3073 	uxth	r3, r3
8f63926c:	e0ce30b2 	strh	r3, [r14], #2
    for (len = 1; len < MAXBITS; len++)
8f639270:	1afffff9 	bne	8f63925c <inflate_table+0x168>
    for (sym = 0; sym < codes; sym++)
8f639274:	e3520000 	cmp	r2, #0
8f639278:	0a00000f 	beq	8f6392bc <inflate_table+0x1c8>
8f63927c:	e59d100c 	ldr	r1, [r13, #12]
8f639280:	e3a0c000 	mov	r12, #0
8f639284:	e0812082 	add	r2, r1, r2, lsl #1
        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
8f639288:	e0d130b2 	ldrh	r3, [r1], #2
8f63928c:	e3530000 	cmp	r3, #0
8f639290:	0a000006 	beq	8f6392b0 <inflate_table+0x1bc>
8f639294:	e28de080 	add	r14, r13, #128	; 0x80
8f639298:	e08e3083 	add	r3, r14, r3, lsl #1
8f63929c:	e153e2b4 	ldrh	r14, [r3, #-36]	; 0xffffffdc
8f6392a0:	e28e7001 	add	r7, r14, #1
8f6392a4:	e14372b4 	strh	r7, [r3, #-36]	; 0xffffffdc
8f6392a8:	e1a0e08e 	lsl	r14, r14, #1
8f6392ac:	e18bc0be 	strh	r12, [r11, r14]
    for (sym = 0; sym < codes; sym++)
8f6392b0:	e1520001 	cmp	r2, r1
8f6392b4:	e28cc001 	add	r12, r12, #1
8f6392b8:	1afffff2 	bne	8f639288 <inflate_table+0x194>
8f6392bc:	e1560004 	cmp	r6, r4
8f6392c0:	21a06004 	movcs	r6, r4
8f6392c4:	e1550006 	cmp	r5, r6
8f6392c8:	21a03005 	movcs	r3, r5
8f6392cc:	31a03006 	movcc	r3, r6
    switch (type) {
8f6392d0:	e3500000 	cmp	r0, #0
8f6392d4:	e58d3004 	str	r3, [r13, #4]
8f6392d8:	0a000026 	beq	8f639378 <inflate_table+0x284>
8f6392dc:	e3500001 	cmp	r0, #1
8f6392e0:	1a00000b 	bne	8f639314 <inflate_table+0x220>
    used = 1U << root;          /* use root table entries */
8f6392e4:	e59d3004 	ldr	r3, [r13, #4]
8f6392e8:	e1a03310 	lsl	r3, r0, r3
8f6392ec:	e58d3018 	str	r3, [r13, #24]
    if ((type == LENS && used > ENOUGH_LENS) ||
8f6392f0:	e3530fd5 	cmp	r3, #852	; 0x354
    next = *table;              /* current table to fill in */
8f6392f4:	e59d3020 	ldr	r3, [r13, #32]
8f6392f8:	e5933000 	ldr	r3, [r3]
8f6392fc:	e58d3028 	str	r3, [r13, #40]	; 0x28
    if ((type == LENS && used > ENOUGH_LENS) ||
8f639300:	9a0000c3 	bls	8f639614 <inflate_table+0x520>
        return 1;
8f639304:	e3a00001 	mov	r0, #1
8f639308:	eaffffab 	b	8f6391bc <inflate_table+0xc8>
        if (left < 0) return -1;        /* over-subscribed */
8f63930c:	e3e00000 	mvn	r0, #0
8f639310:	eaffffa9 	b	8f6391bc <inflate_table+0xc8>
    used = 1U << root;          /* use root table entries */
8f639314:	e59d2004 	ldr	r2, [r13, #4]
8f639318:	e3a03001 	mov	r3, #1
8f63931c:	e1a02213 	lsl	r2, r3, r2
        (type == DISTS && used > ENOUGH_DISTS))
8f639320:	e2403002 	sub	r3, r0, #2
8f639324:	e16f3f13 	clz	r3, r3
    used = 1U << root;          /* use root table entries */
8f639328:	e58d2018 	str	r2, [r13, #24]
        (type == DISTS && used > ENOUGH_DISTS))
8f63932c:	e1a032a3 	lsr	r3, r3, #5
8f639330:	e58d3034 	str	r3, [r13, #52]	; 0x34
    if ((type == LENS && used > ENOUGH_LENS) ||
8f639334:	e3520e25 	cmp	r2, #592	; 0x250
8f639338:	93a03000 	movls	r3, #0
8f63933c:	82033001 	andhi	r3, r3, #1
8f639340:	e3530000 	cmp	r3, #0
    next = *table;              /* current table to fill in */
8f639344:	e59d3020 	ldr	r3, [r13, #32]
8f639348:	e5933000 	ldr	r3, [r3]
8f63934c:	e58d3028 	str	r3, [r13, #40]	; 0x28
    if ((type == LENS && used > ENOUGH_LENS) ||
8f639350:	1affffeb 	bne	8f639304 <inflate_table+0x210>
        extra = dext;
8f639354:	e30b3400 	movw	r3, #46080	; 0xb400
8f639358:	e3483f70 	movt	r3, #36720	; 0x8f70
8f63935c:	e58d3024 	str	r3, [r13, #36]	; 0x24
        base = dbase;
8f639360:	e30b33c0 	movw	r3, #46016	; 0xb3c0
8f639364:	e3483f70 	movt	r3, #36720	; 0x8f70
8f639368:	e58d302c 	str	r3, [r13, #44]	; 0x2c
        end = -1;
8f63936c:	e3e03000 	mvn	r3, #0
8f639370:	e58d3008 	str	r3, [r13, #8]
8f639374:	ea00000b 	b	8f6393a8 <inflate_table+0x2b4>
    used = 1U << root;          /* use root table entries */
8f639378:	e59d2004 	ldr	r2, [r13, #4]
8f63937c:	e3a03001 	mov	r3, #1
8f639380:	e58db024 	str	r11, [r13, #36]	; 0x24
8f639384:	e1a03213 	lsl	r3, r3, r2
8f639388:	e58d3018 	str	r3, [r13, #24]
    next = *table;              /* current table to fill in */
8f63938c:	e59d3020 	ldr	r3, [r13, #32]
    used = 1U << root;          /* use root table entries */
8f639390:	e58db02c 	str	r11, [r13, #44]	; 0x2c
        (type == DISTS && used > ENOUGH_DISTS))
8f639394:	e58d0034 	str	r0, [r13, #52]	; 0x34
    next = *table;              /* current table to fill in */
8f639398:	e5933000 	ldr	r3, [r3]
8f63939c:	e58d3028 	str	r3, [r13, #40]	; 0x28
    used = 1U << root;          /* use root table entries */
8f6393a0:	e3a03013 	mov	r3, #19
8f6393a4:	e58d3008 	str	r3, [r13, #8]
    if ((type == LENS && used > ENOUGH_LENS) ||
8f6393a8:	e2403001 	sub	r3, r0, #1
8f6393ac:	e16f3f13 	clz	r3, r3
8f6393b0:	e1a032a3 	lsr	r3, r3, #5
8f6393b4:	e58d3030 	str	r3, [r13, #48]	; 0x30
    mask = used - 1;            /* mask for comparing low */
8f6393b8:	e59d3018 	ldr	r3, [r13, #24]
8f6393bc:	e2433001 	sub	r3, r3, #1
8f6393c0:	e58d3014 	str	r3, [r13, #20]
        (type == DISTS && used > ENOUGH_DISTS))
8f6393c4:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f6393c8:	e3a0e000 	mov	r14, #0
8f6393cc:	e59d8004 	ldr	r8, [r13, #4]
8f6393d0:	e1a0a00e 	mov	r10, r14
8f6393d4:	e1a0c005 	mov	r12, r5
        incr = 1U << (len - drop);
8f6393d8:	e3a09001 	mov	r9, #1
            next += min;            /* here min is 1 << curr */
8f6393dc:	e1a00005 	mov	r0, r5
        (type == DISTS && used > ENOUGH_DISTS))
8f6393e0:	e58d3000 	str	r3, [r13]
8f6393e4:	e3e03000 	mvn	r3, #0
8f6393e8:	e58d3010 	str	r3, [r13, #16]
        if ((int)(work[sym]) < end) {
8f6393ec:	e0db70b2 	ldrh	r7, [r11], #2
        here.bits = (unsigned char)(len - drop);
8f6393f0:	e6ef6070 	uxtb	r6, r0
        if ((int)(work[sym]) < end) {
8f6393f4:	e59d3008 	ldr	r3, [r13, #8]
8f6393f8:	e1570003 	cmp	r7, r3
            here.op = (unsigned char)0;
8f6393fc:	b3a0c000 	movlt	r12, #0
        if ((int)(work[sym]) < end) {
8f639400:	ba000006 	blt	8f639420 <inflate_table+0x32c>
            here.op = (unsigned char)(extra[work[sym]]);
8f639404:	c59d2024 	ldrgt	r2, [r13, #36]	; 0x24
8f639408:	c1a03087 	lslgt	r3, r7, #1
            here.val = 0;
8f63940c:	d3a07000 	movle	r7, #0
            here.op = (unsigned char)(32 + 64);         /* end of block */
8f639410:	d3a0c060 	movle	r12, #96	; 0x60
            here.op = (unsigned char)(extra[work[sym]]);
8f639414:	c7d2c087 	ldrbgt	r12, [r2, r7, lsl #1]
            here.val = base[work[sym]];
8f639418:	c59d202c 	ldrgt	r2, [r13, #44]	; 0x2c
8f63941c:	c19270b3 	ldrhgt	r7, [r2, r3]
            next[(huff >> drop) + fill] = here;
8f639420:	e1a03a3e 	lsr	r3, r14, r10
8f639424:	e59d2000 	ldr	r2, [r13]
8f639428:	e0833819 	add	r3, r3, r9, lsl r8
        incr = 1U << (len - drop);
8f63942c:	e1a01019 	lsl	r1, r9, r0
        fill = 1U << curr;
8f639430:	e0433019 	sub	r3, r3, r9, lsl r0
8f639434:	e0823103 	add	r3, r2, r3, lsl #2
8f639438:	e3e02003 	mvn	r2, #3
8f63943c:	e1a00012 	lsl	r0, r2, r0
8f639440:	e1a02819 	lsl	r2, r9, r8
        } while (fill != 0);
8f639444:	e0522001 	subs	r2, r2, r1
            next[(huff >> drop) + fill] = here;
8f639448:	e5c3c000 	strb	r12, [r3]
8f63944c:	e5c36001 	strb	r6, [r3, #1]
8f639450:	e1c370b2 	strh	r7, [r3, #2]
        } while (fill != 0);
8f639454:	e0833000 	add	r3, r3, r0
8f639458:	1afffff9 	bne	8f639444 <inflate_table+0x350>
        incr = 1U << (len - 1);
8f63945c:	e2453001 	sub	r3, r5, #1
        while (huff & incr)
8f639460:	e01e2319 	ands	r2, r14, r9, lsl r3
        incr = 1U << (len - 1);
8f639464:	e1a03319 	lsl	r3, r9, r3
        while (huff & incr)
8f639468:	0a000002 	beq	8f639478 <inflate_table+0x384>
            incr >>= 1;
8f63946c:	e1a030a3 	lsr	r3, r3, #1
        while (huff & incr)
8f639470:	e11e0003 	tst	r14, r3
8f639474:	1afffffc 	bne	8f63946c <inflate_table+0x378>
        if (incr != 0) {
8f639478:	e3530000 	cmp	r3, #0
            huff &= incr - 1;
8f63947c:	12432001 	subne	r2, r3, #1
8f639480:	1002200e 	andne	r2, r2, r14
            huff += incr;
8f639484:	10833002 	addne	r3, r3, r2
        if (--(count[len]) == 0) {
8f639488:	e28d2080 	add	r2, r13, #128	; 0x80
8f63948c:	e0821085 	add	r1, r2, r5, lsl #1
8f639490:	e15124b4 	ldrh	r2, [r1, #-68]	; 0xffffffbc
8f639494:	e2422001 	sub	r2, r2, #1
8f639498:	e6ff2072 	uxth	r2, r2
8f63949c:	e14124b4 	strh	r2, [r1, #-68]	; 0xffffffbc
8f6394a0:	e3520000 	cmp	r2, #0
8f6394a4:	1a000005 	bne	8f6394c0 <inflate_table+0x3cc>
            if (len == max) break;
8f6394a8:	e1550004 	cmp	r5, r4
8f6394ac:	0a000046 	beq	8f6395cc <inflate_table+0x4d8>
            len = lens[work[sym]];
8f6394b0:	e1db20b0 	ldrh	r2, [r11]
8f6394b4:	e59d100c 	ldr	r1, [r13, #12]
8f6394b8:	e1a02082 	lsl	r2, r2, #1
8f6394bc:	e19150b2 	ldrh	r5, [r1, r2]
        if (len > root && (huff & mask) != low) {
8f6394c0:	e59d2004 	ldr	r2, [r13, #4]
8f6394c4:	e1520005 	cmp	r2, r5
8f6394c8:	2a000004 	bcs	8f6394e0 <inflate_table+0x3ec>
8f6394cc:	e59d2014 	ldr	r2, [r13, #20]
8f6394d0:	e003e002 	and	r14, r3, r2
8f6394d4:	e59d2010 	ldr	r2, [r13, #16]
8f6394d8:	e15e0002 	cmp	r14, r2
8f6394dc:	1a000002 	bne	8f6394ec <inflate_table+0x3f8>
8f6394e0:	e045000a 	sub	r0, r5, r10
        (type == DISTS && used > ENOUGH_DISTS))
8f6394e4:	e1a0e003 	mov	r14, r3
8f6394e8:	eaffffbf 	b	8f6393ec <inflate_table+0x2f8>
            next += min;            /* here min is 1 << curr */
8f6394ec:	e59d2000 	ldr	r2, [r13]
8f6394f0:	e3a01004 	mov	r1, #4
            if (drop == 0)
8f6394f4:	e35a0000 	cmp	r10, #0
            next += min;            /* here min is 1 << curr */
8f6394f8:	e0822811 	add	r2, r2, r1, lsl r8
8f6394fc:	e58d2000 	str	r2, [r13]
            if (drop == 0)
8f639500:	e59d2004 	ldr	r2, [r13, #4]
8f639504:	01a0a002 	moveq	r10, r2
            while (curr + drop < max) {
8f639508:	e1550004 	cmp	r5, r4
            curr = len - drop;
8f63950c:	e045800a 	sub	r8, r5, r10
            left = (int)(1 << curr);
8f639510:	e1a0c819 	lsl	r12, r9, r8
            curr = len - drop;
8f639514:	e1a00008 	mov	r0, r8
            while (curr + drop < max) {
8f639518:	2a000011 	bcs	8f639564 <inflate_table+0x470>
                left -= count[curr + drop];
8f63951c:	e28d2080 	add	r2, r13, #128	; 0x80
8f639520:	e0822085 	add	r2, r2, r5, lsl #1
8f639524:	e15224b4 	ldrh	r2, [r2, #-68]	; 0xffffffbc
8f639528:	e04c2002 	sub	r2, r12, r2
                if (left <= 0) break;
8f63952c:	e3520000 	cmp	r2, #0
8f639530:	da00000b 	ble	8f639564 <inflate_table+0x470>
8f639534:	e28d103c 	add	r1, r13, #60	; 0x3c
8f639538:	e0811085 	add	r1, r1, r5, lsl #1
8f63953c:	ea000003 	b	8f639550 <inflate_table+0x45c>
                left -= count[curr + drop];
8f639540:	e1f1c0b2 	ldrh	r12, [r1, #2]!
8f639544:	e042200c 	sub	r2, r2, r12
                if (left <= 0) break;
8f639548:	e3520000 	cmp	r2, #0
8f63954c:	da000004 	ble	8f639564 <inflate_table+0x470>
                curr++;
8f639550:	e2888001 	add	r8, r8, #1
                left <<= 1;
8f639554:	e1a02082 	lsl	r2, r2, #1
            while (curr + drop < max) {
8f639558:	e08ac008 	add	r12, r10, r8
8f63955c:	e15c0004 	cmp	r12, r4
8f639560:	3afffff6 	bcc	8f639540 <inflate_table+0x44c>
            used += 1U << curr;
8f639564:	e59d2018 	ldr	r2, [r13, #24]
8f639568:	e0821819 	add	r1, r2, r9, lsl r8
            if ((type == LENS && used > ENOUGH_LENS) ||
8f63956c:	e59d2030 	ldr	r2, [r13, #48]	; 0x30
            used += 1U << curr;
8f639570:	e58d1018 	str	r1, [r13, #24]
            if ((type == LENS && used > ENOUGH_LENS) ||
8f639574:	e3510fd5 	cmp	r1, #852	; 0x354
8f639578:	93a02000 	movls	r2, #0
8f63957c:	82022001 	andhi	r2, r2, #1
8f639580:	e3520000 	cmp	r2, #0
8f639584:	1affff5e 	bne	8f639304 <inflate_table+0x210>
8f639588:	e59d2034 	ldr	r2, [r13, #52]	; 0x34
8f63958c:	e3510e25 	cmp	r1, #592	; 0x250
8f639590:	93a02000 	movls	r2, #0
8f639594:	82022001 	andhi	r2, r2, #1
8f639598:	e3520000 	cmp	r2, #0
8f63959c:	1affff58 	bne	8f639304 <inflate_table+0x210>
            (*table)[low].op = (unsigned char)curr;
8f6395a0:	e59d1028 	ldr	r1, [r13, #40]	; 0x28
            (*table)[low].bits = (unsigned char)root;
8f6395a4:	e59dc004 	ldr	r12, [r13, #4]
            (*table)[low].op = (unsigned char)curr;
8f6395a8:	e081210e 	add	r2, r1, r14, lsl #2
            (*table)[low].val = (unsigned short)(next - *table);
8f6395ac:	e58de010 	str	r14, [r13, #16]
            (*table)[low].op = (unsigned char)curr;
8f6395b0:	e7c1810e 	strb	r8, [r1, r14, lsl #2]
            (*table)[low].bits = (unsigned char)root;
8f6395b4:	e5c2c001 	strb	r12, [r2, #1]
            (*table)[low].val = (unsigned short)(next - *table);
8f6395b8:	e59dc000 	ldr	r12, [r13]
8f6395bc:	e04c1001 	sub	r1, r12, r1
8f6395c0:	e1a01141 	asr	r1, r1, #2
8f6395c4:	e1c210b2 	strh	r1, [r2, #2]
8f6395c8:	eaffffc5 	b	8f6394e4 <inflate_table+0x3f0>
    if (huff != 0) {
8f6395cc:	e3530000 	cmp	r3, #0
8f6395d0:	0a000005 	beq	8f6395ec <inflate_table+0x4f8>
        next[huff] = here;
8f6395d4:	e59dc000 	ldr	r12, [r13]
8f6395d8:	e3a00040 	mov	r0, #64	; 0x40
8f6395dc:	e08c1103 	add	r1, r12, r3, lsl #2
8f6395e0:	e7cc0103 	strb	r0, [r12, r3, lsl #2]
8f6395e4:	e5c16001 	strb	r6, [r1, #1]
8f6395e8:	e1c120b2 	strh	r2, [r1, #2]
    *table += used;
8f6395ec:	e59d2018 	ldr	r2, [r13, #24]
    return 0;
8f6395f0:	e3a00000 	mov	r0, #0
    *table += used;
8f6395f4:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f6395f8:	e0833102 	add	r3, r3, r2, lsl #2
8f6395fc:	e59d2020 	ldr	r2, [r13, #32]
8f639600:	e5823000 	str	r3, [r2]
    *bits = root;
8f639604:	e59d301c 	ldr	r3, [r13, #28]
8f639608:	e59d2004 	ldr	r2, [r13, #4]
8f63960c:	e5832000 	str	r2, [r3]
    return 0;
8f639610:	eafffee9 	b	8f6391bc <inflate_table+0xc8>
        extra -= 257;
8f639614:	e59f3034 	ldr	r3, [pc, #52]	; 8f639650 <inflate_table+0x55c>
    if ((type == LENS && used > ENOUGH_LENS) ||
8f639618:	e58d0030 	str	r0, [r13, #48]	; 0x30
        extra -= 257;
8f63961c:	e58d3024 	str	r3, [r13, #36]	; 0x24
        base -= 257;
8f639620:	e59f302c 	ldr	r3, [pc, #44]	; 8f639654 <inflate_table+0x560>
8f639624:	e58d302c 	str	r3, [r13, #44]	; 0x2c
    mask = used - 1;            /* mask for comparing low */
8f639628:	e59d3018 	ldr	r3, [r13, #24]
8f63962c:	e2433001 	sub	r3, r3, #1
8f639630:	e58d3014 	str	r3, [r13, #20]
        end = 256;
8f639634:	e3a03c01 	mov	r3, #256	; 0x100
8f639638:	e58d3008 	str	r3, [r13, #8]
        (type == DISTS && used > ENOUGH_DISTS))
8f63963c:	e3a03000 	mov	r3, #0
8f639640:	e58d3034 	str	r3, [r13, #52]	; 0x34
8f639644:	eaffff5e 	b	8f6393c4 <inflate_table+0x2d0>
}
8f639648:	ebffe55c 	bl	8f632bc0 <__stack_chk_fail>
8f63964c:	8f74221c 	.word	0x8f74221c
8f639650:	8f70b27e 	.word	0x8f70b27e
8f639654:	8f70b23e 	.word	0x8f70b23e

8f639658 <updatewindow>:
 */
local int updatewindow(strm, end, copy)
z_streamp strm;
const Bytef *end;
unsigned copy;
{
8f639658:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f63965c:	e1a03000 	mov	r3, r0
    struct inflate_state FAR *state;
    unsigned dist;

    state = (struct inflate_state FAR *)strm->state;
8f639660:	e590501c 	ldr	r5, [r0, #28]
{
8f639664:	e1a06002 	mov	r6, r2
8f639668:	e59f2140 	ldr	r2, [pc, #320]	; 8f6397b0 <updatewindow+0x158>
8f63966c:	e24dd008 	sub	r13, r13, #8
8f639670:	e1a07001 	mov	r7, r1

    /* if it hasn't been done already, allocate space for the window */
    if (state->window == Z_NULL) {
8f639674:	e5950034 	ldr	r0, [r5, #52]	; 0x34
{
8f639678:	e5922000 	ldr	r2, [r2]
8f63967c:	e58d2004 	str	r2, [r13, #4]
8f639680:	e3a02000 	mov	r2, #0
    if (state->window == Z_NULL) {
8f639684:	e3500000 	cmp	r0, #0
8f639688:	0a000031 	beq	8f639754 <updatewindow+0xfc>
                               sizeof(unsigned char));
        if (state->window == Z_NULL) return 1;
    }

    /* if window not in use yet, initialize */
    if (state->wsize == 0) {
8f63968c:	e5952028 	ldr	r2, [r5, #40]	; 0x28
8f639690:	e3520000 	cmp	r2, #0
8f639694:	1a000006 	bne	8f6396b4 <updatewindow+0x5c>
        state->wsize = 1U << state->wbits;
8f639698:	e5952024 	ldr	r2, [r5, #36]	; 0x24
8f63969c:	e3a03001 	mov	r3, #1
8f6396a0:	e1a02213 	lsl	r2, r3, r2
        state->wnext = 0;
8f6396a4:	e3a03000 	mov	r3, #0
        state->wsize = 1U << state->wbits;
8f6396a8:	e5852028 	str	r2, [r5, #40]	; 0x28
        state->wnext = 0;
8f6396ac:	e5853030 	str	r3, [r5, #48]	; 0x30
        state->whave = 0;
8f6396b0:	e585302c 	str	r3, [r5, #44]	; 0x2c
    }

    /* copy state->wsize or less output bytes into the circular window */
    if (copy >= state->wsize) {
8f6396b4:	e1560002 	cmp	r6, r2
8f6396b8:	2a00001e 	bcs	8f639738 <updatewindow+0xe0>
        zmemcpy(state->window, end - state->wsize, state->wsize);
        state->wnext = 0;
        state->whave = state->wsize;
    }
    else {
        dist = state->wsize - state->wnext;
8f6396bc:	e5953030 	ldr	r3, [r5, #48]	; 0x30
        if (dist > copy) dist = copy;
        zmemcpy(state->window + state->wnext, end - copy, dist);
8f6396c0:	e0471006 	sub	r1, r7, r6
        dist = state->wsize - state->wnext;
8f6396c4:	e0424003 	sub	r4, r2, r3
        zmemcpy(state->window + state->wnext, end - copy, dist);
8f6396c8:	e0800003 	add	r0, r0, r3
8f6396cc:	e1560004 	cmp	r6, r4
8f6396d0:	31a04006 	movcc	r4, r6
8f6396d4:	e1a02004 	mov	r2, r4
8f6396d8:	ebffeab6 	bl	8f6341b8 <memcpy>
        copy -= dist;
        if (copy) {
8f6396dc:	e0568004 	subs	r8, r6, r4
8f6396e0:	1a000027 	bne	8f639784 <updatewindow+0x12c>
            zmemcpy(state->window, end - copy, copy);
            state->wnext = copy;
            state->whave = state->wsize;
        }
        else {
            state->wnext += dist;
8f6396e4:	e5953030 	ldr	r3, [r5, #48]	; 0x30
            if (state->wnext == state->wsize) state->wnext = 0;
8f6396e8:	e5952028 	ldr	r2, [r5, #40]	; 0x28
            state->wnext += dist;
8f6396ec:	e0843003 	add	r3, r4, r3
            if (state->wnext == state->wsize) state->wnext = 0;
8f6396f0:	e1530002 	cmp	r3, r2
8f6396f4:	11a01003 	movne	r1, r3
            if (state->whave < state->wsize) state->whave += dist;
8f6396f8:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
            if (state->wnext == state->wsize) state->wnext = 0;
8f6396fc:	01a01008 	moveq	r1, r8
8f639700:	e5851030 	str	r1, [r5, #48]	; 0x30
            if (state->whave < state->wsize) state->whave += dist;
8f639704:	e1520003 	cmp	r2, r3
8f639708:	80833004 	addhi	r3, r3, r4
8f63970c:	8585302c 	strhi	r3, [r5, #44]	; 0x2c
        }
    }
    return 0;
8f639710:	81a00008 	movhi	r0, r8
8f639714:	91a00008 	movls	r0, r8
}
8f639718:	e59f3090 	ldr	r3, [pc, #144]	; 8f6397b0 <updatewindow+0x158>
8f63971c:	e5932000 	ldr	r2, [r3]
8f639720:	e59d3004 	ldr	r3, [r13, #4]
8f639724:	e0332002 	eors	r2, r3, r2
8f639728:	e3a03000 	mov	r3, #0
8f63972c:	1a00001e 	bne	8f6397ac <updatewindow+0x154>
8f639730:	e28dd008 	add	r13, r13, #8
8f639734:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
        zmemcpy(state->window, end - state->wsize, state->wsize);
8f639738:	e0471002 	sub	r1, r7, r2
8f63973c:	ebffea9d 	bl	8f6341b8 <memcpy>
        state->whave = state->wsize;
8f639740:	e5953028 	ldr	r3, [r5, #40]	; 0x28
        state->wnext = 0;
8f639744:	e3a00000 	mov	r0, #0
8f639748:	e5850030 	str	r0, [r5, #48]	; 0x30
        state->whave = state->wsize;
8f63974c:	e585302c 	str	r3, [r5, #44]	; 0x2c
8f639750:	eafffff0 	b	8f639718 <updatewindow+0xc0>
                        ZALLOC(strm, 1U << state->wbits,
8f639754:	e5951024 	ldr	r1, [r5, #36]	; 0x24
8f639758:	e3a04001 	mov	r4, #1
8f63975c:	e5938020 	ldr	r8, [r3, #32]
8f639760:	e1a02004 	mov	r2, r4
8f639764:	e5930028 	ldr	r0, [r3, #40]	; 0x28
8f639768:	e1a01114 	lsl	r1, r4, r1
8f63976c:	e12fff38 	blx	r8
        if (state->window == Z_NULL) return 1;
8f639770:	e3500000 	cmp	r0, #0
        state->window = (unsigned char FAR *)
8f639774:	e5850034 	str	r0, [r5, #52]	; 0x34
        if (state->window == Z_NULL) return 1;
8f639778:	01a00004 	moveq	r0, r4
8f63977c:	1affffc2 	bne	8f63968c <updatewindow+0x34>
8f639780:	eaffffe4 	b	8f639718 <updatewindow+0xc0>
            zmemcpy(state->window, end - copy, copy);
8f639784:	e0444006 	sub	r4, r4, r6
8f639788:	e5950034 	ldr	r0, [r5, #52]	; 0x34
8f63978c:	e0871004 	add	r1, r7, r4
8f639790:	e1a02008 	mov	r2, r8
8f639794:	ebffea87 	bl	8f6341b8 <memcpy>
            state->whave = state->wsize;
8f639798:	e5953028 	ldr	r3, [r5, #40]	; 0x28
    return 0;
8f63979c:	e3a00000 	mov	r0, #0
            state->wnext = copy;
8f6397a0:	e5858030 	str	r8, [r5, #48]	; 0x30
            state->whave = state->wsize;
8f6397a4:	e585302c 	str	r3, [r5, #44]	; 0x2c
8f6397a8:	eaffffda 	b	8f639718 <updatewindow+0xc0>
}
8f6397ac:	ebffe503 	bl	8f632bc0 <__stack_chk_fail>
8f6397b0:	8f74221c 	.word	0x8f74221c

8f6397b4 <inflateResetKeep>:
{
8f6397b4:	e59f30bc 	ldr	r3, [pc, #188]	; 8f639878 <inflateResetKeep+0xc4>
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
8f6397b8:	e3500000 	cmp	r0, #0
{
8f6397bc:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f6397c0:	e24dd00c 	sub	r13, r13, #12
8f6397c4:	e5933000 	ldr	r3, [r3]
8f6397c8:	e58d3004 	str	r3, [r13, #4]
8f6397cc:	e3a03000 	mov	r3, #0
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
8f6397d0:	0a000025 	beq	8f63986c <inflateResetKeep+0xb8>
8f6397d4:	e590301c 	ldr	r3, [r0, #28]
8f6397d8:	e3530000 	cmp	r3, #0
8f6397dc:	0a000022 	beq	8f63986c <inflateResetKeep+0xb8>
    if (state->wrap)        /* to support ill-conceived Java test suite */
8f6397e0:	e5931008 	ldr	r1, [r3, #8]
    strm->total_in = strm->total_out = state->total = 0;
8f6397e4:	e3a02000 	mov	r2, #0
8f6397e8:	e583201c 	str	r2, [r3, #28]
    state->dmax = 32768U;
8f6397ec:	e3a0c902 	mov	r12, #32768	; 0x8000
    if (state->wrap)        /* to support ill-conceived Java test suite */
8f6397f0:	e1510002 	cmp	r1, r2
    strm->total_in = strm->total_out = state->total = 0;
8f6397f4:	e5802014 	str	r2, [r0, #20]
        strm->adler = state->wrap & 1;
8f6397f8:	12011001 	andne	r1, r1, #1
8f6397fc:	15801030 	strne	r1, [r0, #48]	; 0x30
    state->sane = 1;
8f639800:	e2831a01 	add	r1, r3, #4096	; 0x1000
    strm->total_in = strm->total_out = state->total = 0;
8f639804:	e5802008 	str	r2, [r0, #8]
    strm->msg = Z_NULL;
8f639808:	e5802018 	str	r2, [r0, #24]
    state->mode = HEAD;
8f63980c:	e3a00000 	mov	r0, #0
    state->lencode = state->distcode = state->next = state->codes;
8f639810:	e2832e53 	add	r2, r3, #1328	; 0x530
    state->mode = HEAD;
8f639814:	e5c30000 	strb	r0, [r3]
    state->lencode = state->distcode = state->next = state->codes;
8f639818:	e583206c 	str	r2, [r3, #108]	; 0x6c
8f63981c:	e5832050 	str	r2, [r3, #80]	; 0x50
8f639820:	e583204c 	str	r2, [r3, #76]	; 0x4c
    state->sane = 1;
8f639824:	e3a02001 	mov	r2, #1
    state->last = 0;
8f639828:	e5830004 	str	r0, [r3, #4]
    state->havedict = 0;
8f63982c:	e583000c 	str	r0, [r3, #12]
    state->head = Z_NULL;
8f639830:	e5830020 	str	r0, [r3, #32]
    state->hold = 0;
8f639834:	e5830038 	str	r0, [r3, #56]	; 0x38
    state->bits = 0;
8f639838:	e583003c 	str	r0, [r3, #60]	; 0x3c
    state->dmax = 32768U;
8f63983c:	e583c014 	str	r12, [r3, #20]
    state->back = -1;
8f639840:	e3e03000 	mvn	r3, #0
    state->sane = 1;
8f639844:	e5812bc0 	str	r2, [r1, #3008]	; 0xbc0
    state->back = -1;
8f639848:	e5813bc4 	str	r3, [r1, #3012]	; 0xbc4
}
8f63984c:	e59f3024 	ldr	r3, [pc, #36]	; 8f639878 <inflateResetKeep+0xc4>
8f639850:	e5932000 	ldr	r2, [r3]
8f639854:	e59d3004 	ldr	r3, [r13, #4]
8f639858:	e0332002 	eors	r2, r3, r2
8f63985c:	e3a03000 	mov	r3, #0
8f639860:	1a000003 	bne	8f639874 <inflateResetKeep+0xc0>
8f639864:	e28dd00c 	add	r13, r13, #12
8f639868:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
8f63986c:	e3e00001 	mvn	r0, #1
8f639870:	eafffff5 	b	8f63984c <inflateResetKeep+0x98>
}
8f639874:	ebffe4d1 	bl	8f632bc0 <__stack_chk_fail>
8f639878:	8f74221c 	.word	0x8f74221c

8f63987c <inflateReset2>:
{
8f63987c:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
8f639880:	e2505000 	subs	r5, r0, #0
{
8f639884:	e59f30f4 	ldr	r3, [pc, #244]	; 8f639980 <inflateReset2+0x104>
8f639888:	e24dd008 	sub	r13, r13, #8
8f63988c:	e5933000 	ldr	r3, [r3]
8f639890:	e58d3004 	str	r3, [r13, #4]
8f639894:	e3a03000 	mov	r3, #0
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
8f639898:	0a00001d 	beq	8f639914 <inflateReset2+0x98>
8f63989c:	e595601c 	ldr	r6, [r5, #28]
8f6398a0:	e3560000 	cmp	r6, #0
8f6398a4:	0a00001a 	beq	8f639914 <inflateReset2+0x98>
    if (windowBits < 0) {
8f6398a8:	e3510000 	cmp	r1, #0
8f6398ac:	e1a04001 	mov	r4, r1
        windowBits = -windowBits;
8f6398b0:	b2614000 	rsblt	r4, r1, #0
        wrap = (windowBits >> 4) + 1;
8f6398b4:	a1a08244 	asrge	r8, r4, #4
    if (windowBits && (windowBits < 8 || windowBits > 15))
8f6398b8:	e2443008 	sub	r3, r4, #8
        wrap = (windowBits >> 4) + 1;
8f6398bc:	a2888001 	addge	r8, r8, #1
        wrap = 0;
8f6398c0:	b3a08000 	movlt	r8, #0
    if (windowBits && (windowBits < 8 || windowBits > 15))
8f6398c4:	e3540000 	cmp	r4, #0
8f6398c8:	13530007 	cmpne	r3, #7
8f6398cc:	83a07001 	movhi	r7, #1
8f6398d0:	93a07000 	movls	r7, #0
8f6398d4:	8a00000e 	bhi	8f639914 <inflateReset2+0x98>
    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
8f6398d8:	e5961034 	ldr	r1, [r6, #52]	; 0x34
8f6398dc:	e3510000 	cmp	r1, #0
8f6398e0:	0a000014 	beq	8f639938 <inflateReset2+0xbc>
8f6398e4:	e5963024 	ldr	r3, [r6, #36]	; 0x24
8f6398e8:	e1540003 	cmp	r4, r3
8f6398ec:	0a000011 	beq	8f639938 <inflateReset2+0xbc>
        ZFREE(strm, state->window);
8f6398f0:	e5953024 	ldr	r3, [r5, #36]	; 0x24
8f6398f4:	e5950028 	ldr	r0, [r5, #40]	; 0x28
8f6398f8:	e12fff33 	blx	r3
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
8f6398fc:	e595301c 	ldr	r3, [r5, #28]
        state->window = Z_NULL;
8f639900:	e5867034 	str	r7, [r6, #52]	; 0x34
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
8f639904:	e3530000 	cmp	r3, #0
    state->wrap = wrap;
8f639908:	e5868008 	str	r8, [r6, #8]
    state->wbits = (unsigned)windowBits;
8f63990c:	e5864024 	str	r4, [r6, #36]	; 0x24
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
8f639910:	1a00000b 	bne	8f639944 <inflateReset2+0xc8>
}
8f639914:	e59f3064 	ldr	r3, [pc, #100]	; 8f639980 <inflateReset2+0x104>
8f639918:	e5932000 	ldr	r2, [r3]
8f63991c:	e59d3004 	ldr	r3, [r13, #4]
8f639920:	e0332002 	eors	r2, r3, r2
8f639924:	e3a03000 	mov	r3, #0
8f639928:	1a000013 	bne	8f63997c <inflateReset2+0x100>
8f63992c:	e3e00001 	mvn	r0, #1
8f639930:	e28dd008 	add	r13, r13, #8
8f639934:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
    state->wbits = (unsigned)windowBits;
8f639938:	e1a03006 	mov	r3, r6
    state->wrap = wrap;
8f63993c:	e5868008 	str	r8, [r6, #8]
    state->wbits = (unsigned)windowBits;
8f639940:	e5864024 	str	r4, [r6, #36]	; 0x24
    state->wsize = 0;
8f639944:	e3a02000 	mov	r2, #0
8f639948:	e5832028 	str	r2, [r3, #40]	; 0x28
    state->whave = 0;
8f63994c:	e583202c 	str	r2, [r3, #44]	; 0x2c
    state->wnext = 0;
8f639950:	e5832030 	str	r2, [r3, #48]	; 0x30
    return inflateResetKeep(strm);
8f639954:	e59f3024 	ldr	r3, [pc, #36]	; 8f639980 <inflateReset2+0x104>
8f639958:	e5932000 	ldr	r2, [r3]
8f63995c:	e59d3004 	ldr	r3, [r13, #4]
8f639960:	e0332002 	eors	r2, r3, r2
8f639964:	e3a03000 	mov	r3, #0
8f639968:	1a000003 	bne	8f63997c <inflateReset2+0x100>
8f63996c:	e1a00005 	mov	r0, r5
}
8f639970:	e28dd008 	add	r13, r13, #8
8f639974:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, r14}
    return inflateResetKeep(strm);
8f639978:	eaffff8d 	b	8f6397b4 <inflateResetKeep>
}
8f63997c:	ebffe48f 	bl	8f632bc0 <__stack_chk_fail>
8f639980:	8f74221c 	.word	0x8f74221c

8f639984 <inflateInit2_>:
{
8f639984:	e92d40f0 	push	{r4, r5, r6, r7, r14}
    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
8f639988:	e3520000 	cmp	r2, #0
{
8f63998c:	e1a06001 	mov	r6, r1
8f639990:	e59f10fc 	ldr	r1, [pc, #252]	; 8f639a94 <inflateInit2_+0x110>
8f639994:	e24dd00c 	sub	r13, r13, #12
8f639998:	e5911000 	ldr	r1, [r1]
8f63999c:	e58d1004 	str	r1, [r13, #4]
8f6399a0:	e3a01000 	mov	r1, #0
    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
8f6399a4:	0a000033 	beq	8f639a78 <inflateInit2_+0xf4>
8f6399a8:	e5d22000 	ldrb	r2, [r2]
8f6399ac:	e3530038 	cmp	r3, #56	; 0x38
8f6399b0:	03520031 	cmpeq	r2, #49	; 0x31
8f6399b4:	13a03001 	movne	r3, #1
8f6399b8:	03a03000 	moveq	r3, #0
8f6399bc:	1a00002d 	bne	8f639a78 <inflateInit2_+0xf4>
    if (strm == Z_NULL) return Z_STREAM_ERROR;
8f6399c0:	e3500000 	cmp	r0, #0
8f6399c4:	e1a04000 	mov	r4, r0
8f6399c8:	0a00002e 	beq	8f639a88 <inflateInit2_+0x104>
    if (strm->zalloc == (alloc_func)0) {
8f6399cc:	e5905020 	ldr	r5, [r0, #32]
            ZALLOC(strm, 1, sizeof(struct inflate_state));
8f6399d0:	e3012bcc 	movw	r2, #7116	; 0x1bcc
    strm->msg = Z_NULL;                 /* in case we return an error */
8f6399d4:	e5803018 	str	r3, [r0, #24]
            ZALLOC(strm, 1, sizeof(struct inflate_state));
8f6399d8:	e3a01001 	mov	r1, #1
    if (strm->zalloc == (alloc_func)0) {
8f6399dc:	e3550000 	cmp	r5, #0
        strm->opaque = (voidpf)0;
8f6399e0:	05845028 	streq	r5, [r4, #40]	; 0x28
        strm->zalloc = zcalloc;
8f6399e4:	03083cfc 	movweq	r3, #36092	; 0x8cfc
8f6399e8:	03483f63 	movteq	r3, #36707	; 0x8f63
        strm->opaque = (voidpf)0;
8f6399ec:	01a00005 	moveq	r0, r5
        strm->zalloc = zcalloc;
8f6399f0:	05843020 	streq	r3, [r4, #32]
        strm->opaque = (voidpf)0;
8f6399f4:	01a05003 	moveq	r5, r3
    if (strm->zfree == (free_func)0)
8f6399f8:	e5943024 	ldr	r3, [r4, #36]	; 0x24
            ZALLOC(strm, 1, sizeof(struct inflate_state));
8f6399fc:	15900028 	ldrne	r0, [r0, #40]	; 0x28
    if (strm->zfree == (free_func)0)
8f639a00:	e3530000 	cmp	r3, #0
        strm->zfree = zcfree;
8f639a04:	03083d44 	movweq	r3, #36164	; 0x8d44
8f639a08:	03483f63 	movteq	r3, #36707	; 0x8f63
8f639a0c:	05843024 	streq	r3, [r4, #36]	; 0x24
            ZALLOC(strm, 1, sizeof(struct inflate_state));
8f639a10:	e12fff35 	blx	r5
    if (state == Z_NULL) return Z_MEM_ERROR;
8f639a14:	e2505000 	subs	r5, r0, #0
8f639a18:	0a000018 	beq	8f639a80 <inflateInit2_+0xfc>
    ret = inflateReset2(strm, windowBits);
8f639a1c:	e1a01006 	mov	r1, r6
    strm->state = (struct internal_state FAR *)state;
8f639a20:	e584501c 	str	r5, [r4, #28]
    state->window = Z_NULL;
8f639a24:	e3a07000 	mov	r7, #0
    ret = inflateReset2(strm, windowBits);
8f639a28:	e1a00004 	mov	r0, r4
    state->window = Z_NULL;
8f639a2c:	e5857034 	str	r7, [r5, #52]	; 0x34
    ret = inflateReset2(strm, windowBits);
8f639a30:	ebffff91 	bl	8f63987c <inflateReset2>
    if (ret != Z_OK) {
8f639a34:	e2506000 	subs	r6, r0, #0
8f639a38:	1a000008 	bne	8f639a60 <inflateInit2_+0xdc>
}
8f639a3c:	e59f3050 	ldr	r3, [pc, #80]	; 8f639a94 <inflateInit2_+0x110>
8f639a40:	e5932000 	ldr	r2, [r3]
8f639a44:	e59d3004 	ldr	r3, [r13, #4]
8f639a48:	e0332002 	eors	r2, r3, r2
8f639a4c:	e3a03000 	mov	r3, #0
8f639a50:	1a00000e 	bne	8f639a90 <inflateInit2_+0x10c>
8f639a54:	e1a00006 	mov	r0, r6
8f639a58:	e28dd00c 	add	r13, r13, #12
8f639a5c:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
        ZFREE(strm, state);
8f639a60:	e5943024 	ldr	r3, [r4, #36]	; 0x24
8f639a64:	e1a01005 	mov	r1, r5
8f639a68:	e5940028 	ldr	r0, [r4, #40]	; 0x28
8f639a6c:	e12fff33 	blx	r3
        strm->state = Z_NULL;
8f639a70:	e584701c 	str	r7, [r4, #28]
8f639a74:	eafffff0 	b	8f639a3c <inflateInit2_+0xb8>
        return Z_VERSION_ERROR;
8f639a78:	e3e06005 	mvn	r6, #5
8f639a7c:	eaffffee 	b	8f639a3c <inflateInit2_+0xb8>
    if (state == Z_NULL) return Z_MEM_ERROR;
8f639a80:	e3e06003 	mvn	r6, #3
8f639a84:	eaffffec 	b	8f639a3c <inflateInit2_+0xb8>
    if (strm == Z_NULL) return Z_STREAM_ERROR;
8f639a88:	e3e06001 	mvn	r6, #1
8f639a8c:	eaffffea 	b	8f639a3c <inflateInit2_+0xb8>
}
8f639a90:	ebffe44a 	bl	8f632bc0 <__stack_chk_fail>
8f639a94:	8f74221c 	.word	0x8f74221c

8f639a98 <inflate>:
 */

int ZEXPORT inflate(strm, flush)
z_streamp strm;
int flush;
{
8f639a98:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
8f639a9c:	e2509000 	subs	r9, r0, #0
{
8f639aa0:	e24dd03c 	sub	r13, r13, #60	; 0x3c
8f639aa4:	e59f3fec 	ldr	r3, [pc, #4076]	; 8f63aa98 <inflate+0x1000>
8f639aa8:	e5933000 	ldr	r3, [r3]
8f639aac:	e58d3034 	str	r3, [r13, #52]	; 0x34
8f639ab0:	e3a03000 	mov	r3, #0
8f639ab4:	e58d101c 	str	r1, [r13, #28]
    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
8f639ab8:	0a00009d 	beq	8f639d34 <inflate+0x29c>
8f639abc:	e599b01c 	ldr	r11, [r9, #28]
8f639ac0:	e35b0000 	cmp	r11, #0
8f639ac4:	0a00009a 	beq	8f639d34 <inflate+0x29c>
8f639ac8:	e599300c 	ldr	r3, [r9, #12]
8f639acc:	e3530000 	cmp	r3, #0
8f639ad0:	e58d3010 	str	r3, [r13, #16]
8f639ad4:	0a000096 	beq	8f639d34 <inflate+0x29c>
        (strm->next_in == Z_NULL && strm->avail_in != 0))
8f639ad8:	e5998000 	ldr	r8, [r9]
8f639adc:	e5993004 	ldr	r3, [r9, #4]
    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
8f639ae0:	e3580000 	cmp	r8, #0
        (strm->next_in == Z_NULL && strm->avail_in != 0))
8f639ae4:	e58d3018 	str	r3, [r13, #24]
    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
8f639ae8:	0a00008f 	beq	8f639d2c <inflate+0x294>
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
8f639aec:	e5db3000 	ldrb	r3, [r11]
8f639af0:	e30b1ee0 	movw	r1, #48864	; 0xbee0
    LOAD();
8f639af4:	e59b6038 	ldr	r6, [r11, #56]	; 0x38
8f639af8:	e3481f70 	movt	r1, #36720	; 0x8f70
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
8f639afc:	e353000b 	cmp	r3, #11
    LOAD();
8f639b00:	e59b403c 	ldr	r4, [r11, #60]	; 0x3c
8f639b04:	e59d5018 	ldr	r5, [r13, #24]
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
8f639b08:	03a0300c 	moveq	r3, #12
8f639b0c:	05cb3000 	strbeq	r3, [r11]
    LOAD();
8f639b10:	e5992010 	ldr	r2, [r9, #16]
8f639b14:	e58d1020 	str	r1, [r13, #32]
                state->head->done = -1;
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
#else
            if (
#endif
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
8f639b18:	e3011085 	movw	r1, #4229	; 0x1085
8f639b1c:	e3401842 	movt	r1, #2114	; 0x842
8f639b20:	e58d1024 	str	r1, [r13, #36]	; 0x24
    LOAD();
8f639b24:	e58d2014 	str	r2, [r13, #20]
8f639b28:	e58d200c 	str	r2, [r13, #12]
        switch (state->mode) {
8f639b2c:	e353001e 	cmp	r3, #30
8f639b30:	979ff103 	ldrls	r15, [r15, r3, lsl #2]
8f639b34:	ea00007e 	b	8f639d34 <inflate+0x29c>
8f639b38:	8f63a424 	.word	0x8f63a424
8f639b3c:	8f639d34 	.word	0x8f639d34
8f639b40:	8f639d34 	.word	0x8f639d34
8f639b44:	8f639d34 	.word	0x8f639d34
8f639b48:	8f639d34 	.word	0x8f639d34
8f639b4c:	8f639d34 	.word	0x8f639d34
8f639b50:	8f639d34 	.word	0x8f639d34
8f639b54:	8f639d34 	.word	0x8f639d34
8f639b58:	8f639d34 	.word	0x8f639d34
8f639b5c:	8f639c68 	.word	0x8f639c68
8f639b60:	8f639ca8 	.word	0x8f639ca8
8f639b64:	8f639cd4 	.word	0x8f639cd4
8f639b68:	8f639ce4 	.word	0x8f639ce4
8f639b6c:	8f639ec4 	.word	0x8f639ec4
8f639b70:	8f63a3a8 	.word	0x8f63a3a8
8f639b74:	8f63a41c 	.word	0x8f63a41c
8f639b78:	8f639bcc 	.word	0x8f639bcc
8f639b7c:	8f63a20c 	.word	0x8f63a20c
8f639b80:	8f63a2f0 	.word	0x8f63a2f0
8f639b84:	8f63a090 	.word	0x8f63a090
8f639b88:	8f63a098 	.word	0x8f63a098
8f639b8c:	8f63a118 	.word	0x8f63a118
8f639b90:	8f63a138 	.word	0x8f63a138
8f639b94:	8f639df8 	.word	0x8f639df8
8f639b98:	8f639e0c 	.word	0x8f639e0c
8f639b9c:	8f63a5c0 	.word	0x8f63a5c0
8f639ba0:	8f639d04 	.word	0x8f639d04
8f639ba4:	8f639d34 	.word	0x8f639d34
8f639ba8:	8f639d18 	.word	0x8f639d18
8f639bac:	8f639c30 	.word	0x8f639c30
8f639bb0:	8f63a4e4 	.word	0x8f63a4e4
            }
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
8f639bb4:	e3550000 	cmp	r5, #0
8f639bb8:	0a0000cf 	beq	8f639efc <inflate+0x464>
8f639bbc:	e4d83001 	ldrb	r3, [r8], #1
8f639bc0:	e2455001 	sub	r5, r5, #1
8f639bc4:	e0866413 	add	r6, r6, r3, lsl r4
8f639bc8:	e2844008 	add	r4, r4, #8
8f639bcc:	e354000d 	cmp	r4, #13
8f639bd0:	9afffff7 	bls	8f639bb4 <inflate+0x11c>
            state->nlen = BITS(5) + 257;
8f639bd4:	e206201f 	and	r2, r6, #31
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
8f639bd8:	e7e432d6 	ubfx	r3, r6, #5, #5
            state->nlen = BITS(5) + 257;
8f639bdc:	e2822c01 	add	r2, r2, #256	; 0x100
            state->ndist = BITS(5) + 1;
8f639be0:	e2833001 	add	r3, r3, #1
            state->nlen = BITS(5) + 257;
8f639be4:	e2822001 	add	r2, r2, #1
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
8f639be8:	e300111e 	movw	r1, #286	; 0x11e
8f639bec:	e353001e 	cmp	r3, #30
8f639bf0:	91520001 	cmpls	r2, r1
            state->ncode = BITS(4) + 4;
8f639bf4:	e7e31556 	ubfx	r1, r6, #10, #4
            state->nlen = BITS(5) + 257;
8f639bf8:	e58b2060 	str	r2, [r11, #96]	; 0x60
            state->ncode = BITS(4) + 4;
8f639bfc:	e2811004 	add	r1, r1, #4
            DROPBITS(4);
8f639c00:	e244400e 	sub	r4, r4, #14
            state->ncode = BITS(4) + 4;
8f639c04:	e1a06726 	lsr	r6, r6, #14
            if (state->nlen > 286 || state->ndist > 30) {
8f639c08:	83a02001 	movhi	r2, #1
8f639c0c:	93a02000 	movls	r2, #0
            state->ndist = BITS(5) + 1;
8f639c10:	e58b3064 	str	r3, [r11, #100]	; 0x64
            state->ncode = BITS(4) + 4;
8f639c14:	e58b105c 	str	r1, [r11, #92]	; 0x5c
            if (state->nlen > 286 || state->ndist > 30) {
8f639c18:	9a000331 	bls	8f63a8e4 <inflate+0xe4c>
                strm->msg = (char *)"too many length or distance symbols";
8f639c1c:	e30b353c 	movw	r3, #46396	; 0xb53c
8f639c20:	e3483f70 	movt	r3, #36720	; 0x8f70
                state->back += last.bits;
            }
            DROPBITS(here.bits);
            state->back += here.bits;
            if (here.op & 64) {
                strm->msg = (char *)"invalid distance code";
8f639c24:	e5893018 	str	r3, [r9, #24]
                state->mode = BAD;
8f639c28:	e3a0301d 	mov	r3, #29
8f639c2c:	e5cb3000 	strb	r3, [r11]
        switch (state->mode) {
8f639c30:	e59d3014 	ldr	r3, [r13, #20]
8f639c34:	e59d200c 	ldr	r2, [r13, #12]
8f639c38:	e0431002 	sub	r1, r3, r2
8f639c3c:	ea000088 	b	8f639e64 <inflate+0x3cc>
            INITBITS();
8f639c40:	e3a06000 	mov	r6, #0
            state->mode = hold & 0x200 ? DICTID : TYPE;
8f639c44:	e3a03009 	mov	r3, #9
            INITBITS();
8f639c48:	e1a04006 	mov	r4, r6
            state->mode = hold & 0x200 ? DICTID : TYPE;
8f639c4c:	e5cb3000 	strb	r3, [r11]
            NEEDBITS(32);
8f639c50:	e3550000 	cmp	r5, #0
8f639c54:	0a0000a8 	beq	8f639efc <inflate+0x464>
8f639c58:	e4d83001 	ldrb	r3, [r8], #1
8f639c5c:	e2455001 	sub	r5, r5, #1
8f639c60:	e0866413 	add	r6, r6, r3, lsl r4
8f639c64:	e2844008 	add	r4, r4, #8
8f639c68:	e354001f 	cmp	r4, #31
8f639c6c:	9afffff7 	bls	8f639c50 <inflate+0x1b8>
            strm->adler = state->check = ZSWAP32(hold);
8f639c70:	e1a03c06 	lsl	r3, r6, #24
8f639c74:	e1a02426 	lsr	r2, r6, #8
8f639c78:	e0833c26 	add	r3, r3, r6, lsr #24
8f639c7c:	e2022cff 	and	r2, r2, #65280	; 0xff00
8f639c80:	e1a06406 	lsl	r6, r6, #8
8f639c84:	e0833002 	add	r3, r3, r2
8f639c88:	e20668ff 	and	r6, r6, #16711680	; 0xff0000
8f639c8c:	e0833006 	add	r3, r3, r6
            INITBITS();
8f639c90:	e3a06000 	mov	r6, #0
8f639c94:	e1a04006 	mov	r4, r6
            strm->adler = state->check = ZSWAP32(hold);
8f639c98:	e58b3018 	str	r3, [r11, #24]
8f639c9c:	e5893030 	str	r3, [r9, #48]	; 0x30
            state->mode = DICT;
8f639ca0:	e3a0300a 	mov	r3, #10
8f639ca4:	e5cb3000 	strb	r3, [r11]
            if (state->havedict == 0) {
8f639ca8:	e59b300c 	ldr	r3, [r11, #12]
8f639cac:	e3530000 	cmp	r3, #0
8f639cb0:	0a00037f 	beq	8f63aab4 <inflate+0x101c>
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
8f639cb4:	e3a02000 	mov	r2, #0
8f639cb8:	e1a01002 	mov	r1, r2
8f639cbc:	e1a00002 	mov	r0, r2
8f639cc0:	ebfffc31 	bl	8f638d8c <adler32>
8f639cc4:	e58b0018 	str	r0, [r11, #24]
8f639cc8:	e5890030 	str	r0, [r9, #48]	; 0x30
            state->mode = TYPE;
8f639ccc:	e3a0300b 	mov	r3, #11
8f639cd0:	e5cb3000 	strb	r3, [r11]
            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
8f639cd4:	e59d301c 	ldr	r3, [r13, #28]
8f639cd8:	e2433005 	sub	r3, r3, #5
8f639cdc:	e3530001 	cmp	r3, #1
8f639ce0:	9a000085 	bls	8f639efc <inflate+0x464>
            if (state->last) {
8f639ce4:	e59b7004 	ldr	r7, [r11, #4]
8f639ce8:	e3570000 	cmp	r7, #0
8f639cec:	0a00005f 	beq	8f639e70 <inflate+0x3d8>
                BYTEBITS();
8f639cf0:	e2043007 	and	r3, r4, #7
8f639cf4:	e3c44007 	bic	r4, r4, #7
8f639cf8:	e1a06336 	lsr	r6, r6, r3
                state->mode = CHECK;
8f639cfc:	e3a0301a 	mov	r3, #26
8f639d00:	e5cb3000 	strb	r3, [r11]
            *put++ = (unsigned char)(state->length);
            left--;
            state->mode = LEN;
            break;
        case CHECK:
            if (state->wrap) {
8f639d04:	e59b3008 	ldr	r3, [r11, #8]
8f639d08:	e3530000 	cmp	r3, #0
8f639d0c:	1a000018 	bne	8f639d74 <inflate+0x2dc>
                }
                INITBITS();
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
8f639d10:	e3a0301c 	mov	r3, #28
8f639d14:	e5cb3000 	strb	r3, [r11]
     */
  inf_leave:
    RESTORE();
    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
            (state->mode < CHECK || flush != Z_FINISH)))
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
8f639d18:	e59d3014 	ldr	r3, [r13, #20]
            ret = Z_STREAM_END;
8f639d1c:	e3a07001 	mov	r7, #1
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
8f639d20:	e59d200c 	ldr	r2, [r13, #12]
8f639d24:	e043a002 	sub	r10, r3, r2
8f639d28:	ea000077 	b	8f639f0c <inflate+0x474>
        (strm->next_in == Z_NULL && strm->avail_in != 0))
8f639d2c:	e3530000 	cmp	r3, #0
8f639d30:	0affff6d 	beq	8f639aec <inflate+0x54>
        return Z_STREAM_ERROR;
8f639d34:	e3e07001 	mvn	r7, #1
                      (state->mode == TYPE ? 128 : 0) +
                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
        ret = Z_BUF_ERROR;
    return ret;
}
8f639d38:	e59f3d58 	ldr	r3, [pc, #3416]	; 8f63aa98 <inflate+0x1000>
8f639d3c:	e5932000 	ldr	r2, [r3]
8f639d40:	e59d3034 	ldr	r3, [r13, #52]	; 0x34
8f639d44:	e0332002 	eors	r2, r3, r2
8f639d48:	e3a03000 	mov	r3, #0
8f639d4c:	1a000396 	bne	8f63abac <inflate+0x1114>
8f639d50:	e1a00007 	mov	r0, r7
8f639d54:	e28dd03c 	add	r13, r13, #60	; 0x3c
8f639d58:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
                NEEDBITS(32);
8f639d5c:	e3550000 	cmp	r5, #0
8f639d60:	0a000065 	beq	8f639efc <inflate+0x464>
8f639d64:	e4d83001 	ldrb	r3, [r8], #1
8f639d68:	e2455001 	sub	r5, r5, #1
8f639d6c:	e0866413 	add	r6, r6, r3, lsl r4
8f639d70:	e2844008 	add	r4, r4, #8
8f639d74:	e354001f 	cmp	r4, #31
8f639d78:	9afffff7 	bls	8f639d5c <inflate+0x2c4>
                out -= left;
8f639d7c:	e59d3014 	ldr	r3, [r13, #20]
8f639d80:	e59d200c 	ldr	r2, [r13, #12]
8f639d84:	e0432002 	sub	r2, r3, r2
                strm->total_out += out;
8f639d88:	e5993014 	ldr	r3, [r9, #20]
                if (out)
8f639d8c:	e3520000 	cmp	r2, #0
                strm->total_out += out;
8f639d90:	e0833002 	add	r3, r3, r2
8f639d94:	e5893014 	str	r3, [r9, #20]
                state->total += out;
8f639d98:	e59b301c 	ldr	r3, [r11, #28]
8f639d9c:	e0833002 	add	r3, r3, r2
8f639da0:	e58b301c 	str	r3, [r11, #28]
                if (out)
8f639da4:	1a000282 	bne	8f63a7b4 <inflate+0xd1c>
                     ZSWAP32(hold)) != state->check) {
8f639da8:	e59b0018 	ldr	r0, [r11, #24]
8f639dac:	e1a03c06 	lsl	r3, r6, #24
8f639db0:	e1a02426 	lsr	r2, r6, #8
8f639db4:	e2022cff 	and	r2, r2, #65280	; 0xff00
8f639db8:	e0833c26 	add	r3, r3, r6, lsr #24
8f639dbc:	e0833002 	add	r3, r3, r2
8f639dc0:	e1a02406 	lsl	r2, r6, #8
8f639dc4:	e20228ff 	and	r2, r2, #16711680	; 0xff0000
8f639dc8:	e0833002 	add	r3, r3, r2
                if ((
8f639dcc:	e1530000 	cmp	r3, r0
8f639dd0:	0a000370 	beq	8f63ab98 <inflate+0x1100>
                    strm->msg = (char *)"incorrect data check";
8f639dd4:	e30b3648 	movw	r3, #46664	; 0xb648
8f639dd8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f639ddc:	e5893018 	str	r3, [r9, #24]
                    state->mode = BAD;
8f639de0:	e3a0301d 	mov	r3, #29
8f639de4:	e5cb3000 	strb	r3, [r11]
        switch (state->mode) {
8f639de8:	e3a01000 	mov	r1, #0
                    state->mode = BAD;
8f639dec:	e59d300c 	ldr	r3, [r13, #12]
8f639df0:	e58d3014 	str	r3, [r13, #20]
8f639df4:	ea00001a 	b	8f639e64 <inflate+0x3cc>
            if (state->extra) {
8f639df8:	e59b1048 	ldr	r1, [r11, #72]	; 0x48
8f639dfc:	e3510000 	cmp	r1, #0
8f639e00:	1a0000f3 	bne	8f63a1d4 <inflate+0x73c>
            state->mode = MATCH;
8f639e04:	e3a03018 	mov	r3, #24
8f639e08:	e5cb3000 	strb	r3, [r11]
            if (left == 0) goto inf_leave;
8f639e0c:	e59d200c 	ldr	r2, [r13, #12]
8f639e10:	e3520000 	cmp	r2, #0
8f639e14:	0a0002d2 	beq	8f63a964 <inflate+0xecc>
            copy = out - left;
8f639e18:	e59d0014 	ldr	r0, [r13, #20]
            if (state->offset > copy) {         /* copy from window */
8f639e1c:	e59b3044 	ldr	r3, [r11, #68]	; 0x44
            copy = out - left;
8f639e20:	e0401002 	sub	r1, r0, r2
            if (state->offset > copy) {         /* copy from window */
8f639e24:	e1530001 	cmp	r3, r1
8f639e28:	9a00007f 	bls	8f63a02c <inflate+0x594>
                copy = state->offset - copy;
8f639e2c:	e0833002 	add	r3, r3, r2
                if (copy > state->whave) {
8f639e30:	e59b202c 	ldr	r2, [r11, #44]	; 0x2c
                copy = state->offset - copy;
8f639e34:	e0430000 	sub	r0, r3, r0
                if (copy > state->whave) {
8f639e38:	e1520000 	cmp	r2, r0
8f639e3c:	2a0001d1 	bcs	8f63a588 <inflate+0xaf0>
                    if (state->sane) {
8f639e40:	e28bca01 	add	r12, r11, #4096	; 0x1000
8f639e44:	e59c2bc0 	ldr	r2, [r12, #3008]	; 0xbc0
8f639e48:	e3520000 	cmp	r2, #0
8f639e4c:	0a0001cd 	beq	8f63a588 <inflate+0xaf0>
                        strm->msg = (char *)"invalid distance too far back";
8f639e50:	e30b3628 	movw	r3, #46632	; 0xb628
8f639e54:	e3483f70 	movt	r3, #36720	; 0x8f70
8f639e58:	e5893018 	str	r3, [r9, #24]
                        state->mode = BAD;
8f639e5c:	e3a0301d 	mov	r3, #29
8f639e60:	e5cb3000 	strb	r3, [r11]
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
8f639e64:	e1a0a001 	mov	r10, r1
            ret = Z_DATA_ERROR;
8f639e68:	e3e07002 	mvn	r7, #2
8f639e6c:	ea000026 	b	8f639f0c <inflate+0x474>
            NEEDBITS(3);
8f639e70:	e3540002 	cmp	r4, #2
8f639e74:	8a000005 	bhi	8f639e90 <inflate+0x3f8>
8f639e78:	e3550000 	cmp	r5, #0
8f639e7c:	0a0002a1 	beq	8f63a908 <inflate+0xe70>
8f639e80:	e4d83001 	ldrb	r3, [r8], #1
8f639e84:	e2455001 	sub	r5, r5, #1
8f639e88:	e0866413 	add	r6, r6, r3, lsl r4
8f639e8c:	e2844008 	add	r4, r4, #8
            switch (BITS(2)) {
8f639e90:	e7e130d6 	ubfx	r3, r6, #1, #2
            state->last = BITS(1);
8f639e94:	e2062001 	and	r2, r6, #1
8f639e98:	e3530002 	cmp	r3, #2
8f639e9c:	e58b2004 	str	r2, [r11, #4]
            switch (BITS(2)) {
8f639ea0:	0a0001eb 	beq	8f63a654 <inflate+0xbbc>
8f639ea4:	e3530003 	cmp	r3, #3
8f639ea8:	0a00025d 	beq	8f63a824 <inflate+0xd8c>
8f639eac:	e3530001 	cmp	r3, #1
8f639eb0:	0a000249 	beq	8f63a7dc <inflate+0xd44>
            DROPBITS(2);
8f639eb4:	e1a061a6 	lsr	r6, r6, #3
8f639eb8:	e2444003 	sub	r4, r4, #3
                state->mode = STORED;
8f639ebc:	e3a0300d 	mov	r3, #13
8f639ec0:	e5cb3000 	strb	r3, [r11]
            BYTEBITS();                         /* go to byte boundary */
8f639ec4:	e2043007 	and	r3, r4, #7
8f639ec8:	e3c44007 	bic	r4, r4, #7
            NEEDBITS(32);
8f639ecc:	e354001f 	cmp	r4, #31
            BYTEBITS();                         /* go to byte boundary */
8f639ed0:	e1a06336 	lsr	r6, r6, r3
            NEEDBITS(32);
8f639ed4:	9a000006 	bls	8f639ef4 <inflate+0x45c>
8f639ed8:	ea0001e2 	b	8f63a668 <inflate+0xbd0>
8f639edc:	e4d83001 	ldrb	r3, [r8], #1
8f639ee0:	e2455001 	sub	r5, r5, #1
8f639ee4:	e0866413 	add	r6, r6, r3, lsl r4
8f639ee8:	e2844008 	add	r4, r4, #8
8f639eec:	e354001f 	cmp	r4, #31
8f639ef0:	8a0001dc 	bhi	8f63a668 <inflate+0xbd0>
8f639ef4:	e3550000 	cmp	r5, #0
8f639ef8:	1afffff7 	bne	8f639edc <inflate+0x444>
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
8f639efc:	e59d3014 	ldr	r3, [r13, #20]
8f639f00:	e3a07000 	mov	r7, #0
8f639f04:	e59d200c 	ldr	r2, [r13, #12]
8f639f08:	e043a002 	sub	r10, r3, r2
    RESTORE();
8f639f0c:	e59d3010 	ldr	r3, [r13, #16]
8f639f10:	e59d200c 	ldr	r2, [r13, #12]
8f639f14:	e5898000 	str	r8, [r9]
8f639f18:	e589300c 	str	r3, [r9, #12]
    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
8f639f1c:	e59b3028 	ldr	r3, [r11, #40]	; 0x28
    RESTORE();
8f639f20:	e5892010 	str	r2, [r9, #16]
    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
8f639f24:	e3530000 	cmp	r3, #0
    RESTORE();
8f639f28:	e5895004 	str	r5, [r9, #4]
8f639f2c:	e58b6038 	str	r6, [r11, #56]	; 0x38
8f639f30:	e58b403c 	str	r4, [r11, #60]	; 0x3c
    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
8f639f34:	1a000030 	bne	8f639ffc <inflate+0x564>
8f639f38:	e59d3014 	ldr	r3, [r13, #20]
8f639f3c:	e1530002 	cmp	r3, r2
8f639f40:	0a000002 	beq	8f639f50 <inflate+0x4b8>
8f639f44:	e5db3000 	ldrb	r3, [r11]
8f639f48:	e353001c 	cmp	r3, #28
8f639f4c:	9a000022 	bls	8f639fdc <inflate+0x544>
    in -= strm->avail_in;
8f639f50:	e59d3018 	ldr	r3, [r13, #24]
8f639f54:	e0435005 	sub	r5, r3, r5
    if (state->wrap && out)
8f639f58:	e59b3008 	ldr	r3, [r11, #8]
8f639f5c:	e3530000 	cmp	r3, #0
8f639f60:	135a0000 	cmpne	r10, #0
    strm->total_in += in;
8f639f64:	e5993008 	ldr	r3, [r9, #8]
8f639f68:	e0833005 	add	r3, r3, r5
8f639f6c:	e5893008 	str	r3, [r9, #8]
    strm->total_out += out;
8f639f70:	e5993014 	ldr	r3, [r9, #20]
8f639f74:	e083300a 	add	r3, r3, r10
8f639f78:	e5893014 	str	r3, [r9, #20]
    state->total += out;
8f639f7c:	e59b301c 	ldr	r3, [r11, #28]
8f639f80:	e083300a 	add	r3, r3, r10
8f639f84:	e58b301c 	str	r3, [r11, #28]
    if (state->wrap && out)
8f639f88:	1a000157 	bne	8f63a4ec <inflate+0xa54>
    strm->data_type = state->bits + (state->last ? 64 : 0) +
8f639f8c:	e59b3004 	ldr	r3, [r11, #4]
                      (state->mode == TYPE ? 128 : 0) +
8f639f90:	e5db2000 	ldrb	r2, [r11]
    strm->data_type = state->bits + (state->last ? 64 : 0) +
8f639f94:	e3530000 	cmp	r3, #0
8f639f98:	e59b303c 	ldr	r3, [r11, #60]	; 0x3c
8f639f9c:	12833040 	addne	r3, r3, #64	; 0x40
                      (state->mode == TYPE ? 128 : 0) +
8f639fa0:	e352000b 	cmp	r2, #11
    strm->data_type = state->bits + (state->last ? 64 : 0) +
8f639fa4:	02833080 	addeq	r3, r3, #128	; 0x80
                      (state->mode == TYPE ? 128 : 0) +
8f639fa8:	0a000002 	beq	8f639fb8 <inflate+0x520>
                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
8f639fac:	e352000e 	cmp	r2, #14
8f639fb0:	13520013 	cmpne	r2, #19
                      (state->mode == TYPE ? 128 : 0) +
8f639fb4:	02833c01 	addeq	r3, r3, #256	; 0x100
    strm->data_type = state->bits + (state->last ? 64 : 0) +
8f639fb8:	e589302c 	str	r3, [r9, #44]	; 0x2c
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
8f639fbc:	e185500a 	orr	r5, r5, r10
8f639fc0:	e59d301c 	ldr	r3, [r13, #28]
8f639fc4:	e3550000 	cmp	r5, #0
8f639fc8:	13530004 	cmpne	r3, #4
8f639fcc:	1affff59 	bne	8f639d38 <inflate+0x2a0>
        ret = Z_BUF_ERROR;
8f639fd0:	e3570000 	cmp	r7, #0
8f639fd4:	03e07004 	mvneq	r7, #4
8f639fd8:	eaffff56 	b	8f639d38 <inflate+0x2a0>
    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
8f639fdc:	e3530019 	cmp	r3, #25
            (state->mode < CHECK || flush != Z_FINISH)))
8f639fe0:	e59d201c 	ldr	r2, [r13, #28]
    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
8f639fe4:	83a03000 	movhi	r3, #0
8f639fe8:	93a03001 	movls	r3, #1
            (state->mode < CHECK || flush != Z_FINISH)))
8f639fec:	e3520004 	cmp	r2, #4
8f639ff0:	13833001 	orrne	r3, r3, #1
8f639ff4:	e3530000 	cmp	r3, #0
8f639ff8:	0affffd4 	beq	8f639f50 <inflate+0x4b8>
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
8f639ffc:	e59d1010 	ldr	r1, [r13, #16]
8f63a000:	e1a0200a 	mov	r2, r10
8f63a004:	e1a00009 	mov	r0, r9
8f63a008:	ebfffd92 	bl	8f639658 <updatewindow>
8f63a00c:	e3500000 	cmp	r0, #0
8f63a010:	1a000291 	bne	8f63aa5c <inflate+0xfc4>
    out -= strm->avail_out;
8f63a014:	e5993010 	ldr	r3, [r9, #16]
8f63a018:	e59d2014 	ldr	r2, [r13, #20]
    in -= strm->avail_in;
8f63a01c:	e5995004 	ldr	r5, [r9, #4]
    out -= strm->avail_out;
8f63a020:	e042a003 	sub	r10, r2, r3
8f63a024:	e58d300c 	str	r3, [r13, #12]
8f63a028:	eaffffc8 	b	8f639f50 <inflate+0x4b8>
                copy = state->length;
8f63a02c:	e59b0040 	ldr	r0, [r11, #64]	; 0x40
                from = put - state->offset;
8f63a030:	e59d2010 	ldr	r2, [r13, #16]
8f63a034:	e0423003 	sub	r3, r2, r3
                copy = state->length;
8f63a038:	e1a02000 	mov	r2, r0
            if (copy > left) copy = left;
8f63a03c:	e59d100c 	ldr	r1, [r13, #12]
8f63a040:	e1500001 	cmp	r0, r1
8f63a044:	21a00001 	movcs	r0, r1
            state->length -= copy;
8f63a048:	e0422000 	sub	r2, r2, r0
8f63a04c:	e58b2040 	str	r2, [r11, #64]	; 0x40
8f63a050:	e083c000 	add	r12, r3, r0
8f63a054:	e59d2010 	ldr	r2, [r13, #16]
            left -= copy;
8f63a058:	e0411000 	sub	r1, r1, r0
8f63a05c:	e58d100c 	str	r1, [r13, #12]
            state->length -= copy;
8f63a060:	e2422001 	sub	r2, r2, #1
                *put++ = *from++;
8f63a064:	e4d31001 	ldrb	r1, [r3], #1
            } while (--copy);
8f63a068:	e15c0003 	cmp	r12, r3
                *put++ = *from++;
8f63a06c:	e5e21001 	strb	r1, [r2, #1]!
            } while (--copy);
8f63a070:	1afffffb 	bne	8f63a064 <inflate+0x5cc>
                *put++ = *from++;
8f63a074:	e59d3010 	ldr	r3, [r13, #16]
8f63a078:	e0833000 	add	r3, r3, r0
8f63a07c:	e58d3010 	str	r3, [r13, #16]
            if (state->length == 0) state->mode = LEN;
8f63a080:	e59b3040 	ldr	r3, [r11, #64]	; 0x40
8f63a084:	e3530000 	cmp	r3, #0
        switch (state->mode) {
8f63a088:	15db3000 	ldrbne	r3, [r11]
            if (state->length == 0) state->mode = LEN;
8f63a08c:	1afffea6 	bne	8f639b2c <inflate+0x94>
            state->mode = LEN;
8f63a090:	e3a03014 	mov	r3, #20
8f63a094:	e5cb3000 	strb	r3, [r11]
            if (have >= 6 && left >= 258) {
8f63a098:	e59d200c 	ldr	r2, [r13, #12]
8f63a09c:	e3003101 	movw	r3, #257	; 0x101
8f63a0a0:	e3550005 	cmp	r5, #5
8f63a0a4:	81520003 	cmphi	r2, r3
8f63a0a8:	83a03001 	movhi	r3, #1
8f63a0ac:	93a03000 	movls	r3, #0
8f63a0b0:	9a000118 	bls	8f63a518 <inflate+0xa80>
                RESTORE();
8f63a0b4:	e59d3010 	ldr	r3, [r13, #16]
                inflate_fast(strm, out);
8f63a0b8:	e1a00009 	mov	r0, r9
                RESTORE();
8f63a0bc:	e5892010 	str	r2, [r9, #16]
8f63a0c0:	e5898000 	str	r8, [r9]
8f63a0c4:	e589300c 	str	r3, [r9, #12]
8f63a0c8:	e5895004 	str	r5, [r9, #4]
                inflate_fast(strm, out);
8f63a0cc:	e59d1014 	ldr	r1, [r13, #20]
                RESTORE();
8f63a0d0:	e58b6038 	str	r6, [r11, #56]	; 0x38
8f63a0d4:	e58b403c 	str	r4, [r11, #60]	; 0x3c
                inflate_fast(strm, out);
8f63a0d8:	eb0002fa 	bl	8f63acc8 <inflate_fast>
                LOAD();
8f63a0dc:	e599200c 	ldr	r2, [r9, #12]
                if (state->mode == TYPE)
8f63a0e0:	e5db3000 	ldrb	r3, [r11]
                LOAD();
8f63a0e4:	e5998000 	ldr	r8, [r9]
                if (state->mode == TYPE)
8f63a0e8:	e353000b 	cmp	r3, #11
                LOAD();
8f63a0ec:	e58d2010 	str	r2, [r13, #16]
8f63a0f0:	e5992010 	ldr	r2, [r9, #16]
                    state->back = -1;
8f63a0f4:	028bca01 	addeq	r12, r11, #4096	; 0x1000
                LOAD();
8f63a0f8:	e5995004 	ldr	r5, [r9, #4]
                    state->back = -1;
8f63a0fc:	03e03000 	mvneq	r3, #0
                LOAD();
8f63a100:	e59b6038 	ldr	r6, [r11, #56]	; 0x38
8f63a104:	e59b403c 	ldr	r4, [r11, #60]	; 0x3c
8f63a108:	e58d200c 	str	r2, [r13, #12]
                    state->back = -1;
8f63a10c:	058c3bc4 	streq	r3, [r12, #3012]	; 0xbc4
                if (state->mode == TYPE)
8f63a110:	1afffe85 	bne	8f639b2c <inflate+0x94>
8f63a114:	eafffeee 	b	8f639cd4 <inflate+0x23c>
            if (state->extra) {
8f63a118:	e59b1048 	ldr	r1, [r11, #72]	; 0x48
8f63a11c:	e3510000 	cmp	r1, #0
8f63a120:	1a0000e1 	bne	8f63a4ac <inflate+0xa14>
            state->was = state->length;
8f63a124:	e59b3040 	ldr	r3, [r11, #64]	; 0x40
8f63a128:	e28bca01 	add	r12, r11, #4096	; 0x1000
8f63a12c:	e58c3bc8 	str	r3, [r12, #3016]	; 0xbc8
            state->mode = DIST;
8f63a130:	e3a03016 	mov	r3, #22
8f63a134:	e5cb3000 	strb	r3, [r11]
                here = state->distcode[BITS(state->distbits)];
8f63a138:	e59b1058 	ldr	r1, [r11, #88]	; 0x58
8f63a13c:	e3e0e000 	mvn	r14, #0
8f63a140:	e59b2050 	ldr	r2, [r11, #80]	; 0x50
8f63a144:	e1c6311e 	bic	r3, r6, r14, lsl r1
8f63a148:	e1e0e11e 	mvn	r14, r14, lsl r1
8f63a14c:	ea000006 	b	8f63a16c <inflate+0x6d4>
                PULLBYTE();
8f63a150:	e3550000 	cmp	r5, #0
8f63a154:	0affff68 	beq	8f639efc <inflate+0x464>
8f63a158:	e4d83001 	ldrb	r3, [r8], #1
8f63a15c:	e2455001 	sub	r5, r5, #1
8f63a160:	e0866413 	add	r6, r6, r3, lsl r4
8f63a164:	e2844008 	add	r4, r4, #8
                here = state->distcode[BITS(state->distbits)];
8f63a168:	e00e3006 	and	r3, r14, r6
8f63a16c:	e0820103 	add	r0, r2, r3, lsl #2
8f63a170:	e7d21103 	ldrb	r1, [r2, r3, lsl #2]
8f63a174:	e5d03001 	ldrb	r3, [r0, #1]
8f63a178:	e1d000b2 	ldrh	r0, [r0, #2]
                if ((unsigned)(here.bits) <= bits) break;
8f63a17c:	e1530004 	cmp	r3, r4
8f63a180:	e1a0c003 	mov	r12, r3
8f63a184:	8afffff1 	bhi	8f63a150 <inflate+0x6b8>
            if ((here.op & 0xf0) == 0) {
8f63a188:	e31100f0 	tst	r1, #240	; 0xf0
8f63a18c:	0a000148 	beq	8f63a6b4 <inflate+0xc1c>
            state->back += here.bits;
8f63a190:	e28bca01 	add	r12, r11, #4096	; 0x1000
8f63a194:	e59cebc4 	ldr	r14, [r12, #3012]	; 0xbc4
            if (here.op & 64) {
8f63a198:	e3110040 	tst	r1, #64	; 0x40
            state->back += here.bits;
8f63a19c:	e083e00e 	add	r14, r3, r14
            DROPBITS(here.bits);
8f63a1a0:	e1a06336 	lsr	r6, r6, r3
8f63a1a4:	e0444003 	sub	r4, r4, r3
            state->back += here.bits;
8f63a1a8:	e58cebc4 	str	r14, [r12, #3012]	; 0xbc4
            if (here.op & 64) {
8f63a1ac:	0a000122 	beq	8f63a63c <inflate+0xba4>
                strm->msg = (char *)"invalid distance code";
8f63a1b0:	e30b3610 	movw	r3, #46608	; 0xb610
8f63a1b4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f63a1b8:	eafffe99 	b	8f639c24 <inflate+0x18c>
                NEEDBITS(state->extra);
8f63a1bc:	e3550000 	cmp	r5, #0
8f63a1c0:	0affff4d 	beq	8f639efc <inflate+0x464>
8f63a1c4:	e4d83001 	ldrb	r3, [r8], #1
8f63a1c8:	e2455001 	sub	r5, r5, #1
8f63a1cc:	e0866413 	add	r6, r6, r3, lsl r4
8f63a1d0:	e2844008 	add	r4, r4, #8
8f63a1d4:	e1540001 	cmp	r4, r1
8f63a1d8:	3afffff7 	bcc	8f63a1bc <inflate+0x724>
                state->offset += BITS(state->extra);
8f63a1dc:	e3e03000 	mvn	r3, #0
                state->back += state->extra;
8f63a1e0:	e28bca01 	add	r12, r11, #4096	; 0x1000
                state->offset += BITS(state->extra);
8f63a1e4:	e1c62113 	bic	r2, r6, r3, lsl r1
8f63a1e8:	e59b3044 	ldr	r3, [r11, #68]	; 0x44
                DROPBITS(state->extra);
8f63a1ec:	e0444001 	sub	r4, r4, r1
8f63a1f0:	e1a06136 	lsr	r6, r6, r1
                state->offset += BITS(state->extra);
8f63a1f4:	e0833002 	add	r3, r3, r2
8f63a1f8:	e58b3044 	str	r3, [r11, #68]	; 0x44
                state->back += state->extra;
8f63a1fc:	e59c3bc4 	ldr	r3, [r12, #3012]	; 0xbc4
8f63a200:	e0831001 	add	r1, r3, r1
8f63a204:	e58c1bc4 	str	r1, [r12, #3012]	; 0xbc4
8f63a208:	eafffefd 	b	8f639e04 <inflate+0x36c>
            while (state->have < state->ncode) {
8f63a20c:	e59b2068 	ldr	r2, [r11, #104]	; 0x68
8f63a210:	e59b105c 	ldr	r1, [r11, #92]	; 0x5c
8f63a214:	e1520001 	cmp	r2, r1
8f63a218:	2a000013 	bcs	8f63a26c <inflate+0x7d4>
8f63a21c:	e59d3020 	ldr	r3, [r13, #32]
8f63a220:	e0830082 	add	r0, r3, r2, lsl #1
                NEEDBITS(3);
8f63a224:	e3540002 	cmp	r4, #2
8f63a228:	8a000005 	bhi	8f63a244 <inflate+0x7ac>
8f63a22c:	e3550000 	cmp	r5, #0
8f63a230:	0affff31 	beq	8f639efc <inflate+0x464>
8f63a234:	e4d83001 	ldrb	r3, [r8], #1
8f63a238:	e2455001 	sub	r5, r5, #1
8f63a23c:	e0866413 	add	r6, r6, r3, lsl r4
8f63a240:	e2844008 	add	r4, r4, #8
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
8f63a244:	e0d030b2 	ldrh	r3, [r0], #2
8f63a248:	e2822001 	add	r2, r2, #1
            while (state->have < state->ncode) {
8f63a24c:	e1520001 	cmp	r2, r1
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
8f63a250:	e206c007 	and	r12, r6, #7
8f63a254:	e58b2068 	str	r2, [r11, #104]	; 0x68
                DROPBITS(3);
8f63a258:	e2444003 	sub	r4, r4, #3
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
8f63a25c:	e08b3083 	add	r3, r11, r3, lsl #1
                DROPBITS(3);
8f63a260:	e1a061a6 	lsr	r6, r6, #3
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
8f63a264:	e1c3c7b0 	strh	r12, [r3, #112]	; 0x70
            while (state->have < state->ncode) {
8f63a268:	3affffed 	bcc	8f63a224 <inflate+0x78c>
            while (state->have < 19)
8f63a26c:	e3520012 	cmp	r2, #18
8f63a270:	8a00000b 	bhi	8f63a2a4 <inflate+0x80c>
8f63a274:	e59d3020 	ldr	r3, [r13, #32]
                state->lens[order[state->have++]] = 0;
8f63a278:	e3a01000 	mov	r1, #0
8f63a27c:	e0832082 	add	r2, r3, r2, lsl #1
8f63a280:	e0d230b2 	ldrh	r3, [r2], #2
            while (state->have < 19)
8f63a284:	e59f0810 	ldr	r0, [pc, #2064]	; 8f63aa9c <inflate+0x1004>
                state->lens[order[state->have++]] = 0;
8f63a288:	e2833038 	add	r3, r3, #56	; 0x38
            while (state->have < 19)
8f63a28c:	e1500002 	cmp	r0, r2
                state->lens[order[state->have++]] = 0;
8f63a290:	e1a03083 	lsl	r3, r3, #1
8f63a294:	e18b10b3 	strh	r1, [r11, r3]
            while (state->have < 19)
8f63a298:	1afffff8 	bne	8f63a280 <inflate+0x7e8>
8f63a29c:	e3a03013 	mov	r3, #19
8f63a2a0:	e58b3068 	str	r3, [r11, #104]	; 0x68
            state->next = state->codes;
8f63a2a4:	e28b3e53 	add	r3, r11, #1328	; 0x530
                                &(state->lenbits), state->work);
8f63a2a8:	e28b0e2f 	add	r0, r11, #752	; 0x2f0
            state->next = state->codes;
8f63a2ac:	e58b306c 	str	r3, [r11, #108]	; 0x6c
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
8f63a2b0:	e28b2054 	add	r2, r11, #84	; 0x54
            state->lencode = (const code FAR *)(state->next);
8f63a2b4:	e58b304c 	str	r3, [r11, #76]	; 0x4c
            state->lenbits = 7;
8f63a2b8:	e3a0c007 	mov	r12, #7
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
8f63a2bc:	e28b306c 	add	r3, r11, #108	; 0x6c
            state->lenbits = 7;
8f63a2c0:	e58bc054 	str	r12, [r11, #84]	; 0x54
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
8f63a2c4:	e28b1070 	add	r1, r11, #112	; 0x70
8f63a2c8:	e58d0004 	str	r0, [r13, #4]
8f63a2cc:	e58d2000 	str	r2, [r13]
8f63a2d0:	e3a00000 	mov	r0, #0
8f63a2d4:	e3a02013 	mov	r2, #19
8f63a2d8:	ebfffb85 	bl	8f6390f4 <inflate_table>
            if (ret) {
8f63a2dc:	e3500000 	cmp	r0, #0
8f63a2e0:	0a0001ee 	beq	8f63aaa0 <inflate+0x1008>
                strm->msg = (char *)"invalid code lengths set";
8f63a2e4:	e30b3560 	movw	r3, #46432	; 0xb560
8f63a2e8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f63a2ec:	eafffe4c 	b	8f639c24 <inflate+0x18c>
            while (state->have < state->nlen + state->ndist) {
8f63a2f0:	e59bc068 	ldr	r12, [r11, #104]	; 0x68
8f63a2f4:	e59b2060 	ldr	r2, [r11, #96]	; 0x60
8f63a2f8:	e59be064 	ldr	r14, [r11, #100]	; 0x64
8f63a2fc:	e082e00e 	add	r14, r2, r14
8f63a300:	e15e000c 	cmp	r14, r12
8f63a304:	9a00001d 	bls	8f63a380 <inflate+0x8e8>
                    here = state->lencode[BITS(state->lenbits)];
8f63a308:	e59b3054 	ldr	r3, [r11, #84]	; 0x54
8f63a30c:	e3e01000 	mvn	r1, #0
8f63a310:	e59b004c 	ldr	r0, [r11, #76]	; 0x4c
8f63a314:	e1e01311 	mvn	r1, r1, lsl r3
8f63a318:	e28b306e 	add	r3, r11, #110	; 0x6e
8f63a31c:	e58d3028 	str	r3, [r13, #40]	; 0x28
8f63a320:	ea000005 	b	8f63a33c <inflate+0x8a4>
                    PULLBYTE();
8f63a324:	e3550000 	cmp	r5, #0
8f63a328:	0afffef3 	beq	8f639efc <inflate+0x464>
8f63a32c:	e4d83001 	ldrb	r3, [r8], #1
8f63a330:	e2455001 	sub	r5, r5, #1
8f63a334:	e0866413 	add	r6, r6, r3, lsl r4
8f63a338:	e2844008 	add	r4, r4, #8
                    here = state->lencode[BITS(state->lenbits)];
8f63a33c:	e0013006 	and	r3, r1, r6
8f63a340:	e0803103 	add	r3, r0, r3, lsl #2
8f63a344:	e5d37001 	ldrb	r7, [r3, #1]
8f63a348:	e1d330b2 	ldrh	r3, [r3, #2]
                    if ((unsigned)(here.bits) <= bits) break;
8f63a34c:	e1570004 	cmp	r7, r4
8f63a350:	8afffff3 	bhi	8f63a324 <inflate+0x88c>
                if (here.val < 16) {
8f63a354:	e353000f 	cmp	r3, #15
8f63a358:	8a0000a6 	bhi	8f63a5f8 <inflate+0xb60>
                    DROPBITS(here.bits);
8f63a35c:	e1a06736 	lsr	r6, r6, r7
8f63a360:	e0444007 	sub	r4, r4, r7
                    state->lens[state->have++] = here.val;
8f63a364:	e28c7001 	add	r7, r12, #1
8f63a368:	e08bc08c 	add	r12, r11, r12, lsl #1
8f63a36c:	e58b7068 	str	r7, [r11, #104]	; 0x68
8f63a370:	e1cc37b0 	strh	r3, [r12, #112]	; 0x70
8f63a374:	e1a0c007 	mov	r12, r7
            while (state->have < state->nlen + state->ndist) {
8f63a378:	e15e000c 	cmp	r14, r12
8f63a37c:	8affffee 	bhi	8f63a33c <inflate+0x8a4>
            if (state->mode == BAD) break;
8f63a380:	e5db3000 	ldrb	r3, [r11]
8f63a384:	e353001d 	cmp	r3, #29
8f63a388:	0afffe28 	beq	8f639c30 <inflate+0x198>
            if (state->lens[256] == 0) {
8f63a38c:	e28b3e27 	add	r3, r11, #624	; 0x270
8f63a390:	e1d330b0 	ldrh	r3, [r3]
8f63a394:	e3530000 	cmp	r3, #0
8f63a398:	1a0001ea 	bne	8f63ab48 <inflate+0x10b0>
                strm->msg = (char *)"invalid code -- missing end-of-block";
8f63a39c:	e30b3598 	movw	r3, #46488	; 0xb598
8f63a3a0:	e3483f70 	movt	r3, #36720	; 0x8f70
8f63a3a4:	eafffe1e 	b	8f639c24 <inflate+0x18c>
            copy = state->length;
8f63a3a8:	e59b7040 	ldr	r7, [r11, #64]	; 0x40
            state->mode = COPY;
8f63a3ac:	e3a0300f 	mov	r3, #15
8f63a3b0:	e5cb3000 	strb	r3, [r11]
            if (copy) {
8f63a3b4:	e3570000 	cmp	r7, #0
8f63a3b8:	0afffe43 	beq	8f639ccc <inflate+0x234>
                if (copy > left) copy = left;
8f63a3bc:	e1550007 	cmp	r5, r7
8f63a3c0:	e59d300c 	ldr	r3, [r13, #12]
8f63a3c4:	31a07005 	movcc	r7, r5
8f63a3c8:	e1570003 	cmp	r7, r3
8f63a3cc:	21a07003 	movcs	r7, r3
                if (copy == 0) goto inf_leave;
8f63a3d0:	e3570000 	cmp	r7, #0
8f63a3d4:	0a00014b 	beq	8f63a908 <inflate+0xe70>
                left -= copy;
8f63a3d8:	e59d300c 	ldr	r3, [r13, #12]
                zmemcpy(put, next, copy);
8f63a3dc:	e1a01008 	mov	r1, r8
8f63a3e0:	e1a02007 	mov	r2, r7
                have -= copy;
8f63a3e4:	e0455007 	sub	r5, r5, r7
                left -= copy;
8f63a3e8:	e0433007 	sub	r3, r3, r7
8f63a3ec:	e58d300c 	str	r3, [r13, #12]
                zmemcpy(put, next, copy);
8f63a3f0:	e59d3010 	ldr	r3, [r13, #16]
                next += copy;
8f63a3f4:	e0888007 	add	r8, r8, r7
                zmemcpy(put, next, copy);
8f63a3f8:	e1a00003 	mov	r0, r3
                put += copy;
8f63a3fc:	e0833007 	add	r3, r3, r7
8f63a400:	e58d3010 	str	r3, [r13, #16]
                zmemcpy(put, next, copy);
8f63a404:	ebffe76b 	bl	8f6341b8 <memcpy>
                state->length -= copy;
8f63a408:	e59b3040 	ldr	r3, [r11, #64]	; 0x40
8f63a40c:	e0433007 	sub	r3, r3, r7
8f63a410:	e58b3040 	str	r3, [r11, #64]	; 0x40
        switch (state->mode) {
8f63a414:	e5db3000 	ldrb	r3, [r11]
                break;
8f63a418:	eafffdc3 	b	8f639b2c <inflate+0x94>
            copy = state->length;
8f63a41c:	e59b7040 	ldr	r7, [r11, #64]	; 0x40
8f63a420:	eaffffe3 	b	8f63a3b4 <inflate+0x91c>
            if (state->wrap == 0) {
8f63a424:	e59b3008 	ldr	r3, [r11, #8]
8f63a428:	e3530000 	cmp	r3, #0
                state->mode = TYPEDO;
8f63a42c:	03a0300c 	moveq	r3, #12
8f63a430:	05cb3000 	strbeq	r3, [r11]
            if (state->wrap == 0) {
8f63a434:	0afffe2a 	beq	8f639ce4 <inflate+0x24c>
8f63a438:	ea000005 	b	8f63a454 <inflate+0x9bc>
            NEEDBITS(16);
8f63a43c:	e3550000 	cmp	r5, #0
8f63a440:	0afffead 	beq	8f639efc <inflate+0x464>
8f63a444:	e4d83001 	ldrb	r3, [r8], #1
8f63a448:	e2455001 	sub	r5, r5, #1
8f63a44c:	e0866413 	add	r6, r6, r3, lsl r4
8f63a450:	e2844008 	add	r4, r4, #8
8f63a454:	e354000f 	cmp	r4, #15
8f63a458:	9afffff7 	bls	8f63a43c <inflate+0x9a4>
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
8f63a45c:	e1a02406 	lsl	r2, r6, #8
8f63a460:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f63a464:	e6ff2072 	uxth	r2, r2
8f63a468:	e0822426 	add	r2, r2, r6, lsr #8
8f63a46c:	e0831293 	umull	r1, r3, r3, r2
8f63a470:	e0421003 	sub	r1, r2, r3
8f63a474:	e08330a1 	add	r3, r3, r1, lsr #1
8f63a478:	e1a03223 	lsr	r3, r3, #4
8f63a47c:	e0633283 	rsb	r3, r3, r3, lsl #5
            if (
8f63a480:	e1520003 	cmp	r2, r3
8f63a484:	0a000123 	beq	8f63a918 <inflate+0xe80>
                strm->msg = (char *)"incorrect header check";
8f63a488:	e30b34c0 	movw	r3, #46272	; 0xb4c0
8f63a48c:	e3483f70 	movt	r3, #36720	; 0x8f70
8f63a490:	eafffde3 	b	8f639c24 <inflate+0x18c>
                NEEDBITS(state->extra);
8f63a494:	e3550000 	cmp	r5, #0
8f63a498:	0afffe97 	beq	8f639efc <inflate+0x464>
8f63a49c:	e4d83001 	ldrb	r3, [r8], #1
8f63a4a0:	e2455001 	sub	r5, r5, #1
8f63a4a4:	e0866413 	add	r6, r6, r3, lsl r4
8f63a4a8:	e2844008 	add	r4, r4, #8
8f63a4ac:	e1540001 	cmp	r4, r1
8f63a4b0:	3afffff7 	bcc	8f63a494 <inflate+0x9fc>
                state->length += BITS(state->extra);
8f63a4b4:	e59b2040 	ldr	r2, [r11, #64]	; 0x40
                state->back += state->extra;
8f63a4b8:	e28bca01 	add	r12, r11, #4096	; 0x1000
                state->length += BITS(state->extra);
8f63a4bc:	e3e03000 	mvn	r3, #0
                DROPBITS(state->extra);
8f63a4c0:	e0444001 	sub	r4, r4, r1
                state->length += BITS(state->extra);
8f63a4c4:	e1c63113 	bic	r3, r6, r3, lsl r1
                DROPBITS(state->extra);
8f63a4c8:	e1a06136 	lsr	r6, r6, r1
                state->length += BITS(state->extra);
8f63a4cc:	e0833002 	add	r3, r3, r2
                state->back += state->extra;
8f63a4d0:	e59c2bc4 	ldr	r2, [r12, #3012]	; 0xbc4
                state->length += BITS(state->extra);
8f63a4d4:	e58b3040 	str	r3, [r11, #64]	; 0x40
                state->back += state->extra;
8f63a4d8:	e0821001 	add	r1, r2, r1
8f63a4dc:	e58c1bc4 	str	r1, [r12, #3012]	; 0xbc4
8f63a4e0:	eaffff11 	b	8f63a12c <inflate+0x694>
            return Z_MEM_ERROR;
8f63a4e4:	e3e07003 	mvn	r7, #3
8f63a4e8:	eafffe12 	b	8f639d38 <inflate+0x2a0>
            UPDATE(state->check, strm->next_out - out, out);
8f63a4ec:	e59d300c 	ldr	r3, [r13, #12]
8f63a4f0:	e59d2014 	ldr	r2, [r13, #20]
8f63a4f4:	e59b0018 	ldr	r0, [r11, #24]
8f63a4f8:	e0431002 	sub	r1, r3, r2
8f63a4fc:	e599300c 	ldr	r3, [r9, #12]
8f63a500:	e1a0200a 	mov	r2, r10
8f63a504:	e0831001 	add	r1, r3, r1
8f63a508:	ebfffa1f 	bl	8f638d8c <adler32>
        strm->adler = state->check =
8f63a50c:	e58b0018 	str	r0, [r11, #24]
8f63a510:	e5890030 	str	r0, [r9, #48]	; 0x30
8f63a514:	eafffe9c 	b	8f639f8c <inflate+0x4f4>
                here = state->lencode[BITS(state->lenbits)];
8f63a518:	e59b1054 	ldr	r1, [r11, #84]	; 0x54
            state->back = 0;
8f63a51c:	e28bca01 	add	r12, r11, #4096	; 0x1000
                here = state->lencode[BITS(state->lenbits)];
8f63a520:	e3e0e000 	mvn	r14, #0
8f63a524:	e59b204c 	ldr	r2, [r11, #76]	; 0x4c
            state->back = 0;
8f63a528:	e58c3bc4 	str	r3, [r12, #3012]	; 0xbc4
                here = state->lencode[BITS(state->lenbits)];
8f63a52c:	e1c6311e 	bic	r3, r6, r14, lsl r1
8f63a530:	e1e0e11e 	mvn	r14, r14, lsl r1
8f63a534:	e0820103 	add	r0, r2, r3, lsl #2
8f63a538:	e7d21103 	ldrb	r1, [r2, r3, lsl #2]
8f63a53c:	e5d03001 	ldrb	r3, [r0, #1]
8f63a540:	e1d000b2 	ldrh	r0, [r0, #2]
                if ((unsigned)(here.bits) <= bits) break;
8f63a544:	e1540003 	cmp	r4, r3
8f63a548:	3a00000b 	bcc	8f63a57c <inflate+0xae4>
8f63a54c:	ea00004e 	b	8f63a68c <inflate+0xbf4>
                PULLBYTE();
8f63a550:	e4d83001 	ldrb	r3, [r8], #1
8f63a554:	e2455001 	sub	r5, r5, #1
8f63a558:	e0866413 	add	r6, r6, r3, lsl r4
8f63a55c:	e2844008 	add	r4, r4, #8
                here = state->lencode[BITS(state->lenbits)];
8f63a560:	e006300e 	and	r3, r6, r14
8f63a564:	e0820103 	add	r0, r2, r3, lsl #2
8f63a568:	e7d21103 	ldrb	r1, [r2, r3, lsl #2]
8f63a56c:	e5d03001 	ldrb	r3, [r0, #1]
8f63a570:	e1d000b2 	ldrh	r0, [r0, #2]
                if ((unsigned)(here.bits) <= bits) break;
8f63a574:	e1530004 	cmp	r3, r4
8f63a578:	9a000043 	bls	8f63a68c <inflate+0xbf4>
                PULLBYTE();
8f63a57c:	e3550000 	cmp	r5, #0
8f63a580:	1afffff2 	bne	8f63a550 <inflate+0xab8>
8f63a584:	eafffe5c 	b	8f639efc <inflate+0x464>
                if (copy > state->wnext) {
8f63a588:	e59b2030 	ldr	r2, [r11, #48]	; 0x30
8f63a58c:	e1520000 	cmp	r2, r0
                    copy -= state->wnext;
8f63a590:	30400002 	subcc	r0, r0, r2
                    from = state->window + (state->wsize - copy);
8f63a594:	359b1028 	ldrcc	r1, [r11, #40]	; 0x28
8f63a598:	30822001 	addcc	r2, r2, r1
                    from = state->window + (state->wnext - copy);
8f63a59c:	e59d1014 	ldr	r1, [r13, #20]
8f63a5a0:	e0822001 	add	r2, r2, r1
8f63a5a4:	e0423003 	sub	r3, r2, r3
8f63a5a8:	e59b2034 	ldr	r2, [r11, #52]	; 0x34
8f63a5ac:	e0823003 	add	r3, r2, r3
                if (copy > state->length) copy = state->length;
8f63a5b0:	e59b2040 	ldr	r2, [r11, #64]	; 0x40
8f63a5b4:	e1520000 	cmp	r2, r0
8f63a5b8:	31a00002 	movcc	r0, r2
8f63a5bc:	eafffe9e 	b	8f63a03c <inflate+0x5a4>
        switch (state->mode) {
8f63a5c0:	e59d2010 	ldr	r2, [r13, #16]
            if (left == 0) goto inf_leave;
8f63a5c4:	e59d300c 	ldr	r3, [r13, #12]
8f63a5c8:	e3530000 	cmp	r3, #0
8f63a5cc:	0a0000e4 	beq	8f63a964 <inflate+0xecc>
            left--;
8f63a5d0:	e2433001 	sub	r3, r3, #1
8f63a5d4:	e58d300c 	str	r3, [r13, #12]
            *put++ = (unsigned char)(state->length);
8f63a5d8:	e59b3040 	ldr	r3, [r11, #64]	; 0x40
8f63a5dc:	e59d1010 	ldr	r1, [r13, #16]
8f63a5e0:	e5c23000 	strb	r3, [r2]
8f63a5e4:	e2811001 	add	r1, r1, #1
            state->mode = LEN;
8f63a5e8:	e3a03014 	mov	r3, #20
            *put++ = (unsigned char)(state->length);
8f63a5ec:	e58d1010 	str	r1, [r13, #16]
            state->mode = LEN;
8f63a5f0:	e5cb3000 	strb	r3, [r11]
        switch (state->mode) {
8f63a5f4:	eafffea7 	b	8f63a098 <inflate+0x600>
                    if (here.val == 16) {
8f63a5f8:	e3530010 	cmp	r3, #16
8f63a5fc:	0a0000cb 	beq	8f63a930 <inflate+0xe98>
                    else if (here.val == 17) {
8f63a600:	e3530011 	cmp	r3, #17
8f63a604:	0a0000a4 	beq	8f63a89c <inflate+0xe04>
                        NEEDBITS(here.bits + 7);
8f63a608:	e287a007 	add	r10, r7, #7
8f63a60c:	e15a0004 	cmp	r10, r4
8f63a610:	8a000006 	bhi	8f63a630 <inflate+0xb98>
8f63a614:	ea000087 	b	8f63a838 <inflate+0xda0>
8f63a618:	e4d83001 	ldrb	r3, [r8], #1
8f63a61c:	e2455001 	sub	r5, r5, #1
8f63a620:	e0866413 	add	r6, r6, r3, lsl r4
8f63a624:	e2844008 	add	r4, r4, #8
8f63a628:	e154000a 	cmp	r4, r10
8f63a62c:	2a000081 	bcs	8f63a838 <inflate+0xda0>
8f63a630:	e3550000 	cmp	r5, #0
8f63a634:	1afffff7 	bne	8f63a618 <inflate+0xb80>
8f63a638:	eafffe2f 	b	8f639efc <inflate+0x464>
            state->extra = (unsigned)(here.op) & 15;
8f63a63c:	e201100f 	and	r1, r1, #15
            state->mode = DISTEXT;
8f63a640:	e3a03017 	mov	r3, #23
            state->offset = (unsigned)here.val;
8f63a644:	e58b0044 	str	r0, [r11, #68]	; 0x44
            state->extra = (unsigned)(here.op) & 15;
8f63a648:	e58b1048 	str	r1, [r11, #72]	; 0x48
            state->mode = DISTEXT;
8f63a64c:	e5cb3000 	strb	r3, [r11]
8f63a650:	eafffde9 	b	8f639dfc <inflate+0x364>
                state->mode = TABLE;
8f63a654:	e3a03010 	mov	r3, #16
            DROPBITS(2);
8f63a658:	e1a061a6 	lsr	r6, r6, #3
8f63a65c:	e2444003 	sub	r4, r4, #3
                state->mode = TABLE;
8f63a660:	e5cb3000 	strb	r3, [r11]
        switch (state->mode) {
8f63a664:	eafffd58 	b	8f639bcc <inflate+0x134>
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
8f63a668:	e1a03826 	lsr	r3, r6, #16
8f63a66c:	e6ff7076 	uxth	r7, r6
8f63a670:	e2233cff 	eor	r3, r3, #65280	; 0xff00
8f63a674:	e22330ff 	eor	r3, r3, #255	; 0xff
8f63a678:	e1570003 	cmp	r7, r3
8f63a67c:	0a000043 	beq	8f63a790 <inflate+0xcf8>
                strm->msg = (char *)"invalid stored block lengths";
8f63a680:	e30b351c 	movw	r3, #46364	; 0xb51c
8f63a684:	e3483f70 	movt	r3, #36720	; 0x8f70
8f63a688:	eafffd65 	b	8f639c24 <inflate+0x18c>
            if (here.op && (here.op & 0xf0) == 0) {
8f63a68c:	e3510000 	cmp	r1, #0
8f63a690:	1a000031 	bne	8f63a75c <inflate+0xcc4>
            DROPBITS(here.bits);
8f63a694:	e1a06336 	lsr	r6, r6, r3
8f63a698:	e0444003 	sub	r4, r4, r3
            state->back += here.bits;
8f63a69c:	e58c3bc4 	str	r3, [r12, #3012]	; 0xbc4
            state->length = (unsigned)here.val;
8f63a6a0:	e58b0040 	str	r0, [r11, #64]	; 0x40
                state->mode = LIT;
8f63a6a4:	e3a03019 	mov	r3, #25
8f63a6a8:	e59d2010 	ldr	r2, [r13, #16]
8f63a6ac:	e5cb3000 	strb	r3, [r11]
        switch (state->mode) {
8f63a6b0:	eaffffc3 	b	8f63a5c4 <inflate+0xb2c>
                            (BITS(last.bits + last.op) >> last.bits)];
8f63a6b4:	e0811003 	add	r1, r1, r3
8f63a6b8:	e3e0e000 	mvn	r14, #0
8f63a6bc:	e1c6711e 	bic	r7, r6, r14, lsl r1
                    here = state->distcode[last.val +
8f63a6c0:	e1a0a000 	mov	r10, r0
                            (BITS(last.bits + last.op) >> last.bits)];
8f63a6c4:	e1e0111e 	mvn	r1, r14, lsl r1
8f63a6c8:	e58d1028 	str	r1, [r13, #40]	; 0x28
                    here = state->distcode[last.val +
8f63a6cc:	e0801337 	add	r1, r0, r7, lsr r3
                            (BITS(last.bits + last.op) >> last.bits)];
8f63a6d0:	e1a0e003 	mov	r14, r3
                    here = state->distcode[last.val +
8f63a6d4:	e0820101 	add	r0, r2, r1, lsl #2
8f63a6d8:	e7d21101 	ldrb	r1, [r2, r1, lsl #2]
8f63a6dc:	e5d03001 	ldrb	r3, [r0, #1]
8f63a6e0:	e1d000b2 	ldrh	r0, [r0, #2]
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
8f63a6e4:	e083700c 	add	r7, r3, r12
8f63a6e8:	e1570004 	cmp	r7, r4
8f63a6ec:	9a000014 	bls	8f63a744 <inflate+0xcac>
                    PULLBYTE();
8f63a6f0:	e3550000 	cmp	r5, #0
8f63a6f4:	0afffe00 	beq	8f639efc <inflate+0x464>
8f63a6f8:	e59d7028 	ldr	r7, [r13, #40]	; 0x28
8f63a6fc:	e58dc02c 	str	r12, [r13, #44]	; 0x2c
8f63a700:	ea000001 	b	8f63a70c <inflate+0xc74>
8f63a704:	e3550000 	cmp	r5, #0
8f63a708:	0afffdfb 	beq	8f639efc <inflate+0x464>
8f63a70c:	e4d83001 	ldrb	r3, [r8], #1
8f63a710:	e2455001 	sub	r5, r5, #1
8f63a714:	e0866413 	add	r6, r6, r3, lsl r4
8f63a718:	e2844008 	add	r4, r4, #8
                            (BITS(last.bits + last.op) >> last.bits)];
8f63a71c:	e0063007 	and	r3, r6, r7
                    here = state->distcode[last.val +
8f63a720:	e08a3e33 	add	r3, r10, r3, lsr r14
8f63a724:	e0820103 	add	r0, r2, r3, lsl #2
8f63a728:	e7d21103 	ldrb	r1, [r2, r3, lsl #2]
8f63a72c:	e5d03001 	ldrb	r3, [r0, #1]
8f63a730:	e1d000b2 	ldrh	r0, [r0, #2]
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
8f63a734:	e083c00e 	add	r12, r3, r14
8f63a738:	e15c0004 	cmp	r12, r4
8f63a73c:	8afffff0 	bhi	8f63a704 <inflate+0xc6c>
8f63a740:	e59dc02c 	ldr	r12, [r13, #44]	; 0x2c
                DROPBITS(last.bits);
8f63a744:	e044400c 	sub	r4, r4, r12
                state->back += last.bits;
8f63a748:	e28bca01 	add	r12, r11, #4096	; 0x1000
                DROPBITS(last.bits);
8f63a74c:	e1a06e36 	lsr	r6, r6, r14
                state->back += last.bits;
8f63a750:	e59c2bc4 	ldr	r2, [r12, #3012]	; 0xbc4
8f63a754:	e08ee002 	add	r14, r14, r2
8f63a758:	eafffe8e 	b	8f63a198 <inflate+0x700>
            if (here.op && (here.op & 0xf0) == 0) {
8f63a75c:	e31100f0 	tst	r1, #240	; 0xf0
8f63a760:	0a00008d 	beq	8f63a99c <inflate+0xf04>
            DROPBITS(here.bits);
8f63a764:	e1a06336 	lsr	r6, r6, r3
8f63a768:	e0444003 	sub	r4, r4, r3
            state->back += here.bits;
8f63a76c:	e58c3bc4 	str	r3, [r12, #3012]	; 0xbc4
            state->length = (unsigned)here.val;
8f63a770:	e58b0040 	str	r0, [r11, #64]	; 0x40
            if (here.op & 32) {
8f63a774:	e3110020 	tst	r1, #32
8f63a778:	0a000054 	beq	8f63a8d0 <inflate+0xe38>
                state->back = -1;
8f63a77c:	e3e03000 	mvn	r3, #0
8f63a780:	e58c3bc4 	str	r3, [r12, #3012]	; 0xbc4
                state->mode = TYPE;
8f63a784:	e3a0300b 	mov	r3, #11
8f63a788:	e5cb3000 	strb	r3, [r11]
        switch (state->mode) {
8f63a78c:	eafffd50 	b	8f639cd4 <inflate+0x23c>
            if (flush == Z_TREES) goto inf_leave;
8f63a790:	e59d301c 	ldr	r3, [r13, #28]
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
8f63a794:	e3a04000 	mov	r4, #0
            state->length = (unsigned)hold & 0xffff;
8f63a798:	e58b7040 	str	r7, [r11, #64]	; 0x40
            if (flush == Z_TREES) goto inf_leave;
8f63a79c:	e3530006 	cmp	r3, #6
            state->mode = COPY_;
8f63a7a0:	e3a0300e 	mov	r3, #14
8f63a7a4:	e5cb3000 	strb	r3, [r11]
            if (flush == Z_TREES) goto inf_leave;
8f63a7a8:	0a000103 	beq	8f63abbc <inflate+0x1124>
            INITBITS();
8f63a7ac:	e1a06004 	mov	r6, r4
8f63a7b0:	eafffefd 	b	8f63a3ac <inflate+0x914>
                        UPDATE(state->check, put - out, out);
8f63a7b4:	e59d300c 	ldr	r3, [r13, #12]
8f63a7b8:	e59d1014 	ldr	r1, [r13, #20]
8f63a7bc:	e59b0018 	ldr	r0, [r11, #24]
8f63a7c0:	e0431001 	sub	r1, r3, r1
8f63a7c4:	e59d3010 	ldr	r3, [r13, #16]
8f63a7c8:	e0831001 	add	r1, r3, r1
8f63a7cc:	ebfff96e 	bl	8f638d8c <adler32>
                    strm->adler = state->check =
8f63a7d0:	e58b0018 	str	r0, [r11, #24]
8f63a7d4:	e5890030 	str	r0, [r9, #48]	; 0x30
8f63a7d8:	eafffd73 	b	8f639dac <inflate+0x314>
                if (flush == Z_TREES) {
8f63a7dc:	e59d301c 	ldr	r3, [r13, #28]
8f63a7e0:	e3530006 	cmp	r3, #6
    state->lencode = lenfix;
8f63a7e4:	e30b36e0 	movw	r3, #46816	; 0xb6e0
8f63a7e8:	e3483f70 	movt	r3, #36720	; 0x8f70
8f63a7ec:	e58b304c 	str	r3, [r11, #76]	; 0x4c
    state->lenbits = 9;
8f63a7f0:	e3a03009 	mov	r3, #9
8f63a7f4:	e58b3054 	str	r3, [r11, #84]	; 0x54
    state->distcode = distfix;
8f63a7f8:	e30b3660 	movw	r3, #46688	; 0xb660
8f63a7fc:	e3483f70 	movt	r3, #36720	; 0x8f70
8f63a800:	e58b3050 	str	r3, [r11, #80]	; 0x50
    state->distbits = 5;
8f63a804:	e3a03005 	mov	r3, #5
8f63a808:	e58b3058 	str	r3, [r11, #88]	; 0x58
                state->mode = LEN_;             /* decode codes */
8f63a80c:	e3a03013 	mov	r3, #19
8f63a810:	e5cb3000 	strb	r3, [r11]
                if (flush == Z_TREES) {
8f63a814:	0a0000ee 	beq	8f63abd4 <inflate+0x113c>
            DROPBITS(2);
8f63a818:	e1a061a6 	lsr	r6, r6, #3
8f63a81c:	e2444003 	sub	r4, r4, #3
        switch (state->mode) {
8f63a820:	eafffe1a 	b	8f63a090 <inflate+0x5f8>
                strm->msg = (char *)"invalid block type";
8f63a824:	e30b3508 	movw	r3, #46344	; 0xb508
            DROPBITS(2);
8f63a828:	e1a061a6 	lsr	r6, r6, #3
8f63a82c:	e2444003 	sub	r4, r4, #3
                strm->msg = (char *)"invalid block type";
8f63a830:	e3483f70 	movt	r3, #36720	; 0x8f70
8f63a834:	eafffcfa 	b	8f639c24 <inflate+0x18c>
                        DROPBITS(here.bits);
8f63a838:	e1a06736 	lsr	r6, r6, r7
                        DROPBITS(7);
8f63a83c:	e26774ff 	rsb	r7, r7, #-16777216	; 0xff000000
8f63a840:	e28778ff 	add	r7, r7, #16711680	; 0xff0000
                        copy = 11 + BITS(7);
8f63a844:	e206a07f 	and	r10, r6, #127	; 0x7f
                        DROPBITS(7);
8f63a848:	e2877cff 	add	r7, r7, #65280	; 0xff00
                        copy = 11 + BITS(7);
8f63a84c:	e28aa00b 	add	r10, r10, #11
                        DROPBITS(7);
8f63a850:	e28770f9 	add	r7, r7, #249	; 0xf9
8f63a854:	e1a063a6 	lsr	r6, r6, #7
8f63a858:	e0844007 	add	r4, r4, r7
                        len = 0;
8f63a85c:	e3a07000 	mov	r7, #0
                    if (state->have + copy > state->nlen + state->ndist) {
8f63a860:	e08ac00c 	add	r12, r10, r12
8f63a864:	e15e000c 	cmp	r14, r12
8f63a868:	3a0000d0 	bcc	8f63abb0 <inflate+0x1118>
                    while (copy--)
8f63a86c:	e59b3068 	ldr	r3, [r11, #104]	; 0x68
                        state->lens[state->have++] = (unsigned short)len;
8f63a870:	e6ff7077 	uxth	r7, r7
8f63a874:	e08ac003 	add	r12, r10, r3
8f63a878:	e59da028 	ldr	r10, [r13, #40]	; 0x28
8f63a87c:	e08b3083 	add	r3, r11, r3, lsl #1
8f63a880:	e283306e 	add	r3, r3, #110	; 0x6e
8f63a884:	e08aa08c 	add	r10, r10, r12, lsl #1
8f63a888:	e1e370b2 	strh	r7, [r3, #2]!
                    while (copy--)
8f63a88c:	e15a0003 	cmp	r10, r3
8f63a890:	1afffffc 	bne	8f63a888 <inflate+0xdf0>
8f63a894:	e58bc068 	str	r12, [r11, #104]	; 0x68
8f63a898:	eafffeb6 	b	8f63a378 <inflate+0x8e0>
                        NEEDBITS(here.bits + 3);
8f63a89c:	e287a003 	add	r10, r7, #3
8f63a8a0:	e15a0004 	cmp	r10, r4
8f63a8a4:	8a000006 	bhi	8f63a8c4 <inflate+0xe2c>
8f63a8a8:	ea000030 	b	8f63a970 <inflate+0xed8>
8f63a8ac:	e4d83001 	ldrb	r3, [r8], #1
8f63a8b0:	e2455001 	sub	r5, r5, #1
8f63a8b4:	e0866413 	add	r6, r6, r3, lsl r4
8f63a8b8:	e2844008 	add	r4, r4, #8
8f63a8bc:	e154000a 	cmp	r4, r10
8f63a8c0:	2a00002a 	bcs	8f63a970 <inflate+0xed8>
8f63a8c4:	e3550000 	cmp	r5, #0
8f63a8c8:	1afffff7 	bne	8f63a8ac <inflate+0xe14>
8f63a8cc:	eafffd8a 	b	8f639efc <inflate+0x464>
            if (here.op & 64) {
8f63a8d0:	e3110040 	tst	r1, #64	; 0x40
8f63a8d4:	0a00005b 	beq	8f63aa48 <inflate+0xfb0>
                strm->msg = (char *)"invalid literal/length code";
8f63a8d8:	e30b35f4 	movw	r3, #46580	; 0xb5f4
8f63a8dc:	e3483f70 	movt	r3, #36720	; 0x8f70
8f63a8e0:	eafffccf 	b	8f639c24 <inflate+0x18c>
            state->mode = LENLENS;
8f63a8e4:	e3a03011 	mov	r3, #17
            state->have = 0;
8f63a8e8:	e58b2068 	str	r2, [r11, #104]	; 0x68
            state->mode = LENLENS;
8f63a8ec:	e5cb3000 	strb	r3, [r11]
            while (state->have < state->ncode) {
8f63a8f0:	eafffe49 	b	8f63a21c <inflate+0x784>
            if (flush == Z_TREES) goto inf_leave;
8f63a8f4:	e59d301c 	ldr	r3, [r13, #28]
8f63a8f8:	e3530006 	cmp	r3, #6
            state->mode = LEN_;
8f63a8fc:	e3a03013 	mov	r3, #19
8f63a900:	e5cb3000 	strb	r3, [r11]
            if (flush == Z_TREES) goto inf_leave;
8f63a904:	1afffde1 	bne	8f63a090 <inflate+0x5f8>
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
8f63a908:	e59d3014 	ldr	r3, [r13, #20]
8f63a90c:	e59d200c 	ldr	r2, [r13, #12]
8f63a910:	e043a002 	sub	r10, r3, r2
8f63a914:	eafffd7c 	b	8f639f0c <inflate+0x474>
            if (BITS(4) != Z_DEFLATED) {
8f63a918:	e206300f 	and	r3, r6, #15
8f63a91c:	e3530008 	cmp	r3, #8
8f63a920:	0a00006d 	beq	8f63aadc <inflate+0x1044>
                strm->msg = (char *)"unknown compression method";
8f63a924:	e30b34d8 	movw	r3, #46296	; 0xb4d8
8f63a928:	e3483f70 	movt	r3, #36720	; 0x8f70
8f63a92c:	eafffcbc 	b	8f639c24 <inflate+0x18c>
                        NEEDBITS(here.bits + 2);
8f63a930:	e287a002 	add	r10, r7, #2
8f63a934:	e15a0004 	cmp	r10, r4
8f63a938:	8a000006 	bhi	8f63a958 <inflate+0xec0>
8f63a93c:	ea00004a 	b	8f63aa6c <inflate+0xfd4>
8f63a940:	e4d83001 	ldrb	r3, [r8], #1
8f63a944:	e2455001 	sub	r5, r5, #1
8f63a948:	e0866413 	add	r6, r6, r3, lsl r4
8f63a94c:	e2844008 	add	r4, r4, #8
8f63a950:	e15a0004 	cmp	r10, r4
8f63a954:	9a000044 	bls	8f63aa6c <inflate+0xfd4>
8f63a958:	e3550000 	cmp	r5, #0
8f63a95c:	1afffff7 	bne	8f63a940 <inflate+0xea8>
8f63a960:	eafffd65 	b	8f639efc <inflate+0x464>
8f63a964:	e59da014 	ldr	r10, [r13, #20]
8f63a968:	e59d700c 	ldr	r7, [r13, #12]
8f63a96c:	eafffd66 	b	8f639f0c <inflate+0x474>
                        DROPBITS(here.bits);
8f63a970:	e1a06736 	lsr	r6, r6, r7
                        DROPBITS(3);
8f63a974:	e26774ff 	rsb	r7, r7, #-16777216	; 0xff000000
8f63a978:	e28778ff 	add	r7, r7, #16711680	; 0xff0000
                        copy = 3 + BITS(3);
8f63a97c:	e206a007 	and	r10, r6, #7
                        DROPBITS(3);
8f63a980:	e2877cff 	add	r7, r7, #65280	; 0xff00
                        copy = 3 + BITS(3);
8f63a984:	e28aa003 	add	r10, r10, #3
                        DROPBITS(3);
8f63a988:	e28770fd 	add	r7, r7, #253	; 0xfd
8f63a98c:	e1a061a6 	lsr	r6, r6, #3
8f63a990:	e0844007 	add	r4, r4, r7
                        len = 0;
8f63a994:	e3a07000 	mov	r7, #0
8f63a998:	eaffffb0 	b	8f63a860 <inflate+0xdc8>
                            (BITS(last.bits + last.op) >> last.bits)];
8f63a99c:	e3e07000 	mvn	r7, #0
8f63a9a0:	e081e003 	add	r14, r1, r3
8f63a9a4:	e1c61e17 	bic	r1, r6, r7, lsl r14
8f63a9a8:	e1e0ee17 	mvn	r14, r7, lsl r14
8f63a9ac:	e58de028 	str	r14, [r13, #40]	; 0x28
                    here = state->lencode[last.val +
8f63a9b0:	e0801331 	add	r1, r0, r1, lsr r3
8f63a9b4:	e0827101 	add	r7, r2, r1, lsl #2
8f63a9b8:	e7d21101 	ldrb	r1, [r2, r1, lsl #2]
8f63a9bc:	e5d7e001 	ldrb	r14, [r7, #1]
8f63a9c0:	e1d7a0b2 	ldrh	r10, [r7, #2]
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
8f63a9c4:	e08e7003 	add	r7, r14, r3
8f63a9c8:	e1570004 	cmp	r7, r4
8f63a9cc:	9a000014 	bls	8f63aa24 <inflate+0xf8c>
                    PULLBYTE();
8f63a9d0:	e3550000 	cmp	r5, #0
8f63a9d4:	0afffd48 	beq	8f639efc <inflate+0x464>
8f63a9d8:	e58dc02c 	str	r12, [r13, #44]	; 0x2c
8f63a9dc:	e59dc028 	ldr	r12, [r13, #40]	; 0x28
8f63a9e0:	ea000001 	b	8f63a9ec <inflate+0xf54>
8f63a9e4:	e3550000 	cmp	r5, #0
8f63a9e8:	0afffd43 	beq	8f639efc <inflate+0x464>
8f63a9ec:	e4d81001 	ldrb	r1, [r8], #1
8f63a9f0:	e2455001 	sub	r5, r5, #1
8f63a9f4:	e0866411 	add	r6, r6, r1, lsl r4
8f63a9f8:	e2844008 	add	r4, r4, #8
                            (BITS(last.bits + last.op) >> last.bits)];
8f63a9fc:	e006100c 	and	r1, r6, r12
                    here = state->lencode[last.val +
8f63aa00:	e0801331 	add	r1, r0, r1, lsr r3
8f63aa04:	e0827101 	add	r7, r2, r1, lsl #2
8f63aa08:	e7d21101 	ldrb	r1, [r2, r1, lsl #2]
8f63aa0c:	e5d7e001 	ldrb	r14, [r7, #1]
8f63aa10:	e1d7a0b2 	ldrh	r10, [r7, #2]
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
8f63aa14:	e08e7003 	add	r7, r14, r3
8f63aa18:	e1570004 	cmp	r7, r4
8f63aa1c:	8afffff0 	bhi	8f63a9e4 <inflate+0xf4c>
8f63aa20:	e59dc02c 	ldr	r12, [r13, #44]	; 0x2c
                DROPBITS(last.bits);
8f63aa24:	e1a06336 	lsr	r6, r6, r3
            if ((int)(here.op) == 0) {
8f63aa28:	e3510000 	cmp	r1, #0
                DROPBITS(last.bits);
8f63aa2c:	e0444003 	sub	r4, r4, r3
            state->back += here.bits;
8f63aa30:	e58c7bc4 	str	r7, [r12, #3012]	; 0xbc4
            DROPBITS(here.bits);
8f63aa34:	e044400e 	sub	r4, r4, r14
8f63aa38:	e1a06e36 	lsr	r6, r6, r14
            state->length = (unsigned)here.val;
8f63aa3c:	e58ba040 	str	r10, [r11, #64]	; 0x40
            if ((int)(here.op) == 0) {
8f63aa40:	1affff4b 	bne	8f63a774 <inflate+0xcdc>
8f63aa44:	eaffff16 	b	8f63a6a4 <inflate+0xc0c>
            state->extra = (unsigned)(here.op) & 15;
8f63aa48:	e201100f 	and	r1, r1, #15
            state->mode = LENEXT;
8f63aa4c:	e3a03015 	mov	r3, #21
            state->extra = (unsigned)(here.op) & 15;
8f63aa50:	e58b1048 	str	r1, [r11, #72]	; 0x48
            state->mode = LENEXT;
8f63aa54:	e5cb3000 	strb	r3, [r11]
8f63aa58:	eafffdaf 	b	8f63a11c <inflate+0x684>
            state->mode = MEM;
8f63aa5c:	e3a0301e 	mov	r3, #30
            return Z_MEM_ERROR;
8f63aa60:	e3e07003 	mvn	r7, #3
            state->mode = MEM;
8f63aa64:	e5cb3000 	strb	r3, [r11]
            return Z_MEM_ERROR;
8f63aa68:	eafffcb2 	b	8f639d38 <inflate+0x2a0>
                        if (state->have == 0) {
8f63aa6c:	e35c0000 	cmp	r12, #0
                        DROPBITS(here.bits);
8f63aa70:	e1a06736 	lsr	r6, r6, r7
8f63aa74:	e0444007 	sub	r4, r4, r7
                        if (state->have == 0) {
8f63aa78:	0a00004c 	beq	8f63abb0 <inflate+0x1118>
                        len = state->lens[state->have - 1];
8f63aa7c:	e08b308c 	add	r3, r11, r12, lsl #1
                        copy = 3 + BITS(2);
8f63aa80:	e206a003 	and	r10, r6, #3
                        DROPBITS(2);
8f63aa84:	e2444002 	sub	r4, r4, #2
                        copy = 3 + BITS(2);
8f63aa88:	e28aa003 	add	r10, r10, #3
                        len = state->lens[state->have - 1];
8f63aa8c:	e1d376be 	ldrh	r7, [r3, #110]	; 0x6e
                        DROPBITS(2);
8f63aa90:	e1a06126 	lsr	r6, r6, #2
8f63aa94:	eaffff71 	b	8f63a860 <inflate+0xdc8>
8f63aa98:	8f74221c 	.word	0x8f74221c
8f63aa9c:	8f70bf06 	.word	0x8f70bf06
            state->mode = CODELENS;
8f63aaa0:	e3a03012 	mov	r3, #18
8f63aaa4:	e1a0c000 	mov	r12, r0
            state->have = 0;
8f63aaa8:	e58b0068 	str	r0, [r11, #104]	; 0x68
            state->mode = CODELENS;
8f63aaac:	e5cb3000 	strb	r3, [r11]
8f63aab0:	eafffe0f 	b	8f63a2f4 <inflate+0x85c>
                RESTORE();
8f63aab4:	e59d3010 	ldr	r3, [r13, #16]
                return Z_NEED_DICT;
8f63aab8:	e3a07002 	mov	r7, #2
                RESTORE();
8f63aabc:	e5898000 	str	r8, [r9]
8f63aac0:	e5895004 	str	r5, [r9, #4]
8f63aac4:	e589300c 	str	r3, [r9, #12]
8f63aac8:	e59d300c 	ldr	r3, [r13, #12]
8f63aacc:	e5893010 	str	r3, [r9, #16]
8f63aad0:	e58b6038 	str	r6, [r11, #56]	; 0x38
8f63aad4:	e58b403c 	str	r4, [r11, #60]	; 0x3c
                return Z_NEED_DICT;
8f63aad8:	eafffc96 	b	8f639d38 <inflate+0x2a0>
            if (state->wbits == 0)
8f63aadc:	e59b2024 	ldr	r2, [r11, #36]	; 0x24
            DROPBITS(4);
8f63aae0:	e1a06226 	lsr	r6, r6, #4
            len = BITS(4) + 8;
8f63aae4:	e206300f 	and	r3, r6, #15
            if (state->wbits == 0)
8f63aae8:	e3520000 	cmp	r2, #0
            len = BITS(4) + 8;
8f63aaec:	e2833008 	add	r3, r3, #8
                state->wbits = len;
8f63aaf0:	058b3024 	streq	r3, [r11, #36]	; 0x24
            if (state->wbits == 0)
8f63aaf4:	0a000004 	beq	8f63ab0c <inflate+0x1074>
            else if (len > state->wbits) {
8f63aaf8:	e1520003 	cmp	r2, r3
                strm->msg = (char *)"invalid window size";
8f63aafc:	330b34f4 	movwcc	r3, #46324	; 0xb4f4
            DROPBITS(4);
8f63ab00:	32444004 	subcc	r4, r4, #4
                strm->msg = (char *)"invalid window size";
8f63ab04:	33483f70 	movtcc	r3, #36720	; 0x8f70
8f63ab08:	3afffc45 	bcc	8f639c24 <inflate+0x18c>
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
8f63ab0c:	e3a02000 	mov	r2, #0
            state->dmax = 1U << len;
8f63ab10:	e3a01001 	mov	r1, #1
8f63ab14:	e1a03311 	lsl	r3, r1, r3
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
8f63ab18:	e1a00002 	mov	r0, r2
8f63ab1c:	e1a01002 	mov	r1, r2
            state->dmax = 1U << len;
8f63ab20:	e58b3014 	str	r3, [r11, #20]
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
8f63ab24:	ebfff898 	bl	8f638d8c <adler32>
            state->mode = hold & 0x200 ? DICTID : TYPE;
8f63ab28:	e2166c02 	ands	r6, r6, #512	; 0x200
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
8f63ab2c:	e58b0018 	str	r0, [r11, #24]
8f63ab30:	e5890030 	str	r0, [r9, #48]	; 0x30
            state->mode = hold & 0x200 ? DICTID : TYPE;
8f63ab34:	1afffc41 	bne	8f639c40 <inflate+0x1a8>
8f63ab38:	e3a0300b 	mov	r3, #11
            INITBITS();
8f63ab3c:	e1a04006 	mov	r4, r6
            state->mode = hold & 0x200 ? DICTID : TYPE;
8f63ab40:	e5cb3000 	strb	r3, [r11]
        switch (state->mode) {
8f63ab44:	eafffc62 	b	8f639cd4 <inflate+0x23c>
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
8f63ab48:	e28ba070 	add	r10, r11, #112	; 0x70
8f63ab4c:	e28b306c 	add	r3, r11, #108	; 0x6c
            state->next = state->codes;
8f63ab50:	e28b1e53 	add	r1, r11, #1328	; 0x530
            state->lenbits = 9;
8f63ab54:	e3a00009 	mov	r0, #9
            state->next = state->codes;
8f63ab58:	e58b106c 	str	r1, [r11, #108]	; 0x6c
                                &(state->lenbits), state->work);
8f63ab5c:	e28b7e2f 	add	r7, r11, #752	; 0x2f0
            state->lencode = (const code FAR *)(state->next);
8f63ab60:	e58b104c 	str	r1, [r11, #76]	; 0x4c
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
8f63ab64:	e28b1054 	add	r1, r11, #84	; 0x54
            state->lenbits = 9;
8f63ab68:	e58b0054 	str	r0, [r11, #84]	; 0x54
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
8f63ab6c:	e3a00001 	mov	r0, #1
8f63ab70:	e88d0082 	stm	r13, {r1, r7}
8f63ab74:	e1a0100a 	mov	r1, r10
8f63ab78:	e58d3028 	str	r3, [r13, #40]	; 0x28
8f63ab7c:	ebfff95c 	bl	8f6390f4 <inflate_table>
            if (ret) {
8f63ab80:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f63ab84:	e3500000 	cmp	r0, #0
8f63ab88:	0a000017 	beq	8f63abec <inflate+0x1154>
                strm->msg = (char *)"invalid literal/lengths set";
8f63ab8c:	e30b35c0 	movw	r3, #46528	; 0xb5c0
8f63ab90:	e3483f70 	movt	r3, #36720	; 0x8f70
8f63ab94:	eafffc22 	b	8f639c24 <inflate+0x18c>
8f63ab98:	e59d300c 	ldr	r3, [r13, #12]
                INITBITS();
8f63ab9c:	e3a04000 	mov	r4, #0
8f63aba0:	e1a06004 	mov	r6, r4
8f63aba4:	e58d3014 	str	r3, [r13, #20]
8f63aba8:	eafffc58 	b	8f639d10 <inflate+0x278>
}
8f63abac:	ebffe003 	bl	8f632bc0 <__stack_chk_fail>
                        strm->msg = (char *)"invalid bit length repeat";
8f63abb0:	e30b357c 	movw	r3, #46460	; 0xb57c
8f63abb4:	e3483f70 	movt	r3, #36720	; 0x8f70
8f63abb8:	eafffc19 	b	8f639c24 <inflate+0x18c>
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
8f63abbc:	e59d3014 	ldr	r3, [r13, #20]
            INITBITS();
8f63abc0:	e1a07004 	mov	r7, r4
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
8f63abc4:	e59d200c 	ldr	r2, [r13, #12]
            INITBITS();
8f63abc8:	e1a06004 	mov	r6, r4
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
8f63abcc:	e043a002 	sub	r10, r3, r2
8f63abd0:	eafffccd 	b	8f639f0c <inflate+0x474>
8f63abd4:	e59d3014 	ldr	r3, [r13, #20]
                    DROPBITS(2);
8f63abd8:	e1a061a6 	lsr	r6, r6, #3
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
8f63abdc:	e59d200c 	ldr	r2, [r13, #12]
                    DROPBITS(2);
8f63abe0:	e2444003 	sub	r4, r4, #3
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
8f63abe4:	e043a002 	sub	r10, r3, r2
                    goto inf_leave;
8f63abe8:	eafffcc7 	b	8f639f0c <inflate+0x474>
            state->distcode = (const code FAR *)(state->next);
8f63abec:	e59b206c 	ldr	r2, [r11, #108]	; 0x6c
            state->distbits = 6;
8f63abf0:	e3a00006 	mov	r0, #6
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
8f63abf4:	e59b1060 	ldr	r1, [r11, #96]	; 0x60
            state->distbits = 6;
8f63abf8:	e58b0058 	str	r0, [r11, #88]	; 0x58
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
8f63abfc:	e3a00002 	mov	r0, #2
            state->distcode = (const code FAR *)(state->next);
8f63ac00:	e58b2050 	str	r2, [r11, #80]	; 0x50
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
8f63ac04:	e28b2058 	add	r2, r11, #88	; 0x58
8f63ac08:	e08a1081 	add	r1, r10, r1, lsl #1
8f63ac0c:	e88d0084 	stm	r13, {r2, r7}
8f63ac10:	e59b2064 	ldr	r2, [r11, #100]	; 0x64
8f63ac14:	ebfff936 	bl	8f6390f4 <inflate_table>
            if (ret) {
8f63ac18:	e2507000 	subs	r7, r0, #0
8f63ac1c:	0affff34 	beq	8f63a8f4 <inflate+0xe5c>
                strm->msg = (char *)"invalid distances set";
8f63ac20:	e30b35dc 	movw	r3, #46556	; 0xb5dc
8f63ac24:	e3483f70 	movt	r3, #36720	; 0x8f70
8f63ac28:	eafffbfd 	b	8f639c24 <inflate+0x18c>

8f63ac2c <inflateEnd>:

int ZEXPORT inflateEnd(strm)
z_streamp strm;
{
8f63ac2c:	e92d4010 	push	{r4, r14}
    struct inflate_state FAR *state;
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
8f63ac30:	e2504000 	subs	r4, r0, #0
{
8f63ac34:	e59f3088 	ldr	r3, [pc, #136]	; 8f63acc4 <inflateEnd+0x98>
8f63ac38:	e24dd008 	sub	r13, r13, #8
8f63ac3c:	e5933000 	ldr	r3, [r3]
8f63ac40:	e58d3004 	str	r3, [r13, #4]
8f63ac44:	e3a03000 	mov	r3, #0
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
8f63ac48:	0a00001a 	beq	8f63acb8 <inflateEnd+0x8c>
8f63ac4c:	e594101c 	ldr	r1, [r4, #28]
8f63ac50:	e3510000 	cmp	r1, #0
8f63ac54:	0a000017 	beq	8f63acb8 <inflateEnd+0x8c>
8f63ac58:	e5943024 	ldr	r3, [r4, #36]	; 0x24
8f63ac5c:	e3530000 	cmp	r3, #0
8f63ac60:	0a000014 	beq	8f63acb8 <inflateEnd+0x8c>
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (state->window != Z_NULL) ZFREE(strm, state->window);
8f63ac64:	e5912034 	ldr	r2, [r1, #52]	; 0x34
8f63ac68:	e3520000 	cmp	r2, #0
8f63ac6c:	0a000004 	beq	8f63ac84 <inflateEnd+0x58>
8f63ac70:	e1a01002 	mov	r1, r2
8f63ac74:	e5940028 	ldr	r0, [r4, #40]	; 0x28
8f63ac78:	e12fff33 	blx	r3
    ZFREE(strm, strm->state);
8f63ac7c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
8f63ac80:	e594101c 	ldr	r1, [r4, #28]
8f63ac84:	e5940028 	ldr	r0, [r4, #40]	; 0x28
8f63ac88:	e12fff33 	blx	r3
    strm->state = Z_NULL;
8f63ac8c:	e3a03000 	mov	r3, #0
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
8f63ac90:	e1a00003 	mov	r0, r3
    strm->state = Z_NULL;
8f63ac94:	e584301c 	str	r3, [r4, #28]
}
8f63ac98:	e59f3024 	ldr	r3, [pc, #36]	; 8f63acc4 <inflateEnd+0x98>
8f63ac9c:	e5932000 	ldr	r2, [r3]
8f63aca0:	e59d3004 	ldr	r3, [r13, #4]
8f63aca4:	e0332002 	eors	r2, r3, r2
8f63aca8:	e3a03000 	mov	r3, #0
8f63acac:	1a000003 	bne	8f63acc0 <inflateEnd+0x94>
8f63acb0:	e28dd008 	add	r13, r13, #8
8f63acb4:	e8bd8010 	pop	{r4, r15}
        return Z_STREAM_ERROR;
8f63acb8:	e3e00001 	mvn	r0, #1
8f63acbc:	eafffff5 	b	8f63ac98 <inflateEnd+0x6c>
}
8f63acc0:	ebffdfbe 	bl	8f632bc0 <__stack_chk_fail>
8f63acc4:	8f74221c 	.word	0x8f74221c

8f63acc8 <inflate_fast>:
      output space.
 */
void ZLIB_INTERNAL inflate_fast(strm, start)
z_streamp strm;
unsigned start;         /* inflate()'s starting value for strm->avail_out */
{
8f63acc8:	e59f3560 	ldr	r3, [pc, #1376]	; 8f63b230 <inflate_fast+0x568>
8f63accc:	e3e0c000 	mvn	r12, #0
8f63acd0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f63acd4:	e24dd054 	sub	r13, r13, #84	; 0x54
8f63acd8:	e5933000 	ldr	r3, [r3]
8f63acdc:	e58d304c 	str	r3, [r13, #76]	; 0x4c
8f63ace0:	e3a03000 	mov	r3, #0
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
8f63ace4:	e1c020d0 	ldrd	r2, [r0]
    state = (struct inflate_state FAR *)strm->state;
8f63ace8:	e590b01c 	ldr	r11, [r0, #28]
{
8f63acec:	e1a0a000 	mov	r10, r0
    in = strm->next_in - OFF;
8f63acf0:	e2428001 	sub	r8, r2, #1
    last = in + (strm->avail_in - 5);
8f63acf4:	e2433005 	sub	r3, r3, #5
8f63acf8:	e0883003 	add	r3, r8, r3
8f63acfc:	e58d3000 	str	r3, [r13]
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
8f63ad00:	e5903010 	ldr	r3, [r0, #16]
    out = strm->next_out - OFF;
8f63ad04:	e590000c 	ldr	r0, [r0, #12]
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
    wnext = state->wnext;
8f63ad08:	e59b5030 	ldr	r5, [r11, #48]	; 0x30
    beg = out - (start - strm->avail_out);
8f63ad0c:	e0431001 	sub	r1, r3, r1
    out = strm->next_out - OFF;
8f63ad10:	e2400001 	sub	r0, r0, #1
    end = out + (strm->avail_out - 257);
8f63ad14:	e2433c01 	sub	r3, r3, #256	; 0x100
    beg = out - (start - strm->avail_out);
8f63ad18:	e0802001 	add	r2, r0, r1
    end = out + (strm->avail_out - 257);
8f63ad1c:	e2433001 	sub	r3, r3, #1
    beg = out - (start - strm->avail_out);
8f63ad20:	e58d2014 	str	r2, [r13, #20]
    end = out + (strm->avail_out - 257);
8f63ad24:	e0803003 	add	r3, r0, r3
    window = state->window;
8f63ad28:	e59b2034 	ldr	r2, [r11, #52]	; 0x34
    end = out + (strm->avail_out - 257);
8f63ad2c:	e58d3004 	str	r3, [r13, #4]
    wsize = state->wsize;
8f63ad30:	e2453001 	sub	r3, r5, #1
8f63ad34:	e0823003 	add	r3, r2, r3
8f63ad38:	e58d302c 	str	r3, [r13, #44]	; 0x2c
    whave = state->whave;
8f63ad3c:	e59b302c 	ldr	r3, [r11, #44]	; 0x2c
    wsize = state->wsize;
8f63ad40:	e59b6028 	ldr	r6, [r11, #40]	; 0x28
8f63ad44:	e59be054 	ldr	r14, [r11, #84]	; 0x54
8f63ad48:	e59b4058 	ldr	r4, [r11, #88]	; 0x58
    window = state->window;
8f63ad4c:	e58d201c 	str	r2, [r13, #28]
    whave = state->whave;
8f63ad50:	e58d3018 	str	r3, [r13, #24]
8f63ad54:	e1e0ee1c 	mvn	r14, r12, lsl r14
    hold = state->hold;
8f63ad58:	e59b3038 	ldr	r3, [r11, #56]	; 0x38
    bits = state->bits;
8f63ad5c:	e59b203c 	ldr	r2, [r11, #60]	; 0x3c
    lcode = state->lencode;
8f63ad60:	e59b104c 	ldr	r1, [r11, #76]	; 0x4c
    dcode = state->distcode;
8f63ad64:	e59b9050 	ldr	r9, [r11, #80]	; 0x50
8f63ad68:	e58de008 	str	r14, [r13, #8]
8f63ad6c:	e1e0e41c 	mvn	r14, r12, lsl r4
    wnext = state->wnext;
8f63ad70:	e58d5010 	str	r5, [r13, #16]
8f63ad74:	e58de00c 	str	r14, [r13, #12]
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (wnext < op) {      /* wrap around window */
                        from += wsize + wnext - op;
8f63ad78:	e086e005 	add	r14, r6, r5
    wsize = state->wsize;
8f63ad7c:	e58d6020 	str	r6, [r13, #32]
                        from += wsize + wnext - op;
8f63ad80:	e58de028 	str	r14, [r13, #40]	; 0x28
                        if (state->sane) {
8f63ad84:	e28bea01 	add	r14, r11, #4096	; 0x1000
8f63ad88:	e58de024 	str	r14, [r13, #36]	; 0x24
        if (bits < 15) {
8f63ad8c:	e352000e 	cmp	r2, #14
8f63ad90:	8a000007 	bhi	8f63adb4 <inflate_fast+0xec>
            hold += (unsigned long)(PUP(in)) << bits;
8f63ad94:	e5d8e001 	ldrb	r14, [r8, #1]
            bits += 8;
8f63ad98:	e2824008 	add	r4, r2, #8
            hold += (unsigned long)(PUP(in)) << bits;
8f63ad9c:	e5d85002 	ldrb	r5, [r8, #2]
8f63ada0:	e2888002 	add	r8, r8, #2
            hold += (unsigned long)(PUP(in)) << bits;
8f63ada4:	e1a0e21e 	lsl	r14, r14, r2
            bits += 8;
8f63ada8:	e2822010 	add	r2, r2, #16
            hold += (unsigned long)(PUP(in)) << bits;
8f63adac:	e08ee415 	add	r14, r14, r5, lsl r4
8f63adb0:	e083300e 	add	r3, r3, r14
        here = lcode[hold & lmask];
8f63adb4:	e59de008 	ldr	r14, [r13, #8]
8f63adb8:	e003e00e 	and	r14, r3, r14
8f63adbc:	ea000005 	b	8f63add8 <inflate_fast+0x110>
        else if (op & 16) {                     /* length base */
8f63adc0:	e31e0010 	tst	r14, #16
8f63adc4:	1a000035 	bne	8f63aea0 <inflate_fast+0x1d8>
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
8f63adc8:	e31e0040 	tst	r14, #64	; 0x40
8f63adcc:	1a000086 	bne	8f63afec <inflate_fast+0x324>
            here = lcode[here.val + (hold & ((1U << op) - 1))];
8f63add0:	e1c3ee1c 	bic	r14, r3, r12, lsl r14
8f63add4:	e08ee004 	add	r14, r14, r4
8f63add8:	e081410e 	add	r4, r1, r14, lsl #2
8f63addc:	e7d1e10e 	ldrb	r14, [r1, r14, lsl #2]
        op = (unsigned)(here.bits);
8f63ade0:	e5d45001 	ldrb	r5, [r4, #1]
        if (op == 0) {                          /* literal */
8f63ade4:	e35e0000 	cmp	r14, #0
            here = lcode[here.val + (hold & ((1U << op) - 1))];
8f63ade8:	e1d440b2 	ldrh	r4, [r4, #2]
        hold >>= op;
8f63adec:	e1a03533 	lsr	r3, r3, r5
        bits -= op;
8f63adf0:	e0422005 	sub	r2, r2, r5
        if (op == 0) {                          /* literal */
8f63adf4:	1afffff1 	bne	8f63adc0 <inflate_fast+0xf8>
            PUP(out) = (unsigned char)(here.val);
8f63adf8:	e5c04001 	strb	r4, [r0, #1]
8f63adfc:	e2800001 	add	r0, r0, #1
        else {
            strm->msg = (char *)"invalid literal/length code";
            state->mode = BAD;
            break;
        }
    } while (in < last && out < end);
8f63ae00:	e59de000 	ldr	r14, [r13]
8f63ae04:	e59d4004 	ldr	r4, [r13, #4]
8f63ae08:	e158000e 	cmp	r8, r14
8f63ae0c:	31500004 	cmpcc	r0, r4
8f63ae10:	3affffdd 	bcc	8f63ad8c <inflate_fast+0xc4>
    hold &= (1U << bits) - 1;

    /* update state and return */
    strm->next_in = in + OFF;
    strm->next_out = out + OFF;
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
8f63ae14:	e59de000 	ldr	r14, [r13]
    in -= len;
8f63ae18:	e04811a2 	sub	r1, r8, r2, lsr #3
    hold &= (1U << bits) - 1;
8f63ae1c:	e3e0c000 	mvn	r12, #0
8f63ae20:	e2022007 	and	r2, r2, #7
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
8f63ae24:	e15e0001 	cmp	r14, r1
    hold &= (1U << bits) - 1;
8f63ae28:	e1c3321c 	bic	r3, r3, r12, lsl r2
    strm->next_in = in + OFF;
8f63ae2c:	e281c001 	add	r12, r1, #1
8f63ae30:	e58ac000 	str	r12, [r10]
    strm->next_out = out + OFF;
8f63ae34:	e280c001 	add	r12, r0, #1
8f63ae38:	e58ac00c 	str	r12, [r10, #12]
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
8f63ae3c:	959dc000 	ldrls	r12, [r13]
8f63ae40:	804e1001 	subhi	r1, r14, r1
8f63ae44:	82811005 	addhi	r1, r1, #5
8f63ae48:	9041100c 	subls	r1, r1, r12
8f63ae4c:	92611005 	rsbls	r1, r1, #5
8f63ae50:	e58a1004 	str	r1, [r10, #4]
    strm->avail_out = (unsigned)(out < end ?
8f63ae54:	e59d1004 	ldr	r1, [r13, #4]
8f63ae58:	e1500001 	cmp	r0, r1
                                 257 + (end - out) : 257 - (out - end));
8f63ae5c:	30410000 	subcc	r0, r1, r0
8f63ae60:	259d1004 	ldrcs	r1, [r13, #4]
8f63ae64:	32800c01 	addcc	r0, r0, #256	; 0x100
8f63ae68:	20400001 	subcs	r0, r0, r1
8f63ae6c:	22600c01 	rsbcs	r0, r0, #256	; 0x100
8f63ae70:	e2800001 	add	r0, r0, #1
    strm->avail_out = (unsigned)(out < end ?
8f63ae74:	e58a0010 	str	r0, [r10, #16]
    state->hold = hold;
8f63ae78:	e58b3038 	str	r3, [r11, #56]	; 0x38
    state->bits = bits;
    return;
}
8f63ae7c:	e59f33ac 	ldr	r3, [pc, #940]	; 8f63b230 <inflate_fast+0x568>
    state->bits = bits;
8f63ae80:	e58b203c 	str	r2, [r11, #60]	; 0x3c
}
8f63ae84:	e5932000 	ldr	r2, [r3]
8f63ae88:	e59d304c 	ldr	r3, [r13, #76]	; 0x4c
8f63ae8c:	e0332002 	eors	r2, r3, r2
8f63ae90:	e3a03000 	mov	r3, #0
8f63ae94:	1a0000e4 	bne	8f63b22c <inflate_fast+0x564>
8f63ae98:	e28dd054 	add	r13, r13, #84	; 0x54
8f63ae9c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
            if (op) {
8f63aea0:	e21e500f 	ands	r5, r14, #15
            len = (unsigned)(here.val);
8f63aea4:	e1a0e004 	mov	r14, r4
            if (op) {
8f63aea8:	0a000008 	beq	8f63aed0 <inflate_fast+0x208>
                if (bits < op) {
8f63aeac:	e1550002 	cmp	r5, r2
                    hold += (unsigned long)(PUP(in)) << bits;
8f63aeb0:	85d8e001 	ldrbhi	r14, [r8, #1]
8f63aeb4:	82888001 	addhi	r8, r8, #1
8f63aeb8:	8083321e 	addhi	r3, r3, r14, lsl r2
                    bits += 8;
8f63aebc:	82822008 	addhi	r2, r2, #8
                len += (unsigned)hold & ((1U << op) - 1);
8f63aec0:	e1c3e51c 	bic	r14, r3, r12, lsl r5
                bits -= op;
8f63aec4:	e0422005 	sub	r2, r2, r5
                len += (unsigned)hold & ((1U << op) - 1);
8f63aec8:	e084e00e 	add	r14, r4, r14
                hold >>= op;
8f63aecc:	e1a03533 	lsr	r3, r3, r5
            if (bits < 15) {
8f63aed0:	e352000e 	cmp	r2, #14
8f63aed4:	9a00004c 	bls	8f63b00c <inflate_fast+0x344>
            here = dcode[hold & dmask];
8f63aed8:	e59d400c 	ldr	r4, [r13, #12]
8f63aedc:	e0034004 	and	r4, r3, r4
8f63aee0:	ea000003 	b	8f63aef4 <inflate_fast+0x22c>
            else if ((op & 64) == 0) {          /* 2nd level distance code */
8f63aee4:	e3140040 	tst	r4, #64	; 0x40
8f63aee8:	1a000050 	bne	8f63b030 <inflate_fast+0x368>
                here = dcode[here.val + (hold & ((1U << op) - 1))];
8f63aeec:	e1c3441c 	bic	r4, r3, r12, lsl r4
8f63aef0:	e0844005 	add	r4, r4, r5
8f63aef4:	e0895104 	add	r5, r9, r4, lsl #2
8f63aef8:	e7d94104 	ldrb	r4, [r9, r4, lsl #2]
            op = (unsigned)(here.bits);
8f63aefc:	e5d56001 	ldrb	r6, [r5, #1]
            if (op & 16) {                      /* distance base */
8f63af00:	e3140010 	tst	r4, #16
                here = dcode[here.val + (hold & ((1U << op) - 1))];
8f63af04:	e1d550b2 	ldrh	r5, [r5, #2]
            hold >>= op;
8f63af08:	e1a03633 	lsr	r3, r3, r6
            bits -= op;
8f63af0c:	e0422006 	sub	r2, r2, r6
            if (op & 16) {                      /* distance base */
8f63af10:	0afffff3 	beq	8f63aee4 <inflate_fast+0x21c>
                op &= 15;                       /* number of extra bits */
8f63af14:	e204400f 	and	r4, r4, #15
                if (bits < op) {
8f63af18:	e1540002 	cmp	r4, r2
8f63af1c:	8a000049 	bhi	8f63b048 <inflate_fast+0x380>
                dist += (unsigned)hold & ((1U << op) - 1);
8f63af20:	e1c3641c 	bic	r6, r3, r12, lsl r4
                bits -= op;
8f63af24:	e0422004 	sub	r2, r2, r4
                hold >>= op;
8f63af28:	e1a03433 	lsr	r3, r3, r4
                op = (unsigned)(out - beg);     /* max distance in output */
8f63af2c:	e59d4014 	ldr	r4, [r13, #20]
                dist += (unsigned)hold & ((1U << op) - 1);
8f63af30:	e0867005 	add	r7, r6, r5
                op = (unsigned)(out - beg);     /* max distance in output */
8f63af34:	e0405004 	sub	r5, r0, r4
                if (dist > op) {                /* see if copy from window */
8f63af38:	e1570005 	cmp	r7, r5
8f63af3c:	9a00007f 	bls	8f63b140 <inflate_fast+0x478>
                    if (op > whave) {
8f63af40:	e59d6018 	ldr	r6, [r13, #24]
                    op = dist - op;             /* distance back in window */
8f63af44:	e0474005 	sub	r4, r7, r5
8f63af48:	e58d4030 	str	r4, [r13, #48]	; 0x30
                    if (op > whave) {
8f63af4c:	e1560004 	cmp	r6, r4
8f63af50:	2a000003 	bcs	8f63af64 <inflate_fast+0x29c>
                        if (state->sane) {
8f63af54:	e59d4024 	ldr	r4, [r13, #36]	; 0x24
8f63af58:	e5944bc0 	ldr	r4, [r4, #3008]	; 0xbc0
8f63af5c:	e3540000 	cmp	r4, #0
8f63af60:	1a0000a1 	bne	8f63b1ec <inflate_fast+0x524>
                    if (wnext == 0) {           /* very common case */
8f63af64:	e59d4010 	ldr	r4, [r13, #16]
8f63af68:	e3540000 	cmp	r4, #0
                    from = window - OFF;
8f63af6c:	e59d401c 	ldr	r4, [r13, #28]
8f63af70:	e2446001 	sub	r6, r4, #1
8f63af74:	e58d6034 	str	r6, [r13, #52]	; 0x34
                    if (wnext == 0) {           /* very common case */
8f63af78:	1a00003d 	bne	8f63b074 <inflate_fast+0x3ac>
                        if (op < len) {         /* some from window */
8f63af7c:	e59d4030 	ldr	r4, [r13, #48]	; 0x30
8f63af80:	e0455007 	sub	r5, r5, r7
8f63af84:	e15e0004 	cmp	r14, r4
                        from += wsize - op;
8f63af88:	e59d4020 	ldr	r4, [r13, #32]
8f63af8c:	e0844005 	add	r4, r4, r5
8f63af90:	e0864004 	add	r4, r6, r4
                        if (op < len) {         /* some from window */
8f63af94:	8a00009a 	bhi	8f63b204 <inflate_fast+0x53c>
                    while (len > 2) {
8f63af98:	e35e0002 	cmp	r14, #2
8f63af9c:	9a000008 	bls	8f63afc4 <inflate_fast+0x2fc>
                        PUP(out) = PUP(from);
8f63afa0:	e5d45001 	ldrb	r5, [r4, #1]
                        len -= 3;
8f63afa4:	e24ee003 	sub	r14, r14, #3
                    while (len > 2) {
8f63afa8:	e35e0002 	cmp	r14, #2
                        PUP(out) = PUP(from);
8f63afac:	e5c05001 	strb	r5, [r0, #1]
                        PUP(out) = PUP(from);
8f63afb0:	e5d45002 	ldrb	r5, [r4, #2]
8f63afb4:	e5c05002 	strb	r5, [r0, #2]
                        PUP(out) = PUP(from);
8f63afb8:	e5f45003 	ldrb	r5, [r4, #3]!
8f63afbc:	e5e05003 	strb	r5, [r0, #3]!
                    while (len > 2) {
8f63afc0:	8afffff6 	bhi	8f63afa0 <inflate_fast+0x2d8>
                    if (len) {
8f63afc4:	e35e0000 	cmp	r14, #0
8f63afc8:	0affff8c 	beq	8f63ae00 <inflate_fast+0x138>
                        if (len > 1)
8f63afcc:	e35e0002 	cmp	r14, #2
                        PUP(out) = PUP(from);
8f63afd0:	e5d4e001 	ldrb	r14, [r4, #1]
8f63afd4:	e5c0e001 	strb	r14, [r0, #1]
8f63afd8:	12800001 	addne	r0, r0, #1
                            PUP(out) = PUP(from);
8f63afdc:	05d4e002 	ldrbeq	r14, [r4, #2]
8f63afe0:	05c0e002 	strbeq	r14, [r0, #2]
8f63afe4:	02800002 	addeq	r0, r0, #2
8f63afe8:	eaffff84 	b	8f63ae00 <inflate_fast+0x138>
        else if (op & 32) {                     /* end-of-block */
8f63afec:	e31e0020 	tst	r14, #32
            strm->msg = (char *)"invalid literal/length code";
8f63aff0:	030b15f4 	movweq	r1, #46580	; 0xb5f4
            state->mode = TYPE;
8f63aff4:	13a0100b 	movne	r1, #11
            strm->msg = (char *)"invalid literal/length code";
8f63aff8:	03481f70 	movteq	r1, #36720	; 0x8f70
8f63affc:	058a1018 	streq	r1, [r10, #24]
            state->mode = BAD;
8f63b000:	03a0101d 	moveq	r1, #29
8f63b004:	e5cb1000 	strb	r1, [r11]
            break;
8f63b008:	eaffff81 	b	8f63ae14 <inflate_fast+0x14c>
                hold += (unsigned long)(PUP(in)) << bits;
8f63b00c:	e5d84001 	ldrb	r4, [r8, #1]
                bits += 8;
8f63b010:	e2825008 	add	r5, r2, #8
                hold += (unsigned long)(PUP(in)) << bits;
8f63b014:	e5d86002 	ldrb	r6, [r8, #2]
8f63b018:	e2888002 	add	r8, r8, #2
                hold += (unsigned long)(PUP(in)) << bits;
8f63b01c:	e1a04214 	lsl	r4, r4, r2
                bits += 8;
8f63b020:	e2822010 	add	r2, r2, #16
                hold += (unsigned long)(PUP(in)) << bits;
8f63b024:	e0844516 	add	r4, r4, r6, lsl r5
8f63b028:	e0833004 	add	r3, r3, r4
                bits += 8;
8f63b02c:	eaffffa9 	b	8f63aed8 <inflate_fast+0x210>
                strm->msg = (char *)"invalid distance code";
8f63b030:	e30b1610 	movw	r1, #46608	; 0xb610
8f63b034:	e3481f70 	movt	r1, #36720	; 0x8f70
8f63b038:	e58a1018 	str	r1, [r10, #24]
                state->mode = BAD;
8f63b03c:	e3a0101d 	mov	r1, #29
8f63b040:	e5cb1000 	strb	r1, [r11]
                break;
8f63b044:	eaffff72 	b	8f63ae14 <inflate_fast+0x14c>
                    hold += (unsigned long)(PUP(in)) << bits;
8f63b048:	e5d86001 	ldrb	r6, [r8, #1]
8f63b04c:	e0833216 	add	r3, r3, r6, lsl r2
                    bits += 8;
8f63b050:	e2826008 	add	r6, r2, #8
                    if (bits < op) {
8f63b054:	e1540006 	cmp	r4, r6
                    hold += (unsigned long)(PUP(in)) << bits;
8f63b058:	92888001 	addls	r8, r8, #1
                        bits += 8;
8f63b05c:	82822010 	addhi	r2, r2, #16
                        hold += (unsigned long)(PUP(in)) << bits;
8f63b060:	85d87002 	ldrbhi	r7, [r8, #2]
                    hold += (unsigned long)(PUP(in)) << bits;
8f63b064:	91a02006 	movls	r2, r6
                        hold += (unsigned long)(PUP(in)) << bits;
8f63b068:	82888002 	addhi	r8, r8, #2
8f63b06c:	80833617 	addhi	r3, r3, r7, lsl r6
                        bits += 8;
8f63b070:	eaffffaa 	b	8f63af20 <inflate_fast+0x258>
                    else if (wnext < op) {      /* wrap around window */
8f63b074:	e59d4010 	ldr	r4, [r13, #16]
8f63b078:	e0455007 	sub	r5, r5, r7
8f63b07c:	e59d6030 	ldr	r6, [r13, #48]	; 0x30
8f63b080:	e1540006 	cmp	r4, r6
8f63b084:	2a000043 	bcs	8f63b198 <inflate_fast+0x4d0>
                        op -= wnext;
8f63b088:	e0464004 	sub	r4, r6, r4
8f63b08c:	e58d4038 	str	r4, [r13, #56]	; 0x38
                        if (op < len) {         /* some from end of window */
8f63b090:	e15e0004 	cmp	r14, r4
                        from += wsize + wnext - op;
8f63b094:	e59d4028 	ldr	r4, [r13, #40]	; 0x28
8f63b098:	e59d6034 	ldr	r6, [r13, #52]	; 0x34
8f63b09c:	e0844005 	add	r4, r4, r5
8f63b0a0:	e0864004 	add	r4, r6, r4
                        if (op < len) {         /* some from end of window */
8f63b0a4:	9affffbb 	bls	8f63af98 <inflate_fast+0x2d0>
                            len -= op;
8f63b0a8:	e59d6010 	ldr	r6, [r13, #16]
8f63b0ac:	e58d8044 	str	r8, [r13, #68]	; 0x44
8f63b0b0:	e08ee006 	add	r14, r14, r6
8f63b0b4:	e59d6034 	ldr	r6, [r13, #52]	; 0x34
8f63b0b8:	e085e00e 	add	r14, r5, r14
8f63b0bc:	e59d5038 	ldr	r5, [r13, #56]	; 0x38
8f63b0c0:	e58de040 	str	r14, [r13, #64]	; 0x40
8f63b0c4:	e0845005 	add	r5, r4, r5
8f63b0c8:	e58d503c 	str	r5, [r13, #60]	; 0x3c
8f63b0cc:	e59d803c 	ldr	r8, [r13, #60]	; 0x3c
8f63b0d0:	e1a05000 	mov	r5, r0
                                PUP(out) = PUP(from);
8f63b0d4:	e5f4e001 	ldrb	r14, [r4, #1]!
                            } while (--op);
8f63b0d8:	e1540008 	cmp	r4, r8
                                PUP(out) = PUP(from);
8f63b0dc:	e5e5e001 	strb	r14, [r5, #1]!
                            } while (--op);
8f63b0e0:	1afffffb 	bne	8f63b0d4 <inflate_fast+0x40c>
                            if (wnext < len) {  /* some from start of window */
8f63b0e4:	e59d4010 	ldr	r4, [r13, #16]
8f63b0e8:	e59de040 	ldr	r14, [r13, #64]	; 0x40
8f63b0ec:	e58d6034 	str	r6, [r13, #52]	; 0x34
8f63b0f0:	e154000e 	cmp	r4, r14
                                PUP(out) = PUP(from);
8f63b0f4:	e59d4038 	ldr	r4, [r13, #56]	; 0x38
                            if (wnext < len) {  /* some from start of window */
8f63b0f8:	e59d8044 	ldr	r8, [r13, #68]	; 0x44
                                PUP(out) = PUP(from);
8f63b0fc:	e0805004 	add	r5, r0, r4
                            from = window - OFF;
8f63b100:	259d4034 	ldrcs	r4, [r13, #52]	; 0x34
                                PUP(out) = PUP(from);
8f63b104:	21a00005 	movcs	r0, r5
                            if (wnext < len) {  /* some from start of window */
8f63b108:	2affffa2 	bcs	8f63af98 <inflate_fast+0x2d0>
                                len -= op;
8f63b10c:	e59d4010 	ldr	r4, [r13, #16]
8f63b110:	e04ee004 	sub	r14, r14, r4
8f63b114:	e1a0400e 	mov	r4, r14
                                    PUP(out) = PUP(from);
8f63b118:	e5f6e001 	ldrb	r14, [r6, #1]!
8f63b11c:	e5e5e001 	strb	r14, [r5, #1]!
                                } while (--op);
8f63b120:	e59de02c 	ldr	r14, [r13, #44]	; 0x2c
8f63b124:	e156000e 	cmp	r6, r14
8f63b128:	1afffffa 	bne	8f63b118 <inflate_fast+0x450>
                                    PUP(out) = PUP(from);
8f63b12c:	e1a0e004 	mov	r14, r4
8f63b130:	e59d4030 	ldr	r4, [r13, #48]	; 0x30
8f63b134:	e0800004 	add	r0, r0, r4
                                from = out - dist;      /* rest from output */
8f63b138:	e0404007 	sub	r4, r0, r7
8f63b13c:	eaffff95 	b	8f63af98 <inflate_fast+0x2d0>
                    from = out - dist;          /* copy direct from output */
8f63b140:	e0404007 	sub	r4, r0, r7
                        PUP(out) = PUP(from);
8f63b144:	e5d45001 	ldrb	r5, [r4, #1]
                        len -= 3;
8f63b148:	e24ee003 	sub	r14, r14, #3
8f63b14c:	e1a07004 	mov	r7, r4
                    } while (len > 2);
8f63b150:	e35e0002 	cmp	r14, #2
8f63b154:	e1a06000 	mov	r6, r0
                        PUP(out) = PUP(from);
8f63b158:	e5c05001 	strb	r5, [r0, #1]
                        PUP(out) = PUP(from);
8f63b15c:	e5d45002 	ldrb	r5, [r4, #2]
8f63b160:	e5c05002 	strb	r5, [r0, #2]
                        PUP(out) = PUP(from);
8f63b164:	e5f45003 	ldrb	r5, [r4, #3]!
8f63b168:	e5e05003 	strb	r5, [r0, #3]!
                    } while (len > 2);
8f63b16c:	8afffff4 	bhi	8f63b144 <inflate_fast+0x47c>
                    if (len) {
8f63b170:	e35e0000 	cmp	r14, #0
8f63b174:	0affff21 	beq	8f63ae00 <inflate_fast+0x138>
                        PUP(out) = PUP(from);
8f63b178:	e5d70004 	ldrb	r0, [r7, #4]
                        if (len > 1)
8f63b17c:	e35e0002 	cmp	r14, #2
                        PUP(out) = PUP(from);
8f63b180:	e5c60004 	strb	r0, [r6, #4]
8f63b184:	12860004 	addne	r0, r6, #4
                            PUP(out) = PUP(from);
8f63b188:	05d70005 	ldrbeq	r0, [r7, #5]
8f63b18c:	05c60005 	strbeq	r0, [r6, #5]
8f63b190:	02860005 	addeq	r0, r6, #5
8f63b194:	eaffff19 	b	8f63ae00 <inflate_fast+0x138>
                        if (op < len) {         /* some from window */
8f63b198:	e59d4030 	ldr	r4, [r13, #48]	; 0x30
                        from += wnext - op;
8f63b19c:	e59d6034 	ldr	r6, [r13, #52]	; 0x34
                        if (op < len) {         /* some from window */
8f63b1a0:	e15e0004 	cmp	r14, r4
                        from += wnext - op;
8f63b1a4:	e59d4010 	ldr	r4, [r13, #16]
8f63b1a8:	e0844005 	add	r4, r4, r5
8f63b1ac:	e0864004 	add	r4, r6, r4
                        if (op < len) {         /* some from window */
8f63b1b0:	9affff78 	bls	8f63af98 <inflate_fast+0x2d0>
                            len -= op;
8f63b1b4:	e08ee005 	add	r14, r14, r5
8f63b1b8:	e59d5030 	ldr	r5, [r13, #48]	; 0x30
8f63b1bc:	e58de034 	str	r14, [r13, #52]	; 0x34
8f63b1c0:	e0846005 	add	r6, r4, r5
8f63b1c4:	e1a05000 	mov	r5, r0
                                PUP(out) = PUP(from);
8f63b1c8:	e5f4e001 	ldrb	r14, [r4, #1]!
                            } while (--op);
8f63b1cc:	e1540006 	cmp	r4, r6
                                PUP(out) = PUP(from);
8f63b1d0:	e5e5e001 	strb	r14, [r5, #1]!
                            } while (--op);
8f63b1d4:	1afffffb 	bne	8f63b1c8 <inflate_fast+0x500>
                                PUP(out) = PUP(from);
8f63b1d8:	e59d4030 	ldr	r4, [r13, #48]	; 0x30
8f63b1dc:	e59de034 	ldr	r14, [r13, #52]	; 0x34
8f63b1e0:	e0800004 	add	r0, r0, r4
                            from = out - dist;  /* rest from output */
8f63b1e4:	e0404007 	sub	r4, r0, r7
8f63b1e8:	eaffff6a 	b	8f63af98 <inflate_fast+0x2d0>
                            strm->msg =
8f63b1ec:	e30b1628 	movw	r1, #46632	; 0xb628
8f63b1f0:	e3481f70 	movt	r1, #36720	; 0x8f70
8f63b1f4:	e58a1018 	str	r1, [r10, #24]
                            state->mode = BAD;
8f63b1f8:	e3a0101d 	mov	r1, #29
8f63b1fc:	e5cb1000 	strb	r1, [r11]
                            break;
8f63b200:	eaffff03 	b	8f63ae14 <inflate_fast+0x14c>
                            len -= op;
8f63b204:	e08ee005 	add	r14, r14, r5
8f63b208:	e59d5030 	ldr	r5, [r13, #48]	; 0x30
8f63b20c:	e58de034 	str	r14, [r13, #52]	; 0x34
8f63b210:	e0846005 	add	r6, r4, r5
8f63b214:	e1a05000 	mov	r5, r0
                                PUP(out) = PUP(from);
8f63b218:	e5f4e001 	ldrb	r14, [r4, #1]!
                            } while (--op);
8f63b21c:	e1540006 	cmp	r4, r6
                                PUP(out) = PUP(from);
8f63b220:	e5e5e001 	strb	r14, [r5, #1]!
                            } while (--op);
8f63b224:	1afffffb 	bne	8f63b218 <inflate_fast+0x550>
8f63b228:	eaffffea 	b	8f63b1d8 <inflate_fast+0x510>
}
8f63b22c:	ebffde63 	bl	8f632bc0 <__stack_chk_fail>
8f63b230:	8f74221c 	.word	0x8f74221c

8f63b234 <zlib_alloc>:
{
	return free(addr);
}

static void *zlib_alloc(voidpf qpaque, uInt items, size_t size)
{
8f63b234:	e59f303c 	ldr	r3, [pc, #60]	; 8f63b278 <zlib_alloc+0x44>
8f63b238:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f63b23c:	e24dd00c 	sub	r13, r13, #12
8f63b240:	e5933000 	ldr	r3, [r3]
8f63b244:	e58d3004 	str	r3, [r13, #4]
8f63b248:	e3a03000 	mov	r3, #0
	return malloc(items * size);
8f63b24c:	e59f3024 	ldr	r3, [pc, #36]	; 8f63b278 <zlib_alloc+0x44>
8f63b250:	e5930000 	ldr	r0, [r3]
8f63b254:	e59d3004 	ldr	r3, [r13, #4]
8f63b258:	e0330000 	eors	r0, r3, r0
8f63b25c:	e3a03000 	mov	r3, #0
8f63b260:	1a000003 	bne	8f63b274 <zlib_alloc+0x40>
8f63b264:	e0000192 	mul	r0, r2, r1
}
8f63b268:	e28dd00c 	add	r13, r13, #12
8f63b26c:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return malloc(items * size);
8f63b270:	eaffe361 	b	8f633ffc <malloc>
8f63b274:	ebffde51 	bl	8f632bc0 <__stack_chk_fail>
8f63b278:	8f74221c 	.word	0x8f74221c

8f63b27c <zlib_free>:
{
8f63b27c:	e59f303c 	ldr	r3, [pc, #60]	; 8f63b2c0 <zlib_free+0x44>
8f63b280:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f63b284:	e24dd00c 	sub	r13, r13, #12
8f63b288:	e5933000 	ldr	r3, [r3]
8f63b28c:	e58d3004 	str	r3, [r13, #4]
8f63b290:	e3a03000 	mov	r3, #0
	return free(addr);
8f63b294:	e59f3024 	ldr	r3, [pc, #36]	; 8f63b2c0 <zlib_free+0x44>
8f63b298:	e5932000 	ldr	r2, [r3]
8f63b29c:	e59d3004 	ldr	r3, [r13, #4]
8f63b2a0:	e0332002 	eors	r2, r3, r2
8f63b2a4:	e3a03000 	mov	r3, #0
8f63b2a8:	1a000003 	bne	8f63b2bc <zlib_free+0x40>
8f63b2ac:	e1a00001 	mov	r0, r1
}
8f63b2b0:	e28dd00c 	add	r13, r13, #12
8f63b2b4:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	return free(addr);
8f63b2b8:	eaffe393 	b	8f63410c <free>
8f63b2bc:	ebffde3f 	bl	8f632bc0 <__stack_chk_fail>
8f63b2c0:	8f74221c 	.word	0x8f74221c

8f63b2c4 <decompress>:
 */
int decompress(unsigned char *in_buf, unsigned int in_len,
		       unsigned char *out_buf,
		       unsigned int out_buf_len,
		       unsigned int *pos,
		       unsigned int *out_len) {
8f63b2c4:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, r14}
	struct z_stream_s *stream;
	int rc = -1;
	int i;

	if (in_len < GZIP_HEADER_LEN) {
8f63b2c8:	e3510009 	cmp	r1, #9
		       unsigned int *out_len) {
8f63b2cc:	e24dd00c 	sub	r13, r13, #12
8f63b2d0:	e1a08003 	mov	r8, r3
8f63b2d4:	e59f31ac 	ldr	r3, [pc, #428]	; 8f63b488 <decompress+0x1c4>
8f63b2d8:	e59d7028 	ldr	r7, [r13, #40]	; 0x28
8f63b2dc:	e59d602c 	ldr	r6, [r13, #44]	; 0x2c
8f63b2e0:	e5933000 	ldr	r3, [r3]
8f63b2e4:	e58d3004 	str	r3, [r13, #4]
8f63b2e8:	e3a03000 	mov	r3, #0
	if (in_len < GZIP_HEADER_LEN) {
8f63b2ec:	9a00005a 	bls	8f63b45c <decompress+0x198>
		dprintf(INFO, "the input data is not a gzip package.\n");
		return rc;
	}
	if (out_buf_len < in_len) {
8f63b2f0:	e1510008 	cmp	r1, r8
8f63b2f4:	8a000053 	bhi	8f63b448 <decompress+0x184>
		dprintf(INFO, "the avaiable length of out_buf is not enough.\n");
		return rc;
	}

	stream = malloc(sizeof(*stream));
8f63b2f8:	e1a05000 	mov	r5, r0
8f63b2fc:	e3a00038 	mov	r0, #56	; 0x38
8f63b300:	e1a09002 	mov	r9, r2
8f63b304:	ebffe33c 	bl	8f633ffc <malloc>
	if (stream == NULL) {
8f63b308:	e2504000 	subs	r4, r0, #0
8f63b30c:	0a000057 	beq	8f63b470 <decompress+0x1ac>

	/* skip over gzip header */
	stream->next_in = in_buf + GZIP_HEADER_LEN;
	stream->avail_in = out_buf_len - GZIP_HEADER_LEN;
	/* skip over asciz filename */
	if (in_buf[3] & 0x8) {
8f63b310:	e5d53003 	ldrb	r3, [r5, #3]
	stream->zalloc = zlib_alloc;
8f63b314:	e30b2234 	movw	r2, #45620	; 0xb234
	stream->avail_out = out_buf_len;
8f63b318:	e5848010 	str	r8, [r4, #16]
	stream->zalloc = zlib_alloc;
8f63b31c:	e3482f63 	movt	r2, #36707	; 0x8f63
	if (in_buf[3] & 0x8) {
8f63b320:	e3130008 	tst	r3, #8
	stream->avail_in = out_buf_len - GZIP_HEADER_LEN;
8f63b324:	e248800a 	sub	r8, r8, #10
	stream->next_in = in_buf + GZIP_HEADER_LEN;
8f63b328:	e285300a 	add	r3, r5, #10
	stream->zalloc = zlib_alloc;
8f63b32c:	e5842020 	str	r2, [r4, #32]
	stream->next_out = out_buf;
8f63b330:	e584900c 	str	r9, [r4, #12]
	stream->zfree = zlib_free;
8f63b334:	e30b227c 	movw	r2, #45692	; 0xb27c
	stream->avail_in = out_buf_len - GZIP_HEADER_LEN;
8f63b338:	e5848004 	str	r8, [r4, #4]
	stream->zfree = zlib_free;
8f63b33c:	e3482f63 	movt	r2, #36707	; 0x8f63
	stream->next_in = in_buf + GZIP_HEADER_LEN;
8f63b340:	e5843000 	str	r3, [r4]
	stream->zfree = zlib_free;
8f63b344:	e5842024 	str	r2, [r4, #36]	; 0x24
	if (in_buf[3] & 0x8) {
8f63b348:	0a00000e 	beq	8f63b388 <decompress+0xc4>
8f63b34c:	e2851f42 	add	r1, r5, #264	; 0x108
8f63b350:	e2811002 	add	r1, r1, #2
8f63b354:	ea000006 	b	8f63b374 <decompress+0xb0>
		for (i = 0; i < GZIP_FILENAME_LIMIT && *stream->next_in++; i++) {
			if (stream->avail_in == 0) {
8f63b358:	e5942004 	ldr	r2, [r4, #4]
8f63b35c:	e3520000 	cmp	r2, #0
8f63b360:	0a00002e 	beq	8f63b420 <decompress+0x15c>
		for (i = 0; i < GZIP_FILENAME_LIMIT && *stream->next_in++; i++) {
8f63b364:	e1530001 	cmp	r3, r1
				dprintf(INFO, "header error\n");
				goto gunzip_end;
			}
			--stream->avail_in;
8f63b368:	e2422001 	sub	r2, r2, #1
8f63b36c:	e5842004 	str	r2, [r4, #4]
		for (i = 0; i < GZIP_FILENAME_LIMIT && *stream->next_in++; i++) {
8f63b370:	0a000004 	beq	8f63b388 <decompress+0xc4>
8f63b374:	e2833001 	add	r3, r3, #1
8f63b378:	e5843000 	str	r3, [r4]
8f63b37c:	e5532001 	ldrb	r2, [r3, #-1]
8f63b380:	e3520000 	cmp	r2, #0
8f63b384:	1afffff3 	bne	8f63b358 <decompress+0x94>
		}
	}

	rc = inflateInit2(stream, -MAX_WBITS);
8f63b388:	e3a03038 	mov	r3, #56	; 0x38
8f63b38c:	e30b2f80 	movw	r2, #49024	; 0xbf80
8f63b390:	e3e0100e 	mvn	r1, #14
8f63b394:	e3482f70 	movt	r2, #36720	; 0x8f70
8f63b398:	e1a00004 	mov	r0, r4
8f63b39c:	ebfff978 	bl	8f639984 <inflateInit2_>
	if (rc != Z_OK) {
8f63b3a0:	e2508000 	subs	r8, r0, #0
8f63b3a4:	1a000019 	bne	8f63b410 <decompress+0x14c>
		dprintf(INFO, "inflateInit2 failed!\n");
		goto gunzip_end;
	}

	rc = inflate(stream, 0);
8f63b3a8:	e1a01008 	mov	r1, r8
8f63b3ac:	e1a00004 	mov	r0, r4
8f63b3b0:	ebfff9b8 	bl	8f639a98 <inflate>
	/* Z_STREAM_END is "we unpacked it all" */
	if (rc == Z_STREAM_END) {
		rc = 0;
	} else if (rc != Z_OK) {
8f63b3b4:	e3500001 	cmp	r0, #1
8f63b3b8:	8a00001d 	bhi	8f63b434 <decompress+0x170>
		dprintf(INFO, "uncompression error \n");
		rc = -1;
	}

	inflateEnd(stream);
8f63b3bc:	e1a00004 	mov	r0, r4
8f63b3c0:	ebfffe19 	bl	8f63ac2c <inflateEnd>
	if (pos)
8f63b3c4:	e3570000 	cmp	r7, #0
		/* alculation the length of the compressed package */
		*pos = stream->next_in - in_buf + 8;
8f63b3c8:	15943000 	ldrne	r3, [r4]
8f63b3cc:	10435005 	subne	r5, r3, r5
8f63b3d0:	12855008 	addne	r5, r5, #8
8f63b3d4:	15875000 	strne	r5, [r7]

	if (out_len)
8f63b3d8:	e3560000 	cmp	r6, #0
		*out_len = stream->total_out;
8f63b3dc:	15943014 	ldrne	r3, [r4, #20]
8f63b3e0:	15863000 	strne	r3, [r6]

gunzip_end:
	free(stream);
8f63b3e4:	e1a00004 	mov	r0, r4
8f63b3e8:	ebffe347 	bl	8f63410c <free>
	return rc; /* returns 0 if decompressed successful */
}
8f63b3ec:	e59f3094 	ldr	r3, [pc, #148]	; 8f63b488 <decompress+0x1c4>
8f63b3f0:	e5932000 	ldr	r2, [r3]
8f63b3f4:	e59d3004 	ldr	r3, [r13, #4]
8f63b3f8:	e0332002 	eors	r2, r3, r2
8f63b3fc:	e3a03000 	mov	r3, #0
8f63b400:	1a00001f 	bne	8f63b484 <decompress+0x1c0>
8f63b404:	e1a00008 	mov	r0, r8
8f63b408:	e28dd00c 	add	r13, r13, #12
8f63b40c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, r15}
		dprintf(INFO, "inflateInit2 failed!\n");
8f63b410:	e30b0f98 	movw	r0, #49048	; 0xbf98
8f63b414:	e3480f70 	movt	r0, #36720	; 0x8f70
8f63b418:	ebffdd55 	bl	8f632974 <_dprintf>
		goto gunzip_end;
8f63b41c:	eafffff0 	b	8f63b3e4 <decompress+0x120>
				dprintf(INFO, "header error\n");
8f63b420:	e30b0f88 	movw	r0, #49032	; 0xbf88
8f63b424:	e3480f70 	movt	r0, #36720	; 0x8f70
8f63b428:	ebffdd51 	bl	8f632974 <_dprintf>
	int rc = -1;
8f63b42c:	e3e08000 	mvn	r8, #0
				goto gunzip_end;
8f63b430:	eaffffeb 	b	8f63b3e4 <decompress+0x120>
		dprintf(INFO, "uncompression error \n");
8f63b434:	e30b0fb0 	movw	r0, #49072	; 0xbfb0
8f63b438:	e3480f70 	movt	r0, #36720	; 0x8f70
8f63b43c:	ebffdd4c 	bl	8f632974 <_dprintf>
		rc = -1;
8f63b440:	e3e08000 	mvn	r8, #0
8f63b444:	eaffffdc 	b	8f63b3bc <decompress+0xf8>
		dprintf(INFO, "the avaiable length of out_buf is not enough.\n");
8f63b448:	e30b0f30 	movw	r0, #48944	; 0xbf30
8f63b44c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f63b450:	ebffdd47 	bl	8f632974 <_dprintf>
		return rc;
8f63b454:	e3e08000 	mvn	r8, #0
8f63b458:	eaffffe3 	b	8f63b3ec <decompress+0x128>
		dprintf(INFO, "the input data is not a gzip package.\n");
8f63b45c:	e30b0f08 	movw	r0, #48904	; 0xbf08
8f63b460:	e3480f70 	movt	r0, #36720	; 0x8f70
8f63b464:	ebffdd42 	bl	8f632974 <_dprintf>
		return rc;
8f63b468:	e3e08000 	mvn	r8, #0
8f63b46c:	eaffffde 	b	8f63b3ec <decompress+0x128>
		dprintf(INFO, "allocating z_stream failed.\n");
8f63b470:	e30b0f60 	movw	r0, #48992	; 0xbf60
8f63b474:	e3480f70 	movt	r0, #36720	; 0x8f70
8f63b478:	ebffdd3d 	bl	8f632974 <_dprintf>
		return rc;
8f63b47c:	e3e08000 	mvn	r8, #0
8f63b480:	eaffffd9 	b	8f63b3ec <decompress+0x128>
}
8f63b484:	ebffddcd 	bl	8f632bc0 <__stack_chk_fail>
8f63b488:	8f74221c 	.word	0x8f74221c

8f63b48c <is_gzip_package>:
/* check if the input "buf" file was a gzip package.
 * Return true if the input "buf" is a gzip package.
 */
int is_gzip_package(unsigned char *buf, unsigned int len)
{
	if (len < 10 || !buf || buf[0] != 0x1f ||
8f63b48c:	e3500000 	cmp	r0, #0
8f63b490:	13510009 	cmpne	r1, #9
{
8f63b494:	e59f3070 	ldr	r3, [pc, #112]	; 8f63b50c <is_gzip_package+0x80>
8f63b498:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f63b49c:	e24dd00c 	sub	r13, r13, #12
8f63b4a0:	e5933000 	ldr	r3, [r3]
8f63b4a4:	e58d3004 	str	r3, [r13, #4]
8f63b4a8:	e3a03000 	mov	r3, #0
	if (len < 10 || !buf || buf[0] != 0x1f ||
8f63b4ac:	93a01001 	movls	r1, #1
8f63b4b0:	83a01000 	movhi	r1, #0
8f63b4b4:	9a000002 	bls	8f63b4c4 <is_gzip_package+0x38>
8f63b4b8:	e5d03000 	ldrb	r3, [r0]
8f63b4bc:	e353001f 	cmp	r3, #31
8f63b4c0:	0a000008 	beq	8f63b4e8 <is_gzip_package+0x5c>
		buf[1] != 0x8b || buf[2] != 0x08)
	{
		return false;
8f63b4c4:	e3a00000 	mov	r0, #0
	}

	return true;
}
8f63b4c8:	e59f303c 	ldr	r3, [pc, #60]	; 8f63b50c <is_gzip_package+0x80>
8f63b4cc:	e5932000 	ldr	r2, [r3]
8f63b4d0:	e59d3004 	ldr	r3, [r13, #4]
8f63b4d4:	e0332002 	eors	r2, r3, r2
8f63b4d8:	e3a03000 	mov	r3, #0
8f63b4dc:	1a000009 	bne	8f63b508 <is_gzip_package+0x7c>
8f63b4e0:	e28dd00c 	add	r13, r13, #12
8f63b4e4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
	if (len < 10 || !buf || buf[0] != 0x1f ||
8f63b4e8:	e5d03001 	ldrb	r3, [r0, #1]
8f63b4ec:	e353008b 	cmp	r3, #139	; 0x8b
		return false;
8f63b4f0:	11a00001 	movne	r0, r1
		buf[1] != 0x8b || buf[2] != 0x08)
8f63b4f4:	05d00002 	ldrbeq	r0, [r0, #2]
8f63b4f8:	02400008 	subeq	r0, r0, #8
8f63b4fc:	016f0f10 	clzeq	r0, r0
8f63b500:	01a002a0 	lsreq	r0, r0, #5
8f63b504:	eaffffef 	b	8f63b4c8 <is_gzip_package+0x3c>
}
8f63b508:	ebffddac 	bl	8f632bc0 <__stack_chk_fail>
8f63b50c:	8f74221c 	.word	0x8f74221c

8f63b510 <ext2_unmount>:
    free(ext2);
    return err;
}

status_t ext2_unmount(fscookie *cookie)
{
8f63b510:	e59f3054 	ldr	r3, [pc, #84]	; 8f63b56c <ext2_unmount+0x5c>
8f63b514:	e92d4010 	push	{r4, r14}
8f63b518:	e1a04000 	mov	r4, r0
8f63b51c:	e24dd008 	sub	r13, r13, #8
    // free it up
    ext2_t *ext2 = (ext2_t *)cookie;

    bcache_destroy(ext2->cache);
8f63b520:	e5900004 	ldr	r0, [r0, #4]
{
8f63b524:	e5933000 	ldr	r3, [r3]
8f63b528:	e58d3004 	str	r3, [r13, #4]
8f63b52c:	e3a03000 	mov	r3, #0
    bcache_destroy(ext2->cache);
8f63b530:	eb00051f 	bl	8f63c9b4 <bcache_destroy>
    free(ext2->gd);
8f63b534:	e594040c 	ldr	r0, [r4, #1036]	; 0x40c
8f63b538:	ebffe2f3 	bl	8f63410c <free>
    free(ext2);
8f63b53c:	e1a00004 	mov	r0, r4
8f63b540:	ebffe2f1 	bl	8f63410c <free>

    return 0;
}
8f63b544:	e59f3020 	ldr	r3, [pc, #32]	; 8f63b56c <ext2_unmount+0x5c>
8f63b548:	e5932000 	ldr	r2, [r3]
8f63b54c:	e59d3004 	ldr	r3, [r13, #4]
8f63b550:	e0332002 	eors	r2, r3, r2
8f63b554:	e3a03000 	mov	r3, #0
8f63b558:	1a000002 	bne	8f63b568 <ext2_unmount+0x58>
8f63b55c:	e3a00000 	mov	r0, #0
8f63b560:	e28dd008 	add	r13, r13, #8
8f63b564:	e8bd8010 	pop	{r4, r15}
8f63b568:	ebffdd94 	bl	8f632bc0 <__stack_chk_fail>
8f63b56c:	8f74221c 	.word	0x8f74221c

8f63b570 <ext2_load_inode>:
    *block_offset = offset % EXT2_BLOCK_SIZE(ext2->sb);
    *block += offset / EXT2_BLOCK_SIZE(ext2->sb);
}

int ext2_load_inode(ext2_t *ext2, inodenum_t num, struct ext2_inode *inode)
{
8f63b570:	e92d41f0 	push	{r4, r5, r6, r7, r8, r14}
8f63b574:	e1a03001 	mov	r3, r1
8f63b578:	e1a04000 	mov	r4, r0
8f63b57c:	e5901030 	ldr	r1, [r0, #48]	; 0x30
8f63b580:	e2430001 	sub	r0, r3, #1
8f63b584:	e59f30ac 	ldr	r3, [pc, #172]	; 8f63b638 <ext2_load_inode+0xc8>
8f63b588:	e24dd008 	sub	r13, r13, #8
8f63b58c:	e1a07002 	mov	r7, r2
8f63b590:	e5933000 	ldr	r3, [r3]
8f63b594:	e58d3004 	str	r3, [r13, #4]
8f63b598:	e3a03000 	mov	r3, #0
    uint32_t group = num / ext2->sb.s_inodes_per_group;
8f63b59c:	fa000624 	blx	8f63ce34 <__aeabi_uidivmod>
    size_t offset = (num % EXT2_INODES_PER_GROUP(ext2->sb)) * EXT2_INODE_SIZE(ext2->sb);
8f63b5a0:	e5942054 	ldr	r2, [r4, #84]	; 0x54
    *block = ext2->gd[group].bg_inode_table;
8f63b5a4:	e594340c 	ldr	r3, [r4, #1036]	; 0x40c
    size_t offset = (num % EXT2_INODES_PER_GROUP(ext2->sb)) * EXT2_INODE_SIZE(ext2->sb);
8f63b5a8:	e3520000 	cmp	r2, #0
    *block_offset = offset % EXT2_BLOCK_SIZE(ext2->sb);
8f63b5ac:	e5948020 	ldr	r8, [r4, #32]
    size_t offset = (num % EXT2_INODES_PER_GROUP(ext2->sb)) * EXT2_INODE_SIZE(ext2->sb);
8f63b5b0:	11d456b0 	ldrhne	r5, [r4, #96]	; 0x60
8f63b5b4:	03a05080 	moveq	r5, #128	; 0x80
8f63b5b8:	e0050195 	mul	r5, r5, r1
    *block = ext2->gd[group].bg_inode_table;
8f63b5bc:	e0833280 	add	r3, r3, r0, lsl #5

    LTRACEF("bnum %u, offset %zd\n", bnum, block_offset);

    /* get a pointer to the cache block */
    void *cache_ptr;
    err = bcache_get_block(ext2->cache, &cache_ptr, bnum);
8f63b5c0:	e1a0100d 	mov	r1, r13
8f63b5c4:	e5940004 	ldr	r0, [r4, #4]
    *block = ext2->gd[group].bg_inode_table;
8f63b5c8:	e5936008 	ldr	r6, [r3, #8]
    *block += offset / EXT2_BLOCK_SIZE(ext2->sb);
8f63b5cc:	e288300a 	add	r3, r8, #10
8f63b5d0:	e0866335 	add	r6, r6, r5, lsr r3
    err = bcache_get_block(ext2->cache, &cache_ptr, bnum);
8f63b5d4:	e1a02006 	mov	r2, r6
8f63b5d8:	eb000545 	bl	8f63caf4 <bcache_get_block>
    if (err < 0)
8f63b5dc:	e3500000 	cmp	r0, #0
8f63b5e0:	ba00000b 	blt	8f63b614 <ext2_load_inode+0xa4>
    *block_offset = offset % EXT2_BLOCK_SIZE(ext2->sb);
8f63b5e4:	e3a01b3f 	mov	r1, #64512	; 0xfc00
8f63b5e8:	e34f1fff 	movt	r1, #65535	; 0xffff
        return err;

    /* copy the inode out */
    memcpy(inode, (uint8_t *)cache_ptr + block_offset, sizeof(struct ext2_inode));
8f63b5ec:	e3a02080 	mov	r2, #128	; 0x80
8f63b5f0:	e1a00007 	mov	r0, r7
    *block_offset = offset % EXT2_BLOCK_SIZE(ext2->sb);
8f63b5f4:	e1c55811 	bic	r5, r5, r1, lsl r8
    memcpy(inode, (uint8_t *)cache_ptr + block_offset, sizeof(struct ext2_inode));
8f63b5f8:	e59d1000 	ldr	r1, [r13]
8f63b5fc:	e0811005 	add	r1, r1, r5
8f63b600:	ebffe2ec 	bl	8f6341b8 <memcpy>

    /* put the cache block */
    bcache_put_block(ext2->cache, bnum);
8f63b604:	e5940004 	ldr	r0, [r4, #4]
8f63b608:	e1a01006 	mov	r1, r6
8f63b60c:	eb00055c 	bl	8f63cb84 <bcache_put_block>
    /* endian swap it */
    endian_swap_inode(inode);

    LTRACEF("read inode: mode 0x%x, size %d\n", inode->i_mode, inode->i_size);

    return 0;
8f63b610:	e3a00000 	mov	r0, #0
}
8f63b614:	e59f301c 	ldr	r3, [pc, #28]	; 8f63b638 <ext2_load_inode+0xc8>
8f63b618:	e5932000 	ldr	r2, [r3]
8f63b61c:	e59d3004 	ldr	r3, [r13, #4]
8f63b620:	e0332002 	eors	r2, r3, r2
8f63b624:	e3a03000 	mov	r3, #0
8f63b628:	1a000001 	bne	8f63b634 <ext2_load_inode+0xc4>
8f63b62c:	e28dd008 	add	r13, r13, #8
8f63b630:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, r15}
8f63b634:	ebffdd61 	bl	8f632bc0 <__stack_chk_fail>
8f63b638:	8f74221c 	.word	0x8f74221c

8f63b63c <ext2_mount>:
{
8f63b63c:	e59f315c 	ldr	r3, [pc, #348]	; 8f63b7a0 <ext2_mount+0x164>
8f63b640:	e92d4070 	push	{r4, r5, r6, r14}
8f63b644:	e1a05000 	mov	r5, r0
8f63b648:	e24dd010 	sub	r13, r13, #16
    ext2_t *ext2 = malloc(sizeof(ext2_t));
8f63b64c:	e3a00e49 	mov	r0, #1168	; 0x490
{
8f63b650:	e5933000 	ldr	r3, [r3]
8f63b654:	e58d300c 	str	r3, [r13, #12]
8f63b658:	e3a03000 	mov	r3, #0
8f63b65c:	e1a06001 	mov	r6, r1
    ext2_t *ext2 = malloc(sizeof(ext2_t));
8f63b660:	ebffe265 	bl	8f633ffc <malloc>
    err = bio_read(dev, &ext2->sb, 1024, sizeof(struct ext2_super_block));
8f63b664:	e3a03b01 	mov	r3, #1024	; 0x400
8f63b668:	e3a02b01 	mov	r2, #1024	; 0x400
8f63b66c:	e58d3000 	str	r3, [r13]
8f63b670:	e3a03000 	mov	r3, #0
    ext2->dev = dev;
8f63b674:	e1a01000 	mov	r1, r0
    ext2_t *ext2 = malloc(sizeof(ext2_t));
8f63b678:	e1a04000 	mov	r4, r0
    ext2->dev = dev;
8f63b67c:	e4815008 	str	r5, [r1], #8
    err = bio_read(dev, &ext2->sb, 1024, sizeof(struct ext2_super_block));
8f63b680:	e1a00005 	mov	r0, r5
8f63b684:	ebffeecb 	bl	8f6371b8 <bio_read>
    if (err < 0)
8f63b688:	e2505000 	subs	r5, r0, #0
8f63b68c:	ba000037 	blt	8f63b770 <ext2_mount+0x134>
    if (ext2->sb.s_magic != EXT2_SUPER_MAGIC) {
8f63b690:	e1d424b0 	ldrh	r2, [r4, #64]	; 0x40
8f63b694:	e30e3f53 	movw	r3, #61267	; 0xef53
8f63b698:	e1520003 	cmp	r2, r3
8f63b69c:	1a000038 	bne	8f63b784 <ext2_mount+0x148>
    ext2->s_group_count = (ext2->sb.s_blocks_count + ext2->sb.s_blocks_per_group - 1) / ext2->sb.s_blocks_per_group;
8f63b6a0:	e5941028 	ldr	r1, [r4, #40]	; 0x28
8f63b6a4:	e594000c 	ldr	r0, [r4, #12]
8f63b6a8:	e0810000 	add	r0, r1, r0
8f63b6ac:	e2400001 	sub	r0, r0, #1
8f63b6b0:	fa000548 	blx	8f63cbd8 <__udivsi3>
    if (ext2->sb.s_rev_level > EXT2_DYNAMIC_REV) {
8f63b6b4:	e5943054 	ldr	r3, [r4, #84]	; 0x54
8f63b6b8:	e3530001 	cmp	r3, #1
    ext2->s_group_count = (ext2->sb.s_blocks_count + ext2->sb.s_blocks_per_group - 1) / ext2->sb.s_blocks_per_group;
8f63b6bc:	e5840408 	str	r0, [r4, #1032]	; 0x408
    if (ext2->sb.s_rev_level > EXT2_DYNAMIC_REV) {
8f63b6c0:	8a000031 	bhi	8f63b78c <ext2_mount+0x150>
    if (ext2->sb.s_feature_ro_compat & ~(EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER|EXT2_FEATURE_RO_COMPAT_LARGE_FILE)) {
8f63b6c4:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
8f63b6c8:	e3d33003 	bics	r3, r3, #3
8f63b6cc:	1a00002a 	bne	8f63b77c <ext2_mount+0x140>
    ext2->gd = malloc(sizeof(struct ext2_group_desc) * ext2->s_group_count);
8f63b6d0:	e1a00280 	lsl	r0, r0, #5
8f63b6d4:	ebffe248 	bl	8f633ffc <malloc>
    err = bio_read(ext2->dev, (void *)ext2->gd,
8f63b6d8:	e5943020 	ldr	r3, [r4, #32]
8f63b6dc:	e594c408 	ldr	r12, [r4, #1032]	; 0x408
8f63b6e0:	e3530002 	cmp	r3, #2
8f63b6e4:	e3a03000 	mov	r3, #0
8f63b6e8:	e1a0c28c 	lsl	r12, r12, #5
8f63b6ec:	13a02b02 	movne	r2, #2048	; 0x800
8f63b6f0:	03a02a01 	moveq	r2, #4096	; 0x1000
8f63b6f4:	e58dc000 	str	r12, [r13]
    ext2->gd = malloc(sizeof(struct ext2_group_desc) * ext2->s_group_count);
8f63b6f8:	e1a01000 	mov	r1, r0
    err = bio_read(ext2->dev, (void *)ext2->gd,
8f63b6fc:	e5940000 	ldr	r0, [r4]
    ext2->gd = malloc(sizeof(struct ext2_group_desc) * ext2->s_group_count);
8f63b700:	e584140c 	str	r1, [r4, #1036]	; 0x40c
    err = bio_read(ext2->dev, (void *)ext2->gd,
8f63b704:	ebffeeab 	bl	8f6371b8 <bio_read>
    if (err < 0) {
8f63b708:	e3500000 	cmp	r0, #0
8f63b70c:	ba000020 	blt	8f63b794 <ext2_mount+0x158>
    ext2->cache = bcache_create(ext2->dev, EXT2_BLOCK_SIZE(ext2->sb), 4);
8f63b710:	e5943020 	ldr	r3, [r4, #32]
8f63b714:	e3a01b01 	mov	r1, #1024	; 0x400
8f63b718:	e3a02004 	mov	r2, #4
8f63b71c:	e5940000 	ldr	r0, [r4]
8f63b720:	e1a01311 	lsl	r1, r1, r3
8f63b724:	eb000464 	bl	8f63c8bc <bcache_create>
    err = ext2_load_inode(ext2, EXT2_ROOT_INO, &ext2->root_inode);
8f63b728:	e2842e41 	add	r2, r4, #1040	; 0x410
8f63b72c:	e3a01002 	mov	r1, #2
    ext2->cache = bcache_create(ext2->dev, EXT2_BLOCK_SIZE(ext2->sb), 4);
8f63b730:	e5840004 	str	r0, [r4, #4]
    err = ext2_load_inode(ext2, EXT2_ROOT_INO, &ext2->root_inode);
8f63b734:	e1a00004 	mov	r0, r4
8f63b738:	ebffff8c 	bl	8f63b570 <ext2_load_inode>
    if (err < 0)
8f63b73c:	e2505000 	subs	r5, r0, #0
8f63b740:	ba00000a 	blt	8f63b770 <ext2_mount+0x134>
    return 0;
8f63b744:	e3a05000 	mov	r5, #0
    *cookie = (fscookie *)ext2;
8f63b748:	e5864000 	str	r4, [r6]
}
8f63b74c:	e59f304c 	ldr	r3, [pc, #76]	; 8f63b7a0 <ext2_mount+0x164>
8f63b750:	e5932000 	ldr	r2, [r3]
8f63b754:	e59d300c 	ldr	r3, [r13, #12]
8f63b758:	e0332002 	eors	r2, r3, r2
8f63b75c:	e3a03000 	mov	r3, #0
8f63b760:	1a00000d 	bne	8f63b79c <ext2_mount+0x160>
8f63b764:	e1a00005 	mov	r0, r5
8f63b768:	e28dd010 	add	r13, r13, #16
8f63b76c:	e8bd8070 	pop	{r4, r5, r6, r15}
    free(ext2);
8f63b770:	e1a00004 	mov	r0, r4
8f63b774:	ebffe264 	bl	8f63410c <free>
    return err;
8f63b778:	eafffff3 	b	8f63b74c <ext2_mount+0x110>
        return err;
8f63b77c:	e3e05002 	mvn	r5, #2
8f63b780:	eafffff1 	b	8f63b74c <ext2_mount+0x110>
        return err;
8f63b784:	e3e05000 	mvn	r5, #0
8f63b788:	eaffffef 	b	8f63b74c <ext2_mount+0x110>
        return err;
8f63b78c:	e3e05001 	mvn	r5, #1
8f63b790:	eaffffed 	b	8f63b74c <ext2_mount+0x110>
        return err;
8f63b794:	e3e05003 	mvn	r5, #3
8f63b798:	eaffffeb 	b	8f63b74c <ext2_mount+0x110>
}
8f63b79c:	ebffdd07 	bl	8f632bc0 <__stack_chk_fail>
8f63b7a0:	8f74221c 	.word	0x8f74221c

8f63b7a4 <ext2_init>:
    .readdir = ext2_read_directory,
    .closedir = ext2_close_directory
};

void ext2_init(void)
{
8f63b7a4:	e59f3048 	ldr	r3, [pc, #72]	; 8f63b7f4 <ext2_init+0x50>
8f63b7a8:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f63b7ac:	e24dd00c 	sub	r13, r13, #12
8f63b7b0:	e5933000 	ldr	r3, [r3]
8f63b7b4:	e58d3004 	str	r3, [r13, #4]
8f63b7b8:	e3a03000 	mov	r3, #0
    fs_register_type("ext2", &ext2_api);
8f63b7bc:	e59f3030 	ldr	r3, [pc, #48]	; 8f63b7f4 <ext2_init+0x50>
8f63b7c0:	e5932000 	ldr	r2, [r3]
8f63b7c4:	e59d3004 	ldr	r3, [r13, #4]
8f63b7c8:	e0332002 	eors	r2, r3, r2
8f63b7cc:	e3a03000 	mov	r3, #0
8f63b7d0:	1a000006 	bne	8f63b7f0 <ext2_init+0x4c>
8f63b7d4:	e30b1fc8 	movw	r1, #49096	; 0xbfc8
8f63b7d8:	e30a0a18 	movw	r0, #43544	; 0xaa18
8f63b7dc:	e3481f70 	movt	r1, #36720	; 0x8f70
8f63b7e0:	e3480f70 	movt	r0, #36720	; 0x8f70
}
8f63b7e4:	e28dd00c 	add	r13, r13, #12
8f63b7e8:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
    fs_register_type("ext2", &ext2_api);
8f63b7ec:	eafff112 	b	8f637c3c <fs_register_type>
8f63b7f0:	ebffdcf2 	bl	8f632bc0 <__stack_chk_fail>
8f63b7f4:	8f74221c 	.word	0x8f74221c

8f63b7f8 <ext2_walk>:
    }
}

/* note, trashes path */
static int ext2_walk(ext2_t *ext2, char *path, struct ext2_inode *start_inode, inodenum_t *inum, int recurse)
{
8f63b7f8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f63b7fc:	e24ddfcf 	sub	r13, r13, #828	; 0x33c
8f63b800:	e59dc360 	ldr	r12, [r13, #864]	; 0x360
8f63b804:	e58d3020 	str	r3, [r13, #32]
    int err;
    bool done;

    LTRACEF("path '%s', start_inode %p, inum %p, recurse %d\n", path, start_inode, inum, recurse);

    if (recurse > 4)
8f63b808:	e35c0005 	cmp	r12, #5
{
8f63b80c:	e59f32a0 	ldr	r3, [pc, #672]	; 8f63bab4 <ext2_walk+0x2bc>
8f63b810:	e58dc024 	str	r12, [r13, #36]	; 0x24
8f63b814:	e5933000 	ldr	r3, [r3]
8f63b818:	e58d3334 	str	r3, [r13, #820]	; 0x334
8f63b81c:	e3a03000 	mov	r3, #0
    if (recurse > 4)
8f63b820:	0a0000a0 	beq	8f63baa8 <ext2_walk+0x2b0>
8f63b824:	e1a09001 	mov	r9, r1
8f63b828:	e1a0a000 	mov	r10, r0
        return ERR_RECURSE_TOO_DEEP;

    /* chew up leading slashes */
    ptr = &path[0];
    while (*ptr == '/')
8f63b82c:	e5d93000 	ldrb	r3, [r9]
8f63b830:	e1a01002 	mov	r1, r2
8f63b834:	e353002f 	cmp	r3, #47	; 0x2f
8f63b838:	1a000002 	bne	8f63b848 <ext2_walk+0x50>
8f63b83c:	e5f93001 	ldrb	r3, [r9, #1]!
8f63b840:	e353002f 	cmp	r3, #47	; 0x2f
8f63b844:	0afffffc 	beq	8f63b83c <ext2_walk+0x44>
        ptr++;

    done = false;
    memcpy(&dir_inode, start_inode, sizeof(struct ext2_inode));
8f63b848:	e28d00b4 	add	r0, r13, #180	; 0xb4
8f63b84c:	e3a02080 	mov	r2, #128	; 0x80
    if (!S_ISDIR(dir_inode->i_mode))
8f63b850:	e3a03a0f 	mov	r3, #61440	; 0xf000
8f63b854:	e34f3fff 	movt	r3, #65535	; 0xffff
8f63b858:	e58d301c 	str	r3, [r13, #28]
    memcpy(&dir_inode, start_inode, sizeof(struct ext2_inode));
8f63b85c:	ebffe255 	bl	8f6341b8 <memcpy>
    while (!done) {
        /* process the first component */
        char *next_sep = strchr(ptr, '/');
8f63b860:	e3a0102f 	mov	r1, #47	; 0x2f
8f63b864:	e1a00009 	mov	r0, r9
8f63b868:	ebffe312 	bl	8f6344b8 <strchr>
        if (next_sep) {
8f63b86c:	e2502000 	subs	r2, r0, #0
    size_t namelen = strlen(name);
8f63b870:	e1a00009 	mov	r0, r9
        if (next_sep) {
8f63b874:	e58d202c 	str	r2, [r13, #44]	; 0x2c
            /* terminate the next component, giving us a substring */
            *next_sep = 0;
8f63b878:	13a03000 	movne	r3, #0
8f63b87c:	15c23000 	strbne	r3, [r2]
        } else {
            /* this is the last component */
            done = true;
8f63b880:	03a03001 	moveq	r3, #1
8f63b884:	e58d3028 	str	r3, [r13, #40]	; 0x28
    size_t namelen = strlen(name);
8f63b888:	ebffe3de 	bl	8f634808 <strlen>
    if (!S_ISDIR(dir_inode->i_mode))
8f63b88c:	e1dd3bb4 	ldrh	r3, [r13, #180]	; 0xb4
8f63b890:	e59d201c 	ldr	r2, [r13, #28]
8f63b894:	e0033002 	and	r3, r3, r2
8f63b898:	e3530901 	cmp	r3, #16384	; 0x4000
    size_t namelen = strlen(name);
8f63b89c:	e1a07000 	mov	r7, r0
    if (!S_ISDIR(dir_inode->i_mode))
8f63b8a0:	1a00006e 	bne	8f63ba60 <ext2_walk+0x268>
    buf = malloc(EXT2_BLOCK_SIZE(ext2->sb));
8f63b8a4:	e59a0020 	ldr	r0, [r10, #32]
8f63b8a8:	e3a03b01 	mov	r3, #1024	; 0x400
    file_blocknum = 0;
8f63b8ac:	e3a08000 	mov	r8, #0
    buf = malloc(EXT2_BLOCK_SIZE(ext2->sb));
8f63b8b0:	e1a00013 	lsl	r0, r3, r0
8f63b8b4:	ebffe1d0 	bl	8f633ffc <malloc>
        err = ext2_read_inode(ext2, dir_inode, buf, file_blocknum * EXT2_BLOCK_SIZE(ext2->sb), EXT2_BLOCK_SIZE(ext2->sb));
8f63b8b8:	e59a3020 	ldr	r3, [r10, #32]
8f63b8bc:	e58da018 	str	r10, [r13, #24]
8f63b8c0:	e58d3014 	str	r3, [r13, #20]
    buf = malloc(EXT2_BLOCK_SIZE(ext2->sb));
8f63b8c4:	e1a0b000 	mov	r11, r0
        err = ext2_read_inode(ext2, dir_inode, buf, file_blocknum * EXT2_BLOCK_SIZE(ext2->sb), EXT2_BLOCK_SIZE(ext2->sb));
8f63b8c8:	e59d3014 	ldr	r3, [r13, #20]
8f63b8cc:	e3a04b01 	mov	r4, #1024	; 0x400
8f63b8d0:	e3a02000 	mov	r2, #0
8f63b8d4:	e59d5018 	ldr	r5, [r13, #24]
8f63b8d8:	e1a03314 	lsl	r3, r4, r3
8f63b8dc:	e1cd20f4 	strd	r2, [r13, #4]
8f63b8e0:	e28d10b4 	add	r1, r13, #180	; 0xb4
8f63b8e4:	e1a0200b 	mov	r2, r11
8f63b8e8:	e0030398 	mul	r3, r8, r3
8f63b8ec:	e1a00005 	mov	r0, r5
8f63b8f0:	e58d3000 	str	r3, [r13]
8f63b8f4:	eb0001a3 	bl	8f63bf88 <ext2_read_inode>
        if (err <= 0) {
8f63b8f8:	e3500000 	cmp	r0, #0
8f63b8fc:	da00004c 	ble	8f63ba34 <ext2_walk+0x23c>
        while (pos < EXT2_BLOCK_SIZE(ext2->sb)) {
8f63b900:	e5953020 	ldr	r3, [r5, #32]
8f63b904:	e1b0a314 	lsls	r10, r4, r3
8f63b908:	e58d3014 	str	r3, [r13, #20]
        uint pos = 0;
8f63b90c:	13a05000 	movne	r5, #0
        while (pos < EXT2_BLOCK_SIZE(ext2->sb)) {
8f63b910:	1a000005 	bne	8f63b92c <ext2_walk+0x134>
8f63b914:	ea000042 	b	8f63ba24 <ext2_walk+0x22c>
            pos += ROUNDUP(LE16(ent->rec_len), 4);
8f63b918:	e2844003 	add	r4, r4, #3
8f63b91c:	e3c44003 	bic	r4, r4, #3
8f63b920:	e0855004 	add	r5, r5, r4
        while (pos < EXT2_BLOCK_SIZE(ext2->sb)) {
8f63b924:	e15a0005 	cmp	r10, r5
8f63b928:	9a00003d 	bls	8f63ba24 <ext2_walk+0x22c>
            ent = (struct ext2_dir_entry_2 *)&buf[pos];
8f63b92c:	e08b6005 	add	r6, r11, r5
            if (LE16(ent->rec_len) == 0)
8f63b930:	e1d640b4 	ldrh	r4, [r6, #4]
8f63b934:	e3540000 	cmp	r4, #0
8f63b938:	0a000039 	beq	8f63ba24 <ext2_walk+0x22c>
            if (ent->name_len == namelen && memcmp(name, ent->name, ent->name_len) == 0) {
8f63b93c:	e5d63006 	ldrb	r3, [r6, #6]
8f63b940:	e1570003 	cmp	r7, r3
8f63b944:	1afffff3 	bne	8f63b918 <ext2_walk+0x120>
8f63b948:	e2861008 	add	r1, r6, #8
8f63b94c:	e1a02007 	mov	r2, r7
8f63b950:	e1a00009 	mov	r0, r9
8f63b954:	ebffe29f 	bl	8f6343d8 <memcmp>
8f63b958:	e3500000 	cmp	r0, #0
8f63b95c:	1affffed 	bne	8f63b918 <ext2_walk+0x120>
                *inum = LE32(ent->inode);
8f63b960:	e5963000 	ldr	r3, [r6]
                free(buf);
8f63b964:	e1a0000b 	mov	r0, r11
                *inum = LE32(ent->inode);
8f63b968:	e59d4020 	ldr	r4, [r13, #32]
8f63b96c:	e59da018 	ldr	r10, [r13, #24]
8f63b970:	e5843000 	str	r3, [r4]
                free(buf);
8f63b974:	ebffe1e4 	bl	8f63410c <free>

        LTRACEF("component '%s', done %d\n", ptr, done);

        /* do the lookup on this component */
        err = ext2_dir_lookup(ext2, &dir_inode, ptr, inum);
        if (err < 0)
8f63b978:	e1cd62d4 	ldrd	r6, [r13, #36]	; 0x24
8f63b97c:	e59d501c 	ldr	r5, [r13, #28]

nextcomponent:
        LTRACEF("inum %u\n", *inum);

        /* load the next inode */
        err = ext2_load_inode(ext2, *inum, &inode);
8f63b980:	e5941000 	ldr	r1, [r4]
8f63b984:	e28d2034 	add	r2, r13, #52	; 0x34
8f63b988:	e1a0000a 	mov	r0, r10
8f63b98c:	ebfffef7 	bl	8f63b570 <ext2_load_inode>
        if (err < 0)
8f63b990:	e3500000 	cmp	r0, #0
8f63b994:	ba00001a 	blt	8f63ba04 <ext2_walk+0x20c>
            return err;

        /* is it a symlink? */
        if (S_ISLNK(inode.i_mode)) {
8f63b998:	e1dd33b4 	ldrh	r3, [r13, #52]	; 0x34
8f63b99c:	e0033005 	and	r3, r3, r5
8f63b9a0:	e3530a0a 	cmp	r3, #40960	; 0xa000
8f63b9a4:	1a000026 	bne	8f63ba44 <ext2_walk+0x24c>
            char link[512];

            LTRACEF("hit symlink\n");

            err = ext2_read_link(ext2, &inode, link, sizeof(link));
8f63b9a8:	e28d2f4d 	add	r2, r13, #308	; 0x134
8f63b9ac:	e28d1034 	add	r1, r13, #52	; 0x34
8f63b9b0:	e3a03c02 	mov	r3, #512	; 0x200
8f63b9b4:	e1a0000a 	mov	r0, r10
8f63b9b8:	eb0002e5 	bl	8f63c554 <ext2_read_link>
            if (err < 0)
8f63b9bc:	e3500000 	cmp	r0, #0
8f63b9c0:	ba00000f 	blt	8f63ba04 <ext2_walk+0x20c>
                return err;

            LTRACEF("symlink read returns %d '%s'\n", err, link);

            /* recurse, parsing the link */
            if (link[0] == '/') {
8f63b9c4:	e5dd3134 	ldrb	r3, [r13, #308]	; 0x134
                /* link starts with '/', so start over again at the rootfs */
                err = ext2_walk(ext2, link, &ext2->root_inode, inum, recurse + 1);
            } else {
                err = ext2_walk(ext2, link, &dir_inode, inum, recurse + 1);
8f63b9c8:	e28d1f4d 	add	r1, r13, #308	; 0x134
8f63b9cc:	e1a0000a 	mov	r0, r10
            if (link[0] == '/') {
8f63b9d0:	e353002f 	cmp	r3, #47	; 0x2f
                err = ext2_walk(ext2, link, &ext2->root_inode, inum, recurse + 1);
8f63b9d4:	e2863001 	add	r3, r6, #1
8f63b9d8:	028a2e41 	addeq	r2, r10, #1040	; 0x410
8f63b9dc:	e58d3000 	str	r3, [r13]
                err = ext2_walk(ext2, link, &dir_inode, inum, recurse + 1);
8f63b9e0:	128d20b4 	addne	r2, r13, #180	; 0xb4
                err = ext2_walk(ext2, link, &ext2->root_inode, inum, recurse + 1);
8f63b9e4:	01a03004 	moveq	r3, r4
                err = ext2_walk(ext2, link, &dir_inode, inum, recurse + 1);
8f63b9e8:	11a03004 	movne	r3, r4
8f63b9ec:	ebffff81 	bl	8f63b7f8 <ext2_walk>
            }

            LTRACEF("recursive walk returns %d\n", err);

            if (err < 0)
8f63b9f0:	e3500000 	cmp	r0, #0
8f63b9f4:	ba000002 	blt	8f63ba04 <ext2_walk+0x20c>
                return err;

            /* if we weren't done with our path parsing, start again with the result of this recurse */
            if (!done) {
8f63b9f8:	e3570000 	cmp	r7, #0
8f63b9fc:	0affffdf 	beq	8f63b980 <ext2_walk+0x188>
            while (*ptr == '/')
                ptr++;
        }
    }

    return 0;
8f63ba00:	e3a00000 	mov	r0, #0
}
8f63ba04:	e59f30a8 	ldr	r3, [pc, #168]	; 8f63bab4 <ext2_walk+0x2bc>
8f63ba08:	e5932000 	ldr	r2, [r3]
8f63ba0c:	e59d3334 	ldr	r3, [r13, #820]	; 0x334
8f63ba10:	e0332002 	eors	r2, r3, r2
8f63ba14:	e3a03000 	mov	r3, #0
8f63ba18:	1a000024 	bne	8f63bab0 <ext2_walk+0x2b8>
8f63ba1c:	e28ddfcf 	add	r13, r13, #828	; 0x33c
8f63ba20:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
        file_blocknum++;
8f63ba24:	e2888001 	add	r8, r8, #1
        if (file_blocknum > 1024) {
8f63ba28:	e3003401 	movw	r3, #1025	; 0x401
8f63ba2c:	e1580003 	cmp	r8, r3
8f63ba30:	1affffa4 	bne	8f63b8c8 <ext2_walk+0xd0>
            free(buf);
8f63ba34:	e1a0000b 	mov	r0, r11
8f63ba38:	ebffe1b3 	bl	8f63410c <free>
            return -1;
8f63ba3c:	e3e00000 	mvn	r0, #0
8f63ba40:	eaffffef 	b	8f63ba04 <ext2_walk+0x20c>
        } else if (S_ISDIR(inode.i_mode)) {
8f63ba44:	e3530901 	cmp	r3, #16384	; 0x4000
8f63ba48:	0a000006 	beq	8f63ba68 <ext2_walk+0x270>
            if (!done) {
8f63ba4c:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f63ba50:	e3530000 	cmp	r3, #0
8f63ba54:	1affffe9 	bne	8f63ba00 <ext2_walk+0x208>
                return ERR_NOT_FOUND;
8f63ba58:	e3e00001 	mvn	r0, #1
8f63ba5c:	eaffffe8 	b	8f63ba04 <ext2_walk+0x20c>
        return ERR_NOT_DIR;
8f63ba60:	e3e00014 	mvn	r0, #20
8f63ba64:	eaffffe6 	b	8f63ba04 <ext2_walk+0x20c>
            memcpy(&dir_inode, &inode, sizeof(struct ext2_inode));
8f63ba68:	e28d1034 	add	r1, r13, #52	; 0x34
8f63ba6c:	e28d00b4 	add	r0, r13, #180	; 0xb4
8f63ba70:	e3a02080 	mov	r2, #128	; 0x80
8f63ba74:	ebffe1cf 	bl	8f6341b8 <memcpy>
        if (!done) {
8f63ba78:	e59d3028 	ldr	r3, [r13, #40]	; 0x28
8f63ba7c:	e3530000 	cmp	r3, #0
8f63ba80:	1affffde 	bne	8f63ba00 <ext2_walk+0x208>
            while (*ptr == '/')
8f63ba84:	e59d202c 	ldr	r2, [r13, #44]	; 0x2c
            ptr = next_sep + 1;
8f63ba88:	e2829001 	add	r9, r2, #1
            while (*ptr == '/')
8f63ba8c:	e5d23001 	ldrb	r3, [r2, #1]
8f63ba90:	e353002f 	cmp	r3, #47	; 0x2f
8f63ba94:	1affff71 	bne	8f63b860 <ext2_walk+0x68>
8f63ba98:	e5f93001 	ldrb	r3, [r9, #1]!
8f63ba9c:	e353002f 	cmp	r3, #47	; 0x2f
8f63baa0:	0afffffc 	beq	8f63ba98 <ext2_walk+0x2a0>
8f63baa4:	eaffff6d 	b	8f63b860 <ext2_walk+0x68>
        return ERR_RECURSE_TOO_DEEP;
8f63baa8:	e3e00016 	mvn	r0, #22
8f63baac:	eaffffd4 	b	8f63ba04 <ext2_walk+0x20c>
}
8f63bab0:	ebffdc42 	bl	8f632bc0 <__stack_chk_fail>
8f63bab4:	8f74221c 	.word	0x8f74221c

8f63bab8 <ext2_lookup>:

/* do a path parse, looking up each component */
int ext2_lookup(ext2_t *ext2, const char *_path, inodenum_t *inum)
{
8f63bab8:	e92d4030 	push	{r4, r5, r14}
8f63babc:	e24ddf85 	sub	r13, r13, #532	; 0x214
8f63bac0:	e59f305c 	ldr	r3, [pc, #92]	; 8f63bb24 <ext2_lookup+0x6c>
8f63bac4:	e1a04000 	mov	r4, r0
8f63bac8:	e1a05002 	mov	r5, r2
    LTRACEF("path '%s', inum %p\n", _path, inum);

    char path[512];
    strlcpy(path, _path, sizeof(path));
8f63bacc:	e28d000c 	add	r0, r13, #12
8f63bad0:	e3a02c02 	mov	r2, #512	; 0x200
{
8f63bad4:	e5933000 	ldr	r3, [r3]
8f63bad8:	e58d320c 	str	r3, [r13, #524]	; 0x20c
8f63badc:	e3a03000 	mov	r3, #0
    strlcpy(path, _path, sizeof(path));
8f63bae0:	ebffe312 	bl	8f634730 <strlcpy>

    return ext2_walk(ext2, path, &ext2->root_inode, inum, 1);
8f63bae4:	e2842e41 	add	r2, r4, #1040	; 0x410
8f63bae8:	e3a0c001 	mov	r12, #1
8f63baec:	e1a03005 	mov	r3, r5
8f63baf0:	e28d100c 	add	r1, r13, #12
8f63baf4:	e1a00004 	mov	r0, r4
8f63baf8:	e58dc000 	str	r12, [r13]
8f63bafc:	ebffff3d 	bl	8f63b7f8 <ext2_walk>
}
8f63bb00:	e59f301c 	ldr	r3, [pc, #28]	; 8f63bb24 <ext2_lookup+0x6c>
8f63bb04:	e5932000 	ldr	r2, [r3]
8f63bb08:	e59d320c 	ldr	r3, [r13, #524]	; 0x20c
8f63bb0c:	e0332002 	eors	r2, r3, r2
8f63bb10:	e3a03000 	mov	r3, #0
8f63bb14:	1a000001 	bne	8f63bb20 <ext2_lookup+0x68>
8f63bb18:	e28ddf85 	add	r13, r13, #532	; 0x214
8f63bb1c:	e8bd8030 	pop	{r4, r5, r15}
8f63bb20:	ebffdc26 	bl	8f632bc0 <__stack_chk_fail>
8f63bb24:	8f74221c 	.word	0x8f74221c

8f63bb28 <ext2_open_directory>:

// © 2019 Mis012 - SPDX-License-Identifier: GPL-3.0
// from here till the end of file

status_t ext2_open_directory(fscookie *cookie, const char *path, dircookie **dircookie) {
8f63bb28:	e59f3100 	ldr	r3, [pc, #256]	; 8f63bc30 <ext2_open_directory+0x108>
8f63bb2c:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f63bb30:	e1a06000 	mov	r6, r0
8f63bb34:	e24dd00c 	sub	r13, r13, #12
	off_t entry_len = 0;
	ext2_dir_t *dir = malloc(sizeof(ext2_dir_t));
8f63bb38:	e3a00018 	mov	r0, #24
status_t ext2_open_directory(fscookie *cookie, const char *path, dircookie **dircookie) {
8f63bb3c:	e5933000 	ldr	r3, [r3]
8f63bb40:	e58d3004 	str	r3, [r13, #4]
8f63bb44:	e3a03000 	mov	r3, #0
8f63bb48:	e1a05001 	mov	r5, r1
8f63bb4c:	e1a07002 	mov	r7, r2
	ext2_dir_t *dir = malloc(sizeof(ext2_dir_t));
8f63bb50:	ebffe129 	bl	8f633ffc <malloc>
	memset(dir, 0, sizeof(ext2_dir_t));
8f63bb54:	e3a02018 	mov	r2, #24
8f63bb58:	e3a01000 	mov	r1, #0
	ext2_dir_t *dir = malloc(sizeof(ext2_dir_t));
8f63bb5c:	e1a04000 	mov	r4, r0
	memset(dir, 0, sizeof(ext2_dir_t));
8f63bb60:	ebffe1d7 	bl	8f6342c4 <memset>
	if (!dir) {
8f63bb64:	e3540000 	cmp	r4, #0
8f63bb68:	0a00002a 	beq	8f63bc18 <ext2_open_directory+0xf0>
		dprintf(INFO, "ext2_list_directory: failed to malloc (dir)\n");
		return -1;
	}
	int ret;

	ret = ext2_open_file(cookie, (path[0] == 0 ? "/." : path), (filecookie **)&dir->file); // fails if path=""
8f63bb6c:	e5d51000 	ldrb	r1, [r5]
8f63bb70:	e30b3ff8 	movw	r3, #49144	; 0xbff8
8f63bb74:	e3483f70 	movt	r3, #36720	; 0x8f70
8f63bb78:	e1a00006 	mov	r0, r6
8f63bb7c:	e3510000 	cmp	r1, #0
8f63bb80:	e1a02004 	mov	r2, r4
8f63bb84:	11a01005 	movne	r1, r5
8f63bb88:	01a01003 	moveq	r1, r3
8f63bb8c:	eb0001c6 	bl	8f63c2ac <ext2_open_file>
	if (ret < 0) {
8f63bb90:	e2505000 	subs	r5, r0, #0
8f63bb94:	ba000015 	blt	8f63bbf0 <ext2_open_directory+0xc8>
		free(dir);
		return ret;
	}

	if (!S_ISDIR(dir->file->inode.i_mode)) {
8f63bb98:	e5941000 	ldr	r1, [r4]
8f63bb9c:	e1d131bc 	ldrh	r3, [r1, #28]
8f63bba0:	e2033a0f 	and	r3, r3, #61440	; 0xf000
8f63bba4:	e3530901 	cmp	r3, #16384	; 0x4000
8f63bba8:	1a000013 	bne	8f63bbfc <ext2_open_directory+0xd4>
		dprintf(INFO, "ext2_list_directory: not a directory\n");
		free(dir);
		return ERR_NOT_DIR;
	}

	entry_len = ext2_file_len(dir->file->ext2, &dir->file->inode);
8f63bbac:	e491001c 	ldr	r0, [r1], #28
	dir->offset = 0;
	dir->length = entry_len;

	*dircookie = dir;

	return 0;
8f63bbb0:	e3a05000 	mov	r5, #0
	entry_len = ext2_file_len(dir->file->ext2, &dir->file->inode);
8f63bbb4:	eb000226 	bl	8f63c454 <ext2_file_len>
	dir->offset = 0;
8f63bbb8:	e3a02000 	mov	r2, #0
8f63bbbc:	e3a03000 	mov	r3, #0
	*dircookie = dir;
8f63bbc0:	e5874000 	str	r4, [r7]
	dir->offset = 0;
8f63bbc4:	e1c420f8 	strd	r2, [r4, #8]
	dir->length = entry_len;
8f63bbc8:	e1c401f0 	strd	r0, [r4, #16]
}
8f63bbcc:	e59f305c 	ldr	r3, [pc, #92]	; 8f63bc30 <ext2_open_directory+0x108>
8f63bbd0:	e5932000 	ldr	r2, [r3]
8f63bbd4:	e59d3004 	ldr	r3, [r13, #4]
8f63bbd8:	e0332002 	eors	r2, r3, r2
8f63bbdc:	e3a03000 	mov	r3, #0
8f63bbe0:	1a000011 	bne	8f63bc2c <ext2_open_directory+0x104>
8f63bbe4:	e1a00005 	mov	r0, r5
8f63bbe8:	e28dd00c 	add	r13, r13, #12
8f63bbec:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		free(dir);
8f63bbf0:	e1a00004 	mov	r0, r4
8f63bbf4:	ebffe144 	bl	8f63410c <free>
		return ret;
8f63bbf8:	eafffff3 	b	8f63bbcc <ext2_open_directory+0xa4>
		dprintf(INFO, "ext2_list_directory: not a directory\n");
8f63bbfc:	e30c002c 	movw	r0, #49196	; 0xc02c
8f63bc00:	e3480f70 	movt	r0, #36720	; 0x8f70
8f63bc04:	ebffdb5a 	bl	8f632974 <_dprintf>
		free(dir);
8f63bc08:	e1a00004 	mov	r0, r4
8f63bc0c:	ebffe13e 	bl	8f63410c <free>
		return ERR_NOT_DIR;
8f63bc10:	e3e05014 	mvn	r5, #20
8f63bc14:	eaffffec 	b	8f63bbcc <ext2_open_directory+0xa4>
		dprintf(INFO, "ext2_list_directory: failed to malloc (dir)\n");
8f63bc18:	e30b0ffc 	movw	r0, #49148	; 0xbffc
8f63bc1c:	e3480f70 	movt	r0, #36720	; 0x8f70
8f63bc20:	ebffdb53 	bl	8f632974 <_dprintf>
		return -1;
8f63bc24:	e3e05000 	mvn	r5, #0
8f63bc28:	eaffffe7 	b	8f63bbcc <ext2_open_directory+0xa4>
}
8f63bc2c:	ebffdbe3 	bl	8f632bc0 <__stack_chk_fail>
8f63bc30:	8f74221c 	.word	0x8f74221c

8f63bc34 <ext2_read_directory>:
	struct ext2_dir_entry_2 direntry;
	int ret;

	ext2_dir_t *dir = (ext2_dir_t *)dircookie;

	if (dir->offset >= dir->length)
8f63bc34:	e5902010 	ldr	r2, [r0, #16]
8f63bc38:	e590c008 	ldr	r12, [r0, #8]
status_t ext2_read_directory(dircookie *dircookie, struct dirent *ent) {
8f63bc3c:	e92d4030 	push	{r4, r5, r14}
	if (dir->offset >= dir->length)
8f63bc40:	e15c0002 	cmp	r12, r2
status_t ext2_read_directory(dircookie *dircookie, struct dirent *ent) {
8f63bc44:	e59f20b0 	ldr	r2, [pc, #176]	; 8f63bcfc <ext2_read_directory+0xc8>
8f63bc48:	e24ddf49 	sub	r13, r13, #292	; 0x124
	if (dir->offset >= dir->length)
8f63bc4c:	e590300c 	ldr	r3, [r0, #12]
status_t ext2_read_directory(dircookie *dircookie, struct dirent *ent) {
8f63bc50:	e5922000 	ldr	r2, [r2]
8f63bc54:	e58d211c 	str	r2, [r13, #284]	; 0x11c
8f63bc58:	e3a02000 	mov	r2, #0
	if (dir->offset >= dir->length)
8f63bc5c:	e5902014 	ldr	r2, [r0, #20]
8f63bc60:	e0d32002 	sbcs	r2, r3, r2
8f63bc64:	aa000021 	bge	8f63bcf0 <ext2_read_directory+0xbc>
		return ERR_NOT_FOUND;

	ret = ext2_read_inode(dir->file->ext2, &dir->file->inode, &direntry, dir->offset, sizeof(struct ext2_dir_entry_2));
8f63bc68:	e1a05001 	mov	r5, r1
8f63bc6c:	e5901000 	ldr	r1, [r0]
8f63bc70:	e3a0ef42 	mov	r14, #264	; 0x108
8f63bc74:	e28d2014 	add	r2, r13, #20
8f63bc78:	e1a04000 	mov	r4, r0
8f63bc7c:	e491001c 	ldr	r0, [r1], #28
8f63bc80:	e58de008 	str	r14, [r13, #8]
8f63bc84:	e58dc000 	str	r12, [r13]
8f63bc88:	e58d3004 	str	r3, [r13, #4]
8f63bc8c:	eb0000bd 	bl	8f63bf88 <ext2_read_inode>
	if (ret < 0)
8f63bc90:	e3500000 	cmp	r0, #0
8f63bc94:	ba00000d 	blt	8f63bcd0 <ext2_read_directory+0x9c>
		return ret;

	memcpy(ent->name, direntry.name, direntry.name_len);
8f63bc98:	e5dd201a 	ldrb	r2, [r13, #26]
8f63bc9c:	e28d101c 	add	r1, r13, #28
8f63bca0:	e1a00005 	mov	r0, r5
8f63bca4:	ebffe143 	bl	8f6341b8 <memcpy>
	ent->name[direntry.name_len] = '\0';
8f63bca8:	e5dd301a 	ldrb	r3, [r13, #26]

	dir->offset += direntry.rec_len;
8f63bcac:	e1dd11b8 	ldrh	r1, [r13, #24]
	ent->name[direntry.name_len] = '\0';
8f63bcb0:	e3a00000 	mov	r0, #0
8f63bcb4:	e7c50003 	strb	r0, [r5, r3]
	dir->offset += direntry.rec_len;
8f63bcb8:	e5943008 	ldr	r3, [r4, #8]
8f63bcbc:	e594200c 	ldr	r2, [r4, #12]
8f63bcc0:	e0933001 	adds	r3, r3, r1
8f63bcc4:	e5843008 	str	r3, [r4, #8]
8f63bcc8:	e2a23000 	adc	r3, r2, #0
8f63bccc:	e584300c 	str	r3, [r4, #12]

	return 0;
}
8f63bcd0:	e59f3024 	ldr	r3, [pc, #36]	; 8f63bcfc <ext2_read_directory+0xc8>
8f63bcd4:	e5932000 	ldr	r2, [r3]
8f63bcd8:	e59d311c 	ldr	r3, [r13, #284]	; 0x11c
8f63bcdc:	e0332002 	eors	r2, r3, r2
8f63bce0:	e3a03000 	mov	r3, #0
8f63bce4:	1a000003 	bne	8f63bcf8 <ext2_read_directory+0xc4>
8f63bce8:	e28ddf49 	add	r13, r13, #292	; 0x124
8f63bcec:	e8bd8030 	pop	{r4, r5, r15}
		return ERR_NOT_FOUND;
8f63bcf0:	e3e00001 	mvn	r0, #1
8f63bcf4:	eafffff5 	b	8f63bcd0 <ext2_read_directory+0x9c>
}
8f63bcf8:	ebffdbb0 	bl	8f632bc0 <__stack_chk_fail>
8f63bcfc:	8f74221c 	.word	0x8f74221c

8f63bd00 <ext2_close_directory>:

status_t ext2_close_directory(dircookie *dircookie) {
8f63bd00:	e59f304c 	ldr	r3, [pc, #76]	; 8f63bd54 <ext2_close_directory+0x54>
8f63bd04:	e92d4010 	push	{r4, r14}
8f63bd08:	e1a04000 	mov	r4, r0
8f63bd0c:	e24dd008 	sub	r13, r13, #8
	ext2_dir_t *dir = (ext2_dir_t *)dircookie;

	ext2_close_file(dir->file);
8f63bd10:	e5900000 	ldr	r0, [r0]
status_t ext2_close_directory(dircookie *dircookie) {
8f63bd14:	e5933000 	ldr	r3, [r3]
8f63bd18:	e58d3004 	str	r3, [r13, #4]
8f63bd1c:	e3a03000 	mov	r3, #0
	ext2_close_file(dir->file);
8f63bd20:	eb0001ac 	bl	8f63c3d8 <ext2_close_file>
	free(dir);
8f63bd24:	e1a00004 	mov	r0, r4
8f63bd28:	ebffe0f7 	bl	8f63410c <free>
	return 0;
}
8f63bd2c:	e59f3020 	ldr	r3, [pc, #32]	; 8f63bd54 <ext2_close_directory+0x54>
8f63bd30:	e5932000 	ldr	r2, [r3]
8f63bd34:	e59d3004 	ldr	r3, [r13, #4]
8f63bd38:	e0332002 	eors	r2, r3, r2
8f63bd3c:	e3a03000 	mov	r3, #0
8f63bd40:	1a000002 	bne	8f63bd50 <ext2_close_directory+0x50>
8f63bd44:	e3a00000 	mov	r0, #0
8f63bd48:	e28dd008 	add	r13, r13, #8
8f63bd4c:	e8bd8010 	pop	{r4, r15}
8f63bd50:	ebffdb9a 	bl	8f632bc0 <__stack_chk_fail>
8f63bd54:	8f74221c 	.word	0x8f74221c

8f63bd58 <ext2_get_indirect_block_pointer_cache_block>:
	return -1;
}

// This function returns a pointer to the cache block that corresponds to the indirect block pointer.
int ext2_get_indirect_block_pointer_cache_block(ext2_t *ext2, struct ext2_inode *inode, blocknum_t **cache_block, uint32_t level, uint32_t pos[], uint *block_loaded)
{
8f63bd58:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f63bd5c:	e1a07003 	mov	r7, r3
8f63bd60:	e59f30dc 	ldr	r3, [pc, #220]	; 8f63be44 <ext2_get_indirect_block_pointer_cache_block+0xec>
8f63bd64:	e24dd00c 	sub	r13, r13, #12
	uint32_t current_level = 0;
	size_t current_block = 0, last_block;
	blocknum_t *block = NULL;
8f63bd68:	e3a04000 	mov	r4, #0
{
8f63bd6c:	e1a0b002 	mov	r11, r2
8f63bd70:	e5933000 	ldr	r3, [r3]
8f63bd74:	e58d3004 	str	r3, [r13, #4]
8f63bd78:	e3a03000 	mov	r3, #0
	int err;

	if ((level > 3) || (level == 0)) {
8f63bd7c:	e2473001 	sub	r3, r7, #1
8f63bd80:	e3530002 	cmp	r3, #2
{
8f63bd84:	e59d9030 	ldr	r9, [r13, #48]	; 0x30
8f63bd88:	e59d8034 	ldr	r8, [r13, #52]	; 0x34
	blocknum_t *block = NULL;
8f63bd8c:	e58d4000 	str	r4, [r13]
	if ((level > 3) || (level == 0)) {
8f63bd90:	8a00001e 	bhi	8f63be10 <ext2_get_indirect_block_pointer_cache_block+0xb8>
8f63bd94:	e1a06000 	mov	r6, r0
8f63bd98:	e1a0a001 	mov	r10, r1
	uint32_t current_level = 0;
8f63bd9c:	e1a05004 	mov	r5, r4
		goto error;
	}

	// Dig down into the indirect blocks. When done, current_block should point to the target.
	while (current_level < level) {
		if (current_level == 0) {
8f63bda0:	e3550000 	cmp	r5, #0
			// read the direct block, simulates a prior loop
			current_block = LE32(inode->i_block[pos[0]]);
8f63bda4:	05993000 	ldreq	r3, [r9]
8f63bda8:	0283300a 	addeq	r3, r3, #10
8f63bdac:	079a4103 	ldreq	r4, [r10, r3, lsl #2]
		}

		if (current_block == 0) {
8f63bdb0:	e3540000 	cmp	r4, #0
8f63bdb4:	0a000015 	beq	8f63be10 <ext2_get_indirect_block_pointer_cache_block+0xb8>
	return bcache_get_block(ext2->cache, ptr, bnum);
8f63bdb8:	e5960004 	ldr	r0, [r6, #4]
8f63bdbc:	e1a02004 	mov	r2, r4
8f63bdc0:	e1a0100d 	mov	r1, r13
			goto error;
		}

		last_block = current_block;
		current_level++;
		*block_loaded = current_block;
8f63bdc4:	e5884000 	str	r4, [r8]
	return bcache_get_block(ext2->cache, ptr, bnum);
8f63bdc8:	eb000349 	bl	8f63caf4 <bcache_get_block>
		current_level++;
8f63bdcc:	e2855001 	add	r5, r5, #1

		err = ext2_get_block(ext2, (void **)(void *)&block, current_block);
		if (err < 0) {
8f63bdd0:	e3500000 	cmp	r0, #0
8f63bdd4:	ba00000e 	blt	8f63be14 <ext2_get_indirect_block_pointer_cache_block+0xbc>
			goto error;
		} 

		if (current_level < level) {
8f63bdd8:	e1570005 	cmp	r7, r5
8f63bddc:	8a000004 	bhi	8f63bdf4 <ext2_get_indirect_block_pointer_cache_block+0x9c>
	while (current_level < level) {
8f63bde0:	1affffee 	bne	8f63bda0 <ext2_get_indirect_block_pointer_cache_block+0x48>
			current_block = LE32(block[pos[current_level]]);
			ext2_put_block(ext2, last_block);
		}
	}

	*cache_block = block;
8f63bde4:	e59d3000 	ldr	r3, [r13]
	return 0;
8f63bde8:	e3a00000 	mov	r0, #0
	*cache_block = block;
8f63bdec:	e58b3000 	str	r3, [r11]
	return 0;
8f63bdf0:	ea00000a 	b	8f63be20 <ext2_get_indirect_block_pointer_cache_block+0xc8>
			current_block = LE32(block[pos[current_level]]);
8f63bdf4:	e7992105 	ldr	r2, [r9, r5, lsl #2]
	return bcache_put_block(ext2->cache, bnum);
8f63bdf8:	e1a01004 	mov	r1, r4
			current_block = LE32(block[pos[current_level]]);
8f63bdfc:	e59d3000 	ldr	r3, [r13]
	return bcache_put_block(ext2->cache, bnum);
8f63be00:	e5960004 	ldr	r0, [r6, #4]
			current_block = LE32(block[pos[current_level]]);
8f63be04:	e7934102 	ldr	r4, [r3, r2, lsl #2]
	return bcache_put_block(ext2->cache, bnum);
8f63be08:	eb00035d 	bl	8f63cb84 <bcache_put_block>
	while (current_level < level) {
8f63be0c:	eaffffe3 	b	8f63bda0 <ext2_get_indirect_block_pointer_cache_block+0x48>
		err = -1;
8f63be10:	e3e00000 	mvn	r0, #0

error:
	*cache_block = NULL;
8f63be14:	e3a03000 	mov	r3, #0
8f63be18:	e58b3000 	str	r3, [r11]
	*block_loaded = 0;
8f63be1c:	e5883000 	str	r3, [r8]
	return err;
}
8f63be20:	e59f301c 	ldr	r3, [pc, #28]	; 8f63be44 <ext2_get_indirect_block_pointer_cache_block+0xec>
8f63be24:	e5932000 	ldr	r2, [r3]
8f63be28:	e59d3004 	ldr	r3, [r13, #4]
8f63be2c:	e0332002 	eors	r2, r3, r2
8f63be30:	e3a03000 	mov	r3, #0
8f63be34:	1a000001 	bne	8f63be40 <ext2_get_indirect_block_pointer_cache_block+0xe8>
8f63be38:	e28dd00c 	add	r13, r13, #12
8f63be3c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
8f63be40:	ebffdb5e 	bl	8f632bc0 <__stack_chk_fail>
8f63be44:	8f74221c 	.word	0x8f74221c

8f63be48 <file_block_to_fs_block>:

/* translate a file block to a physical block */
static blocknum_t file_block_to_fs_block(ext2_t *ext2, struct ext2_inode *inode, uint fileblock)
{
8f63be48:	e59f3134 	ldr	r3, [pc, #308]	; 8f63bf84 <file_block_to_fs_block+0x13c>
	if(block_to_find < EXT2_NDIR_BLOCKS) {
8f63be4c:	e352000b 	cmp	r2, #11
{
8f63be50:	e92d4070 	push	{r4, r5, r6, r14}
8f63be54:	e24dd028 	sub	r13, r13, #40	; 0x28
8f63be58:	e5933000 	ldr	r3, [r3]
8f63be5c:	e58d3024 	str	r3, [r13, #36]	; 0x24
8f63be60:	e3a03000 	mov	r3, #0
8f63be64:	e1a06001 	mov	r6, r1
	if(block_to_find < EXT2_NDIR_BLOCKS) {
8f63be68:	9a00002e 	bls	8f63bf28 <file_block_to_fs_block+0xe0>
	block_ptr_per_block = EXT2_ADDR_PER_BLOCK(ext2->sb);
8f63be6c:	e5903020 	ldr	r3, [r0, #32]
8f63be70:	e3a04b01 	mov	r4, #1024	; 0x400
8f63be74:	e1a05000 	mov	r5, r0
8f63be78:	e1a04314 	lsl	r4, r4, r3
	block_to_find -= EXT2_NDIR_BLOCKS;
8f63be7c:	e242300c 	sub	r3, r2, #12
	block_ptr_per_block = EXT2_ADDR_PER_BLOCK(ext2->sb);
8f63be80:	e1a04124 	lsr	r4, r4, #2
	if(block_to_find < block_ptr_per_block) {
8f63be84:	e1540003 	cmp	r4, r3
8f63be88:	8a000031 	bhi	8f63bf54 <file_block_to_fs_block+0x10c>
	block_ptr_per_2nd_block = block_ptr_per_block * block_ptr_per_block;
8f63be8c:	e0010494 	mul	r1, r4, r4
	block_to_find -= block_ptr_per_block;
8f63be90:	e0430004 	sub	r0, r3, r4
	if(block_to_find < (block_ptr_per_2nd_block)) {
8f63be94:	e1500001 	cmp	r0, r1
8f63be98:	3a000031 	bcc	8f63bf64 <file_block_to_fs_block+0x11c>
	if(block_to_find < (block_ptr_per_2nd_block * block_ptr_per_block)) {
8f63be9c:	e0030491 	mul	r3, r1, r4
	block_to_find -= block_ptr_per_2nd_block;
8f63bea0:	e0400001 	sub	r0, r0, r1
	if(block_to_find < (block_ptr_per_2nd_block * block_ptr_per_block)) {
8f63bea4:	e1500003 	cmp	r0, r3
8f63bea8:	2a00001e 	bcs	8f63bf28 <file_block_to_fs_block+0xe0>
		pos[0] = EXT2_TIND_BLOCK;
8f63beac:	e3a0300e 	mov	r3, #14
8f63beb0:	e58d3014 	str	r3, [r13, #20]
		pos[1] = block_to_find / block_ptr_per_2nd_block;
8f63beb4:	fa0003de 	blx	8f63ce34 <__aeabi_uidivmod>
8f63beb8:	e1a03000 	mov	r3, r0
8f63bebc:	e1a00001 	mov	r0, r1
8f63bec0:	e1a01004 	mov	r1, r4
8f63bec4:	e58d3018 	str	r3, [r13, #24]
		pos[2] = (block_to_find % block_ptr_per_2nd_block) / block_ptr_per_block;
8f63bec8:	fa0003d9 	blx	8f63ce34 <__aeabi_uidivmod>
		*level = 3;
8f63becc:	e3a04003 	mov	r4, #3
		pos[3] = (block_to_find % block_ptr_per_2nd_block) % block_ptr_per_block;
8f63bed0:	e1cd01fc 	strd	r0, [r13, #28]
		block = LE32(inode->i_block[fileblock]);
	} else {
		/* at least one level of indirection, get a pointer to the final indirect block table and dereference it */
		blocknum_t *ind_table;
		blocknum_t phys_block;
		err = ext2_get_indirect_block_pointer_cache_block(ext2, inode, &ind_table, level, pos, &phys_block);
8f63bed4:	e28d2010 	add	r2, r13, #16
8f63bed8:	e28d3014 	add	r3, r13, #20
8f63bedc:	e58d2004 	str	r2, [r13, #4]
8f63bee0:	e1a01006 	mov	r1, r6
8f63bee4:	e58d3000 	str	r3, [r13]
8f63bee8:	e28d200c 	add	r2, r13, #12
8f63beec:	e1a03004 	mov	r3, r4
8f63bef0:	e1a00005 	mov	r0, r5
8f63bef4:	ebffff97 	bl	8f63bd58 <ext2_get_indirect_block_pointer_cache_block>
		if (err < 0)
8f63bef8:	e3500000 	cmp	r0, #0
			return 0;
8f63befc:	b3a04000 	movlt	r4, #0
		if (err < 0)
8f63bf00:	ba00000a 	blt	8f63bf30 <file_block_to_fs_block+0xe8>

		/* dereference the final entry in the final table */
		block = LE32(ind_table[pos[level]]);
8f63bf04:	e28d3028 	add	r3, r13, #40	; 0x28
	return bcache_put_block(ext2->cache, bnum);
8f63bf08:	e59d1010 	ldr	r1, [r13, #16]
		block = LE32(ind_table[pos[level]]);
8f63bf0c:	e0834104 	add	r4, r3, r4, lsl #2
8f63bf10:	e59d300c 	ldr	r3, [r13, #12]
	return bcache_put_block(ext2->cache, bnum);
8f63bf14:	e5950004 	ldr	r0, [r5, #4]
		block = LE32(ind_table[pos[level]]);
8f63bf18:	e5142014 	ldr	r2, [r4, #-20]	; 0xffffffec
8f63bf1c:	e7934102 	ldr	r4, [r3, r2, lsl #2]
	return bcache_put_block(ext2->cache, bnum);
8f63bf20:	eb000317 	bl	8f63cb84 <bcache_put_block>
8f63bf24:	ea000001 	b	8f63bf30 <file_block_to_fs_block+0xe8>
		block = LE32(inode->i_block[fileblock]);
8f63bf28:	e282200a 	add	r2, r2, #10
8f63bf2c:	e7964102 	ldr	r4, [r6, r2, lsl #2]
	}

	LTRACEF("returning %u\n", block);

	return block;
}
8f63bf30:	e59f304c 	ldr	r3, [pc, #76]	; 8f63bf84 <file_block_to_fs_block+0x13c>
8f63bf34:	e5932000 	ldr	r2, [r3]
8f63bf38:	e59d3024 	ldr	r3, [r13, #36]	; 0x24
8f63bf3c:	e0332002 	eors	r2, r3, r2
8f63bf40:	e3a03000 	mov	r3, #0
8f63bf44:	1a00000d 	bne	8f63bf80 <file_block_to_fs_block+0x138>
8f63bf48:	e1a00004 	mov	r0, r4
8f63bf4c:	e28dd028 	add	r13, r13, #40	; 0x28
8f63bf50:	e8bd8070 	pop	{r4, r5, r6, r15}
		pos[0] = EXT2_IND_BLOCK;	
8f63bf54:	e3a0200c 	mov	r2, #12
		*level = 1;
8f63bf58:	e3a04001 	mov	r4, #1
		pos[1] = block_to_find;
8f63bf5c:	e1cd21f4 	strd	r2, [r13, #20]
	if (level == 0) {
8f63bf60:	eaffffdb 	b	8f63bed4 <file_block_to_fs_block+0x8c>
		pos[0] = EXT2_DIND_BLOCK;
8f63bf64:	e1a01004 	mov	r1, r4
8f63bf68:	e3a0300d 	mov	r3, #13
8f63bf6c:	e58d3014 	str	r3, [r13, #20]
		pos[1] = block_to_find / block_ptr_per_block;
8f63bf70:	fa0003af 	blx	8f63ce34 <__aeabi_uidivmod>
		*level = 2;
8f63bf74:	e3a04002 	mov	r4, #2
		pos[2] = block_to_find % block_ptr_per_block;		
8f63bf78:	e1cd01f8 	strd	r0, [r13, #24]
	if (level == 0) {
8f63bf7c:	eaffffd4 	b	8f63bed4 <file_block_to_fs_block+0x8c>
}
8f63bf80:	ebffdb0e 	bl	8f632bc0 <__stack_chk_fail>
8f63bf84:	8f74221c 	.word	0x8f74221c

8f63bf88 <ext2_read_inode>:

ssize_t ext2_read_inode(ext2_t *ext2, struct ext2_inode *inode, void *_buf, off_t offset, size_t len)
{
8f63bf88:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f63bf8c:	e28db020 	add	r11, r13, #32
8f63bf90:	e24dd024 	sub	r13, r13, #36	; 0x24
8f63bf94:	e59f330c 	ldr	r3, [pc, #780]	; 8f63c2a8 <ext2_read_inode+0x320>
8f63bf98:	e1a05000 	mov	r5, r0
8f63bf9c:	e59b4004 	ldr	r4, [r11, #4]
8f63bfa0:	e1a08001 	mov	r8, r1
8f63bfa4:	e59b9008 	ldr	r9, [r11, #8]
8f63bfa8:	e50b2030 	str	r2, [r11, #-48]	; 0xffffffd0
8f63bfac:	e5933000 	ldr	r3, [r3]
8f63bfb0:	e50b3028 	str	r3, [r11, #-40]	; 0xffffffd8
8f63bfb4:	e3a03000 	mov	r3, #0
8f63bfb8:	e59ba00c 	ldr	r10, [r11, #12]
	int err = 0;
    size_t bytes_read = 0;
	uint8_t *buf = _buf;

	/* calculate the file size */
	off_t file_size = ext2_file_len(ext2, inode);
8f63bfbc:	eb000124 	bl	8f63c454 <ext2_file_len>

	LTRACEF("inode %p, offset %lld, len %zd, file_size %lld\n", inode, offset, len, file_size);	

	/* trim the read */
	if (offset > file_size)
8f63bfc0:	e1500004 	cmp	r0, r4
8f63bfc4:	e0d13009 	sbcs	r3, r1, r9
8f63bfc8:	ba000055 	blt	8f63c124 <ext2_read_inode+0x19c>
		return 0;
	if (offset + len >= file_size)
8f63bfcc:	e09a2004 	adds	r2, r10, r4
8f63bfd0:	e2a93000 	adc	r3, r9, #0
8f63bfd4:	e1520000 	cmp	r2, r0
8f63bfd8:	e0d33001 	sbcs	r3, r3, r1
		len = file_size - offset;
8f63bfdc:	a040a004 	subge	r10, r0, r4
	if (len == 0)
8f63bfe0:	e35a0000 	cmp	r10, #0
8f63bfe4:	0a00004e 	beq	8f63c124 <ext2_read_inode+0x19c>
		return 0;
	
	/* calculate the starting file block */
	size_t file_block = (size_t)offset / (size_t)EXT2_BLOCK_SIZE(ext2->sb);
8f63bfe8:	e5957020 	ldr	r7, [r5, #32]

	/* handle partial first block */
	if ((offset % EXT2_BLOCK_SIZE(ext2->sb)) != 0) {
8f63bfec:	e3a02b01 	mov	r2, #1024	; 0x400
8f63bff0:	e3a03000 	mov	r3, #0
8f63bff4:	e1a00004 	mov	r0, r4
8f63bff8:	e1a06712 	lsl	r6, r2, r7
8f63bffc:	e1a01009 	mov	r1, r9
	size_t file_block = (size_t)offset / (size_t)EXT2_BLOCK_SIZE(ext2->sb);
8f63c000:	e287700a 	add	r7, r7, #10
	if ((offset % EXT2_BLOCK_SIZE(ext2->sb)) != 0) {
8f63c004:	e1a02006 	mov	r2, r6
	size_t file_block = (size_t)offset / (size_t)EXT2_BLOCK_SIZE(ext2->sb);
8f63c008:	e1a07734 	lsr	r7, r4, r7
	if ((offset % EXT2_BLOCK_SIZE(ext2->sb)) != 0) {
8f63c00c:	fa00043c 	blx	8f63d104 <__aeabi_ldivmod>
8f63c010:	e1923003 	orrs	r3, r2, r3
8f63c014:	1a000053 	bne	8f63c168 <ext2_read_inode+0x1e0>
		bytes_read += tocopy;
		buf += tocopy;
	}

	/* handle middle blocks */
	while (len >= EXT2_BLOCK_SIZE(ext2->sb)) {
8f63c018:	e156000a 	cmp	r6, r10
    size_t bytes_read = 0;
8f63c01c:	e3a03000 	mov	r3, #0
8f63c020:	e50b3038 	str	r3, [r11, #-56]	; 0xffffffc8
	while (len >= EXT2_BLOCK_SIZE(ext2->sb)) {
8f63c024:	8a00007c 	bhi	8f63c21c <ext2_read_inode+0x294>
		/* calculate the block and read it */
		blocknum_t phys_block = file_block_to_fs_block(ext2, inode, file_block);
        blocknum_t count_cont_blks = 1;
        blocknum_t max_blocks = len / EXT2_BLOCK_SIZE(ext2->sb);
		if (phys_block == 0) {
			memset(buf, 0, EXT2_BLOCK_SIZE(ext2->sb));
8f63c028:	e50ba034 	str	r10, [r11, #-52]	; 0xffffffcc
8f63c02c:	ea000015 	b	8f63c088 <ext2_read_inode+0x100>
8f63c030:	e3a03b01 	mov	r3, #1024	; 0x400
8f63c034:	e51b0030 	ldr	r0, [r11, #-48]	; 0xffffffd0
8f63c038:	e1a02213 	lsl	r2, r3, r2
8f63c03c:	e1a01006 	mov	r1, r6
8f63c040:	ebffe09f 	bl	8f6342c4 <memset>
            }
            bio_read(ext2->dev, buf, EXT2_BLOCK_SIZE(ext2->sb) * phys_block, EXT2_BLOCK_SIZE(ext2->sb) * count_cont_blks);
		}

		/* increment our stuff */
        file_block += count_cont_blks;
8f63c044:	e2877001 	add	r7, r7, #1
        blocknum_t count_cont_blks = 1;
8f63c048:	e3a04001 	mov	r4, #1
        len -= EXT2_BLOCK_SIZE(ext2->sb) * count_cont_blks;
8f63c04c:	e5956020 	ldr	r6, [r5, #32]
8f63c050:	e3a03b01 	mov	r3, #1024	; 0x400
        bytes_read += EXT2_BLOCK_SIZE(ext2->sb) * count_cont_blks;
8f63c054:	e51b2038 	ldr	r2, [r11, #-56]	; 0xffffffc8
        len -= EXT2_BLOCK_SIZE(ext2->sb) * count_cont_blks;
8f63c058:	e1a06613 	lsl	r6, r3, r6
8f63c05c:	e51b3034 	ldr	r3, [r11, #-52]	; 0xffffffcc
8f63c060:	e0040694 	mul	r4, r4, r6
8f63c064:	e0433004 	sub	r3, r3, r4
8f63c068:	e50b3034 	str	r3, [r11, #-52]	; 0xffffffcc
	while (len >= EXT2_BLOCK_SIZE(ext2->sb)) {
8f63c06c:	e1560003 	cmp	r6, r3
        buf += EXT2_BLOCK_SIZE(ext2->sb) * count_cont_blks;
8f63c070:	e51b3030 	ldr	r3, [r11, #-48]	; 0xffffffd0
        bytes_read += EXT2_BLOCK_SIZE(ext2->sb) * count_cont_blks;
8f63c074:	e0822004 	add	r2, r2, r4
8f63c078:	e50b2038 	str	r2, [r11, #-56]	; 0xffffffc8
        buf += EXT2_BLOCK_SIZE(ext2->sb) * count_cont_blks;
8f63c07c:	e0833004 	add	r3, r3, r4
8f63c080:	e50b3030 	str	r3, [r11, #-48]	; 0xffffffd0
	while (len >= EXT2_BLOCK_SIZE(ext2->sb)) {
8f63c084:	8a000032 	bhi	8f63c154 <ext2_read_inode+0x1cc>
		blocknum_t phys_block = file_block_to_fs_block(ext2, inode, file_block);
8f63c088:	e1a02007 	mov	r2, r7
8f63c08c:	e1a01008 	mov	r1, r8
8f63c090:	e1a00005 	mov	r0, r5
8f63c094:	ebffff6b 	bl	8f63be48 <file_block_to_fs_block>
        blocknum_t max_blocks = len / EXT2_BLOCK_SIZE(ext2->sb);
8f63c098:	e5952020 	ldr	r2, [r5, #32]
		if (phys_block == 0) {
8f63c09c:	e2506000 	subs	r6, r0, #0
8f63c0a0:	0affffe2 	beq	8f63c030 <ext2_read_inode+0xa8>
        blocknum_t max_blocks = len / EXT2_BLOCK_SIZE(ext2->sb);
8f63c0a4:	e51b3034 	ldr	r3, [r11, #-52]	; 0xffffffcc
8f63c0a8:	e282900a 	add	r9, r2, #10
8f63c0ac:	e1a09933 	lsr	r9, r3, r9
            while (count_cont_blks < max_blocks && file_block_to_fs_block(ext2, inode, file_block + count_cont_blks) == phys_block + count_cont_blks) {
8f63c0b0:	e3590001 	cmp	r9, #1
        file_block += count_cont_blks;
8f63c0b4:	92877001 	addls	r7, r7, #1
        blocknum_t count_cont_blks = 1;
8f63c0b8:	93a04001 	movls	r4, #1
            while (count_cont_blks < max_blocks && file_block_to_fs_block(ext2, inode, file_block + count_cont_blks) == phys_block + count_cont_blks) {
8f63c0bc:	9a00000e 	bls	8f63c0fc <ext2_read_inode+0x174>
        blocknum_t count_cont_blks = 1;
8f63c0c0:	e3a04001 	mov	r4, #1
8f63c0c4:	ea000002 	b	8f63c0d4 <ext2_read_inode+0x14c>
                count_cont_blks++;
8f63c0c8:	e2844001 	add	r4, r4, #1
            while (count_cont_blks < max_blocks && file_block_to_fs_block(ext2, inode, file_block + count_cont_blks) == phys_block + count_cont_blks) {
8f63c0cc:	e1590004 	cmp	r9, r4
8f63c0d0:	0a00001c 	beq	8f63c148 <ext2_read_inode+0x1c0>
8f63c0d4:	e087a004 	add	r10, r7, r4
8f63c0d8:	e1a01008 	mov	r1, r8
8f63c0dc:	e1a00005 	mov	r0, r5
8f63c0e0:	e1a0200a 	mov	r2, r10
8f63c0e4:	ebffff57 	bl	8f63be48 <file_block_to_fs_block>
8f63c0e8:	e0863004 	add	r3, r6, r4
8f63c0ec:	e1500003 	cmp	r0, r3
8f63c0f0:	0afffff4 	beq	8f63c0c8 <ext2_read_inode+0x140>
            bio_read(ext2->dev, buf, EXT2_BLOCK_SIZE(ext2->sb) * phys_block, EXT2_BLOCK_SIZE(ext2->sb) * count_cont_blks);
8f63c0f4:	e5952020 	ldr	r2, [r5, #32]
8f63c0f8:	e1a0700a 	mov	r7, r10
8f63c0fc:	e3a03b01 	mov	r3, #1024	; 0x400
8f63c100:	e5950000 	ldr	r0, [r5]
8f63c104:	e1a03213 	lsl	r3, r3, r2
8f63c108:	e0020396 	mul	r2, r6, r3
8f63c10c:	e0030394 	mul	r3, r4, r3
8f63c110:	e58d3000 	str	r3, [r13]
8f63c114:	e3a03000 	mov	r3, #0
8f63c118:	e51b1030 	ldr	r1, [r11, #-48]	; 0xffffffd0
8f63c11c:	ebffec25 	bl	8f6371b8 <bio_read>
8f63c120:	eaffffc9 	b	8f63c04c <ext2_read_inode+0xc4>
		return 0;
8f63c124:	e3a00000 	mov	r0, #0
	}

    LTRACEF("err %d, bytes_read %zu\n", err, bytes_read);

    return (err < 0) ? err : (ssize_t)bytes_read;
}
8f63c128:	e59f3178 	ldr	r3, [pc, #376]	; 8f63c2a8 <ext2_read_inode+0x320>
8f63c12c:	e5932000 	ldr	r2, [r3]
8f63c130:	e51b3028 	ldr	r3, [r11, #-40]	; 0xffffffd8
8f63c134:	e0332002 	eors	r2, r3, r2
8f63c138:	e3a03000 	mov	r3, #0
8f63c13c:	1a000058 	bne	8f63c2a4 <ext2_read_inode+0x31c>
8f63c140:	e24bd020 	sub	r13, r11, #32
8f63c144:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
            bio_read(ext2->dev, buf, EXT2_BLOCK_SIZE(ext2->sb) * phys_block, EXT2_BLOCK_SIZE(ext2->sb) * count_cont_blks);
8f63c148:	e5952020 	ldr	r2, [r5, #32]
        file_block += count_cont_blks;
8f63c14c:	e0877004 	add	r7, r7, r4
8f63c150:	eaffffe9 	b	8f63c0fc <ext2_read_inode+0x174>
8f63c154:	e51ba034 	ldr	r10, [r11, #-52]	; 0xffffffcc
	if (len > 0) {
8f63c158:	e35a0000 	cmp	r10, #0
8f63c15c:	1a00002e 	bne	8f63c21c <ext2_read_inode+0x294>
    return (err < 0) ? err : (ssize_t)bytes_read;
8f63c160:	e51b0038 	ldr	r0, [r11, #-56]	; 0xffffffc8
8f63c164:	eaffffef 	b	8f63c128 <ext2_read_inode+0x1a0>
		uint8_t temp[EXT2_BLOCK_SIZE(ext2->sb)];
8f63c168:	e2863007 	add	r3, r6, #7
		size_t phys_block = file_block_to_fs_block(ext2, inode, file_block);
8f63c16c:	e1a02007 	mov	r2, r7
		uint8_t temp[EXT2_BLOCK_SIZE(ext2->sb)];
8f63c170:	e3c33007 	bic	r3, r3, #7
	if ((offset % EXT2_BLOCK_SIZE(ext2->sb)) != 0) {
8f63c174:	e50bd03c 	str	r13, [r11, #-60]	; 0xffffffc4
		size_t phys_block = file_block_to_fs_block(ext2, inode, file_block);
8f63c178:	e1a01008 	mov	r1, r8
		uint8_t temp[EXT2_BLOCK_SIZE(ext2->sb)];
8f63c17c:	e04dd003 	sub	r13, r13, r3
		size_t phys_block = file_block_to_fs_block(ext2, inode, file_block);
8f63c180:	e1a00005 	mov	r0, r5
8f63c184:	ebffff2f 	bl	8f63be48 <file_block_to_fs_block>
		if (phys_block == 0) {
8f63c188:	e2502000 	subs	r2, r0, #0
		uint8_t temp[EXT2_BLOCK_SIZE(ext2->sb)];
8f63c18c:	e28d0008 	add	r0, r13, #8
8f63c190:	e50b0034 	str	r0, [r11, #-52]	; 0xffffffcc
		if (phys_block == 0) {
8f63c194:	1a000039 	bne	8f63c280 <ext2_read_inode+0x2f8>
			memset(temp, 0, EXT2_BLOCK_SIZE(ext2->sb));
8f63c198:	e1a01002 	mov	r1, r2
8f63c19c:	e5952020 	ldr	r2, [r5, #32]
8f63c1a0:	e3a03b01 	mov	r3, #1024	; 0x400
8f63c1a4:	e1a02213 	lsl	r2, r3, r2
8f63c1a8:	ebffe045 	bl	8f6342c4 <memset>
		size_t block_offset = offset % (size_t)EXT2_BLOCK_SIZE(ext2->sb);
8f63c1ac:	e1a00004 	mov	r0, r4
8f63c1b0:	e5954020 	ldr	r4, [r5, #32]
8f63c1b4:	e3a06b01 	mov	r6, #1024	; 0x400
8f63c1b8:	e1a01009 	mov	r1, r9
8f63c1bc:	e1a04416 	lsl	r4, r6, r4
8f63c1c0:	e3a03000 	mov	r3, #0
		file_block++;
8f63c1c4:	e2877001 	add	r7, r7, #1
		size_t block_offset = offset % (size_t)EXT2_BLOCK_SIZE(ext2->sb);
8f63c1c8:	e1a02004 	mov	r2, r4
8f63c1cc:	fa0003cc 	blx	8f63d104 <__aeabi_ldivmod>
		memcpy(buf, temp + block_offset, tocopy);
8f63c1d0:	e51b3034 	ldr	r3, [r11, #-52]	; 0xffffffcc
		size_t tocopy = (size_t)MIN((size_t)len, (size_t)EXT2_BLOCK_SIZE(ext2->sb) - (size_t)block_offset);
8f63c1d4:	e0444002 	sub	r4, r4, r2
		memcpy(buf, temp + block_offset, tocopy);
8f63c1d8:	e0831002 	add	r1, r3, r2
8f63c1dc:	e51b3030 	ldr	r3, [r11, #-48]	; 0xffffffd0
		size_t tocopy = (size_t)MIN((size_t)len, (size_t)EXT2_BLOCK_SIZE(ext2->sb) - (size_t)block_offset);
8f63c1e0:	e154000a 	cmp	r4, r10
8f63c1e4:	31a02004 	movcc	r2, r4
8f63c1e8:	21a0200a 	movcs	r2, r10
		memcpy(buf, temp + block_offset, tocopy);
8f63c1ec:	e1a00003 	mov	r0, r3
		len -= tocopy;
8f63c1f0:	e04aa002 	sub	r10, r10, r2
		buf += tocopy;
8f63c1f4:	e0833002 	add	r3, r3, r2
		size_t tocopy = (size_t)MIN((size_t)len, (size_t)EXT2_BLOCK_SIZE(ext2->sb) - (size_t)block_offset);
8f63c1f8:	e50b2038 	str	r2, [r11, #-56]	; 0xffffffc8
		buf += tocopy;
8f63c1fc:	e50b3030 	str	r3, [r11, #-48]	; 0xffffffd0
		memcpy(buf, temp + block_offset, tocopy);
8f63c200:	ebffdfec 	bl	8f6341b8 <memcpy>
	while (len >= EXT2_BLOCK_SIZE(ext2->sb)) {
8f63c204:	e5953020 	ldr	r3, [r5, #32]
8f63c208:	e51bd03c 	ldr	r13, [r11, #-60]	; 0xffffffc4
8f63c20c:	e15a0316 	cmp	r10, r6, lsl r3
8f63c210:	e1a06316 	lsl	r6, r6, r3
8f63c214:	2affff83 	bcs	8f63c028 <ext2_read_inode+0xa0>
8f63c218:	eaffffce 	b	8f63c158 <ext2_read_inode+0x1d0>
		uint8_t temp[EXT2_BLOCK_SIZE(ext2->sb)];
8f63c21c:	e2863007 	add	r3, r6, #7
		size_t phys_block = file_block_to_fs_block(ext2, inode, file_block);
8f63c220:	e1a01008 	mov	r1, r8
		uint8_t temp[EXT2_BLOCK_SIZE(ext2->sb)];
8f63c224:	e3c33007 	bic	r3, r3, #7
		size_t phys_block = file_block_to_fs_block(ext2, inode, file_block);
8f63c228:	e1a02007 	mov	r2, r7
	if (len > 0) {
8f63c22c:	e1a0400d 	mov	r4, r13
		size_t phys_block = file_block_to_fs_block(ext2, inode, file_block);
8f63c230:	e1a00005 	mov	r0, r5
		uint8_t temp[EXT2_BLOCK_SIZE(ext2->sb)];
8f63c234:	e04dd003 	sub	r13, r13, r3
		size_t phys_block = file_block_to_fs_block(ext2, inode, file_block);
8f63c238:	ebffff02 	bl	8f63be48 <file_block_to_fs_block>
		uint8_t temp[EXT2_BLOCK_SIZE(ext2->sb)];
8f63c23c:	e28d6008 	add	r6, r13, #8
		if (phys_block == 0) {
8f63c240:	e2501000 	subs	r1, r0, #0
8f63c244:	1a000011 	bne	8f63c290 <ext2_read_inode+0x308>
			memset(temp, 0, EXT2_BLOCK_SIZE(ext2->sb));
8f63c248:	e5953020 	ldr	r3, [r5, #32]
8f63c24c:	e3a02b01 	mov	r2, #1024	; 0x400
8f63c250:	e1a00006 	mov	r0, r6
8f63c254:	e1a02312 	lsl	r2, r2, r3
8f63c258:	ebffe019 	bl	8f6342c4 <memset>
		bytes_read += len;
8f63c25c:	e51b3038 	ldr	r3, [r11, #-56]	; 0xffffffc8
		memcpy(buf, temp, len);
8f63c260:	e1a0200a 	mov	r2, r10
8f63c264:	e51b0030 	ldr	r0, [r11, #-48]	; 0xffffffd0
8f63c268:	e1a01006 	mov	r1, r6
		bytes_read += len;
8f63c26c:	e083300a 	add	r3, r3, r10
8f63c270:	e50b3038 	str	r3, [r11, #-56]	; 0xffffffc8
		memcpy(buf, temp, len);
8f63c274:	ebffdfcf 	bl	8f6341b8 <memcpy>
		bytes_read += len;
8f63c278:	e1a0d004 	mov	r13, r4
8f63c27c:	eaffffb7 	b	8f63c160 <ext2_read_inode+0x1d8>
	return bcache_read_block(ext2->cache, buf, bnum);
8f63c280:	e5950004 	ldr	r0, [r5, #4]
8f63c284:	e51b1034 	ldr	r1, [r11, #-52]	; 0xffffffcc
8f63c288:	eb0001f6 	bl	8f63ca68 <bcache_read_block>
8f63c28c:	eaffffc6 	b	8f63c1ac <ext2_read_inode+0x224>
8f63c290:	e1a02001 	mov	r2, r1
8f63c294:	e5950004 	ldr	r0, [r5, #4]
8f63c298:	e1a01006 	mov	r1, r6
8f63c29c:	eb0001f1 	bl	8f63ca68 <bcache_read_block>
8f63c2a0:	eaffffed 	b	8f63c25c <ext2_read_inode+0x2d4>
}
8f63c2a4:	ebffda45 	bl	8f632bc0 <__stack_chk_fail>
8f63c2a8:	8f74221c 	.word	0x8f74221c

8f63c2ac <ext2_open_file>:
#include "ext2_priv.h"

#define LOCAL_TRACE 0

int ext2_open_file(fscookie *cookie, const char *path, filecookie **fcookie)
{
8f63c2ac:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f63c2b0:	e24dd00c 	sub	r13, r13, #12
8f63c2b4:	e59f3090 	ldr	r3, [pc, #144]	; 8f63c34c <ext2_open_file+0xa0>
8f63c2b8:	e1a06002 	mov	r6, r2
	ext2_t *ext2 = (ext2_t *)cookie;
	int err;

	/* do a path lookup */
	inodenum_t inum;
	err = ext2_lookup(ext2, path, &inum);
8f63c2bc:	e1a0200d 	mov	r2, r13
{
8f63c2c0:	e1a05000 	mov	r5, r0
8f63c2c4:	e5933000 	ldr	r3, [r3]
8f63c2c8:	e58d3004 	str	r3, [r13, #4]
8f63c2cc:	e3a03000 	mov	r3, #0
	err = ext2_lookup(ext2, path, &inum);
8f63c2d0:	ebfffdf8 	bl	8f63bab8 <ext2_lookup>
	if (err < 0)
8f63c2d4:	e2504000 	subs	r4, r0, #0
8f63c2d8:	ba00000e 	blt	8f63c318 <ext2_open_file+0x6c>
		return err;

	/* create the file object */
	ext2_file_t *file = malloc(sizeof(ext2_file_t));
8f63c2dc:	e3a0009c 	mov	r0, #156	; 0x9c
8f63c2e0:	ebffdf45 	bl	8f633ffc <malloc>
	memset(file, 0, sizeof(ext2_file_t));
8f63c2e4:	e3a0209c 	mov	r2, #156	; 0x9c
8f63c2e8:	e3a01000 	mov	r1, #0
	ext2_file_t *file = malloc(sizeof(ext2_file_t));
8f63c2ec:	e1a07000 	mov	r7, r0
	memset(file, 0, sizeof(ext2_file_t));
8f63c2f0:	ebffdff3 	bl	8f6342c4 <memset>

	/* read in the inode */
	err = ext2_load_inode(ext2, inum, &file->inode);
8f63c2f4:	e59d1000 	ldr	r1, [r13]
8f63c2f8:	e287201c 	add	r2, r7, #28
8f63c2fc:	e1a00005 	mov	r0, r5
8f63c300:	ebfffc9a 	bl	8f63b570 <ext2_load_inode>
	if (err < 0) {
8f63c304:	e2504000 	subs	r4, r0, #0
		free(file);
		return err;
	}

	file->ext2 = ext2;
8f63c308:	a5875000 	strge	r5, [r7]
    *fcookie = (filecookie *)file;
8f63c30c:	a5867000 	strge	r7, [r6]

	return 0;
8f63c310:	a3a04000 	movge	r4, #0
	if (err < 0) {
8f63c314:	ba000008 	blt	8f63c33c <ext2_open_file+0x90>
}
8f63c318:	e59f302c 	ldr	r3, [pc, #44]	; 8f63c34c <ext2_open_file+0xa0>
8f63c31c:	e5932000 	ldr	r2, [r3]
8f63c320:	e59d3004 	ldr	r3, [r13, #4]
8f63c324:	e0332002 	eors	r2, r3, r2
8f63c328:	e3a03000 	mov	r3, #0
8f63c32c:	1a000005 	bne	8f63c348 <ext2_open_file+0x9c>
8f63c330:	e1a00004 	mov	r0, r4
8f63c334:	e28dd00c 	add	r13, r13, #12
8f63c338:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
		free(file);
8f63c33c:	e1a00007 	mov	r0, r7
8f63c340:	ebffdf71 	bl	8f63410c <free>
		return err;
8f63c344:	eafffff3 	b	8f63c318 <ext2_open_file+0x6c>
}
8f63c348:	ebffda1c 	bl	8f632bc0 <__stack_chk_fail>
8f63c34c:	8f74221c 	.word	0x8f74221c

8f63c350 <ext2_read_file>:
{
	ext2_file_t *file = (ext2_file_t *)fcookie;
	int err;

	// test that it's a file
	if (!S_ISREG(file->inode.i_mode)) {
8f63c350:	e1d0c1bc 	ldrh	r12, [r0, #28]
{
8f63c354:	e92d4010 	push	{r4, r14}
	if (!S_ISREG(file->inode.i_mode)) {
8f63c358:	e20cca0f 	and	r12, r12, #61440	; 0xf000
{
8f63c35c:	e24dd018 	sub	r13, r13, #24
8f63c360:	e1a0e002 	mov	r14, r2
	if (!S_ISREG(file->inode.i_mode)) {
8f63c364:	e35c0902 	cmp	r12, #32768	; 0x8000
{
8f63c368:	e1a02001 	mov	r2, r1
8f63c36c:	e59f1060 	ldr	r1, [pc, #96]	; 8f63c3d4 <ext2_read_file+0x84>
8f63c370:	e59d4020 	ldr	r4, [r13, #32]
8f63c374:	e5911000 	ldr	r1, [r1]
8f63c378:	e58d1014 	str	r1, [r13, #20]
8f63c37c:	e3a01000 	mov	r1, #0
	if (!S_ISREG(file->inode.i_mode)) {
8f63c380:	1a00000d 	bne	8f63c3bc <ext2_read_file+0x6c>
		dprintf(INFO, "ext2_read_file: not a file\n");
		return -1;
	}

	// read from the inode
	err = ext2_read_inode(file->ext2, &file->inode, buf, offset, len);
8f63c384:	e1a01000 	mov	r1, r0
8f63c388:	e58d4008 	str	r4, [r13, #8]
8f63c38c:	e58de000 	str	r14, [r13]
8f63c390:	e58d3004 	str	r3, [r13, #4]
8f63c394:	e491001c 	ldr	r0, [r1], #28
8f63c398:	ebfffefa 	bl	8f63bf88 <ext2_read_inode>

	return err;
}
8f63c39c:	e59f3030 	ldr	r3, [pc, #48]	; 8f63c3d4 <ext2_read_file+0x84>
8f63c3a0:	e5932000 	ldr	r2, [r3]
8f63c3a4:	e59d3014 	ldr	r3, [r13, #20]
8f63c3a8:	e0332002 	eors	r2, r3, r2
8f63c3ac:	e3a03000 	mov	r3, #0
8f63c3b0:	1a000006 	bne	8f63c3d0 <ext2_read_file+0x80>
8f63c3b4:	e28dd018 	add	r13, r13, #24
8f63c3b8:	e8bd8010 	pop	{r4, r15}
		dprintf(INFO, "ext2_read_file: not a file\n");
8f63c3bc:	e30c0054 	movw	r0, #49236	; 0xc054
8f63c3c0:	e3480f70 	movt	r0, #36720	; 0x8f70
8f63c3c4:	ebffd96a 	bl	8f632974 <_dprintf>
		return -1;
8f63c3c8:	e3e00000 	mvn	r0, #0
8f63c3cc:	eafffff2 	b	8f63c39c <ext2_read_file+0x4c>
}
8f63c3d0:	ebffd9fa 	bl	8f632bc0 <__stack_chk_fail>
8f63c3d4:	8f74221c 	.word	0x8f74221c

8f63c3d8 <ext2_close_file>:

int ext2_close_file(filecookie *fcookie)
{
8f63c3d8:	e59f3070 	ldr	r3, [pc, #112]	; 8f63c450 <ext2_close_file+0x78>
8f63c3dc:	e92d4070 	push	{r4, r5, r6, r14}
8f63c3e0:	e24dd008 	sub	r13, r13, #8
8f63c3e4:	e5933000 	ldr	r3, [r3]
8f63c3e8:	e58d3004 	str	r3, [r13, #4]
8f63c3ec:	e3a03000 	mov	r3, #0
	ext2_file_t *file = (ext2_file_t *)fcookie;
8f63c3f0:	e2806018 	add	r6, r0, #24
{
8f63c3f4:	e1a05000 	mov	r5, r0

	// see if we need to free any of the cache blocks
	int i;
	for (i=0; i < 3; i++) {
8f63c3f8:	e1a04000 	mov	r4, r0
		if (file->ind_cache[i].num != 0) {
8f63c3fc:	e5943004 	ldr	r3, [r4, #4]
8f63c400:	e3530000 	cmp	r3, #0
8f63c404:	1a00000d 	bne	8f63c440 <ext2_close_file+0x68>
	for (i=0; i < 3; i++) {
8f63c408:	e2844008 	add	r4, r4, #8
8f63c40c:	e1540006 	cmp	r4, r6
8f63c410:	1afffff9 	bne	8f63c3fc <ext2_close_file+0x24>
			free(file->ind_cache[i].ptr);
		}
	}

	free(file);
8f63c414:	e1a00005 	mov	r0, r5
8f63c418:	ebffdf3b 	bl	8f63410c <free>

	return 0;
}
8f63c41c:	e59f302c 	ldr	r3, [pc, #44]	; 8f63c450 <ext2_close_file+0x78>
8f63c420:	e5932000 	ldr	r2, [r3]
8f63c424:	e59d3004 	ldr	r3, [r13, #4]
8f63c428:	e0332002 	eors	r2, r3, r2
8f63c42c:	e3a03000 	mov	r3, #0
8f63c430:	1a000005 	bne	8f63c44c <ext2_close_file+0x74>
8f63c434:	e3a00000 	mov	r0, #0
8f63c438:	e28dd008 	add	r13, r13, #8
8f63c43c:	e8bd8070 	pop	{r4, r5, r6, r15}
			free(file->ind_cache[i].ptr);
8f63c440:	e5940008 	ldr	r0, [r4, #8]
8f63c444:	ebffdf30 	bl	8f63410c <free>
8f63c448:	eaffffee 	b	8f63c408 <ext2_close_file+0x30>
}
8f63c44c:	ebffd9db 	bl	8f632bc0 <__stack_chk_fail>
8f63c450:	8f74221c 	.word	0x8f74221c

8f63c454 <ext2_file_len>:

off_t ext2_file_len(ext2_t *ext2, struct ext2_inode *inode)
{
	/* calculate the file size */
	off_t len = inode->i_size;
	if ((ext2->sb.s_feature_ro_compat & EXT2_FEATURE_RO_COMPAT_LARGE_FILE) && (S_ISREG(inode->i_mode))) {
8f63c454:	e590206c 	ldr	r2, [r0, #108]	; 0x6c
{
8f63c458:	e1a03001 	mov	r3, r1
8f63c45c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	if ((ext2->sb.s_feature_ro_compat & EXT2_FEATURE_RO_COMPAT_LARGE_FILE) && (S_ISREG(inode->i_mode))) {
8f63c460:	e3120002 	tst	r2, #2
{
8f63c464:	e59f204c 	ldr	r2, [pc, #76]	; 8f63c4b8 <ext2_file_len+0x64>
8f63c468:	e24dd00c 	sub	r13, r13, #12
	off_t len = inode->i_size;
8f63c46c:	e5910004 	ldr	r0, [r1, #4]
8f63c470:	e3a01000 	mov	r1, #0
{
8f63c474:	e5922000 	ldr	r2, [r2]
8f63c478:	e58d2004 	str	r2, [r13, #4]
8f63c47c:	e3a02000 	mov	r2, #0
	if ((ext2->sb.s_feature_ro_compat & EXT2_FEATURE_RO_COMPAT_LARGE_FILE) && (S_ISREG(inode->i_mode))) {
8f63c480:	0a000003 	beq	8f63c494 <ext2_file_len+0x40>
8f63c484:	e1d320b0 	ldrh	r2, [r3]
8f63c488:	e2022a0f 	and	r2, r2, #61440	; 0xf000
8f63c48c:	e3520902 	cmp	r2, #32768	; 0x8000
		/* can potentially be a large file */
		len |= (off_t)inode->i_size_high << 32;
8f63c490:	0593106c 	ldreq	r1, [r3, #108]	; 0x6c
	}

	return len;
}
8f63c494:	e59f301c 	ldr	r3, [pc, #28]	; 8f63c4b8 <ext2_file_len+0x64>
8f63c498:	e5932000 	ldr	r2, [r3]
8f63c49c:	e59d3004 	ldr	r3, [r13, #4]
8f63c4a0:	e0332002 	eors	r2, r3, r2
8f63c4a4:	e3a03000 	mov	r3, #0
8f63c4a8:	1a000001 	bne	8f63c4b4 <ext2_file_len+0x60>
8f63c4ac:	e28dd00c 	add	r13, r13, #12
8f63c4b0:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f63c4b4:	ebffd9c1 	bl	8f632bc0 <__stack_chk_fail>
8f63c4b8:	8f74221c 	.word	0x8f74221c

8f63c4bc <ext2_stat_file>:
	if ((ext2->sb.s_feature_ro_compat & EXT2_FEATURE_RO_COMPAT_LARGE_FILE) && (S_ISREG(inode->i_mode))) {
8f63c4bc:	e5903000 	ldr	r3, [r0]
	off_t len = inode->i_size;
8f63c4c0:	e3a0c000 	mov	r12, #0

int ext2_stat_file(filecookie *fcookie, struct file_stat *stat)
{
8f63c4c4:	e92d4010 	push	{r4, r14}
8f63c4c8:	e24dd008 	sub	r13, r13, #8
	if ((ext2->sb.s_feature_ro_compat & EXT2_FEATURE_RO_COMPAT_LARGE_FILE) && (S_ISREG(inode->i_mode))) {
8f63c4cc:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
{
8f63c4d0:	e59fe078 	ldr	r14, [pc, #120]	; 8f63c550 <ext2_stat_file+0x94>
	if ((ext2->sb.s_feature_ro_compat & EXT2_FEATURE_RO_COMPAT_LARGE_FILE) && (S_ISREG(inode->i_mode))) {
8f63c4d4:	e3130002 	tst	r3, #2
8f63c4d8:	e1d031bc 	ldrh	r3, [r0, #28]
	off_t len = inode->i_size;
8f63c4dc:	e5902020 	ldr	r2, [r0, #32]
{
8f63c4e0:	e59ee000 	ldr	r14, [r14]
8f63c4e4:	e58de004 	str	r14, [r13, #4]
8f63c4e8:	e3a0e000 	mov	r14, #0
	if ((ext2->sb.s_feature_ro_compat & EXT2_FEATURE_RO_COMPAT_LARGE_FILE) && (S_ISREG(inode->i_mode))) {
8f63c4ec:	e2033a0f 	and	r3, r3, #61440	; 0xf000
8f63c4f0:	0a000001 	beq	8f63c4fc <ext2_stat_file+0x40>
8f63c4f4:	e3530902 	cmp	r3, #32768	; 0x8000
8f63c4f8:	0a000010 	beq	8f63c540 <ext2_stat_file+0x84>

	stat->size = ext2_file_len(file->ext2, &file->inode);

	/* is it a dir? */
	stat->is_dir = false;
	if (S_ISDIR(file->inode.i_mode))
8f63c4fc:	e3530901 	cmp	r3, #16384	; 0x4000
	stat->size = ext2_file_len(file->ext2, &file->inode);
8f63c500:	e5812008 	str	r2, [r1, #8]
8f63c504:	e581c00c 	str	r12, [r1, #12]
		stat->is_dir = true;
8f63c508:	03a03001 	moveq	r3, #1
8f63c50c:	05813000 	streq	r3, [r1]
	if (S_ISDIR(file->inode.i_mode))
8f63c510:	0a000001 	beq	8f63c51c <ext2_stat_file+0x60>
	stat->is_dir = false;
8f63c514:	e3a03000 	mov	r3, #0
8f63c518:	e5813000 	str	r3, [r1]

	return 0;
}
8f63c51c:	e59f302c 	ldr	r3, [pc, #44]	; 8f63c550 <ext2_stat_file+0x94>
8f63c520:	e5932000 	ldr	r2, [r3]
8f63c524:	e59d3004 	ldr	r3, [r13, #4]
8f63c528:	e0332002 	eors	r2, r3, r2
8f63c52c:	e3a03000 	mov	r3, #0
8f63c530:	1a000005 	bne	8f63c54c <ext2_stat_file+0x90>
8f63c534:	e3a00000 	mov	r0, #0
8f63c538:	e28dd008 	add	r13, r13, #8
8f63c53c:	e8bd8010 	pop	{r4, r15}
		len |= (off_t)inode->i_size_high << 32;
8f63c540:	e5903088 	ldr	r3, [r0, #136]	; 0x88
	stat->size = ext2_file_len(file->ext2, &file->inode);
8f63c544:	e1c120f8 	strd	r2, [r1, #8]
	if (S_ISDIR(file->inode.i_mode))
8f63c548:	eafffff1 	b	8f63c514 <ext2_stat_file+0x58>
}
8f63c54c:	ebffd99b 	bl	8f632bc0 <__stack_chk_fail>
8f63c550:	8f74221c 	.word	0x8f74221c

8f63c554 <ext2_read_link>:

int ext2_read_link(ext2_t *ext2, struct ext2_inode *inode, char *str, size_t len)
{
8f63c554:	e92d4370 	push	{r4, r5, r6, r8, r9, r14}
8f63c558:	e1a05002 	mov	r5, r2
8f63c55c:	e59f20c8 	ldr	r2, [pc, #200]	; 8f63c62c <ext2_read_link+0xd8>
8f63c560:	e24dd018 	sub	r13, r13, #24
	off_t len = inode->i_size;
8f63c564:	e5914004 	ldr	r4, [r1, #4]
{
8f63c568:	e5922000 	ldr	r2, [r2]
8f63c56c:	e58d2014 	str	r2, [r13, #20]
8f63c570:	e3a02000 	mov	r2, #0
	if ((ext2->sb.s_feature_ro_compat & EXT2_FEATURE_RO_COMPAT_LARGE_FILE) && (S_ISREG(inode->i_mode))) {
8f63c574:	e590206c 	ldr	r2, [r0, #108]	; 0x6c
8f63c578:	e3120002 	tst	r2, #2
	off_t len = inode->i_size;
8f63c57c:	e3a02000 	mov	r2, #0
	if ((ext2->sb.s_feature_ro_compat & EXT2_FEATURE_RO_COMPAT_LARGE_FILE) && (S_ISREG(inode->i_mode))) {
8f63c580:	0a000003 	beq	8f63c594 <ext2_read_link+0x40>
8f63c584:	e1d1c0b0 	ldrh	r12, [r1]
8f63c588:	e20cca0f 	and	r12, r12, #61440	; 0xf000
8f63c58c:	e35c0902 	cmp	r12, #32768	; 0x8000
8f63c590:	0a00001f 	beq	8f63c614 <ext2_read_link+0xc0>
	LTRACEF("inode %p, str %p, len %d\n", inode, str, len);

	off_t linklen = ext2_file_len(ext2, inode);

	if ((linklen < 0) || (linklen + 1 > len))
8f63c594:	e294e001 	adds	r14, r4, #1
8f63c598:	e3a06000 	mov	r6, #0
8f63c59c:	e2a2c000 	adc	r12, r2, #0
8f63c5a0:	e153000e 	cmp	r3, r14
8f63c5a4:	e0d6300c 	sbcs	r3, r6, r12
8f63c5a8:	ba00001c 	blt	8f63c620 <ext2_read_link+0xcc>
		return ERR_NO_MEMORY;

	if (linklen > 60) {
8f63c5ac:	e354003d 	cmp	r4, #61	; 0x3d
8f63c5b0:	e2d23000 	sbcs	r3, r2, #0
8f63c5b4:	aa00000d 	bge	8f63c5f0 <ext2_read_link+0x9c>
		int err = ext2_read_inode(ext2, inode, str, 0, linklen);
		if (err < 0)
			return err;
		str[linklen] = 0;
	} else {
		memcpy(str, &inode->i_block[0], linklen);	
8f63c5b8:	e2811028 	add	r1, r1, #40	; 0x28
8f63c5bc:	e1a02004 	mov	r2, r4
8f63c5c0:	e1a00005 	mov	r0, r5
8f63c5c4:	ebffdefb 	bl	8f6341b8 <memcpy>
		str[linklen] = 0;
	}

	LTRACEF("read link '%s'\n", str);

	return linklen;
8f63c5c8:	e1a00004 	mov	r0, r4
		str[linklen] = 0;
8f63c5cc:	e7c56004 	strb	r6, [r5, r4]
}
8f63c5d0:	e59f3054 	ldr	r3, [pc, #84]	; 8f63c62c <ext2_read_link+0xd8>
8f63c5d4:	e5932000 	ldr	r2, [r3]
8f63c5d8:	e59d3014 	ldr	r3, [r13, #20]
8f63c5dc:	e0332002 	eors	r2, r3, r2
8f63c5e0:	e3a03000 	mov	r3, #0
8f63c5e4:	1a00000f 	bne	8f63c628 <ext2_read_link+0xd4>
8f63c5e8:	e28dd018 	add	r13, r13, #24
8f63c5ec:	e8bd8370 	pop	{r4, r5, r6, r8, r9, r15}
		int err = ext2_read_inode(ext2, inode, str, 0, linklen);
8f63c5f0:	e1a02005 	mov	r2, r5
8f63c5f4:	e3a08000 	mov	r8, #0
8f63c5f8:	e3a09000 	mov	r9, #0
8f63c5fc:	e58d4008 	str	r4, [r13, #8]
8f63c600:	e1cd80f0 	strd	r8, [r13]
8f63c604:	ebfffe5f 	bl	8f63bf88 <ext2_read_inode>
		if (err < 0)
8f63c608:	e3500000 	cmp	r0, #0
8f63c60c:	aaffffed 	bge	8f63c5c8 <ext2_read_link+0x74>
8f63c610:	eaffffee 	b	8f63c5d0 <ext2_read_link+0x7c>
		len |= (off_t)inode->i_size_high << 32;
8f63c614:	e591206c 	ldr	r2, [r1, #108]	; 0x6c
	if ((linklen < 0) || (linklen + 1 > len))
8f63c618:	e3520000 	cmp	r2, #0
8f63c61c:	aaffffdc 	bge	8f63c594 <ext2_read_link+0x40>
		return ERR_NO_MEMORY;
8f63c620:	e3e00004 	mvn	r0, #4
8f63c624:	eaffffe9 	b	8f63c5d0 <ext2_read_link+0x7c>
}
8f63c628:	ebffd964 	bl	8f632bc0 <__stack_chk_fail>
8f63c62c:	8f74221c 	.word	0x8f74221c

8f63c630 <find_block>:
	free(cache);
}

/* find a block if it's already present */
static struct bcache_block *find_block(struct bcache *cache, uint blocknum)
{
8f63c630:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	struct bcache_block *block;

	LTRACEF("num %u\n", blocknum);

	block = NULL;
	list_for_every_entry(&cache->lru_list, block, struct bcache_block, node) {
8f63c634:	e280c028 	add	r12, r0, #40	; 0x28
{
8f63c638:	e1a0e000 	mov	r14, r0
	list_for_every_entry(&cache->lru_list, block, struct bcache_block, node) {
8f63c63c:	e590002c 	ldr	r0, [r0, #44]	; 0x2c
{
8f63c640:	e59f30b4 	ldr	r3, [pc, #180]	; 8f63c6fc <find_block+0xcc>
8f63c644:	e24dd00c 	sub	r13, r13, #12
	list_for_every_entry(&cache->lru_list, block, struct bcache_block, node) {
8f63c648:	e150000c 	cmp	r0, r12
{
8f63c64c:	e5933000 	ldr	r3, [r3]
8f63c650:	e58d3004 	str	r3, [r13, #4]
8f63c654:	e3a03000 	mov	r3, #0
	list_for_every_entry(&cache->lru_list, block, struct bcache_block, node) {
8f63c658:	0a00001a 	beq	8f63c6c8 <find_block+0x98>
	uint32_t depth = 0;
8f63c65c:	e3a03000 	mov	r3, #0
8f63c660:	ea000002 	b	8f63c670 <find_block+0x40>
	list_for_every_entry(&cache->lru_list, block, struct bcache_block, node) {
8f63c664:	e5900004 	ldr	r0, [r0, #4]
8f63c668:	e15c0000 	cmp	r12, r0
8f63c66c:	0a000015 	beq	8f63c6c8 <find_block+0x98>
		LTRACEF("looking at entry %p, num %u\n", block, block->blocknum);
		depth++;

		if (block->blocknum == blocknum) {
8f63c670:	e5902008 	ldr	r2, [r0, #8]
		depth++;
8f63c674:	e2833001 	add	r3, r3, #1
		if (block->blocknum == blocknum) {
8f63c678:	e1520001 	cmp	r2, r1
8f63c67c:	1afffff8 	bne	8f63c664 <find_block+0x34>
	item->next->prev = item->prev;
8f63c680:	e5902000 	ldr	r2, [r0]
8f63c684:	e5901004 	ldr	r1, [r0, #4]
8f63c688:	e5812000 	str	r2, [r1]
	item->prev->next = item->next;
8f63c68c:	e5821004 	str	r1, [r2, #4]
	item->prev = item->next = 0;
8f63c690:	e3a02000 	mov	r2, #0
8f63c694:	e5802000 	str	r2, [r0]
	item->prev = list->prev;
8f63c698:	e59e1028 	ldr	r1, [r14, #40]	; 0x28
			list_delete(&block->node);
			list_add_tail(&cache->lru_list, &block->node);
			cache->stats.hits++;
8f63c69c:	e59e200c 	ldr	r2, [r14, #12]
	item->next = list;
8f63c6a0:	e580c004 	str	r12, [r0, #4]
	item->prev = list->prev;
8f63c6a4:	e5801000 	str	r1, [r0]
8f63c6a8:	e2822001 	add	r2, r2, #1
	list->prev->next = item;
8f63c6ac:	e5810004 	str	r0, [r1, #4]
8f63c6b0:	e58e200c 	str	r2, [r14, #12]
			cache->stats.depth += depth;
8f63c6b4:	e59e2010 	ldr	r2, [r14, #16]
	list->prev = item;
8f63c6b8:	e58e0028 	str	r0, [r14, #40]	; 0x28
8f63c6bc:	e0823003 	add	r3, r2, r3
8f63c6c0:	e58e3010 	str	r3, [r14, #16]
			return block;
8f63c6c4:	ea000003 	b	8f63c6d8 <find_block+0xa8>
		}
	}

	cache->stats.misses++;
8f63c6c8:	e59e3014 	ldr	r3, [r14, #20]
	return NULL;
8f63c6cc:	e3a00000 	mov	r0, #0
	cache->stats.misses++;
8f63c6d0:	e2833001 	add	r3, r3, #1
8f63c6d4:	e58e3014 	str	r3, [r14, #20]
}
8f63c6d8:	e59f301c 	ldr	r3, [pc, #28]	; 8f63c6fc <find_block+0xcc>
8f63c6dc:	e5932000 	ldr	r2, [r3]
8f63c6e0:	e59d3004 	ldr	r3, [r13, #4]
8f63c6e4:	e0332002 	eors	r2, r3, r2
8f63c6e8:	e3a03000 	mov	r3, #0
8f63c6ec:	1a000001 	bne	8f63c6f8 <find_block+0xc8>
8f63c6f0:	e28dd00c 	add	r13, r13, #12
8f63c6f4:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f63c6f8:	ebffd930 	bl	8f632bc0 <__stack_chk_fail>
8f63c6fc:	8f74221c 	.word	0x8f74221c

8f63c700 <alloc_block.part.0>:

/* allocate a new block */
static struct bcache_block *alloc_block(struct bcache *cache)
8f63c700:	e92d40f0 	push	{r4, r5, r6, r7, r14}
		LTRACEF("found block %p on free list\n", block);
		return block;
	}

	/* walk the lru, looking for a free block */
	list_for_every_entry(&cache->lru_list, block, struct bcache_block, node) {
8f63c704:	e2806028 	add	r6, r0, #40	; 0x28
8f63c708:	e590402c 	ldr	r4, [r0, #44]	; 0x2c
static struct bcache_block *alloc_block(struct bcache *cache)
8f63c70c:	e24dd014 	sub	r13, r13, #20
8f63c710:	e59f30c8 	ldr	r3, [pc, #200]	; 8f63c7e0 <alloc_block.part.0+0xe0>
	list_for_every_entry(&cache->lru_list, block, struct bcache_block, node) {
8f63c714:	e1540006 	cmp	r4, r6
static struct bcache_block *alloc_block(struct bcache *cache)
8f63c718:	e5933000 	ldr	r3, [r3]
8f63c71c:	e58d300c 	str	r3, [r13, #12]
8f63c720:	e3a03000 	mov	r3, #0
	list_for_every_entry(&cache->lru_list, block, struct bcache_block, node) {
8f63c724:	0a000022 	beq	8f63c7b4 <alloc_block.part.0+0xb4>
8f63c728:	e1a07000 	mov	r7, r0
8f63c72c:	ea000002 	b	8f63c73c <alloc_block.part.0+0x3c>
8f63c730:	e5944004 	ldr	r4, [r4, #4]
8f63c734:	e1560004 	cmp	r6, r4
8f63c738:	0a00001d 	beq	8f63c7b4 <alloc_block.part.0+0xb4>
		LTRACEF("looking at %p, num %u\n", block, block->blocknum);
		if (block->ref_count == 0) {
8f63c73c:	e594500c 	ldr	r5, [r4, #12]
8f63c740:	e3550000 	cmp	r5, #0
8f63c744:	1afffff9 	bne	8f63c730 <alloc_block.part.0+0x30>
			if (block->is_dirty) {
8f63c748:	e5943010 	ldr	r3, [r4, #16]
8f63c74c:	e3530000 	cmp	r3, #0
8f63c750:	0a00000c 	beq	8f63c788 <alloc_block.part.0+0x88>
			(off_t)block->blocknum * cache->block_size,
8f63c754:	e5973004 	ldr	r3, [r7, #4]
	rc = bio_write(cache->dev, block->ptr,
8f63c758:	e5942008 	ldr	r2, [r4, #8]
8f63c75c:	e5941014 	ldr	r1, [r4, #20]
8f63c760:	e58d3000 	str	r3, [r13]
8f63c764:	e0832293 	umull	r2, r3, r3, r2
8f63c768:	e5970000 	ldr	r0, [r7]
8f63c76c:	ebffeae9 	bl	8f637318 <bio_write>
	if (rc < 0)
8f63c770:	e3500000 	cmp	r0, #0
8f63c774:	ba00000e 	blt	8f63c7b4 <alloc_block.part.0+0xb4>
	cache->stats.writes++;
8f63c778:	e597301c 	ldr	r3, [r7, #28]
	block->is_dirty = false;
8f63c77c:	e5845010 	str	r5, [r4, #16]
	cache->stats.writes++;
8f63c780:	e2833001 	add	r3, r3, #1
8f63c784:	e587301c 	str	r3, [r7, #28]
	item->next->prev = item->prev;
8f63c788:	e5943000 	ldr	r3, [r4]
8f63c78c:	e5942004 	ldr	r2, [r4, #4]
8f63c790:	e5823000 	str	r3, [r2]
	item->prev->next = item->next;
8f63c794:	e5832004 	str	r2, [r3, #4]
	item->prev = item->next = 0;
8f63c798:	e3a03000 	mov	r3, #0
8f63c79c:	e5843000 	str	r3, [r4]
	item->prev = list->prev;
8f63c7a0:	e5973028 	ldr	r3, [r7, #40]	; 0x28
8f63c7a4:	e8840048 	stm	r4, {r3, r6}
	list->prev->next = item;
8f63c7a8:	e5834004 	str	r4, [r3, #4]
	list->prev = item;
8f63c7ac:	e5874028 	str	r4, [r7, #40]	; 0x28
			}

			// add it to the tail of the lru
			list_delete(&block->node);
			list_add_tail(&cache->lru_list, &block->node);
			return block;
8f63c7b0:	ea000000 	b	8f63c7b8 <alloc_block.part.0+0xb8>
		}
	}

	return NULL;
8f63c7b4:	e3a04000 	mov	r4, #0
}
8f63c7b8:	e59f3020 	ldr	r3, [pc, #32]	; 8f63c7e0 <alloc_block.part.0+0xe0>
8f63c7bc:	e5932000 	ldr	r2, [r3]
8f63c7c0:	e59d300c 	ldr	r3, [r13, #12]
8f63c7c4:	e0332002 	eors	r2, r3, r2
8f63c7c8:	e3a03000 	mov	r3, #0
8f63c7cc:	1a000002 	bne	8f63c7dc <alloc_block.part.0+0xdc>
8f63c7d0:	e1a00004 	mov	r0, r4
8f63c7d4:	e28dd014 	add	r13, r13, #20
8f63c7d8:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
8f63c7dc:	ebffd8f7 	bl	8f632bc0 <__stack_chk_fail>
8f63c7e0:	8f74221c 	.word	0x8f74221c

8f63c7e4 <find_or_fill_block.part.0>:

static struct bcache_block *find_or_fill_block(struct bcache *cache, uint blocknum)
8f63c7e4:	e92d40f0 	push	{r4, r5, r6, r7, r14}
	block = list_remove_head_type(&cache->free_list, struct bcache_block, node);
8f63c7e8:	e2807020 	add	r7, r0, #32
	if(list->next != list) {
8f63c7ec:	e5904024 	ldr	r4, [r0, #36]	; 0x24
static struct bcache_block *find_or_fill_block(struct bcache *cache, uint blocknum)
8f63c7f0:	e24dd014 	sub	r13, r13, #20
8f63c7f4:	e59f30bc 	ldr	r3, [pc, #188]	; 8f63c8b8 <find_or_fill_block.part.0+0xd4>
8f63c7f8:	e1a05000 	mov	r5, r0
8f63c7fc:	e1570004 	cmp	r7, r4
8f63c800:	e1a06001 	mov	r6, r1
8f63c804:	e5933000 	ldr	r3, [r3]
8f63c808:	e58d300c 	str	r3, [r13, #12]
8f63c80c:	e3a03000 	mov	r3, #0
8f63c810:	0a000024 	beq	8f63c8a8 <find_or_fill_block.part.0+0xc4>
	item->next->prev = item->prev;
8f63c814:	e5943000 	ldr	r3, [r4]
8f63c818:	e5942004 	ldr	r2, [r4, #4]
8f63c81c:	e5823000 	str	r3, [r2]
	item->prev->next = item->next;
8f63c820:	e5832004 	str	r2, [r3, #4]
	item->prev = item->next = 0;
8f63c824:	e3a03000 	mov	r3, #0
8f63c828:	e5843000 	str	r3, [r4]
		block->ref_count = 0;
8f63c82c:	e584300c 	str	r3, [r4, #12]
	item->prev = list->prev;
8f63c830:	e1a03000 	mov	r3, r0
8f63c834:	e5b32028 	ldr	r2, [r3, #40]!	; 0x28
8f63c838:	e1c420f0 	strd	r2, [r4]
	list->prev->next = item;
8f63c83c:	e5824004 	str	r4, [r2, #4]
	list->prev = item;
8f63c840:	e5804028 	str	r4, [r0, #40]	; 0x28
		DEBUG_ASSERT(block);

		LTRACEF("wasn't allocated, new block %p\n", block);

		block->blocknum = blocknum;
		err = bio_read(cache->dev, block->ptr, (off_t)blocknum * cache->block_size, cache->block_size);
8f63c844:	e5952004 	ldr	r2, [r5, #4]
8f63c848:	e5941014 	ldr	r1, [r4, #20]
		block->blocknum = blocknum;
8f63c84c:	e5846008 	str	r6, [r4, #8]
		err = bio_read(cache->dev, block->ptr, (off_t)blocknum * cache->block_size, cache->block_size);
8f63c850:	e58d2000 	str	r2, [r13]
8f63c854:	e0832296 	umull	r2, r3, r6, r2
8f63c858:	e5950000 	ldr	r0, [r5]
8f63c85c:	ebffea55 	bl	8f6371b8 <bio_read>
		if (err < 0) {
8f63c860:	e3500000 	cmp	r0, #0
	item->prev = list->prev;
8f63c864:	b5953020 	ldrlt	r3, [r5, #32]
			/* free the block, return an error */
			list_add_tail(&cache->free_list, &block->node);
			return NULL;
		}

		cache->stats.reads++;
8f63c868:	a5953018 	ldrge	r3, [r5, #24]
8f63c86c:	b8840088 	stmlt	r4, {r3, r7}
8f63c870:	a2833001 	addge	r3, r3, #1
	list->prev->next = item;
8f63c874:	b5834004 	strlt	r4, [r3, #4]
8f63c878:	a5853018 	strge	r3, [r5, #24]
	}

	DEBUG_ASSERT(block->blocknum == blocknum);

	return block;
}
8f63c87c:	e59f3034 	ldr	r3, [pc, #52]	; 8f63c8b8 <find_or_fill_block.part.0+0xd4>
	list->prev = item;
8f63c880:	b5854020 	strlt	r4, [r5, #32]
			return NULL;
8f63c884:	b3a04000 	movlt	r4, #0
}
8f63c888:	e5932000 	ldr	r2, [r3]
8f63c88c:	e59d300c 	ldr	r3, [r13, #12]
8f63c890:	e0332002 	eors	r2, r3, r2
8f63c894:	e3a03000 	mov	r3, #0
8f63c898:	1a000005 	bne	8f63c8b4 <find_or_fill_block.part.0+0xd0>
8f63c89c:	e1a00004 	mov	r0, r4
8f63c8a0:	e28dd014 	add	r13, r13, #20
8f63c8a4:	e8bd80f0 	pop	{r4, r5, r6, r7, r15}
8f63c8a8:	ebffff94 	bl	8f63c700 <alloc_block.part.0>
8f63c8ac:	e1a04000 	mov	r4, r0
8f63c8b0:	eaffffe3 	b	8f63c844 <find_or_fill_block.part.0+0x60>
8f63c8b4:	ebffd8c1 	bl	8f632bc0 <__stack_chk_fail>
8f63c8b8:	8f74221c 	.word	0x8f74221c

8f63c8bc <bcache_create>:
{
8f63c8bc:	e59f30ec 	ldr	r3, [pc, #236]	; 8f63c9b0 <bcache_create+0xf4>
8f63c8c0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
8f63c8c4:	e1a05000 	mov	r5, r0
8f63c8c8:	e24dd00c 	sub	r13, r13, #12
	cache = malloc(sizeof(struct bcache));
8f63c8cc:	e3a00034 	mov	r0, #52	; 0x34
{
8f63c8d0:	e1a06002 	mov	r6, r2
8f63c8d4:	e5933000 	ldr	r3, [r3]
8f63c8d8:	e58d3004 	str	r3, [r13, #4]
8f63c8dc:	e3a03000 	mov	r3, #0
8f63c8e0:	e1a07001 	mov	r7, r1
	cache = malloc(sizeof(struct bcache));
8f63c8e4:	ebffddc4 	bl	8f633ffc <malloc>
	memset(&cache->stats, 0, sizeof(cache->stats));
8f63c8e8:	e3a02014 	mov	r2, #20
8f63c8ec:	e3a01000 	mov	r1, #0
	cache = malloc(sizeof(struct bcache));
8f63c8f0:	e1a04000 	mov	r4, r0
	cache->block_size = block_size;
8f63c8f4:	e88000a0 	stm	r0, {r5, r7}
	cache->count = block_count;
8f63c8f8:	e5806008 	str	r6, [r0, #8]
	memset(&cache->stats, 0, sizeof(cache->stats));
8f63c8fc:	e280000c 	add	r0, r0, #12
8f63c900:	ebffde6f 	bl	8f6342c4 <memset>
	list_initialize(&cache->lru_list);
8f63c904:	e2843028 	add	r3, r4, #40	; 0x28
	list->prev = list->next = list;
8f63c908:	e584302c 	str	r3, [r4, #44]	; 0x2c
	list_initialize(&cache->free_list);
8f63c90c:	e2848020 	add	r8, r4, #32
8f63c910:	e5843028 	str	r3, [r4, #40]	; 0x28
	cache->blocks = malloc(sizeof(struct bcache_block) * block_count);
8f63c914:	e3a03018 	mov	r3, #24
8f63c918:	e0000693 	mul	r0, r3, r6
8f63c91c:	e5848024 	str	r8, [r4, #36]	; 0x24
8f63c920:	e5848020 	str	r8, [r4, #32]
8f63c924:	ebffddb4 	bl	8f633ffc <malloc>
	for (i=0; i < block_count; i++) {
8f63c928:	e3560000 	cmp	r6, #0
	cache->blocks = malloc(sizeof(struct bcache_block) * block_count);
8f63c92c:	e5840030 	str	r0, [r4, #48]	; 0x30
	for (i=0; i < block_count; i++) {
8f63c930:	da000014 	ble	8f63c988 <bcache_create+0xcc>
8f63c934:	e3a05000 	mov	r5, #0
8f63c938:	e1a03000 	mov	r3, r0
		cache->blocks[i].ref_count = 0;
8f63c93c:	e1a09005 	mov	r9, r5
8f63c940:	e3a02018 	mov	r2, #24
		cache->blocks[i].ptr = malloc(block_size);
8f63c944:	e1a00007 	mov	r0, r7
8f63c948:	e00a0592 	mul	r10, r2, r5
	for (i=0; i < block_count; i++) {
8f63c94c:	e2855001 	add	r5, r5, #1
		cache->blocks[i].ref_count = 0;
8f63c950:	e083b00a 	add	r11, r3, r10
8f63c954:	e58b900c 	str	r9, [r11, #12]
		cache->blocks[i].is_dirty = false;
8f63c958:	e58b9010 	str	r9, [r11, #16]
		cache->blocks[i].ptr = malloc(block_size);
8f63c95c:	ebffdda6 	bl	8f633ffc <malloc>
		list_add_head(&cache->free_list, &cache->blocks[i].node);	
8f63c960:	e5943030 	ldr	r3, [r4, #48]	; 0x30
	item->next = list->next;
8f63c964:	e594c024 	ldr	r12, [r4, #36]	; 0x24
	for (i=0; i < block_count; i++) {
8f63c968:	e1560005 	cmp	r6, r5
		list_add_head(&cache->free_list, &cache->blocks[i].node);	
8f63c96c:	e083200a 	add	r2, r3, r10
		cache->blocks[i].ptr = malloc(block_size);
8f63c970:	e58b0014 	str	r0, [r11, #20]
8f63c974:	e582c004 	str	r12, [r2, #4]
	item->prev = list;
8f63c978:	e783800a 	str	r8, [r3, r10]
	list->next->prev = item;
8f63c97c:	e58c2000 	str	r2, [r12]
	list->next = item;
8f63c980:	e5842024 	str	r2, [r4, #36]	; 0x24
	for (i=0; i < block_count; i++) {
8f63c984:	1affffed 	bne	8f63c940 <bcache_create+0x84>
}
8f63c988:	e59f3020 	ldr	r3, [pc, #32]	; 8f63c9b0 <bcache_create+0xf4>
8f63c98c:	e5932000 	ldr	r2, [r3]
8f63c990:	e59d3004 	ldr	r3, [r13, #4]
8f63c994:	e0332002 	eors	r2, r3, r2
8f63c998:	e3a03000 	mov	r3, #0
8f63c99c:	1a000002 	bne	8f63c9ac <bcache_create+0xf0>
8f63c9a0:	e1a00004 	mov	r0, r4
8f63c9a4:	e28dd00c 	add	r13, r13, #12
8f63c9a8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}
8f63c9ac:	ebffd883 	bl	8f632bc0 <__stack_chk_fail>
8f63c9b0:	8f74221c 	.word	0x8f74221c

8f63c9b4 <bcache_destroy>:
{
8f63c9b4:	e59f30a8 	ldr	r3, [pc, #168]	; 8f63ca64 <bcache_destroy+0xb0>
8f63c9b8:	e92d40f0 	push	{r4, r5, r6, r7, r14}
8f63c9bc:	e24dd00c 	sub	r13, r13, #12
8f63c9c0:	e5933000 	ldr	r3, [r3]
8f63c9c4:	e58d3004 	str	r3, [r13, #4]
8f63c9c8:	e3a03000 	mov	r3, #0
	for (i=0; i < cache->count; i++) {
8f63c9cc:	e5903008 	ldr	r3, [r0, #8]
{
8f63c9d0:	e1a06000 	mov	r6, r0
	for (i=0; i < cache->count; i++) {
8f63c9d4:	e3530000 	cmp	r3, #0
8f63c9d8:	c3a04000 	movgt	r4, #0
			printf("warning: freeing dirty block %u\n",
8f63c9dc:	c30c7070 	movwgt	r7, #49264	; 0xc070
	for (i=0; i < cache->count; i++) {
8f63c9e0:	c1a05004 	movgt	r5, r4
			printf("warning: freeing dirty block %u\n",
8f63c9e4:	c3487f70 	movtgt	r7, #36720	; 0x8f70
	for (i=0; i < cache->count; i++) {
8f63c9e8:	ca000007 	bgt	8f63ca0c <bcache_destroy+0x58>
8f63c9ec:	ea000011 	b	8f63ca38 <bcache_destroy+0x84>
		free(cache->blocks[i].ptr);
8f63c9f0:	e5930014 	ldr	r0, [r3, #20]
	for (i=0; i < cache->count; i++) {
8f63c9f4:	e2855001 	add	r5, r5, #1
		free(cache->blocks[i].ptr);
8f63c9f8:	ebffddc3 	bl	8f63410c <free>
	for (i=0; i < cache->count; i++) {
8f63c9fc:	e5963008 	ldr	r3, [r6, #8]
8f63ca00:	e2844018 	add	r4, r4, #24
8f63ca04:	e1530005 	cmp	r3, r5
8f63ca08:	da00000a 	ble	8f63ca38 <bcache_destroy+0x84>
		if (cache->blocks[i].is_dirty)
8f63ca0c:	e5963030 	ldr	r3, [r6, #48]	; 0x30
8f63ca10:	e0833004 	add	r3, r3, r4
8f63ca14:	e5932010 	ldr	r2, [r3, #16]
8f63ca18:	e3520000 	cmp	r2, #0
8f63ca1c:	0afffff3 	beq	8f63c9f0 <bcache_destroy+0x3c>
			printf("warning: freeing dirty block %u\n",
8f63ca20:	e5931008 	ldr	r1, [r3, #8]
8f63ca24:	e1a00007 	mov	r0, r7
8f63ca28:	ebffdb71 	bl	8f6337f4 <printf>
		free(cache->blocks[i].ptr);
8f63ca2c:	e5963030 	ldr	r3, [r6, #48]	; 0x30
8f63ca30:	e0833004 	add	r3, r3, r4
8f63ca34:	eaffffed 	b	8f63c9f0 <bcache_destroy+0x3c>
	free(cache);
8f63ca38:	e59f3024 	ldr	r3, [pc, #36]	; 8f63ca64 <bcache_destroy+0xb0>
8f63ca3c:	e5932000 	ldr	r2, [r3]
8f63ca40:	e59d3004 	ldr	r3, [r13, #4]
8f63ca44:	e0332002 	eors	r2, r3, r2
8f63ca48:	e3a03000 	mov	r3, #0
8f63ca4c:	1a000003 	bne	8f63ca60 <bcache_destroy+0xac>
8f63ca50:	e1a00006 	mov	r0, r6
}
8f63ca54:	e28dd00c 	add	r13, r13, #12
8f63ca58:	e8bd40f0 	pop	{r4, r5, r6, r7, r14}
	free(cache);
8f63ca5c:	eaffddaa 	b	8f63410c <free>
8f63ca60:	ebffd856 	bl	8f632bc0 <__stack_chk_fail>
8f63ca64:	8f74221c 	.word	0x8f74221c

8f63ca68 <bcache_read_block>:

int bcache_read_block(bcache_t _cache, void *buf, uint blocknum)
{
8f63ca68:	e59f3080 	ldr	r3, [pc, #128]	; 8f63caf0 <bcache_read_block+0x88>
8f63ca6c:	e92d4070 	push	{r4, r5, r6, r14}
8f63ca70:	e1a06001 	mov	r6, r1
8f63ca74:	e24dd008 	sub	r13, r13, #8
	struct bcache_block *block = find_block(cache, blocknum);
8f63ca78:	e1a01002 	mov	r1, r2
{
8f63ca7c:	e5933000 	ldr	r3, [r3]
8f63ca80:	e58d3004 	str	r3, [r13, #4]
8f63ca84:	e3a03000 	mov	r3, #0
8f63ca88:	e1a04002 	mov	r4, r2
8f63ca8c:	e1a05000 	mov	r5, r0
	struct bcache_block *block = find_block(cache, blocknum);
8f63ca90:	ebfffee6 	bl	8f63c630 <find_block>
	if (block == NULL) {
8f63ca94:	e2503000 	subs	r3, r0, #0
8f63ca98:	0a00000c 	beq	8f63cad0 <bcache_read_block+0x68>
	if (block == NULL) {
		/* error */
		return -1;
	}

	memcpy(buf, block->ptr, cache->block_size);
8f63ca9c:	e5952004 	ldr	r2, [r5, #4]
8f63caa0:	e1a00006 	mov	r0, r6
8f63caa4:	e5931014 	ldr	r1, [r3, #20]
8f63caa8:	ebffddc2 	bl	8f6341b8 <memcpy>
	return 0;
8f63caac:	e3a00000 	mov	r0, #0
}
8f63cab0:	e59f3038 	ldr	r3, [pc, #56]	; 8f63caf0 <bcache_read_block+0x88>
8f63cab4:	e5932000 	ldr	r2, [r3]
8f63cab8:	e59d3004 	ldr	r3, [r13, #4]
8f63cabc:	e0332002 	eors	r2, r3, r2
8f63cac0:	e3a03000 	mov	r3, #0
8f63cac4:	1a000008 	bne	8f63caec <bcache_read_block+0x84>
8f63cac8:	e28dd008 	add	r13, r13, #8
8f63cacc:	e8bd8070 	pop	{r4, r5, r6, r15}
8f63cad0:	e1a01004 	mov	r1, r4
8f63cad4:	e1a00005 	mov	r0, r5
8f63cad8:	ebffff41 	bl	8f63c7e4 <find_or_fill_block.part.0>
	if (block == NULL) {
8f63cadc:	e2503000 	subs	r3, r0, #0
8f63cae0:	1affffed 	bne	8f63ca9c <bcache_read_block+0x34>
		return -1;
8f63cae4:	e3e00000 	mvn	r0, #0
8f63cae8:	eafffff0 	b	8f63cab0 <bcache_read_block+0x48>
}
8f63caec:	ebffd833 	bl	8f632bc0 <__stack_chk_fail>
8f63caf0:	8f74221c 	.word	0x8f74221c

8f63caf4 <bcache_get_block>:

int bcache_get_block(bcache_t _cache, void **ptr, uint blocknum)
{
8f63caf4:	e59f3084 	ldr	r3, [pc, #132]	; 8f63cb80 <bcache_get_block+0x8c>
8f63caf8:	e92d4070 	push	{r4, r5, r6, r14}
8f63cafc:	e1a06001 	mov	r6, r1
8f63cb00:	e24dd008 	sub	r13, r13, #8
	struct bcache_block *block = find_block(cache, blocknum);
8f63cb04:	e1a01002 	mov	r1, r2
{
8f63cb08:	e5933000 	ldr	r3, [r3]
8f63cb0c:	e58d3004 	str	r3, [r13, #4]
8f63cb10:	e3a03000 	mov	r3, #0
8f63cb14:	e1a04002 	mov	r4, r2
8f63cb18:	e1a05000 	mov	r5, r0
	struct bcache_block *block = find_block(cache, blocknum);
8f63cb1c:	ebfffec3 	bl	8f63c630 <find_block>
	if (block == NULL) {
8f63cb20:	e2503000 	subs	r3, r0, #0
8f63cb24:	0a00000d 	beq	8f63cb60 <bcache_get_block+0x6c>
		return -1;
	}

	/* increment the ref count to keep it from being freed */
	block->ref_count++;
	*ptr = block->ptr;
8f63cb28:	e5931014 	ldr	r1, [r3, #20]

	return 0;
8f63cb2c:	e3a00000 	mov	r0, #0
	block->ref_count++;
8f63cb30:	e593200c 	ldr	r2, [r3, #12]
8f63cb34:	e2822001 	add	r2, r2, #1
8f63cb38:	e583200c 	str	r2, [r3, #12]
	*ptr = block->ptr;
8f63cb3c:	e5861000 	str	r1, [r6]
}
8f63cb40:	e59f3038 	ldr	r3, [pc, #56]	; 8f63cb80 <bcache_get_block+0x8c>
8f63cb44:	e5932000 	ldr	r2, [r3]
8f63cb48:	e59d3004 	ldr	r3, [r13, #4]
8f63cb4c:	e0332002 	eors	r2, r3, r2
8f63cb50:	e3a03000 	mov	r3, #0
8f63cb54:	1a000008 	bne	8f63cb7c <bcache_get_block+0x88>
8f63cb58:	e28dd008 	add	r13, r13, #8
8f63cb5c:	e8bd8070 	pop	{r4, r5, r6, r15}
8f63cb60:	e1a01004 	mov	r1, r4
8f63cb64:	e1a00005 	mov	r0, r5
8f63cb68:	ebffff1d 	bl	8f63c7e4 <find_or_fill_block.part.0>
	if (block == NULL) {
8f63cb6c:	e2503000 	subs	r3, r0, #0
8f63cb70:	1affffec 	bne	8f63cb28 <bcache_get_block+0x34>
		return -1;
8f63cb74:	e3e00000 	mvn	r0, #0
8f63cb78:	eafffff0 	b	8f63cb40 <bcache_get_block+0x4c>
}
8f63cb7c:	ebffd80f 	bl	8f632bc0 <__stack_chk_fail>
8f63cb80:	8f74221c 	.word	0x8f74221c

8f63cb84 <bcache_put_block>:

int bcache_put_block(bcache_t _cache, uint blocknum)
{
8f63cb84:	e59f3048 	ldr	r3, [pc, #72]	; 8f63cbd4 <bcache_put_block+0x50>
8f63cb88:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
8f63cb8c:	e24dd00c 	sub	r13, r13, #12
8f63cb90:	e5933000 	ldr	r3, [r3]
8f63cb94:	e58d3004 	str	r3, [r13, #4]
8f63cb98:	e3a03000 	mov	r3, #0
	struct bcache *cache = _cache;

	LTRACEF("blocknum %u\n", blocknum);

	struct bcache_block *block = find_block(cache, blocknum);
8f63cb9c:	ebfffea3 	bl	8f63c630 <find_block>

	/* be pretty hard on the caller for now */
	DEBUG_ASSERT(block);
	DEBUG_ASSERT(block->ref_count > 0);

	block->ref_count--;
8f63cba0:	e590300c 	ldr	r3, [r0, #12]
8f63cba4:	e2433001 	sub	r3, r3, #1
8f63cba8:	e580300c 	str	r3, [r0, #12]

	return 0;
}
8f63cbac:	e59f3020 	ldr	r3, [pc, #32]	; 8f63cbd4 <bcache_put_block+0x50>
8f63cbb0:	e5932000 	ldr	r2, [r3]
8f63cbb4:	e59d3004 	ldr	r3, [r13, #4]
8f63cbb8:	e0332002 	eors	r2, r3, r2
8f63cbbc:	e3a03000 	mov	r3, #0
8f63cbc0:	1a000002 	bne	8f63cbd0 <bcache_put_block+0x4c>
8f63cbc4:	e3a00000 	mov	r0, #0
8f63cbc8:	e28dd00c 	add	r13, r13, #12
8f63cbcc:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
8f63cbd0:	ebffd7fa 	bl	8f632bc0 <__stack_chk_fail>
8f63cbd4:	8f74221c 	.word	0x8f74221c

8f63cbd8 <__udivsi3>:
8f63cbd8:	1e4a      	subs	r2, r1, #1
8f63cbda:	bf08      	it	eq
8f63cbdc:	4770      	bxeq	r14
8f63cbde:	f0c0 8124 	bcc.w	8f63ce2a <__udivsi3+0x252>
8f63cbe2:	4288      	cmp	r0, r1
8f63cbe4:	f240 8116 	bls.w	8f63ce14 <__udivsi3+0x23c>
8f63cbe8:	4211      	tst	r1, r2
8f63cbea:	f000 8117 	beq.w	8f63ce1c <__udivsi3+0x244>
8f63cbee:	fab0 f380 	clz	r3, r0
8f63cbf2:	fab1 f281 	clz	r2, r1
8f63cbf6:	eba2 0303 	sub.w	r3, r2, r3
8f63cbfa:	f1c3 031f 	rsb	r3, r3, #31
8f63cbfe:	a204      	add	r2, pc, #16	; (adr r2, 8f63cc10 <__udivsi3+0x38>)
8f63cc00:	eb02 1303 	add.w	r3, r2, r3, lsl #4
8f63cc04:	f04f 0200 	mov.w	r2, #0
8f63cc08:	469f      	mov	r15, r3
8f63cc0a:	bf00      	nop
8f63cc0c:	f3af 8000 	nop.w
8f63cc10:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
8f63cc14:	bf00      	nop
8f63cc16:	eb42 0202 	adc.w	r2, r2, r2
8f63cc1a:	bf28      	it	cs
8f63cc1c:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
8f63cc20:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
8f63cc24:	bf00      	nop
8f63cc26:	eb42 0202 	adc.w	r2, r2, r2
8f63cc2a:	bf28      	it	cs
8f63cc2c:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
8f63cc30:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
8f63cc34:	bf00      	nop
8f63cc36:	eb42 0202 	adc.w	r2, r2, r2
8f63cc3a:	bf28      	it	cs
8f63cc3c:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
8f63cc40:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
8f63cc44:	bf00      	nop
8f63cc46:	eb42 0202 	adc.w	r2, r2, r2
8f63cc4a:	bf28      	it	cs
8f63cc4c:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
8f63cc50:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
8f63cc54:	bf00      	nop
8f63cc56:	eb42 0202 	adc.w	r2, r2, r2
8f63cc5a:	bf28      	it	cs
8f63cc5c:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
8f63cc60:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
8f63cc64:	bf00      	nop
8f63cc66:	eb42 0202 	adc.w	r2, r2, r2
8f63cc6a:	bf28      	it	cs
8f63cc6c:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
8f63cc70:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
8f63cc74:	bf00      	nop
8f63cc76:	eb42 0202 	adc.w	r2, r2, r2
8f63cc7a:	bf28      	it	cs
8f63cc7c:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
8f63cc80:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
8f63cc84:	bf00      	nop
8f63cc86:	eb42 0202 	adc.w	r2, r2, r2
8f63cc8a:	bf28      	it	cs
8f63cc8c:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
8f63cc90:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
8f63cc94:	bf00      	nop
8f63cc96:	eb42 0202 	adc.w	r2, r2, r2
8f63cc9a:	bf28      	it	cs
8f63cc9c:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
8f63cca0:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
8f63cca4:	bf00      	nop
8f63cca6:	eb42 0202 	adc.w	r2, r2, r2
8f63ccaa:	bf28      	it	cs
8f63ccac:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
8f63ccb0:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
8f63ccb4:	bf00      	nop
8f63ccb6:	eb42 0202 	adc.w	r2, r2, r2
8f63ccba:	bf28      	it	cs
8f63ccbc:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
8f63ccc0:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
8f63ccc4:	bf00      	nop
8f63ccc6:	eb42 0202 	adc.w	r2, r2, r2
8f63ccca:	bf28      	it	cs
8f63cccc:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
8f63ccd0:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
8f63ccd4:	bf00      	nop
8f63ccd6:	eb42 0202 	adc.w	r2, r2, r2
8f63ccda:	bf28      	it	cs
8f63ccdc:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
8f63cce0:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
8f63cce4:	bf00      	nop
8f63cce6:	eb42 0202 	adc.w	r2, r2, r2
8f63ccea:	bf28      	it	cs
8f63ccec:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
8f63ccf0:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
8f63ccf4:	bf00      	nop
8f63ccf6:	eb42 0202 	adc.w	r2, r2, r2
8f63ccfa:	bf28      	it	cs
8f63ccfc:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
8f63cd00:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
8f63cd04:	bf00      	nop
8f63cd06:	eb42 0202 	adc.w	r2, r2, r2
8f63cd0a:	bf28      	it	cs
8f63cd0c:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
8f63cd10:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
8f63cd14:	bf00      	nop
8f63cd16:	eb42 0202 	adc.w	r2, r2, r2
8f63cd1a:	bf28      	it	cs
8f63cd1c:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
8f63cd20:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
8f63cd24:	bf00      	nop
8f63cd26:	eb42 0202 	adc.w	r2, r2, r2
8f63cd2a:	bf28      	it	cs
8f63cd2c:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
8f63cd30:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
8f63cd34:	bf00      	nop
8f63cd36:	eb42 0202 	adc.w	r2, r2, r2
8f63cd3a:	bf28      	it	cs
8f63cd3c:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
8f63cd40:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
8f63cd44:	bf00      	nop
8f63cd46:	eb42 0202 	adc.w	r2, r2, r2
8f63cd4a:	bf28      	it	cs
8f63cd4c:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
8f63cd50:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
8f63cd54:	bf00      	nop
8f63cd56:	eb42 0202 	adc.w	r2, r2, r2
8f63cd5a:	bf28      	it	cs
8f63cd5c:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
8f63cd60:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
8f63cd64:	bf00      	nop
8f63cd66:	eb42 0202 	adc.w	r2, r2, r2
8f63cd6a:	bf28      	it	cs
8f63cd6c:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
8f63cd70:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
8f63cd74:	bf00      	nop
8f63cd76:	eb42 0202 	adc.w	r2, r2, r2
8f63cd7a:	bf28      	it	cs
8f63cd7c:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
8f63cd80:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
8f63cd84:	bf00      	nop
8f63cd86:	eb42 0202 	adc.w	r2, r2, r2
8f63cd8a:	bf28      	it	cs
8f63cd8c:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
8f63cd90:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
8f63cd94:	bf00      	nop
8f63cd96:	eb42 0202 	adc.w	r2, r2, r2
8f63cd9a:	bf28      	it	cs
8f63cd9c:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
8f63cda0:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
8f63cda4:	bf00      	nop
8f63cda6:	eb42 0202 	adc.w	r2, r2, r2
8f63cdaa:	bf28      	it	cs
8f63cdac:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
8f63cdb0:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
8f63cdb4:	bf00      	nop
8f63cdb6:	eb42 0202 	adc.w	r2, r2, r2
8f63cdba:	bf28      	it	cs
8f63cdbc:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
8f63cdc0:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
8f63cdc4:	bf00      	nop
8f63cdc6:	eb42 0202 	adc.w	r2, r2, r2
8f63cdca:	bf28      	it	cs
8f63cdcc:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
8f63cdd0:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
8f63cdd4:	bf00      	nop
8f63cdd6:	eb42 0202 	adc.w	r2, r2, r2
8f63cdda:	bf28      	it	cs
8f63cddc:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
8f63cde0:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
8f63cde4:	bf00      	nop
8f63cde6:	eb42 0202 	adc.w	r2, r2, r2
8f63cdea:	bf28      	it	cs
8f63cdec:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
8f63cdf0:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
8f63cdf4:	bf00      	nop
8f63cdf6:	eb42 0202 	adc.w	r2, r2, r2
8f63cdfa:	bf28      	it	cs
8f63cdfc:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
8f63ce00:	ebb0 0f01 	cmp.w	r0, r1
8f63ce04:	bf00      	nop
8f63ce06:	eb42 0202 	adc.w	r2, r2, r2
8f63ce0a:	bf28      	it	cs
8f63ce0c:	eba0 0001 	subcs.w	r0, r0, r1
8f63ce10:	4610      	mov	r0, r2
8f63ce12:	4770      	bx	r14
8f63ce14:	bf0c      	ite	eq
8f63ce16:	2001      	moveq	r0, #1
8f63ce18:	2000      	movne	r0, #0
8f63ce1a:	4770      	bx	r14
8f63ce1c:	fab1 f281 	clz	r2, r1
8f63ce20:	f1c2 021f 	rsb	r2, r2, #31
8f63ce24:	fa20 f002 	lsr.w	r0, r0, r2
8f63ce28:	4770      	bx	r14
8f63ce2a:	b108      	cbz	r0, 8f63ce30 <__udivsi3+0x258>
8f63ce2c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
8f63ce30:	f000 b966 	b.w	8f63d100 <__aeabi_idiv0>

8f63ce34 <__aeabi_uidivmod>:
8f63ce34:	2900      	cmp	r1, #0
8f63ce36:	d0f8      	beq.n	8f63ce2a <__udivsi3+0x252>
8f63ce38:	e92d 4003 	stmdb	r13!, {r0, r1, r14}
8f63ce3c:	f7ff fecc 	bl	8f63cbd8 <__udivsi3>
8f63ce40:	e8bd 4006 	ldmia.w	r13!, {r1, r2, r14}
8f63ce44:	fb02 f300 	mul.w	r3, r2, r0
8f63ce48:	eba1 0103 	sub.w	r1, r1, r3
8f63ce4c:	4770      	bx	r14
8f63ce4e:	bf00      	nop

8f63ce50 <__divsi3>:
8f63ce50:	2900      	cmp	r1, #0
8f63ce52:	f000 813e 	beq.w	8f63d0d2 <.divsi3_skip_div0_test+0x27c>

8f63ce56 <.divsi3_skip_div0_test>:
8f63ce56:	ea80 0c01 	eor.w	r12, r0, r1
8f63ce5a:	bf48      	it	mi
8f63ce5c:	4249      	negmi	r1, r1
8f63ce5e:	1e4a      	subs	r2, r1, #1
8f63ce60:	f000 811f 	beq.w	8f63d0a2 <.divsi3_skip_div0_test+0x24c>
8f63ce64:	0003      	movs	r3, r0
8f63ce66:	bf48      	it	mi
8f63ce68:	4243      	negmi	r3, r0
8f63ce6a:	428b      	cmp	r3, r1
8f63ce6c:	f240 811e 	bls.w	8f63d0ac <.divsi3_skip_div0_test+0x256>
8f63ce70:	4211      	tst	r1, r2
8f63ce72:	f000 8123 	beq.w	8f63d0bc <.divsi3_skip_div0_test+0x266>
8f63ce76:	fab3 f283 	clz	r2, r3
8f63ce7a:	fab1 f081 	clz	r0, r1
8f63ce7e:	eba0 0202 	sub.w	r2, r0, r2
8f63ce82:	f1c2 021f 	rsb	r2, r2, #31
8f63ce86:	a004      	add	r0, pc, #16	; (adr r0, 8f63ce98 <.divsi3_skip_div0_test+0x42>)
8f63ce88:	eb00 1202 	add.w	r2, r0, r2, lsl #4
8f63ce8c:	f04f 0000 	mov.w	r0, #0
8f63ce90:	4697      	mov	r15, r2
8f63ce92:	bf00      	nop
8f63ce94:	f3af 8000 	nop.w
8f63ce98:	ebb3 7fc1 	cmp.w	r3, r1, lsl #31
8f63ce9c:	bf00      	nop
8f63ce9e:	eb40 0000 	adc.w	r0, r0, r0
8f63cea2:	bf28      	it	cs
8f63cea4:	eba3 73c1 	subcs.w	r3, r3, r1, lsl #31
8f63cea8:	ebb3 7f81 	cmp.w	r3, r1, lsl #30
8f63ceac:	bf00      	nop
8f63ceae:	eb40 0000 	adc.w	r0, r0, r0
8f63ceb2:	bf28      	it	cs
8f63ceb4:	eba3 7381 	subcs.w	r3, r3, r1, lsl #30
8f63ceb8:	ebb3 7f41 	cmp.w	r3, r1, lsl #29
8f63cebc:	bf00      	nop
8f63cebe:	eb40 0000 	adc.w	r0, r0, r0
8f63cec2:	bf28      	it	cs
8f63cec4:	eba3 7341 	subcs.w	r3, r3, r1, lsl #29
8f63cec8:	ebb3 7f01 	cmp.w	r3, r1, lsl #28
8f63cecc:	bf00      	nop
8f63cece:	eb40 0000 	adc.w	r0, r0, r0
8f63ced2:	bf28      	it	cs
8f63ced4:	eba3 7301 	subcs.w	r3, r3, r1, lsl #28
8f63ced8:	ebb3 6fc1 	cmp.w	r3, r1, lsl #27
8f63cedc:	bf00      	nop
8f63cede:	eb40 0000 	adc.w	r0, r0, r0
8f63cee2:	bf28      	it	cs
8f63cee4:	eba3 63c1 	subcs.w	r3, r3, r1, lsl #27
8f63cee8:	ebb3 6f81 	cmp.w	r3, r1, lsl #26
8f63ceec:	bf00      	nop
8f63ceee:	eb40 0000 	adc.w	r0, r0, r0
8f63cef2:	bf28      	it	cs
8f63cef4:	eba3 6381 	subcs.w	r3, r3, r1, lsl #26
8f63cef8:	ebb3 6f41 	cmp.w	r3, r1, lsl #25
8f63cefc:	bf00      	nop
8f63cefe:	eb40 0000 	adc.w	r0, r0, r0
8f63cf02:	bf28      	it	cs
8f63cf04:	eba3 6341 	subcs.w	r3, r3, r1, lsl #25
8f63cf08:	ebb3 6f01 	cmp.w	r3, r1, lsl #24
8f63cf0c:	bf00      	nop
8f63cf0e:	eb40 0000 	adc.w	r0, r0, r0
8f63cf12:	bf28      	it	cs
8f63cf14:	eba3 6301 	subcs.w	r3, r3, r1, lsl #24
8f63cf18:	ebb3 5fc1 	cmp.w	r3, r1, lsl #23
8f63cf1c:	bf00      	nop
8f63cf1e:	eb40 0000 	adc.w	r0, r0, r0
8f63cf22:	bf28      	it	cs
8f63cf24:	eba3 53c1 	subcs.w	r3, r3, r1, lsl #23
8f63cf28:	ebb3 5f81 	cmp.w	r3, r1, lsl #22
8f63cf2c:	bf00      	nop
8f63cf2e:	eb40 0000 	adc.w	r0, r0, r0
8f63cf32:	bf28      	it	cs
8f63cf34:	eba3 5381 	subcs.w	r3, r3, r1, lsl #22
8f63cf38:	ebb3 5f41 	cmp.w	r3, r1, lsl #21
8f63cf3c:	bf00      	nop
8f63cf3e:	eb40 0000 	adc.w	r0, r0, r0
8f63cf42:	bf28      	it	cs
8f63cf44:	eba3 5341 	subcs.w	r3, r3, r1, lsl #21
8f63cf48:	ebb3 5f01 	cmp.w	r3, r1, lsl #20
8f63cf4c:	bf00      	nop
8f63cf4e:	eb40 0000 	adc.w	r0, r0, r0
8f63cf52:	bf28      	it	cs
8f63cf54:	eba3 5301 	subcs.w	r3, r3, r1, lsl #20
8f63cf58:	ebb3 4fc1 	cmp.w	r3, r1, lsl #19
8f63cf5c:	bf00      	nop
8f63cf5e:	eb40 0000 	adc.w	r0, r0, r0
8f63cf62:	bf28      	it	cs
8f63cf64:	eba3 43c1 	subcs.w	r3, r3, r1, lsl #19
8f63cf68:	ebb3 4f81 	cmp.w	r3, r1, lsl #18
8f63cf6c:	bf00      	nop
8f63cf6e:	eb40 0000 	adc.w	r0, r0, r0
8f63cf72:	bf28      	it	cs
8f63cf74:	eba3 4381 	subcs.w	r3, r3, r1, lsl #18
8f63cf78:	ebb3 4f41 	cmp.w	r3, r1, lsl #17
8f63cf7c:	bf00      	nop
8f63cf7e:	eb40 0000 	adc.w	r0, r0, r0
8f63cf82:	bf28      	it	cs
8f63cf84:	eba3 4341 	subcs.w	r3, r3, r1, lsl #17
8f63cf88:	ebb3 4f01 	cmp.w	r3, r1, lsl #16
8f63cf8c:	bf00      	nop
8f63cf8e:	eb40 0000 	adc.w	r0, r0, r0
8f63cf92:	bf28      	it	cs
8f63cf94:	eba3 4301 	subcs.w	r3, r3, r1, lsl #16
8f63cf98:	ebb3 3fc1 	cmp.w	r3, r1, lsl #15
8f63cf9c:	bf00      	nop
8f63cf9e:	eb40 0000 	adc.w	r0, r0, r0
8f63cfa2:	bf28      	it	cs
8f63cfa4:	eba3 33c1 	subcs.w	r3, r3, r1, lsl #15
8f63cfa8:	ebb3 3f81 	cmp.w	r3, r1, lsl #14
8f63cfac:	bf00      	nop
8f63cfae:	eb40 0000 	adc.w	r0, r0, r0
8f63cfb2:	bf28      	it	cs
8f63cfb4:	eba3 3381 	subcs.w	r3, r3, r1, lsl #14
8f63cfb8:	ebb3 3f41 	cmp.w	r3, r1, lsl #13
8f63cfbc:	bf00      	nop
8f63cfbe:	eb40 0000 	adc.w	r0, r0, r0
8f63cfc2:	bf28      	it	cs
8f63cfc4:	eba3 3341 	subcs.w	r3, r3, r1, lsl #13
8f63cfc8:	ebb3 3f01 	cmp.w	r3, r1, lsl #12
8f63cfcc:	bf00      	nop
8f63cfce:	eb40 0000 	adc.w	r0, r0, r0
8f63cfd2:	bf28      	it	cs
8f63cfd4:	eba3 3301 	subcs.w	r3, r3, r1, lsl #12
8f63cfd8:	ebb3 2fc1 	cmp.w	r3, r1, lsl #11
8f63cfdc:	bf00      	nop
8f63cfde:	eb40 0000 	adc.w	r0, r0, r0
8f63cfe2:	bf28      	it	cs
8f63cfe4:	eba3 23c1 	subcs.w	r3, r3, r1, lsl #11
8f63cfe8:	ebb3 2f81 	cmp.w	r3, r1, lsl #10
8f63cfec:	bf00      	nop
8f63cfee:	eb40 0000 	adc.w	r0, r0, r0
8f63cff2:	bf28      	it	cs
8f63cff4:	eba3 2381 	subcs.w	r3, r3, r1, lsl #10
8f63cff8:	ebb3 2f41 	cmp.w	r3, r1, lsl #9
8f63cffc:	bf00      	nop
8f63cffe:	eb40 0000 	adc.w	r0, r0, r0
8f63d002:	bf28      	it	cs
8f63d004:	eba3 2341 	subcs.w	r3, r3, r1, lsl #9
8f63d008:	ebb3 2f01 	cmp.w	r3, r1, lsl #8
8f63d00c:	bf00      	nop
8f63d00e:	eb40 0000 	adc.w	r0, r0, r0
8f63d012:	bf28      	it	cs
8f63d014:	eba3 2301 	subcs.w	r3, r3, r1, lsl #8
8f63d018:	ebb3 1fc1 	cmp.w	r3, r1, lsl #7
8f63d01c:	bf00      	nop
8f63d01e:	eb40 0000 	adc.w	r0, r0, r0
8f63d022:	bf28      	it	cs
8f63d024:	eba3 13c1 	subcs.w	r3, r3, r1, lsl #7
8f63d028:	ebb3 1f81 	cmp.w	r3, r1, lsl #6
8f63d02c:	bf00      	nop
8f63d02e:	eb40 0000 	adc.w	r0, r0, r0
8f63d032:	bf28      	it	cs
8f63d034:	eba3 1381 	subcs.w	r3, r3, r1, lsl #6
8f63d038:	ebb3 1f41 	cmp.w	r3, r1, lsl #5
8f63d03c:	bf00      	nop
8f63d03e:	eb40 0000 	adc.w	r0, r0, r0
8f63d042:	bf28      	it	cs
8f63d044:	eba3 1341 	subcs.w	r3, r3, r1, lsl #5
8f63d048:	ebb3 1f01 	cmp.w	r3, r1, lsl #4
8f63d04c:	bf00      	nop
8f63d04e:	eb40 0000 	adc.w	r0, r0, r0
8f63d052:	bf28      	it	cs
8f63d054:	eba3 1301 	subcs.w	r3, r3, r1, lsl #4
8f63d058:	ebb3 0fc1 	cmp.w	r3, r1, lsl #3
8f63d05c:	bf00      	nop
8f63d05e:	eb40 0000 	adc.w	r0, r0, r0
8f63d062:	bf28      	it	cs
8f63d064:	eba3 03c1 	subcs.w	r3, r3, r1, lsl #3
8f63d068:	ebb3 0f81 	cmp.w	r3, r1, lsl #2
8f63d06c:	bf00      	nop
8f63d06e:	eb40 0000 	adc.w	r0, r0, r0
8f63d072:	bf28      	it	cs
8f63d074:	eba3 0381 	subcs.w	r3, r3, r1, lsl #2
8f63d078:	ebb3 0f41 	cmp.w	r3, r1, lsl #1
8f63d07c:	bf00      	nop
8f63d07e:	eb40 0000 	adc.w	r0, r0, r0
8f63d082:	bf28      	it	cs
8f63d084:	eba3 0341 	subcs.w	r3, r3, r1, lsl #1
8f63d088:	ebb3 0f01 	cmp.w	r3, r1
8f63d08c:	bf00      	nop
8f63d08e:	eb40 0000 	adc.w	r0, r0, r0
8f63d092:	bf28      	it	cs
8f63d094:	eba3 0301 	subcs.w	r3, r3, r1
8f63d098:	f1bc 0f00 	cmp.w	r12, #0
8f63d09c:	bf48      	it	mi
8f63d09e:	4240      	negmi	r0, r0
8f63d0a0:	4770      	bx	r14
8f63d0a2:	ea9c 0f00 	teq	r12, r0
8f63d0a6:	bf48      	it	mi
8f63d0a8:	4240      	negmi	r0, r0
8f63d0aa:	4770      	bx	r14
8f63d0ac:	bf38      	it	cc
8f63d0ae:	2000      	movcc	r0, #0
8f63d0b0:	bf04      	itt	eq
8f63d0b2:	ea4f 70ec 	moveq.w	r0, r12, asr #31
8f63d0b6:	f040 0001 	orreq.w	r0, r0, #1
8f63d0ba:	4770      	bx	r14
8f63d0bc:	fab1 f281 	clz	r2, r1
8f63d0c0:	f1c2 021f 	rsb	r2, r2, #31
8f63d0c4:	f1bc 0f00 	cmp.w	r12, #0
8f63d0c8:	fa23 f002 	lsr.w	r0, r3, r2
8f63d0cc:	bf48      	it	mi
8f63d0ce:	4240      	negmi	r0, r0
8f63d0d0:	4770      	bx	r14
8f63d0d2:	2800      	cmp	r0, #0
8f63d0d4:	bfc8      	it	gt
8f63d0d6:	f06f 4000 	mvngt.w	r0, #2147483648	; 0x80000000
8f63d0da:	bfb8      	it	lt
8f63d0dc:	f04f 4000 	movlt.w	r0, #2147483648	; 0x80000000
8f63d0e0:	f000 b80e 	b.w	8f63d100 <__aeabi_idiv0>

8f63d0e4 <__aeabi_idivmod>:
8f63d0e4:	2900      	cmp	r1, #0
8f63d0e6:	d0f4      	beq.n	8f63d0d2 <.divsi3_skip_div0_test+0x27c>
8f63d0e8:	e92d 4003 	stmdb	r13!, {r0, r1, r14}
8f63d0ec:	f7ff feb3 	bl	8f63ce56 <.divsi3_skip_div0_test>
8f63d0f0:	e8bd 4006 	ldmia.w	r13!, {r1, r2, r14}
8f63d0f4:	fb02 f300 	mul.w	r3, r2, r0
8f63d0f8:	eba1 0103 	sub.w	r1, r1, r3
8f63d0fc:	4770      	bx	r14
8f63d0fe:	bf00      	nop

8f63d100 <__aeabi_idiv0>:
8f63d100:	4770      	bx	r14
8f63d102:	bf00      	nop

8f63d104 <__aeabi_ldivmod>:
8f63d104:	b97b      	cbnz	r3, 8f63d126 <__aeabi_ldivmod+0x22>
8f63d106:	b972      	cbnz	r2, 8f63d126 <__aeabi_ldivmod+0x22>
8f63d108:	2900      	cmp	r1, #0
8f63d10a:	bfbe      	ittt	lt
8f63d10c:	2000      	movlt	r0, #0
8f63d10e:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
8f63d112:	e006      	blt.n	8f63d122 <__aeabi_ldivmod+0x1e>
8f63d114:	bf08      	it	eq
8f63d116:	2800      	cmpeq	r0, #0
8f63d118:	bf1c      	itt	ne
8f63d11a:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
8f63d11e:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
8f63d122:	f7ff bfed 	b.w	8f63d100 <__aeabi_idiv0>
8f63d126:	f1ad 0c08 	sub.w	r12, r13, #8
8f63d12a:	e96d ce04 	strd	r12, r14, [r13, #-16]!
8f63d12e:	2900      	cmp	r1, #0
8f63d130:	db09      	blt.n	8f63d146 <__aeabi_ldivmod+0x42>
8f63d132:	2b00      	cmp	r3, #0
8f63d134:	db1a      	blt.n	8f63d16c <__aeabi_ldivmod+0x68>
8f63d136:	f000 f84d 	bl	8f63d1d4 <__udivmoddi4>
8f63d13a:	f8dd e004 	ldr.w	r14, [r13, #4]
8f63d13e:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
8f63d142:	b004      	add	sp, #16
8f63d144:	4770      	bx	r14
8f63d146:	4240      	negs	r0, r0
8f63d148:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
8f63d14c:	2b00      	cmp	r3, #0
8f63d14e:	db1b      	blt.n	8f63d188 <__aeabi_ldivmod+0x84>
8f63d150:	f000 f840 	bl	8f63d1d4 <__udivmoddi4>
8f63d154:	f8dd e004 	ldr.w	r14, [r13, #4]
8f63d158:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
8f63d15c:	b004      	add	sp, #16
8f63d15e:	4240      	negs	r0, r0
8f63d160:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
8f63d164:	4252      	negs	r2, r2
8f63d166:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
8f63d16a:	4770      	bx	r14
8f63d16c:	4252      	negs	r2, r2
8f63d16e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
8f63d172:	f000 f82f 	bl	8f63d1d4 <__udivmoddi4>
8f63d176:	f8dd e004 	ldr.w	r14, [r13, #4]
8f63d17a:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
8f63d17e:	b004      	add	sp, #16
8f63d180:	4240      	negs	r0, r0
8f63d182:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
8f63d186:	4770      	bx	r14
8f63d188:	4252      	negs	r2, r2
8f63d18a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
8f63d18e:	f000 f821 	bl	8f63d1d4 <__udivmoddi4>
8f63d192:	f8dd e004 	ldr.w	r14, [r13, #4]
8f63d196:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
8f63d19a:	b004      	add	sp, #16
8f63d19c:	4252      	negs	r2, r2
8f63d19e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
8f63d1a2:	4770      	bx	r14

8f63d1a4 <__aeabi_uldivmod>:
8f63d1a4:	b953      	cbnz	r3, 8f63d1bc <__aeabi_uldivmod+0x18>
8f63d1a6:	b94a      	cbnz	r2, 8f63d1bc <__aeabi_uldivmod+0x18>
8f63d1a8:	2900      	cmp	r1, #0
8f63d1aa:	bf08      	it	eq
8f63d1ac:	2800      	cmpeq	r0, #0
8f63d1ae:	bf1c      	itt	ne
8f63d1b0:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
8f63d1b4:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
8f63d1b8:	f7ff bfa2 	b.w	8f63d100 <__aeabi_idiv0>
8f63d1bc:	f1ad 0c08 	sub.w	r12, r13, #8
8f63d1c0:	e96d ce04 	strd	r12, r14, [r13, #-16]!
8f63d1c4:	f000 f806 	bl	8f63d1d4 <__udivmoddi4>
8f63d1c8:	f8dd e004 	ldr.w	r14, [r13, #4]
8f63d1cc:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
8f63d1d0:	b004      	add	sp, #16
8f63d1d2:	4770      	bx	r14

8f63d1d4 <__udivmoddi4>:
8f63d1d4:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
8f63d1d8:	4290      	cmp	r0, r2
8f63d1da:	460d      	mov	r5, r1
8f63d1dc:	eb75 0103 	sbcs.w	r1, r5, r3
8f63d1e0:	4604      	mov	r4, r0
8f63d1e2:	9f07      	ldr	r7, [sp, #28]
8f63d1e4:	bf3c      	itt	cc
8f63d1e6:	2000      	movcc	r0, #0
8f63d1e8:	4601      	movcc	r1, r0
8f63d1ea:	d366      	bcc.n	8f63d2ba <__udivmoddi4+0xe6>
8f63d1ec:	fab3 f083 	clz	r0, r3
8f63d1f0:	2b00      	cmp	r3, #0
8f63d1f2:	d06b      	beq.n	8f63d2cc <__udivmoddi4+0xf8>
8f63d1f4:	fab5 f185 	clz	r1, r5
8f63d1f8:	2d00      	cmp	r5, #0
8f63d1fa:	d063      	beq.n	8f63d2c4 <__udivmoddi4+0xf0>
8f63d1fc:	1a46      	subs	r6, r0, r1
8f63d1fe:	f1a6 0c20 	sub.w	r12, r6, #32
8f63d202:	f1c6 0e20 	rsb	r14, r6, #32
8f63d206:	40b3      	lsls	r3, r6
8f63d208:	fa02 f10c 	lsl.w	r1, r2, r12
8f63d20c:	fa02 f806 	lsl.w	r8, r2, r6
8f63d210:	430b      	orrs	r3, r1
8f63d212:	fa22 f20e 	lsr.w	r2, r2, r14
8f63d216:	4544      	cmp	r4, r8
8f63d218:	ea43 0302 	orr.w	r3, r3, r2
8f63d21c:	eb75 0203 	sbcs.w	r2, r5, r3
8f63d220:	bf3c      	itt	cc
8f63d222:	2000      	movcc	r0, #0
8f63d224:	4601      	movcc	r1, r0
8f63d226:	d30a      	bcc.n	8f63d23e <__udivmoddi4+0x6a>
8f63d228:	2001      	movs	r0, #1
8f63d22a:	ebb4 0408 	subs.w	r4, r4, r8
8f63d22e:	fa00 f10c 	lsl.w	r1, r0, r12
8f63d232:	eb65 0503 	sbc.w	r5, r5, r3
8f63d236:	fa20 f20e 	lsr.w	r2, r0, r14
8f63d23a:	4311      	orrs	r1, r2
8f63d23c:	40b0      	lsls	r0, r6
8f63d23e:	b3e6      	cbz	r6, 8f63d2ba <__udivmoddi4+0xe6>
8f63d240:	ea4f 0258 	mov.w	r2, r8, lsr #1
8f63d244:	46b0      	mov	r8, r6
8f63d246:	ea42 72c3 	orr.w	r2, r2, r3, lsl #31
8f63d24a:	085b      	lsrs	r3, r3, #1
8f63d24c:	e00a      	b.n	8f63d264 <__udivmoddi4+0x90>
8f63d24e:	1aa4      	subs	r4, r4, r2
8f63d250:	eb65 0503 	sbc.w	r5, r5, r3
8f63d254:	1924      	adds	r4, r4, r4
8f63d256:	416d      	adcs	r5, r5
8f63d258:	3401      	adds	r4, #1
8f63d25a:	f145 0500 	adc.w	r5, r5, #0
8f63d25e:	f1b8 0801 	subs.w	r8, r8, #1
8f63d262:	d008      	beq.n	8f63d276 <__udivmoddi4+0xa2>
8f63d264:	4294      	cmp	r4, r2
8f63d266:	eb75 0903 	sbcs.w	r9, r5, r3
8f63d26a:	d2f0      	bcs.n	8f63d24e <__udivmoddi4+0x7a>
8f63d26c:	1924      	adds	r4, r4, r4
8f63d26e:	416d      	adcs	r5, r5
8f63d270:	f1b8 0801 	subs.w	r8, r8, #1
8f63d274:	d1f6      	bne.n	8f63d264 <__udivmoddi4+0x90>
8f63d276:	eb10 0804 	adds.w	r8, r0, r4
8f63d27a:	fa05 fe0e 	lsl.w	r14, r5, r14
8f63d27e:	fa24 f406 	lsr.w	r4, r4, r6
8f63d282:	eb41 0105 	adc.w	r1, r1, r5
8f63d286:	fa25 fc0c 	lsr.w	r12, r5, r12
8f63d28a:	ea44 040e 	orr.w	r4, r4, r14
8f63d28e:	ea44 040c 	orr.w	r4, r4, r12
8f63d292:	40f5      	lsrs	r5, r6
8f63d294:	f1a6 0c20 	sub.w	r12, r6, #32
8f63d298:	f1c6 0220 	rsb	r2, r6, #32
8f63d29c:	fa05 f306 	lsl.w	r3, r5, r6
8f63d2a0:	fa04 fc0c 	lsl.w	r12, r4, r12
8f63d2a4:	fa24 f202 	lsr.w	r2, r4, r2
8f63d2a8:	ea43 030c 	orr.w	r3, r3, r12
8f63d2ac:	fa04 f006 	lsl.w	r0, r4, r6
8f63d2b0:	4313      	orrs	r3, r2
8f63d2b2:	ebb8 0000 	subs.w	r0, r8, r0
8f63d2b6:	eb61 0103 	sbc.w	r1, r1, r3
8f63d2ba:	b10f      	cbz	r7, 8f63d2c0 <__udivmoddi4+0xec>
8f63d2bc:	e9c7 4500 	strd	r4, r5, [r7]
8f63d2c0:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
8f63d2c4:	fab4 f184 	clz	r1, r4
8f63d2c8:	3120      	adds	r1, #32
8f63d2ca:	e797      	b.n	8f63d1fc <__udivmoddi4+0x28>
8f63d2cc:	fab2 f082 	clz	r0, r2
8f63d2d0:	fab5 f185 	clz	r1, r5
8f63d2d4:	3020      	adds	r0, #32
8f63d2d6:	2d00      	cmp	r5, #0
8f63d2d8:	d190      	bne.n	8f63d1fc <__udivmoddi4+0x28>
8f63d2da:	e7f3      	b.n	8f63d2c4 <__udivmoddi4+0xf0>
